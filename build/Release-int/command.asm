; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\CriuS\Documents\Visual Studio 2008\Projects\DRAMsimIIhg\src\command.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4Command@DRAMsimII@@6B@			; DRAMsimII::Command::`RTTI Complete Object Locator'
PUBLIC	??_R3Command@DRAMsimII@@8			; DRAMsimII::Command::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Command@DRAMsimII@@8			; DRAMsimII::Command::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Command@DRAMsimII@@8		; DRAMsimII::Command::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCommand@DRAMsimII@@@8			; DRAMsimII::Command `RTTI Type Descriptor'
PUBLIC	??0Event@DRAMsimII@@IAE@XZ			; DRAMsimII::Event::Event
PUBLIC	??0Event@DRAMsimII@@IAE@ABV01@@Z		; DRAMsimII::Event::Event
PUBLIC	??0Event@DRAMsimII@@IAE@ABVAddress@1@_J@Z	; DRAMsimII::Event::Event
PUBLIC	?getType@Transaction@DRAMsimII@@QBE?AW4TransactionType@12@XZ ; DRAMsimII::Transaction::getType
PUBLIC	??_GCommand@DRAMsimII@@UAEPAXI@Z		; DRAMsimII::Command::`scalar deleting destructor'
PUBLIC	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
PUBLIC	?releaseItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEXPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::releaseItem
PUBLIC	??8Event@DRAMsimII@@QBE_NABV01@@Z		; DRAMsimII::Event::operator==
PUBLIC	??_C@_0CE@DNBMIKHG@Unknown?5transaction?5type?0?5quitti@ ; `string'
PUBLIC	??_C@_04KDNIBPFK@RAS?5?$AA@			; `string'
PUBLIC	??_C@_04POFIKBGI@CAS?5?$AA@			; `string'
PUBLIC	??_C@_06CCMMABJK@CAS?$CLP?5?$AA@		; `string'
PUBLIC	??_C@_05IHKNOLLM@CASW?5?$AA@			; `string'
PUBLIC	??_C@_07FBJBNAPK@CASW?$CLP?5?$AA@		; `string'
PUBLIC	??_C@_07NLMAFCIK@RETIRE?5?$AA@			; `string'
PUBLIC	??_C@_05ELPCHFDE@PREC?5?$AA@			; `string'
PUBLIC	??_C@_07EMMFEOCJ@PREC_A?5?$AA@			; `string'
PUBLIC	??_C@_06BKNMGIGM@RAS_A?5?$AA@			; `string'
PUBLIC	??_C@_06MLMBNJNI@DRIVE?5?$AA@			; `string'
PUBLIC	??_C@_05BPNEDMHP@DATA?5?$AA@			; `string'
PUBLIC	??_C@_06DJODAKDG@CAS?$CLD?5?$AA@		; `string'
PUBLIC	??_C@_06FDAECDFF@REF?5?5?5?$AA@			; `string'
PUBLIC	??_C@_06DEOJNLN@SELREF?$AA@			; `string'
PUBLIC	??_C@_06IPDIBDGD@DESLCT?$AA@			; `string'
PUBLIC	??_C@_06DEMODEGE@NOOP?5?5?$AA@			; `string'
PUBLIC	??_C@_06PPDMIAKB@INVALD?$AA@			; `string'
PUBLIC	??_7Command@DRAMsimII@@6B@			; DRAMsimII::Command::`vftable'
EXTRN	??_ECommand@DRAMsimII@@UAEPAXI@Z:PROC		; DRAMsimII::Command::`vector deleting destructor'
;	COMDAT ??_7Command@DRAMsimII@@6B@
CONST	SEGMENT
??_7Command@DRAMsimII@@6B@ DD FLAT:??_R4Command@DRAMsimII@@6B@ ; DRAMsimII::Command::`vftable'
	DD	FLAT:??_ECommand@DRAMsimII@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4Command@DRAMsimII@@6B@
rdata$r	SEGMENT
??_R4Command@DRAMsimII@@6B@ DD 00H			; DRAMsimII::Command::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCommand@DRAMsimII@@@8
	DD	FLAT:??_R3Command@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R3Command@DRAMsimII@@8
rdata$r	SEGMENT
??_R3Command@DRAMsimII@@8 DD 00H			; DRAMsimII::Command::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Command@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R2Command@DRAMsimII@@8
rdata$r	SEGMENT
??_R2Command@DRAMsimII@@8 DD FLAT:??_R1A@?0A@EA@Command@DRAMsimII@@8 ; DRAMsimII::Command::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Event@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Command@DRAMsimII@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Command@DRAMsimII@@8 DD FLAT:??_R0?AVCommand@DRAMsimII@@@8 ; DRAMsimII::Command::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Command@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCommand@DRAMsimII@@@8
_DATA	SEGMENT
??_R0?AVCommand@DRAMsimII@@@8 DD FLAT:??_7type_info@@6B@ ; DRAMsimII::Command `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCommand@DRAMsimII@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_06PPDMIAKB@INVALD?$AA@
CONST	SEGMENT
??_C@_06PPDMIAKB@INVALD?$AA@ DB 'INVALD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DEMODEGE@NOOP?5?5?$AA@
CONST	SEGMENT
??_C@_06DEMODEGE@NOOP?5?5?$AA@ DB 'NOOP  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IPDIBDGD@DESLCT?$AA@
CONST	SEGMENT
??_C@_06IPDIBDGD@DESLCT?$AA@ DB 'DESLCT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DEOJNLN@SELREF?$AA@
CONST	SEGMENT
??_C@_06DEOJNLN@SELREF?$AA@ DB 'SELREF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDAECDFF@REF?5?5?5?$AA@
CONST	SEGMENT
??_C@_06FDAECDFF@REF?5?5?5?$AA@ DB 'REF   ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DJODAKDG@CAS?$CLD?5?$AA@
CONST	SEGMENT
??_C@_06DJODAKDG@CAS?$CLD?5?$AA@ DB 'CAS+D ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05BPNEDMHP@DATA?5?$AA@
CONST	SEGMENT
??_C@_05BPNEDMHP@DATA?5?$AA@ DB 'DATA ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MLMBNJNI@DRIVE?5?$AA@
CONST	SEGMENT
??_C@_06MLMBNJNI@DRIVE?5?$AA@ DB 'DRIVE ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BKNMGIGM@RAS_A?5?$AA@
CONST	SEGMENT
??_C@_06BKNMGIGM@RAS_A?5?$AA@ DB 'RAS_A ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EMMFEOCJ@PREC_A?5?$AA@
CONST	SEGMENT
??_C@_07EMMFEOCJ@PREC_A?5?$AA@ DB 'PREC_A ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05ELPCHFDE@PREC?5?$AA@
CONST	SEGMENT
??_C@_05ELPCHFDE@PREC?5?$AA@ DB 'PREC ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NLMAFCIK@RETIRE?5?$AA@
CONST	SEGMENT
??_C@_07NLMAFCIK@RETIRE?5?$AA@ DB 'RETIRE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FBJBNAPK@CASW?$CLP?5?$AA@
CONST	SEGMENT
??_C@_07FBJBNAPK@CASW?$CLP?5?$AA@ DB 'CASW+P ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IHKNOLLM@CASW?5?$AA@
CONST	SEGMENT
??_C@_05IHKNOLLM@CASW?5?$AA@ DB 'CASW ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CCMMABJK@CAS?$CLP?5?$AA@
CONST	SEGMENT
??_C@_06CCMMABJK@CAS?$CLP?5?$AA@ DB 'CAS+P ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04POFIKBGI@CAS?5?$AA@
CONST	SEGMENT
??_C@_04POFIKBGI@CAS?5?$AA@ DB 'CAS ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KDNIBPFK@RAS?5?$AA@
CONST	SEGMENT
??_C@_04KDNIBPFK@RAS?5?$AA@ DB 'RAS ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DNBMIKHG@Unknown?5transaction?5type?0?5quitti@
CONST	SEGMENT
??_C@_0CE@DNBMIKHG@Unknown?5transaction?5type?0?5quitti@ DB 'Unknown tran'
	DB	'saction type, quitting.', 00H		; `string'
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
PUBLIC	??4Command@DRAMsimII@@IAEAAV01@ABV01@@Z		; DRAMsimII::Command::operator=
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\command.cpp
_TEXT	SEGMENT
??4Command@DRAMsimII@@IAEAAV01@ABV01@@Z PROC		; DRAMsimII::Command::operator=
; _this$ = eax
; _rhs$ = ecx

; 239  : 	if (this == &rhs)

	cmp	eax, ecx

; 240  : 	{
; 241  : 		return *this;

	je	SHORT $LN2@operator@24

; 242  : 	}
; 243  : 	length = rhs.length;

	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+88], edx

; 244  : 	hostTransaction = rhs.hostTransaction;

	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+84], edx

; 245  : 	commandType = rhs.commandType;

	mov	ecx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+80], ecx
$LN2@operator@24:

; 246  : 	return *this;
; 247  : }

	ret	0
??4Command@DRAMsimII@@IAEAAV01@ABV01@@Z ENDP		; DRAMsimII::Command::operator=
_TEXT	ENDS
PUBLIC	?setAutoPrecharge@Command@DRAMsimII@@QBEX_N@Z	; DRAMsimII::Command::setAutoPrecharge
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_autoPrecharge$ = 8					; size = 1
?setAutoPrecharge@Command@DRAMsimII@@QBEX_N@Z PROC	; DRAMsimII::Command::setAutoPrecharge
; _this$ = edx

; 164  : 	switch (commandType)

	mov	eax, DWORD PTR [edx+80]
	lea	ecx, DWORD PTR [eax-1]
	push	ebx
	mov	bl, BYTE PTR _autoPrecharge$[esp]
	cmp	ecx, 3
	ja	SHORT $LN2@setAutoPre
	jmp	DWORD PTR $LN11@setAutoPre[ecx*4]
$LN5@setAutoPre:

; 165  : 	{
; 166  : 	case READ_AND_PRECHARGE:
; 167  : 	case WRITE_AND_PRECHARGE:
; 168  : 		if (!autoPrecharge)

	test	bl, bl
	jne	SHORT $LN2@setAutoPre

; 169  : 			commandType = (commandType == WRITE_AND_PRECHARGE) ? WRITE : READ;

	xor	ecx, ecx
	cmp	eax, 4
	sete	cl
	pop	ebx
	lea	ecx, DWORD PTR [ecx+ecx+1]

; 174  : 			commandType = (commandType == WRITE) ? WRITE_AND_PRECHARGE : READ_AND_PRECHARGE;

	mov	DWORD PTR [edx+80], ecx

; 175  : 		break;
; 176  : 	default:
; 177  : 		break;
; 178  : 	}
; 179  : 
; 180  : 	assert(isReadOrWrite() && hostTransaction);
; 181  : 
; 182  : 	assert((isWrite() && hostTransaction->isWrite()) ||
; 183  : 		(isRead() && hostTransaction->isRead()));
; 184  : }

	ret	4
$LN3@setAutoPre:

; 170  : 		break;
; 171  : 	case READ:
; 172  : 	case WRITE:
; 173  : 		if (autoPrecharge)

	test	bl, bl
	je	SHORT $LN2@setAutoPre

; 174  : 			commandType = (commandType == WRITE) ? WRITE_AND_PRECHARGE : READ_AND_PRECHARGE;

	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	lea	ecx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR [edx+80], ecx
$LN2@setAutoPre:
	pop	ebx

; 175  : 		break;
; 176  : 	default:
; 177  : 		break;
; 178  : 	}
; 179  : 
; 180  : 	assert(isReadOrWrite() && hostTransaction);
; 181  : 
; 182  : 	assert((isWrite() && hostTransaction->isWrite()) ||
; 183  : 		(isRead() && hostTransaction->isRead()));
; 184  : }

	ret	4
	npad	3
$LN11@setAutoPre:
	DD	$LN3@setAutoPre
	DD	$LN5@setAutoPre
	DD	$LN3@setAutoPre
	DD	$LN5@setAutoPre
?setAutoPrecharge@Command@DRAMsimII@@QBEX_N@Z ENDP	; DRAMsimII::Command::setAutoPrecharge
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\transaction.h
_TEXT	ENDS
;	COMDAT ?getType@Transaction@DRAMsimII@@QBE?AW4TransactionType@12@XZ
_TEXT	SEGMENT
?getType@Transaction@DRAMsimII@@QBE?AW4TransactionType@12@XZ PROC ; DRAMsimII::Transaction::getType, COMDAT
; _this$ = eax

; 64   : 		TransactionType getType() const { return type; }							///< get what type of transaction this is

	mov	eax, DWORD PTR [eax+80]
	ret	0
?getType@Transaction@DRAMsimII@@QBE?AW4TransactionType@12@XZ ENDP ; DRAMsimII::Transaction::getType
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\event.h
_TEXT	ENDS
;	COMDAT ??0Event@DRAMsimII@@IAE@ABV01@@Z
_TEXT	SEGMENT
??0Event@DRAMsimII@@IAE@ABV01@@Z PROC			; DRAMsimII::Event::Event, COMDAT
; _this$ = eax
; _rhs$ = ecx

; 78   : 		{}

	mov	DWORD PTR [eax], OFFSET ??_7Event@DRAMsimII@@6B@
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	edx, DWORD PTR [ecx+36]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR [eax+36], edx
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax+40], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR [eax+48], xmm0
	movq	xmm0, QWORD PTR [ecx+16]
	movq	QWORD PTR [eax+56], xmm0
	movq	xmm0, QWORD PTR [ecx+24]
	movq	QWORD PTR [eax+64], xmm0
	movq	xmm0, QWORD PTR [ecx+32]
	movq	QWORD PTR [eax+72], xmm0
	ret	0
??0Event@DRAMsimII@@IAE@ABV01@@Z ENDP			; DRAMsimII::Event::Event
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0Event@DRAMsimII@@IAE@ABVAddress@1@_J@Z
_TEXT	SEGMENT
_enqTime$ = 8						; size = 8
??0Event@DRAMsimII@@IAE@ABVAddress@1@_J@Z PROC		; DRAMsimII::Event::Event, COMDAT
; _this$ = eax
; _add$ = ecx

; 54   : 		{}

	push	esi
	mov	esi, DWORD PTR _enqTime$[esp]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR _enqTime$[esp+4]
	xor	edx, edx
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [eax], OFFSET ??_7Event@DRAMsimII@@6B@
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+24], edx
	mov	DWORD PTR [eax+28], edx
	mov	DWORD PTR [eax+32], edx
	mov	DWORD PTR [eax+36], edx
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax+40], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR [eax+48], xmm0
	movq	xmm0, QWORD PTR [ecx+16]
	movq	QWORD PTR [eax+56], xmm0
	movq	xmm0, QWORD PTR [ecx+24]
	movq	QWORD PTR [eax+64], xmm0
	movq	xmm0, QWORD PTR [ecx+32]
	movq	QWORD PTR [eax+72], xmm0
	pop	esi
	ret	8
??0Event@DRAMsimII@@IAE@ABVAddress@1@_J@Z ENDP		; DRAMsimII::Event::Event
PUBLIC	??1Command@DRAMsimII@@UAE@XZ			; DRAMsimII::Command::~Command
__unwindtable$??1Command@DRAMsimII@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Command@DRAMsimII@@UAE@XZ$0
__ehfuncinfo$??1Command@DRAMsimII@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1Command@DRAMsimII@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\command.cpp
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1Command@DRAMsimII@@UAE@XZ PROC			; DRAMsimII::Command::~Command

; 149  : {

	push	-1
	push	__ehhandler$??1Command@DRAMsimII@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+16]
	mov	DWORD PTR [esi], OFFSET ??_7Command@DRAMsimII@@6B@
	mov	DWORD PTR __$EHRec$[esp+28], 0

; 150  : 	if (hostTransaction)

	mov	ecx, DWORD PTR [esi+84]
	test	ecx, ecx
	je	SHORT $LN9@Command

; 151  : 	{
; 152  : 		delete hostTransaction;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx

; 153  : 		// don't want to checkpoint this
; 154  : 		hostTransaction = NULL;

	mov	DWORD PTR [esi+84], 0
$LN9@Command:

; 155  : 	}
; 156  : }

	mov	DWORD PTR [esi], OFFSET ??_7Event@DRAMsimII@@6B@
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
__unwindfunclet$??1Command@DRAMsimII@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1Event@DRAMsimII@@UAE@XZ		; DRAMsimII::Event::~Event
__ehhandler$??1Command@DRAMsimII@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Command@DRAMsimII@@UAE@XZ
	jmp	___CxxFrameHandler3
??1Command@DRAMsimII@@UAE@XZ ENDP			; DRAMsimII::Command::~Command
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\event.h
;	COMDAT ??8Event@DRAMsimII@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8Event@DRAMsimII@@QBE_NABV01@@Z PROC			; DRAMsimII::Event::operator==, COMDAT
; _this$ = ecx
; _right$ = eax

; 108  : 			return (arrivalTime == right.arrivalTime && enqueueTime == right.enqueueTime && startTime == right.startTime && completionTime == right.completionTime && address == right.getAddress());

	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator@118
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR [eax+12]
	jne	SHORT $LN3@operator@118
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR [eax+16]
	jne	SHORT $LN3@operator@118
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN3@operator@118
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR [eax+24]
	jne	SHORT $LN3@operator@118
	mov	edx, DWORD PTR [ecx+28]
	cmp	edx, DWORD PTR [eax+28]
	jne	SHORT $LN3@operator@118
	mov	edx, DWORD PTR [ecx+32]
	cmp	edx, DWORD PTR [eax+32]
	jne	SHORT $LN3@operator@118
	mov	edx, DWORD PTR [ecx+36]
	cmp	edx, DWORD PTR [eax+36]
	jne	SHORT $LN3@operator@118
	add	eax, 40					; 00000028H
	add	ecx, 40					; 00000028H
	call	??8Address@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Address::operator==
	test	al, al
	je	SHORT $LN3@operator@118
	mov	eax, 1

; 109  : 		}

	ret	0
$LN3@operator@118:

; 108  : 			return (arrivalTime == right.arrivalTime && enqueueTime == right.enqueueTime && startTime == right.startTime && completionTime == right.completionTime && address == right.getAddress());

	xor	eax, eax

; 109  : 		}

	ret	0
??8Event@DRAMsimII@@QBE_NABV01@@Z ENDP			; DRAMsimII::Event::operator==
PUBLIC	??8Command@DRAMsimII@@QBE_NABV01@@Z		; DRAMsimII::Command::operator==
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\command.cpp
_TEXT	SEGMENT
??8Command@DRAMsimII@@QBE_NABV01@@Z PROC		; DRAMsimII::Command::operator==
; _this$ = ecx
; _right$ = eax

; 210  : {

	push	esi
	push	edi
	mov	esi, eax
	mov	edi, ecx

; 211  : 	if (commandType == right.commandType && startTime == right.startTime &&
; 212  : 		enqueueTime == right.enqueueTime && completionTime == right.completionTime &&
; 213  : 		length == right.length && this->Event::operator==(right))

	mov	eax, DWORD PTR [edi+80]
	cmp	eax, DWORD PTR [esi+80]
	jne	SHORT $LN10@operator@248
	mov	ecx, DWORD PTR [edi+24]
	cmp	ecx, DWORD PTR [esi+24]
	jne	SHORT $LN10@operator@248
	mov	edx, DWORD PTR [edi+28]
	cmp	edx, DWORD PTR [esi+28]
	jne	SHORT $LN10@operator@248
	mov	eax, DWORD PTR [edi+16]
	cmp	eax, DWORD PTR [esi+16]
	jne	SHORT $LN10@operator@248
	mov	ecx, DWORD PTR [edi+20]
	cmp	ecx, DWORD PTR [esi+20]
	jne	SHORT $LN10@operator@248
	mov	edx, DWORD PTR [edi+32]
	cmp	edx, DWORD PTR [esi+32]
	jne	SHORT $LN10@operator@248
	mov	eax, DWORD PTR [edi+36]
	cmp	eax, DWORD PTR [esi+36]
	jne	SHORT $LN10@operator@248
	mov	ecx, DWORD PTR [edi+88]
	cmp	ecx, DWORD PTR [esi+88]
	jne	SHORT $LN10@operator@248
	mov	eax, esi
	mov	ecx, edi
	call	??8Event@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Event::operator==
	test	al, al
	je	SHORT $LN10@operator@248

; 214  : 	{
; 215  : 		if ((hostTransaction && !right.hostTransaction) || 
; 216  : 			(!hostTransaction && right.hostTransaction))

	mov	edi, DWORD PTR [edi+84]
	test	edi, edi
	je	SHORT $LN14@operator@248
	cmp	DWORD PTR [esi+84], 0
	je	SHORT $LN10@operator@248
	test	edi, edi
	jne	SHORT $LN5@operator@248
$LN14@operator@248:
	cmp	DWORD PTR [esi+84], 0

; 217  : 			return false;

	jne	SHORT $LN10@operator@248

; 218  : 		else if (!hostTransaction && !right.hostTransaction)

	test	edi, edi
	jne	SHORT $LN5@operator@248
	cmp	DWORD PTR [esi+84], edi
	jne	SHORT $LN5@operator@248
	pop	edi

; 219  : 			return true;

	mov	al, 1
	pop	esi

; 227  : }

	ret	0
$LN5@operator@248:

; 220  : 		else if (*hostTransaction == *right.hostTransaction)

	mov	esi, DWORD PTR [esi+84]
	call	??8Transaction@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Transaction::operator==
	test	al, al
	pop	edi
	setne	al
	pop	esi

; 227  : }

	ret	0
$LN10@operator@248:
	pop	edi

; 221  : 			return true;
; 222  : 		else 
; 223  : 			return false;
; 224  : 	}
; 225  : 	else
; 226  : 		return false;

	xor	al, al
	pop	esi

; 227  : }

	ret	0
??8Command@DRAMsimII@@QBE_NABV01@@Z ENDP		; DRAMsimII::Command::operator==
PUBLIC	??9Command@DRAMsimII@@QBE_NABV01@@Z		; DRAMsimII::Command::operator!=
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
??9Command@DRAMsimII@@QBE_NABV01@@Z PROC		; DRAMsimII::Command::operator!=
; _this$ = ecx
; _right$ = eax

; 234  : 	return !(*this == right);

	call	??8Command@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Command::operator==
	xor	ecx, ecx
	test	al, al
	sete	cl
	mov	al, cl

; 235  : }

	ret	0
??9Command@DRAMsimII@@QBE_NABV01@@Z ENDP		; DRAMsimII::Command::operator!=
PUBLIC	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABW4CommandType@Command@0@@Z ; DRAMsimII::operator<<
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABW4CommandType@Command@0@@Z PROC ; DRAMsimII::operator<<
; _os$ = esi
; _command$ = eax

; 254  : 	switch(command)

	mov	eax, DWORD PTR [eax]
	cmp	eax, 16					; 00000010H
	ja	$LN1@operator@426
	jmp	DWORD PTR $LN24@operator@426[eax*4]
$LN18@operator@426:

; 255  : 	{
; 256  : 	case Command::ACTIVATE:
; 257  : 		os << "RAS ";

	push	OFFSET ??_C@_04KDNIBPFK@RAS?5?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN17@operator@426:

; 258  : 		break;
; 259  : 	case Command::READ:
; 260  : 		os << "CAS ";

	push	OFFSET ??_C@_04POFIKBGI@CAS?5?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN16@operator@426:

; 261  : 		break;
; 262  : 	case Command::READ_AND_PRECHARGE:
; 263  : 		os << "CAS+P ";

	push	OFFSET ??_C@_06CCMMABJK@CAS?$CLP?5?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN15@operator@426:

; 264  : 		break;
; 265  : 	case Command::WRITE:
; 266  : 		os << "CASW ";

	push	OFFSET ??_C@_05IHKNOLLM@CASW?5?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN14@operator@426:

; 267  : 		break;
; 268  : 	case Command::WRITE_AND_PRECHARGE:
; 269  : 		os << "CASW+P ";

	push	OFFSET ??_C@_07FBJBNAPK@CASW?$CLP?5?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN13@operator@426:

; 270  : 		break;
; 271  : 	case Command::RETIRE_COMMAND:
; 272  : 		os << "RETIRE ";

	push	OFFSET ??_C@_07NLMAFCIK@RETIRE?5?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN12@operator@426:

; 273  : 		break;
; 274  : 	case Command::PRECHARGE:
; 275  : 		os << "PREC ";

	push	OFFSET ??_C@_05ELPCHFDE@PREC?5?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN11@operator@426:

; 276  : 		break;
; 277  : 	case Command::PRECHARGE_ALL:
; 278  : 		os << "PREC_A ";

	push	OFFSET ??_C@_07EMMFEOCJ@PREC_A?5?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN10@operator@426:

; 279  : 		break;
; 280  : 	case Command::ACTIVATE_ALL:
; 281  : 		os << "RAS_A ";

	push	OFFSET ??_C@_06BKNMGIGM@RAS_A?5?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN9@operator@426:

; 282  : 		break;
; 283  : 	case Command::DRIVE_COMMAND:
; 284  : 		os << "DRIVE ";

	push	OFFSET ??_C@_06MLMBNJNI@DRIVE?5?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN8@operator@426:

; 285  : 		break;
; 286  : 	case Command::DATA_COMMAND:
; 287  : 		os << "DATA ";

	push	OFFSET ??_C@_05BPNEDMHP@DATA?5?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN7@operator@426:

; 288  : 		break;
; 289  : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 290  : 		os << "CAS+D ";

	push	OFFSET ??_C@_06DJODAKDG@CAS?$CLD?5?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN6@operator@426:

; 291  : 		break;
; 292  : 	case Command::REFRESH_ALL:
; 293  : 		os << "REF   ";

	push	OFFSET ??_C@_06FDAECDFF@REF?5?5?5?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN5@operator@426:

; 294  : 		break;
; 295  : 	case Command::SELF_REFRESH:
; 296  : 		os << "SELREF";

	push	OFFSET ??_C@_06DEOJNLN@SELREF?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN4@operator@426:

; 297  : 		break;
; 298  : 	case Command::DESELECT:
; 299  : 		os << "DESLCT";

	push	OFFSET ??_C@_06IPDIBDGD@DESLCT?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN3@operator@426:

; 300  : 		break;
; 301  : 	case Command::NOOP:
; 302  : 		os << "NOOP  ";

	push	OFFSET ??_C@_06DEMODEGE@NOOP?5?5?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN2@operator@426:

; 303  : 		break;
; 304  : 	case Command::INVALID_COMMAND:
; 305  : 		os << "INVALD";

	push	OFFSET ??_C@_06PPDMIAKB@INVALD?$AA@

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN1@operator@426:

; 306  : 		break;
; 307  : 	default:
; 308  : 		os << "UNKWN";

	push	OFFSET ??_C@_05LOKBKELC@UNKWN?$AA@
	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 309  : 		break;
; 310  : 	}
; 311  : 	return os;

	mov	eax, esi

; 312  : }

	ret	0
$LN24@operator@426:
	DD	$LN18@operator@426
	DD	$LN17@operator@426
	DD	$LN16@operator@426
	DD	$LN15@operator@426
	DD	$LN14@operator@426
	DD	$LN13@operator@426
	DD	$LN12@operator@426
	DD	$LN11@operator@426
	DD	$LN10@operator@426
	DD	$LN9@operator@426
	DD	$LN8@operator@426
	DD	$LN7@operator@426
	DD	$LN6@operator@426
	DD	$LN5@operator@426
	DD	$LN4@operator@426
	DD	$LN3@operator@426
	DD	$LN2@operator@426
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABW4CommandType@Command@0@@Z ENDP ; DRAMsimII::operator<<
_TEXT	ENDS
PUBLIC	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
__unwindtable$??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z$0
__ehfuncinfo$??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_enqueueTime$ = 12					; size = 8
_autoPrecharge$ = 20					; size = 1
_commandLength$ = 24					; size = 4
??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z PROC ; DRAMsimII::Command::Command
; _hostTransaction$ = ecx
; _type$ = edx

; 108  : {

	push	-1
	push	__ehhandler$??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	bl, BYTE PTR _autoPrecharge$[esp+28]
	mov	esi, ecx
	mov	eax, DWORD PTR _this$[esp+28]
	mov	edi, DWORD PTR _enqueueTime$[esp+28]
	mov	DWORD PTR [eax+16], edi
	mov	edi, DWORD PTR _enqueueTime$[esp+32]
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7Event@DRAMsimII@@6B@
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+20], edi
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], ecx
	movq	xmm0, QWORD PTR [esi+40]
	movq	QWORD PTR [eax+40], xmm0
	movq	xmm0, QWORD PTR [esi+48]
	movq	QWORD PTR [eax+48], xmm0
	movq	xmm0, QWORD PTR [esi+56]
	movq	QWORD PTR [eax+56], xmm0
	movq	xmm0, QWORD PTR [esi+64]
	movq	QWORD PTR [eax+64], xmm0
	movq	xmm0, QWORD PTR [esi+72]
	movq	QWORD PTR [eax+72], xmm0
	mov	edi, edx
	dec	edi
	neg	edi
	sbb	edi, edi
	not	edi
	mov	DWORD PTR __$EHRec$[esp+40], ecx
	and	edi, esi
	mov	DWORD PTR [eax+84], edi
	mov	edi, DWORD PTR _commandLength$[esp+28]
	mov	DWORD PTR [eax], OFFSET ??_7Command@DRAMsimII@@6B@
	mov	DWORD PTR [eax+88], edi
	mov	BYTE PTR [eax+92], cl

; 109  : 	if (type == READ)

	cmp	edx, 1
	jne	SHORT $LN8@Command@2

; 110  : 	{
; 111  : 		switch (hostTransaction->getType())

	mov	esi, DWORD PTR [esi+80]
	cmp	esi, 4
	ja	SHORT $LN2@Command@2
	jmp	DWORD PTR $LN24@Command@2[esi*4]
$LN5@Command@2:

; 112  : 		{
; 113  : 		case Transaction::AUTO_REFRESH_TRANSACTION:
; 114  : 			commandType = REFRESH_ALL;

	mov	DWORD PTR [eax+80], 12			; 0000000cH

; 133  : 	}
; 134  : 
; 135  : 	assert((commandType == WRITE_AND_PRECHARGE && hostTransaction->isWrite()) ||
; 136  : 		(commandType == READ_AND_PRECHARGE && hostTransaction->isRead()) ||
; 137  : 		(commandType == READ && hostTransaction->isRead()) ||
; 138  : 		(commandType == WRITE && hostTransaction->isWrite()) ||
; 139  : 		(commandType == ACTIVATE) || (commandType == PRECHARGE) ||
; 140  : 		(commandType == REFRESH_ALL && hostTransaction->isRefresh())
; 141  : 		);
; 142  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	20					; 00000014H
$LN4@Command@2:

; 115  : 			break;
; 116  : 		case Transaction::WRITE_TRANSACTION:
; 117  : 			commandType = autoPrecharge ? WRITE_AND_PRECHARGE : WRITE;

	xor	edx, edx
	cmp	bl, cl
	setne	dl
	add	edx, 3
$LN8@Command@2:

; 130  : 	{
; 131  : 		assert(type == PRECHARGE || type == ACTIVATE);
; 132  : 		commandType = type;

	mov	DWORD PTR [eax+80], edx

; 133  : 	}
; 134  : 
; 135  : 	assert((commandType == WRITE_AND_PRECHARGE && hostTransaction->isWrite()) ||
; 136  : 		(commandType == READ_AND_PRECHARGE && hostTransaction->isRead()) ||
; 137  : 		(commandType == READ && hostTransaction->isRead()) ||
; 138  : 		(commandType == WRITE && hostTransaction->isWrite()) ||
; 139  : 		(commandType == ACTIVATE) || (commandType == PRECHARGE) ||
; 140  : 		(commandType == REFRESH_ALL && hostTransaction->isRefresh())
; 141  : 		);
; 142  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	20					; 00000014H
$LN3@Command@2:

; 118  : 			break;
; 119  : 		case Transaction::READ_TRANSACTION:
; 120  : 		case Transaction::IFETCH_TRANSACTION:
; 121  : 			commandType = autoPrecharge ? READ_AND_PRECHARGE : READ;

	xor	edx, edx
	cmp	bl, cl
	setne	dl
	inc	edx

; 126  : 			break;
; 127  : 		}
; 128  : 	}
; 129  : 	else

	jmp	SHORT $LN8@Command@2
$LN2@Command@2:

; 122  : 			break;
; 123  : 		default:
; 124  : 			cerr << "Unknown transaction type, quitting." << endl;

	push	OFFSET ??_C@_0CE@DNBMIKHG@Unknown?5transaction?5type?0?5quitti@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 125  : 			exit(-21);

	push	-21					; ffffffebH
	call	_exit
$LN25@Command@2:
$LN23@Command@2:
	npad	3
$LN24@Command@2:

; 133  : 	}
; 134  : 
; 135  : 	assert((commandType == WRITE_AND_PRECHARGE && hostTransaction->isWrite()) ||
; 136  : 		(commandType == READ_AND_PRECHARGE && hostTransaction->isRead()) ||
; 137  : 		(commandType == READ && hostTransaction->isRead()) ||
; 138  : 		(commandType == WRITE && hostTransaction->isWrite()) ||
; 139  : 		(commandType == ACTIVATE) || (commandType == PRECHARGE) ||
; 140  : 		(commandType == REFRESH_ALL && hostTransaction->isRefresh())
; 141  : 		);
; 142  : }

	DD	$LN3@Command@2
	DD	$LN4@Command@2
	DD	$LN3@Command@2
	DD	$LN2@Command@2
	DD	$LN5@Command@2
__unwindfunclet$??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1Event@DRAMsimII@@UAE@XZ		; DRAMsimII::Event::~Event
__ehhandler$??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z
	jmp	___CxxFrameHandler3
??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ENDP ; DRAMsimII::Command::Command
PUBLIC	??0Command@DRAMsimII@@QAE@PAVTransaction@1@ABVAddress@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
__unwindtable$??0Command@DRAMsimII@@QAE@PAVTransaction@1@ABVAddress@1@_J_NIW4CommandType@01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Command@DRAMsimII@@QAE@PAVTransaction@1@ABVAddress@1@_J_NIW4CommandType@01@@Z$0
__ehfuncinfo$??0Command@DRAMsimII@@QAE@PAVTransaction@1@ABVAddress@1@_J_NIW4CommandType@01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Command@DRAMsimII@@QAE@PAVTransaction@1@ABVAddress@1@_J_NIW4CommandType@01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_enqueueTime$ = 12					; size = 8
_commandLength$ = 20					; size = 4
??0Command@DRAMsimII@@QAE@PAVTransaction@1@ABVAddress@1@_J_NIW4CommandType@01@@Z PROC ; DRAMsimII::Command::Command
; _addr$ = ecx

; 66   : {

	push	-1
	push	__ehhandler$??0Command@DRAMsimII@@QAE@PAVTransaction@1@ABVAddress@1@_J_NIW4CommandType@01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _this$[esp+16]
	mov	esi, DWORD PTR _enqueueTime$[esp+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR _enqueueTime$[esp+20]
	xor	edx, edx
	mov	DWORD PTR [eax], OFFSET ??_7Event@DRAMsimII@@6B@
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [eax+24], edx
	mov	DWORD PTR [eax+28], edx
	mov	DWORD PTR [eax+32], edx
	mov	DWORD PTR [eax+36], edx
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax+40], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR [eax+48], xmm0
	movq	xmm0, QWORD PTR [ecx+16]
	movq	QWORD PTR [eax+56], xmm0
	movq	xmm0, QWORD PTR [ecx+24]
	movq	QWORD PTR [eax+64], xmm0
	movq	xmm0, QWORD PTR [ecx+32]
	movq	QWORD PTR [eax+72], xmm0
	mov	ecx, DWORD PTR _commandLength$[esp+16]
	mov	DWORD PTR [eax], OFFSET ??_7Command@DRAMsimII@@6B@
	mov	DWORD PTR [eax+84], edx
	mov	DWORD PTR [eax+88], ecx
	mov	BYTE PTR [eax+92], dl

; 67   : 	if (type == READ)
; 68   : 	{
; 69   : 		switch (hostTransaction->getType())
; 70   : 		{
; 71   : 		case Transaction::AUTO_REFRESH_TRANSACTION:
; 72   : 			commandType = REFRESH_ALL;
; 73   : 			break;
; 74   : 		case Transaction::WRITE_TRANSACTION:
; 75   : 			commandType = autoPrecharge ? WRITE_AND_PRECHARGE : WRITE;
; 76   : 			break;
; 77   : 		case Transaction::READ_TRANSACTION:
; 78   : 		case Transaction::IFETCH_TRANSACTION:
; 79   : 			commandType = autoPrecharge ? READ_AND_PRECHARGE : READ;
; 80   : 			break;
; 81   : 		default:
; 82   : 			cerr << "Unknown transaction type, quitting." << endl;
; 83   : 			exit(-21);
; 84   : 			break;
; 85   : 		}
; 86   : 	}
; 87   : 	else
; 88   : 	{
; 89   : 		assert(type == PRECHARGE || type == ACTIVATE);
; 90   : 		commandType = type;

	mov	DWORD PTR [eax+80], 6

; 91   : 	}
; 92   : 
; 93   : 	assert((isWrite() && hostTransaction->isWrite()) ||
; 94   : 		(isRead() && hostTransaction->isRead()) ||
; 95   : 		(isActivate()) || (isPrecharge()) ||
; 96   : 		(isRefresh() && hostTransaction->isRefresh())
; 97   : 		);
; 98   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
__unwindfunclet$??0Command@DRAMsimII@@QAE@PAVTransaction@1@ABVAddress@1@_J_NIW4CommandType@01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1Event@DRAMsimII@@UAE@XZ		; DRAMsimII::Event::~Event
__ehhandler$??0Command@DRAMsimII@@QAE@PAVTransaction@1@ABVAddress@1@_J_NIW4CommandType@01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Command@DRAMsimII@@QAE@PAVTransaction@1@ABVAddress@1@_J_NIW4CommandType@01@@Z
	jmp	___CxxFrameHandler3
??0Command@DRAMsimII@@QAE@PAVTransaction@1@ABVAddress@1@_J_NIW4CommandType@01@@Z ENDP ; DRAMsimII::Command::Command
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\event.h
;	COMDAT ??0Event@DRAMsimII@@IAE@XZ
_TEXT	SEGMENT
??0Event@DRAMsimII@@IAE@XZ PROC				; DRAMsimII::Event::Event, COMDAT
; _this$ = esi

; 46   : 		{}

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	xor	eax, eax
	mov	DWORD PTR [esi], OFFSET ??_7Event@DRAMsimII@@6B@
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+36], eax
	push	edi
	lea	edi, DWORD PTR [esi+40]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], eax
	mov	DWORD PTR [edi+24], eax
	mov	DWORD PTR [edi+28], eax
	mov	DWORD PTR [edi+32], eax
	call	?addressTranslation@Address@DRAMsimII@@IAE_NXZ ; DRAMsimII::Address::addressTranslation
	mov	eax, esi
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
??0Event@DRAMsimII@@IAE@XZ ENDP				; DRAMsimII::Event::Event
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
;	COMDAT ?releaseItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEXPAVCommand@2@@Z
_TEXT	SEGMENT
_item$ = 8						; size = 4
?releaseItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEXPAVCommand@2@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Command>::releaseItem, COMDAT

; 266  : 		{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	ebx
	push	esi

; 267  : 			assert(pool);
; 268  : 			//#pragma omp critical
; 269  : 			{
; 270  : 
; 271  : #if 1
; 272  : 				// look around to see if this was already in there, slows things down a lot, so use only when this might be a problem
; 273  : 				for (typename std::vector<T *>::iterator i = entry.begin(); i != entry.end(); i++)

	mov	esi, DWORD PTR ?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A+24
	push	edi
	cmp	esi, DWORD PTR ?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A+28
	jbe	SHORT $LN14@releaseIte@3
	call	__invalid_parameter_noinfo
$LN14@releaseIte@3:
	mov	ebx, DWORD PTR ?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A+12
	npad	13
$LL31@releaseIte@3:
	mov	edi, DWORD PTR ?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A+28
	cmp	DWORD PTR ?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A+24, edi
	jbe	SHORT $LN46@releaseIte@3
	call	__invalid_parameter_noinfo
$LN46@releaseIte@3:
	test	ebx, ebx
	je	SHORT $LN59@releaseIte@3
	cmp	ebx, DWORD PTR ?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A+12
	je	SHORT $LN60@releaseIte@3
$LN59@releaseIte@3:
	call	__invalid_parameter_noinfo
$LN60@releaseIte@3:
	cmp	esi, edi
	je	SHORT $LN2@releaseIte@3
	test	ebx, ebx
	jne	SHORT $LN68@releaseIte@3
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN38@releaseIte@3:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN29@releaseIte@3
	call	__invalid_parameter_noinfo
$LN29@releaseIte@3:
	add	esi, 4
	jmp	SHORT $LL31@releaseIte@3
$LN68@releaseIte@3:
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN38@releaseIte@3
$LN2@releaseIte@3:

; 274  : 				{
; 275  : 					assert(item != *i);
; 276  : 				}
; 277  : #endif
; 278  : 				assert(pool);
; 279  : 				if (!push(item))

	mov	esi, DWORD PTR _item$[ebp]
	push	esi
	mov	eax, OFFSET ?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A ; DRAMsimII::Command::freeCommandPool
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push
	test	al, al
	jne	SHORT $LN1@releaseIte@3

; 280  : 				{
; 281  : 					::delete item;

	test	esi, esi
	je	SHORT $LN7@releaseIte@3
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 282  : 					item = NULL;
; 283  : 				}
; 284  : 			}
; 285  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN7@releaseIte@3:

; 280  : 				{
; 281  : 					::delete item;

	xor	eax, eax
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@releaseIte@3:

; 282  : 					item = NULL;
; 283  : 				}
; 284  : 			}
; 285  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?releaseItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEXPAVCommand@2@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::releaseItem
_TEXT	ENDS
PUBLIC	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCommand@0@@Z ; DRAMsimII::operator<<
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\command.cpp
_TEXT	SEGMENT
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCommand@0@@Z PROC ; DRAMsimII::operator<<
; _os$ = esi
; _currentCommand$ = eax

; 318  : {

	push	edi
	mov	edi, eax

; 319  : 	return os << currentCommand.commandType << (const Event&)(currentCommand);	

	lea	eax, DWORD PTR [edi+80]
	call	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABW4CommandType@Command@0@@Z ; DRAMsimII::operator<<
	push	eax
	call	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVEvent@0@@Z ; DRAMsimII::operator<<
	add	esp, 4
	pop	edi

; 320  : }

	ret	0
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCommand@0@@Z ENDP ; DRAMsimII::operator<<
_TEXT	ENDS
PUBLIC	??3Command@DRAMsimII@@SAXPAX@Z			; DRAMsimII::Command::operator delete
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
??3Command@DRAMsimII@@SAXPAX@Z PROC			; DRAMsimII::Command::operator delete
; _mem$ = esi

; 200  : 	Command *cmd = static_cast<Command*>(mem);
; 201  : 	assert(!cmd->getHost());
; 202  : 	cmd->~Command();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx

; 203  : 	freeCommandPool.releaseItem(cmd);

	push	esi
	call	?releaseItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEXPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::releaseItem

; 204  : }

	ret	0
??3Command@DRAMsimII@@SAXPAX@Z ENDP			; DRAMsimII::Command::operator delete
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCommand@DRAMsimII@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCommand@DRAMsimII@@UAEPAXI@Z PROC			; DRAMsimII::Command::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	esi
	call	??1Command@DRAMsimII@@UAE@XZ		; DRAMsimII::Command::~Command
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@105
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx
	push	esi
	call	?releaseItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEXPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::releaseItem
$LN6@scalar@105:
	mov	eax, esi
	pop	esi
	ret	4
??_GCommand@DRAMsimII@@UAEPAXI@Z ENDP			; DRAMsimII::Command::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0Command@DRAMsimII@@QAE@XZ			; DRAMsimII::Command::Command
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
??0Command@DRAMsimII@@QAE@XZ PROC			; DRAMsimII::Command::Command
; _this$ = eax

; 36   : {}

	push	esi
	mov	esi, eax
	call	??0Event@DRAMsimII@@IAE@XZ		; DRAMsimII::Event::Event
	xor	eax, eax
	mov	DWORD PTR [esi+84], eax
	mov	DWORD PTR [esi+88], eax
	mov	DWORD PTR [esi], OFFSET ??_7Command@DRAMsimII@@6B@
	mov	DWORD PTR [esi+80], 5
	mov	eax, esi
	pop	esi
	ret	0
??0Command@DRAMsimII@@QAE@XZ ENDP			; DRAMsimII::Command::Command
;	COMDAT xdata$x
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.cpp
xdata$x	SEGMENT
__unwindtable$?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ$0
__ehfuncinfo$?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
xdata$x	ENDS
;	COMDAT ?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ
_TEXT	SEGMENT
$T679322 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ PROC ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem, COMDAT

; 291  : 		{

	push	-1
	push	__ehhandler$?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax

; 292  : 			assert(pool);
; 293  : 			T* newItem;
; 294  : 			//#pragma omp critical
; 295  : 			{
; 296  : 				if (count == 0)

	cmp	DWORD PTR ?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A, 0
	jne	SHORT $LN2@acquireIte@3

; 297  : 				{
; 298  : 					newItem = ::new T;

	push	96					; 00000060H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T679322[esp+28], esi
	mov	DWORD PTR __$EHRec$[esp+36], 0
	test	esi, esi
	je	SHORT $LN5@acquireIte@3
	call	??0Event@DRAMsimII@@IAE@XZ		; DRAMsimII::Event::Event
	mov	DWORD PTR [esi], OFFSET ??_7Command@DRAMsimII@@6B@
	mov	DWORD PTR [esi+80], 5
	mov	DWORD PTR [esi+84], 0
	mov	DWORD PTR [esi+88], 0
	mov	eax, esi

; 303  : 			}
; 304  : 			return newItem;
; 305  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
$LN5@acquireIte@3:

; 297  : 				{
; 298  : 					newItem = ::new T;

	xor	eax, eax

; 303  : 			}
; 304  : 			return newItem;
; 305  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
$LN2@acquireIte@3:

; 299  : 					assert(newItem != NULL);
; 300  : 				}
; 301  : 				else
; 302  : 					newItem = pop();

	mov	esi, OFFSET ?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A ; DRAMsimII::Command::freeCommandPool
	call	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop

; 303  : 			}
; 304  : 			return newItem;
; 305  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ$0:
	mov	eax, DWORD PTR $T679322[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
PUBLIC	??2Command@DRAMsimII@@SAPAXI@Z			; DRAMsimII::Command::operator new
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\command.cpp
_TEXT	SEGMENT
??2Command@DRAMsimII@@SAPAXI@Z PROC			; DRAMsimII::Command::operator new

; 190  : {

	push	ecx

; 191  : 	assert(size == sizeof(Command));
; 192  : 	return freeCommandPool.acquireItem();

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	pop	ecx

; 193  : }

	ret	0
??2Command@DRAMsimII@@SAPAXI@Z ENDP			; DRAMsimII::Command::operator new
_TEXT	ENDS
PUBLIC	??0Command@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Command::Command
__unwindtable$??0Command@DRAMsimII@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Command@DRAMsimII@@QAE@ABV01@@Z$0
__ehfuncinfo$??0Command@DRAMsimII@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Command@DRAMsimII@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_rhs$ = 12						; size = 4
??0Command@DRAMsimII@@QAE@ABV01@@Z PROC			; DRAMsimII::Command::Command

; 47   : {

	push	-1
	push	__ehhandler$??0Command@DRAMsimII@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _rhs$[esp+32]
	mov	ebx, DWORD PTR _this$[esp+32]
	mov	ecx, ebp
	mov	eax, ebx
	call	??0Event@DRAMsimII@@IAE@ABV01@@Z	; DRAMsimII::Event::Event
	mov	DWORD PTR __$EHRec$[esp+44], 0
	mov	DWORD PTR [ebx], OFFSET ??_7Command@DRAMsimII@@6B@
	mov	eax, DWORD PTR [ebp+80]
	mov	DWORD PTR [ebx+80], eax
	cmp	DWORD PTR [ebp+84], 0
	je	SHORT $LN5@Command@3
	call	?acquireItem@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::acquireItem
	test	eax, eax
	je	SHORT $LN5@Command@3
	mov	edi, DWORD PTR [ebp+84]
	mov	esi, eax
	call	??0Transaction@DRAMsimII@@QAE@ABV01@@Z	; DRAMsimII::Transaction::Transaction
	jmp	SHORT $LN6@Command@3
$LN5@Command@3:
	xor	eax, eax
$LN6@Command@3:
	mov	DWORD PTR [ebx+84], eax
	mov	ecx, DWORD PTR [ebp+88]
	mov	DWORD PTR [ebx+88], ecx
	mov	dl, BYTE PTR [ebp+92]
	mov	BYTE PTR [ebx+92], dl

; 48   : 	assert(!hostTransaction ||
; 49   : 		(commandType == WRITE_AND_PRECHARGE && hostTransaction->isWrite()) ||
; 50   : 		(commandType == READ_AND_PRECHARGE && hostTransaction->isRead()) ||
; 51   : 		(commandType == READ && hostTransaction->isRead()) ||
; 52   : 		(commandType == WRITE && hostTransaction->isWrite()) ||		 
; 53   : 		(commandType == REFRESH_ALL && hostTransaction->isRefresh()) ||
; 54   : 		(commandType == ACTIVATE) || (commandType == PRECHARGE)
; 55   : 		);
; 56   : }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
__unwindfunclet$??0Command@DRAMsimII@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1Event@DRAMsimII@@UAE@XZ		; DRAMsimII::Event::~Event
__ehhandler$??0Command@DRAMsimII@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Command@DRAMsimII@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
??0Command@DRAMsimII@@QAE@ABV01@@Z ENDP			; DRAMsimII::Command::Command
; Function compile flags: /Ogtpy
;	COMDAT ??__E?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A@@YAXXZ
text$yc	SEGMENT
??__E?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A@@YAXXZ PROC ; `dynamic initializer for 'DRAMsimII::Command::freeCommandPool'', COMDAT

; 26   : Queue<Command> Command::freeCommandPool(16*POOL_SIZE,true);

	push	1
	push	OFFSET ?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A ; DRAMsimII::Command::freeCommandPool
	mov	ecx, 1024				; 00000400H
	call	??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ; DRAMsimII::Queue<DRAMsimII::Command>::Queue<DRAMsimII::Command>
	push	OFFSET ??__F?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A@@YAXXZ ; `dynamic atexit destructor for 'DRAMsimII::Command::freeCommandPool''
	call	_atexit
	pop	ecx
	ret	0
??__E?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A@@YAXXZ ENDP ; `dynamic initializer for 'DRAMsimII::Command::freeCommandPool''
; Function compile flags: /Ogtpy
;	COMDAT ??__F?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A@@YAXXZ
text$yd	SEGMENT
??__F?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'DRAMsimII::Command::freeCommandPool'', COMDAT
	push	OFFSET ?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A ; DRAMsimII::Command::freeCommandPool
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	ret	0
??__F?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'DRAMsimII::Command::freeCommandPool''
PUBLIC	?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A ; DRAMsimII::Command::freeCommandPool
	ALIGN	4

?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A DB 028H DUP (?) ; DRAMsimII::Command::freeCommandPool
?freeCommandPool$initializer$@Command@DRAMsimII@@1P6AXXZA DD FLAT:??__E?freeCommandPool@Command@DRAMsimII@@1V?$Queue@VCommand@DRAMsimII@@@2@A@@YAXXZ ; DRAMsimII::Command::freeCommandPool$initializer$
END
