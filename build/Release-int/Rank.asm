; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\CriuS\Documents\Visual Studio 2008\Projects\DRAMsimIIhg\src\Rank.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6B@ ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Bexception@2@@ ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Blength_error@std@@@ ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8 ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8 ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`RTTI Base Class Array'
PUBLIC	??_R1DM@?0A@EA@clone_base@exception_detail@boost@@8 ; boost::exception_detail::clone_base::`RTTI Base Class Descriptor at (60,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8 ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Bexception@2@@ ; boost::exception_detail::error_info_injector<std::length_error>::`RTTI Complete Object Locator'
PUBLIC	??_R4?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Blength_error@std@@@ ; boost::exception_detail::error_info_injector<std::length_error>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8 ; boost::exception_detail::error_info_injector<std::length_error>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8 ; boost::exception_detail::error_info_injector<std::length_error>::`RTTI Base Class Array'
PUBLIC	??_R1CI@?0A@EA@exception@boost@@8		; boost::exception::`RTTI Base Class Descriptor at (40,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8 ; boost::exception_detail::error_info_injector<std::length_error>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?get_allocator@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE?AV?$allocator@_J@std@@XZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::get_allocator
PUBLIC	??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::circular_buffer<__int64,std::allocator<__int64> >
PUBLIC	??0?$allocator@VBank@DRAMsimII@@@std@@QAE@XZ	; std::allocator<DRAMsimII::Bank>::allocator<DRAMsimII::Bank>
PUBLIC	??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Bank *,unsigned int,DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@stdext@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Bank *,unsigned int,DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	?_Ufill@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEPAVBank@DRAMsimII@@PAV34@IABV34@@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Ufill
PUBLIC	?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Construct_n
PUBLIC	??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@IABVBank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	??$?0VBank@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VBank@DRAMsimII@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Bank>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VBank@DRAMsimII@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >
PUBLIC	??0?$allocator@VBank@DRAMsimII@@@std@@QAE@ABV01@@Z ; std::allocator<DRAMsimII::Bank>::allocator<DRAMsimII::Bank>
PUBLIC	??0?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VBank@DRAMsimII@@@1@@Z ; std::_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@PAVBank@DRAMsimII@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@AAPAVBank@DRAMsimII@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,DRAMsimII::Bank *>
PUBLIC	??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Bank const *,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@PAVBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@2@@stdext@@YAPAVBank@DRAMsimII@@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEPAVBank@DRAMsimII@@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@1@0PAV23@@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Ucopy<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >
PUBLIC	??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXI@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::initialize_buffer
PUBLIC	??$uninitialized_fill_n_with_alloc@PA_JI_JV?$allocator@_J@std@@@cb_details@boost@@YAXPA_JIAB_JAAV?$allocator@_J@std@@@Z ; boost::cb_details::uninitialized_fill_n_with_alloc<__int64 *,unsigned int,__int64,std::allocator<__int64> >
PUBLIC	?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::initialize_buffer
PUBLIC	??$initialize@H@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIHHABU?$integral_constant@_N$00@1@@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::initialize<int>
PUBLIC	??$?0H@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@IHHABV?$allocator@_J@std@@@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::circular_buffer<__int64,std::allocator<__int64> ><int>
PUBLIC	?full@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE_NXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::full
PUBLIC	?replace@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_JAB_J@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::replace
PUBLIC	??$decrement@PA_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPA_J@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::decrement<__int64 *>
PUBLIC	?push_front@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEXAB_J@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::push_front
PUBLIC	??0?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@QAE@P8Bank@DRAMsimII@@AEXXZ@Z ; boost::mem_fun_ref_t<void,DRAMsimII::Bank>::mem_fun_ref_t<void,DRAMsimII::Bank>
PUBLIC	??$mem_fun_ref@XVBank@DRAMsimII@@@boost@@YA?AV?$mem_fun_ref_t@XVBank@DRAMsimII@@@0@P8Bank@DRAMsimII@@AEXXZ@Z ; boost::mem_fun_ref<void,DRAMsimII::Bank>
PUBLIC	??R?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@QBEXAAVBank@DRAMsimII@@@Z ; boost::mem_fun_ref_t<void,DRAMsimII::Bank>::operator()
PUBLIC	?_Checked_iterator_base@?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAVBank@DRAMsimII@@AAV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@std@@YAPAVBank@DRAMsimII@@AAV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >
PUBLIC	??$for_each@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@V?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@@std@@YA?AV?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@0V12@@Z ; std::for_each<std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,boost::mem_fun_ref_t<void,DRAMsimII::Bank> >
PUBLIC	?nextCommandType@Bank@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ; DRAMsimII::Bank::nextCommandType
PUBLIC	?begin@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::begin
PUBLIC	??0?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE@PBV?$circular_buffer@_JV?$allocator@_J@std@@@2@QA_J@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >
PUBLIC	?end@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::end
PUBLIC	??D?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEAA_JXZ ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::operator*
PUBLIC	??0?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE@ABU012@@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >
PUBLIC	??E?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@XZ ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::operator++
PUBLIC	??E?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE?AU012@H@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::operator++
PUBLIC	??$?9U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBE_NABU012@@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::operator!=<boost::cb_details::nonconst_traits<std::allocator<__int64> > >
PUBLIC	?allocate@?$allocator@_J@std@@QAEPA_JIPBX@Z	; std::allocator<__int64>::allocate
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	?max_size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::max_size
PUBLIC	??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABVlength_error@std@@@Z ; boost::exception_detail::error_info_injector<std::length_error>::error_info_injector<std::length_error>
PUBLIC	??$enable_error_info@Vlength_error@std@@@boost@@YA?AU?$error_info_injector@Vlength_error@std@@@exception_detail@0@ABVlength_error@std@@@Z ; boost::enable_error_info<std::length_error>
PUBLIC	??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >
PUBLIC	??$enable_current_exception@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@boost@@YA?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@0@ABU?$error_info_injector@Vlength_error@std@@@20@@Z ; boost::enable_current_exception<boost::exception_detail::error_info_injector<std::length_error> >
PUBLIC	?clone@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEPBVclone_base@23@XZ ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::clone
PUBLIC	?rethrow@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEXXZ ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::rethrow
PUBLIC	??_E?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@WCI@AEPAXI@Z ; [thunk]:boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`vector deleting destructor'
PUBLIC	??1?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@UAE@XZ ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::~clone_impl<boost::exception_detail::error_info_injector<std::length_error> >
PUBLIC	??_G?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@UAEPAXI@Z ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`scalar deleting destructor'
PUBLIC	??_E?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@WDM@AEPAXI@Z ; [thunk]:boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`vector deleting destructor'
PUBLIC	??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABV012@@Z ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >
PUBLIC	??1?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAE@XZ ; boost::exception_detail::error_info_injector<std::length_error>::~error_info_injector<std::length_error>
PUBLIC	??_G?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAEPAXI@Z ; boost::exception_detail::error_info_injector<std::length_error>::`scalar deleting destructor'
PUBLIC	??_E?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@WCI@AEPAXI@Z ; [thunk]:boost::exception_detail::error_info_injector<std::length_error>::`vector deleting destructor'
PUBLIC	??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z ; boost::exception_detail::error_info_injector<std::length_error>::error_info_injector<std::length_error>
PUBLIC	??$throw_exception@Vlength_error@std@@@boost@@YAXABVlength_error@std@@@Z ; boost::throw_exception<std::length_error>
PUBLIC	?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::allocate
PUBLIC	?reset@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_J0I@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::reset
PUBLIC	??$_Construct@_J_J@std@@YAXPA_JAB_J@Z		; std::_Construct<__int64,__int64>
PUBLIC	?construct@?$allocator@_J@std@@QAEXPA_JAB_J@Z	; std::allocator<__int64>::construct
PUBLIC	??$uninitialized_copy_with_alloc@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@PA_JV?$allocator@_J@std@@@cb_details@boost@@YAPA_JU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@01@0PA_JAAV?$allocator@_J@std@@@Z ; boost::cb_details::uninitialized_copy_with_alloc<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,__int64 *,std::allocator<__int64> >
PUBLIC	??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::operator=
PUBLIC	?capacity@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::capacity
PUBLIC	?_Make_iter@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Make_iter
PUBLIC	?erase@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@0@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::erase
PUBLIC	?clear@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::clear
PUBLIC	??$_Allocate@VBank@DRAMsimII@@@std@@YAPAVBank@DRAMsimII@@IPAV12@@Z ; std::_Allocate<DRAMsimII::Bank>
PUBLIC	?allocate@?$allocator@VBank@DRAMsimII@@@std@@QAEPAVBank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Bank>::allocate
PUBLIC	?max_size@?$allocator@VBank@DRAMsimII@@@std@@QBEIXZ ; std::allocator<DRAMsimII::Bank>::max_size
PUBLIC	?max_size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::max_size
PUBLIC	?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Xlen
PUBLIC	?_Buy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE_NI@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Buy
PUBLIC	??$_Iter_random@PAVBank@DRAMsimII@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVBank@DRAMsimII@@0@Z ; std::_Iter_random<DRAMsimII::Bank *,DRAMsimII::Bank *>
PUBLIC	??$_Copy_opt@PAVBank@DRAMsimII@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Bank *,DRAMsimII::Bank *,std::forward_iterator_tag>
PUBLIC	??$_Copy_opt@PAVBank@DRAMsimII@@PAV12@@std@@YAPAVBank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Bank *,DRAMsimII::Bank *>
PUBLIC	??$unchecked_copy@PAVBank@DRAMsimII@@PAV12@@stdext@@YAPAVBank@DRAMsimII@@PAV12@00@Z ; stdext::unchecked_copy<DRAMsimII::Bank *,DRAMsimII::Bank *>
PUBLIC	??$_Checked_base@PAVBank@DRAMsimII@@@std@@YAPAVBank@DRAMsimII@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<DRAMsimII::Bank *>
PUBLIC	??$_Checked_base@PAVBank@DRAMsimII@@@std@@YAPAVBank@DRAMsimII@@AAPAV12@@Z ; std::_Checked_base<DRAMsimII::Bank *>
PUBLIC	??$_Construct@VBank@DRAMsimII@@V12@@std@@YAXPAVBank@DRAMsimII@@ABV12@@Z ; std::_Construct<DRAMsimII::Bank,DRAMsimII::Bank>
PUBLIC	?construct@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@ABV34@@Z ; std::allocator<DRAMsimII::Bank>::construct
PUBLIC	??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Bank *,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >
PUBLIC	??$unchecked_uninitialized_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@stdext@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_copy<DRAMsimII::Bank *,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >
PUBLIC	??$_Ucopy@PAVBank@DRAMsimII@@@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEPAVBank@DRAMsimII@@PAV23@00@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Ucopy<DRAMsimII::Bank *>
PUBLIC	??4?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator=
PUBLIC	?empty@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE_NXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::empty
PUBLIC	?begin@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::begin
PUBLIC	??0?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE@PBV?$circular_buffer@_JV?$allocator@_J@std@@@2@QB_J@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >
PUBLIC	?end@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::end
PUBLIC	??$_Iter_random@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@@std@@YA?AUrandom_access_iterator_tag@0@ABU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@0@Z ; std::_Iter_random<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >
PUBLIC	??$sub@PB_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEPB_JPB_JH@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::sub<__int64 const *>
PUBLIC	??Z?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@H@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator-=
PUBLIC	??$add@PB_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEPB_JPB_JH@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::add<__int64 const *>
PUBLIC	??Y?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@H@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator+=
PUBLIC	??H?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBE?AU012@H@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator+
PUBLIC	??$_Checked_base@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@@std@@YA?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@AAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >
PUBLIC	??$_Checked_base@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@@std@@YA?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@AAU123@@Z ; std::_Checked_base<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >
PUBLIC	??$linearize_pointer@U?$const_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEPB_JABU012@@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::linearize_pointer<boost::cb_details::const_traits<std::allocator<__int64> > >
PUBLIC	??$?GU?$const_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEHABU012@@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator-<boost::cb_details::const_traits<std::allocator<__int64> > >
PUBLIC	??D?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEAB_JXZ ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator*
PUBLIC	??$increment@PB_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPB_J@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::increment<__int64 const *>
PUBLIC	??E?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@XZ ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator++
PUBLIC	??$?9U?$const_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBE_NABU012@@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator!=<boost::cb_details::const_traits<std::allocator<__int64> > >
PUBLIC	??$_Equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@Uforward_iterator_tag@std@@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,std::forward_iterator_tag>
PUBLIC	??$_Equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >
PUBLIC	??$equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00@Z ; std::equal<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >
PUBLIC	??$?8_JV?$allocator@_J@std@@@boost@@YA_NABV?$circular_buffer@_JV?$allocator@_J@std@@@0@0@Z ; boost::operator==<__int64,std::allocator<__int64> >
PUBLIC	??$_Iter_random@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@0@Z ; std::_Iter_random<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVBank@DRAMsimII@@AAV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@std@@YAPBVBank@DRAMsimII@@AAV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >
PUBLIC	??$_Equal@PBVBank@DRAMsimII@@PBV12@Uforward_iterator_tag@std@@@std@@YA_NPBVBank@DRAMsimII@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<DRAMsimII::Bank const *,DRAMsimII::Bank const *,std::forward_iterator_tag>
PUBLIC	??$_Equal@PBVBank@DRAMsimII@@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVBank@DRAMsimII@@0V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<DRAMsimII::Bank const *,std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >
PUBLIC	??$equal@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@00@Z ; std::equal<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >
PUBLIC	??$?8VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@0@Z ; std::operator==<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	??_C@_0BA@BJAEHAHE@circular_buffer?$AA@		; `string'
PUBLIC	??_R0?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@@8 ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> > `RTTI Type Descriptor'
PUBLIC	??_R0?AU?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@8 ; boost::exception_detail::error_info_injector<std::length_error> `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@@8??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABV012@@Z64
PUBLIC	__CT??_R0?AU?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@8??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z60
PUBLIC	__CT??_R0?AVexception@boost@@@8??0exception@boost@@QAE@ABV01@@Z2040
PUBLIC	__CT??_R0?AVclone_base@exception_detail@boost@@@8??0clone_base@exception_detail@boost@@QAE@ABV012@@Z460
PUBLIC	__CTA7?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@
PUBLIC	__TI7?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@
PUBLIC	??_7?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Blength_error@std@@@ ; boost::exception_detail::error_info_injector<std::length_error>::`vftable'
PUBLIC	??_7?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Bexception@2@@ ; boost::exception_detail::error_info_injector<std::length_error>::`vftable'
PUBLIC	??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Blength_error@std@@@ ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`vftable'
PUBLIC	??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Bexception@2@@ ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`vftable'
PUBLIC	??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6B@ ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`vftable'
EXTRN	??_E?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@UAEPAXI@Z:PROC ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`vector deleting destructor'
EXTRN	??_E?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAEPAXI@Z:PROC ; boost::exception_detail::error_info_injector<std::length_error>::`vector deleting destructor'
;	COMDAT ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6B@
CONST	SEGMENT
??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6B@ DD FLAT:??_R4?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6B@ ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`vftable'
	DD	FLAT:?clone@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEPBVclone_base@23@XZ
	DD	FLAT:?rethrow@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEXXZ
	DD	FLAT:??_E?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@WDM@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6B@
rdata$r	SEGMENT
??_R4?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6B@ DD 00H ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`RTTI Complete Object Locator'
	DD	03cH
	DD	00H
	DD	FLAT:??_R0?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@@8
	DD	FLAT:??_R3?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Bexception@2@@
CONST	SEGMENT
??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Bexception@2@@ DD FLAT:??_R4?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Bexception@2@@ ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`vftable'
	DD	FLAT:??_E?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@WCI@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Bexception@2@@
rdata$r	SEGMENT
??_R4?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Bexception@2@@ DD 00H ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`RTTI Complete Object Locator'
	DD	028H
	DD	00H
	DD	FLAT:??_R0?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@@8
	DD	FLAT:??_R3?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Blength_error@std@@@
CONST	SEGMENT
??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Blength_error@std@@@ DD FLAT:??_R4?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Blength_error@std@@@ ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`vftable'
	DD	FLAT:??_E?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Blength_error@std@@@
rdata$r	SEGMENT
??_R4?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Blength_error@std@@@ DD 00H ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@@8
	DD	FLAT:??_R3?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R3?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8
rdata$r	SEGMENT
??_R3?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8 DD 00H ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	07H
	DD	FLAT:??_R2?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R2?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8
rdata$r	SEGMENT
??_R2?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8 DD FLAT:??_R1A@?0A@EA@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8 ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8
	DD	FLAT:??_R1A@?0A@EA@length_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
	DD	FLAT:??_R1CI@?0A@EA@exception@boost@@8
	DD	FLAT:??_R1DM@?0A@EA@clone_base@exception_detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R1DM@?0A@EA@clone_base@exception_detail@boost@@8
rdata$r	SEGMENT
??_R1DM@?0A@EA@clone_base@exception_detail@boost@@8 DD FLAT:??_R0?AVclone_base@exception_detail@boost@@@8 ; boost::exception_detail::clone_base::`RTTI Base Class Descriptor at (60,-1,0,64)'
	DD	00H
	DD	03cH
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3clone_base@exception_detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8 DD FLAT:??_R0?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@@8 ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_7?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Bexception@2@@
CONST	SEGMENT
??_7?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Bexception@2@@ DD FLAT:??_R4?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Bexception@2@@ ; boost::exception_detail::error_info_injector<std::length_error>::`vftable'
	DD	FLAT:??_E?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@WCI@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Bexception@2@@
rdata$r	SEGMENT
??_R4?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Bexception@2@@ DD 00H ; boost::exception_detail::error_info_injector<std::length_error>::`RTTI Complete Object Locator'
	DD	028H
	DD	00H
	DD	FLAT:??_R0?AU?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@8
	DD	FLAT:??_R3?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_7?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Blength_error@std@@@
CONST	SEGMENT
??_7?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Blength_error@std@@@ DD FLAT:??_R4?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Blength_error@std@@@ ; boost::exception_detail::error_info_injector<std::length_error>::`vftable'
	DD	FLAT:??_E?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Blength_error@std@@@
rdata$r	SEGMENT
??_R4?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Blength_error@std@@@ DD 00H ; boost::exception_detail::error_info_injector<std::length_error>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@8
	DD	FLAT:??_R3?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R3?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8
rdata$r	SEGMENT
??_R3?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8 DD 00H ; boost::exception_detail::error_info_injector<std::length_error>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R2?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8
rdata$r	SEGMENT
??_R2?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8 DD FLAT:??_R1A@?0A@EA@?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8 ; boost::exception_detail::error_info_injector<std::length_error>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@length_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
	DD	FLAT:??_R1CI@?0A@EA@exception@boost@@8
rdata$r	ENDS
;	COMDAT ??_R1CI@?0A@EA@exception@boost@@8
rdata$r	SEGMENT
??_R1CI@?0A@EA@exception@boost@@8 DD FLAT:??_R0?AVexception@boost@@@8 ; boost::exception::`RTTI Base Class Descriptor at (40,-1,0,64)'
	DD	00H
	DD	028H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@boost@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8 DD FLAT:??_R0?AU?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@8 ; boost::exception_detail::error_info_injector<std::length_error>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@8
rdata$r	ENDS
;	COMDAT __TI7?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@
xdata$x	SEGMENT
__TI7?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@ DD 00H
	DD	FLAT:??1?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA7?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@
xdata$x	ENDS
;	COMDAT __CTA7?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@
xdata$x	SEGMENT
__CTA7?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@ DD 07H
	DD	FLAT:__CT??_R0?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@@8??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABV012@@Z64
	DD	FLAT:__CT??_R0?AU?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@8??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z60
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@boost@@@8??0exception@boost@@QAE@ABV01@@Z2040
	DD	FLAT:__CT??_R0?AVclone_base@exception_detail@boost@@@8??0clone_base@exception_detail@boost@@QAE@ABV012@@Z460
xdata$x	ENDS
;	COMDAT __CT??_R0?AVclone_base@exception_detail@boost@@@8??0clone_base@exception_detail@boost@@QAE@ABV012@@Z460
xdata$x	SEGMENT
__CT??_R0?AVclone_base@exception_detail@boost@@@8??0clone_base@exception_detail@boost@@QAE@ABV012@@Z460 DD 00H
	DD	FLAT:??_R0?AVclone_base@exception_detail@boost@@@8
	DD	03cH
	DD	0ffffffffH
	DD	00H
	DD	04H
	DD	FLAT:??0clone_base@exception_detail@boost@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@boost@@@8??0exception@boost@@QAE@ABV01@@Z2040
xdata$x	SEGMENT
__CT??_R0?AVexception@boost@@@8??0exception@boost@@QAE@ABV01@@Z2040 DD 00H
	DD	FLAT:??_R0?AVexception@boost@@@8
	DD	028H
	DD	0ffffffffH
	DD	00H
	DD	014H
	DD	FLAT:??0exception@boost@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AU?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@8??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z60
xdata$x	SEGMENT
__CT??_R0?AU?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@8??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z60 DD 00H
	DD	FLAT:??_R0?AU?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	03cH
	DD	FLAT:??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@@8??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABV012@@Z64
xdata$x	SEGMENT
__CT??_R0?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@@8??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABV012@@Z64 DD 00H
	DD	FLAT:??_R0?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	040H
	DD	FLAT:??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AU?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@8
_DATA	SEGMENT
??_R0?AU?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@8 DD FLAT:??_7type_info@@6B@ ; boost::exception_detail::error_info_injector<std::length_error> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$error_info_injector@Vlength_error@std@@@exception_'
	DB	'detail@boost@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@@8
_DATA	SEGMENT
??_R0?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@@8 DD FLAT:??_7type_info@@6B@ ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$clone_impl@U?$error_info_injector@Vlength_error@st'
	DB	'd@@@exception_detail@boost@@@exception_detail@boost@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BA@BJAEHAHE@circular_buffer?$AA@
CONST	SEGMENT
??_C@_0BA@BJAEHAHE@circular_buffer?$AA@ DB 'circular_buffer', 00H ; `string'
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Odtpy
;	COMDAT ??_E?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@WDM@AEPAXI@Z
_TEXT	SEGMENT
??_E?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@WDM@AEPAXI@Z PROC ; [thunk]:boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`vector deleting destructor', COMDAT
	sub	ecx, 60					; 0000003cH
	jmp	??_E?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@UAEPAXI@Z
??_E?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@WDM@AEPAXI@Z ENDP ; [thunk]:boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`vector deleting destructor'
; Function compile flags: /Odtpy
_TEXT	ENDS
;	COMDAT ??_E?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@WCI@AEPAXI@Z
_TEXT	SEGMENT
??_E?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@WCI@AEPAXI@Z PROC ; [thunk]:boost::exception_detail::error_info_injector<std::length_error>::`vector deleting destructor', COMDAT
	sub	ecx, 40					; 00000028H
	jmp	??_E?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAEPAXI@Z
??_E?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@WCI@AEPAXI@Z ENDP ; [thunk]:boost::exception_detail::error_info_injector<std::length_error>::`vector deleting destructor'
; Function compile flags: /Odtpy
_TEXT	ENDS
;	COMDAT ??_E?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@WCI@AEPAXI@Z
_TEXT	SEGMENT
??_E?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@WCI@AEPAXI@Z PROC ; [thunk]:boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`vector deleting destructor', COMDAT
	sub	ecx, 40					; 00000028H
	jmp	??_E?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@UAEPAXI@Z
??_E?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@WCI@AEPAXI@Z ENDP ; [thunk]:boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`vector deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVBank@DRAMsimII@@AAV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVBank@DRAMsimII@@AAV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVBank@DRAMsimII@@AAV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@@std@@YA?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@AAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@@std@@YA?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@AAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >, COMDAT
; ___$ReturnUdt$ = eax
; __It$ = ecx

; 1147 : 		return _It;

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1148 : 	}

	ret	0
??$_Checked_base@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@@std@@YA?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@AAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 305  : 		return (this->_Myptr);

	mov	eax, DWORD PTR [eax+4]

; 306  : 		}

	ret	0
?_Checked_iterator_base@?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAVBank@DRAMsimII@@@std@@YAPAVBank@DRAMsimII@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAVBank@DRAMsimII@@@std@@YAPAVBank@DRAMsimII@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<DRAMsimII::Bank *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAVBank@DRAMsimII@@@std@@YAPAVBank@DRAMsimII@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<DRAMsimII::Bank *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@PAVBank@DRAMsimII@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@AAPAVBank@DRAMsimII@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@PAVBank@DRAMsimII@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@AAPAVBank@DRAMsimII@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,DRAMsimII::Bank *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@PAVBank@DRAMsimII@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@AAPAVBank@DRAMsimII@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,DRAMsimII::Bank *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Iter_random@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@std@@YAPBVBank@DRAMsimII@@AAV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@std@@YAPBVBank@DRAMsimII@@AAV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@std@@YAPBVBank@DRAMsimII@@AAV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@@std@@YA?AUrandom_access_iterator_tag@0@ABU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@0@Z
_TEXT	SEGMENT
??$_Iter_random@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@@std@@YA?AUrandom_access_iterator_tag@0@ABU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@0@Z PROC ; std::_Iter_random<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@@std@@YA?AUrandom_access_iterator_tag@0@ABU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@0@Z ENDP ; std::_Iter_random<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@@std@@YA?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@AAU123@@Z
_TEXT	SEGMENT
??$_Checked_base@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@@std@@YA?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@AAU123@@Z PROC ; std::_Checked_base<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >, COMDAT
; ___$ReturnUdt$ = eax
; __It$ = ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1166 : 	}

	ret	0
??$_Checked_base@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@@std@@YA?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@AAU123@@Z ENDP ; std::_Checked_base<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAVBank@DRAMsimII@@AAV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAVBank@DRAMsimII@@AAV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAVBank@DRAMsimII@@AAV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ??$increment@PB_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPB_J@Z
_TEXT	SEGMENT
??$increment@PB_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPB_J@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::increment<__int64 const *>, COMDAT
; _this$ = edx
; _p$ = eax

; 1981 :         if (++p == m_end)

	add	DWORD PTR [eax], 8
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN1@increment

; 1982 :             p = m_buff;

	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN1@increment:

; 1983 :     }

	ret	0
??$increment@PB_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPB_J@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::increment<__int64 const *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAVBank@DRAMsimII@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVBank@DRAMsimII@@0@Z
_TEXT	SEGMENT
??$_Iter_random@PAVBank@DRAMsimII@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVBank@DRAMsimII@@0@Z PROC ; std::_Iter_random<DRAMsimII::Bank *,DRAMsimII::Bank *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PAVBank@DRAMsimII@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVBank@DRAMsimII@@0@Z ENDP ; std::_Iter_random<DRAMsimII::Bank *,DRAMsimII::Bank *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAVBank@DRAMsimII@@@std@@YAPAVBank@DRAMsimII@@AAPAV12@@Z
_TEXT	SEGMENT
??$_Checked_base@PAVBank@DRAMsimII@@@std@@YAPAVBank@DRAMsimII@@AAPAV12@@Z PROC ; std::_Checked_base<DRAMsimII::Bank *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAVBank@DRAMsimII@@@std@@YAPAVBank@DRAMsimII@@AAPAV12@@Z ENDP ; std::_Checked_base<DRAMsimII::Bank *>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\details.hpp
_TEXT	ENDS
;	COMDAT ??$?9U?$const_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBE_NABU012@@Z
_TEXT	SEGMENT
??$?9U?$const_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBE_NABU012@@Z PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator!=<boost::cb_details::const_traits<std::allocator<__int64> > >, COMDAT
; _this$ = eax
; _it$ = edx

; 366  :         BOOST_CB_ASSERT(is_valid(m_buff));    // check for uninitialized or invalidated iterator
; 367  :         BOOST_CB_ASSERT(it.is_valid(m_buff)); // check for uninitialized or invalidated iterator
; 368  :         return m_it != it.m_it;

	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx+4]
	setne	al

; 369  :     }

	ret	0
??$?9U?$const_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBE_NABU012@@Z ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator!=<boost::cb_details::const_traits<std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@std@@YAPAVBank@DRAMsimII@@AAV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@std@@YAPAVBank@DRAMsimII@@AAV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@std@@YAPAVBank@DRAMsimII@@AAV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\details.hpp
_TEXT	ENDS
;	COMDAT ??E?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@XZ
_TEXT	SEGMENT
??E?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@XZ PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator++, COMDAT
; _this$ = eax

; 286  :         BOOST_CB_ASSERT(is_valid(m_buff)); // check for uninitialized or invalidated iterator
; 287  :         BOOST_CB_ASSERT(m_it != 0);        // check for iterator pointing to end()
; 288  :         m_buff->increment(m_it);

	mov	ecx, DWORD PTR [eax]
	add	DWORD PTR [eax+4], 8
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@operator@10
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
$LN4@operator@10:

; 289  :         if (m_it == m_buff->m_last)

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [edx+12]
	jne	SHORT $LN1@operator@10

; 290  :             m_it = 0;

	mov	DWORD PTR [eax+4], 0
$LN1@operator@10:

; 291  :         return *this;
; 292  :     }

	ret	0
??E?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@XZ ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEAB_JXZ
_TEXT	SEGMENT
??D?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEAB_JXZ PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator*, COMDAT
; _this$ = eax

; 268  :         BOOST_CB_ASSERT(is_valid(m_buff)); // check for uninitialized or invalidated iterator
; 269  :         BOOST_CB_ASSERT(m_it != 0);        // check for iterator pointing to end()
; 270  :         return *m_it;

	mov	eax, DWORD PTR [eax+4]

; 271  :     }

	ret	0
??D?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEAB_JXZ ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\functional.hpp
_TEXT	ENDS
;	COMDAT ??R?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@QBEXAAVBank@DRAMsimII@@@Z
_TEXT	SEGMENT
??R?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@QBEXAAVBank@DRAMsimII@@@Z PROC ; boost::mem_fun_ref_t<void,DRAMsimII::Bank>::operator(), COMDAT
; _this$ = eax
; _p$ = ecx

; 414  :             return (p.*ptr)();

	mov	edx, DWORD PTR [eax]
	jmp	edx
??R?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@QBEXAAVBank@DRAMsimII@@@Z ENDP ; boost::mem_fun_ref_t<void,DRAMsimII::Bank>::operator()
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@QAE@P8Bank@DRAMsimII@@AEXXZ@Z
_TEXT	SEGMENT
??0?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@QAE@P8Bank@DRAMsimII@@AEXXZ@Z PROC ; boost::mem_fun_ref_t<void,DRAMsimII::Bank>::mem_fun_ref_t<void,DRAMsimII::Bank>, COMDAT
; _this$ = eax

; 411  :         {}

	mov	DWORD PTR [eax], OFFSET ?issueREF@Bank@DRAMsimII@@QAEXXZ ; DRAMsimII::Bank::issueREF
	ret	0
??0?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@QAE@P8Bank@DRAMsimII@@AEXXZ@Z ENDP ; boost::mem_fun_ref_t<void,DRAMsimII::Bank>::mem_fun_ref_t<void,DRAMsimII::Bank>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0VBank@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VBank@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
??$?0VBank@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VBank@DRAMsimII@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Bank>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0VBank@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VBank@DRAMsimII@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Bank>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jb	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ??$decrement@PA_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPA_J@Z
_TEXT	SEGMENT
??$decrement@PA_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPA_J@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::decrement<__int64 *>, COMDAT
; _this$ = ecx
; _p$ = eax

; 1988 :         if (p == m_buff)

	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN4@decrement

; 1989 :             p = m_end;

	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx
$LN4@decrement:

; 1990 :         --p;

	add	DWORD PTR [eax], -8			; fffffff8H

; 1991 :     }

	ret	0
??$decrement@PA_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPA_J@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::decrement<__int64 *>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\details.hpp
_TEXT	ENDS
;	COMDAT ??$?9U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBE_NABU012@@Z
_TEXT	SEGMENT
??$?9U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBE_NABU012@@Z PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::operator!=<boost::cb_details::nonconst_traits<std::allocator<__int64> > >, COMDAT
; _this$ = eax
; _it$ = edx

; 366  :         BOOST_CB_ASSERT(is_valid(m_buff));    // check for uninitialized or invalidated iterator
; 367  :         BOOST_CB_ASSERT(it.is_valid(m_buff)); // check for uninitialized or invalidated iterator
; 368  :         return m_it != it.m_it;

	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx+4]
	setne	al

; 369  :     }

	ret	0
??$?9U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBE_NABU012@@Z ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::operator!=<boost::cb_details::nonconst_traits<std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$for_each@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@V?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@@std@@YA?AV?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@0V12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Func$ = 28						; size = 4
??$for_each@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@V?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@@std@@YA?AV?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@0V12@@Z PROC ; std::for_each<std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,boost::mem_fun_ref_t<void,DRAMsimII::Bank> >, COMDAT

; 23   : 	{	// perform function for each element

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));

	mov	esi, DWORD PTR __First$[esp+8]
	push	edi

; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	edi, DWORD PTR __Last$[esp+12]

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, edi
	je	SHORT $LN22@for_each@3
$LL3@for_each@3:

; 29   : 		_Func(*_ChkFirst);

	mov	ecx, esi
	call	DWORD PTR __Func$[esp+8]
	add	esi, 152				; 00000098H
	cmp	esi, edi
	jne	SHORT $LL3@for_each@3

; 30   : 	return (_Func);

	mov	eax, DWORD PTR __Func$[esp+8]
	pop	edi
	mov	DWORD PTR [ebx], eax
	pop	esi
	mov	eax, ebx
	pop	ebx

; 31   : 	}

	ret	0
$LN22@for_each@3:

; 30   : 	return (_Func);

	mov	ecx, DWORD PTR __Func$[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], ecx
	mov	eax, ebx
	pop	ebx

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@V?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@@std@@YA?AV?$mem_fun_ref_t@XVBank@DRAMsimII@@@boost@@V?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@0V12@@Z ENDP ; std::for_each<std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,boost::mem_fun_ref_t<void,DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\functional.hpp
_TEXT	ENDS
;	COMDAT ??$mem_fun_ref@XVBank@DRAMsimII@@@boost@@YA?AV?$mem_fun_ref_t@XVBank@DRAMsimII@@@0@P8Bank@DRAMsimII@@AEXXZ@Z
_TEXT	SEGMENT
??$mem_fun_ref@XVBank@DRAMsimII@@@boost@@YA?AV?$mem_fun_ref_t@XVBank@DRAMsimII@@@0@P8Bank@DRAMsimII@@AEXXZ@Z PROC ; boost::mem_fun_ref<void,DRAMsimII::Bank>, COMDAT
; ___$ReturnUdt$ = eax

; 473  :         return mem_fun_ref_t<S,T>(f);

	mov	DWORD PTR [eax], OFFSET ?issueREF@Bank@DRAMsimII@@QAEXXZ ; DRAMsimII::Bank::issueREF

; 474  :     }

	ret	0
??$mem_fun_ref@XVBank@DRAMsimII@@@boost@@YA?AV?$mem_fun_ref_t@XVBank@DRAMsimII@@@0@P8Bank@DRAMsimII@@AEXXZ@Z ENDP ; boost::mem_fun_ref<void,DRAMsimII::Bank>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VBank@DRAMsimII@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VBank@DRAMsimII@@@std@@QBEIXZ PROC ; std::allocator<DRAMsimII::Bank>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 28256363				; 01af286bH

; 167  : 		}

	ret	0
?max_size@?$allocator@VBank@DRAMsimII@@@std@@QBEIXZ ENDP ; std::allocator<DRAMsimII::Bank>::max_size
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\details.hpp
_TEXT	ENDS
;	COMDAT ??0?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE@PBV?$circular_buffer@_JV?$allocator@_J@std@@@2@QB_J@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??0?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE@PBV?$circular_buffer@_JV?$allocator@_J@std@@@2@QB_J@Z PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >, COMDAT
; _this$ = eax
; _cb$ = ecx

; 248  :     iterator(const Buff* cb, const pointer p) : m_buff(cb), m_it(p) {}

	mov	edx, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	4
??0?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE@PBV?$circular_buffer@_JV?$allocator@_J@std@@@2@QB_J@Z ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 28256363				; 01af286bH

; 732  : 		}

	ret	0
?max_size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\details.hpp
_TEXT	ENDS
;	COMDAT ??0?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE@PBV?$circular_buffer@_JV?$allocator@_J@std@@@2@QA_J@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??0?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE@PBV?$circular_buffer@_JV?$allocator@_J@std@@@2@QA_J@Z PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >, COMDAT
; _this$ = eax
; _cb$ = ecx

; 248  :     iterator(const Buff* cb, const pointer p) : m_buff(cb), m_it(p) {}

	mov	edx, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	4
??0?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE@PBV?$circular_buffer@_JV?$allocator@_J@std@@@2@QA_J@Z ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE@ABU012@@Z
_TEXT	SEGMENT
??0?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE@ABU012@@Z PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >, COMDAT
; _this$ = eax
; _it$ = ecx

; 246  :     iterator(const nonconst_self& it) : m_buff(it.m_buff), m_it(it.m_it) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	ret	0
??0?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE@ABU012@@Z ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@VBank@DRAMsimII@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@VBank@DRAMsimII@@@std@@QAE@ABV01@@Z PROC	; std::allocator<DRAMsimII::Bank>::allocator<DRAMsimII::Bank>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@VBank@DRAMsimII@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<DRAMsimII::Bank>::allocator<DRAMsimII::Bank>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@VBank@DRAMsimII@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VBank@DRAMsimII@@@std@@QAE@XZ PROC	; std::allocator<DRAMsimII::Bank>::allocator<DRAMsimII::Bank>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VBank@DRAMsimII@@@std@@QAE@XZ ENDP	; std::allocator<DRAMsimII::Bank>::allocator<DRAMsimII::Bank>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	jne	SHORT $LN3@capacity@7

; 636  : 		}

	ret	0
$LN3@capacity@7:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, eax
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?replace@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_JAB_J@Z
_TEXT	SEGMENT
?replace@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_JAB_J@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::replace, COMDAT
; _pos$ = ecx
; _item$ = eax

; 2034 :         *pos = item;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax

; 2035 : #if BOOST_CB_ENABLE_DEBUG
; 2036 :         invalidate_iterators(iterator(this, pos));
; 2037 : #endif
; 2038 :     }

	ret	0
?replace@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_JAB_J@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::replace
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ
_TEXT	SEGMENT
?end@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 280  :     const_iterator end() const { return const_iterator(this, 0); }

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0
	ret	0
?end@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::end
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\details.hpp
_TEXT	ENDS
;	COMDAT ??D?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEAA_JXZ
_TEXT	SEGMENT
??D?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEAA_JXZ PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::operator*, COMDAT
; _this$ = eax

; 268  :         BOOST_CB_ASSERT(is_valid(m_buff)); // check for uninitialized or invalidated iterator
; 269  :         BOOST_CB_ASSERT(m_it != 0);        // check for iterator pointing to end()
; 270  :         return *m_it;

	mov	eax, DWORD PTR [eax+4]

; 271  :     }

	ret	0
??D?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEAA_JXZ ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?end@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ
_TEXT	SEGMENT
?end@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 248  :     iterator end() { return iterator(this, 0); }

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0
	ret	0
?end@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::end
_TEXT	ENDS
PUBLIC	?next@Rank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ; DRAMsimII::Rank::next
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\rank.cpp
_TEXT	SEGMENT
?next@Rank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z PROC ; DRAMsimII::Rank::next
; _this$ = ecx
; _nextCommandType$ = eax

; 313  : 	switch (nextCommandType)

	cmp	eax, 12					; 0000000cH
	ja	SHORT $LN1@next
	movzx	eax, BYTE PTR $LN11@next[eax]
	jmp	DWORD PTR $LN12@next[eax*4]
$LN6@next:

; 314  : 	{
; 315  : 	case Command::READ:
; 316  : 	case Command::READ_AND_PRECHARGE:
; 317  : 		return nextReadTime;

	mov	eax, DWORD PTR [ecx+80]
	mov	edx, DWORD PTR [ecx+84]

; 334  : 		break;
; 335  : 	}
; 336  : }

	ret	0
$LN5@next:

; 318  : 		break;
; 319  : 	case Command::ACTIVATE:
; 320  : 		return nextActivateTime;

	mov	eax, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR [ecx+76]

; 334  : 		break;
; 335  : 	}
; 336  : }

	ret	0
$LN4@next:

; 321  : 		break;	
; 322  : 	case Command::WRITE:
; 323  : 	case Command::WRITE_AND_PRECHARGE:
; 324  : 		return nextWriteTime;

	mov	eax, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR [ecx+92]

; 334  : 		break;
; 335  : 	}
; 336  : }

	ret	0
$LN3@next:

; 325  : 		break;
; 326  : 	case Command::PRECHARGE:
; 327  : 		return 0;

	xor	eax, eax
	xor	edx, edx

; 334  : 		break;
; 335  : 	}
; 336  : }

	ret	0
$LN2@next:

; 328  : 		break;
; 329  : 	case Command::REFRESH_ALL:
; 330  : 		return nextRefreshTime;

	mov	eax, DWORD PTR [ecx+96]
	mov	edx, DWORD PTR [ecx+100]

; 334  : 		break;
; 335  : 	}
; 336  : }

	ret	0
$LN1@next:

; 331  : 		break;
; 332  : 	default:
; 333  : 		return TICK_MAX;

	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH

; 334  : 		break;
; 335  : 	}
; 336  : }

	ret	0
	npad	3
$LN12@next:
	DD	$LN5@next
	DD	$LN6@next
	DD	$LN4@next
	DD	$LN3@next
	DD	$LN2@next
	DD	$LN1@next
$LN11@next:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	2
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
?next@Rank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ENDP ; DRAMsimII::Rank::next
_TEXT	ENDS
PUBLIC	?resetPrechargeTime@Rank@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Rank::resetPrechargeTime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_time$ = 8						; size = 8
?resetPrechargeTime@Rank@DRAMsimII@@QAEX_J@Z PROC	; DRAMsimII::Rank::resetPrechargeTime
; _this$ = eax

; 302  : 	prechargeTime = 0;
; 303  : 	lastCalculationTime = time;

	mov	edx, DWORD PTR _time$[esp]
	xor	ecx, ecx
	mov	DWORD PTR [eax+56], ecx
	mov	DWORD PTR [eax+60], ecx
	mov	ecx, DWORD PTR _time$[esp-4]
	mov	DWORD PTR [eax+104], ecx
	mov	DWORD PTR [eax+108], edx

; 304  : 	assert (nextRefreshTime == lastPrechargeAnyBankTime + timing.tRP() || nextRefreshTime == lastRefreshTime + timing.tRFC());
; 305  : }

	ret	8
?resetPrechargeTime@Rank@DRAMsimII@@QAEX_J@Z ENDP	; DRAMsimII::Rank::resetPrechargeTime
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\limits
_TEXT	ENDS
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 615  : 		{	// return maximum value
; 616  : 		return (INT_MAX);

	mov	eax, 2147483647				; 7fffffffH

; 617  : 		}

	ret	0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\details.hpp
;	COMDAT ??$linearize_pointer@U?$const_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEPB_JABU012@@Z
_TEXT	SEGMENT
??$linearize_pointer@U?$const_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEPB_JABU012@@Z PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::linearize_pointer<boost::cb_details::const_traits<std::allocator<__int64> > >, COMDAT
; _this$ = ecx
; _it$ = eax

; 396  :         return it.m_it == 0 ? m_buff->m_buff + m_buff->size() :
; 397  :             (it.m_it < m_buff->m_first ? it.m_it + (m_buff->m_end - m_buff->m_first)
; 398  :                 : m_buff->m_buff + (it.m_it - m_buff->m_first));

	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	jne	SHORT $LN5@linearize_
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [edx+ecx*8]

; 399  :     }

	ret	0
$LN5@linearize_:

; 396  :         return it.m_it == 0 ? m_buff->m_buff + m_buff->size() :
; 397  :             (it.m_it < m_buff->m_first ? it.m_it + (m_buff->m_end - m_buff->m_first)
; 398  :                 : m_buff->m_buff + (it.m_it - m_buff->m_first));

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+8]
	cmp	eax, edx
	jae	SHORT $LN3@linearize_
	mov	ecx, DWORD PTR [ecx+4]
	sub	ecx, edx
	sar	ecx, 3
	lea	eax, DWORD PTR [eax+ecx*8]

; 399  :     }

	ret	0
$LN3@linearize_:

; 396  :         return it.m_it == 0 ? m_buff->m_buff + m_buff->size() :
; 397  :             (it.m_it < m_buff->m_first ? it.m_it + (m_buff->m_end - m_buff->m_first)
; 398  :                 : m_buff->m_buff + (it.m_it - m_buff->m_first));

	sub	eax, edx
	mov	edx, DWORD PTR [ecx]
	sar	eax, 3
	lea	eax, DWORD PTR [edx+eax*8]

; 399  :     }

	ret	0
??$linearize_pointer@U?$const_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEPB_JABU012@@Z ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::linearize_pointer<boost::cb_details::const_traits<std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ??$sub@PB_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEPB_JPB_JH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??$sub@PB_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEPB_JPB_JH@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::sub<__int64 const *>, COMDAT
; _p$ = eax
; _n$ = ecx

; 2001 :     Pointer sub(Pointer p, difference_type n) const {

	push	esi
	mov	esi, DWORD PTR _this$[esp]

; 2002 :         return p - (n > (p - m_buff) ? n - capacity() : n);

	mov	edx, DWORD PTR [esi]
	push	edi
	mov	edi, eax
	sub	edi, edx
	sar	edi, 3
	cmp	ecx, edi
	jle	SHORT $LN3@sub
	mov	esi, DWORD PTR [esi+4]
	sub	esi, edx
	sar	esi, 3
	sub	ecx, esi
$LN3@sub:
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	pop	edi
	sub	eax, ecx
	pop	esi

; 2003 :     }

	ret	4
??$sub@PB_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEPB_JPB_JH@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::sub<__int64 const *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$add@PB_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEPB_JPB_JH@Z
_TEXT	SEGMENT
??$add@PB_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEPB_JPB_JH@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::add<__int64 const *>, COMDAT
; _this$ = esi
; _p$ = edx
; _n$ = ecx

; 1996 :         return p + (n < (m_end - p) ? n : n - capacity());

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, eax
	sub	edi, edx
	sar	edi, 3
	cmp	ecx, edi
	pop	edi
	jl	SHORT $LN7@add
	sub	eax, DWORD PTR [esi]
	sar	eax, 3
	sub	ecx, eax
$LN7@add:
	lea	eax, DWORD PTR [edx+ecx*8]

; 1997 :     }

	ret	0
??$add@PB_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEPB_JPB_JH@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::add<__int64 const *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@Uforward_iterator_tag@std@@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 8
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@Uforward_iterator_tag@std@@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,std::forward_iterator_tag>, COMDAT

; 2992 : 	for (; _First1 != _Last1; ++_First1, ++_First2)

	mov	eax, DWORD PTR __First1$[esp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last1$[esp+12]
	cmp	eax, edi
	je	SHORT $LN2@Equal@4
	mov	edx, DWORD PTR __First2$[esp+8]
	mov	esi, DWORD PTR __First1$[esp+8]
	mov	ecx, DWORD PTR __First2$[esp+12]
	npad	5
$LL13@Equal@4:

; 2993 : 		if (!(*_First1 == *_First2))

	mov	ebx, DWORD PTR [eax]
	cmp	ebx, DWORD PTR [ecx]
	jne	SHORT $LN26@Equal@4
	mov	ebx, DWORD PTR [eax+4]
	cmp	ebx, DWORD PTR [ecx+4]
	jne	SHORT $LN26@Equal@4
	add	eax, 8
	mov	DWORD PTR __First1$[esp+12], eax
	cmp	eax, DWORD PTR [esi+4]
	jne	SHORT $LN10@Equal@4
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR __First1$[esp+12], eax
$LN10@Equal@4:

; 2992 : 	for (; _First1 != _Last1; ++_First1, ++_First2)

	cmp	eax, DWORD PTR [esi+12]
	jne	SHORT $LN7@Equal@4
	xor	eax, eax
	mov	DWORD PTR __First1$[esp+12], eax
$LN7@Equal@4:
	add	ecx, 8
	mov	DWORD PTR __First2$[esp+12], ecx
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN16@Equal@4
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __First2$[esp+12], ecx
$LN16@Equal@4:
	cmp	ecx, DWORD PTR [edx+12]
	jne	SHORT $LN27@Equal@4
	xor	ecx, ecx
	mov	DWORD PTR __First2$[esp+12], ecx
$LN27@Equal@4:
	cmp	eax, edi
	jne	SHORT $LL13@Equal@4
$LN2@Equal@4:
	pop	edi
	pop	esi

; 2995 : 	return (true);

	mov	al, 1
	pop	ebx

; 2996 : 	}

	ret	0
$LN26@Equal@4:
	pop	edi
	pop	esi

; 2994 : 			return (false);

	xor	al, al
	pop	ebx

; 2996 : 	}

	ret	0
??$_Equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@Uforward_iterator_tag@std@@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\details.hpp
_TEXT	ENDS
;	COMDAT ??$?GU?$const_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEHABU012@@Z
_TEXT	SEGMENT
_it$ = 8						; size = 4
??$?GU?$const_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEHABU012@@Z PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator-<boost::cb_details::const_traits<std::allocator<__int64> > >, COMDAT
; _this$ = ecx

; 279  :         BOOST_CB_ASSERT(is_valid(m_buff));    // check for uninitialized or invalidated iterator
; 280  :         BOOST_CB_ASSERT(it.is_valid(m_buff)); // check for uninitialized or invalidated iterator
; 281  :         return linearize_pointer(*this) - linearize_pointer(it);

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	push	esi
	test	eax, eax
	jne	SHORT $LN7@operator@62
	mov	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN19@operator@62
$LN7@operator@62:
	mov	edx, DWORD PTR [ecx+8]
	cmp	eax, edx
	jae	SHORT $LN5@operator@62
	mov	esi, DWORD PTR [ecx+4]
	sub	esi, edx
	sar	esi, 3
	lea	eax, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN6@operator@62
$LN5@operator@62:
	sub	eax, edx
	sar	eax, 3
$LN19@operator@62:
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*8]
$LN6@operator@62:
	mov	edx, DWORD PTR _it$[esp]
	mov	edx, DWORD PTR [edx+4]
	test	edx, edx
	jne	SHORT $LN15@operator@62
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+edx*8]
	sub	eax, ecx
	sar	eax, 3
	pop	esi

; 282  :     }

	ret	4

; 279  :         BOOST_CB_ASSERT(is_valid(m_buff));    // check for uninitialized or invalidated iterator
; 280  :         BOOST_CB_ASSERT(it.is_valid(m_buff)); // check for uninitialized or invalidated iterator
; 281  :         return linearize_pointer(*this) - linearize_pointer(it);

$LN15@operator@62:
	mov	esi, DWORD PTR [ecx+8]
	cmp	edx, esi
	jae	SHORT $LN13@operator@62
	mov	ecx, DWORD PTR [ecx+4]
	sub	ecx, esi
	sar	ecx, 3
	lea	ecx, DWORD PTR [edx+ecx*8]
	sub	eax, ecx
	sar	eax, 3
	pop	esi

; 282  :     }

	ret	4

; 279  :         BOOST_CB_ASSERT(is_valid(m_buff));    // check for uninitialized or invalidated iterator
; 280  :         BOOST_CB_ASSERT(it.is_valid(m_buff)); // check for uninitialized or invalidated iterator
; 281  :         return linearize_pointer(*this) - linearize_pointer(it);

$LN13@operator@62:
	mov	ecx, DWORD PTR [ecx]
	sub	edx, esi
	sar	edx, 3
	lea	ecx, DWORD PTR [ecx+edx*8]
	sub	eax, ecx
	sar	eax, 3
	pop	esi

; 282  :     }

	ret	4
??$?GU?$const_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEHABU012@@Z ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator-<boost::cb_details::const_traits<std::allocator<__int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Z?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@H@Z
_TEXT	SEGMENT
??Z?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@H@Z PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator-=, COMDAT
; _this$ = esi
; _n$ = eax

; 337  :         BOOST_CB_ASSERT(is_valid(m_buff)); // check for uninitialized or invalidated iterator
; 338  :         if (n > 0) {

	test	eax, eax
	jle	SHORT $LN102@operator@63

; 339  :             BOOST_CB_ASSERT(*this - m_buff->begin() >= n); // check for too large n
; 340  :             m_it = m_buff->sub(m_it == 0 ? m_buff->m_last : m_it, n);

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LN6@operator@63
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+12]
$LN6@operator@63:
	mov	edx, DWORD PTR [esi]
	push	ebx
	push	edi
	mov	edi, DWORD PTR [edx]
	mov	ebx, ecx
	sub	ebx, edi
	sar	ebx, 3
	cmp	eax, ebx
	jle	SHORT $LN10@operator@63
	mov	edx, DWORD PTR [edx+4]
	sub	edx, edi
	sar	edx, 3
	sub	eax, edx
$LN10@operator@63:
	add	eax, eax
	add	eax, eax
	add	eax, eax
	sub	ecx, eax
	pop	edi
	mov	DWORD PTR [esi+4], ecx
	pop	ebx

; 343  :         }
; 344  :         return *this;

	mov	eax, esi

; 345  :     }

	ret	0
$LN102@operator@63:

; 341  :         } else if (n < 0) {

	jge	SHORT $LN101@operator@63

; 342  :             *this += -n;

	neg	eax
	push	eax
	mov	ecx, esi
	call	??Y?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@H@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator+=
$LN101@operator@63:

; 343  :         }
; 344  :         return *this;

	mov	eax, esi

; 345  :     }

	ret	0
??Z?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@H@Z ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator-=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@H@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
??Y?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@H@Z PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator+=, COMDAT
; _this$ = ecx

; 320  :         BOOST_CB_ASSERT(is_valid(m_buff)); // check for uninitialized or invalidated iterator
; 321  :         if (n > 0) {

	mov	eax, DWORD PTR _n$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN15@operator@64

; 322  :             BOOST_CB_ASSERT(m_buff->end() - *this >= n); // check for too large n
; 323  :             m_it = m_buff->add(m_it, n);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+4]
	push	ebx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ebx, ecx
	sub	ebx, edi
	sar	ebx, 3
	cmp	eax, ebx
	jl	SHORT $LN10@operator@64
	sub	ecx, DWORD PTR [edx]
	sar	ecx, 3
	sub	eax, ecx
$LN10@operator@64:
	lea	eax, DWORD PTR [edi+eax*8]
	mov	DWORD PTR [esi+4], eax

; 324  :             if (m_it == m_buff->m_last)

	cmp	eax, DWORD PTR [edx+12]
	pop	edi
	pop	ebx

; 328  :         }
; 329  :         return *this;

	mov	eax, esi
	jne	SHORT $LN1@operator@64

; 325  :                 m_it = 0;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 330  :     }

	ret	4
$LN15@operator@64:

; 326  :         } else if (n < 0) {

	jge	SHORT $LN13@operator@64

; 327  :             *this -= -n;

	neg	eax
	call	??Z?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@H@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator-=
$LN13@operator@64:

; 328  :         }
; 329  :         return *this;

	mov	eax, esi
$LN1@operator@64:
	pop	esi

; 330  :     }

	ret	4
??Y?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@H@Z ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBE?AU012@H@Z
_TEXT	SEGMENT
$T330261 = -8						; size = 8
??H?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBE?AU012@H@Z PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator+, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = edi
; _n$ = eax

; 333  :     iterator operator + (difference_type n) const { return iterator<Buff, Traits>(*this) += n; }

	sub	esp, 8
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR $T330261[esp+12], esi
	mov	DWORD PTR $T330261[esp+16], edx
	test	eax, eax
	jle	SHORT $LN15@operator@65
	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	mov	ebx, ecx
	sub	ebx, edx
	sar	ebx, 3
	cmp	eax, ebx
	pop	ebx
	jl	SHORT $LN12@operator@65
	sub	ecx, DWORD PTR [esi]
	sar	ecx, 3
	sub	eax, ecx
$LN12@operator@65:
	lea	edx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T330261[esp+16], edx
	cmp	edx, DWORD PTR [esi+12]
	jne	SHORT $LN3@operator@65
	xor	edx, edx
	mov	DWORD PTR [edi], esi
	mov	DWORD PTR [edi+4], edx
	mov	eax, edi
	pop	esi
	add	esp, 8
	ret	0
$LN15@operator@65:
	jge	SHORT $LN3@operator@65
	neg	eax
	lea	esi, DWORD PTR $T330261[esp+12]
	call	??Z?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@H@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator-=
	mov	edx, DWORD PTR $T330261[esp+16]
	mov	esi, DWORD PTR $T330261[esp+12]
$LN3@operator@65:
	mov	DWORD PTR [edi], esi
	mov	DWORD PTR [edi+4], edx
	mov	eax, edi
	pop	esi
	add	esp, 8
	ret	0
??H?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBE?AU012@H@Z ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator+
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T330292 = -8						; size = 1
__Last2$ = -8						; size = 8
__First1$ = 8						; size = 8
__Last1$ = 16						; size = 8
$T330293 = 24						; size = 1
__First2$ = 24						; size = 8
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >, COMDAT

; 3042 : 	{

	sub	esp, 8
	push	edi

; 3043 : 	// for range checked iterators, this will make sure there is enough space
; 3044 : 	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);

	lea	eax, DWORD PTR __First1$[esp+8]
	push	eax
	lea	ecx, DWORD PTR __Last1$[esp+12]
	call	??$?GU?$const_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEHABU012@@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator-<boost::cb_details::const_traits<std::allocator<__int64> > >
	lea	edi, DWORD PTR __Last2$[esp+12]
	lea	ecx, DWORD PTR __First2$[esp+8]
	call	??H?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBE?AU012@H@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator+

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	mov	edx, DWORD PTR $T330293[esp+8]
	mov	eax, DWORD PTR __First2$[esp+12]
	mov	BYTE PTR $T330292[esp+12], 0
	mov	ecx, DWORD PTR $T330292[esp+12]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+20]
	push	eax
	mov	eax, DWORD PTR __Last1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+28]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+28]
	push	eax
	push	ecx
	push	edx
	call	??$_Equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@Uforward_iterator_tag@std@@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,std::forward_iterator_tag>
	add	esp, 32					; 00000020H
	pop	edi

; 3047 : 	}

	add	esp, 8
	ret	0
??$_Equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00@Z
_TEXT	SEGMENT
$T330347 = -32						; size = 1
$T330359 = -32						; size = 8
$T330357 = -24						; size = 8
$T330358 = -16						; size = 8
__Last2$330356 = -8					; size = 8
__First1$ = 8						; size = 8
__Last1$ = 16						; size = 8
$T330348 = 24						; size = 1
__First2$ = 24						; size = 8
??$equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00@Z PROC ; std::equal<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >, COMDAT

; 3072 : 	{	// compare [_First1, _Last1) to [First2, ...)

	sub	esp, 32					; 00000020H

; 3073 : 	return _Equal(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _First2,
; 3074 : 		_Iter_random(_First1, _First2), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last1$[esp+32]
	mov	ecx, DWORD PTR __First1$[esp+28]
	mov	edx, DWORD PTR __First1$[esp+32]
	push	ebx
	mov	ebx, DWORD PTR __First2$[esp+36]
	push	ebp
	mov	ebp, DWORD PTR __Last1$[esp+36]
	push	esi
	mov	esi, DWORD PTR __First2$[esp+40]
	mov	DWORD PTR $T330358[esp+48], eax
	push	edi
	lea	eax, DWORD PTR $T330357[esp+48]
	mov	DWORD PTR $T330357[esp+48], ecx
	push	eax
	lea	ecx, DWORD PTR $T330358[esp+52]
	mov	DWORD PTR $T330359[esp+52], esi
	mov	DWORD PTR $T330359[esp+56], ebx
	mov	DWORD PTR $T330358[esp+52], ebp
	mov	DWORD PTR $T330357[esp+56], edx
	call	??$?GU?$const_traits@V?$allocator@_J@std@@@cb_details@boost@@@?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBEHABU012@@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator-<boost::cb_details::const_traits<std::allocator<__int64> > >
	lea	edi, DWORD PTR __Last2$330356[esp+48]
	lea	ecx, DWORD PTR $T330359[esp+48]
	call	??H?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QBE?AU012@H@Z ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >::operator+
	mov	edx, DWORD PTR $T330348[esp+44]
	mov	eax, DWORD PTR $T330358[esp+52]
	mov	BYTE PTR $T330347[esp+48], 0
	mov	ecx, DWORD PTR $T330347[esp+48]
	push	ecx
	mov	ecx, DWORD PTR $T330357[esp+56]
	push	edx
	mov	edx, DWORD PTR $T330357[esp+56]
	push	ebx
	push	esi
	push	eax
	push	ebp
	push	ecx
	push	edx
	call	??$_Equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@Uforward_iterator_tag@std@@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,std::forward_iterator_tag>
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3075 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00@Z ENDP ; std::equal<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@VBank@DRAMsimII@@@std@@YAPAVBank@DRAMsimII@@IPAV12@@Z
_TEXT	SEGMENT
$T330373 = -16						; size = 4
$T330365 = -12						; size = 12
??$_Allocate@VBank@DRAMsimII@@@std@@YAPAVBank@DRAMsimII@@IPAV12@@Z PROC ; std::_Allocate<DRAMsimII::Bank>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 152				; 00000098H
	jae	SHORT $LN1@Allocate@13

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T330373[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T330365[esp+20]
	mov	DWORD PTR $T330373[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T330365[esp+20]
	push	ecx
	mov	DWORD PTR $T330365[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@13:
$LN1@Allocate@13:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	imul	ecx, 152				; 00000098H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@13:
??$_Allocate@VBank@DRAMsimII@@@std@@YAPAVBank@DRAMsimII@@IPAV12@@Z ENDP ; std::_Allocate<DRAMsimII::Bank>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Construct@_J_J@std@@YAXPA_JAB_J@Z
_TEXT	SEGMENT
??$_Construct@_J_J@std@@YAXPA_JAB_J@Z PROC		; std::_Construct<__int64,__int64>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@11
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct@11:

; 53   : 	}

	ret	0
??$_Construct@_J_J@std@@YAXPA_JAB_J@Z ENDP		; std::_Construct<__int64,__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@VBank@DRAMsimII@@@std@@QAEPAVBank@DRAMsimII@@I@Z
_TEXT	SEGMENT
$T330393 = -16						; size = 4
$T330395 = -12						; size = 12
?allocate@?$allocator@VBank@DRAMsimII@@@std@@QAEPAVBank@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::Bank>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@5
	xor	ecx, ecx
$LN3@allocate@5:
	imul	ecx, 152				; 00000098H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@5:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 152				; 00000098H
	jae	SHORT $LN3@allocate@5
	lea	eax, DWORD PTR $T330393[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T330395[esp+20]
	mov	DWORD PTR $T330393[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T330395[esp+20]
	push	ecx
	mov	DWORD PTR $T330395[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@5:
$LN11@allocate@5:
	int	3
?allocate@?$allocator@VBank@DRAMsimII@@@std@@QAEPAVBank@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::Bank>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?max_size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::max_size, COMDAT

; 767  :         return (std::min<size_type>)(m_alloc.max_size(), (std::numeric_limits<difference_type>::max)());

	mov	eax, 536870911				; 1fffffffH

; 768  :     }

	ret	0
?max_size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\details.hpp
_TEXT	ENDS
;	COMDAT ??E?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@XZ
_TEXT	SEGMENT
??E?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@XZ PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::operator++, COMDAT
; _this$ = eax

; 286  :         BOOST_CB_ASSERT(is_valid(m_buff)); // check for uninitialized or invalidated iterator
; 287  :         BOOST_CB_ASSERT(m_it != 0);        // check for iterator pointing to end()
; 288  :         m_buff->increment(m_it);

	mov	ecx, DWORD PTR [eax]
	add	DWORD PTR [eax+4], 8
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@operator@66
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
$LN4@operator@66:

; 289  :         if (m_it == m_buff->m_last)

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [edx+12]
	jne	SHORT $LN1@operator@66

; 290  :             m_it = 0;

	mov	DWORD PTR [eax+4], 0
$LN1@operator@66:

; 291  :         return *this;
; 292  :     }

	ret	0
??E?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAEAAU012@XZ ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::operator++
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@_J@std@@QAEXPA_JAB_J@Z
_TEXT	SEGMENT
?construct@?$allocator@_J@std@@QAEXPA_JAB_J@Z PROC	; std::allocator<__int64>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@11
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct@11:

; 156  : 		}

	ret	0
?construct@?$allocator@_J@std@@QAEXPA_JAB_J@Z ENDP	; std::allocator<__int64>::construct
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?full@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE_NXZ
_TEXT	SEGMENT
?full@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE_NXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::full, COMDAT
; _this$ = eax

; 798  :     bool full() const { return capacity() == size(); }

	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	xor	edx, edx
	sar	ecx, 3
	cmp	ecx, DWORD PTR [eax+16]
	sete	dl
	mov	al, dl
	ret	0
?full@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE_NXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::full
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?empty@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE_NXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::empty, COMDAT
; _this$ = ecx

; 783  :     bool empty() const { return size() == 0; }

	xor	eax, eax
	cmp	DWORD PTR [ecx+16], eax
	sete	al
	ret	0
?empty@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE_NXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::empty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ
_TEXT	SEGMENT
?begin@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::begin, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 264  :     const_iterator begin() const { return const_iterator(this, empty() ? 0 : m_first); }

	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN3@begin@6
	xor	ecx, ecx
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	ret	0
$LN3@begin@6:
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	ret	0
?begin@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_allocator@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE?AV?$allocator@_J@std@@XZ
_TEXT	SEGMENT
?get_allocator@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE?AV?$allocator@_J@std@@XZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::get_allocator, COMDAT
; ___$ReturnUdt$ = eax

; 198  :     allocator_type get_allocator() const { return m_alloc; }

	ret	0
?get_allocator@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBE?AV?$allocator@_J@std@@XZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::get_allocator
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\details.hpp
_TEXT	ENDS
;	COMDAT ??E?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE?AU012@H@Z
_TEXT	SEGMENT
??E?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE?AU012@H@Z PROC ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::operator++, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 296  :         iterator<Buff, Traits> tmp = *this;

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [ecx+4]

; 297  :         ++*this;

	add	DWORD PTR [ecx+4], 8
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	cmp	esi, DWORD PTR [edx+4]
	jne	SHORT $LN8@operator@67
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
$LN8@operator@67:
	mov	esi, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx]
	cmp	esi, DWORD PTR [edx+12]
	pop	esi
	jne	SHORT $LN5@operator@67
	mov	DWORD PTR [ecx+4], 0
$LN5@operator@67:

; 298  :         return tmp;
; 299  :     }

	ret	0
??E?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@QAE?AU012@H@Z ENDP ; boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::nonconst_traits<std::allocator<__int64> > >::operator++
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?push_front@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEXAB_J@Z
_TEXT	SEGMENT
?push_front@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEXAB_J@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::push_front, COMDAT
; _this$ = eax
; _item$ = edi

; 1425 :         BOOST_TRY {
; 1426 :             if (full()) {

	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	push	ebx
	mov	ebx, edx
	sub	ebx, ecx
	push	esi
	mov	esi, DWORD PTR [eax+16]
	sar	ebx, 3
	cmp	ebx, esi
	jne	SHORT $LN3@push_front

; 1427 :                 if (empty())

	test	esi, esi
	je	SHORT $LN1@push_front

; 1428 :                     return;
; 1429 :                 decrement(m_first);

	cmp	DWORD PTR [eax+8], ecx
	jne	SHORT $LN21@push_front
	mov	DWORD PTR [eax+8], edx
$LN21@push_front:
	add	DWORD PTR [eax+8], -8			; fffffff8H

; 1430 :                 replace(m_first, item);

	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+4], edx

; 1431 :                 m_last = m_first;

	mov	ecx, DWORD PTR [eax+8]
	pop	esi
	mov	DWORD PTR [eax+12], ecx
	pop	ebx

; 1436 :             }
; 1437 :         } BOOST_CATCH(...) {
; 1438 :             increment(m_first);
; 1439 :             BOOST_RETHROW
; 1440 :         }
; 1441 :         BOOST_CATCH_END
; 1442 :     }

	ret	0
$LN3@push_front:

; 1432 :             } else {
; 1433 :                 decrement(m_first);

	cmp	DWORD PTR [eax+8], ecx
	jne	SHORT $LN26@push_front
	mov	DWORD PTR [eax+8], edx
$LN26@push_front:
	add	DWORD PTR [eax+8], -8			; fffffff8H

; 1434 :                 m_alloc.construct(m_first, item);

	mov	ecx, DWORD PTR [eax+8]
	je	SHORT $LN33@push_front
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+4], edx
$LN33@push_front:

; 1435 :                 ++m_size;

	inc	DWORD PTR [eax+16]
$LN1@push_front:
	pop	esi
	pop	ebx

; 1436 :             }
; 1437 :         } BOOST_CATCH(...) {
; 1438 :             increment(m_first);
; 1439 :             BOOST_RETHROW
; 1440 :         }
; 1441 :         BOOST_CATCH_END
; 1442 :     }

	ret	0
?push_front@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEXAB_J@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::push_front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ
_TEXT	SEGMENT
?begin@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::begin, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 232  :     iterator begin() { return iterator(this, empty() ? 0 : m_first); }

	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN3@begin@7
	xor	ecx, ecx
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	ret	0
$LN3@begin@7:
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	ret	0
?begin@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE?AU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$nonconst_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@2@XZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::begin
_TEXT	ENDS
PUBLIC	?getPrechargeTime@Rank@DRAMsimII@@QBE_J_J@Z	; DRAMsimII::Rank::getPrechargeTime
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\rank.cpp
_TEXT	SEGMENT
$T330621 = -16						; size = 8
$T330622 = -8						; size = 8
_currentTime$ = 8					; size = 8
?getPrechargeTime@Rank@DRAMsimII@@QBE_J_J@Z PROC	; DRAMsimII::Rank::getPrechargeTime
; _this$ = esi

; 416  : 	return prechargeTime + ((banksPrecharged == bank.size()) ? max(currentTime - max(lastPrechargeAnyBankTime, lastCalculationTime), (tick)0) : 0);

	mov	ecx, DWORD PTR [esi+188]
	sub	ecx, DWORD PTR [esi+184]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	sub	esp, 16					; 00000010H
	shr	eax, 31					; 0000001fH
	push	edi
	add	eax, edx
	xor	edi, edi
	cmp	DWORD PTR [esi+144], eax
	jne	SHORT $LN3@getPrechar
	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, DWORD PTR [esi+108]
	lea	edx, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [esi+104]
	mov	DWORD PTR $T330621[esp+20], edi
	mov	DWORD PTR $T330621[esp+24], edi
	jg	SHORT $LN9@getPrechar
	jl	SHORT $LN15@getPrechar
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN9@getPrechar
$LN15@getPrechar:
	mov	edx, eax
$LN9@getPrechar:
	mov	ecx, DWORD PTR _currentTime$[esp+16]
	sub	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _currentTime$[esp+20]
	sbb	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T330622[esp+20], ecx
	cmp	eax, edi
	mov	DWORD PTR $T330622[esp+24], eax
	jg	SHORT $LN13@getPrechar
	jl	SHORT $LN16@getPrechar
	cmp	ecx, edi
	jae	SHORT $LN13@getPrechar
$LN16@getPrechar:
	mov	edx, DWORD PTR [esi+60]
	lea	eax, DWORD PTR $T330621[esp+20]
	mov	edi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+56]
	add	eax, ecx
	adc	edx, edi

; 417  : }

	pop	edi
	add	esp, 16					; 00000010H
	ret	8

; 416  : 	return prechargeTime + ((banksPrecharged == bank.size()) ? max(currentTime - max(lastPrechargeAnyBankTime, lastCalculationTime), (tick)0) : 0);

$LN13@getPrechar:
	mov	edx, DWORD PTR [esi+60]
	lea	eax, DWORD PTR $T330622[esp+20]
	mov	edi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+56]
	add	eax, ecx
	adc	edx, edi

; 417  : }

	pop	edi
	add	esp, 16					; 00000010H
	ret	8
$LN3@getPrechar:

; 416  : 	return prechargeTime + ((banksPrecharged == bank.size()) ? max(currentTime - max(lastPrechargeAnyBankTime, lastCalculationTime), (tick)0) : 0);

	mov	eax, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [esi+60]
	xor	ecx, ecx
	add	eax, ecx
	adc	edx, edi

; 417  : }

	pop	edi
	add	esp, 16					; 00000010H
	ret	8
?getPrechargeTime@Rank@DRAMsimII@@QBE_J_J@Z ENDP	; DRAMsimII::Rank::getPrechargeTime
_TEXT	ENDS
PUBLIC	?getTotalPrechargeTime@Rank@DRAMsimII@@QBE_J_J@Z ; DRAMsimII::Rank::getTotalPrechargeTime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T330652 = -16						; size = 8
$T330653 = -8						; size = 8
_currentTime$ = 8					; size = 8
?getTotalPrechargeTime@Rank@DRAMsimII@@QBE_J_J@Z PROC	; DRAMsimII::Rank::getTotalPrechargeTime
; _this$ = esi

; 407  : 	return totalPrechargeTime + ((banksPrecharged == bank.size()) ? max(currentTime - max(lastPrechargeAnyBankTime, lastCalculationTime), (tick)0) : 0);

	mov	ecx, DWORD PTR [esi+188]
	sub	ecx, DWORD PTR [esi+184]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	sub	esp, 16					; 00000010H
	shr	eax, 31					; 0000001fH
	push	edi
	add	eax, edx
	xor	edi, edi
	cmp	DWORD PTR [esi+144], eax
	jne	SHORT $LN3@getTotalPr
	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, DWORD PTR [esi+108]
	lea	edx, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [esi+104]
	mov	DWORD PTR $T330652[esp+20], edi
	mov	DWORD PTR $T330652[esp+24], edi
	jg	SHORT $LN9@getTotalPr
	jl	SHORT $LN15@getTotalPr
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN9@getTotalPr
$LN15@getTotalPr:
	mov	edx, eax
$LN9@getTotalPr:
	mov	ecx, DWORD PTR _currentTime$[esp+16]
	sub	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _currentTime$[esp+20]
	sbb	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T330653[esp+20], ecx
	cmp	eax, edi
	mov	DWORD PTR $T330653[esp+24], eax
	jg	SHORT $LN13@getTotalPr
	jl	SHORT $LN16@getTotalPr
	cmp	ecx, edi
	jae	SHORT $LN13@getTotalPr
$LN16@getTotalPr:
	mov	edx, DWORD PTR [esi+68]
	lea	eax, DWORD PTR $T330652[esp+20]
	mov	edi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+64]
	add	eax, ecx
	adc	edx, edi
	pop	edi

; 408  : }

	add	esp, 16					; 00000010H
	ret	8

; 407  : 	return totalPrechargeTime + ((banksPrecharged == bank.size()) ? max(currentTime - max(lastPrechargeAnyBankTime, lastCalculationTime), (tick)0) : 0);

$LN13@getTotalPr:
	mov	edx, DWORD PTR [esi+68]
	lea	eax, DWORD PTR $T330653[esp+20]
	mov	edi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+64]
	add	eax, ecx
	adc	edx, edi
	pop	edi

; 408  : }

	add	esp, 16					; 00000010H
	ret	8
$LN3@getTotalPr:

; 407  : 	return totalPrechargeTime + ((banksPrecharged == bank.size()) ? max(currentTime - max(lastPrechargeAnyBankTime, lastCalculationTime), (tick)0) : 0);

	mov	eax, DWORD PTR [esi+64]
	mov	edx, DWORD PTR [esi+68]
	xor	ecx, ecx
	add	eax, ecx
	adc	edx, edi
	pop	edi

; 408  : }

	add	esp, 16					; 00000010H
	ret	8
?getTotalPrechargeTime@Rank@DRAMsimII@@QBE_J_J@Z ENDP	; DRAMsimII::Rank::getTotalPrechargeTime
_TEXT	ENDS
PUBLIC	?issueCASWother@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issueCASWother
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T330684 = -8						; size = 8
$T330683 = -8						; size = 8
_this$ = 8						; size = 4
_currentTime$ = 12					; size = 8
?issueCASWother@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z PROC ; DRAMsimII::Rank::issueCASWother
; _currentCommand$ = ecx

; 287  : {

	sub	esp, 8

; 288  : 	assert(currentTime + timing.tAL() > otherLastCASWTime);
; 289  : 	otherLastCASWTime = currentTime;

	mov	eax, DWORD PTR _currentTime$[esp+8]
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+8]
	mov	DWORD PTR [ebx+52], eax
	push	ebp
	mov	ebp, DWORD PTR _currentTime$[esp+12]
	mov	DWORD PTR [ebx+48], ebp

; 290  : 	otherLastCASWLength = currentCommand->getLength();

	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [ebx+124], edx
	push	esi

; 291  : 
; 292  : 	// calculate when the next few commands can happen
; 293  : 	nextReadTime = max(nextReadTime, currentTime + timing.tCWD() + timing.tBurst() + timing.tRTRS() - timing.tCAS());

	mov	esi, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+56]
	cdq
	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, edx
	cdq
	sub	edi, eax
	mov	eax, DWORD PTR [esi+20]
	sbb	ecx, edx
	cdq
	add	edi, eax
	mov	eax, DWORD PTR [esi+4]
	adc	ecx, edx
	cdq
	add	edi, eax
	adc	ecx, edx
	mov	edx, DWORD PTR [ebx+84]
	add	edi, ebp
	adc	ecx, DWORD PTR _currentTime$[esp+24]
	lea	eax, DWORD PTR [ebx+80]
	cmp	edx, ecx
	mov	DWORD PTR $T330683[esp+24], edi
	mov	DWORD PTR $T330683[esp+28], ecx
	jg	SHORT $LN15@issueCASWo
	jl	SHORT $LN25@issueCASWo
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, edi
	jae	SHORT $LN15@issueCASWo
$LN25@issueCASWo:
	lea	ecx, DWORD PTR $T330683[esp+24]
	jmp	SHORT $LN16@issueCASWo
$LN15@issueCASWo:
	mov	ecx, eax
$LN16@issueCASWo:
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 294  : 	nextWriteTime = max(nextWriteTime, currentTime + timing.tOST() + timing.tBurst());

	mov	eax, DWORD PTR [esi+68]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, edx
	cdq
	add	edi, eax
	adc	ecx, edx
	mov	edx, DWORD PTR [ebx+92]
	add	edi, ebp
	adc	ecx, DWORD PTR _currentTime$[esp+24]
	lea	eax, DWORD PTR [ebx+88]
	cmp	edx, ecx
	mov	DWORD PTR $T330684[esp+24], edi
	mov	DWORD PTR $T330684[esp+28], ecx
	jg	SHORT $LN23@issueCASWo
	jl	SHORT $LN26@issueCASWo
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, edi
	jae	SHORT $LN23@issueCASWo
$LN26@issueCASWo:
	lea	ecx, DWORD PTR $T330684[esp+24]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 295  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH

; 294  : 	nextWriteTime = max(nextWriteTime, currentTime + timing.tOST() + timing.tBurst());

$LN23@issueCASWo:
	mov	ecx, eax
	mov	edx, DWORD PTR [ecx]

; 295  : }

	pop	edi
	pop	esi
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	pop	ebp
	mov	DWORD PTR [eax+4], ecx
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH
?issueCASWother@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ENDP ; DRAMsimII::Rank::issueCASWother
_TEXT	ENDS
PUBLIC	?issueCASother@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issueCASother
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
tv94 = -8						; size = 4
$T330737 = -8						; size = 8
$T330736 = -8						; size = 8
tv150 = 8						; size = 4
_this$ = 8						; size = 4
_currentTime$ = 12					; size = 8
?issueCASother@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z PROC ; DRAMsimII::Rank::issueCASother
; _currentCommand$ = ecx

; 273  : {

	sub	esp, 8

; 274  : 	assert(currentTime + timing.tAL() > otherLastCASTime); 
; 275  : 	otherLastCASTime = currentTime; 

	mov	eax, DWORD PTR _currentTime$[esp+8]
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+8]
	mov	DWORD PTR [ebx+44], eax
	push	ebp
	mov	ebp, DWORD PTR _currentTime$[esp+12]
	mov	DWORD PTR [ebx+40], ebp

; 276  : 	otherLastCASLength = currentCommand->getLength();

	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [ebx+120], edx
	push	esi

; 277  : 
; 278  : 	// calculate when the next few commands can happen
; 279  : 	nextReadTime = max(nextReadTime, currentTime + timing.tBurst() + timing.tRTRS());

	mov	esi, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+56]
	cdq
	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, edx
	cdq
	add	edi, eax
	adc	ecx, edx
	mov	edx, DWORD PTR [ebx+84]
	add	edi, ebp
	adc	ecx, DWORD PTR _currentTime$[esp+24]
	lea	eax, DWORD PTR [ebx+80]
	cmp	edx, ecx
	mov	DWORD PTR $T330736[esp+24], edi
	mov	DWORD PTR $T330736[esp+28], ecx
	jg	SHORT $LN11@issueCASot
	jl	SHORT $LN25@issueCASot
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, edi
	jae	SHORT $LN11@issueCASot
$LN25@issueCASot:
	lea	ecx, DWORD PTR $T330736[esp+24]
	jmp	SHORT $LN12@issueCASot
$LN11@issueCASot:
	mov	ecx, eax
$LN12@issueCASot:
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 280  : 	nextWriteTime = max(nextWriteTime, currentTime + timing.tCAS() + timing.tBurst() + timing.tRTRS() - timing.tCWD());

	mov	eax, DWORD PTR [esi+20]
	cdq
	mov	DWORD PTR tv150[esp+20], eax
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, edx
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR tv150[esp+20]
	sub	edi, eax
	mov	eax, ecx
	mov	ecx, edx
	sbb	ecx, eax
	mov	eax, DWORD PTR [esi+56]
	cdq
	add	edi, eax
	mov	eax, DWORD PTR [esi+4]
	adc	ecx, edx
	cdq
	add	edi, eax
	adc	ecx, edx
	mov	edx, DWORD PTR [ebx+92]
	add	edi, ebp
	adc	ecx, DWORD PTR _currentTime$[esp+24]
	lea	eax, DWORD PTR [ebx+88]
	cmp	edx, ecx
	mov	DWORD PTR $T330737[esp+24], edi
	mov	DWORD PTR $T330737[esp+28], ecx
	jg	SHORT $LN23@issueCASot
	jl	SHORT $LN26@issueCASot
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, edi
	jae	SHORT $LN23@issueCASot
$LN26@issueCASot:
	lea	ecx, DWORD PTR $T330737[esp+24]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 281  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH

; 280  : 	nextWriteTime = max(nextWriteTime, currentTime + timing.tCAS() + timing.tBurst() + timing.tRTRS() - timing.tCWD());

$LN23@issueCASot:
	mov	ecx, eax
	mov	edx, DWORD PTR [ecx]

; 281  : }

	pop	edi
	pop	esi
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	pop	ebp
	mov	DWORD PTR [eax+4], ecx
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH
?issueCASother@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ENDP ; DRAMsimII::Rank::issueCASother
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\details.hpp
;	COMDAT ??$uninitialized_fill_n_with_alloc@PA_JI_JV?$allocator@_J@std@@@cb_details@boost@@YAXPA_JIAB_JAAV?$allocator@_J@std@@@Z
_TEXT	SEGMENT
_first$ = 8						; size = 4
??$uninitialized_fill_n_with_alloc@PA_JI_JV?$allocator@_J@std@@@cb_details@boost@@YAXPA_JIAB_JAAV?$allocator@_J@std@@@Z PROC ; boost::cb_details::uninitialized_fill_n_with_alloc<__int64 *,unsigned int,__int64,std::allocator<__int64> >, COMDAT
; _n$ = ecx
; _item$ = edx

; 453  : inline void uninitialized_fill_n_with_alloc(ForwardIterator first, Diff n, const T& item, Alloc& alloc) {

	mov	eax, DWORD PTR _first$[esp-4]

; 454  :     ForwardIterator next = first;
; 455  :     BOOST_TRY {
; 456  :         for (; n > 0; ++first, --n)

	test	ecx, ecx
	jbe	SHORT $LN4@uninitiali
	push	esi
	npad	7
$LL6@uninitiali:

; 457  :             alloc.construct(first, item);

	test	eax, eax
	je	SHORT $LN5@uninitiali
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@uninitiali:
	add	eax, 8
	sub	ecx, 1
	jne	SHORT $LL6@uninitiali
	pop	esi
$LN4@uninitiali:

; 458  :     } BOOST_CATCH(...) {
; 459  :         for (; next != first; ++next)
; 460  :             alloc.destroy(next);
; 461  :         BOOST_RETHROW
; 462  :     }
; 463  :     BOOST_CATCH_END
; 464  : }

	ret	0
??$uninitialized_fill_n_with_alloc@PA_JI_JV?$allocator@_J@std@@@cb_details@boost@@YAXPA_JIAB_JAAV?$allocator@_J@std@@@Z ENDP ; boost::cb_details::uninitialized_fill_n_with_alloc<__int64 *,unsigned int,__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$uninitialized_copy_with_alloc@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@PA_JV?$allocator@_J@std@@@cb_details@boost@@YAPA_JU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@01@0PA_JAAV?$allocator@_J@std@@@Z
_TEXT	SEGMENT
_first$ = 8						; size = 8
_last$ = 16						; size = 8
??$uninitialized_copy_with_alloc@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@PA_JV?$allocator@_J@std@@@cb_details@boost@@YAPA_JU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@01@0PA_JAAV?$allocator@_J@std@@@Z PROC ; boost::cb_details::uninitialized_copy_with_alloc<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,__int64 *,std::allocator<__int64> >, COMDAT
; _dest$ = eax

; 435  :     ForwardIterator next = dest;
; 436  :     BOOST_TRY {
; 437  :         for (; first != last; ++first, ++dest)

	mov	ecx, DWORD PTR _first$[esp]
	push	esi
	mov	esi, DWORD PTR _last$[esp+4]
	cmp	ecx, esi
	je	SHORT $LN4@uninitiali@2
	mov	edx, DWORD PTR _first$[esp]
	push	edi
$LL6@uninitiali@2:

; 438  :             alloc.construct(dest, *first);

	test	eax, eax
	je	SHORT $LN5@uninitiali@2
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
$LN5@uninitiali@2:
	add	ecx, 8
	mov	DWORD PTR _first$[esp+8], ecx
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN17@uninitiali@2
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR _first$[esp+8], ecx
$LN17@uninitiali@2:

; 435  :     ForwardIterator next = dest;
; 436  :     BOOST_TRY {
; 437  :         for (; first != last; ++first, ++dest)

	cmp	ecx, DWORD PTR [edx+12]
	jne	SHORT $LN14@uninitiali@2
	xor	ecx, ecx
	mov	DWORD PTR _first$[esp+8], ecx
$LN14@uninitiali@2:
	add	eax, 8
	cmp	ecx, esi
	jne	SHORT $LL6@uninitiali@2
	pop	edi
$LN4@uninitiali@2:
	pop	esi

; 439  :     } BOOST_CATCH(...) {
; 440  :         for (; next != dest; ++next)
; 441  :             alloc.destroy(next);
; 442  :         BOOST_RETHROW
; 443  :     }
; 444  :     BOOST_CATCH_END
; 445  :     return dest;
; 446  : }

	ret	0
??$uninitialized_copy_with_alloc@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@PA_JV?$allocator@_J@std@@@cb_details@boost@@YAPA_JU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@01@0PA_JAAV?$allocator@_J@std@@@Z ENDP ; boost::cb_details::uninitialized_copy_with_alloc<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,__int64 *,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ??$?8_JV?$allocator@_J@std@@@boost@@YA_NABV?$circular_buffer@_JV?$allocator@_J@std@@@0@0@Z
_TEXT	SEGMENT
??$?8_JV?$allocator@_J@std@@@boost@@YA_NABV?$circular_buffer@_JV?$allocator@_J@std@@@0@0@Z PROC ; boost::operator==<__int64,std::allocator<__int64> >, COMDAT
; _lhs$ = ecx
; _rhs$ = esi

; 2587 :     return lhs.size() == rhs.size() && std::equal(lhs.begin(), lhs.end(), rhs.begin());

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [esi+16]
	cmp	edx, eax
	jne	SHORT $LN3@operator@163
	push	ebx
	push	edi
	test	eax, eax
	jne	SHORT $LN11@operator@163
	xor	ebx, ebx
	jmp	SHORT $LN12@operator@163
$LN11@operator@163:
	mov	ebx, DWORD PTR [esi+8]
$LN12@operator@163:
	xor	edi, edi
	test	edx, edx
	jne	SHORT $LN25@operator@163
	xor	eax, eax
	jmp	SHORT $LN26@operator@163
$LN25@operator@163:
	mov	eax, DWORD PTR [ecx+8]
$LN26@operator@163:
	push	ebx
	push	esi
	push	edi
	push	ecx
	push	eax
	push	ecx
	call	??$equal@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@U123@@std@@YA_NU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@00@Z ; std::equal<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > > >
	add	esp, 24					; 00000018H
	pop	edi
	pop	ebx
	test	al, al
	je	SHORT $LN3@operator@163
	mov	eax, 1

; 2588 : }

	ret	0
$LN3@operator@163:

; 2587 :     return lhs.size() == rhs.size() && std::equal(lhs.begin(), lhs.end(), rhs.begin());

	xor	eax, eax

; 2588 : }

	ret	0
??$?8_JV?$allocator@_J@std@@@boost@@YA_NABV?$circular_buffer@_JV?$allocator@_J@std@@@0@0@Z ENDP ; boost::operator==<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VBank@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VBank@DRAMsimII@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@14
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@14:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VBank@DRAMsimII@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_J@std@@QAEPA_JIPBX@Z
_TEXT	SEGMENT
?allocate@?$allocator@_J@std@@QAEPA_JIPBX@Z PROC	; std::allocator<__int64>::allocate, COMDAT
; __Count$ = ecx

; 150  : 		return (allocate(_Count));

	jmp	?allocate@?$allocator@_J@std@@QAEPA_JI@Z ; std::allocator<__int64>::allocate
?allocate@?$allocator@_J@std@@QAEPA_JIPBX@Z ENDP	; std::allocator<__int64>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VBank@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VBank@DRAMsimII@@@1@@Z PROC ; std::_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@8
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@8:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VBank@DRAMsimII@@@1@@Z ENDP ; std::_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?reset@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_J0I@Z
_TEXT	SEGMENT
_last$ = 8						; size = 4
_new_capacity$ = 12					; size = 4
?reset@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_J0I@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::reset, COMDAT
; _this$ = esi
; _buff$ = edi

; 2221 :         destroy();

	xor	ecx, ecx
	push	ebx
	mov	ebx, DWORD PTR _last$[esp]
	cmp	DWORD PTR [esi+16], ecx
	jbe	SHORT $LN7@reset@9
	mov	edx, 8
$LL12@reset@9:
	add	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [esi+8]
	inc	ecx
	cmp	eax, DWORD PTR [esi+4]
	jne	SHORT $LN25@reset@9
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+8], eax
$LN25@reset@9:
	cmp	ecx, DWORD PTR [esi+16]
	jb	SHORT $LL12@reset@9
$LN7@reset@9:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN22@reset@9
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN22@reset@9:

; 2222 :         m_size = last - buff;
; 2223 :         m_first = m_buff = buff;
; 2224 :         m_end = m_buff + new_capacity;

	mov	edx, DWORD PTR _new_capacity$[esp]
	mov	ecx, ebx
	sub	ecx, edi
	lea	eax, DWORD PTR [edi+edx*8]
	sar	ecx, 3
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+4], eax

; 2225 :         m_last = last == m_end ? m_buff : last;

	cmp	ebx, eax
	jne	SHORT $LN3@reset@9
	mov	DWORD PTR [esi+12], edi
	pop	ebx

; 2226 :     }

	ret	8
$LN3@reset@9:

; 2225 :         m_last = last == m_end ? m_buff : last;

	mov	DWORD PTR [esi+12], ebx
	pop	ebx

; 2226 :     }

	ret	8
?reset@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_J0I@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::reset
_TEXT	ENDS
PUBLIC	?issueCASW@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issueCASW
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\rank.cpp
_TEXT	SEGMENT
$T380564 = -8						; size = 8
$T380565 = 8						; size = 8
_currentTime$ = 8					; size = 8
?issueCASW@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z PROC	; DRAMsimII::Rank::issueCASW
; _this$ = ecx
; _currentCommand$ = eax

; 234  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 235  : 	// update the bank to reflect this change also
; 236  : 	bank[currentCommand->getAddress().getBank()].issueCASW(currentTime, currentCommand);

	mov	ecx, DWORD PTR [esi+188]
	sub	ecx, DWORD PTR [esi+184]
	push	edi
	mov	edi, eax
	mov	ebx, DWORD PTR [edi+64]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	jb	SHORT $LN7@issueCASW@2
	call	__invalid_parameter_noinfo
$LN7@issueCASW@2:
	mov	ebp, DWORD PTR _currentTime$[esp+28]
	mov	ecx, DWORD PTR _currentTime$[esp+24]
	push	ebp
	push	ecx
	mov	ecx, ebx
	imul	ecx, 152				; 00000098H
	add	ecx, DWORD PTR [esi+184]
	mov	edx, edi
	call	?issueCASW@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Bank::issueCASW

; 237  : 
; 238  : 	lastCASWTime = currentTime;

	mov	edx, DWORD PTR _currentTime$[esp+24]

; 239  : 
; 240  : 	lastCASWLength = currentCommand->getLength();
; 241  : 
; 242  : 	CASWLength += currentCommand->getLength();
; 243  : 
; 244  : 	assert(currentCommand->getAddress().getBank() == lastBankID);
; 245  : 	
; 246  : 	// calculate when the next few commands can happen
; 247  : 	// ensure that the next read does not happen until the write is done with the I/O drivers
; 248  : 	nextReadTime = max(nextReadTime, currentTime + timing.tCWD() + timing.tBurst() + timing.tWTR());

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR [esi+32], edx
	mov	DWORD PTR [esi+36], ebp
	mov	eax, DWORD PTR [edi+88]
	mov	DWORD PTR [esi+116], eax
	mov	ecx, DWORD PTR [edi+88]
	add	DWORD PTR [esi+132], ecx
	mov	eax, DWORD PTR [ebx+64]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, edx
	cdq
	add	edi, eax
	mov	eax, DWORD PTR [ebx+4]
	adc	ecx, edx
	cdq
	add	edi, eax
	adc	ecx, edx
	add	edi, DWORD PTR _currentTime$[esp+24]
	mov	edx, DWORD PTR [esi+84]
	lea	eax, DWORD PTR [esi+80]
	adc	ecx, ebp
	cmp	edx, ecx
	mov	DWORD PTR $T380564[esp+28], edi
	mov	DWORD PTR $T380564[esp+32], ecx
	jg	SHORT $LN24@issueCASW@2
	jl	SHORT $LN32@issueCASW@2
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, edi
	jae	SHORT $LN24@issueCASW@2
$LN32@issueCASW@2:
	lea	ecx, DWORD PTR $T380564[esp+28]
	jmp	SHORT $LN25@issueCASW@2
$LN24@issueCASW@2:
	mov	ecx, eax
$LN25@issueCASW@2:
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 249  : 
; 250  : 	nextWriteTime = max(nextWriteTime, currentTime + timing.tBurst());

	mov	eax, DWORD PTR [ebx+4]
	cdq
	add	eax, DWORD PTR _currentTime$[esp+24]
	lea	ecx, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [ecx+4]
	adc	edx, ebp
	cmp	esi, edx
	mov	DWORD PTR $T380565[esp+24], eax
	mov	DWORD PTR $T380565[esp+28], edx
	jg	SHORT $LN30@issueCASW@2
	jl	SHORT $LN33@issueCASW@2
	mov	edx, DWORD PTR [ecx]
	cmp	edx, eax
	jae	SHORT $LN30@issueCASW@2
$LN33@issueCASW@2:
	lea	eax, DWORD PTR $T380565[esp+24]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax

; 251  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8

; 249  : 
; 250  : 	nextWriteTime = max(nextWriteTime, currentTime + timing.tBurst());

$LN30@issueCASW@2:
	mov	eax, ecx
	mov	edx, DWORD PTR [eax]

; 251  : }

	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	pop	ebp
	mov	DWORD PTR [ecx+4], eax
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
?issueCASW@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ENDP	; DRAMsimII::Rank::issueCASW
_TEXT	ENDS
PUBLIC	?issueCAS@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z	; DRAMsimII::Rank::issueCAS
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T380630 = -8						; size = 8
$T380631 = 8						; size = 8
_currentTime$ = 8					; size = 8
_currentCommand$ = 16					; size = 4
?issueCAS@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z PROC	; DRAMsimII::Rank::issueCAS
; _this$ = edi

; 214  : 	// update the bank to reflect this change also
; 215  : 	bank[currentCommand->getAddress().getBank()].issueCAS(currentTime, currentCommand);

	mov	ecx, DWORD PTR [edi+188]
	sub	ecx, DWORD PTR [edi+184]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sub	esp, 12					; 0000000cH
	sar	edx, 6
	push	ebx
	mov	ebx, DWORD PTR _currentCommand$[esp+12]
	mov	eax, edx
	push	ebp
	shr	eax, 31					; 0000001fH
	push	esi
	mov	esi, DWORD PTR [ebx+64]
	add	eax, edx
	cmp	esi, eax
	jb	SHORT $LN7@issueCAS@2
	call	__invalid_parameter_noinfo
$LN7@issueCAS@2:
	mov	ebp, DWORD PTR _currentTime$[esp+24]
	imul	esi, 152				; 00000098H
	mov	ecx, DWORD PTR _currentTime$[esp+20]
	add	esi, DWORD PTR [edi+184]
	push	ebp
	push	ecx
	mov	eax, ebx
	call	?issueCAS@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Bank::issueCAS

; 216  : 
; 217  : 	lastCASTime = currentTime;

	mov	edx, DWORD PTR _currentTime$[esp+20]
	mov	DWORD PTR [edi+24], edx
	mov	DWORD PTR [edi+28], ebp

; 218  : 
; 219  : 	lastCASLength = currentCommand->getLength();

	mov	eax, DWORD PTR [ebx+88]
	mov	DWORD PTR [edi+112], eax

; 220  : 
; 221  : 	CASLength += currentCommand->getLength();

	mov	ecx, DWORD PTR [ebx+88]
	add	DWORD PTR [edi+128], ecx

; 222  : 
; 223  : 	assert(currentCommand->getAddress().getBank() == lastBankID);
; 224  : 	
; 225  : 	// calculate when the next few commands can happen
; 226  : 	nextReadTime = max(nextReadTime, currentTime + timing.tBurst());

	mov	ebx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR [edi+84]
	cdq
	add	eax, DWORD PTR _currentTime$[esp+20]
	lea	ecx, DWORD PTR [edi+80]
	adc	edx, ebp
	cmp	esi, edx
	mov	DWORD PTR $T380630[esp+24], eax
	mov	DWORD PTR $T380630[esp+28], edx
	jg	SHORT $LN20@issueCAS@2
	jl	SHORT $LN34@issueCAS@2
	mov	edx, DWORD PTR [ecx]
	cmp	edx, eax
	jae	SHORT $LN20@issueCAS@2
$LN34@issueCAS@2:
	lea	eax, DWORD PTR $T380630[esp+24]
	jmp	SHORT $LN21@issueCAS@2
$LN20@issueCAS@2:
	mov	eax, ecx
$LN21@issueCAS@2:
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax

; 227  : 	nextWriteTime = max(nextWriteTime, currentTime + timing.tCAS() + timing.tBurst() + timing.tRTRS() - timing.tCWD());

	mov	eax, DWORD PTR [ebx+56]
	cdq
	mov	esi, eax
	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, edx
	cdq
	sub	esi, eax
	mov	eax, DWORD PTR [ebx+8]
	sbb	ecx, edx
	cdq
	add	esi, eax
	mov	eax, DWORD PTR [ebx+4]
	adc	ecx, edx
	cdq
	add	esi, eax
	adc	ecx, edx
	add	esi, DWORD PTR _currentTime$[esp+20]
	mov	edx, DWORD PTR [edi+92]
	lea	eax, DWORD PTR [edi+88]
	adc	ecx, ebp
	cmp	edx, ecx
	mov	DWORD PTR $T380631[esp+20], esi
	mov	DWORD PTR $T380631[esp+24], ecx
	jg	SHORT $LN32@issueCAS@2
	jl	SHORT $LN35@issueCAS@2
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, esi
	jae	SHORT $LN32@issueCAS@2
$LN35@issueCAS@2:
	lea	ecx, DWORD PTR $T380631[esp+20]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 228  : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH

; 227  : 	nextWriteTime = max(nextWriteTime, currentTime + timing.tCAS() + timing.tBurst() + timing.tRTRS() - timing.tCWD());

$LN32@issueCAS@2:
	mov	ecx, eax
	mov	edx, DWORD PTR [ecx]

; 228  : }

	pop	esi
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	pop	ebp
	mov	DWORD PTR [eax+4], ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
?issueCAS@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ENDP	; DRAMsimII::Rank::issueCAS
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Equal@PBVBank@DRAMsimII@@PBV12@Uforward_iterator_tag@std@@@std@@YA_NPBVBank@DRAMsimII@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Last1$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Equal@PBVBank@DRAMsimII@@PBV12@Uforward_iterator_tag@std@@@std@@YA_NPBVBank@DRAMsimII@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<DRAMsimII::Bank const *,DRAMsimII::Bank const *,std::forward_iterator_tag>, COMDAT
; __First1$ = ecx
; __First2$ = eax

; 2991 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ebx
	mov	ebx, DWORD PTR __Last1$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, eax

; 2992 : 	for (; _First1 != _Last1; ++_First1, ++_First2)

	cmp	edi, ebx
	je	SHORT $LN2@Equal@11
	npad	1
$LL4@Equal@11:

; 2993 : 		if (!(*_First1 == *_First2))

	call	??8Bank@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Bank::operator==
	test	al, al
	je	SHORT $LN8@Equal@11
	add	edi, 152				; 00000098H
	add	esi, 152				; 00000098H
	cmp	edi, ebx
	jne	SHORT $LL4@Equal@11
$LN2@Equal@11:
	pop	edi
	pop	esi

; 2995 : 	return (true);

	mov	al, 1
	pop	ebx

; 2996 : 	}

	ret	0
$LN8@Equal@11:
	pop	edi
	pop	esi

; 2994 : 			return (false);

	xor	al, al
	pop	ebx

; 2996 : 	}

	ret	0
??$_Equal@PBVBank@DRAMsimII@@PBV12@Uforward_iterator_tag@std@@@std@@YA_NPBVBank@DRAMsimII@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<DRAMsimII::Bank const *,DRAMsimII::Bank const *,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Equal@PBVBank@DRAMsimII@@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVBank@DRAMsimII@@0V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Tmp$418909 = -8					; size = 8
__Last1$ = 8						; size = 4
__First2$ = 12						; size = 8
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Equal@PBVBank@DRAMsimII@@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVBank@DRAMsimII@@0V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<DRAMsimII::Bank const *,std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >, COMDAT
; __First1$ = eax

; 3042 : 	{

	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Last1$[esp+8]
	push	ebp

; 3043 : 	// for range checked iterators, this will make sure there is enough space
; 3044 : 	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);

	mov	ebp, DWORD PTR __First2$[esp+16]
	push	esi
	push	edi
	mov	edi, eax
	mov	ecx, ebx
	sub	ecx, edi
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	mov	eax, DWORD PTR __First2$[esp+20]
	sar	edx, 6
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	ecx, eax
	mov	DWORD PTR __Tmp$418909[esp+24], ecx
	test	eax, eax
	jne	SHORT $LN39@Equal@12
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR __Tmp$418909[esp+24]
	xor	eax, eax
$LN15@Equal@12:
	imul	esi, 152				; 00000098H
	add	esi, ebp
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN5@Equal@12
	test	ecx, ecx
	je	SHORT $LN20@Equal@12
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN21@Equal@12
$LN39@Equal@12:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN15@Equal@12
$LN20@Equal@12:
	xor	ecx, ecx
$LN21@Equal@12:
	cmp	esi, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Equal@12
$LN5@Equal@12:
	call	__invalid_parameter_noinfo
$LN6@Equal@12:

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	mov	esi, DWORD PTR __First2$[esp+24]
	cmp	edi, ebx
	je	SHORT $LN31@Equal@12
	npad	4
$LL33@Equal@12:
	call	??8Bank@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Bank::operator==
	test	al, al
	je	SHORT $LN37@Equal@12
	add	edi, 152				; 00000098H
	add	esi, 152				; 00000098H
	cmp	edi, ebx
	jne	SHORT $LL33@Equal@12
$LN31@Equal@12:
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx

; 3047 : 	}

	add	esp, 8
	ret	0
$LN37@Equal@12:
	pop	edi
	pop	esi
	pop	ebp

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	xor	al, al
	pop	ebx

; 3047 : 	}

	add	esp, 8
	ret	0
??$_Equal@PBVBank@DRAMsimII@@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVBank@DRAMsimII@@0V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<DRAMsimII::Bank const *,std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$equal@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@00@Z
_TEXT	SEGMENT
$T418946 = -4						; size = 1
__First1$ = 8						; size = 8
$T418947 = 16						; size = 1
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
??$equal@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@00@Z PROC ; std::equal<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >, COMDAT

; 3055 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ecx

; 3056 : 	return _Equal(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _First2,
; 3057 : 		_Iter_random(_First1, _First2), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T418947[esp]
	mov	edx, DWORD PTR __First2$[esp+4]
	mov	BYTE PTR $T418946[esp+4], 0
	mov	eax, DWORD PTR $T418946[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+12]
	push	edx
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	call	??$_Equal@PBVBank@DRAMsimII@@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVBank@DRAMsimII@@0V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<DRAMsimII::Bank const *,std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >

; 3058 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$equal@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@00@Z ENDP ; std::equal<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$?8VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@0@Z
_TEXT	SEGMENT
$T418989 = -8						; size = 8
tv284 = 8						; size = 4
$T419183 = 8						; size = 1
$T419184 = 8						; size = 1
__Right$ = 8						; size = 4
??$?8VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@0@Z PROC ; std::operator==<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; __Left$ = esi

; 1307 : 	{	// test for vector equality

	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Right$[esp+8]
	push	ebp

; 1308 : 	return (_Left.size() == _Right.size()
; 1309 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	mov	ebp, DWORD PTR [ebx+16]
	push	edi
	mov	edi, DWORD PTR [ebx+12]
	mov	ecx, ebp
	sub	ecx, edi
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR tv284[esp+16], eax
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	mov	ecx, DWORD PTR tv284[esp+16]
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jne	SHORT $LN3@operator@254
	cmp	edi, ebp
	jbe	SHORT $LN12@operator@254
	call	__invalid_parameter_noinfo
$LN12@operator@254:
	mov	ebp, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR $T418989[esp+20], ecx
	cmp	DWORD PTR [esi+12], ebp
	jbe	SHORT $LN26@operator@254
	call	__invalid_parameter_noinfo
$LN26@operator@254:
	mov	ebx, DWORD PTR [esi+12]
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN40@operator@254
	call	__invalid_parameter_noinfo
$LN40@operator@254:
	mov	ecx, DWORD PTR $T418989[esp+20]
	mov	BYTE PTR $T419183[esp+16], 0
	mov	edx, DWORD PTR $T419183[esp+16]
	mov	eax, DWORD PTR $T419184[esp+16]
	push	edx
	push	eax
	push	edi
	push	ecx
	push	ebp
	mov	eax, ebx
	call	??$_Equal@PBVBank@DRAMsimII@@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVBank@DRAMsimII@@0V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<DRAMsimII::Bank const *,std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN3@operator@254
	pop	edi
	pop	ebp
	mov	eax, 1
	pop	ebx

; 1310 : 	}

	add	esp, 8
	ret	0
$LN3@operator@254:
	pop	edi
	pop	ebp

; 1308 : 	return (_Left.size() == _Right.size()
; 1309 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	xor	eax, eax
	pop	ebx

; 1310 : 	}

	add	esp, 8
	ret	0
??$?8VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@0@Z ENDP ; std::operator==<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN5@Make_iter@19
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN5@Make_iter@19
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN6@Make_iter@19
$LN5@Make_iter@19:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN6@Make_iter@19:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Make_iter
_TEXT	ENDS
PUBLIC	??8Rank@DRAMsimII@@QBE_NABV01@@Z		; DRAMsimII::Rank::operator==
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\rank.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
??8Rank@DRAMsimII@@QBE_NABV01@@Z PROC			; DRAMsimII::Rank::operator==
; _right$ = edi

; 482  : 	return (timing == right.timing && lastRefreshTime == right.lastRefreshTime && lastPrechargeAnyBankTime == right.lastPrechargeAnyBankTime &&
; 483  : 		lastCASTime == right.lastCASTime && lastCASWTime == right.lastCASWTime && prechargeTime == right.prechargeTime && totalPrechargeTime == right.totalPrechargeTime &&
; 484  : 		lastCASLength == right.lastCASLength && lastCASWLength == right.lastCASWLength && rankID == right.rankID && lastBankID == right.lastBankID &&
; 485  : 		banksPrecharged == right.banksPrecharged && lastActivateTimes == right.lastActivateTimes && bank == right.bank && CASLength == right.CASLength &&
; 486  : 		CASWLength == right.CASWLength && otherLastCASTime == right.otherLastCASTime && otherLastCASWTime == right.otherLastCASWTime &&
; 487  : 		otherLastCASLength == right.otherLastCASLength && otherLastCASWLength == right.otherLastCASWLength);

	mov	eax, DWORD PTR [edi]
	push	ebx
	mov	ebx, DWORD PTR _this$[esp]
	mov	ecx, DWORD PTR [ebx]
	push	esi
	call	??8TimingSpecification@DRAMsimII@@QBE_NABV01@@Z ; DRAMsimII::TimingSpecification::operator==
	test	al, al
	je	$LN3@operator@255
	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, DWORD PTR [edi+8]
	jne	$LN3@operator@255
	mov	ecx, DWORD PTR [ebx+12]
	cmp	ecx, DWORD PTR [edi+12]
	jne	$LN3@operator@255
	mov	edx, DWORD PTR [ebx+16]
	cmp	edx, DWORD PTR [edi+16]
	jne	$LN3@operator@255
	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, DWORD PTR [edi+20]
	jne	$LN3@operator@255
	mov	ecx, DWORD PTR [ebx+24]
	cmp	ecx, DWORD PTR [edi+24]
	jne	$LN3@operator@255
	mov	edx, DWORD PTR [ebx+28]
	cmp	edx, DWORD PTR [edi+28]
	jne	$LN3@operator@255
	mov	eax, DWORD PTR [ebx+32]
	cmp	eax, DWORD PTR [edi+32]
	jne	$LN3@operator@255
	mov	ecx, DWORD PTR [ebx+36]
	cmp	ecx, DWORD PTR [edi+36]
	jne	$LN3@operator@255
	mov	edx, DWORD PTR [ebx+56]
	cmp	edx, DWORD PTR [edi+56]
	jne	$LN3@operator@255
	mov	eax, DWORD PTR [ebx+60]
	cmp	eax, DWORD PTR [edi+60]
	jne	$LN3@operator@255
	mov	ecx, DWORD PTR [ebx+64]
	cmp	ecx, DWORD PTR [edi+64]
	jne	$LN3@operator@255
	mov	edx, DWORD PTR [ebx+68]
	cmp	edx, DWORD PTR [edi+68]
	jne	$LN3@operator@255
	mov	eax, DWORD PTR [ebx+112]
	cmp	eax, DWORD PTR [edi+112]
	jne	$LN3@operator@255
	mov	ecx, DWORD PTR [ebx+116]
	cmp	ecx, DWORD PTR [edi+116]
	jne	$LN3@operator@255
	mov	edx, DWORD PTR [ebx+136]
	cmp	edx, DWORD PTR [edi+136]
	jne	$LN3@operator@255
	mov	eax, DWORD PTR [ebx+140]
	cmp	eax, DWORD PTR [edi+140]
	jne	$LN3@operator@255
	mov	ecx, DWORD PTR [ebx+144]
	cmp	ecx, DWORD PTR [edi+144]
	jne	$LN3@operator@255
	lea	esi, DWORD PTR [edi+148]
	lea	ecx, DWORD PTR [ebx+148]
	call	??$?8_JV?$allocator@_J@std@@@boost@@YA_NABV?$circular_buffer@_JV?$allocator@_J@std@@@0@0@Z ; boost::operator==<__int64,std::allocator<__int64> >
	test	al, al
	je	SHORT $LN3@operator@255
	lea	edx, DWORD PTR [edi+172]
	push	edx
	lea	esi, DWORD PTR [ebx+172]
	call	??$?8VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@0@0@Z ; std::operator==<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	add	esp, 4
	test	al, al
	je	SHORT $LN3@operator@255
	mov	eax, DWORD PTR [ebx+128]
	cmp	eax, DWORD PTR [edi+128]
	jne	SHORT $LN3@operator@255
	mov	ecx, DWORD PTR [ebx+132]
	cmp	ecx, DWORD PTR [edi+132]
	jne	SHORT $LN3@operator@255
	mov	edx, DWORD PTR [ebx+40]
	cmp	edx, DWORD PTR [edi+40]
	jne	SHORT $LN3@operator@255
	mov	eax, DWORD PTR [ebx+44]
	cmp	eax, DWORD PTR [edi+44]
	jne	SHORT $LN3@operator@255
	mov	ecx, DWORD PTR [ebx+48]
	cmp	ecx, DWORD PTR [edi+48]
	jne	SHORT $LN3@operator@255
	mov	edx, DWORD PTR [ebx+52]
	cmp	edx, DWORD PTR [edi+52]
	jne	SHORT $LN3@operator@255
	mov	eax, DWORD PTR [ebx+120]
	cmp	eax, DWORD PTR [edi+120]
	jne	SHORT $LN3@operator@255
	mov	ecx, DWORD PTR [ebx+124]
	cmp	ecx, DWORD PTR [edi+124]
	jne	SHORT $LN3@operator@255
	pop	esi
	mov	eax, 1
	pop	ebx

; 488  : }

	ret	4
$LN3@operator@255:
	pop	esi

; 482  : 	return (timing == right.timing && lastRefreshTime == right.lastRefreshTime && lastPrechargeAnyBankTime == right.lastPrechargeAnyBankTime &&
; 483  : 		lastCASTime == right.lastCASTime && lastCASWTime == right.lastCASWTime && prechargeTime == right.prechargeTime && totalPrechargeTime == right.totalPrechargeTime &&
; 484  : 		lastCASLength == right.lastCASLength && lastCASWLength == right.lastCASWLength && rankID == right.rankID && lastBankID == right.lastBankID &&
; 485  : 		banksPrecharged == right.banksPrecharged && lastActivateTimes == right.lastActivateTimes && bank == right.bank && CASLength == right.CASLength &&
; 486  : 		CASWLength == right.CASWLength && otherLastCASTime == right.otherLastCASTime && otherLastCASWTime == right.otherLastCASWTime &&
; 487  : 		otherLastCASLength == right.otherLastCASLength && otherLastCASWLength == right.otherLastCASWLength);

	xor	eax, eax
	pop	ebx

; 488  : }

	ret	4
??8Rank@DRAMsimII@@QBE_NABV01@@Z ENDP			; DRAMsimII::Rank::operator==
_TEXT	ENDS
PUBLIC	?isEmpty@Rank@DRAMsimII@@QBE_NXZ		; DRAMsimII::Rank::isEmpty
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_this$ = 8						; size = 4
?isEmpty@Rank@DRAMsimII@@QBE_NXZ PROC			; DRAMsimII::Rank::isEmpty

; 445  : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]
	push	esi

; 446  : 	for (vector<Bank>::const_iterator i = bank.begin(); i != bank.end(); i++)

	mov	esi, DWORD PTR [ebp+184]
	push	edi
	cmp	esi, DWORD PTR [ebp+188]
	jbe	SHORT $LN10@isEmpty
	call	__invalid_parameter_noinfo
$LN10@isEmpty:
	mov	edi, DWORD PTR [ebp+172]
$LL25@isEmpty:
	mov	ebx, DWORD PTR [ebp+188]
	cmp	DWORD PTR [ebp+184], ebx
	jbe	SHORT $LN38@isEmpty
	call	__invalid_parameter_noinfo
$LN38@isEmpty:
	mov	eax, DWORD PTR [ebp+172]
	test	edi, edi
	je	SHORT $LN51@isEmpty
	cmp	edi, eax
	je	SHORT $LN52@isEmpty
$LN51@isEmpty:
	call	__invalid_parameter_noinfo
$LN52@isEmpty:
	cmp	esi, ebx
	je	SHORT $LN2@isEmpty

; 447  : 	{
; 448  : 		if (!i->hasNoReadWrite())

	test	edi, edi
	jne	SHORT $LN76@isEmpty
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN70@isEmpty:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN61@isEmpty
	call	__invalid_parameter_noinfo
$LN61@isEmpty:
	call	?hasNoReadWrite@Bank@DRAMsimII@@QBE_NXZ	; DRAMsimII::Bank::hasNoReadWrite
	test	al, al
	je	SHORT $LN74@isEmpty

; 446  : 	for (vector<Bank>::const_iterator i = bank.begin(); i != bank.end(); i++)

	test	edi, edi
	jne	SHORT $LN75@isEmpty
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN32@isEmpty:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN23@isEmpty
	call	__invalid_parameter_noinfo
$LN23@isEmpty:
	add	esi, 152				; 00000098H
	jmp	SHORT $LL25@isEmpty
$LN76@isEmpty:

; 447  : 	{
; 448  : 		if (!i->hasNoReadWrite())

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN70@isEmpty
$LN75@isEmpty:

; 446  : 	for (vector<Bank>::const_iterator i = bank.begin(); i != bank.end(); i++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN32@isEmpty
$LN74@isEmpty:
	pop	edi
	pop	esi
	pop	ebp

; 449  : 			return false;

	xor	al, al
	pop	ebx

; 452  : }

	ret	4
$LN2@isEmpty:
	pop	edi
	pop	esi
	pop	ebp

; 450  : 	}
; 451  : 	return true;

	mov	al, 1
	pop	ebx

; 452  : }

	ret	4
?isEmpty@Rank@DRAMsimII@@QBE_NXZ ENDP			; DRAMsimII::Rank::isEmpty
_TEXT	ENDS
PUBLIC	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ	; DRAMsimII::Rank::refreshAllReady
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_this$ = 8						; size = 4
?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Rank::refreshAllReady

; 432  : {

	push	ebx
	push	ebp

; 433  : 	for (vector<Bank>::const_iterator currentBank = bank.begin(); currentBank != bank.end(); currentBank++)

	mov	ebp, DWORD PTR _this$[esp+4]
	push	esi
	mov	esi, DWORD PTR [ebp+184]
	push	edi
	cmp	esi, DWORD PTR [ebp+188]
	jbe	SHORT $LN11@refreshAll
	call	__invalid_parameter_noinfo
$LN11@refreshAll:
	mov	ebx, DWORD PTR [ebp+172]
	add	esi, 32					; 00000020H
	npad	12
$LL26@refreshAll:
	mov	edi, DWORD PTR [ebp+188]
	cmp	DWORD PTR [ebp+184], edi
	jbe	SHORT $LN39@refreshAll
	call	__invalid_parameter_noinfo
$LN39@refreshAll:
	mov	eax, DWORD PTR [ebp+172]
	test	ebx, ebx
	je	SHORT $LN52@refreshAll
	cmp	ebx, eax
	je	SHORT $LN53@refreshAll
$LN52@refreshAll:
	call	__invalid_parameter_noinfo
$LN53@refreshAll:
	lea	ebp, DWORD PTR [esi-32]
	cmp	ebp, edi
	je	$LN3@refreshAll

; 434  : 	{
; 435  : 		// if any queue is empty or the head of any queue isn't a refresh command, then the rank isn't ready for a refresh all command
; 436  : 		if (!currentBank->front() || !currentBank->front()->isRefresh())

	test	ebx, ebx
	jne	$LN112@refreshAll
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN71@refreshAll:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN62@refreshAll
	call	__invalid_parameter_noinfo
$LN62@refreshAll:
	mov	eax, DWORD PTR [esi+4]
	sub	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR [esi-20]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN78@refreshAll
	call	__invalid_parameter_noinfo
$LN78@refreshAll:
	mov	ecx, DWORD PTR [esi]
	cmp	DWORD PTR [ecx+edi*4], 0
	je	SHORT $LN109@refreshAll
	test	ebx, ebx
	jne	SHORT $LN111@refreshAll
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN94@refreshAll:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN85@refreshAll
	call	__invalid_parameter_noinfo
$LN85@refreshAll:
	mov	edx, DWORD PTR [esi+4]
	sub	edx, DWORD PTR [esi]
	mov	edi, DWORD PTR [esi-20]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN101@refreshAll
	call	__invalid_parameter_noinfo
$LN101@refreshAll:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+edi*4]
	cmp	DWORD PTR [ecx+80], 12			; 0000000cH
	jne	SHORT $LN109@refreshAll

; 433  : 	for (vector<Bank>::const_iterator currentBank = bank.begin(); currentBank != bank.end(); currentBank++)

	test	ebx, ebx
	jne	SHORT $LN110@refreshAll
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN33@refreshAll:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN24@refreshAll
	call	__invalid_parameter_noinfo
$LN24@refreshAll:
	mov	ebp, DWORD PTR _this$[esp+12]
	add	esi, 152				; 00000098H
	jmp	$LL26@refreshAll
$LN112@refreshAll:

; 434  : 	{
; 435  : 		// if any queue is empty or the head of any queue isn't a refresh command, then the rank isn't ready for a refresh all command
; 436  : 		if (!currentBank->front() || !currentBank->front()->isRefresh())

	mov	eax, DWORD PTR [ebx]
	jmp	$LN71@refreshAll
$LN111@refreshAll:
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN94@refreshAll
$LN110@refreshAll:

; 433  : 	for (vector<Bank>::const_iterator currentBank = bank.begin(); currentBank != bank.end(); currentBank++)

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN33@refreshAll
$LN109@refreshAll:

; 437  : 		{
; 438  : 			return false;

	xor	al, al

; 439  : 		}
; 440  : 	}
; 441  : 	return true;
; 442  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN3@refreshAll:
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	ret	4
?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Rank::refreshAllReady
_TEXT	ENDS
PUBLIC	?issueREF@Rank@DRAMsimII@@QAEX_J@Z		; DRAMsimII::Rank::issueREF
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T419815 = -8						; size = 8
$T419814 = -8						; size = 8
_currentTime$ = 8					; size = 8
?issueREF@Rank@DRAMsimII@@QAEX_J@Z PROC			; DRAMsimII::Rank::issueREF
; _this$ = eax

; 257  : {

	sub	esp, 8
	push	ebx

; 258  : 	lastRefreshTime = currentTime;

	mov	ebx, DWORD PTR _currentTime$[esp+8]
	push	ebp
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR _currentTime$[esp+20]
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], eax
	push	edi

; 259  : 
; 260  : 	// FIXME: should this not count as a RAS + PRE command to all banks?
; 261  : 	std::for_each(bank.begin(), bank.end(), boost::mem_fun_ref(&Bank::issueREF));

	mov	edi, DWORD PTR [esi+188]
	cmp	DWORD PTR [esi+184], edi
	jbe	SHORT $LN12@issueREF
	call	__invalid_parameter_noinfo
$LN12@issueREF:
	mov	ebp, DWORD PTR [esi+184]
	cmp	ebp, DWORD PTR [esi+188]
	jbe	SHORT $LN28@issueREF
	call	__invalid_parameter_noinfo
$LN28@issueREF:
	mov	ecx, ebp
	cmp	ebp, edi
	je	SHORT $LN39@issueREF
$LL41@issueREF:
	call	?issueREF@Bank@DRAMsimII@@QAEXXZ	; DRAMsimII::Bank::issueREF
	add	ecx, 152				; 00000098H
	cmp	ecx, edi
	jne	SHORT $LL41@issueREF
$LN39@issueREF:

; 262  : 
; 263  : 	// calculate when the next few commands can happen
; 264  : 	nextRefreshTime = max(nextRefreshTime, currentTime + timing.tRFC());

	mov	edi, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi+40]
	mov	ebp, DWORD PTR [esi+100]
	cdq
	add	eax, ebx
	adc	edx, DWORD PTR _currentTime$[esp+24]
	lea	ecx, DWORD PTR [esi+96]
	cmp	ebp, edx
	mov	DWORD PTR $T419814[esp+24], eax
	mov	DWORD PTR $T419814[esp+28], edx
	jg	SHORT $LN62@issueREF
	jl	SHORT $LN72@issueREF
	mov	edx, DWORD PTR [ecx]
	cmp	edx, eax
	jae	SHORT $LN62@issueREF
$LN72@issueREF:
	lea	eax, DWORD PTR $T419814[esp+24]
	jmp	SHORT $LN63@issueREF
$LN62@issueREF:
	mov	eax, ecx
$LN63@issueREF:
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax

; 265  : 	assert (nextRefreshTime == lastPrechargeAnyBankTime + timing.tRP() || nextRefreshTime == lastRefreshTime + timing.tRFC() || currentTime < 250);
; 266  : 	nextActivateTime = max(nextActivateTime, currentTime + timing.tRFC());

	mov	eax, DWORD PTR [edi+40]
	cdq
	add	eax, ebx
	adc	edx, DWORD PTR _currentTime$[esp+24]
	lea	ecx, DWORD PTR [esi+72]
	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, edx
	mov	DWORD PTR $T419815[esp+24], eax
	mov	DWORD PTR $T419815[esp+28], edx
	jg	SHORT $LN68@issueREF
	jl	SHORT $LN73@issueREF
	mov	edx, DWORD PTR [ecx]
	cmp	edx, eax
	jae	SHORT $LN68@issueREF
$LN73@issueREF:
	lea	eax, DWORD PTR $T419815[esp+24]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax

; 267  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	8

; 265  : 	assert (nextRefreshTime == lastPrechargeAnyBankTime + timing.tRP() || nextRefreshTime == lastRefreshTime + timing.tRFC() || currentTime < 250);
; 266  : 	nextActivateTime = max(nextActivateTime, currentTime + timing.tRFC());

$LN68@issueREF:
	mov	eax, ecx
	mov	edx, DWORD PTR [eax]

; 267  : }

	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	pop	ebp
	mov	DWORD PTR [ecx+4], eax
	pop	ebx
	add	esp, 8
	ret	8
?issueREF@Rank@DRAMsimII@@QAEX_J@Z ENDP			; DRAMsimII::Rank::issueREF
_TEXT	ENDS
PUBLIC	?issueRAS@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z	; DRAMsimII::Rank::issueRAS
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T420059 = -16						; size = 8
$T420054 = -16						; size = 8
$T420051 = -16						; size = 8
_thisRASTime$ = -16					; size = 8
$T420058 = -8						; size = 8
$T420053 = -8						; size = 8
$T420052 = -8						; size = 8
_currentTime$ = 8					; size = 8
_currentCommand$ = 16					; size = 4
?issueRAS@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z PROC	; DRAMsimII::Rank::issueRAS
; _this$ = eax

; 150  : {

	sub	esp, 16					; 00000010H
	push	ebx

; 151  : 	// RAS time history queue, per rank
; 152  : 	const tick thisRASTime = currentTime;

	mov	ebx, DWORD PTR _currentTime$[esp+16]
	push	ebp
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR _currentTime$[esp+28]
	push	edi
	mov	DWORD PTR _thisRASTime$[esp+36], eax

; 153  : 	// record these for tFAW calculations
; 154  : 	lastActivateTimes.push_front(thisRASTime);

	lea	eax, DWORD PTR [esi+148]
	lea	edi, DWORD PTR _thisRASTime$[esp+32]
	mov	DWORD PTR _thisRASTime$[esp+32], ebx
	call	?push_front@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEXAB_J@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::push_front

; 155  : 
; 156  : 	lastBankID = currentCommand->getAddress().getBank();

	mov	ebp, DWORD PTR _currentCommand$[esp+28]
	mov	ecx, DWORD PTR [ebp+64]
	mov	DWORD PTR [esi+140], ecx

; 157  : 
; 158  : 	// for power modeling, if all banks were precharged and now one is being activated, record the interval that one was precharged	
; 159  : 	if (banksPrecharged == bank.size())

	mov	ecx, DWORD PTR [esi+188]
	sub	ecx, DWORD PTR [esi+184]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	DWORD PTR [esi+144], eax
	jne	$LN1@issueRAS@2

; 160  : 	{
; 161  : 		prechargeTime += max(currentTime - max(lastCalculationTime, lastPrechargeAnyBankTime),(tick)0);

	mov	ecx, DWORD PTR [esi+108]
	lea	ebp, DWORD PTR [esi+104]
	xor	eax, eax
	cmp	ecx, DWORD PTR [esi+20]
	lea	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T420051[esp+32], eax
	mov	DWORD PTR $T420051[esp+36], eax
	jg	SHORT $LN15@issueRAS@2
	jl	SHORT $LN112@issueRAS@2
	mov	eax, DWORD PTR [ebp]
	cmp	eax, DWORD PTR [edx]
	jae	SHORT $LN15@issueRAS@2
$LN112@issueRAS@2:
	mov	edi, edx
	jmp	SHORT $LN16@issueRAS@2
$LN15@issueRAS@2:
	mov	edi, ebp
$LN16@issueRAS@2:
	mov	eax, DWORD PTR _currentTime$[esp+32]
	mov	ecx, ebx
	sub	ecx, DWORD PTR [edi]
	sbb	eax, DWORD PTR [edi+4]
	xor	edi, edi
	cmp	eax, edi
	mov	DWORD PTR $T420052[esp+32], ecx
	mov	DWORD PTR $T420052[esp+36], eax
	jg	SHORT $LN19@issueRAS@2
	jl	SHORT $LN113@issueRAS@2
	cmp	ecx, edi
	jae	SHORT $LN19@issueRAS@2
$LN113@issueRAS@2:
	lea	eax, DWORD PTR $T420051[esp+32]
	jmp	SHORT $LN20@issueRAS@2
$LN19@issueRAS@2:
	lea	eax, DWORD PTR $T420052[esp+32]
$LN20@issueRAS@2:
	mov	ecx, DWORD PTR [eax]
	add	DWORD PTR [esi+56], ecx
	mov	eax, DWORD PTR [eax+4]

; 162  : 		totalPrechargeTime += max(currentTime - max(lastCalculationTime, lastPrechargeAnyBankTime), (tick)0);

	mov	DWORD PTR $T420053[esp+32], edi
	adc	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebp+4]
	cmp	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR $T420053[esp+36], edi
	jg	SHORT $LN23@issueRAS@2
	jl	SHORT $LN24@issueRAS@2
	mov	eax, DWORD PTR [ebp]
	cmp	eax, DWORD PTR [edx]
	jb	SHORT $LN24@issueRAS@2
$LN23@issueRAS@2:
	mov	edx, ebp
$LN24@issueRAS@2:
	mov	eax, DWORD PTR _currentTime$[esp+32]
	mov	ecx, ebx
	sub	ecx, DWORD PTR [edx]
	sbb	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T420054[esp+32], ecx
	cmp	eax, edi
	mov	DWORD PTR $T420054[esp+36], eax
	jg	SHORT $LN27@issueRAS@2
	jl	SHORT $LN115@issueRAS@2
	cmp	ecx, edi
	jae	SHORT $LN27@issueRAS@2
$LN115@issueRAS@2:
	lea	eax, DWORD PTR $T420053[esp+32]
	jmp	SHORT $LN28@issueRAS@2
$LN27@issueRAS@2:
	lea	eax, DWORD PTR $T420054[esp+32]
$LN28@issueRAS@2:
	mov	ecx, DWORD PTR [eax]
	add	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [eax+4]
	adc	DWORD PTR [esi+68], edx

; 163  : 		for (vector<Bank>::const_iterator curBnk = bank.begin(); curBnk != bank.end(); curBnk++)

	mov	ebp, DWORD PTR [esi+184]
	cmp	ebp, DWORD PTR [esi+188]
	jbe	SHORT $LN34@issueRAS@2
	call	__invalid_parameter_noinfo
$LN34@issueRAS@2:
	mov	edi, DWORD PTR [esi+172]
	mov	ebx, ebp
$LL49@issueRAS@2:
	mov	ebp, DWORD PTR [esi+188]
	cmp	DWORD PTR [esi+184], ebp
	jbe	SHORT $LN64@issueRAS@2
	call	__invalid_parameter_noinfo
$LN64@issueRAS@2:
	mov	eax, DWORD PTR [esi+172]
	test	edi, edi
	je	SHORT $LN77@issueRAS@2
	cmp	edi, eax
	je	SHORT $LN78@issueRAS@2
$LN77@issueRAS@2:
	call	__invalid_parameter_noinfo
$LN78@issueRAS@2:
	cmp	ebx, ebp
	je	SHORT $LN118@issueRAS@2
	test	edi, edi
	jne	SHORT $LN111@issueRAS@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN56@issueRAS@2:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN47@issueRAS@2
	call	__invalid_parameter_noinfo
$LN47@issueRAS@2:
	add	ebx, 152				; 00000098H
	jmp	SHORT $LL49@issueRAS@2
$LN111@issueRAS@2:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN56@issueRAS@2
$LN118@issueRAS@2:
	mov	ebx, DWORD PTR _currentTime$[esp+28]
	mov	ebp, DWORD PTR _currentCommand$[esp+28]
$LN1@issueRAS@2:

; 164  : 			assert(!curBnk->isActivated());
; 165  : 	}	
; 166  : 	banksPrecharged--;

	dec	DWORD PTR [esi+144]

; 167  : 	assert(banksPrecharged < bank.size());
; 168  : 	// update the bank to reflect this change also
; 169  : 	bank[currentCommand->getAddress().getBank()].issueRAS(currentTime,currentCommand);

	mov	ecx, DWORD PTR [esi+188]
	sub	ecx, DWORD PTR [esi+184]
	mov	edi, DWORD PTR [ebp+64]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN89@issueRAS@2
	call	__invalid_parameter_noinfo
$LN89@issueRAS@2:
	mov	ecx, DWORD PTR _currentTime$[esp+32]
	push	ecx
	mov	ecx, edi
	imul	ecx, 152				; 00000098H
	add	ecx, DWORD PTR [esi+184]
	push	ebx
	mov	edx, ebp
	call	?issueRAS@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Bank::issueRAS

; 170  : 
; 171  : 	// calculate when the next few commands can happen
; 172  : 	nextActivateTime = max(currentTime + timing.tRRD(), max(lastActivateTimes.back() + timing.tFAW() , nextActivateTime));

	mov	ebp, DWORD PTR [esi+160]
	cmp	ebp, DWORD PTR [esi+148]
	jne	SHORT $LN96@issueRAS@2
	mov	ebp, DWORD PTR [esi+152]
$LN96@issueRAS@2:
	mov	ebx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ebx+24]
	cdq
	mov	edi, eax
	add	edi, DWORD PTR [ebp-8]
	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, edx
	adc	ecx, DWORD PTR [ebp-4]
	cdq
	add	eax, DWORD PTR _currentTime$[esp+28]
	mov	DWORD PTR $T420058[esp+32], edi
	adc	edx, DWORD PTR _currentTime$[esp+32]
	add	esi, 72					; 00000048H
	cmp	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR $T420058[esp+36], ecx
	mov	DWORD PTR $T420059[esp+32], eax
	mov	DWORD PTR $T420059[esp+36], edx
	jg	SHORT $LN104@issueRAS@2
	jl	SHORT $LN116@issueRAS@2
	cmp	edi, DWORD PTR [esi]
	jae	SHORT $LN104@issueRAS@2
$LN116@issueRAS@2:
	mov	ecx, esi
	jmp	SHORT $LN105@issueRAS@2
$LN104@issueRAS@2:
	lea	ecx, DWORD PTR $T420058[esp+32]
$LN105@issueRAS@2:
	cmp	edx, DWORD PTR [ecx+4]
	jg	SHORT $LN108@issueRAS@2
	jl	SHORT $LN109@issueRAS@2
	cmp	eax, DWORD PTR [ecx]
	jb	SHORT $LN109@issueRAS@2
$LN108@issueRAS@2:
	lea	ecx, DWORD PTR $T420059[esp+32]
$LN109@issueRAS@2:
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [ecx+4]

; 173  : }

	pop	edi
	mov	DWORD PTR [esi+4], eax
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
?issueRAS@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ENDP	; DRAMsimII::Rank::issueRAS
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.h
_TEXT	ENDS
;	COMDAT ?nextCommandType@Bank@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ
_TEXT	SEGMENT
?nextCommandType@Bank@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ PROC ; DRAMsimII::Bank::nextCommandType, COMDAT
; _this$ = esi

; 110  : 		Command::CommandType nextCommandType() const { return perBankQueue.front() ? perBankQueue.front()->getCommandType() : Command::INVALID_COMMAND; }

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	push	edi
	mov	edi, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN7@nextComman@2
	call	__invalid_parameter_noinfo
$LN7@nextComman@2:
	mov	ecx, DWORD PTR [esi+32]
	cmp	DWORD PTR [ecx+edi*4], 0
	je	SHORT $LN3@nextComman@2
	mov	edx, DWORD PTR [esi+36]
	mov	edi, DWORD PTR [esi+12]
	sub	edx, ecx
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN14@nextComman@2
	call	__invalid_parameter_noinfo
$LN14@nextComman@2:
	mov	eax, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [ecx+80]
	pop	edi
	ret	0
$LN3@nextComman@2:
	mov	eax, 16					; 00000010H
	pop	edi
	ret	0
?nextCommandType@Bank@DRAMsimII@@QBE?AW4CommandType@Command@2@XZ ENDP ; DRAMsimII::Bank::nextCommandType
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\exception\exception.hpp
;	COMDAT ??1?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAE@XZ
_TEXT	SEGMENT
??1?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAE@XZ PROC ; boost::exception_detail::error_info_injector<std::length_error>::~error_info_injector<std::length_error>, COMDAT
; _this$ = esi

; 275  :                 {

	mov	DWORD PTR [esi], OFFSET ??_7?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Blength_error@std@@@
	mov	DWORD PTR [esi+40], OFFSET ??_7?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Bexception@2@@

; 276  :                 }

	mov	DWORD PTR [esi+40], OFFSET ??_7exception@boost@@6B@
	mov	ecx, DWORD PTR [esi+44]
	test	ecx, ecx
	je	SHORT $LN7@error_info@5
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	call	edx
$LN7@error_info@5:
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN30@error_info@5
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN30@error_info@5:
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], 0
	mov	BYTE PTR [esi+16], 0
	mov	ecx, esi
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAE@XZ ENDP ; boost::exception_detail::error_info_injector<std::length_error>::~error_info_injector<std::length_error>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAEPAXI@Z PROC ; boost::exception_detail::error_info_injector<std::length_error>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAE@XZ ; boost::exception_detail::error_info_injector<std::length_error>::~error_info_injector<std::length_error>
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@72
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@72:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAEPAXI@Z ENDP ; boost::exception_detail::error_info_injector<std::length_error>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?resetToTime@Rank@DRAMsimII@@QAEX_J@Z		; DRAMsimII::Rank::resetToTime
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\rank.cpp
_TEXT	SEGMENT
$T456701 = -12						; size = 4
$T456574 = -12						; size = 4
_i$135162 = -8						; size = 8
_time$ = 8						; size = 8
?resetToTime@Rank@DRAMsimII@@QAEX_J@Z PROC		; DRAMsimII::Rank::resetToTime
; _this$ = edi

; 384  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp

; 385  : 	lastCASTime = time - 1000;

	mov	ebp, DWORD PTR _time$[esp+20]
	push	esi
	mov	esi, DWORD PTR _time$[esp+28]
	mov	eax, ebp
	sub	eax, 1000				; 000003e8H
	mov	DWORD PTR [edi+24], eax

; 386  : 	lastCASWTime = time - 1000;

	mov	DWORD PTR [edi+32], eax
	mov	ecx, esi
	sbb	ecx, 0
	mov	DWORD PTR [edi+28], ecx
	mov	DWORD PTR [edi+36], ecx

; 387  : 	lastPrechargeAnyBankTime = time;
; 388  : 	lastRefreshTime = time - timing.tRFC();

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [edi+16], ebp
	mov	DWORD PTR [edi+20], esi
	mov	eax, DWORD PTR [ecx+40]
	cdq
	mov	ebx, ebp
	sub	ebx, eax
	mov	eax, esi
	sbb	eax, edx
	mov	DWORD PTR [edi+8], ebx

; 389  : 	lastCalculationTime = time;
; 390  : 	prechargeTime = 0;

	xor	ebx, ebx
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+104], ebp
	mov	DWORD PTR [edi+108], esi
	mov	DWORD PTR [edi+56], ebx
	mov	DWORD PTR [edi+60], ebx

; 391  : 
; 392  : 	nextActivateTime = time;

	mov	DWORD PTR [edi+72], ebp
	mov	DWORD PTR [edi+76], esi

; 393  : 	nextRefreshTime = time + timing.tRP();

	mov	eax, DWORD PTR [ecx+44]
	cdq
	add	eax, ebp
	adc	edx, esi
	mov	DWORD PTR [edi+96], eax
	mov	DWORD PTR [edi+100], edx

; 394  : 	for (boost::circular_buffer<tick>::iterator i = lastActivateTimes.begin(); i != lastActivateTimes.end(); i++)

	cmp	DWORD PTR [edi+164], ebx
	jne	SHORT $LN15@resetToTim@2
	xor	ecx, ecx
	jmp	SHORT $LN16@resetToTim@2
$LN15@resetToTim@2:
	mov	ecx, DWORD PTR [edi+156]
$LN16@resetToTim@2:
	cmp	ecx, ebx
	je	SHORT $LN123@resetToTim@2
$LL27@resetToTim@2:

; 395  : 		*i = time - timing.tFAW();

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+24]
	cdq
	mov	ebx, ebp
	sub	ebx, eax
	mov	eax, esi
	sbb	eax, edx
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], eax
	add	ecx, 8
	cmp	ecx, DWORD PTR [edi+152]
	jne	SHORT $LN30@resetToTim@2

; 394  : 	for (boost::circular_buffer<tick>::iterator i = lastActivateTimes.begin(); i != lastActivateTimes.end(); i++)

	mov	ecx, DWORD PTR [edi+148]
$LN30@resetToTim@2:
	cmp	ecx, DWORD PTR [edi+160]
	je	SHORT $LN123@resetToTim@2
	test	ecx, ecx
	jne	SHORT $LL27@resetToTim@2
$LN123@resetToTim@2:

; 396  : 	for (vector<Bank>::iterator i = bank.begin(); i != bank.end(); i++)

	mov	eax, DWORD PTR [edi+184]
	mov	DWORD PTR $T456574[esp+28], eax
	cmp	eax, DWORD PTR [edi+188]
	jbe	SHORT $LN48@resetToTim@2
	call	__invalid_parameter_noinfo
$LN48@resetToTim@2:
	mov	ecx, DWORD PTR $T456574[esp+28]
	mov	ebx, DWORD PTR [edi+172]
	mov	DWORD PTR _i$135162[esp+32], ecx
	npad	3
$LL65@resetToTim@2:
	mov	eax, DWORD PTR [edi+188]
	mov	DWORD PTR $T456701[esp+28], eax
	cmp	DWORD PTR [edi+184], eax
	jbe	SHORT $LN80@resetToTim@2
	call	__invalid_parameter_noinfo
$LN80@resetToTim@2:
	mov	eax, DWORD PTR [edi+172]
	test	ebx, ebx
	je	SHORT $LN93@resetToTim@2
	cmp	ebx, eax
	je	SHORT $LN94@resetToTim@2
$LN93@resetToTim@2:
	call	__invalid_parameter_noinfo
$LN94@resetToTim@2:
	mov	edx, DWORD PTR $T456701[esp+28]
	cmp	DWORD PTR _i$135162[esp+32], edx
	je	SHORT $LN1@resetToTim@2

; 397  : 		i->resetToTime(time);

	test	ebx, ebx
	jne	SHORT $LN121@resetToTim@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN114@resetToTim@2:
	mov	ecx, DWORD PTR _i$135162[esp+32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN105@resetToTim@2
	call	__invalid_parameter_noinfo
$LN105@resetToTim@2:
	push	esi
	mov	esi, DWORD PTR _i$135162[esp+36]
	push	ebp
	call	?resetToTime@Bank@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Bank::resetToTime
	test	ebx, ebx
	jne	SHORT $LN120@resetToTim@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN72@resetToTim@2:
	mov	edx, DWORD PTR _i$135162[esp+32]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN63@resetToTim@2

; 396  : 	for (vector<Bank>::iterator i = bank.begin(); i != bank.end(); i++)

	call	__invalid_parameter_noinfo
$LN63@resetToTim@2:
	add	DWORD PTR _i$135162[esp+32], 152	; 00000098H
	mov	esi, DWORD PTR _time$[esp+28]
	jmp	SHORT $LL65@resetToTim@2
$LN121@resetToTim@2:

; 397  : 		i->resetToTime(time);

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN114@resetToTim@2
$LN120@resetToTim@2:

; 396  : 	for (vector<Bank>::iterator i = bank.begin(); i != bank.end(); i++)

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN72@resetToTim@2
$LN1@resetToTim@2:

; 398  : 
; 399  : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
?resetToTime@Rank@DRAMsimII@@QAEX_J@Z ENDP		; DRAMsimII::Rank::resetToTime
_TEXT	ENDS
PUBLIC	?getCommand@Rank@DRAMsimII@@QAEPAVCommand@2@I@Z	; DRAMsimII::Rank::getCommand
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tempCommand$134936 = 8					; size = 4
_thisBank$ = 8						; size = 4
?getCommand@Rank@DRAMsimII@@QAEPAVCommand@2@I@Z PROC	; DRAMsimII::Rank::getCommand
; _this$ = eax

; 348  : {

	push	ebx

; 349  : 	if (bank[thisBank].nextCommandType() == Command::REFRESH_ALL)

	mov	ebx, DWORD PTR _thisBank$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, eax
	mov	ecx, DWORD PTR [edi+188]
	sub	ecx, DWORD PTR [edi+184]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	jb	SHORT $LN12@getCommand
	call	__invalid_parameter_noinfo
$LN12@getCommand:
	mov	esi, DWORD PTR [edi+184]
	imul	ebx, 152				; 00000098H
	mov	ecx, DWORD PTR [esi+ebx+36]
	sub	ecx, DWORD PTR [esi+ebx+32]
	mov	ebp, DWORD PTR [esi+ebx+12]
	add	esi, ebx
	sar	ecx, 2
	cmp	ebp, ecx
	jb	SHORT $LN23@getCommand
	call	__invalid_parameter_noinfo
$LN23@getCommand:
	mov	edx, DWORD PTR [esi+32]
	cmp	DWORD PTR [edx+ebp*4], 0
	je	$LN7@getCommand
	mov	eax, DWORD PTR [esi+36]
	mov	ebp, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	cmp	ebp, eax
	jb	SHORT $LN30@getCommand
	call	__invalid_parameter_noinfo
$LN30@getCommand:
	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [ecx+ebp*4]
	cmp	DWORD PTR [edx+80], 12			; 0000000cH
	jne	$LN7@getCommand

; 350  : 	{
; 351  : 		if (refreshAllReady())

	push	edi
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	je	$LN6@getCommand

; 352  : 		{
; 353  : 			Command *tempCommand = NULL;
; 354  : 
; 355  : 			for (vector<Bank>::iterator currentBank = bank.begin(); currentBank != bank.end(); currentBank++)

	mov	esi, DWORD PTR [edi+184]
	mov	DWORD PTR _tempCommand$134936[esp+12], 0
	cmp	esi, DWORD PTR [edi+188]
	jbe	SHORT $LN42@getCommand
	call	__invalid_parameter_noinfo
$LN42@getCommand:
	mov	ebx, DWORD PTR [edi+172]
	mov	ebp, esi
	npad	8
$LL59@getCommand:
	mov	esi, DWORD PTR [edi+188]
	cmp	DWORD PTR [edi+184], esi
	jbe	SHORT $LN74@getCommand
	call	__invalid_parameter_noinfo
$LN74@getCommand:
	mov	eax, DWORD PTR [edi+172]
	test	ebx, ebx
	je	SHORT $LN87@getCommand
	cmp	ebx, eax
	je	SHORT $LN88@getCommand
$LN87@getCommand:
	call	__invalid_parameter_noinfo
$LN88@getCommand:
	cmp	ebp, esi
	je	SHORT $LN3@getCommand

; 356  : 			{
; 357  : 				delete tempCommand;

	mov	ecx, DWORD PTR _tempCommand$134936[esp+12]
	test	ecx, ecx
	je	SHORT $LN10@getCommand
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN10@getCommand:

; 358  : 
; 359  : 				tempCommand = currentBank->pop();

	test	ebx, ebx
	jne	SHORT $LN122@getCommand
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN108@getCommand:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN99@getCommand
	call	__invalid_parameter_noinfo
$LN99@getCommand:
	lea	esi, DWORD PTR [ebp+8]
	call	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop
	mov	DWORD PTR _tempCommand$134936[esp+12], eax
	test	ebx, ebx
	jne	SHORT $LN121@getCommand
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN66@getCommand:

; 352  : 		{
; 353  : 			Command *tempCommand = NULL;
; 354  : 
; 355  : 			for (vector<Bank>::iterator currentBank = bank.begin(); currentBank != bank.end(); currentBank++)

	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN57@getCommand
	call	__invalid_parameter_noinfo
$LN57@getCommand:
	add	ebp, 152				; 00000098H
	jmp	SHORT $LL59@getCommand
$LN122@getCommand:

; 358  : 
; 359  : 				tempCommand = currentBank->pop();

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN108@getCommand
$LN121@getCommand:

; 352  : 		{
; 353  : 			Command *tempCommand = NULL;
; 354  : 
; 355  : 			for (vector<Bank>::iterator currentBank = bank.begin(); currentBank != bank.end(); currentBank++)

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN66@getCommand
$LN3@getCommand:

; 360  : 
; 361  : 				assert(tempCommand->isRefresh());
; 362  : 			}
; 363  : 
; 364  : 			return tempCommand;

	mov	eax, DWORD PTR _tempCommand$134936[esp+12]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 374  : 	}
; 375  : }

	ret	4
$LN6@getCommand:
	pop	edi
	pop	esi
	pop	ebp

; 365  : 		}
; 366  : 		else
; 367  : 		{
; 368  : 			return NULL;

	xor	eax, eax
	pop	ebx

; 374  : 	}
; 375  : }

	ret	4
$LN7@getCommand:

; 369  : 		}
; 370  : 	}
; 371  : 	else
; 372  : 	{
; 373  : 		return bank[thisBank].pop();

	mov	ecx, DWORD PTR [edi+188]
	sub	ecx, DWORD PTR [edi+184]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	DWORD PTR _thisBank$[esp+12], eax
	jb	SHORT $LN113@getCommand
	call	__invalid_parameter_noinfo
$LN113@getCommand:
	mov	edi, DWORD PTR [edi+184]
	add	edi, ebx
	lea	esi, DWORD PTR [edi+8]
	call	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 374  : 	}
; 375  : }

	ret	4
?getCommand@Rank@DRAMsimII@@QAEPAVCommand@2@I@Z ENDP	; DRAMsimII::Rank::getCommand
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\exception\exception.hpp
;	COMDAT ??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABVlength_error@std@@@Z
_TEXT	SEGMENT
??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABVlength_error@std@@@Z PROC ; boost::exception_detail::error_info_injector<std::length_error>::error_info_injector<std::length_error>, COMDAT
; _this$ = esi
; _x$ = eax

; 271  :                 {

	push	eax
	mov	ecx, esi
	call	??0logic_error@std@@QAE@ABV01@@Z
	xor	eax, eax
	mov	DWORD PTR [esi+40], OFFSET ??_7exception@boost@@6B@
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR [esi+52], eax
	mov	DWORD PTR [esi+56], -1
	mov	DWORD PTR [esi], OFFSET ??_7?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Blength_error@std@@@
	mov	DWORD PTR [esi+40], OFFSET ??_7?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Bexception@2@@

; 272  :                 }

	mov	eax, esi
	ret	0
??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABVlength_error@std@@@Z ENDP ; boost::exception_detail::error_info_injector<std::length_error>::error_info_injector<std::length_error>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$enable_error_info@Vlength_error@std@@@boost@@YA?AU?$error_info_injector@Vlength_error@std@@@exception_detail@0@ABVlength_error@std@@@Z
_TEXT	SEGMENT
$T520885 = -4						; size = 4
??$enable_error_info@Vlength_error@std@@@boost@@YA?AU?$error_info_injector@Vlength_error@std@@@exception_detail@0@ABVlength_error@std@@@Z PROC ; boost::enable_error_info<std::length_error>, COMDAT
; ___$ReturnUdt$ = esi
; _x$ = eax

; 315  :         {

	push	ecx
	push	edi
	xor	edi, edi

; 316  :         typedef typename exception_detail::enable_error_info_return_type<T>::type rt;
; 317  :         return rt(x);

	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T520885[esp+12], edi
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi+40], OFFSET ??_7exception@boost@@6B@
	mov	DWORD PTR [esi+44], edi
	mov	DWORD PTR [esi+48], edi
	mov	DWORD PTR [esi+52], edi
	mov	DWORD PTR [esi+56], -1
	mov	DWORD PTR [esi], OFFSET ??_7?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Blength_error@std@@@
	mov	DWORD PTR [esi+40], OFFSET ??_7?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Bexception@2@@
	mov	eax, esi
	pop	edi

; 318  :         }

	pop	ecx
	ret	0
??$enable_error_info@Vlength_error@std@@@boost@@YA?AU?$error_info_injector@Vlength_error@std@@@exception_detail@0@ABVlength_error@std@@@Z ENDP ; boost::enable_error_info<std::length_error>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@UAE@XZ
_TEXT	SEGMENT
??1?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@UAE@XZ PROC ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::~clone_impl<boost::exception_detail::error_info_injector<std::length_error> >, COMDAT
; _this$ = ecx

; 368  :                 {

	push	esi

; 369  :                 }

	mov	esi, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Blength_error@std@@@
	mov	DWORD PTR [ecx+40], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Bexception@2@@
	mov	DWORD PTR [ecx+60], OFFSET ??_7clone_base@exception_detail@boost@@6B@
	call	??1?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAE@XZ ; boost::exception_detail::error_info_injector<std::length_error>::~error_info_injector<std::length_error>
	pop	esi
	ret	0
??1?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@UAE@XZ ENDP ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::~clone_impl<boost::exception_detail::error_info_injector<std::length_error> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@UAEPAXI@Z PROC ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Blength_error@std@@@
	mov	DWORD PTR [esi+40], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Bexception@2@@
	mov	DWORD PTR [esi+60], OFFSET ??_7clone_base@exception_detail@boost@@6B@
	call	??1?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAE@XZ ; boost::exception_detail::error_info_injector<std::length_error>::~error_info_injector<std::length_error>
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@88
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@88:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@UAEPAXI@Z ENDP ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z$0
__ehfuncinfo$??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z PROC ; boost::exception_detail::error_info_injector<std::length_error>::error_info_injector<std::length_error>, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	mov	edi, DWORD PTR ___that$[esp+24]
	push	edi
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[esp+36], 0
	test	edi, edi
	je	SHORT $LN3@error_info@9
	add	edi, 40					; 00000028H
	jmp	SHORT $LN4@error_info@9
$LN3@error_info@9:
	xor	edi, edi
$LN4@error_info@9:
	mov	DWORD PTR [esi+40], OFFSET ??_7exception@boost@@6B@
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+44], ecx
	test	ecx, ecx
	je	SHORT $LN15@error_info@9
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
$LN15@error_info@9:
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+52], ecx
	mov	edx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+56], edx
	mov	DWORD PTR [esi], OFFSET ??_7?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Blength_error@std@@@
	mov	DWORD PTR [esi+40], OFFSET ??_7?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@6Bexception@2@@
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
__ehhandler$??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z ENDP ; boost::exception_detail::error_info_injector<std::length_error>::error_info_injector<std::length_error>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABV012@@Z PROC ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z
	mov	DWORD PTR [esi+60], OFFSET ??_7clone_base@exception_detail@boost@@6B@
	mov	DWORD PTR [esi], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Blength_error@std@@@
	mov	DWORD PTR [esi+40], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Bexception@2@@
	mov	DWORD PTR [esi+60], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABV012@@Z ENDP ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T520984 = -80						; size = 28
$T520983 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T520984[esp+92]
	mov	DWORD PTR $T520984[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T520984[esp+112], 0
	mov	BYTE PTR $T520984[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T520984[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T520983[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T520983[esp+88]
	push	ecx
	mov	DWORD PTR $T520983[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@7:
$LN44@Xlen@7:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T520984[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE_NI@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = eax

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi
	mov	esi, eax

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	esi, eax
	jne	SHORT $LN4@Buy@6

; 1105 : 			return (false);

	xor	al, al

; 1115 : 		}

	pop	esi
	ret	0
$LN4@Buy@6:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	esi, 28256363				; 01af286bH
	jbe	SHORT $LN2@Buy@6

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Xlen
$LN14@Buy@6:
$LN2@Buy@6:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, esi
	call	?allocate@?$allocator@VBank@DRAMsimII@@@std@@QAEPAVBank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Bank>::allocate

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	imul	esi, 152				; 00000098H
	add	esi, eax
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], esi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1

; 1115 : 		}

	pop	esi
	ret	0
$LN13@Buy@6:
?_Buy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Buy
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\exception\exception.hpp
xdata$x	SEGMENT
__unwindtable$??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z$1
__ehfuncinfo$??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z PROC ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >, COMDAT
; _x$ = ecx

; 363  :                 {

	push	-1
	push	__ehhandler$??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	esi, DWORD PTR _this$[esp+24]
	push	edi
	mov	ecx, esi
	call	??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi+60], OFFSET ??_7clone_base@exception_detail@boost@@6B@
	mov	BYTE PTR __$EHRec$[esp+36], 1
	mov	DWORD PTR [esi], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Blength_error@std@@@
	mov	DWORD PTR [esi+40], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Bexception@2@@
	mov	DWORD PTR [esi+60], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6B@

; 364  :                 copy_boost_exception(this,&x);

	test	edi, edi
	je	SHORT $LN3@clone_impl@5
	lea	ebx, DWORD PTR [edi+40]
	jmp	SHORT $LN4@clone_impl@5
$LN3@clone_impl@5:
	xor	ebx, ebx
$LN4@clone_impl@5:
	mov	ecx, DWORD PTR [esi+44]
	mov	edi, DWORD PTR [ebx+4]
	test	ecx, ecx
	je	SHORT $LN19@clone_impl@5
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	call	edx
$LN19@clone_impl@5:
	mov	DWORD PTR [esi+44], edi
	test	edi, edi
	je	SHORT $LN22@clone_impl@5
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, edi
	call	edx
$LN22@clone_impl@5:
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+52], ecx
	mov	edx, DWORD PTR [ebx+16]
	mov	DWORD PTR [esi+56], edx

; 365  :                 }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	jmp	??1?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAE@XZ ; boost::exception_detail::error_info_injector<std::length_error>::~error_info_injector<std::length_error>
__unwindfunclet$??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 60					; 0000003cH
	jmp	??1clone_base@exception_detail@boost@@UAE@XZ ; boost::exception_detail::clone_base::~clone_base
__ehhandler$??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z ENDP ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >
; Function compile flags: /Ogtpy
;	COMDAT ??$enable_current_exception@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@boost@@YA?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@0@ABU?$error_info_injector@Vlength_error@std@@@20@@Z
_TEXT	SEGMENT
$T559323 = -4						; size = 4
??$enable_current_exception@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@boost@@YA?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@0@ABU?$error_info_injector@Vlength_error@std@@@20@@Z PROC ; boost::enable_current_exception<boost::exception_detail::error_info_injector<std::length_error> >, COMDAT
; ___$ReturnUdt$ = esi
; _x$ = ecx

; 391  :         {

	push	ecx

; 392  :         return exception_detail::clone_impl<T>(x);

	push	esi
	mov	DWORD PTR $T559323[esp+8], 0
	call	??0?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@QAE@ABU?$error_info_injector@Vlength_error@std@@@12@@Z ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >
	mov	eax, esi

; 393  :         }

	pop	ecx
	ret	0
??$enable_current_exception@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@boost@@YA?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@0@ABU?$error_info_injector@Vlength_error@std@@@20@@Z ENDP ; boost::enable_current_exception<boost::exception_detail::error_info_injector<std::length_error> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rethrow@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEXXZ
_TEXT	SEGMENT
$T559328 = -64						; size = 64
?rethrow@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEXXZ PROC ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::rethrow, COMDAT
; _this$ = ecx

; 381  :                 {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 64					; 00000040H

; 382  :                 throw*this;

	lea	eax, DWORD PTR [ecx-60]
	push	eax
	lea	ecx, DWORD PTR $T559328[esp+68]
	call	??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z
	push	OFFSET __TI7?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@
	lea	eax, DWORD PTR $T559328[esp+68]
	push	eax
	mov	DWORD PTR $T559328[esp+72], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Blength_error@std@@@
	mov	DWORD PTR $T559328[esp+112], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Bexception@2@@
	mov	DWORD PTR $T559328[esp+132], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6B@
	call	__CxxThrowException@8
$LN12@rethrow@4:
$LN11@rethrow@4:
	int	3
?rethrow@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEXXZ ENDP ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::rethrow
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?clone@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEPBVclone_base@23@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?clone@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEPBVclone_base@23@XZ$0
__ehfuncinfo$?clone@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEPBVclone_base@23@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?clone@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEPBVclone_base@23@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\exception\exception.hpp
xdata$x	ENDS
;	COMDAT ?clone@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEPBVclone_base@23@XZ
_TEXT	SEGMENT
$T559350 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?clone@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEPBVclone_base@23@XZ PROC ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::clone, COMDAT
; _this$ = ecx

; 375  :                 {

	push	-1
	push	__ehhandler$?clone@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEPBVclone_base@23@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 376  :                 return new clone_impl(*this);

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T559350[esp+28], esi
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+36], eax
	cmp	esi, eax
	je	SHORT $LN6@clone@5
	lea	eax, DWORD PTR [edi-60]
	push	eax
	mov	ecx, esi
	call	??0?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@QAE@ABU012@@Z
	lea	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [eax], OFFSET ??_7clone_base@exception_detail@boost@@6B@
	mov	DWORD PTR [esi], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Blength_error@std@@@
	mov	DWORD PTR [esi+40], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6Bexception@2@@
	mov	DWORD PTR [eax], OFFSET ??_7?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@6B@
$LN6@clone@5:

; 377  :                 }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?clone@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEPBVclone_base@23@XZ$0:
	mov	eax, DWORD PTR $T559350[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?clone@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEPBVclone_base@23@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?clone@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEPBVclone_base@23@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?clone@?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@EBEPBVclone_base@23@XZ ENDP ; boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<std::length_error> >::clone
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\throw_exception.hpp
xdata$x	SEGMENT
__unwindtable$??$throw_exception@Vlength_error@std@@@boost@@YAXABVlength_error@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$throw_exception@Vlength_error@std@@@boost@@YAXABVlength_error@std@@@Z$0
__ehfuncinfo$??$throw_exception@Vlength_error@std@@@boost@@YAXABVlength_error@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$throw_exception@Vlength_error@std@@@boost@@YAXABVlength_error@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$throw_exception@Vlength_error@std@@@boost@@YAXABVlength_error@std@@@Z
_TEXT	SEGMENT
$T559381 = -140						; size = 60
$T559382 = -80						; size = 64
__$EHRec$ = -12						; size = 12
_e$ = 8							; size = 4
??$throw_exception@Vlength_error@std@@@boost@@YAXABVlength_error@std@@@Z PROC ; boost::throw_exception<std::length_error>, COMDAT

; 58   : {

	push	-1
	push	__ehhandler$??$throw_exception@Vlength_error@std@@@boost@@YAXABVlength_error@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 132				; 00000084H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+152]
	mov	DWORD PTR fs:0, eax

; 59   :     //All boost exceptions are required to derive std::exception,
; 60   :     //to ensure compatibility with BOOST_NO_EXCEPTIONS.
; 61   :     throw_exception_assert_compatibility(e);
; 62   : 
; 63   : #ifndef BOOST_EXCEPTION_DISABLE
; 64   :     throw enable_current_exception(enable_error_info(e));

	mov	eax, DWORD PTR _e$[esp+148]
	lea	esi, DWORD PTR $T559381[esp+152]
	call	??$enable_error_info@Vlength_error@std@@@boost@@YA?AU?$error_info_injector@Vlength_error@std@@@exception_detail@0@ABVlength_error@std@@@Z ; boost::enable_error_info<std::length_error>
	mov	ecx, eax
	lea	esi, DWORD PTR $T559382[esp+152]
	mov	DWORD PTR __$EHRec$[esp+160], 0
	call	??$enable_current_exception@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@boost@@YA?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@0@ABU?$error_info_injector@Vlength_error@std@@@20@@Z ; boost::enable_current_exception<boost::exception_detail::error_info_injector<std::length_error> >
	push	OFFSET __TI7?AV?$clone_impl@U?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@@exception_detail@boost@@
	mov	eax, esi
	push	eax
	call	__CxxThrowException@8
$LN8@throw_exce@3:
$LN7@throw_exce@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$throw_exception@Vlength_error@std@@@boost@@YAXABVlength_error@std@@@Z$0:
	lea	esi, DWORD PTR $T559381[ebp]
	jmp	??1?$error_info_injector@Vlength_error@std@@@exception_detail@boost@@UAE@XZ ; boost::exception_detail::error_info_injector<std::length_error>::~error_info_injector<std::length_error>
__ehhandler$??$throw_exception@Vlength_error@std@@@boost@@YAXABVlength_error@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-136]
	mov	ecx, DWORD PTR [edx-140]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$throw_exception@Vlength_error@std@@@boost@@YAXABVlength_error@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$throw_exception@Vlength_error@std@@@boost@@YAXABVlength_error@std@@@Z ENDP ; boost::throw_exception<std::length_error>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z$1
__ehfuncinfo$?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
xdata$x	ENDS
;	COMDAT ?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z
_TEXT	SEGMENT
$T559399 = -80						; size = 28
$T559398 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::allocate, COMDAT
; _n$ = ecx

; 2009 :     pointer allocate(size_type n) {

	push	-1
	push	__ehhandler$?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 2010 :         if (n > max_size())

	cmp	ecx, 536870911				; 1fffffffH
	jbe	SHORT $LN1@allocate@17

; 2011 :             throw_exception(std::length_error("circular_buffer"));

	push	15					; 0000000fH
	push	OFFSET ??_C@_0BA@BJAEHAHE@circular_buffer?$AA@
	lea	ecx, DWORD PTR $T559399[esp+92]
	mov	DWORD PTR $T559399[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T559399[esp+112], 0
	mov	BYTE PTR $T559399[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T559399[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T559398[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T559398[esp+84], OFFSET ??_7length_error@std@@6B@
	lea	ecx, DWORD PTR $T559398[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 1
	call	??$throw_exception@Vlength_error@std@@@boost@@YAXABVlength_error@std@@@Z ; boost::throw_exception<std::length_error>
$LN63@allocate@17:
$LN1@allocate@17:

; 2012 : #if BOOST_CB_ENABLE_DEBUG
; 2013 :         pointer p = (n == 0) ? 0 : m_alloc.allocate(n, 0);
; 2014 :         ::memset(p, cb_details::UNINITIALIZED, sizeof(value_type) * n);
; 2015 :         return p;
; 2016 : #else
; 2017 :         return (n == 0) ? 0 : m_alloc.allocate(n, 0);

	test	ecx, ecx
	jne	SHORT $LN4@allocate@17
	xor	eax, eax

; 2018 : #endif
; 2019 :     }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 80					; 00000050H
	ret	0
$LN4@allocate@17:

; 2012 : #if BOOST_CB_ENABLE_DEBUG
; 2013 :         pointer p = (n == 0) ? 0 : m_alloc.allocate(n, 0);
; 2014 :         ::memset(p, cb_details::UNINITIALIZED, sizeof(value_type) * n);
; 2015 :         return p;
; 2016 : #else
; 2017 :         return (n == 0) ? 0 : m_alloc.allocate(n, 0);

	call	?allocate@?$allocator@_J@std@@QAEPA_JI@Z ; std::allocator<__int64>::allocate

; 2018 : #endif
; 2019 :     }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 80					; 00000050H
	ret	0
$LN62@allocate@17:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z$0:
	lea	ecx, DWORD PTR $T559399[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z$1:
	lea	ecx, DWORD PTR $T559398[ebp]
	jmp	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
__ehhandler$?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::allocate
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z$0
__tryblocktable$??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z$2
__ehfuncinfo$??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
xdata$x	ENDS
;	COMDAT ??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
_buff$ = 12						; size = 4
_cb$ = 12						; size = 4
??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::operator=, COMDAT

; 1202 :     circular_buffer<T, Alloc>& operator = (const circular_buffer<T, Alloc>& cb) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR _cb$[ebp]

; 1203 :         if (this == &cb)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, ebx

; 1204 :             return *this;

	je	SHORT $LN3@operator@307

; 1205 :         pointer buff = allocate(cb.capacity());

	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	sar	ecx, 3
	call	?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::allocate
	mov	esi, eax

; 1206 :         BOOST_TRY {

	xor	eax, eax
	mov	DWORD PTR __$EHRec$[ebp+12], eax

; 1207 :             reset(buff, cb_details::uninitialized_copy_with_alloc(cb.begin(), cb.end(), buff, m_alloc), cb.capacity());

	mov	edi, DWORD PTR [ebx+4]
	sub	edi, DWORD PTR [ebx]
	xor	ecx, ecx
	sar	edi, 3
	mov	DWORD PTR _buff$[ebp], esi
	cmp	DWORD PTR [ebx+16], eax
	je	SHORT $LN20@operator@307
	mov	eax, DWORD PTR [ebx+8]
$LN20@operator@307:
	push	ecx
	push	ebx
	push	eax
	push	ebx
	mov	eax, esi
	call	??$uninitialized_copy_with_alloc@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@PA_JV?$allocator@_J@std@@@cb_details@boost@@YAPA_JU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@01@0PA_JAAV?$allocator@_J@std@@@Z ; boost::cb_details::uninitialized_copy_with_alloc<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,__int64 *,std::allocator<__int64> >
	add	esp, 16					; 00000010H
	push	edi
	mov	edi, esi
	mov	esi, DWORD PTR _this$[ebp]
	push	eax
	call	?reset@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_J0I@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::reset

; 1211 :         }
; 1212 :         BOOST_CATCH_END
; 1213 :         return *this;

	mov	eax, esi
$LN3@operator@307:

; 1214 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z$0:

; 1208 :         } BOOST_CATCH(...) {
; 1209 :             deallocate(buff, cb.capacity());

	mov	eax, DWORD PTR _buff$[ebp]
	test	eax, eax
	je	SHORT $LN32@operator@307
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@operator@307:

; 1210 :             BOOST_RETHROW

	push	0
	push	0
	call	__CxxThrowException@8
$LN37@operator@307:
$LN36@operator@307:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXI@Z
_TEXT	SEGMENT
?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXI@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::initialize_buffer, COMDAT
; _this$ = edi
; _buffer_capacity$ = esi

; 2086 :     void initialize_buffer(capacity_type buffer_capacity) {

	push	ecx

; 2087 :         m_buff = allocate(buffer_capacity);

	mov	ecx, esi
	call	?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::allocate
	mov	DWORD PTR [edi], eax

; 2088 :         m_end = m_buff + buffer_capacity;

	lea	eax, DWORD PTR [eax+esi*8]
	mov	DWORD PTR [edi+4], eax
	pop	ecx

; 2089 :     }

	ret	0
?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXI@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::initialize_buffer
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z$0
__tryblocktable$??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
xdata$x	ENDS
;	COMDAT ??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::circular_buffer<__int64,std::allocator<__int64> >, COMDAT
; _cb$ = ecx

; 1074 :     m_size(cb.size()), m_alloc(cb.get_allocator()) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	ebx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [ebx+16], eax

; 1075 :         initialize_buffer(cb.capacity());

	mov	esi, DWORD PTR [edi+4]
	sub	esi, DWORD PTR [edi]
	sar	esi, 3
	mov	ecx, esi
	call	?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::allocate
	lea	ecx, DWORD PTR [eax+esi*8]

; 1076 :         m_first = m_buff;
; 1077 :         BOOST_TRY {
; 1078 :             m_last = cb_details::uninitialized_copy_with_alloc(cb.begin(), cb.end(), m_buff, m_alloc);

	xor	edx, edx
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR [ebx+4], ecx
	mov	DWORD PTR [ebx+8], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	cmp	DWORD PTR [edi+16], edx
	jne	SHORT $LN21@circular_b@2
	xor	ecx, ecx
	jmp	SHORT $LN22@circular_b@2
$LN21@circular_b@2:
	mov	ecx, DWORD PTR [edi+8]
$LN22@circular_b@2:
	push	edx
	push	edi
	push	ecx
	push	edi
	call	??$uninitialized_copy_with_alloc@U?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@cb_details@boost@@PA_JV?$allocator@_J@std@@@cb_details@boost@@YAPA_JU?$iterator@V?$circular_buffer@_JV?$allocator@_J@std@@@boost@@U?$const_traits@V?$allocator@_J@std@@@cb_details@2@@01@0PA_JAAV?$allocator@_J@std@@@Z ; boost::cb_details::uninitialized_copy_with_alloc<boost::cb_details::iterator<boost::circular_buffer<__int64,std::allocator<__int64> >,boost::cb_details::const_traits<std::allocator<__int64> > >,__int64 *,std::allocator<__int64> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ebx+12], eax

; 1082 :         }
; 1083 :         BOOST_CATCH_END
; 1084 :         if (m_last == m_end)

	cmp	eax, DWORD PTR [ebx+4]
	jne	SHORT $LN1@circular_b@2

; 1085 :             m_last = m_buff;

	mov	edx, DWORD PTR [ebx]
	mov	DWORD PTR [ebx+12], edx
$LN1@circular_b@2:

; 1086 :     }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z$0:

; 1079 :         } BOOST_CATCH(...) {
; 1080 :             deallocate(m_buff, cb.capacity());

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN34@circular_b@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@circular_b@2:

; 1081 :             BOOST_RETHROW

	push	0
	push	0
	call	__CxxThrowException@8
$LN39@circular_b@2:
$LN38@circular_b@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::circular_buffer<__int64,std::allocator<__int64> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z$0
__tryblocktable$?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z$2
__ehfuncinfo$?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z
	DD	01H
	DD	FLAT:__tryblocktable$?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
xdata$x	ENDS
;	COMDAT ?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
_item$ = 12						; size = 4
?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::initialize_buffer, COMDAT

; 2092 :     void initialize_buffer(capacity_type buffer_capacity, param_value_type item) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR _this$[ebp]

; 2093 :         initialize_buffer(buffer_capacity);

	mov	ecx, 4
	call	?allocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEPA_JI@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::allocate

; 2094 :         BOOST_TRY {
; 2095 :             cb_details::uninitialized_fill_n_with_alloc(m_buff, size(), item, m_alloc);

	mov	edx, DWORD PTR _item$[ebp]
	lea	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR [esi+16]
	push	eax
	mov	DWORD PTR [esi], eax
	call	??$uninitialized_fill_n_with_alloc@PA_JI_JV?$allocator@_J@std@@@cb_details@boost@@YAXPA_JIAB_JAAV?$allocator@_J@std@@@Z ; boost::cb_details::uninitialized_fill_n_with_alloc<__int64 *,unsigned int,__int64,std::allocator<__int64> >
	add	esp, 4

; 2099 :         }
; 2100 :         BOOST_CATCH_END
; 2101 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z$0:

; 2096 :         } BOOST_CATCH(...) {
; 2097 :             deallocate(m_buff, size());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN17@initialize@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@initialize@3:

; 2098 :             BOOST_RETHROW

	push	0
	push	0
	call	__CxxThrowException@8
$LN22@initialize@3:
$LN21@initialize@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::initialize_buffer
; Function compile flags: /Ogtpy
;	COMDAT ??$initialize@H@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIHHABU?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
$T597832 = -8						; size = 8
??$initialize@H@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIHHABU?$integral_constant@_N$00@1@@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::initialize<int>, COMDAT
; _this$ = esi

; 2142 :     void initialize(capacity_type buffer_capacity, IntegralType n, IntegralType item, const true_type&) {

	sub	esp, 12					; 0000000cH

; 2143 :         BOOST_CB_ASSERT(buffer_capacity >= static_cast<size_type>(n)); // check for capacity lower than n
; 2144 :         m_size = static_cast<size_type>(n);
; 2145 :         initialize_buffer(buffer_capacity, item);

	lea	eax, DWORD PTR $T597832[esp+12]
	push	eax
	push	esi
	mov	DWORD PTR [esi+16], 4
	mov	DWORD PTR $T597832[esp+20], -100	; ffffff9cH
	mov	DWORD PTR $T597832[esp+24], -1
	call	?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::initialize_buffer

; 2146 :         m_first = m_buff;
; 2147 :         m_last = buffer_capacity == size() ? m_buff : m_buff + size();

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+8], eax
	cmp	ecx, 4
	je	SHORT $LN9@initialize@4
	lea	eax, DWORD PTR [eax+ecx*8]
$LN9@initialize@4:
	mov	DWORD PTR [esi+12], eax

; 2148 :     }

	add	esp, 12					; 0000000cH
	ret	0
??$initialize@H@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIHHABU?$integral_constant@_N$00@1@@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::initialize<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0H@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@IHHABV?$allocator@_J@std@@@Z
_TEXT	SEGMENT
$T597865 = -8						; size = 8
??$?0H@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@IHHABV?$allocator@_J@std@@@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::circular_buffer<__int64,std::allocator<__int64> ><int>, COMDAT
; _this$ = esi

; 1152 :     circular_buffer(capacity_type buffer_capacity, InputIterator first, InputIterator last,

	sub	esp, 12					; 0000000cH

; 1153 :         const allocator_type& alloc = allocator_type())
; 1154 :     : m_alloc(alloc) {
; 1155 :         initialize(buffer_capacity, first, last, is_integral<InputIterator>());

	lea	eax, DWORD PTR $T597865[esp+12]
	push	eax
	push	esi
	mov	DWORD PTR [esi+16], 4
	mov	DWORD PTR $T597865[esp+20], -100	; ffffff9cH
	mov	DWORD PTR $T597865[esp+24], -1
	call	?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::initialize_buffer
	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+8], eax
	cmp	ecx, 4
	je	SHORT $LN13@allocator@7
	lea	eax, DWORD PTR [eax+ecx*8]
$LN13@allocator@7:
	mov	DWORD PTR [esi+12], eax

; 1156 :     }

	mov	eax, esi
	add	esp, 12					; 0000000cH
	ret	0
??$?0H@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@IHHABV?$allocator@_J@std@@@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::circular_buffer<__int64,std::allocator<__int64> ><int>
_TEXT	ENDS
PUBLIC	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVRank@0@@Z ; DRAMsimII::operator<<
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\rank.cpp
_TEXT	SEGMENT
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVRank@0@@Z PROC ; DRAMsimII::operator<<
; _os$ = edi
; _r$ = eax

; 491  : {

	push	ebx
	push	esi
	mov	esi, eax

; 492  : 	os << r.lastRefreshTime << endl;

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	push	eax
	push	ecx
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 493  : 	os << r.lastPrechargeAnyBankTime << endl;

	mov	edx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [esi+16]
	push	edx
	push	eax
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 494  : 	os << r.lastCASTime << endl;	

	mov	ecx, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [esi+24]
	push	ecx
	push	edx
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 495  : 	os << r.lastCASWTime << endl;	

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+32]
	push	eax
	push	ecx
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 496  : 	os << r.prechargeTime << endl;

	mov	edx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [esi+56]
	push	edx
	push	eax
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 497  : 	os << r.totalPrechargeTime << endl;

	mov	ecx, DWORD PTR [esi+68]
	mov	edx, DWORD PTR [esi+64]
	push	ecx
	push	edx
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 498  : 	os << r.lastCASLength << endl;	

	mov	eax, DWORD PTR [esi+112]
	push	eax
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 499  : 	os << r.lastCASWLength << endl;	

	mov	ecx, DWORD PTR [esi+116]
	push	ecx
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 500  : 	os << r.rankID << endl;			

	mov	edx, DWORD PTR [esi+136]
	push	edx
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 501  : 	os << r.lastBankID << endl;		

	mov	eax, DWORD PTR [esi+140]
	push	eax
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 502  : 	os << r.banksPrecharged << endl;	

	mov	ecx, DWORD PTR [esi+144]
	push	ecx
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	pop	esi

; 503  : 
; 504  : 	return os;

	mov	eax, edi
	pop	ebx

; 505  : }

	ret	0
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVRank@0@@Z ENDP ; DRAMsimII::operator<<
PUBLIC	?issuePRE@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z	; DRAMsimII::Rank::issuePRE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T623661 = 8						; size = 8
$T623660 = 8						; size = 8
_currentTime$ = 8					; size = 8
_currentCommand$ = 16					; size = 4
?issuePRE@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z PROC	; DRAMsimII::Rank::issuePRE
; _this$ = edi

; 179  : {

	push	ecx

; 180  : 	// update the bank to reflect this change also
; 181  : 	Bank &currentBank = bank[currentCommand->getAddress().getBank()];

	mov	ecx, DWORD PTR [edi+188]
	sub	ecx, DWORD PTR [edi+184]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	push	ebx
	mov	ebx, DWORD PTR _currentCommand$[esp+4]
	mov	eax, edx
	push	ebp
	shr	eax, 31					; 0000001fH
	push	esi
	mov	esi, DWORD PTR [ebx+64]
	add	eax, edx
	cmp	esi, eax
	jb	SHORT $LN12@issuePRE@3
	call	__invalid_parameter_noinfo
$LN12@issuePRE@3:

; 182  : 	currentBank.issuePRE(currentTime, currentCommand);

	mov	ebp, DWORD PTR _currentTime$[esp+16]
	imul	esi, 152				; 00000098H
	add	esi, DWORD PTR [edi+184]
	mov	ecx, DWORD PTR _currentTime$[esp+12]
	push	ebp
	push	ecx
	mov	eax, ebx
	mov	ecx, esi
	call	?issuePRE@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Bank::issuePRE

; 183  : 
; 184  : 	switch (currentCommand->getCommandType())

	mov	eax, DWORD PTR [ebx+80]
	sub	eax, 2
	je	SHORT $LN3@issuePRE@3
	sub	eax, 2
	je	SHORT $LN3@issuePRE@3
	sub	eax, 2
	je	SHORT $LN2@issuePRE@3

; 193  : 		break;
; 194  : 	default:
; 195  : 		cerr << "Unhandled CAS variant" << endl;

	push	OFFSET ??_C@_0BG@GJDAHMDK@Unhandled?5CAS?5variant?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 196  : 		break;

	jmp	SHORT $LN4@issuePRE@3
$LN2@issuePRE@3:

; 189  : 		break;
; 190  : 	case Command::PRECHARGE:
; 191  : 		// choose the latest time since there may be +Pre commands that have queued a Pre internally
; 192  : 		lastPrechargeAnyBankTime = max(lastPrechargeAnyBankTime, currentTime);

	mov	edx, DWORD PTR [edi+20]
	cmp	edx, ebp
	lea	eax, DWORD PTR [edi+16]
	jg	SHORT $LN23@issuePRE@3
	jl	SHORT $LN39@issuePRE@3
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _currentTime$[esp+12]
	jae	SHORT $LN23@issuePRE@3
$LN39@issuePRE@3:
	lea	ecx, DWORD PTR _currentTime$[esp+12]
	jmp	SHORT $LN24@issuePRE@3
$LN3@issuePRE@3:

; 185  : 	{
; 186  : 	case Command::READ_AND_PRECHARGE:		
; 187  : 	case Command::WRITE_AND_PRECHARGE:
; 188  : 		lastPrechargeAnyBankTime = max(lastPrechargeAnyBankTime, currentBank.getLastPrechargeTime());

	mov	ecx, DWORD PTR [esi+72]
	mov	esi, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [edi+20]
	cmp	edx, esi
	lea	eax, DWORD PTR [edi+16]
	mov	DWORD PTR $T623660[esp+12], ecx
	mov	DWORD PTR $T623660[esp+16], esi
	jg	SHORT $LN23@issuePRE@3
	jl	SHORT $LN40@issuePRE@3
	mov	edx, DWORD PTR [eax]
	cmp	edx, ecx
	jae	SHORT $LN23@issuePRE@3
$LN40@issuePRE@3:
	lea	ecx, DWORD PTR $T623660[esp+12]
	jmp	SHORT $LN24@issuePRE@3
$LN23@issuePRE@3:
	mov	ecx, eax
$LN24@issuePRE@3:
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@issuePRE@3:

; 197  : 	}
; 198  : 
; 199  : 	banksPrecharged++;

	inc	DWORD PTR [edi+144]

; 200  : 	assert(banksPrecharged > 0);
; 201  : 	assert(banksPrecharged <= bank.size());
; 202  : 
; 203  : 	// calculate when the next few commands can happen
; 204  : 	nextRefreshTime = max(nextRefreshTime, lastPrechargeAnyBankTime + timing.tRP());

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+44]
	mov	esi, DWORD PTR [edi+100]
	cdq
	add	eax, DWORD PTR [edi+16]
	lea	ecx, DWORD PTR [edi+96]
	adc	edx, DWORD PTR [edi+20]
	mov	DWORD PTR $T623661[esp+12], eax
	cmp	esi, edx
	mov	DWORD PTR $T623661[esp+16], edx
	jg	SHORT $LN37@issuePRE@3
	jl	SHORT $LN41@issuePRE@3
	mov	edx, DWORD PTR [ecx]
	cmp	edx, eax
	jae	SHORT $LN37@issuePRE@3
$LN41@issuePRE@3:
	lea	eax, DWORD PTR $T623661[esp+12]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax

; 205  : 	assert (nextRefreshTime == lastPrechargeAnyBankTime + timing.tRP() || nextRefreshTime == lastRefreshTime + timing.tRFC());
; 206  : 
; 207  : }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	12					; 0000000cH

; 200  : 	assert(banksPrecharged > 0);
; 201  : 	assert(banksPrecharged <= bank.size());
; 202  : 
; 203  : 	// calculate when the next few commands can happen
; 204  : 	nextRefreshTime = max(nextRefreshTime, lastPrechargeAnyBankTime + timing.tRP());

$LN37@issuePRE@3:
	mov	eax, ecx
	mov	edx, DWORD PTR [eax]

; 205  : 	assert (nextRefreshTime == lastPrechargeAnyBankTime + timing.tRP() || nextRefreshTime == lastRefreshTime + timing.tRFC());
; 206  : 
; 207  : }

	pop	esi
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	pop	ebp
	mov	DWORD PTR [ecx+4], eax
	pop	ebx
	pop	ecx
	ret	12					; 0000000cH
?issuePRE@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ENDP	; DRAMsimII::Rank::issuePRE
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Construct@VBank@DRAMsimII@@V12@@std@@YAXPAVBank@DRAMsimII@@ABV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VBank@DRAMsimII@@V12@@std@@YAXPAVBank@DRAMsimII@@ABV12@@Z$0
__ehfuncinfo$??$_Construct@VBank@DRAMsimII@@V12@@std@@YAXPAVBank@DRAMsimII@@ABV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VBank@DRAMsimII@@V12@@std@@YAXPAVBank@DRAMsimII@@ABV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@VBank@DRAMsimII@@V12@@std@@YAXPAVBank@DRAMsimII@@ABV12@@Z
_TEXT	SEGMENT
__Vptr$ = -20						; size = 4
$T644605 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??$_Construct@VBank@DRAMsimII@@V12@@std@@YAXPAVBank@DRAMsimII@@ABV12@@Z PROC ; std::_Construct<DRAMsimII::Bank,DRAMsimII::Bank>, COMDAT
; __Ptr$ = ecx
; __Val$ = edi

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@VBank@DRAMsimII@@V12@@std@@YAXPAVBank@DRAMsimII@@ABV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	DWORD PTR __Vptr$[esp+28], esi

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T644605[esp+28], esi
	mov	DWORD PTR __$EHRec$[esp+36], 0
	test	esi, esi
	je	SHORT $LN3@Construct@20
	call	??0Bank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Bank::Bank
$LN3@Construct@20:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VBank@DRAMsimII@@V12@@std@@YAXPAVBank@DRAMsimII@@ABV12@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T644605[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@VBank@DRAMsimII@@V12@@std@@YAXPAVBank@DRAMsimII@@ABV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@VBank@DRAMsimII@@V12@@std@@YAXPAVBank@DRAMsimII@@ABV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@VBank@DRAMsimII@@V12@@std@@YAXPAVBank@DRAMsimII@@ABV12@@Z ENDP ; std::_Construct<DRAMsimII::Bank,DRAMsimII::Bank>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVBank@DRAMsimII@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Copy_opt@PAVBank@DRAMsimII@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<DRAMsimII::Bank *,DRAMsimII::Bank *,std::forward_iterator_tag>, COMDAT
; __First$ = ecx
; __Dest$ = eax

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx
	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, eax

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	esi, ebx
	je	SHORT $LN1@Copy_opt@8
	npad	1
$LL3@Copy_opt@8:

; 2472 : 		*_Dest = *_First;

	push	esi
	call	??4Bank@DRAMsimII@@QAEAAV01@ABV01@@Z	; DRAMsimII::Bank::operator=
	add	esi, 152				; 00000098H
	add	edi, 152				; 00000098H
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt@8

; 2473 : 	return (_Dest);

	mov	eax, edi
$LN1@Copy_opt@8:

; 2474 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Copy_opt@PAVBank@DRAMsimII@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<DRAMsimII::Bank *,DRAMsimII::Bank *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@ABV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@ABV34@@Z$0
__ehfuncinfo$?construct@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@ABV34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@ABV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@ABV34@@Z
_TEXT	SEGMENT
__Vptr$644637 = -20					; size = 4
$T644640 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?construct@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@ABV34@@Z PROC ; std::allocator<DRAMsimII::Bank>::construct, COMDAT
; __Ptr$ = ecx
; __Val$ = edi

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@ABV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	DWORD PTR __Vptr$644637[esp+28], esi
	mov	DWORD PTR $T644640[esp+28], esi
	mov	DWORD PTR __$EHRec$[esp+36], 0
	test	esi, esi
	je	SHORT $LN5@construct@16
	call	??0Bank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Bank::Bank
$LN5@construct@16:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@ABV34@@Z$0:
	mov	eax, DWORD PTR __Vptr$644637[ebp]
	push	eax
	mov	ecx, DWORD PTR $T644640[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@ABV34@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@ABV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@ABV34@@Z ENDP ; std::allocator<DRAMsimII::Bank>::construct
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\smart_ptr\intrusive_ptr.hpp
xdata$x	SEGMENT
__unwindtable$??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4
__ehfuncinfo$??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T644682 = -24						; size = 4
__Vptr$644679 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<DRAMsimII::Bank *,unsigned int,DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; __Val$ = ecx

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	ebx, DWORD PTR __Count$[ebp]
	mov	esi, DWORD PTR __First$[ebp]

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	DWORD PTR __Next$[ebp], esi

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	npad	3
$LL6@Uninit_fil@13:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	test	ebx, ebx
	jbe	SHORT $LN4@Uninit_fil@13

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$644679[ebp], esi
	mov	DWORD PTR $T644682[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN18@Uninit_fil@13
	call	??0Bank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Bank::Bank
$LN18@Uninit_fil@13:
	dec	ebx
	add	esi, 152				; 00000098H
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@13
__catch$??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@13
$LL3@Uninit_fil@13:
	lea	eax, DWORD PTR [esi+8]

; 407  : 		_Al.destroy(_Next);

	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	add	esi, 152				; 00000098H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@13
$LN1@Uninit_fil@13:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN39@Uninit_fil@13:
$LN4@Uninit_fil@13:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@Uninit_fil@13:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$644679[ebp]
	push	eax
	mov	ecx, DWORD PTR $T644682[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<DRAMsimII::Bank *,unsigned int,DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVBank@DRAMsimII@@PAV12@@std@@YAPAVBank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv148 = 8						; size = 4
__Last$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Copy_opt@PAVBank@DRAMsimII@@PAV12@@std@@YAPAVBank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<DRAMsimII::Bank *,DRAMsimII::Bank *>, COMDAT
; __First$ = ecx
; __Dest$ = eax

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+8]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, eax

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	ecx, ebp
	sub	ecx, esi
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ebx, eax
	imul	ebx, 152				; 00000098H
	add	ebx, edi

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	cmp	esi, ebp
	je	SHORT $LN14@Copy_opt@9
	mov	eax, edi
	sub	eax, esi
	mov	DWORD PTR tv148[esp+16], eax
	jmp	SHORT $LN9@Copy_opt@9
	npad	6
$LL15@Copy_opt@9:
	mov	eax, DWORD PTR tv148[esp+16]
$LN9@Copy_opt@9:
	push	esi
	lea	edi, DWORD PTR [eax+esi]
	call	??4Bank@DRAMsimII@@QAEAAV01@ABV01@@Z	; DRAMsimII::Bank::operator=
	add	esi, 152				; 00000098H
	cmp	esi, ebp
	jne	SHORT $LL15@Copy_opt@9
$LN14@Copy_opt@9:

; 2486 : 	return _Result;
; 2487 : 	}

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	pop	ecx
	ret	0
??$_Copy_opt@PAVBank@DRAMsimII@@PAV12@@std@@YAPAVBank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<DRAMsimII::Bank *,DRAMsimII::Bank *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@stdext@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
$T644761 = -4						; size = 1
__Cat$644765 = -4					; size = 1
__First$ = 8						; size = 4
__Val$ = 12						; size = 4
??$unchecked_uninitialized_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@stdext@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Bank *,unsigned int,DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; __Count$ = edx

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	BYTE PTR $T644761[esp+4], 0
	mov	eax, DWORD PTR $T644761[esp+4]
	mov	ecx, DWORD PTR __Cat$644765[esp+4]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Val$[esp+8]
	push	edx
	push	eax
	call	??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Bank *,unsigned int,DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >

; 943  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$unchecked_uninitialized_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@stdext@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Bank *,unsigned int,DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAVBank@DRAMsimII@@PAV12@@stdext@@YAPAVBank@DRAMsimII@@PAV12@00@Z
_TEXT	SEGMENT
$T644770 = -4						; size = 1
__First$ = 8						; size = 4
__Cat$644775 = 12					; size = 1
$T644772 = 12						; size = 1
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVBank@DRAMsimII@@PAV12@@stdext@@YAPAVBank@DRAMsimII@@PAV12@00@Z PROC ; stdext::unchecked_copy<DRAMsimII::Bank *,DRAMsimII::Bank *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	sub	esp, 8

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$644775[esp+4]
	mov	edx, DWORD PTR $T644772[esp+4]
	mov	BYTE PTR $T644770[esp+8], 0
	mov	eax, DWORD PTR $T644770[esp+8]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+12]
	push	edx
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+20]
	call	??$_Copy_opt@PAVBank@DRAMsimII@@PAV12@@std@@YAPAVBank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Bank *,DRAMsimII::Bank *>

; 3607 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$unchecked_copy@PAVBank@DRAMsimII@@PAV12@@stdext@@YAPAVBank@DRAMsimII@@PAV12@00@Z ENDP ; stdext::unchecked_copy<DRAMsimII::Bank *,DRAMsimII::Bank *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEPAVBank@DRAMsimII@@PAV34@IABV34@@Z
_TEXT	SEGMENT
$T644813 = -4						; size = 1
__Cat$644816 = 8					; size = 1
__Val$ = 8						; size = 4
?_Ufill@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEPAVBank@DRAMsimII@@PAV34@IABV34@@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	sub	esp, 8

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	ecx, DWORD PTR __Cat$644816[esp+4]
	mov	BYTE PTR $T644813[esp+8], 0
	mov	eax, DWORD PTR $T644813[esp+8]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Val$[esp+12]
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Bank *,unsigned int,DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >

; 1255 : 		return (_Ptr + _Count);

	mov	eax, esi
	imul	eax, 152				; 00000098H
	add	eax, edi

; 1256 : 		}

	add	esp, 24					; 00000018H
	ret	4
?_Ufill@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEPAVBank@DRAMsimII@@PAV34@IABV34@@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@0@Z
_TEXT	SEGMENT
$T645008 = -4						; size = 1
__Cat$645012 = 8					; size = 1
$T645010 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@0@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::erase, COMDAT
; _this$ = esi

; 1028 : 		{	// erase [_First, _Last)

	push	ecx
	push	ebx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+4]
	push	ebp
	push	edi
	mov	DWORD PTR [ebx], 0
	test	esi, esi
	je	SHORT $LN8@erase@31
	mov	eax, DWORD PTR __First_arg$[esp+16]
	cmp	DWORD PTR [esi+12], eax
	ja	SHORT $LN8@erase@31
	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN9@erase@31
$LN8@erase@31:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+16]
$LN9@erase@31:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	edi, DWORD PTR __Last_arg$[esp+16]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [esi+12], edi
	ja	SHORT $LN24@erase@31
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN25@erase@31
$LN24@erase@31:
	call	__invalid_parameter_noinfo
	mov	edi, DWORD PTR __Last_arg$[esp+16]
$LN25@erase@31:

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN38@erase@31
	cmp	eax, ecx
	je	SHORT $LN39@erase@31
$LN38@erase@31:
	call	__invalid_parameter_noinfo
$LN39@erase@31:
	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, edi
	je	SHORT $LN83@erase@31

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ecx, DWORD PTR [esi+16]
	mov	BYTE PTR $T645008[esp+16], 0
	mov	edx, DWORD PTR $T645008[esp+16]
	push	edx
	mov	edx, DWORD PTR __Cat$645012[esp+16]
	push	edx
	mov	edx, DWORD PTR $T645010[esp+20]
	push	edx
	push	ecx
	mov	ecx, edi
	call	??$_Copy_opt@PAVBank@DRAMsimII@@PAV12@@std@@YAPAVBank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Bank *,DRAMsimII::Bank *>

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ebp, DWORD PTR [esi+16]
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	edi, ebx
	cmp	ebx, ebp
	je	SHORT $LN66@erase@31
	npad	4
$LL68@erase@31:
	lea	eax, DWORD PTR [edi+8]
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	add	edi, 152				; 00000098H
	cmp	edi, ebp
	jne	SHORT $LL68@erase@31
$LN66@erase@31:

; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+16], ebx

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]

; 1055 : #endif
; 1056 : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	20					; 00000014H
$LN83@erase@31:
	pop	edi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	pop	ecx
	ret	20					; 00000014H
?erase@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@0@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T645137 = -12						; size = 8
?clear@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXXZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 1060 : 		erase(begin(), end());

	mov	ebp, DWORD PTR [esi+16]
	push	edi
	cmp	DWORD PTR [esi+12], ebp
	jbe	SHORT $LN8@clear@22
	call	__invalid_parameter_noinfo
$LN8@clear@22:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN24@clear@22
	call	__invalid_parameter_noinfo
$LN24@clear@22:
	mov	eax, DWORD PTR [esi]
	push	ebp
	push	ebx
	push	edi
	push	eax
	lea	eax, DWORD PTR $T645137[esp+44]
	push	eax
	call	?erase@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@0@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::erase

; 1061 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
?clear@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXXZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::clear
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z$0
__tryblocktable$?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z$2
__ehfuncinfo$?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z
_TEXT	SEGMENT
$T645323 = -20						; size = 1
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Cat$645326 = 12					; size = 1
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Construct_n, COMDAT

; 545  : 		{	// construct from _Count * _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR _this$[ebp]

; 546  : 		if (_Buy(_Count))

	mov	ebx, DWORD PTR __Count$[ebp]
	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	cmp	ebx, eax
	je	SHORT $LN7@Construct_@8
	cmp	ebx, 28256363				; 01af286bH
	jbe	SHORT $LN10@Construct_@8
	call	?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Xlen
$LN32@Construct_@8:
$LN10@Construct_@8:
	mov	ecx, ebx
	call	?allocate@?$allocator@VBank@DRAMsimII@@@std@@QAEPAVBank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Bank>::allocate
	imul	ebx, 152				; 00000098H
	mov	edi, eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	edx, DWORD PTR __Cat$645326[ebp]
	mov	BYTE PTR $T645323[ebp], 0
	mov	ecx, DWORD PTR $T645323[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Val$[ebp]
	lea	eax, DWORD PTR [ebx+edi]
	mov	DWORD PTR [esi+20], eax
	mov	eax, DWORD PTR __Count$[ebp]
	push	edx
	push	eax
	push	edi
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	call	??$_Uninit_fill_n@PAVBank@DRAMsimII@@IV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@IABV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Bank *,unsigned int,DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	add	esp, 16					; 00000010H
	add	ebx, edi
	mov	DWORD PTR [esi+16], ebx
$LN7@Construct_@8:

; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z$0:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Tidy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Tidy

; 552  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN33@Construct_@8:
$LN31@Construct_@8:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Construct_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@IABVBank@DRAMsimII@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@IABVBank@DRAMsimII@@@Z$0
__ehfuncinfo$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@IABVBank@DRAMsimII@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@IABVBank@DRAMsimII@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@IABVBank@DRAMsimII@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@IABVBank@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT

; 488  : 		{	// construct from _Count * _Val

	push	-1
	push	__ehhandler$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@IABVBank@DRAMsimII@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@vector@46
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@46
$LN13@vector@46:
	xor	eax, eax
$LN14@vector@46:
	mov	DWORD PTR [esi], eax

; 489  : 		_Construct_n(_Count, _Val);

	mov	eax, DWORD PTR __Val$[esp+20]
	mov	ecx, DWORD PTR __Count$[esp+20]
	push	eax
	push	ecx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+44], 0
	call	?_Construct_n@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXIABVBank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Construct_n

; 490  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@IABVBank@DRAMsimII@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@IABVBank@DRAMsimII@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@IABVBank@DRAMsimII@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@IABVBank@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ; DRAMsimII::Rank::Rank
__unwindtable$??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z$2
__ehfuncinfo$??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\rank.cpp
_TEXT	SEGMENT
$T645513 = -176						; size = 8
$T645474 = -168						; size = 152
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_settings$ = 12						; size = 4
_timing$ = 16						; size = 4
_systemConfig$ = 20					; size = 4
??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z PROC ; DRAMsimII::Rank::Rank

; 53   : {}

	push	-1
	push	__ehhandler$??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 164				; 000000a4H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+196]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _settings$[esp+192]
	mov	edi, DWORD PTR _this$[esp+192]
	mov	eax, DWORD PTR _timing$[esp+192]
	mov	DWORD PTR [edi], eax
	mov	ecx, DWORD PTR [ebp+360]
	xor	edx, edx
	mov	esi, edx
	neg	ecx
	adc	edx, esi
	or	eax, -1
	mov	DWORD PTR [edi+8], ecx
	mov	ecx, -100				; ffffff9cH
	neg	edx
	mov	DWORD PTR [edi+12], edx
	mov	DWORD PTR [edi+20], eax
	mov	DWORD PTR [edi+28], eax
	mov	DWORD PTR [edi+36], eax
	mov	DWORD PTR [edi+44], eax
	mov	DWORD PTR [edi+52], eax
	mov	DWORD PTR [edi+136], eax
	mov	DWORD PTR [edi+16], ecx
	mov	DWORD PTR [edi+24], ecx
	mov	DWORD PTR [edi+32], ecx
	mov	DWORD PTR [edi+40], ecx
	mov	DWORD PTR [edi+48], ecx
	mov	DWORD PTR [edi+56], esi
	mov	DWORD PTR [edi+60], esi
	mov	DWORD PTR [edi+64], esi
	mov	DWORD PTR [edi+68], esi
	mov	DWORD PTR [edi+72], esi
	mov	DWORD PTR [edi+76], esi
	mov	DWORD PTR [edi+80], esi
	mov	DWORD PTR [edi+84], esi
	mov	DWORD PTR [edi+88], esi
	mov	DWORD PTR [edi+92], esi
	mov	DWORD PTR [edi+96], esi
	mov	DWORD PTR [edi+100], esi
	mov	DWORD PTR [edi+104], esi
	mov	DWORD PTR [edi+108], esi
	mov	DWORD PTR [edi+112], esi
	mov	DWORD PTR [edi+116], esi
	mov	DWORD PTR [edi+120], esi
	mov	DWORD PTR [edi+124], esi
	mov	DWORD PTR [edi+128], esi
	mov	DWORD PTR [edi+132], esi
	mov	edx, DWORD PTR [ebp+308]
	mov	DWORD PTR $T645513[esp+200], eax
	lea	eax, DWORD PTR $T645513[esp+196]
	dec	edx
	lea	ebx, DWORD PTR [edi+148]
	push	eax
	mov	DWORD PTR [edi+140], edx
	mov	DWORD PTR [edi+144], esi
	push	ebx
	mov	DWORD PTR [ebx+16], 4
	mov	DWORD PTR $T645513[esp+204], ecx
	call	?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::initialize_buffer
	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ebx+8], eax
	cmp	ecx, 4
	je	SHORT $LN15@Rank@2
	lea	eax, DWORD PTR [eax+ecx*8]
$LN15@Rank@2:
	mov	DWORD PTR [ebx+12], eax
	mov	ebx, DWORD PTR _systemConfig$[esp+192]
	mov	eax, DWORD PTR _timing$[esp+192]
	mov	DWORD PTR __$EHRec$[esp+204], esi
	push	ebp
	mov	ecx, ebx
	lea	esi, DWORD PTR $T645474[esp+200]
	call	??0Bank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ; DRAMsimII::Bank::Bank
	mov	BYTE PTR __$EHRec$[esp+204], 1
	mov	ecx, DWORD PTR [ebx+364]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR [edi+172]
	push	ecx
	call	??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@IABVBank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	lea	edx, DWORD PTR $T645474[esp+204]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+208], 3
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[esp+196]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 176				; 000000b0H
	ret	16					; 00000010H
__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 148				; 00000094H
	jmp	??1?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@XZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::~circular_buffer<__int64,std::allocator<__int64> >
__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z$1:
	lea	eax, DWORD PTR $T645474[ebp]
	jmp	??1Bank@DRAMsimII@@QAE@XZ
__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z$2:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 172				; 000000acH
	push	eax
	call	??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	ret	0
__ehhandler$??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-180]
	mov	ecx, DWORD PTR [edx-184]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z
	jmp	___CxxFrameHandler3
??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ENDP ; DRAMsimII::Rank::Rank
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\smart_ptr\intrusive_ptr.hpp
xdata$x	SEGMENT
__unwindtable$??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4
__ehfuncinfo$??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T649410 = -28						; size = 4
__Vptr$649416 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Last$ = 8						; size = 4
__Dest$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<DRAMsimII::Bank *,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >, COMDAT
; __First$ = ecx

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR __Dest$[ebp]
	mov	edi, ecx

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
$LL6@Uninit_cop@7:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@7

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$649416[ebp], esi
	mov	DWORD PTR $T649410[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@7
	call	??0Bank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Bank::Bank
$LN18@Uninit_cop@7:
	add	esi, 152				; 00000098H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 152				; 00000098H
	jmp	SHORT $LL6@Uninit_cop@7
__catch$??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@7
	npad	2
$LL3@Uninit_cop@7:
	lea	eax, DWORD PTR [esi+8]

; 134  : 		_Al.destroy(_Next);

	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	add	esi, 152				; 00000098H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@7
$LN1@Uninit_cop@7:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN39@Uninit_cop@7:
$LN4@Uninit_cop@7:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);

	mov	eax, esi

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@Uninit_cop@7:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$649416[ebp]
	push	eax
	mov	ecx, DWORD PTR $T649410[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<DRAMsimII::Bank *,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\smart_ptr\intrusive_ptr.hpp
xdata$x	SEGMENT
__unwindtable$??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4
__ehfuncinfo$??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T649490 = -28						; size = 4
__Vptr$649487 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Last$ = 8						; size = 4
__Dest$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<DRAMsimII::Bank const *,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >, COMDAT
; __First$ = ecx

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR __Dest$[ebp]
	mov	edi, ecx

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
$LL6@Uninit_cop@8:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@8

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$649487[ebp], esi
	mov	DWORD PTR $T649490[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@8
	call	??0Bank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Bank::Bank
$LN18@Uninit_cop@8:
	add	esi, 152				; 00000098H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 152				; 00000098H
	jmp	SHORT $LL6@Uninit_cop@8
__catch$??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@8
	npad	2
$LL3@Uninit_cop@8:
	lea	eax, DWORD PTR [esi+8]

; 134  : 		_Al.destroy(_Next);

	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	add	esi, 152				; 00000098H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@8
$LN1@Uninit_cop@8:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN39@Uninit_cop@8:
$LN4@Uninit_cop@8:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);

	mov	eax, esi

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@Uninit_cop@8:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$649487[ebp]
	push	eax
	mov	ecx, DWORD PTR $T649490[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<DRAMsimII::Bank const *,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@stdext@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
$T649540 = -4						; size = 1
__First$ = 8						; size = 4
__Cat$649544 = 12					; size = 1
__Last$ = 12						; size = 4
??$unchecked_uninitialized_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@stdext@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<DRAMsimII::Bank *,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >, COMDAT
; __Dest$ = edx

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$649544[esp]
	mov	BYTE PTR $T649540[esp+4], 0
	mov	eax, DWORD PTR $T649540[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+8]
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Bank *,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >

; 823  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$unchecked_uninitialized_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@stdext@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<DRAMsimII::Bank *,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@PAVBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@2@@stdext@@YAPAVBank@DRAMsimII@@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@4@@Z
_TEXT	SEGMENT
$T649569 = -4						; size = 1
__First$ = 8						; size = 8
__Cat$649573 = 16					; size = 1
__Last$ = 16						; size = 8
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@PAVBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@2@@stdext@@YAPAVBank@DRAMsimII@@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >, COMDAT
; __Dest$ = edx

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$649573[esp]
	mov	BYTE PTR $T649569[esp+4], 0
	mov	eax, DWORD PTR $T649569[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+12]
	push	edx
	push	eax
	call	??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Bank const *,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >

; 823  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@PAVBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@2@@stdext@@YAPAVBank@DRAMsimII@@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAVBank@DRAMsimII@@@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEPAVBank@DRAMsimII@@PAV23@00@Z
_TEXT	SEGMENT
$T649640 = -4						; size = 1
__First$ = 8						; size = 4
__Cat$649643 = 12					; size = 1
__Last$ = 12						; size = 4
??$_Ucopy@PAVBank@DRAMsimII@@@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEPAVBank@DRAMsimII@@PAV23@00@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Ucopy<DRAMsimII::Bank *>, COMDAT
; __Ptr$ = edx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	ecx, DWORD PTR __Cat$649643[esp]
	mov	BYTE PTR $T649640[esp+4], 0
	mov	eax, DWORD PTR $T649640[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+8]
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PAV12@00AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Bank *,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >

; 1142 : 		}

	add	esp, 20					; 00000014H
	ret	8
??$_Ucopy@PAVBank@DRAMsimII@@@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEPAVBank@DRAMsimII@@PAV23@00@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Ucopy<DRAMsimII::Bank *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEPAVBank@DRAMsimII@@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@1@0PAV23@@Z
_TEXT	SEGMENT
$T649704 = -4						; size = 1
__First$ = 8						; size = 8
__Cat$649707 = 16					; size = 1
__Last$ = 16						; size = 8
??$_Ucopy@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEPAVBank@DRAMsimII@@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@1@0PAV23@@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Ucopy<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >, COMDAT
; __Ptr$ = edx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	ecx, DWORD PTR __Cat$649707[esp]
	mov	BYTE PTR $T649704[esp+4], 0
	mov	eax, DWORD PTR $T649704[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+12]
	push	edx
	push	eax
	call	??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Bank const *,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >

; 1142 : 		}

	add	esp, 20					; 00000014H
	ret	16					; 00000010H
??$_Ucopy@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEPAVBank@DRAMsimII@@V?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@1@0PAV23@@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Ucopy<std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T649773 = 8						; size = 1
__Cat$649777 = 8					; size = 1
$T649775 = 8						; size = 1
__Right$ = 8						; size = 4
??4?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator=, COMDAT
; _this$ = esi

; 563  : 		{	// assign _Right

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Right$[esp+8]
	push	edi

; 564  : 		if (this != &_Right)

	cmp	esi, ebp
	je	$LN47@operator@360

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	eax, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [ebp+16]
	sub	ecx, eax
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	jne	SHORT $LN8@operator@360

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	eax, esi
	call	?clear@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEXXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::clear

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN8@operator@360:

; 573  : 			else if (_Right.size() <= size())

	mov	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+12]
	sub	edx, ecx
	mov	eax, 1808407283				; 6bca1af3H
	imul	edx
	sar	edx, 6
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	cmp	edi, ebx
	ja	SHORT $LN6@operator@360

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	BYTE PTR $T649773[esp+12], 0
	mov	eax, DWORD PTR $T649773[esp+12]
	mov	edx, DWORD PTR __Cat$649777[esp+12]
	push	eax
	mov	eax, DWORD PTR $T649775[esp+16]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ebp+16]
	push	eax
	mov	eax, ecx
	mov	ecx, DWORD PTR [ebp+12]
	call	??$_Copy_opt@PAVBank@DRAMsimII@@PAV12@@std@@YAPAVBank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Bank *,DRAMsimII::Bank *>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	edi, DWORD PTR [esi+16]
	add	esp, 16					; 00000010H
	call	?_Destroy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXPAVBank@DRAMsimII@@0@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR [ebp+16]
	sub	ecx, DWORD PTR [ebp+12]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	imul	ecx, 152				; 00000098H
	add	ecx, DWORD PTR [esi+12]

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	mov	DWORD PTR [esi+16], ecx

; 599  : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN6@operator@360:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ecx, ecx
	jne	SHORT $LN38@operator@360
	xor	eax, eax
	jmp	SHORT $LN39@operator@360
$LN38@operator@360:
	mov	edx, DWORD PTR [esi+20]
	sub	edx, ecx
	mov	eax, 1808407283				; 6bca1af3H
	imul	edx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$LN39@operator@360:
	cmp	edi, eax
	ja	SHORT $LN4@operator@360

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, DWORD PTR [ebp+12]
	imul	ebx, 152				; 00000098H

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ecx
	add	ebx, eax
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVBank@DRAMsimII@@PAV12@@stdext@@YAPAVBank@DRAMsimII@@PAV12@00@Z ; stdext::unchecked_copy<DRAMsimII::Bank *,DRAMsimII::Bank *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR [ebp+16]
	add	esp, 12					; 0000000cH
	push	edx
	mov	edx, DWORD PTR [esi+16]
	push	ebx

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	call	??$_Ucopy@PAVBank@DRAMsimII@@@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEPAVBank@DRAMsimII@@PAV23@00@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Ucopy<DRAMsimII::Bank *>
	mov	DWORD PTR [esi+16], eax

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN4@operator@360:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ecx, ecx
	je	SHORT $LN42@operator@360

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [esi+16]
	mov	eax, ecx
	call	?_Destroy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXPAVBank@DRAMsimII@@0@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN42@operator@360:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR [ebp+16]
	sub	ecx, DWORD PTR [ebp+12]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edi, esi
	call	?_Buy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE_NI@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Buy
	test	al, al
	je	SHORT $LN47@operator@360

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [ebp+12]
	push	ecx
	push	edx
	mov	edx, DWORD PTR [esi+12]
	call	??$_Ucopy@PAVBank@DRAMsimII@@@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEPAVBank@DRAMsimII@@PAV23@00@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Ucopy<DRAMsimII::Bank *>
	mov	DWORD PTR [esi+16], eax
$LN47@operator@360:

; 599  : 		}

	pop	edi
	pop	ebp
	mov	eax, esi
	pop	ebx
	pop	ecx
	ret	4
??4?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator=
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$5
__ehfuncinfo$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T650017 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$650152 = 8					; size = 1
_this$ = 8						; size = 4
$T650149 = 12						; size = 1
__Right$ = 12						; size = 4
??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR __Right$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@vector@47
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN20@vector@47
$LN19@vector@47:
	xor	eax, eax
$LN20@vector@47:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR [ebx+16]
	sub	ecx, DWORD PTR [ebx+12]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	edi, edx
	mov	eax, 0
	shr	edi, 31					; 0000001fH
	add	edi, edx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	je	SHORT $LN8@vector@47
	cmp	edi, 28256363				; 01af286bH
	jbe	SHORT $LN46@vector@47
	call	?_Xlen@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Xlen
$LN107@vector@47:
$LN46@vector@47:
	mov	ecx, edi
	call	?allocate@?$allocator@VBank@DRAMsimII@@@std@@QAEPAVBank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Bank>::allocate
	imul	edi, 152				; 00000098H
	add	edi, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], edi

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR $T650017[ebp], eax
	cmp	DWORD PTR [ebx+12], eax
	jbe	SHORT $LN60@vector@47
	call	__invalid_parameter_noinfo
$LN60@vector@47:
	mov	edi, DWORD PTR [ebx+12]
	cmp	edi, DWORD PTR [ebx+16]
	jbe	SHORT $LN74@vector@47
	call	__invalid_parameter_noinfo
$LN74@vector@47:
	mov	edx, DWORD PTR __Cat$650152[ebp]
	mov	eax, DWORD PTR [esi+12]
	mov	BYTE PTR $T650149[ebp], 0
	mov	ecx, DWORD PTR $T650149[ebp]
	push	ecx
	push	edx
	push	eax
	mov	eax, DWORD PTR $T650017[ebp]
	push	eax
	mov	ecx, edi
	call	??$_Uninit_copy@PBVBank@DRAMsimII@@PAV12@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAPAVBank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Bank const *,DRAMsimII::Bank *,std::allocator<DRAMsimII::Bank> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+16], eax
$LN8@vector@47:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Tidy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN108@vector@47:
$LN106@vector@47:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	eax, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	??4Rank@DRAMsimII@@QAEAAV01@ABV01@@Z		; DRAMsimII::Rank::operator=
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\rank.cpp
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4Rank@DRAMsimII@@QAEAAV01@ABV01@@Z PROC		; DRAMsimII::Rank::operator=
; _this$ = edi

; 455  : {

	push	ebx
	mov	ebx, DWORD PTR _rhs$[esp]

; 456  : 	//::new(this)DRAMsimII::Rank(rhs.timing,rhs.bank);
; 457  : 	lastRefreshTime = rhs.lastRefreshTime;

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [edi+8], eax
	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR [edi+12], ecx

; 458  : 	lastPrechargeAnyBankTime = rhs.lastPrechargeAnyBankTime;

	mov	edx, DWORD PTR [ebx+16]
	mov	DWORD PTR [edi+16], edx
	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [edi+20], eax

; 459  : 	lastCASTime = rhs.lastCASTime;

	mov	ecx, DWORD PTR [ebx+24]
	mov	DWORD PTR [edi+24], ecx
	mov	edx, DWORD PTR [ebx+28]
	mov	DWORD PTR [edi+28], edx

; 460  : 	lastCASWTime = rhs.lastCASWTime;

	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR [edi+32], eax
	mov	ecx, DWORD PTR [ebx+36]
	mov	DWORD PTR [edi+36], ecx

; 461  : 	prechargeTime = rhs.prechargeTime;

	mov	edx, DWORD PTR [ebx+56]
	mov	DWORD PTR [edi+56], edx
	mov	eax, DWORD PTR [ebx+60]
	mov	DWORD PTR [edi+60], eax

; 462  : 	totalPrechargeTime = rhs.totalPrechargeTime;

	mov	ecx, DWORD PTR [ebx+64]
	mov	DWORD PTR [edi+64], ecx
	mov	edx, DWORD PTR [ebx+68]
	mov	DWORD PTR [edi+68], edx

; 463  : 	lastCASLength = rhs.lastCASLength;

	mov	eax, DWORD PTR [ebx+112]
	mov	DWORD PTR [edi+112], eax

; 464  : 	lastCASWLength = rhs.lastCASWLength;

	mov	ecx, DWORD PTR [ebx+116]
	mov	DWORD PTR [edi+116], ecx

; 465  : 	rankID = rhs.rankID;

	mov	edx, DWORD PTR [ebx+136]
	mov	DWORD PTR [edi+136], edx

; 466  : 	lastBankID = rhs.lastBankID;

	mov	eax, DWORD PTR [ebx+140]
	push	esi
	mov	DWORD PTR [edi+140], eax

; 467  : 	banksPrecharged = rhs.banksPrecharged;

	mov	ecx, DWORD PTR [ebx+144]

; 468  : 	lastActivateTimes = rhs.lastActivateTimes;

	lea	edx, DWORD PTR [ebx+148]
	push	edx
	lea	eax, DWORD PTR [edi+148]
	push	eax
	mov	DWORD PTR [edi+144], ecx
	call	??4?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAAV01@ABV01@@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::operator=

; 469  : 	bank = rhs.bank;

	lea	ecx, DWORD PTR [ebx+172]
	push	ecx
	lea	esi, DWORD PTR [edi+172]
	call	??4?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator=

; 470  : 	CASLength = rhs.CASLength;

	mov	edx, DWORD PTR [ebx+128]
	mov	DWORD PTR [edi+128], edx

; 471  : 	CASWLength = rhs.CASWLength;

	mov	eax, DWORD PTR [ebx+132]
	mov	DWORD PTR [edi+132], eax

; 472  : 	otherLastCASTime = rhs.otherLastCASTime;

	mov	ecx, DWORD PTR [ebx+40]
	mov	DWORD PTR [edi+40], ecx
	mov	edx, DWORD PTR [ebx+44]
	mov	DWORD PTR [edi+44], edx

; 473  : 	otherLastCASWTime = rhs.otherLastCASWTime;

	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [edi+48], eax
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR [edi+52], ecx

; 474  : 	otherLastCASLength = rhs.otherLastCASLength;

	mov	edx, DWORD PTR [ebx+120]
	mov	DWORD PTR [edi+120], edx

; 475  : 	otherLastCASWLength = rhs.otherLastCASWLength;

	mov	eax, DWORD PTR [ebx+124]

; 476  : 
; 477  : 	return *this;
; 478  : }

	pop	esi
	mov	DWORD PTR [edi+124], eax
	mov	eax, edi
	pop	ebx
	ret	4
??4Rank@DRAMsimII@@QAEAAV01@ABV01@@Z ENDP		; DRAMsimII::Rank::operator=
_TEXT	ENDS
PUBLIC	??0Rank@DRAMsimII@@AAE@ABVTimingSpecification@1@ABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@Z ; DRAMsimII::Rank::Rank
__unwindtable$??0Rank@DRAMsimII@@AAE@ABVTimingSpecification@1@ABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Rank@DRAMsimII@@AAE@ABVTimingSpecification@1@ABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@Z$0
__ehfuncinfo$??0Rank@DRAMsimII@@AAE@ABVTimingSpecification@1@ABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Rank@DRAMsimII@@AAE@ABVTimingSpecification@1@ABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T650230 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_timingSpec$ = 12					; size = 4
_newBank$ = 16						; size = 4
??0Rank@DRAMsimII@@AAE@ABVTimingSpecification@1@ABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@Z PROC ; DRAMsimII::Rank::Rank

; 144  : {}

	push	-1
	push	__ehhandler$??0Rank@DRAMsimII@@AAE@ABVTimingSpecification@1@ABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _timingSpec$[esp+32]
	mov	esi, DWORD PTR _this$[esp+32]
	mov	edi, 0
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [eax+40]
	cdq
	neg	eax
	mov	DWORD PTR [esi+8], eax
	adc	edx, edi
	or	eax, -1
	mov	ecx, -100				; ffffff9cH
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [esi+52], eax
	mov	DWORD PTR [esi+136], eax
	mov	DWORD PTR $T650230[esp+40], eax
	lea	eax, DWORD PTR $T650230[esp+36]
	neg	edx
	lea	ebx, DWORD PTR [esi+148]
	push	eax
	mov	DWORD PTR [esi+12], edx
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+32], ecx
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+48], ecx
	mov	DWORD PTR [esi+56], edi
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+68], edi
	mov	DWORD PTR [esi+72], edi
	mov	DWORD PTR [esi+76], edi
	mov	DWORD PTR [esi+80], edi
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+88], edi
	mov	DWORD PTR [esi+92], edi
	mov	DWORD PTR [esi+96], edi
	mov	DWORD PTR [esi+100], edi
	mov	DWORD PTR [esi+104], edi
	mov	DWORD PTR [esi+108], edi
	mov	DWORD PTR [esi+112], edi
	mov	DWORD PTR [esi+116], edi
	mov	DWORD PTR [esi+120], edi
	mov	DWORD PTR [esi+124], edi
	mov	DWORD PTR [esi+128], edi
	mov	DWORD PTR [esi+132], edi
	mov	DWORD PTR [esi+140], edi
	mov	DWORD PTR [esi+144], edi
	push	ebx
	mov	DWORD PTR [ebx+16], 4
	mov	DWORD PTR $T650230[esp+44], ecx
	call	?initialize_buffer@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXIAB_J@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::initialize_buffer
	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ebx+8], eax
	cmp	ecx, 4
	je	SHORT $LN16@Rank@3
	lea	eax, DWORD PTR [eax+ecx*8]
$LN16@Rank@3:
	mov	DWORD PTR [ebx+12], eax
	mov	ecx, DWORD PTR _newBank$[esp+32]
	push	ecx
	lea	edx, DWORD PTR [esi+172]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+52], edi
	call	??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
__unwindfunclet$??0Rank@DRAMsimII@@AAE@ABVTimingSpecification@1@ABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 148				; 00000094H
	jmp	??1?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@XZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::~circular_buffer<__int64,std::allocator<__int64> >
__ehhandler$??0Rank@DRAMsimII@@AAE@ABVTimingSpecification@1@ABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Rank@DRAMsimII@@AAE@ABVTimingSpecification@1@ABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
??0Rank@DRAMsimII@@AAE@ABVTimingSpecification@1@ABV?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@@Z ENDP ; DRAMsimII::Rank::Rank
PUBLIC	??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ; DRAMsimII::Rank::Rank
__unwindtable$??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z$2
__ehfuncinfo$??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T650243 = -168						; size = 152
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_systemConfig$ = 12					; size = 4
??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z PROC ; DRAMsimII::Rank::Rank
; _rhs$ = edx
; _timing$ = ecx

; 109  : {

	push	-1
	push	__ehhandler$??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 156				; 0000009cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+188]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	esi, edx
	mov	ebx, DWORD PTR _this$[esp+184]
	mov	DWORD PTR [ebx], edi
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+8], eax
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [ebx+12], ecx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [ebx+16], edx
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [ebx+20], eax
	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [ebx+24], ecx
	mov	edx, DWORD PTR [esi+28]
	mov	DWORD PTR [ebx+28], edx
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [ebx+32], eax
	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR [ebx+36], ecx
	mov	edx, DWORD PTR [esi+40]
	mov	DWORD PTR [ebx+40], edx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [ebx+44], eax
	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [ebx+48], ecx
	mov	edx, DWORD PTR [esi+52]
	mov	DWORD PTR [ebx+52], edx
	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR [ebx+56], eax
	mov	ecx, DWORD PTR [esi+60]
	mov	DWORD PTR [ebx+60], ecx
	mov	edx, DWORD PTR [esi+64]
	mov	DWORD PTR [ebx+64], edx
	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [ebx+68], eax
	mov	ecx, DWORD PTR [esi+72]
	mov	DWORD PTR [ebx+72], ecx
	mov	edx, DWORD PTR [esi+76]
	mov	DWORD PTR [ebx+76], edx
	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR [ebx+80], eax
	mov	ecx, DWORD PTR [esi+84]
	mov	DWORD PTR [ebx+84], ecx
	mov	edx, DWORD PTR [esi+88]
	mov	DWORD PTR [ebx+88], edx
	mov	eax, DWORD PTR [esi+92]
	mov	DWORD PTR [ebx+92], eax
	mov	ecx, DWORD PTR [esi+96]
	mov	DWORD PTR [ebx+96], ecx
	mov	edx, DWORD PTR [esi+100]
	mov	DWORD PTR [ebx+100], edx
	xor	ebp, ebp
	mov	DWORD PTR [ebx+104], ebp
	mov	DWORD PTR [ebx+108], ebp
	mov	eax, DWORD PTR [esi+112]
	mov	DWORD PTR [ebx+112], eax
	mov	ecx, DWORD PTR [esi+116]
	mov	DWORD PTR [ebx+116], ecx
	mov	edx, DWORD PTR [esi+120]
	mov	DWORD PTR [ebx+120], edx
	mov	eax, DWORD PTR [esi+124]
	mov	DWORD PTR [ebx+124], eax
	mov	ecx, DWORD PTR [esi+128]
	mov	DWORD PTR [ebx+128], ecx
	mov	edx, DWORD PTR [esi+132]
	mov	DWORD PTR [ebx+132], edx
	mov	eax, DWORD PTR [esi+136]
	mov	DWORD PTR [ebx+136], eax
	mov	ecx, DWORD PTR [esi+140]
	mov	DWORD PTR [ebx+140], ecx
	mov	edx, DWORD PTR [esi+144]
	lea	eax, DWORD PTR [ebx+148]
	lea	ecx, DWORD PTR [esi+148]
	push	eax
	mov	DWORD PTR [ebx+144], edx
	call	??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::circular_buffer<__int64,std::allocator<__int64> >
	mov	DWORD PTR __$EHRec$[esp+196], ebp
	mov	ecx, DWORD PTR [esi+188]
	sub	ecx, DWORD PTR [esi+184]
	lea	ebp, DWORD PTR [esi+172]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	jne	SHORT $LN6@Rank@4
	call	__invalid_parameter_noinfo
$LN6@Rank@4:
	mov	edx, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR _systemConfig$[esp+184]
	mov	eax, edi
	mov	edi, edx
	lea	esi, DWORD PTR $T650243[esp+188]
	call	??0Bank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ; DRAMsimII::Bank::Bank
	mov	edx, DWORD PTR _systemConfig$[esp+184]
	mov	BYTE PTR __$EHRec$[esp+196], 1
	mov	ecx, DWORD PTR [edx+364]
	push	eax
	push	ecx
	lea	esi, DWORD PTR [ebx+172]
	push	esi
	call	??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@IABVBank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	lea	eax, DWORD PTR $T650243[esp+196]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+200], 3
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>

; 110  : 	// TODO: copy over values in banks now that reference members are init	
; 111  : 	//for (unsigned i = 0; i < systemConfig.getBankCount(); i++)
; 112  : 	//{
; 113  : 	//	bank[i] = rhs.bank[i];
; 114  : 	//}
; 115  : 	bank = rhs.bank;

	push	ebp
	call	??4?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator=

; 116  : }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+188]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 168				; 000000a8H
	ret	8
__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 148				; 00000094H
	jmp	??1?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@XZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::~circular_buffer<__int64,std::allocator<__int64> >
__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z$1:
	lea	eax, DWORD PTR $T650243[ebp]
	jmp	??1Bank@DRAMsimII@@QAE@XZ
__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z$2:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 172				; 000000acH
	push	eax
	call	??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	ret	0
__ehhandler$??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-172]
	mov	ecx, DWORD PTR [edx-176]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z
	jmp	___CxxFrameHandler3
??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ENDP ; DRAMsimII::Rank::Rank
PUBLIC	??0Rank@DRAMsimII@@QAE@ABV01@@Z			; DRAMsimII::Rank::Rank
__unwindtable$??0Rank@DRAMsimII@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABV01@@Z$0
__ehfuncinfo$??0Rank@DRAMsimII@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Rank@DRAMsimII@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0Rank@DRAMsimII@@QAE@ABV01@@Z PROC			; DRAMsimII::Rank::Rank
; _rhs$ = ecx

; 81   : {}

	push	-1
	push	__ehhandler$??0Rank@DRAMsimII@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	esi, DWORD PTR _this$[esp+20]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], ecx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], edx
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], eax
	mov	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR [esi+20], ecx
	mov	edx, DWORD PTR [edi+24]
	mov	DWORD PTR [esi+24], edx
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], eax
	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+32], ecx
	mov	edx, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+36], edx
	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR [esi+40], eax
	mov	ecx, DWORD PTR [edi+44]
	mov	DWORD PTR [esi+44], ecx
	mov	edx, DWORD PTR [edi+48]
	mov	DWORD PTR [esi+48], edx
	mov	eax, DWORD PTR [edi+52]
	mov	DWORD PTR [esi+52], eax
	mov	ecx, DWORD PTR [edi+56]
	mov	DWORD PTR [esi+56], ecx
	mov	edx, DWORD PTR [edi+60]
	mov	DWORD PTR [esi+60], edx
	mov	eax, DWORD PTR [edi+64]
	mov	DWORD PTR [esi+64], eax
	mov	ecx, DWORD PTR [edi+68]
	mov	DWORD PTR [esi+68], ecx
	mov	edx, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+72], edx
	mov	eax, DWORD PTR [edi+76]
	mov	DWORD PTR [esi+76], eax
	mov	ecx, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], ecx
	mov	edx, DWORD PTR [edi+84]
	mov	DWORD PTR [esi+84], edx
	mov	eax, DWORD PTR [edi+88]
	mov	DWORD PTR [esi+88], eax
	mov	ecx, DWORD PTR [edi+92]
	mov	DWORD PTR [esi+92], ecx
	mov	edx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], edx
	mov	eax, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], eax
	mov	DWORD PTR [esi+104], 0
	mov	DWORD PTR [esi+108], 0
	mov	ecx, DWORD PTR [edi+112]
	mov	DWORD PTR [esi+112], ecx
	mov	edx, DWORD PTR [edi+116]
	mov	DWORD PTR [esi+116], edx
	mov	eax, DWORD PTR [edi+120]
	mov	DWORD PTR [esi+120], eax
	mov	ecx, DWORD PTR [edi+124]
	mov	DWORD PTR [esi+124], ecx
	mov	edx, DWORD PTR [edi+128]
	mov	DWORD PTR [esi+128], edx
	mov	eax, DWORD PTR [edi+132]
	mov	DWORD PTR [esi+132], eax
	mov	ecx, DWORD PTR [edi+136]
	mov	DWORD PTR [esi+136], ecx
	mov	edx, DWORD PTR [edi+140]
	mov	DWORD PTR [esi+140], edx
	mov	eax, DWORD PTR [edi+144]
	lea	edx, DWORD PTR [esi+148]
	lea	ecx, DWORD PTR [edi+148]
	push	edx
	mov	DWORD PTR [esi+144], eax
	call	??0?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@ABV01@@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::circular_buffer<__int64,std::allocator<__int64> >
	add	edi, 172				; 000000acH
	push	edi
	lea	eax, DWORD PTR [esi+172]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+40], 0
	call	??0?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
__unwindfunclet$??0Rank@DRAMsimII@@QAE@ABV01@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 148				; 00000094H
	jmp	??1?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@XZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::~circular_buffer<__int64,std::allocator<__int64> >
__ehhandler$??0Rank@DRAMsimII@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Rank@DRAMsimII@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
??0Rank@DRAMsimII@@QAE@ABV01@@Z ENDP			; DRAMsimII::Rank::Rank
END
