; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\CriuS\Documents\Visual Studio 2008\Projects\DRAMsimIIhg\src\reporting\soapC.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_E_ns2__getSettingsFileResponseElement@@UAEPAXI@Z ; _ns2__getSettingsFileResponseElement::`vector deleting destructor'
PUBLIC	?soap_in@_ns2__getSettingsFileResponseElement@@UAEPAXPAUsoap@@PBD1@Z ; _ns2__getSettingsFileResponseElement::soap_in
PUBLIC	?soap_get@_ns2__getSettingsFileResponseElement@@UAEPAXPAUsoap@@PBD1@Z ; _ns2__getSettingsFileResponseElement::soap_get
PUBLIC	?soap_out@_ns2__getSettingsFileResponseElement@@UBEHPAUsoap@@PBDH1@Z ; _ns2__getSettingsFileResponseElement::soap_out
PUBLIC	?soap_put@_ns2__getSettingsFileResponseElement@@UBEHPAUsoap@@PBD1@Z ; _ns2__getSettingsFileResponseElement::soap_put
PUBLIC	?soap_serialize@_ns2__getSettingsFileResponseElement@@UBEXPAUsoap@@@Z ; _ns2__getSettingsFileResponseElement::soap_serialize
PUBLIC	?soap_default@_ns2__getSettingsFileResponseElement@@UAEXPAUsoap@@@Z ; _ns2__getSettingsFileResponseElement::soap_default
PUBLIC	??_R4_ns2__getSettingsFileResponseElement@@6B@	; _ns2__getSettingsFileResponseElement::`RTTI Complete Object Locator'
PUBLIC	??_R3_ns2__getSettingsFileResponseElement@@8	; _ns2__getSettingsFileResponseElement::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_ns2__getSettingsFileResponseElement@@8	; _ns2__getSettingsFileResponseElement::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_ns2__getSettingsFileResponseElement@@8 ; _ns2__getSettingsFileResponseElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_ns2__getSettingsFileResponseElement@@@8 ; _ns2__getSettingsFileResponseElement `RTTI Type Descriptor'
PUBLIC	??_E_ns2__getSettingsFileElement@@UAEPAXI@Z	; _ns2__getSettingsFileElement::`vector deleting destructor'
PUBLIC	?soap_in@_ns2__getSettingsFileElement@@UAEPAXPAUsoap@@PBD1@Z ; _ns2__getSettingsFileElement::soap_in
PUBLIC	?soap_get@_ns2__getSettingsFileElement@@UAEPAXPAUsoap@@PBD1@Z ; _ns2__getSettingsFileElement::soap_get
PUBLIC	?soap_out@_ns2__getSettingsFileElement@@UBEHPAUsoap@@PBDH1@Z ; _ns2__getSettingsFileElement::soap_out
PUBLIC	?soap_put@_ns2__getSettingsFileElement@@UBEHPAUsoap@@PBD1@Z ; _ns2__getSettingsFileElement::soap_put
PUBLIC	?soap_serialize@_ns2__getSettingsFileElement@@UBEXPAUsoap@@@Z ; _ns2__getSettingsFileElement::soap_serialize
PUBLIC	?soap_default@_ns2__getSettingsFileElement@@UAEXPAUsoap@@@Z ; _ns2__getSettingsFileElement::soap_default
PUBLIC	??_R4_ns2__getSettingsFileElement@@6B@		; _ns2__getSettingsFileElement::`RTTI Complete Object Locator'
PUBLIC	??_R3_ns2__getSettingsFileElement@@8		; _ns2__getSettingsFileElement::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_ns2__getSettingsFileElement@@8		; _ns2__getSettingsFileElement::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_ns2__getSettingsFileElement@@8	; _ns2__getSettingsFileElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_ns2__getSettingsFileElement@@@8	; _ns2__getSettingsFileElement `RTTI Type Descriptor'
PUBLIC	??_E_ns2__getSessionIDResponseElement@@UAEPAXI@Z ; _ns2__getSessionIDResponseElement::`vector deleting destructor'
PUBLIC	?soap_in@_ns2__getSessionIDResponseElement@@UAEPAXPAUsoap@@PBD1@Z ; _ns2__getSessionIDResponseElement::soap_in
PUBLIC	?soap_get@_ns2__getSessionIDResponseElement@@UAEPAXPAUsoap@@PBD1@Z ; _ns2__getSessionIDResponseElement::soap_get
PUBLIC	?soap_out@_ns2__getSessionIDResponseElement@@UBEHPAUsoap@@PBDH1@Z ; _ns2__getSessionIDResponseElement::soap_out
PUBLIC	?soap_put@_ns2__getSessionIDResponseElement@@UBEHPAUsoap@@PBD1@Z ; _ns2__getSessionIDResponseElement::soap_put
PUBLIC	?soap_serialize@_ns2__getSessionIDResponseElement@@UBEXPAUsoap@@@Z ; _ns2__getSessionIDResponseElement::soap_serialize
PUBLIC	?soap_default@_ns2__getSessionIDResponseElement@@UAEXPAUsoap@@@Z ; _ns2__getSessionIDResponseElement::soap_default
PUBLIC	??_R4_ns2__getSessionIDResponseElement@@6B@	; _ns2__getSessionIDResponseElement::`RTTI Complete Object Locator'
PUBLIC	??_R3_ns2__getSessionIDResponseElement@@8	; _ns2__getSessionIDResponseElement::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_ns2__getSessionIDResponseElement@@8	; _ns2__getSessionIDResponseElement::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_ns2__getSessionIDResponseElement@@8 ; _ns2__getSessionIDResponseElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_ns2__getSessionIDResponseElement@@@8	; _ns2__getSessionIDResponseElement `RTTI Type Descriptor'
PUBLIC	??_E_ns2__getSessionIDElement@@UAEPAXI@Z	; _ns2__getSessionIDElement::`vector deleting destructor'
PUBLIC	?soap_in@_ns2__getSessionIDElement@@UAEPAXPAUsoap@@PBD1@Z ; _ns2__getSessionIDElement::soap_in
PUBLIC	?soap_get@_ns2__getSessionIDElement@@UAEPAXPAUsoap@@PBD1@Z ; _ns2__getSessionIDElement::soap_get
PUBLIC	?soap_out@_ns2__getSessionIDElement@@UBEHPAUsoap@@PBDH1@Z ; _ns2__getSessionIDElement::soap_out
PUBLIC	?soap_put@_ns2__getSessionIDElement@@UBEHPAUsoap@@PBD1@Z ; _ns2__getSessionIDElement::soap_put
PUBLIC	?soap_serialize@_ns2__getSessionIDElement@@UBEXPAUsoap@@@Z ; _ns2__getSessionIDElement::soap_serialize
PUBLIC	?soap_default@_ns2__getSessionIDElement@@UAEXPAUsoap@@@Z ; _ns2__getSessionIDElement::soap_default
PUBLIC	??_R4_ns2__getSessionIDElement@@6B@		; _ns2__getSessionIDElement::`RTTI Complete Object Locator'
PUBLIC	??_R3_ns2__getSessionIDElement@@8		; _ns2__getSessionIDElement::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_ns2__getSessionIDElement@@8		; _ns2__getSessionIDElement::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_ns2__getSessionIDElement@@8	; _ns2__getSessionIDElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_ns2__getSessionIDElement@@@8		; _ns2__getSessionIDElement `RTTI Type Descriptor'
PUBLIC	??_Exsd__string@@UAEPAXI@Z			; xsd__string::`vector deleting destructor'
PUBLIC	?soap_in@xsd__string@@UAEPAXPAUsoap@@PBD1@Z	; xsd__string::soap_in
PUBLIC	?soap_get@xsd__string@@UAEPAXPAUsoap@@PBD1@Z	; xsd__string::soap_get
PUBLIC	?soap_out@xsd__string@@UBEHPAUsoap@@PBDH1@Z	; xsd__string::soap_out
PUBLIC	?soap_put@xsd__string@@UBEHPAUsoap@@PBD1@Z	; xsd__string::soap_put
PUBLIC	?soap_serialize@xsd__string@@UBEXPAUsoap@@@Z	; xsd__string::soap_serialize
PUBLIC	?soap_default@xsd__string@@UAEXPAUsoap@@@Z	; xsd__string::soap_default
PUBLIC	??_R4xsd__string@@6B@				; xsd__string::`RTTI Complete Object Locator'
PUBLIC	??_R3xsd__string@@8				; xsd__string::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2xsd__string@@8				; xsd__string::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@xsd__string@@8			; xsd__string::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVxsd__string@@@8				; xsd__string `RTTI Type Descriptor'
PUBLIC	??_Exsd__long@@UAEPAXI@Z			; xsd__long::`vector deleting destructor'
PUBLIC	?soap_in@xsd__long@@UAEPAXPAUsoap@@PBD1@Z	; xsd__long::soap_in
PUBLIC	?soap_get@xsd__long@@UAEPAXPAUsoap@@PBD1@Z	; xsd__long::soap_get
PUBLIC	?soap_out@xsd__long@@UBEHPAUsoap@@PBDH1@Z	; xsd__long::soap_out
PUBLIC	?soap_put@xsd__long@@UBEHPAUsoap@@PBD1@Z	; xsd__long::soap_put
PUBLIC	?soap_serialize@xsd__long@@UBEXPAUsoap@@@Z	; xsd__long::soap_serialize
PUBLIC	?soap_default@xsd__long@@UAEXPAUsoap@@@Z	; xsd__long::soap_default
PUBLIC	??_R4xsd__long@@6B@				; xsd__long::`RTTI Complete Object Locator'
PUBLIC	??_R3xsd__long@@8				; xsd__long::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2xsd__long@@8				; xsd__long::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@xsd__long@@8			; xsd__long::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVxsd__long@@@8				; xsd__long `RTTI Type Descriptor'
PUBLIC	??_Exsd__int@@UAEPAXI@Z				; xsd__int::`vector deleting destructor'
PUBLIC	?soap_in@xsd__int@@UAEPAXPAUsoap@@PBD1@Z	; xsd__int::soap_in
PUBLIC	?soap_get@xsd__int@@UAEPAXPAUsoap@@PBD1@Z	; xsd__int::soap_get
PUBLIC	?soap_out@xsd__int@@UBEHPAUsoap@@PBDH1@Z	; xsd__int::soap_out
PUBLIC	?soap_put@xsd__int@@UBEHPAUsoap@@PBD1@Z		; xsd__int::soap_put
PUBLIC	?soap_serialize@xsd__int@@UBEXPAUsoap@@@Z	; xsd__int::soap_serialize
PUBLIC	?soap_default@xsd__int@@UAEXPAUsoap@@@Z		; xsd__int::soap_default
PUBLIC	??_R4xsd__int@@6B@				; xsd__int::`RTTI Complete Object Locator'
PUBLIC	??_R3xsd__int@@8				; xsd__int::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2xsd__int@@8				; xsd__int::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@xsd__int@@8			; xsd__int::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVxsd__int@@@8				; xsd__int `RTTI Type Descriptor'
PUBLIC	??_Exsd__float@@UAEPAXI@Z			; xsd__float::`vector deleting destructor'
PUBLIC	?soap_in@xsd__float@@UAEPAXPAUsoap@@PBD1@Z	; xsd__float::soap_in
PUBLIC	?soap_get@xsd__float@@UAEPAXPAUsoap@@PBD1@Z	; xsd__float::soap_get
PUBLIC	?soap_out@xsd__float@@UBEHPAUsoap@@PBDH1@Z	; xsd__float::soap_out
PUBLIC	?soap_put@xsd__float@@UBEHPAUsoap@@PBD1@Z	; xsd__float::soap_put
PUBLIC	?soap_serialize@xsd__float@@UBEXPAUsoap@@@Z	; xsd__float::soap_serialize
PUBLIC	?soap_default@xsd__float@@UAEXPAUsoap@@@Z	; xsd__float::soap_default
PUBLIC	??_R4xsd__float@@6B@				; xsd__float::`RTTI Complete Object Locator'
PUBLIC	??_R3xsd__float@@8				; xsd__float::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2xsd__float@@8				; xsd__float::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@xsd__float@@8			; xsd__float::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVxsd__float@@@8				; xsd__float `RTTI Type Descriptor'
PUBLIC	??_Exsd__boolean@@UAEPAXI@Z			; xsd__boolean::`vector deleting destructor'
PUBLIC	?soap_in@xsd__boolean@@UAEPAXPAUsoap@@PBD1@Z	; xsd__boolean::soap_in
PUBLIC	?soap_get@xsd__boolean@@UAEPAXPAUsoap@@PBD1@Z	; xsd__boolean::soap_get
PUBLIC	?soap_out@xsd__boolean@@UBEHPAUsoap@@PBDH1@Z	; xsd__boolean::soap_out
PUBLIC	?soap_put@xsd__boolean@@UBEHPAUsoap@@PBD1@Z	; xsd__boolean::soap_put
PUBLIC	?soap_serialize@xsd__boolean@@UBEXPAUsoap@@@Z	; xsd__boolean::soap_serialize
PUBLIC	?soap_default@xsd__boolean@@UAEXPAUsoap@@@Z	; xsd__boolean::soap_default
PUBLIC	??_R4xsd__boolean@@6B@				; xsd__boolean::`RTTI Complete Object Locator'
PUBLIC	??_R3xsd__boolean@@8				; xsd__boolean::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2xsd__boolean@@8				; xsd__boolean::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@xsd__boolean@@8			; xsd__boolean::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVxsd__boolean@@@8			; xsd__boolean `RTTI Type Descriptor'
PUBLIC	??_Exsd__anyType@@UAEPAXI@Z			; xsd__anyType::`vector deleting destructor'
PUBLIC	?soap_in@xsd__anyType@@UAEPAXPAUsoap@@PBD1@Z	; xsd__anyType::soap_in
PUBLIC	?soap_get@xsd__anyType@@UAEPAXPAUsoap@@PBD1@Z	; xsd__anyType::soap_get
PUBLIC	?soap_out@xsd__anyType@@UBEHPAUsoap@@PBDH1@Z	; xsd__anyType::soap_out
PUBLIC	?soap_put@xsd__anyType@@UBEHPAUsoap@@PBD1@Z	; xsd__anyType::soap_put
PUBLIC	?soap_serialize@xsd__anyType@@UBEXPAUsoap@@@Z	; xsd__anyType::soap_serialize
PUBLIC	?soap_default@xsd__anyType@@UAEXPAUsoap@@@Z	; xsd__anyType::soap_default
PUBLIC	??_R4xsd__anyType@@6B@				; xsd__anyType::`RTTI Complete Object Locator'
PUBLIC	??_R3xsd__anyType@@8				; xsd__anyType::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2xsd__anyType@@8				; xsd__anyType::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@xsd__anyType@@8			; xsd__anyType::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVxsd__anyType@@@8			; xsd__anyType `RTTI Type Descriptor'
PUBLIC	??_E_ns2__submitEpochResultResponseElement@@UAEPAXI@Z ; _ns2__submitEpochResultResponseElement::`vector deleting destructor'
PUBLIC	?soap_in@_ns2__submitEpochResultResponseElement@@UAEPAXPAUsoap@@PBD1@Z ; _ns2__submitEpochResultResponseElement::soap_in
PUBLIC	?soap_get@_ns2__submitEpochResultResponseElement@@UAEPAXPAUsoap@@PBD1@Z ; _ns2__submitEpochResultResponseElement::soap_get
PUBLIC	?soap_out@_ns2__submitEpochResultResponseElement@@UBEHPAUsoap@@PBDH1@Z ; _ns2__submitEpochResultResponseElement::soap_out
PUBLIC	?soap_put@_ns2__submitEpochResultResponseElement@@UBEHPAUsoap@@PBD1@Z ; _ns2__submitEpochResultResponseElement::soap_put
PUBLIC	?soap_serialize@_ns2__submitEpochResultResponseElement@@UBEXPAUsoap@@@Z ; _ns2__submitEpochResultResponseElement::soap_serialize
PUBLIC	?soap_default@_ns2__submitEpochResultResponseElement@@UAEXPAUsoap@@@Z ; _ns2__submitEpochResultResponseElement::soap_default
PUBLIC	??_E_ns2__submitEpochResultElement@@UAEPAXI@Z	; _ns2__submitEpochResultElement::`vector deleting destructor'
PUBLIC	?soap_in@_ns2__submitEpochResultElement@@UAEPAXPAUsoap@@PBD1@Z ; _ns2__submitEpochResultElement::soap_in
PUBLIC	?soap_get@_ns2__submitEpochResultElement@@UAEPAXPAUsoap@@PBD1@Z ; _ns2__submitEpochResultElement::soap_get
PUBLIC	?soap_out@_ns2__submitEpochResultElement@@UBEHPAUsoap@@PBDH1@Z ; _ns2__submitEpochResultElement::soap_out
PUBLIC	?soap_put@_ns2__submitEpochResultElement@@UBEHPAUsoap@@PBD1@Z ; _ns2__submitEpochResultElement::soap_put
PUBLIC	?soap_serialize@_ns2__submitEpochResultElement@@UBEXPAUsoap@@@Z ; _ns2__submitEpochResultElement::soap_serialize
PUBLIC	?soap_default@_ns2__submitEpochResultElement@@UAEXPAUsoap@@@Z ; _ns2__submitEpochResultElement::soap_default
PUBLIC	??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ; std::vector<int,std::allocator<int> >::`scalar deleting destructor'
PUBLIC	??_G?$vector@MV?$allocator@M@std@@@std@@QAEPAXI@Z ; std::vector<float,std::allocator<float> >::`scalar deleting destructor'
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
PUBLIC	??4_ns2__submitEpochResultResponseElement@@QAEAAV0@ABV0@@Z ; _ns2__submitEpochResultResponseElement::operator=
PUBLIC	??4_ns2__submitEpochResultElement@@QAEAAV0@ABV0@@Z ; _ns2__submitEpochResultElement::operator=
PUBLIC	??0_ns2__getSettingsFileResponseElement@@QAE@XZ	; _ns2__getSettingsFileResponseElement::_ns2__getSettingsFileResponseElement
PUBLIC	?soap_type@_ns2__getSettingsFileResponseElement@@UBEHXZ ; _ns2__getSettingsFileResponseElement::soap_type
PUBLIC	??1_ns2__getSettingsFileResponseElement@@UAE@XZ	; _ns2__getSettingsFileResponseElement::~_ns2__getSettingsFileResponseElement
PUBLIC	??4_ns2__getSettingsFileResponseElement@@QAEAAV0@ABV0@@Z ; _ns2__getSettingsFileResponseElement::operator=
PUBLIC	??0_ns2__getSettingsFileElement@@QAE@XZ		; _ns2__getSettingsFileElement::_ns2__getSettingsFileElement
PUBLIC	?soap_type@_ns2__getSettingsFileElement@@UBEHXZ	; _ns2__getSettingsFileElement::soap_type
PUBLIC	??1_ns2__getSettingsFileElement@@UAE@XZ		; _ns2__getSettingsFileElement::~_ns2__getSettingsFileElement
PUBLIC	??4_ns2__getSettingsFileElement@@QAEAAV0@ABV0@@Z ; _ns2__getSettingsFileElement::operator=
PUBLIC	??0_ns2__getSessionIDResponseElement@@QAE@XZ	; _ns2__getSessionIDResponseElement::_ns2__getSessionIDResponseElement
PUBLIC	?soap_type@_ns2__getSessionIDResponseElement@@UBEHXZ ; _ns2__getSessionIDResponseElement::soap_type
PUBLIC	??1_ns2__getSessionIDResponseElement@@UAE@XZ	; _ns2__getSessionIDResponseElement::~_ns2__getSessionIDResponseElement
PUBLIC	??4_ns2__getSessionIDResponseElement@@QAEAAV0@ABV0@@Z ; _ns2__getSessionIDResponseElement::operator=
PUBLIC	??0_ns2__getSessionIDElement@@QAE@XZ		; _ns2__getSessionIDElement::_ns2__getSessionIDElement
PUBLIC	?soap_type@_ns2__getSessionIDElement@@UBEHXZ	; _ns2__getSessionIDElement::soap_type
PUBLIC	??1_ns2__getSessionIDElement@@UAE@XZ		; _ns2__getSessionIDElement::~_ns2__getSessionIDElement
PUBLIC	??4_ns2__getSessionIDElement@@QAEAAV0@ABV0@@Z	; _ns2__getSessionIDElement::operator=
PUBLIC	??4xsd__string@@QAEAAV0@ABV0@@Z			; xsd__string::operator=
PUBLIC	??4xsd__long@@QAEAAV0@ABV0@@Z			; xsd__long::operator=
PUBLIC	??4xsd__int@@QAEAAV0@ABV0@@Z			; xsd__int::operator=
PUBLIC	??4xsd__float@@QAEAAV0@ABV0@@Z			; xsd__float::operator=
PUBLIC	??4xsd__boolean@@QAEAAV0@ABV0@@Z		; xsd__boolean::operator=
PUBLIC	??0xsd__boolean@@QAE@XZ				; xsd__boolean::xsd__boolean
PUBLIC	?soap_type@xsd__boolean@@UBEHXZ			; xsd__boolean::soap_type
PUBLIC	??1xsd__boolean@@UAE@XZ				; xsd__boolean::~xsd__boolean
PUBLIC	??0xsd__float@@QAE@XZ				; xsd__float::xsd__float
PUBLIC	?soap_type@xsd__float@@UBEHXZ			; xsd__float::soap_type
PUBLIC	??1xsd__float@@UAE@XZ				; xsd__float::~xsd__float
PUBLIC	??0xsd__int@@QAE@XZ				; xsd__int::xsd__int
PUBLIC	?soap_type@xsd__int@@UBEHXZ			; xsd__int::soap_type
PUBLIC	??1xsd__int@@UAE@XZ				; xsd__int::~xsd__int
PUBLIC	??0xsd__long@@QAE@XZ				; xsd__long::xsd__long
PUBLIC	?soap_type@xsd__long@@UBEHXZ			; xsd__long::soap_type
PUBLIC	??1xsd__long@@UAE@XZ				; xsd__long::~xsd__long
PUBLIC	??0xsd__anyType@@QAE@XZ				; xsd__anyType::xsd__anyType
PUBLIC	??0xsd__string@@QAE@XZ				; xsd__string::xsd__string
PUBLIC	?soap_type@xsd__string@@UBEHXZ			; xsd__string::soap_type
PUBLIC	??1xsd__string@@UAE@XZ				; xsd__string::~xsd__string
PUBLIC	?soap_type@xsd__anyType@@UBEHXZ			; xsd__anyType::soap_type
PUBLIC	??1xsd__anyType@@UAE@XZ				; xsd__anyType::~xsd__anyType
PUBLIC	??4xsd__anyType@@QAEAAV0@ABV0@@Z		; xsd__anyType::operator=
PUBLIC	?begin@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@XZ ; std::vector<float,std::allocator<float> >::begin
PUBLIC	?end@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@XZ ; std::vector<float,std::allocator<float> >::end
PUBLIC	??D?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBEABMXZ ; std::_Vector_const_iterator<float,std::allocator<float> >::operator*
PUBLIC	??E?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<float,std::allocator<float> >::operator++
PUBLIC	??$_Uninit_move@PAMPAMV?$allocator@M@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<float *,float *,std::allocator<float>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z ; stdext::_Unchecked_uninitialized_move<float *,float *,std::allocator<float> >
PUBLIC	??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ; std::vector<float,std::allocator<float> >::_Umove<float *>
PUBLIC	??$_Fill@PAMM@std@@YAXPAM0ABM@Z			; std::_Fill<float *,float>
PUBLIC	??$fill@PAMM@std@@YAXPAM0ABM@Z			; std::fill<float *,float>
PUBLIC	??$_Move_cat@PAM@std@@YA?AU_Undefined_move_tag@0@ABQAM@Z ; std::_Move_cat<float *>
PUBLIC	??$_Copy_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<float *,float *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<float *,float *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAMPAM@stdext@@YAPAMPAM00@Z ; stdext::_Unchecked_move_backward<float *,float *>
PUBLIC	?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z ; std::vector<float,std::allocator<float> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<float,std::allocator<float> >::operator-
PUBLIC	??Y?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<float,std::allocator<float> >::operator+=
PUBLIC	??Y?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<float,std::allocator<float> >::operator+=
PUBLIC	??H?$_Vector_iterator@MV?$allocator@M@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<float,std::allocator<float> >::operator+
PUBLIC	?insert@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@ABM@Z ; std::vector<float,std::allocator<float> >::insert
PUBLIC	?push_back@?$vector@MV?$allocator@M@std@@@std@@QAEXABM@Z ; std::vector<float,std::allocator<float> >::push_back
PUBLIC	??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
PUBLIC	??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
PUBLIC	??_C@_0BA@GBPDPHCK@SOAP?9ENV?3Header?$AA@	; `string'
PUBLIC	??_C@_0P@GLDIJMBO@SOAP?9ENV?3Fault?$AA@		; `string'
PUBLIC	??_C@_08BEPNMEIH@xsd?3byte?$AA@			; `string'
PUBLIC	??_C@_07PCIGPDP@xsd?3int?$AA@			; `string'
PUBLIC	??_C@_08PNDIDGIB@xsd?3long?$AA@			; `string'
PUBLIC	??_C@_09ILBLHFBD@xsd?3float?$AA@		; `string'
PUBLIC	??_C@_0M@FGHMEICI@xsd?3boolean?$AA@		; `string'
PUBLIC	??_C@_0L@DIJPMJCO@xsd?3string?$AA@		; `string'
PUBLIC	??_C@_0M@NOIFKOBF@xsd?3anyType?$AA@		; `string'
PUBLIC	??_C@_0CF@HCKJIEH@ns2?3submitEpochResultResponseEle@ ; `string'
PUBLIC	??_C@_0BN@LEHNEPKC@ns2?3submitEpochResultElement?$AA@ ; `string'
PUBLIC	??_C@_0CD@GADHDKNA@ns2?3getSettingsFileResponseEleme@ ; `string'
PUBLIC	??_C@_0BL@EBHOCBLE@ns2?3getSettingsFileElement?$AA@ ; `string'
PUBLIC	??_C@_0CA@KPMHIEOJ@ns2?3getSessionIDResponseElement?$AA@ ; `string'
PUBLIC	??_C@_0BI@CHGDHCPP@ns2?3getSessionIDElement?$AA@ ; `string'
PUBLIC	??_C@_09JDHJJDCF@xsd?3QName?$AA@		; `string'
PUBLIC	??_C@_09JEONCPHE@SOAP?9ENV?3?$AA@		; `string'
PUBLIC	??_C@_02EGCJHIOB@id?$AA@			; `string'
PUBLIC	??_C@_08FGCKPNBL@?3boolean?$AA@			; `string'
PUBLIC	??_C@_0L@FEKNHBLL@ns2?3result?$AA@		; `string'
PUBLIC	??_C@_0N@EOBKMJFL@ns2?3String_1?$AA@		; `string'
PUBLIC	??_C@_09LGLKGPMP@ns2?3int_2?$AA@		; `string'
PUBLIC	??_C@_0BB@FGDEMAEK@ns2?3arrayOfint_3?$AA@	; `string'
PUBLIC	??_C@_0BB@BJHFFGIN@ns2?3arrayOfint_4?$AA@	; `string'
PUBLIC	??_C@_0BD@GLFPAPIO@ns2?3arrayOffloat_5?$AA@	; `string'
PUBLIC	??_C@_0BD@EAHCFMEN@ns2?3arrayOffloat_6?$AA@	; `string'
PUBLIC	??_C@_0M@OBEIDIJA@ns2?3float_7?$AA@		; `string'
PUBLIC	??_C@_0M@GGNACEFP@ns2?3float_8?$AA@		; `string'
PUBLIC	??_C@_09JNJHDMAM@ns2?3int_1?$AA@		; `string'
PUBLIC	??_C@_09FJACJGDN@faultcode?$AA@			; `string'
PUBLIC	??_C@_0M@LAMIIPIL@faultstring?$AA@		; `string'
PUBLIC	??_C@_0L@JAIOMLLA@faultactor?$AA@		; `string'
PUBLIC	??_C@_06EENFNEPD@detail?$AA@			; `string'
PUBLIC	??_C@_0O@OALMNFDI@SOAP?9ENV?3Code?$AA@		; `string'
PUBLIC	??_C@_0BA@IEHDIDAH@SOAP?9ENV?3Reason?$AA@	; `string'
PUBLIC	??_C@_0O@BICMBBIJ@SOAP?9ENV?3Node?$AA@		; `string'
PUBLIC	??_C@_0O@LDCPDKLC@SOAP?9ENV?3Role?$AA@		; `string'
PUBLIC	??_C@_0BA@OENGLDCF@SOAP?9ENV?3Detail?$AA@	; `string'
PUBLIC	??_C@_0O@BLCEAHMK@SOAP?9ENV?3Text?$AA@		; `string'
PUBLIC	??_C@_05GCLNDCPO@fault?$AA@			; `string'
PUBLIC	??_C@_04DPKCFHKE@?9any?$AA@			; `string'
PUBLIC	??_C@_0P@FNBDNHP@SOAP?9ENV?3Value?$AA@		; `string'
PUBLIC	??_C@_0BB@MGPNIFGI@SOAP?9ENV?3Subcode?$AA@	; `string'
PUBLIC	??_7xsd__anyType@@6B@				; xsd__anyType::`vftable'
PUBLIC	??_7xsd__boolean@@6B@				; xsd__boolean::`vftable'
PUBLIC	??_7xsd__float@@6B@				; xsd__float::`vftable'
PUBLIC	??_7xsd__int@@6B@				; xsd__int::`vftable'
PUBLIC	??_7xsd__long@@6B@				; xsd__long::`vftable'
PUBLIC	??_7xsd__string@@6B@				; xsd__string::`vftable'
PUBLIC	??_7_ns2__getSessionIDElement@@6B@		; _ns2__getSessionIDElement::`vftable'
PUBLIC	??_7_ns2__getSessionIDResponseElement@@6B@	; _ns2__getSessionIDResponseElement::`vftable'
PUBLIC	??_7_ns2__getSettingsFileElement@@6B@		; _ns2__getSettingsFileElement::`vftable'
PUBLIC	??_7_ns2__getSettingsFileResponseElement@@6B@	; _ns2__getSettingsFileResponseElement::`vftable'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
;	COMDAT ??_7_ns2__getSettingsFileResponseElement@@6B@
CONST	SEGMENT
??_7_ns2__getSettingsFileResponseElement@@6B@ DD FLAT:??_R4_ns2__getSettingsFileResponseElement@@6B@ ; _ns2__getSettingsFileResponseElement::`vftable'
	DD	FLAT:?soap_type@_ns2__getSettingsFileResponseElement@@UBEHXZ
	DD	FLAT:?soap_default@_ns2__getSettingsFileResponseElement@@UAEXPAUsoap@@@Z
	DD	FLAT:?soap_serialize@_ns2__getSettingsFileResponseElement@@UBEXPAUsoap@@@Z
	DD	FLAT:?soap_put@_ns2__getSettingsFileResponseElement@@UBEHPAUsoap@@PBD1@Z
	DD	FLAT:?soap_out@_ns2__getSettingsFileResponseElement@@UBEHPAUsoap@@PBDH1@Z
	DD	FLAT:?soap_get@_ns2__getSettingsFileResponseElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:?soap_in@_ns2__getSettingsFileResponseElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:??_E_ns2__getSettingsFileResponseElement@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4_ns2__getSettingsFileResponseElement@@6B@
rdata$r	SEGMENT
??_R4_ns2__getSettingsFileResponseElement@@6B@ DD 00H	; _ns2__getSettingsFileResponseElement::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_ns2__getSettingsFileResponseElement@@@8
	DD	FLAT:??_R3_ns2__getSettingsFileResponseElement@@8
rdata$r	ENDS
;	COMDAT ??_R3_ns2__getSettingsFileResponseElement@@8
rdata$r	SEGMENT
??_R3_ns2__getSettingsFileResponseElement@@8 DD 00H	; _ns2__getSettingsFileResponseElement::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_ns2__getSettingsFileResponseElement@@8
rdata$r	ENDS
;	COMDAT ??_R2_ns2__getSettingsFileResponseElement@@8
rdata$r	SEGMENT
??_R2_ns2__getSettingsFileResponseElement@@8 DD FLAT:??_R1A@?0A@EA@_ns2__getSettingsFileResponseElement@@8 ; _ns2__getSettingsFileResponseElement::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_ns2__getSettingsFileResponseElement@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_ns2__getSettingsFileResponseElement@@8 DD FLAT:??_R0?AV_ns2__getSettingsFileResponseElement@@@8 ; _ns2__getSettingsFileResponseElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_ns2__getSettingsFileResponseElement@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_ns2__getSettingsFileResponseElement@@@8
_DATA	SEGMENT
??_R0?AV_ns2__getSettingsFileResponseElement@@@8 DD FLAT:??_7type_info@@6B@ ; _ns2__getSettingsFileResponseElement `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_ns2__getSettingsFileResponseElement@@', 00H
_DATA	ENDS
;	COMDAT ??_7_ns2__getSettingsFileElement@@6B@
CONST	SEGMENT
??_7_ns2__getSettingsFileElement@@6B@ DD FLAT:??_R4_ns2__getSettingsFileElement@@6B@ ; _ns2__getSettingsFileElement::`vftable'
	DD	FLAT:?soap_type@_ns2__getSettingsFileElement@@UBEHXZ
	DD	FLAT:?soap_default@_ns2__getSettingsFileElement@@UAEXPAUsoap@@@Z
	DD	FLAT:?soap_serialize@_ns2__getSettingsFileElement@@UBEXPAUsoap@@@Z
	DD	FLAT:?soap_put@_ns2__getSettingsFileElement@@UBEHPAUsoap@@PBD1@Z
	DD	FLAT:?soap_out@_ns2__getSettingsFileElement@@UBEHPAUsoap@@PBDH1@Z
	DD	FLAT:?soap_get@_ns2__getSettingsFileElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:?soap_in@_ns2__getSettingsFileElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:??_E_ns2__getSettingsFileElement@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4_ns2__getSettingsFileElement@@6B@
rdata$r	SEGMENT
??_R4_ns2__getSettingsFileElement@@6B@ DD 00H		; _ns2__getSettingsFileElement::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_ns2__getSettingsFileElement@@@8
	DD	FLAT:??_R3_ns2__getSettingsFileElement@@8
rdata$r	ENDS
;	COMDAT ??_R3_ns2__getSettingsFileElement@@8
rdata$r	SEGMENT
??_R3_ns2__getSettingsFileElement@@8 DD 00H		; _ns2__getSettingsFileElement::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_ns2__getSettingsFileElement@@8
rdata$r	ENDS
;	COMDAT ??_R2_ns2__getSettingsFileElement@@8
rdata$r	SEGMENT
??_R2_ns2__getSettingsFileElement@@8 DD FLAT:??_R1A@?0A@EA@_ns2__getSettingsFileElement@@8 ; _ns2__getSettingsFileElement::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_ns2__getSettingsFileElement@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_ns2__getSettingsFileElement@@8 DD FLAT:??_R0?AV_ns2__getSettingsFileElement@@@8 ; _ns2__getSettingsFileElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_ns2__getSettingsFileElement@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_ns2__getSettingsFileElement@@@8
_DATA	SEGMENT
??_R0?AV_ns2__getSettingsFileElement@@@8 DD FLAT:??_7type_info@@6B@ ; _ns2__getSettingsFileElement `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_ns2__getSettingsFileElement@@', 00H
_DATA	ENDS
;	COMDAT ??_7_ns2__getSessionIDResponseElement@@6B@
CONST	SEGMENT
??_7_ns2__getSessionIDResponseElement@@6B@ DD FLAT:??_R4_ns2__getSessionIDResponseElement@@6B@ ; _ns2__getSessionIDResponseElement::`vftable'
	DD	FLAT:?soap_type@_ns2__getSessionIDResponseElement@@UBEHXZ
	DD	FLAT:?soap_default@_ns2__getSessionIDResponseElement@@UAEXPAUsoap@@@Z
	DD	FLAT:?soap_serialize@_ns2__getSessionIDResponseElement@@UBEXPAUsoap@@@Z
	DD	FLAT:?soap_put@_ns2__getSessionIDResponseElement@@UBEHPAUsoap@@PBD1@Z
	DD	FLAT:?soap_out@_ns2__getSessionIDResponseElement@@UBEHPAUsoap@@PBDH1@Z
	DD	FLAT:?soap_get@_ns2__getSessionIDResponseElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:?soap_in@_ns2__getSessionIDResponseElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:??_E_ns2__getSessionIDResponseElement@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4_ns2__getSessionIDResponseElement@@6B@
rdata$r	SEGMENT
??_R4_ns2__getSessionIDResponseElement@@6B@ DD 00H	; _ns2__getSessionIDResponseElement::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_ns2__getSessionIDResponseElement@@@8
	DD	FLAT:??_R3_ns2__getSessionIDResponseElement@@8
rdata$r	ENDS
;	COMDAT ??_R3_ns2__getSessionIDResponseElement@@8
rdata$r	SEGMENT
??_R3_ns2__getSessionIDResponseElement@@8 DD 00H	; _ns2__getSessionIDResponseElement::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_ns2__getSessionIDResponseElement@@8
rdata$r	ENDS
;	COMDAT ??_R2_ns2__getSessionIDResponseElement@@8
rdata$r	SEGMENT
??_R2_ns2__getSessionIDResponseElement@@8 DD FLAT:??_R1A@?0A@EA@_ns2__getSessionIDResponseElement@@8 ; _ns2__getSessionIDResponseElement::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_ns2__getSessionIDResponseElement@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_ns2__getSessionIDResponseElement@@8 DD FLAT:??_R0?AV_ns2__getSessionIDResponseElement@@@8 ; _ns2__getSessionIDResponseElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_ns2__getSessionIDResponseElement@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_ns2__getSessionIDResponseElement@@@8
_DATA	SEGMENT
??_R0?AV_ns2__getSessionIDResponseElement@@@8 DD FLAT:??_7type_info@@6B@ ; _ns2__getSessionIDResponseElement `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_ns2__getSessionIDResponseElement@@', 00H
_DATA	ENDS
;	COMDAT ??_7_ns2__getSessionIDElement@@6B@
CONST	SEGMENT
??_7_ns2__getSessionIDElement@@6B@ DD FLAT:??_R4_ns2__getSessionIDElement@@6B@ ; _ns2__getSessionIDElement::`vftable'
	DD	FLAT:?soap_type@_ns2__getSessionIDElement@@UBEHXZ
	DD	FLAT:?soap_default@_ns2__getSessionIDElement@@UAEXPAUsoap@@@Z
	DD	FLAT:?soap_serialize@_ns2__getSessionIDElement@@UBEXPAUsoap@@@Z
	DD	FLAT:?soap_put@_ns2__getSessionIDElement@@UBEHPAUsoap@@PBD1@Z
	DD	FLAT:?soap_out@_ns2__getSessionIDElement@@UBEHPAUsoap@@PBDH1@Z
	DD	FLAT:?soap_get@_ns2__getSessionIDElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:?soap_in@_ns2__getSessionIDElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:??_E_ns2__getSessionIDElement@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4_ns2__getSessionIDElement@@6B@
rdata$r	SEGMENT
??_R4_ns2__getSessionIDElement@@6B@ DD 00H		; _ns2__getSessionIDElement::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_ns2__getSessionIDElement@@@8
	DD	FLAT:??_R3_ns2__getSessionIDElement@@8
rdata$r	ENDS
;	COMDAT ??_R3_ns2__getSessionIDElement@@8
rdata$r	SEGMENT
??_R3_ns2__getSessionIDElement@@8 DD 00H		; _ns2__getSessionIDElement::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_ns2__getSessionIDElement@@8
rdata$r	ENDS
;	COMDAT ??_R2_ns2__getSessionIDElement@@8
rdata$r	SEGMENT
??_R2_ns2__getSessionIDElement@@8 DD FLAT:??_R1A@?0A@EA@_ns2__getSessionIDElement@@8 ; _ns2__getSessionIDElement::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_ns2__getSessionIDElement@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_ns2__getSessionIDElement@@8 DD FLAT:??_R0?AV_ns2__getSessionIDElement@@@8 ; _ns2__getSessionIDElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_ns2__getSessionIDElement@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_ns2__getSessionIDElement@@@8
_DATA	SEGMENT
??_R0?AV_ns2__getSessionIDElement@@@8 DD FLAT:??_7type_info@@6B@ ; _ns2__getSessionIDElement `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_ns2__getSessionIDElement@@', 00H
_DATA	ENDS
;	COMDAT ??_7xsd__string@@6B@
CONST	SEGMENT
??_7xsd__string@@6B@ DD FLAT:??_R4xsd__string@@6B@	; xsd__string::`vftable'
	DD	FLAT:?soap_type@xsd__string@@UBEHXZ
	DD	FLAT:?soap_default@xsd__string@@UAEXPAUsoap@@@Z
	DD	FLAT:?soap_serialize@xsd__string@@UBEXPAUsoap@@@Z
	DD	FLAT:?soap_put@xsd__string@@UBEHPAUsoap@@PBD1@Z
	DD	FLAT:?soap_out@xsd__string@@UBEHPAUsoap@@PBDH1@Z
	DD	FLAT:?soap_get@xsd__string@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:?soap_in@xsd__string@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:??_Exsd__string@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4xsd__string@@6B@
rdata$r	SEGMENT
??_R4xsd__string@@6B@ DD 00H				; xsd__string::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVxsd__string@@@8
	DD	FLAT:??_R3xsd__string@@8
rdata$r	ENDS
;	COMDAT ??_R3xsd__string@@8
rdata$r	SEGMENT
??_R3xsd__string@@8 DD 00H				; xsd__string::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2xsd__string@@8
rdata$r	ENDS
;	COMDAT ??_R2xsd__string@@8
rdata$r	SEGMENT
??_R2xsd__string@@8 DD FLAT:??_R1A@?0A@EA@xsd__string@@8 ; xsd__string::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@xsd__anyType@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@xsd__string@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@xsd__string@@8 DD FLAT:??_R0?AVxsd__string@@@8 ; xsd__string::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3xsd__string@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVxsd__string@@@8
_DATA	SEGMENT
??_R0?AVxsd__string@@@8 DD FLAT:??_7type_info@@6B@	; xsd__string `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVxsd__string@@', 00H
_DATA	ENDS
;	COMDAT ??_7xsd__long@@6B@
CONST	SEGMENT
??_7xsd__long@@6B@ DD FLAT:??_R4xsd__long@@6B@		; xsd__long::`vftable'
	DD	FLAT:?soap_type@xsd__long@@UBEHXZ
	DD	FLAT:?soap_default@xsd__long@@UAEXPAUsoap@@@Z
	DD	FLAT:?soap_serialize@xsd__long@@UBEXPAUsoap@@@Z
	DD	FLAT:?soap_put@xsd__long@@UBEHPAUsoap@@PBD1@Z
	DD	FLAT:?soap_out@xsd__long@@UBEHPAUsoap@@PBDH1@Z
	DD	FLAT:?soap_get@xsd__long@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:?soap_in@xsd__long@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:??_Exsd__long@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4xsd__long@@6B@
rdata$r	SEGMENT
??_R4xsd__long@@6B@ DD 00H				; xsd__long::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVxsd__long@@@8
	DD	FLAT:??_R3xsd__long@@8
rdata$r	ENDS
;	COMDAT ??_R3xsd__long@@8
rdata$r	SEGMENT
??_R3xsd__long@@8 DD 00H				; xsd__long::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2xsd__long@@8
rdata$r	ENDS
;	COMDAT ??_R2xsd__long@@8
rdata$r	SEGMENT
??_R2xsd__long@@8 DD FLAT:??_R1A@?0A@EA@xsd__long@@8	; xsd__long::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@xsd__anyType@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@xsd__long@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@xsd__long@@8 DD FLAT:??_R0?AVxsd__long@@@8 ; xsd__long::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3xsd__long@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVxsd__long@@@8
_DATA	SEGMENT
??_R0?AVxsd__long@@@8 DD FLAT:??_7type_info@@6B@	; xsd__long `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVxsd__long@@', 00H
_DATA	ENDS
;	COMDAT ??_7xsd__int@@6B@
CONST	SEGMENT
??_7xsd__int@@6B@ DD FLAT:??_R4xsd__int@@6B@		; xsd__int::`vftable'
	DD	FLAT:?soap_type@xsd__int@@UBEHXZ
	DD	FLAT:?soap_default@xsd__int@@UAEXPAUsoap@@@Z
	DD	FLAT:?soap_serialize@xsd__int@@UBEXPAUsoap@@@Z
	DD	FLAT:?soap_put@xsd__int@@UBEHPAUsoap@@PBD1@Z
	DD	FLAT:?soap_out@xsd__int@@UBEHPAUsoap@@PBDH1@Z
	DD	FLAT:?soap_get@xsd__int@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:?soap_in@xsd__int@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:??_Exsd__int@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4xsd__int@@6B@
rdata$r	SEGMENT
??_R4xsd__int@@6B@ DD 00H				; xsd__int::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVxsd__int@@@8
	DD	FLAT:??_R3xsd__int@@8
rdata$r	ENDS
;	COMDAT ??_R3xsd__int@@8
rdata$r	SEGMENT
??_R3xsd__int@@8 DD 00H					; xsd__int::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2xsd__int@@8
rdata$r	ENDS
;	COMDAT ??_R2xsd__int@@8
rdata$r	SEGMENT
??_R2xsd__int@@8 DD FLAT:??_R1A@?0A@EA@xsd__int@@8	; xsd__int::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@xsd__anyType@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@xsd__int@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@xsd__int@@8 DD FLAT:??_R0?AVxsd__int@@@8	; xsd__int::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3xsd__int@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVxsd__int@@@8
_DATA	SEGMENT
??_R0?AVxsd__int@@@8 DD FLAT:??_7type_info@@6B@		; xsd__int `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVxsd__int@@', 00H
_DATA	ENDS
;	COMDAT ??_7xsd__float@@6B@
CONST	SEGMENT
??_7xsd__float@@6B@ DD FLAT:??_R4xsd__float@@6B@	; xsd__float::`vftable'
	DD	FLAT:?soap_type@xsd__float@@UBEHXZ
	DD	FLAT:?soap_default@xsd__float@@UAEXPAUsoap@@@Z
	DD	FLAT:?soap_serialize@xsd__float@@UBEXPAUsoap@@@Z
	DD	FLAT:?soap_put@xsd__float@@UBEHPAUsoap@@PBD1@Z
	DD	FLAT:?soap_out@xsd__float@@UBEHPAUsoap@@PBDH1@Z
	DD	FLAT:?soap_get@xsd__float@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:?soap_in@xsd__float@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:??_Exsd__float@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4xsd__float@@6B@
rdata$r	SEGMENT
??_R4xsd__float@@6B@ DD 00H				; xsd__float::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVxsd__float@@@8
	DD	FLAT:??_R3xsd__float@@8
rdata$r	ENDS
;	COMDAT ??_R3xsd__float@@8
rdata$r	SEGMENT
??_R3xsd__float@@8 DD 00H				; xsd__float::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2xsd__float@@8
rdata$r	ENDS
;	COMDAT ??_R2xsd__float@@8
rdata$r	SEGMENT
??_R2xsd__float@@8 DD FLAT:??_R1A@?0A@EA@xsd__float@@8	; xsd__float::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@xsd__anyType@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@xsd__float@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@xsd__float@@8 DD FLAT:??_R0?AVxsd__float@@@8 ; xsd__float::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3xsd__float@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVxsd__float@@@8
_DATA	SEGMENT
??_R0?AVxsd__float@@@8 DD FLAT:??_7type_info@@6B@	; xsd__float `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVxsd__float@@', 00H
_DATA	ENDS
;	COMDAT ??_7xsd__boolean@@6B@
CONST	SEGMENT
??_7xsd__boolean@@6B@ DD FLAT:??_R4xsd__boolean@@6B@	; xsd__boolean::`vftable'
	DD	FLAT:?soap_type@xsd__boolean@@UBEHXZ
	DD	FLAT:?soap_default@xsd__boolean@@UAEXPAUsoap@@@Z
	DD	FLAT:?soap_serialize@xsd__boolean@@UBEXPAUsoap@@@Z
	DD	FLAT:?soap_put@xsd__boolean@@UBEHPAUsoap@@PBD1@Z
	DD	FLAT:?soap_out@xsd__boolean@@UBEHPAUsoap@@PBDH1@Z
	DD	FLAT:?soap_get@xsd__boolean@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:?soap_in@xsd__boolean@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:??_Exsd__boolean@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4xsd__boolean@@6B@
rdata$r	SEGMENT
??_R4xsd__boolean@@6B@ DD 00H				; xsd__boolean::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVxsd__boolean@@@8
	DD	FLAT:??_R3xsd__boolean@@8
rdata$r	ENDS
;	COMDAT ??_R3xsd__boolean@@8
rdata$r	SEGMENT
??_R3xsd__boolean@@8 DD 00H				; xsd__boolean::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2xsd__boolean@@8
rdata$r	ENDS
;	COMDAT ??_R2xsd__boolean@@8
rdata$r	SEGMENT
??_R2xsd__boolean@@8 DD FLAT:??_R1A@?0A@EA@xsd__boolean@@8 ; xsd__boolean::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@xsd__anyType@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@xsd__boolean@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@xsd__boolean@@8 DD FLAT:??_R0?AVxsd__boolean@@@8 ; xsd__boolean::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3xsd__boolean@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVxsd__boolean@@@8
_DATA	SEGMENT
??_R0?AVxsd__boolean@@@8 DD FLAT:??_7type_info@@6B@	; xsd__boolean `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVxsd__boolean@@', 00H
_DATA	ENDS
;	COMDAT ??_7xsd__anyType@@6B@
CONST	SEGMENT
??_7xsd__anyType@@6B@ DD FLAT:??_R4xsd__anyType@@6B@	; xsd__anyType::`vftable'
	DD	FLAT:?soap_type@xsd__anyType@@UBEHXZ
	DD	FLAT:?soap_default@xsd__anyType@@UAEXPAUsoap@@@Z
	DD	FLAT:?soap_serialize@xsd__anyType@@UBEXPAUsoap@@@Z
	DD	FLAT:?soap_put@xsd__anyType@@UBEHPAUsoap@@PBD1@Z
	DD	FLAT:?soap_out@xsd__anyType@@UBEHPAUsoap@@PBDH1@Z
	DD	FLAT:?soap_get@xsd__anyType@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:?soap_in@xsd__anyType@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:??_Exsd__anyType@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4xsd__anyType@@6B@
rdata$r	SEGMENT
??_R4xsd__anyType@@6B@ DD 00H				; xsd__anyType::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVxsd__anyType@@@8
	DD	FLAT:??_R3xsd__anyType@@8
rdata$r	ENDS
;	COMDAT ??_R3xsd__anyType@@8
rdata$r	SEGMENT
??_R3xsd__anyType@@8 DD 00H				; xsd__anyType::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2xsd__anyType@@8
rdata$r	ENDS
;	COMDAT ??_R2xsd__anyType@@8
rdata$r	SEGMENT
??_R2xsd__anyType@@8 DD FLAT:??_R1A@?0A@EA@xsd__anyType@@8 ; xsd__anyType::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@xsd__anyType@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@xsd__anyType@@8 DD FLAT:??_R0?AVxsd__anyType@@@8 ; xsd__anyType::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3xsd__anyType@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVxsd__anyType@@@8
_DATA	SEGMENT
??_R0?AVxsd__anyType@@@8 DD FLAT:??_7type_info@@6B@	; xsd__anyType `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVxsd__anyType@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BB@MGPNIFGI@SOAP?9ENV?3Subcode?$AA@
CONST	SEGMENT
??_C@_0BB@MGPNIFGI@SOAP?9ENV?3Subcode?$AA@ DB 'SOAP-ENV:Subcode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FNBDNHP@SOAP?9ENV?3Value?$AA@
CONST	SEGMENT
??_C@_0P@FNBDNHP@SOAP?9ENV?3Value?$AA@ DB 'SOAP-ENV:Value', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DPKCFHKE@?9any?$AA@
CONST	SEGMENT
??_C@_04DPKCFHKE@?9any?$AA@ DB '-any', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GCLNDCPO@fault?$AA@
CONST	SEGMENT
??_C@_05GCLNDCPO@fault?$AA@ DB 'fault', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BLCEAHMK@SOAP?9ENV?3Text?$AA@
CONST	SEGMENT
??_C@_0O@BLCEAHMK@SOAP?9ENV?3Text?$AA@ DB 'SOAP-ENV:Text', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OENGLDCF@SOAP?9ENV?3Detail?$AA@
CONST	SEGMENT
??_C@_0BA@OENGLDCF@SOAP?9ENV?3Detail?$AA@ DB 'SOAP-ENV:Detail', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LDCPDKLC@SOAP?9ENV?3Role?$AA@
CONST	SEGMENT
??_C@_0O@LDCPDKLC@SOAP?9ENV?3Role?$AA@ DB 'SOAP-ENV:Role', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BICMBBIJ@SOAP?9ENV?3Node?$AA@
CONST	SEGMENT
??_C@_0O@BICMBBIJ@SOAP?9ENV?3Node?$AA@ DB 'SOAP-ENV:Node', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IEHDIDAH@SOAP?9ENV?3Reason?$AA@
CONST	SEGMENT
??_C@_0BA@IEHDIDAH@SOAP?9ENV?3Reason?$AA@ DB 'SOAP-ENV:Reason', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OALMNFDI@SOAP?9ENV?3Code?$AA@
CONST	SEGMENT
??_C@_0O@OALMNFDI@SOAP?9ENV?3Code?$AA@ DB 'SOAP-ENV:Code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EENFNEPD@detail?$AA@
CONST	SEGMENT
??_C@_06EENFNEPD@detail?$AA@ DB 'detail', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JAIOMLLA@faultactor?$AA@
CONST	SEGMENT
??_C@_0L@JAIOMLLA@faultactor?$AA@ DB 'faultactor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LAMIIPIL@faultstring?$AA@
CONST	SEGMENT
??_C@_0M@LAMIIPIL@faultstring?$AA@ DB 'faultstring', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FJACJGDN@faultcode?$AA@
CONST	SEGMENT
??_C@_09FJACJGDN@faultcode?$AA@ DB 'faultcode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JNJHDMAM@ns2?3int_1?$AA@
CONST	SEGMENT
??_C@_09JNJHDMAM@ns2?3int_1?$AA@ DB 'ns2:int_1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GGNACEFP@ns2?3float_8?$AA@
CONST	SEGMENT
??_C@_0M@GGNACEFP@ns2?3float_8?$AA@ DB 'ns2:float_8', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OBEIDIJA@ns2?3float_7?$AA@
CONST	SEGMENT
??_C@_0M@OBEIDIJA@ns2?3float_7?$AA@ DB 'ns2:float_7', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EAHCFMEN@ns2?3arrayOffloat_6?$AA@
CONST	SEGMENT
??_C@_0BD@EAHCFMEN@ns2?3arrayOffloat_6?$AA@ DB 'ns2:arrayOffloat_6', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GLFPAPIO@ns2?3arrayOffloat_5?$AA@
CONST	SEGMENT
??_C@_0BD@GLFPAPIO@ns2?3arrayOffloat_5?$AA@ DB 'ns2:arrayOffloat_5', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BJHFFGIN@ns2?3arrayOfint_4?$AA@
CONST	SEGMENT
??_C@_0BB@BJHFFGIN@ns2?3arrayOfint_4?$AA@ DB 'ns2:arrayOfint_4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FGDEMAEK@ns2?3arrayOfint_3?$AA@
CONST	SEGMENT
??_C@_0BB@FGDEMAEK@ns2?3arrayOfint_3?$AA@ DB 'ns2:arrayOfint_3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LGLKGPMP@ns2?3int_2?$AA@
CONST	SEGMENT
??_C@_09LGLKGPMP@ns2?3int_2?$AA@ DB 'ns2:int_2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EOBKMJFL@ns2?3String_1?$AA@
CONST	SEGMENT
??_C@_0N@EOBKMJFL@ns2?3String_1?$AA@ DB 'ns2:String_1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FEKNHBLL@ns2?3result?$AA@
CONST	SEGMENT
??_C@_0L@FEKNHBLL@ns2?3result?$AA@ DB 'ns2:result', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FGCKPNBL@?3boolean?$AA@
CONST	SEGMENT
??_C@_08FGCKPNBL@?3boolean?$AA@ DB ':boolean', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id?$AA@
CONST	SEGMENT
??_C@_02EGCJHIOB@id?$AA@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09JEONCPHE@SOAP?9ENV?3?$AA@
CONST	SEGMENT
??_C@_09JEONCPHE@SOAP?9ENV?3?$AA@ DB 'SOAP-ENV:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JDHJJDCF@xsd?3QName?$AA@
CONST	SEGMENT
??_C@_09JDHJJDCF@xsd?3QName?$AA@ DB 'xsd:QName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CHGDHCPP@ns2?3getSessionIDElement?$AA@
CONST	SEGMENT
??_C@_0BI@CHGDHCPP@ns2?3getSessionIDElement?$AA@ DB 'ns2:getSessionIDElem'
	DB	'ent', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KPMHIEOJ@ns2?3getSessionIDResponseElement?$AA@
CONST	SEGMENT
??_C@_0CA@KPMHIEOJ@ns2?3getSessionIDResponseElement?$AA@ DB 'ns2:getSessi'
	DB	'onIDResponseElement', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EBHOCBLE@ns2?3getSettingsFileElement?$AA@
CONST	SEGMENT
??_C@_0BL@EBHOCBLE@ns2?3getSettingsFileElement?$AA@ DB 'ns2:getSettingsFi'
	DB	'leElement', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GADHDKNA@ns2?3getSettingsFileResponseEleme@
CONST	SEGMENT
??_C@_0CD@GADHDKNA@ns2?3getSettingsFileResponseEleme@ DB 'ns2:getSettings'
	DB	'FileResponseElement', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LEHNEPKC@ns2?3submitEpochResultElement?$AA@
CONST	SEGMENT
??_C@_0BN@LEHNEPKC@ns2?3submitEpochResultElement?$AA@ DB 'ns2:submitEpoch'
	DB	'ResultElement', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HCKJIEH@ns2?3submitEpochResultResponseEle@
CONST	SEGMENT
??_C@_0CF@HCKJIEH@ns2?3submitEpochResultResponseEle@ DB 'ns2:submitEpochR'
	DB	'esultResponseElement', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NOIFKOBF@xsd?3anyType?$AA@
CONST	SEGMENT
??_C@_0M@NOIFKOBF@xsd?3anyType?$AA@ DB 'xsd:anyType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DIJPMJCO@xsd?3string?$AA@
CONST	SEGMENT
??_C@_0L@DIJPMJCO@xsd?3string?$AA@ DB 'xsd:string', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FGHMEICI@xsd?3boolean?$AA@
CONST	SEGMENT
??_C@_0M@FGHMEICI@xsd?3boolean?$AA@ DB 'xsd:boolean', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ILBLHFBD@xsd?3float?$AA@
CONST	SEGMENT
??_C@_09ILBLHFBD@xsd?3float?$AA@ DB 'xsd:float', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PNDIDGIB@xsd?3long?$AA@
CONST	SEGMENT
??_C@_08PNDIDGIB@xsd?3long?$AA@ DB 'xsd:long', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PCIGPDP@xsd?3int?$AA@
CONST	SEGMENT
??_C@_07PCIGPDP@xsd?3int?$AA@ DB 'xsd:int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BEPNMEIH@xsd?3byte?$AA@
CONST	SEGMENT
??_C@_08BEPNMEIH@xsd?3byte?$AA@ DB 'xsd:byte', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GLDIJMBO@SOAP?9ENV?3Fault?$AA@
CONST	SEGMENT
??_C@_0P@GLDIJMBO@SOAP?9ENV?3Fault?$AA@ DB 'SOAP-ENV:Fault', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GBPDPHCK@SOAP?9ENV?3Header?$AA@
CONST	SEGMENT
??_C@_0BA@GBPDPHCK@SOAP?9ENV?3Header?$AA@ DB 'SOAP-ENV:Header', 00H ; `string'
_soap_codes_bool DD 00H
	DD	FLAT:??_C@_05LAPONLG@false?$AA@
	DD	01H
	DD	FLAT:??_C@_04LOAJBDKD@true?$AA@
	DD	00H
	DD	00H
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
PUBLIC	?soap_fdelete@@YAHPAUsoap_clist@@@Z		; soap_fdelete
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<float *,float *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;
; 2711 : 	if (_Off > 0)
; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H

; 2713 : 	return _Result;

	mov	eax, esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<float *,float *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAM@std@@YA?AU_Undefined_move_tag@0@ABQAM@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAM@std@@YA?AU_Undefined_move_tag@0@ABQAM@Z PROC ; std::_Move_cat<float *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAM@std@@YA?AU_Undefined_move_tag@0@ABQAM@Z ENDP ; std::_Move_cat<float *>
_TEXT	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAMM@std@@YAXPAM0ABM@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Fill@PAMM@std@@YAXPAM0ABM@Z PROC			; std::_Fill<float *,float>, COMDAT
; __First$ = eax
; __Last$ = ecx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	cmp	eax, ecx
	je	SHORT $LN1@Fill
	mov	edx, DWORD PTR __Val$[esp-4]
	movss	xmm0, DWORD PTR [edx]
	npad	4
$LL3@Fill:

; 3159 : 		*_First = _Val;

	movss	DWORD PTR [eax], xmm0
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAMM@std@@YAXPAM0ABM@Z ENDP			; std::_Fill<float *,float>
_TEXT	ENDS
PUBLIC	?soap_delete_std__vectorTemplateOfint@@YAXPAUsoap@@PAV?$vector@HV?$allocator@H@std@@@std@@@Z ; soap_delete_std__vectorTemplateOfint
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapc.cpp
_TEXT	SEGMENT
?soap_delete_std__vectorTemplateOfint@@YAXPAUsoap@@PAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; soap_delete_std__vectorTemplateOfint
; _soap$ = eax
; _p$ = ecx

; 4471 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 4472 : }

	ret	0
?soap_delete_std__vectorTemplateOfint@@YAXPAUsoap@@PAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; soap_delete_std__vectorTemplateOfint
_TEXT	ENDS
PUBLIC	?soap_serialize_std__vectorTemplateOfint@@YAXPAUsoap@@PBV?$vector@HV?$allocator@H@std@@@std@@@Z ; soap_serialize_std__vectorTemplateOfint
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_std__vectorTemplateOfint@@YAXPAUsoap@@PBV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; soap_serialize_std__vectorTemplateOfint

; 4421 : }

	ret	0
?soap_serialize_std__vectorTemplateOfint@@YAXPAUsoap@@PBV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; soap_serialize_std__vectorTemplateOfint
_TEXT	ENDS
PUBLIC	?soap_delete_std__vectorTemplateOffloat@@YAXPAUsoap@@PAV?$vector@MV?$allocator@M@std@@@std@@@Z ; soap_delete_std__vectorTemplateOffloat
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete_std__vectorTemplateOffloat@@YAXPAUsoap@@PAV?$vector@MV?$allocator@M@std@@@std@@@Z PROC ; soap_delete_std__vectorTemplateOffloat
; _soap$ = eax
; _p$ = ecx

; 4382 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 4383 : }

	ret	0
?soap_delete_std__vectorTemplateOffloat@@YAXPAUsoap@@PAV?$vector@MV?$allocator@M@std@@@std@@@Z ENDP ; soap_delete_std__vectorTemplateOffloat
_TEXT	ENDS
PUBLIC	?soap_serialize_std__vectorTemplateOffloat@@YAXPAUsoap@@PBV?$vector@MV?$allocator@M@std@@@std@@@Z ; soap_serialize_std__vectorTemplateOffloat
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_std__vectorTemplateOffloat@@YAXPAUsoap@@PBV?$vector@MV?$allocator@M@std@@@std@@@Z PROC ; soap_serialize_std__vectorTemplateOffloat

; 4332 : }

	ret	0
?soap_serialize_std__vectorTemplateOffloat@@YAXPAUsoap@@PBV?$vector@MV?$allocator@M@std@@@std@@@Z ENDP ; soap_serialize_std__vectorTemplateOffloat
_TEXT	ENDS
PUBLIC	?soap_default_string@@YAXPAUsoap@@PAPAD@Z	; soap_default_string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default_string@@YAXPAUsoap@@PAPAD@Z PROC		; soap_default_string
; _a$ = eax

; 4287 : #ifdef SOAP_DEFAULT_string
; 4288 : 	*a = SOAP_DEFAULT_string;
; 4289 : #else
; 4290 : 	*a = (char *)0;

	mov	DWORD PTR [eax], 0

; 4291 : #endif
; 4292 : }

	ret	0
?soap_default_string@@YAXPAUsoap@@PAPAD@Z ENDP		; soap_default_string
_TEXT	ENDS
PUBLIC	?soap_default__QName@@YAXPAUsoap@@PAPAD@Z	; soap_default__QName
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default__QName@@YAXPAUsoap@@PAPAD@Z PROC		; soap_default__QName
; _a$ = eax

; 4252 : {	soap_default_string(soap, a);

	mov	DWORD PTR [eax], 0

; 4253 : }

	ret	0
?soap_default__QName@@YAXPAUsoap@@PAPAD@Z ENDP		; soap_default__QName
_TEXT	ENDS
PUBLIC	?soap_copy___ns1__getSessionID@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy___ns1__getSessionID
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_copy___ns1__getSessionID@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy___ns1__getSessionID
; _p$ = edx
; _q$ = eax

; 3701 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSessionID %p -> %p\n", q, p));
; 3702 : 	*(struct __ns1__getSessionID*)p = *(struct __ns1__getSessionID*)q;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 3703 : }

	ret	0
?soap_copy___ns1__getSessionID@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy___ns1__getSessionID
_TEXT	ENDS
PUBLIC	?soap_delete___ns1__getSessionID@@YAXPAUsoap@@PAU__ns1__getSessionID@@@Z ; soap_delete___ns1__getSessionID
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete___ns1__getSessionID@@YAXPAUsoap@@PAU__ns1__getSessionID@@@Z PROC ; soap_delete___ns1__getSessionID
; _soap$ = eax
; _p$ = ecx

; 3673 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 3674 : }

	ret	0
?soap_delete___ns1__getSessionID@@YAXPAUsoap@@PAU__ns1__getSessionID@@@Z ENDP ; soap_delete___ns1__getSessionID
_TEXT	ENDS
PUBLIC	?soap_default___ns1__getSessionID@@YAXPAUsoap@@PAU__ns1__getSessionID@@@Z ; soap_default___ns1__getSessionID
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default___ns1__getSessionID@@YAXPAUsoap@@PAU__ns1__getSessionID@@@Z PROC ; soap_default___ns1__getSessionID
; _a$ = eax

; 3607 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 3608 : 	a->ns2__getSessionIDElement = NULL;

	mov	DWORD PTR [eax], 0

; 3609 : }

	ret	0
?soap_default___ns1__getSessionID@@YAXPAUsoap@@PAU__ns1__getSessionID@@@Z ENDP ; soap_default___ns1__getSessionID
_TEXT	ENDS
PUBLIC	?soap_copy___ns1__getSettingsFile@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy___ns1__getSettingsFile
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_copy___ns1__getSettingsFile@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy___ns1__getSettingsFile
; _p$ = edx
; _q$ = eax

; 3601 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSettingsFile %p -> %p\n", q, p));
; 3602 : 	*(struct __ns1__getSettingsFile*)p = *(struct __ns1__getSettingsFile*)q;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 3603 : }

	ret	0
?soap_copy___ns1__getSettingsFile@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy___ns1__getSettingsFile
_TEXT	ENDS
PUBLIC	?soap_delete___ns1__getSettingsFile@@YAXPAUsoap@@PAU__ns1__getSettingsFile@@@Z ; soap_delete___ns1__getSettingsFile
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete___ns1__getSettingsFile@@YAXPAUsoap@@PAU__ns1__getSettingsFile@@@Z PROC ; soap_delete___ns1__getSettingsFile
; _soap$ = eax
; _p$ = ecx

; 3573 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 3574 : }

	ret	0
?soap_delete___ns1__getSettingsFile@@YAXPAUsoap@@PAU__ns1__getSettingsFile@@@Z ENDP ; soap_delete___ns1__getSettingsFile
_TEXT	ENDS
PUBLIC	?soap_default___ns1__getSettingsFile@@YAXPAUsoap@@PAU__ns1__getSettingsFile@@@Z ; soap_default___ns1__getSettingsFile
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default___ns1__getSettingsFile@@YAXPAUsoap@@PAU__ns1__getSettingsFile@@@Z PROC ; soap_default___ns1__getSettingsFile
; _a$ = eax

; 3507 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 3508 : 	a->ns2__getSettingsFileElement = NULL;

	mov	DWORD PTR [eax], 0

; 3509 : }

	ret	0
?soap_default___ns1__getSettingsFile@@YAXPAUsoap@@PAU__ns1__getSettingsFile@@@Z ENDP ; soap_default___ns1__getSettingsFile
_TEXT	ENDS
PUBLIC	?soap_copy___ns1__submitEpochResult@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy___ns1__submitEpochResult
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_copy___ns1__submitEpochResult@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy___ns1__submitEpochResult
; _p$ = edx
; _q$ = eax

; 3501 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__submitEpochResult %p -> %p\n", q, p));
; 3502 : 	*(struct __ns1__submitEpochResult*)p = *(struct __ns1__submitEpochResult*)q;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 3503 : }

	ret	0
?soap_copy___ns1__submitEpochResult@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy___ns1__submitEpochResult
_TEXT	ENDS
PUBLIC	?soap_delete___ns1__submitEpochResult@@YAXPAUsoap@@PAU__ns1__submitEpochResult@@@Z ; soap_delete___ns1__submitEpochResult
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete___ns1__submitEpochResult@@YAXPAUsoap@@PAU__ns1__submitEpochResult@@@Z PROC ; soap_delete___ns1__submitEpochResult
; _soap$ = eax
; _p$ = ecx

; 3473 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 3474 : }

	ret	0
?soap_delete___ns1__submitEpochResult@@YAXPAUsoap@@PAU__ns1__submitEpochResult@@@Z ENDP ; soap_delete___ns1__submitEpochResult
_TEXT	ENDS
PUBLIC	?soap_default___ns1__submitEpochResult@@YAXPAUsoap@@PAU__ns1__submitEpochResult@@@Z ; soap_default___ns1__submitEpochResult
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default___ns1__submitEpochResult@@YAXPAUsoap@@PAU__ns1__submitEpochResult@@@Z PROC ; soap_default___ns1__submitEpochResult
; _a$ = eax

; 3407 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 3408 : 	a->ns2__submitEpochResultElement = NULL;

	mov	DWORD PTR [eax], 0

; 3409 : }

	ret	0
?soap_default___ns1__submitEpochResult@@YAXPAUsoap@@PAU__ns1__submitEpochResult@@@Z ENDP ; soap_default___ns1__submitEpochResult
_TEXT	ENDS
PUBLIC	?soap_copy_SOAP_ENV__Header@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy_SOAP_ENV__Header
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_copy_SOAP_ENV__Header@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy_SOAP_ENV__Header
; _p$ = edx
; _q$ = eax

; 3399 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
; 3400 : 	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;

	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 3401 : }

	ret	0
?soap_copy_SOAP_ENV__Header@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy_SOAP_ENV__Header
_TEXT	ENDS
PUBLIC	?soap_delete_SOAP_ENV__Header@@YAXPAUsoap@@PAUSOAP_ENV__Header@@@Z ; soap_delete_SOAP_ENV__Header
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete_SOAP_ENV__Header@@YAXPAUsoap@@PAUSOAP_ENV__Header@@@Z PROC ; soap_delete_SOAP_ENV__Header
; _soap$ = eax
; _p$ = ecx

; 3371 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 3372 : }

	ret	0
?soap_delete_SOAP_ENV__Header@@YAXPAUsoap@@PAUSOAP_ENV__Header@@@Z ENDP ; soap_delete_SOAP_ENV__Header
_TEXT	ENDS
PUBLIC	?soap_serialize_SOAP_ENV__Header@@YAXPAUsoap@@PBUSOAP_ENV__Header@@@Z ; soap_serialize_SOAP_ENV__Header
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_SOAP_ENV__Header@@YAXPAUsoap@@PBUSOAP_ENV__Header@@@Z PROC ; soap_serialize_SOAP_ENV__Header

; 3310 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 3311 : }

	ret	0
?soap_serialize_SOAP_ENV__Header@@YAXPAUsoap@@PBUSOAP_ENV__Header@@@Z ENDP ; soap_serialize_SOAP_ENV__Header
_TEXT	ENDS
PUBLIC	?soap_default_SOAP_ENV__Header@@YAXPAUsoap@@PAUSOAP_ENV__Header@@@Z ; soap_default_SOAP_ENV__Header
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default_SOAP_ENV__Header@@YAXPAUsoap@@PAUSOAP_ENV__Header@@@Z PROC ; soap_default_SOAP_ENV__Header

; 3305 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 3306 : }

	ret	0
?soap_default_SOAP_ENV__Header@@YAXPAUsoap@@PAUSOAP_ENV__Header@@@Z ENDP ; soap_default_SOAP_ENV__Header
_TEXT	ENDS
PUBLIC	?soap_copy_SOAP_ENV__Code@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy_SOAP_ENV__Code
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_copy_SOAP_ENV__Code@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy_SOAP_ENV__Code
; _p$ = ecx
; _q$ = eax

; 3295 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
; 3296 : 	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax

; 3297 : }

	ret	0
?soap_copy_SOAP_ENV__Code@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy_SOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_delete_SOAP_ENV__Code@@YAXPAUsoap@@PAUSOAP_ENV__Code@@@Z ; soap_delete_SOAP_ENV__Code
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete_SOAP_ENV__Code@@YAXPAUsoap@@PAUSOAP_ENV__Code@@@Z PROC ; soap_delete_SOAP_ENV__Code
; _soap$ = eax
; _p$ = ecx

; 3267 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 3268 : }

	ret	0
?soap_delete_SOAP_ENV__Code@@YAXPAUsoap@@PAUSOAP_ENV__Code@@@Z ENDP ; soap_delete_SOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_default_SOAP_ENV__Code@@YAXPAUsoap@@PAUSOAP_ENV__Code@@@Z ; soap_default_SOAP_ENV__Code
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default_SOAP_ENV__Code@@YAXPAUsoap@@PAUSOAP_ENV__Code@@@Z PROC ; soap_default_SOAP_ENV__Code
; _a$ = eax

; 3180 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 3181 : 	soap_default__QName(soap, &a->SOAP_ENV__Value);

	mov	DWORD PTR [eax], 0

; 3182 : 	a->SOAP_ENV__Subcode = NULL;

	mov	DWORD PTR [eax+4], 0

; 3183 : }

	ret	0
?soap_default_SOAP_ENV__Code@@YAXPAUsoap@@PAUSOAP_ENV__Code@@@Z ENDP ; soap_default_SOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_copy_SOAP_ENV__Detail@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy_SOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_copy_SOAP_ENV__Detail@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy_SOAP_ENV__Detail
; _p$ = ecx
; _q$ = eax

; 3170 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
; 3171 : 	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;

	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 3172 : }

	ret	0
?soap_copy_SOAP_ENV__Detail@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy_SOAP_ENV__Detail
_TEXT	ENDS
PUBLIC	?soap_delete_SOAP_ENV__Detail@@YAXPAUsoap@@PAUSOAP_ENV__Detail@@@Z ; soap_delete_SOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete_SOAP_ENV__Detail@@YAXPAUsoap@@PAUSOAP_ENV__Detail@@@Z PROC ; soap_delete_SOAP_ENV__Detail
; _soap$ = eax
; _p$ = ecx

; 3142 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 3143 : }

	ret	0
?soap_delete_SOAP_ENV__Detail@@YAXPAUsoap@@PAUSOAP_ENV__Detail@@@Z ENDP ; soap_delete_SOAP_ENV__Detail
_TEXT	ENDS
PUBLIC	?soap_default_SOAP_ENV__Detail@@YAXPAUsoap@@PAUSOAP_ENV__Detail@@@Z ; soap_default_SOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default_SOAP_ENV__Detail@@YAXPAUsoap@@PAUSOAP_ENV__Detail@@@Z PROC ; soap_default_SOAP_ENV__Detail
; _a$ = eax

; 3057 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 3058 : 	a->__type = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 3059 : 	a->fault = NULL;

	mov	DWORD PTR [eax+4], ecx

; 3060 : 	a->__any = NULL;

	mov	DWORD PTR [eax+8], ecx

; 3061 : }

	ret	0
?soap_default_SOAP_ENV__Detail@@YAXPAUsoap@@PAUSOAP_ENV__Detail@@@Z ENDP ; soap_default_SOAP_ENV__Detail
_TEXT	ENDS
PUBLIC	?soap_copy_SOAP_ENV__Reason@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy_SOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_copy_SOAP_ENV__Reason@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy_SOAP_ENV__Reason
; _p$ = edx
; _q$ = eax

; 3047 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
; 3048 : 	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 3049 : }

	ret	0
?soap_copy_SOAP_ENV__Reason@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy_SOAP_ENV__Reason
_TEXT	ENDS
PUBLIC	?soap_delete_SOAP_ENV__Reason@@YAXPAUsoap@@PAUSOAP_ENV__Reason@@@Z ; soap_delete_SOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete_SOAP_ENV__Reason@@YAXPAUsoap@@PAUSOAP_ENV__Reason@@@Z PROC ; soap_delete_SOAP_ENV__Reason
; _soap$ = eax
; _p$ = ecx

; 3019 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 3020 : }

	ret	0
?soap_delete_SOAP_ENV__Reason@@YAXPAUsoap@@PAUSOAP_ENV__Reason@@@Z ENDP ; soap_delete_SOAP_ENV__Reason
_TEXT	ENDS
PUBLIC	?soap_default_SOAP_ENV__Reason@@YAXPAUsoap@@PAUSOAP_ENV__Reason@@@Z ; soap_default_SOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default_SOAP_ENV__Reason@@YAXPAUsoap@@PAUSOAP_ENV__Reason@@@Z PROC ; soap_default_SOAP_ENV__Reason
; _a$ = eax

; 2940 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 2941 : 	soap_default_string(soap, &a->SOAP_ENV__Text);

	mov	DWORD PTR [eax], 0

; 2942 : }

	ret	0
?soap_default_SOAP_ENV__Reason@@YAXPAUsoap@@PAUSOAP_ENV__Reason@@@Z ENDP ; soap_default_SOAP_ENV__Reason
_TEXT	ENDS
PUBLIC	?soap_copy_SOAP_ENV__Fault@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy_SOAP_ENV__Fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_copy_SOAP_ENV__Fault@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy_SOAP_ENV__Fault
; _p$ = ecx
; _q$ = eax

; 2930 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
; 2931 : 	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;

	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+8]
	movq	QWORD PTR [ecx+8], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0
	movq	xmm0, QWORD PTR [eax+24]
	movq	QWORD PTR [ecx+24], xmm0
	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR [ecx+32], eax

; 2932 : }

	ret	0
?soap_copy_SOAP_ENV__Fault@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy_SOAP_ENV__Fault
_TEXT	ENDS
PUBLIC	?soap_delete_SOAP_ENV__Fault@@YAXPAUsoap@@PAUSOAP_ENV__Fault@@@Z ; soap_delete_SOAP_ENV__Fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete_SOAP_ENV__Fault@@YAXPAUsoap@@PAUSOAP_ENV__Fault@@@Z PROC ; soap_delete_SOAP_ENV__Fault
; _soap$ = eax
; _p$ = ecx

; 2902 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 2903 : }

	ret	0
?soap_delete_SOAP_ENV__Fault@@YAXPAUsoap@@PAUSOAP_ENV__Fault@@@Z ENDP ; soap_delete_SOAP_ENV__Fault
_TEXT	ENDS
PUBLIC	?soap_default_SOAP_ENV__Fault@@YAXPAUsoap@@PAUSOAP_ENV__Fault@@@Z ; soap_default_SOAP_ENV__Fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default_SOAP_ENV__Fault@@YAXPAUsoap@@PAUSOAP_ENV__Fault@@@Z PROC ; soap_default_SOAP_ENV__Fault
; _a$ = eax

; 2745 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 2746 : 	soap_default__QName(soap, &a->faultcode);

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 2747 : 	soap_default_string(soap, &a->faultstring);

	mov	DWORD PTR [eax+4], ecx

; 2748 : 	soap_default_string(soap, &a->faultactor);

	mov	DWORD PTR [eax+8], ecx

; 2749 : 	a->detail = NULL;

	mov	DWORD PTR [eax+12], ecx

; 2750 : 	a->SOAP_ENV__Code = NULL;

	mov	DWORD PTR [eax+16], ecx

; 2751 : 	a->SOAP_ENV__Reason = NULL;

	mov	DWORD PTR [eax+20], ecx

; 2752 : 	soap_default_string(soap, &a->SOAP_ENV__Node);

	mov	DWORD PTR [eax+24], ecx

; 2753 : 	soap_default_string(soap, &a->SOAP_ENV__Role);

	mov	DWORD PTR [eax+28], ecx

; 2754 : 	a->SOAP_ENV__Detail = NULL;

	mov	DWORD PTR [eax+32], ecx

; 2755 : }

	ret	0
?soap_default_SOAP_ENV__Fault@@YAXPAUsoap@@PAUSOAP_ENV__Fault@@@Z ENDP ; soap_default_SOAP_ENV__Fault
_TEXT	ENDS
PUBLIC	?soap_delete_xsd__anyType@@YAXPAUsoap@@PAVxsd__anyType@@@Z ; soap_delete_xsd__anyType
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete_xsd__anyType@@YAXPAUsoap@@PAVxsd__anyType@@@Z PROC ; soap_delete_xsd__anyType
; _soap$ = eax
; _p$ = ecx

; 2596 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 2597 : }

	ret	0
?soap_delete_xsd__anyType@@YAXPAUsoap@@PAVxsd__anyType@@@Z ENDP ; soap_delete_xsd__anyType
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_serialize@xsd__anyType@@UBEXPAUsoap@@@Z PROC	; xsd__anyType::soap_serialize
; _this$ = ecx

; 2532 : 	(void)soap; /* appease -Wall -Werror */
; 2533 : 	/* transient soap skipped */
; 2534 : }

	ret	4
?soap_serialize@xsd__anyType@@UBEXPAUsoap@@@Z ENDP	; xsd__anyType::soap_serialize
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_default@xsd__anyType@@UAEXPAUsoap@@@Z PROC	; xsd__anyType::soap_default
; _this$ = ecx

; 2525 : 	this->soap = soap;

	mov	eax, DWORD PTR _soap$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 2526 : 	this->xsd__anyType::__item = NULL;

	mov	DWORD PTR [ecx+4], 0

; 2527 : 	/* transient soap skipped */
; 2528 : }

	ret	4
?soap_default@xsd__anyType@@UAEXPAUsoap@@@Z ENDP	; xsd__anyType::soap_default
_TEXT	ENDS
PUBLIC	?soap_delete_xsd__boolean@@YAXPAUsoap@@PAVxsd__boolean@@@Z ; soap_delete_xsd__boolean
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete_xsd__boolean@@YAXPAUsoap@@PAVxsd__boolean@@@Z PROC ; soap_delete_xsd__boolean
; _soap$ = eax
; _p$ = ecx

; 2488 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 2489 : }

	ret	0
?soap_delete_xsd__boolean@@YAXPAUsoap@@PAVxsd__boolean@@@Z ENDP ; soap_delete_xsd__boolean
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_serialize@xsd__boolean@@UBEXPAUsoap@@@Z PROC	; xsd__boolean::soap_serialize
; _this$ = ecx

; 2424 : 	(void)soap; /* appease -Wall -Werror */
; 2425 : 	/* transient soap skipped */
; 2426 : }

	ret	4
?soap_serialize@xsd__boolean@@UBEXPAUsoap@@@Z ENDP	; xsd__boolean::soap_serialize
_TEXT	ENDS
PUBLIC	?soap_delete_xsd__float@@YAXPAUsoap@@PAVxsd__float@@@Z ; soap_delete_xsd__float
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete_xsd__float@@YAXPAUsoap@@PAVxsd__float@@@Z PROC ; soap_delete_xsd__float
; _soap$ = eax
; _p$ = ecx

; 2379 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 2380 : }

	ret	0
?soap_delete_xsd__float@@YAXPAUsoap@@PAVxsd__float@@@Z ENDP ; soap_delete_xsd__float
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_serialize@xsd__float@@UBEXPAUsoap@@@Z PROC	; xsd__float::soap_serialize
; _this$ = ecx

; 2315 : 	(void)soap; /* appease -Wall -Werror */
; 2316 : 	/* transient soap skipped */
; 2317 : }

	ret	4
?soap_serialize@xsd__float@@UBEXPAUsoap@@@Z ENDP	; xsd__float::soap_serialize
_TEXT	ENDS
PUBLIC	?soap_delete_xsd__int@@YAXPAUsoap@@PAVxsd__int@@@Z ; soap_delete_xsd__int
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete_xsd__int@@YAXPAUsoap@@PAVxsd__int@@@Z PROC	; soap_delete_xsd__int
; _soap$ = eax
; _p$ = ecx

; 2270 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 2271 : }

	ret	0
?soap_delete_xsd__int@@YAXPAUsoap@@PAVxsd__int@@@Z ENDP	; soap_delete_xsd__int
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_serialize@xsd__int@@UBEXPAUsoap@@@Z PROC		; xsd__int::soap_serialize
; _this$ = ecx

; 2206 : 	(void)soap; /* appease -Wall -Werror */
; 2207 : 	/* transient soap skipped */
; 2208 : }

	ret	4
?soap_serialize@xsd__int@@UBEXPAUsoap@@@Z ENDP		; xsd__int::soap_serialize
_TEXT	ENDS
PUBLIC	?soap_delete_xsd__long@@YAXPAUsoap@@PAVxsd__long@@@Z ; soap_delete_xsd__long
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete_xsd__long@@YAXPAUsoap@@PAVxsd__long@@@Z PROC ; soap_delete_xsd__long
; _soap$ = eax
; _p$ = ecx

; 2161 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 2162 : }

	ret	0
?soap_delete_xsd__long@@YAXPAUsoap@@PAVxsd__long@@@Z ENDP ; soap_delete_xsd__long
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_serialize@xsd__long@@UBEXPAUsoap@@@Z PROC		; xsd__long::soap_serialize
; _this$ = ecx

; 2097 : 	(void)soap; /* appease -Wall -Werror */
; 2098 : 	/* transient soap skipped */
; 2099 : }

	ret	4
?soap_serialize@xsd__long@@UBEXPAUsoap@@@Z ENDP		; xsd__long::soap_serialize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4xsd__anyType@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4xsd__anyType@@QAEAAV0@ABV0@@Z PROC			; xsd__anyType::operator=, COMDAT
; _this$ = eax
; ___that$ = ecx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
	ret	0
??4xsd__anyType@@QAEAAV0@ABV0@@Z ENDP			; xsd__anyType::operator=
_TEXT	ENDS
PUBLIC	?soap_delete_xsd__string@@YAXPAUsoap@@PAVxsd__string@@@Z ; soap_delete_xsd__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete_xsd__string@@YAXPAUsoap@@PAVxsd__string@@@Z PROC ; soap_delete_xsd__string
; _soap$ = eax
; _p$ = ecx

; 2052 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 2053 : }

	ret	0
?soap_delete_xsd__string@@YAXPAUsoap@@PAVxsd__string@@@Z ENDP ; soap_delete_xsd__string
_TEXT	ENDS
PUBLIC	?soap_delete_std__string@@YAXPAUsoap@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; soap_delete_std__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete_std__string@@YAXPAUsoap@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; soap_delete_std__string
; _soap$ = eax
; _p$ = ecx

; 1944 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 1945 : }

	ret	0
?soap_delete_std__string@@YAXPAUsoap@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; soap_delete_std__string
_TEXT	ENDS
PUBLIC	?soap_serialize_std__string@@YAXPAUsoap@@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; soap_serialize_std__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_std__string@@YAXPAUsoap@@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; soap_serialize_std__string

; 1885 : }

	ret	0
?soap_serialize_std__string@@YAXPAUsoap@@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; soap_serialize_std__string
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4_ns2__getSessionIDElement@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4_ns2__getSessionIDElement@@QAEAAV0@ABV0@@Z PROC	; _ns2__getSessionIDElement::operator=, COMDAT
; _this$ = eax
; ___that$ = ecx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
	ret	0
??4_ns2__getSessionIDElement@@QAEAAV0@ABV0@@Z ENDP	; _ns2__getSessionIDElement::operator=
_TEXT	ENDS
PUBLIC	?soap_copy__ns2__getSessionIDElement@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy__ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_st$ = 12						; size = 4
_tt$ = 16						; size = 4
_p$ = 20						; size = 4
_len$ = 24						; size = 4
_q$ = 28						; size = 4
_n$ = 32						; size = 4
?soap_copy__ns2__getSessionIDElement@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy__ns2__getSessionIDElement

; 1874 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getSessionIDElement %p -> %p\n", q, p));
; 1875 : 	*(_ns2__getSessionIDElement*)p = *(_ns2__getSessionIDElement*)q;

	mov	eax, DWORD PTR _q$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1876 : }

	ret	0
?soap_copy__ns2__getSessionIDElement@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy__ns2__getSessionIDElement
_TEXT	ENDS
PUBLIC	?soap_delete__ns2__getSessionIDElement@@YAXPAUsoap@@PAV_ns2__getSessionIDElement@@@Z ; soap_delete__ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete__ns2__getSessionIDElement@@YAXPAUsoap@@PAV_ns2__getSessionIDElement@@@Z PROC ; soap_delete__ns2__getSessionIDElement
; _soap$ = eax
; _p$ = ecx

; 1843 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 1844 : }

	ret	0
?soap_delete__ns2__getSessionIDElement@@YAXPAUsoap@@PAV_ns2__getSessionIDElement@@@Z ENDP ; soap_delete__ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_default@_ns2__getSessionIDElement@@UAEXPAUsoap@@@Z PROC ; _ns2__getSessionIDElement::soap_default
; _this$ = ecx

; 1742 : 	this->soap = soap;

	mov	eax, DWORD PTR _soap$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 1743 : 	this->_ns2__getSessionIDElement::String_USCORE1 = NULL;

	mov	DWORD PTR [ecx+4], 0

; 1744 : 	/* transient soap skipped */
; 1745 : }

	ret	4
?soap_default@_ns2__getSessionIDElement@@UAEXPAUsoap@@@Z ENDP ; _ns2__getSessionIDElement::soap_default
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4_ns2__getSessionIDResponseElement@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4_ns2__getSessionIDResponseElement@@QAEAAV0@ABV0@@Z PROC ; _ns2__getSessionIDResponseElement::operator=, COMDAT
; _this$ = eax
; ___that$ = ecx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
	ret	0
??4_ns2__getSessionIDResponseElement@@QAEAAV0@ABV0@@Z ENDP ; _ns2__getSessionIDResponseElement::operator=
_TEXT	ENDS
PUBLIC	?soap_copy__ns2__getSessionIDResponseElement@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy__ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_st$ = 12						; size = 4
_tt$ = 16						; size = 4
_p$ = 20						; size = 4
_len$ = 24						; size = 4
_q$ = 28						; size = 4
_n$ = 32						; size = 4
?soap_copy__ns2__getSessionIDResponseElement@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy__ns2__getSessionIDResponseElement

; 1736 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getSessionIDResponseElement %p -> %p\n", q, p));
; 1737 : 	*(_ns2__getSessionIDResponseElement*)p = *(_ns2__getSessionIDResponseElement*)q;

	mov	eax, DWORD PTR _q$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1738 : }

	ret	0
?soap_copy__ns2__getSessionIDResponseElement@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy__ns2__getSessionIDResponseElement
_TEXT	ENDS
PUBLIC	?soap_delete__ns2__getSessionIDResponseElement@@YAXPAUsoap@@PAV_ns2__getSessionIDResponseElement@@@Z ; soap_delete__ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete__ns2__getSessionIDResponseElement@@YAXPAUsoap@@PAV_ns2__getSessionIDResponseElement@@@Z PROC ; soap_delete__ns2__getSessionIDResponseElement
; _soap$ = eax
; _p$ = ecx

; 1705 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 1706 : }

	ret	0
?soap_delete__ns2__getSessionIDResponseElement@@YAXPAUsoap@@PAV_ns2__getSessionIDResponseElement@@@Z ENDP ; soap_delete__ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_serialize@_ns2__getSessionIDResponseElement@@UBEXPAUsoap@@@Z PROC ; _ns2__getSessionIDResponseElement::soap_serialize
; _this$ = ecx

; 1606 : 	(void)soap; /* appease -Wall -Werror */
; 1607 : 	/* transient soap skipped */
; 1608 : }

	ret	4
?soap_serialize@_ns2__getSessionIDResponseElement@@UBEXPAUsoap@@@Z ENDP ; _ns2__getSessionIDResponseElement::soap_serialize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4_ns2__getSettingsFileElement@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4_ns2__getSettingsFileElement@@QAEAAV0@ABV0@@Z PROC	; _ns2__getSettingsFileElement::operator=, COMDAT
; _this$ = eax
; ___that$ = ecx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
	ret	0
??4_ns2__getSettingsFileElement@@QAEAAV0@ABV0@@Z ENDP	; _ns2__getSettingsFileElement::operator=
_TEXT	ENDS
PUBLIC	?soap_copy__ns2__getSettingsFileElement@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy__ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_st$ = 12						; size = 4
_tt$ = 16						; size = 4
_p$ = 20						; size = 4
_len$ = 24						; size = 4
_q$ = 28						; size = 4
_n$ = 32						; size = 4
?soap_copy__ns2__getSettingsFileElement@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy__ns2__getSettingsFileElement

; 1593 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getSettingsFileElement %p -> %p\n", q, p));
; 1594 : 	*(_ns2__getSettingsFileElement*)p = *(_ns2__getSettingsFileElement*)q;

	mov	eax, DWORD PTR _q$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1595 : }

	ret	0
?soap_copy__ns2__getSettingsFileElement@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy__ns2__getSettingsFileElement
_TEXT	ENDS
PUBLIC	?soap_delete__ns2__getSettingsFileElement@@YAXPAUsoap@@PAV_ns2__getSettingsFileElement@@@Z ; soap_delete__ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete__ns2__getSettingsFileElement@@YAXPAUsoap@@PAV_ns2__getSettingsFileElement@@@Z PROC ; soap_delete__ns2__getSettingsFileElement
; _soap$ = eax
; _p$ = ecx

; 1562 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 1563 : }

	ret	0
?soap_delete__ns2__getSettingsFileElement@@YAXPAUsoap@@PAV_ns2__getSettingsFileElement@@@Z ENDP ; soap_delete__ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_serialize@_ns2__getSettingsFileElement@@UBEXPAUsoap@@@Z PROC ; _ns2__getSettingsFileElement::soap_serialize
; _this$ = ecx

; 1465 : 	(void)soap; /* appease -Wall -Werror */
; 1466 : 	/* transient soap skipped */
; 1467 : }

	ret	4
?soap_serialize@_ns2__getSettingsFileElement@@UBEXPAUsoap@@@Z ENDP ; _ns2__getSettingsFileElement::soap_serialize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4_ns2__getSettingsFileResponseElement@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4_ns2__getSettingsFileResponseElement@@QAEAAV0@ABV0@@Z PROC ; _ns2__getSettingsFileResponseElement::operator=, COMDAT
; _this$ = eax
; ___that$ = ecx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
	ret	0
??4_ns2__getSettingsFileResponseElement@@QAEAAV0@ABV0@@Z ENDP ; _ns2__getSettingsFileResponseElement::operator=
_TEXT	ENDS
PUBLIC	?soap_copy__ns2__getSettingsFileResponseElement@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy__ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_st$ = 12						; size = 4
_tt$ = 16						; size = 4
_p$ = 20						; size = 4
_len$ = 24						; size = 4
_q$ = 28						; size = 4
_n$ = 32						; size = 4
?soap_copy__ns2__getSettingsFileResponseElement@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy__ns2__getSettingsFileResponseElement

; 1452 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getSettingsFileResponseElement %p -> %p\n", q, p));
; 1453 : 	*(_ns2__getSettingsFileResponseElement*)p = *(_ns2__getSettingsFileResponseElement*)q;

	mov	eax, DWORD PTR _q$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1454 : }

	ret	0
?soap_copy__ns2__getSettingsFileResponseElement@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy__ns2__getSettingsFileResponseElement
_TEXT	ENDS
PUBLIC	?soap_delete__ns2__getSettingsFileResponseElement@@YAXPAUsoap@@PAV_ns2__getSettingsFileResponseElement@@@Z ; soap_delete__ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete__ns2__getSettingsFileResponseElement@@YAXPAUsoap@@PAV_ns2__getSettingsFileResponseElement@@@Z PROC ; soap_delete__ns2__getSettingsFileResponseElement
; _soap$ = eax
; _p$ = ecx

; 1421 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 1422 : }

	ret	0
?soap_delete__ns2__getSettingsFileResponseElement@@YAXPAUsoap@@PAV_ns2__getSettingsFileResponseElement@@@Z ENDP ; soap_delete__ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_default@_ns2__getSettingsFileResponseElement@@UAEXPAUsoap@@@Z PROC ; _ns2__getSettingsFileResponseElement::soap_default
; _this$ = ecx

; 1317 : 	this->soap = soap;

	mov	eax, DWORD PTR _soap$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 1318 : 	this->_ns2__getSettingsFileResponseElement::result = NULL;

	mov	DWORD PTR [ecx+4], 0

; 1319 : 	/* transient soap skipped */
; 1320 : }

	ret	4
?soap_default@_ns2__getSettingsFileResponseElement@@UAEXPAUsoap@@@Z ENDP ; _ns2__getSettingsFileResponseElement::soap_default
_TEXT	ENDS
PUBLIC	?soap_delete__ns2__submitEpochResultElement@@YAXPAUsoap@@PAV_ns2__submitEpochResultElement@@@Z ; soap_delete__ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete__ns2__submitEpochResultElement@@YAXPAUsoap@@PAV_ns2__submitEpochResultElement@@@Z PROC ; soap_delete__ns2__submitEpochResultElement
; _soap$ = eax
; _p$ = ecx

; 1280 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 1281 : }

	ret	0
?soap_delete__ns2__submitEpochResultElement@@YAXPAUsoap@@PAV_ns2__submitEpochResultElement@@@Z ENDP ; soap_delete__ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4_ns2__submitEpochResultResponseElement@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4_ns2__submitEpochResultResponseElement@@QAEAAV0@ABV0@@Z PROC ; _ns2__submitEpochResultResponseElement::operator=, COMDAT
; _this$ = eax
; ___that$ = ecx
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
	ret	0
??4_ns2__submitEpochResultResponseElement@@QAEAAV0@ABV0@@Z ENDP ; _ns2__submitEpochResultResponseElement::operator=
_TEXT	ENDS
PUBLIC	?soap_copy__ns2__submitEpochResultResponseElement@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy__ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_st$ = 12						; size = 4
_tt$ = 16						; size = 4
_p$ = 20						; size = 4
_len$ = 24						; size = 4
_q$ = 28						; size = 4
_n$ = 32						; size = 4
?soap_copy__ns2__submitEpochResultResponseElement@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy__ns2__submitEpochResultResponseElement

; 1114 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__submitEpochResultResponseElement %p -> %p\n", q, p));
; 1115 : 	*(_ns2__submitEpochResultResponseElement*)p = *(_ns2__submitEpochResultResponseElement*)q;

	mov	eax, DWORD PTR _q$[esp-4]
	mov	dl, BYTE PTR [eax+4]
	mov	ecx, DWORD PTR _p$[esp-4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1116 : }

	ret	0
?soap_copy__ns2__submitEpochResultResponseElement@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy__ns2__submitEpochResultResponseElement
_TEXT	ENDS
PUBLIC	?soap_delete__ns2__submitEpochResultResponseElement@@YAXPAUsoap@@PAV_ns2__submitEpochResultResponseElement@@@Z ; soap_delete__ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_delete__ns2__submitEpochResultResponseElement@@YAXPAUsoap@@PAV_ns2__submitEpochResultResponseElement@@@Z PROC ; soap_delete__ns2__submitEpochResultResponseElement
; _soap$ = eax
; _p$ = ecx

; 1083 : {	soap_delete(soap, p);

	push	eax
	call	_soap_delete
	pop	ecx

; 1084 : }

	ret	0
?soap_delete__ns2__submitEpochResultResponseElement@@YAXPAUsoap@@PAV_ns2__submitEpochResultResponseElement@@@Z ENDP ; soap_delete__ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_serialize@_ns2__submitEpochResultResponseElement@@UBEXPAUsoap@@@Z PROC ; _ns2__submitEpochResultResponseElement::soap_serialize
; _this$ = ecx

; 984  : 	(void)soap; /* appease -Wall -Werror */
; 985  : 	/* transient soap skipped */
; 986  : }

	ret	4
?soap_serialize@_ns2__submitEpochResultResponseElement@@UBEXPAUsoap@@@Z ENDP ; _ns2__submitEpochResultResponseElement::soap_serialize
_TEXT	ENDS
PUBLIC	?soap_s2bool@@YAHPAUsoap@@PBDPA_N@Z		; soap_s2bool
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_n$83672 = -4						; size = 4
_a$ = 8							; size = 4
?soap_s2bool@@YAHPAUsoap@@PBDPA_N@Z PROC		; soap_s2bool
; _soap$ = ecx
; _s$ = eax

; 936  : {

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _a$[esp+4]
	push	esi
	mov	esi, eax
	push	edi
	mov	edi, ecx

; 937  : 	const struct soap_code_map *map;
; 938  : 	if (!s)

	test	esi, esi

; 939  : 		return SOAP_OK;

	je	SHORT $LN3@soap_s2boo

; 940  : 	map = soap_code(soap_codes_bool, s);

	call	_soap_code

; 941  : 	if (map)

	test	eax, eax
	je	SHORT $LN4@soap_s2boo

; 942  : 		*a = (bool)(map->code != 0);

	cmp	DWORD PTR [eax], 0
	pop	edi
	setne	al
	mov	BYTE PTR [ebx], al
	pop	esi

; 948  : 	}
; 949  : 	return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 950  : }

	pop	ecx
	ret	0
$LN4@soap_s2boo:

; 943  : 	else
; 944  : 	{	long n;
; 945  : 		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)

	lea	ecx, DWORD PTR _n$83672[esp+16]
	push	ecx
	call	_soap_s2long
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_s2boo
	mov	eax, DWORD PTR _n$83672[esp+16]
	cmp	eax, 1
	ja	SHORT $LN1@soap_s2boo

; 947  : 		*a = (bool)(n != 0);

	test	eax, eax
	setne	dl
	mov	BYTE PTR [ebx], dl
$LN3@soap_s2boo:
	pop	edi
	pop	esi

; 948  : 	}
; 949  : 	return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 950  : }

	pop	ecx
	ret	0
$LN1@soap_s2boo:

; 946  : 			return soap->error = SOAP_TYPE;

	mov	eax, 4
	mov	DWORD PTR [edi+90460], eax
	pop	edi
	pop	esi
	pop	ebx

; 950  : }

	pop	ecx
	ret	0
?soap_s2bool@@YAHPAUsoap@@PBDPA_N@Z ENDP		; soap_s2bool
_TEXT	ENDS
PUBLIC	?soap_bool2s@@YAPBDPAUsoap@@_N@Z		; soap_bool2s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_n$ = 8							; size = 1
?soap_bool2s@@YAPBDPAUsoap@@_N@Z PROC			; soap_bool2s

; 918  : {	return soap_code_str(soap_codes_bool, n!=0);

	xor	ecx, ecx
	cmp	BYTE PTR _n$[esp-4], cl
	mov	eax, OFFSET _soap_codes_bool
	setne	cl
	test	ecx, ecx
	je	SHORT $LN11@soap_bool2
$LL4@soap_bool2:
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN11@soap_bool2
	add	eax, 8
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LL4@soap_bool2
$LN11@soap_bool2:
	mov	eax, DWORD PTR [eax+4]

; 919  : }

	ret	0
?soap_bool2s@@YAPBDPAUsoap@@_N@Z ENDP			; soap_bool2s
_TEXT	ENDS
PUBLIC	?soap_default_bool@@YAXPAUsoap@@PA_N@Z		; soap_default_bool
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default_bool@@YAXPAUsoap@@PA_N@Z PROC		; soap_default_bool
; _a$ = eax

; 896  : #ifdef SOAP_DEFAULT_bool
; 897  : 	*a = SOAP_DEFAULT_bool;
; 898  : #else
; 899  : 	*a = (bool)0;

	mov	BYTE PTR [eax], 0

; 900  : #endif
; 901  : }

	ret	0
?soap_default_bool@@YAXPAUsoap@@PA_N@Z ENDP		; soap_default_bool
_TEXT	ENDS
PUBLIC	?soap_default_float@@YAXPAUsoap@@PAM@Z		; soap_default_float
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default_float@@YAXPAUsoap@@PAM@Z PROC		; soap_default_float
; _a$ = eax

; 861  : #ifdef SOAP_DEFAULT_float
; 862  : 	*a = SOAP_DEFAULT_float;
; 863  : #else
; 864  : 	*a = (float)0;

	xorps	xmm0, xmm0
	movss	DWORD PTR [eax], xmm0

; 865  : #endif
; 866  : }

	ret	0
?soap_default_float@@YAXPAUsoap@@PAM@Z ENDP		; soap_default_float
_TEXT	ENDS
PUBLIC	?soap_default_LONG64@@YAXPAUsoap@@PA_J@Z	; soap_default_LONG64
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default_LONG64@@YAXPAUsoap@@PA_J@Z PROC		; soap_default_LONG64
; _a$ = eax

; 826  : #ifdef SOAP_DEFAULT_LONG64
; 827  : 	*a = SOAP_DEFAULT_LONG64;
; 828  : #else
; 829  : 	*a = (LONG64)0;

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 830  : #endif
; 831  : }

	ret	0
?soap_default_LONG64@@YAXPAUsoap@@PA_J@Z ENDP		; soap_default_LONG64
_TEXT	ENDS
PUBLIC	?soap_default_int@@YAXPAUsoap@@PAH@Z		; soap_default_int
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default_int@@YAXPAUsoap@@PAH@Z PROC		; soap_default_int
; _a$ = eax

; 791  : #ifdef SOAP_DEFAULT_int
; 792  : 	*a = SOAP_DEFAULT_int;
; 793  : #else
; 794  : 	*a = (int)0;

	mov	DWORD PTR [eax], 0

; 795  : #endif
; 796  : }

	ret	0
?soap_default_int@@YAXPAUsoap@@PAH@Z ENDP		; soap_default_int
_TEXT	ENDS
PUBLIC	?soap_default_byte@@YAXPAUsoap@@PAD@Z		; soap_default_byte
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default_byte@@YAXPAUsoap@@PAD@Z PROC		; soap_default_byte
; _a$ = eax

; 756  : #ifdef SOAP_DEFAULT_byte
; 757  : 	*a = SOAP_DEFAULT_byte;
; 758  : #else
; 759  : 	*a = (char)0;

	mov	BYTE PTR [eax], 0

; 760  : #endif
; 761  : }

	ret	0
?soap_default_byte@@YAXPAUsoap@@PAD@Z ENDP		; soap_default_byte
_TEXT	ENDS
PUBLIC	_soap_serializeheader
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_serializeheader PROC

; 17   : 	if (soap->header)
; 18   : 		soap_serialize_SOAP_ENV__Header(soap, soap->header);
; 19   : }

	ret	0
_soap_serializeheader ENDP
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapstub.h
_TEXT	ENDS
;	COMDAT ??1_ns2__getSettingsFileResponseElement@@UAE@XZ
_TEXT	SEGMENT
??1_ns2__getSettingsFileResponseElement@@UAE@XZ PROC	; _ns2__getSettingsFileResponseElement::~_ns2__getSettingsFileResponseElement, COMDAT
; _this$ = ecx

; 236  : 	virtual ~_ns2__getSettingsFileResponseElement() { }

	mov	DWORD PTR [ecx], OFFSET ??_7_ns2__getSettingsFileResponseElement@@6B@
	ret	0
??1_ns2__getSettingsFileResponseElement@@UAE@XZ ENDP	; _ns2__getSettingsFileResponseElement::~_ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_ns2__getSettingsFileResponseElement@@QAE@XZ
_TEXT	SEGMENT
??0_ns2__getSettingsFileResponseElement@@QAE@XZ PROC	; _ns2__getSettingsFileResponseElement::_ns2__getSettingsFileResponseElement, COMDAT
; _this$ = ecx

; 235  : 	_ns2__getSettingsFileResponseElement() : result(NULL), soap(NULL) { }

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7_ns2__getSettingsFileResponseElement@@6B@
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0_ns2__getSettingsFileResponseElement@@QAE@XZ ENDP	; _ns2__getSettingsFileResponseElement::_ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?soap_type@_ns2__getSettingsFileResponseElement@@UBEHXZ
_TEXT	SEGMENT
?soap_type@_ns2__getSettingsFileResponseElement@@UBEHXZ PROC ; _ns2__getSettingsFileResponseElement::soap_type, COMDAT
; _this$ = ecx

; 228  : 	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE__ns2__getSettingsFileResponseElement */

	mov	eax, 22					; 00000016H
	ret	0
?soap_type@_ns2__getSettingsFileResponseElement@@UBEHXZ ENDP ; _ns2__getSettingsFileResponseElement::soap_type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1_ns2__getSettingsFileElement@@UAE@XZ
_TEXT	SEGMENT
??1_ns2__getSettingsFileElement@@UAE@XZ PROC		; _ns2__getSettingsFileElement::~_ns2__getSettingsFileElement, COMDAT
; _this$ = ecx

; 215  : 	virtual ~_ns2__getSettingsFileElement() { }

	mov	DWORD PTR [ecx], OFFSET ??_7_ns2__getSettingsFileElement@@6B@
	ret	0
??1_ns2__getSettingsFileElement@@UAE@XZ ENDP		; _ns2__getSettingsFileElement::~_ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_ns2__getSettingsFileElement@@QAE@XZ
_TEXT	SEGMENT
??0_ns2__getSettingsFileElement@@QAE@XZ PROC		; _ns2__getSettingsFileElement::_ns2__getSettingsFileElement, COMDAT
; _this$ = ecx

; 214  : 	_ns2__getSettingsFileElement() : int_USCORE1(0), soap(NULL) { }

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7_ns2__getSettingsFileElement@@6B@
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0_ns2__getSettingsFileElement@@QAE@XZ ENDP		; _ns2__getSettingsFileElement::_ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?soap_type@_ns2__getSettingsFileElement@@UBEHXZ
_TEXT	SEGMENT
?soap_type@_ns2__getSettingsFileElement@@UBEHXZ PROC	; _ns2__getSettingsFileElement::soap_type, COMDAT
; _this$ = ecx

; 207  : 	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE__ns2__getSettingsFileElement */

	mov	eax, 21					; 00000015H
	ret	0
?soap_type@_ns2__getSettingsFileElement@@UBEHXZ ENDP	; _ns2__getSettingsFileElement::soap_type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1_ns2__getSessionIDResponseElement@@UAE@XZ
_TEXT	SEGMENT
??1_ns2__getSessionIDResponseElement@@UAE@XZ PROC	; _ns2__getSessionIDResponseElement::~_ns2__getSessionIDResponseElement, COMDAT
; _this$ = ecx

; 194  : 	virtual ~_ns2__getSessionIDResponseElement() { }

	mov	DWORD PTR [ecx], OFFSET ??_7_ns2__getSessionIDResponseElement@@6B@
	ret	0
??1_ns2__getSessionIDResponseElement@@UAE@XZ ENDP	; _ns2__getSessionIDResponseElement::~_ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_ns2__getSessionIDResponseElement@@QAE@XZ
_TEXT	SEGMENT
??0_ns2__getSessionIDResponseElement@@QAE@XZ PROC	; _ns2__getSessionIDResponseElement::_ns2__getSessionIDResponseElement, COMDAT
; _this$ = ecx

; 193  : 	_ns2__getSessionIDResponseElement() : result(0), soap(NULL) { }

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7_ns2__getSessionIDResponseElement@@6B@
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0_ns2__getSessionIDResponseElement@@QAE@XZ ENDP	; _ns2__getSessionIDResponseElement::_ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?soap_type@_ns2__getSessionIDResponseElement@@UBEHXZ
_TEXT	SEGMENT
?soap_type@_ns2__getSessionIDResponseElement@@UBEHXZ PROC ; _ns2__getSessionIDResponseElement::soap_type, COMDAT
; _this$ = ecx

; 186  : 	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE__ns2__getSessionIDResponseElement */

	mov	eax, 20					; 00000014H
	ret	0
?soap_type@_ns2__getSessionIDResponseElement@@UBEHXZ ENDP ; _ns2__getSessionIDResponseElement::soap_type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1_ns2__getSessionIDElement@@UAE@XZ
_TEXT	SEGMENT
??1_ns2__getSessionIDElement@@UAE@XZ PROC		; _ns2__getSessionIDElement::~_ns2__getSessionIDElement, COMDAT
; _this$ = ecx

; 173  : 	virtual ~_ns2__getSessionIDElement() { }

	mov	DWORD PTR [ecx], OFFSET ??_7_ns2__getSessionIDElement@@6B@
	ret	0
??1_ns2__getSessionIDElement@@UAE@XZ ENDP		; _ns2__getSessionIDElement::~_ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_ns2__getSessionIDElement@@QAE@XZ
_TEXT	SEGMENT
??0_ns2__getSessionIDElement@@QAE@XZ PROC		; _ns2__getSessionIDElement::_ns2__getSessionIDElement, COMDAT
; _this$ = ecx

; 172  : 	_ns2__getSessionIDElement() : String_USCORE1(NULL), soap(NULL) { }

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7_ns2__getSessionIDElement@@6B@
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0_ns2__getSessionIDElement@@QAE@XZ ENDP		; _ns2__getSessionIDElement::_ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?soap_type@_ns2__getSessionIDElement@@UBEHXZ
_TEXT	SEGMENT
?soap_type@_ns2__getSessionIDElement@@UBEHXZ PROC	; _ns2__getSessionIDElement::soap_type, COMDAT
; _this$ = ecx

; 165  : 	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE__ns2__getSessionIDElement */

	mov	eax, 19					; 00000013H
	ret	0
?soap_type@_ns2__getSessionIDElement@@UBEHXZ ENDP	; _ns2__getSessionIDElement::soap_type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?soap_type@xsd__string@@UBEHXZ
_TEXT	SEGMENT
?soap_type@xsd__string@@UBEHXZ PROC			; xsd__string::soap_type, COMDAT
; _this$ = ecx

; 144  : 	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_xsd__string */

	mov	eax, 17					; 00000011H
	ret	0
?soap_type@xsd__string@@UBEHXZ ENDP			; xsd__string::soap_type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?soap_type@xsd__long@@UBEHXZ
_TEXT	SEGMENT
?soap_type@xsd__long@@UBEHXZ PROC			; xsd__long::soap_type, COMDAT
; _this$ = ecx

; 120  : 	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_xsd__long */

	mov	eax, 15					; 0000000fH
	ret	0
?soap_type@xsd__long@@UBEHXZ ENDP			; xsd__long::soap_type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?soap_type@xsd__int@@UBEHXZ
_TEXT	SEGMENT
?soap_type@xsd__int@@UBEHXZ PROC			; xsd__int::soap_type, COMDAT
; _this$ = ecx

; 100  : 	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_xsd__int */

	mov	eax, 14					; 0000000eH
	ret	0
?soap_type@xsd__int@@UBEHXZ ENDP			; xsd__int::soap_type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?soap_type@xsd__float@@UBEHXZ
_TEXT	SEGMENT
?soap_type@xsd__float@@UBEHXZ PROC			; xsd__float::soap_type, COMDAT
; _this$ = ecx

; 80   : 	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_xsd__float */

	mov	eax, 12					; 0000000cH
	ret	0
?soap_type@xsd__float@@UBEHXZ ENDP			; xsd__float::soap_type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?soap_type@xsd__boolean@@UBEHXZ
_TEXT	SEGMENT
?soap_type@xsd__boolean@@UBEHXZ PROC			; xsd__boolean::soap_type, COMDAT
; _this$ = ecx

; 60   : 	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_xsd__boolean */

	mov	eax, 10					; 0000000aH
	ret	0
?soap_type@xsd__boolean@@UBEHXZ ENDP			; xsd__boolean::soap_type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1xsd__anyType@@UAE@XZ
_TEXT	SEGMENT
??1xsd__anyType@@UAE@XZ PROC				; xsd__anyType::~xsd__anyType, COMDAT
; _this$ = ecx

; 48   : 	virtual ~xsd__anyType() { }

	mov	DWORD PTR [ecx], OFFSET ??_7xsd__anyType@@6B@
	ret	0
??1xsd__anyType@@UAE@XZ ENDP				; xsd__anyType::~xsd__anyType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0xsd__anyType@@QAE@XZ
_TEXT	SEGMENT
??0xsd__anyType@@QAE@XZ PROC				; xsd__anyType::xsd__anyType, COMDAT
; _this$ = ecx

; 47   : 	xsd__anyType() : __item(NULL), soap(NULL) { }

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7xsd__anyType@@6B@
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0xsd__anyType@@QAE@XZ ENDP				; xsd__anyType::xsd__anyType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?soap_type@xsd__anyType@@UBEHXZ
_TEXT	SEGMENT
?soap_type@xsd__anyType@@UBEHXZ PROC			; xsd__anyType::soap_type, COMDAT
; _this$ = ecx

; 40   : 	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_xsd__anyType */

	mov	eax, 8
	ret	0
?soap_type@xsd__anyType@@UBEHXZ ENDP			; xsd__anyType::soap_type
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Move_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<float *,float *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<float *,float *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAMPAM@stdext@@YAPAMPAM00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAMPAM@stdext@@YAPAMPAM00@Z PROC ; stdext::_Unchecked_move_backward<float *,float *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN22@Unchecked_
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Unchecked_:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAMPAM@stdext@@YAPAMPAM00@Z ENDP ; stdext::_Unchecked_move_backward<float *,float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$fill@PAMM@std@@YAXPAM0ABM@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$fill@PAMM@std@@YAXPAM0ABM@Z PROC			; std::fill<float *,float>, COMDAT
; __First$ = eax
; __Last$ = ecx

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	cmp	eax, ecx
	je	SHORT $LN11@fill@7
	mov	edx, DWORD PTR __Val$[esp-4]
	movss	xmm0, DWORD PTR [edx]
	npad	4
$LL13@fill@7:
	movss	DWORD PTR [eax], xmm0
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL13@fill@7
$LN11@fill@7:

; 3188 : 	}

	ret	0
??$fill@PAMM@std@@YAXPAM0ABM@Z ENDP			; std::fill<float *,float>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
??G?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<float,std::allocator<float> >::operator-, COMDAT
; _this$ = edi
; __Right$ = esi

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@36
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@36
$LN1@operator@36:
	call	__invalid_parameter_noinfo
$LN2@operator@36:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [esi+4]
	sar	eax, 2

; 195  : 		}

	ret	0
??G?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<float,std::allocator<float> >::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@37
	call	__invalid_parameter_noinfo
$LN1@operator@37:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 786  : 		}

	ret	0
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	?soap_serialize_string@@YAXPAUsoap@@PBQAD@Z	; soap_serialize_string
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapc.cpp
_TEXT	SEGMENT
?soap_serialize_string@@YAXPAUsoap@@PBQAD@Z PROC	; soap_serialize_string
; _soap$ = eax
; _a$ = ecx

; 4296 : 	soap_reference(soap, *a, SOAP_TYPE_string);

	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	eax, 4
	call	_soap_reference
	pop	ecx

; 4297 : }

	ret	0
?soap_serialize_string@@YAXPAUsoap@@PBQAD@Z ENDP	; soap_serialize_string
_TEXT	ENDS
PUBLIC	?soap_serialize__QName@@YAXPAUsoap@@PBQAD@Z	; soap_serialize__QName
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize__QName@@YAXPAUsoap@@PBQAD@Z PROC	; soap_serialize__QName
; _soap$ = eax
; _a$ = ecx

; 4256 : {	soap_serialize_string(soap, a);

	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	eax, 4
	call	_soap_reference
	pop	ecx

; 4257 : }

	ret	0
?soap_serialize__QName@@YAXPAUsoap@@PBQAD@Z ENDP	; soap_serialize__QName
_TEXT	ENDS
PUBLIC	?soap_serialize_PointerTostd__string@@YAXPAUsoap@@PBQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; soap_serialize_PointerTostd__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_PointerTostd__string@@YAXPAUsoap@@PBQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; soap_serialize_PointerTostd__string
; _soap$ = eax
; _a$ = ecx

; 4202 : 	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))

	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	eax, 18					; 00000012H
	call	_soap_reference
	pop	ecx

; 4203 : 		soap_serialize_std__string(soap, *a);
; 4204 : }

	ret	0
?soap_serialize_PointerTostd__string@@YAXPAUsoap@@PBQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; soap_serialize_PointerTostd__string
_TEXT	ENDS
PUBLIC	?soap_serialize_PointerTo_ns2__getSessionIDElement@@YAXPAUsoap@@PBQAV_ns2__getSessionIDElement@@@Z ; soap_serialize_PointerTo_ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_PointerTo_ns2__getSessionIDElement@@YAXPAUsoap@@PBQAV_ns2__getSessionIDElement@@@Z PROC ; soap_serialize_PointerTo_ns2__getSessionIDElement
; _soap$ = edi
; _a$ = esi

; 4147 : 	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getSessionIDElement))

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	eax, 19					; 00000013H
	call	_soap_reference
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_seria

; 4148 : 		(*a)->soap_serialize(soap);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	edi
	call	edx
$LN1@soap_seria:

; 4149 : }

	ret	0
?soap_serialize_PointerTo_ns2__getSessionIDElement@@YAXPAUsoap@@PBQAV_ns2__getSessionIDElement@@@Z ENDP ; soap_serialize_PointerTo_ns2__getSessionIDElement
_TEXT	ENDS
PUBLIC	?soap_serialize_PointerTo_ns2__getSessionIDResponseElement@@YAXPAUsoap@@PBQAV_ns2__getSessionIDResponseElement@@@Z ; soap_serialize_PointerTo_ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_PointerTo_ns2__getSessionIDResponseElement@@YAXPAUsoap@@PBQAV_ns2__getSessionIDResponseElement@@@Z PROC ; soap_serialize_PointerTo_ns2__getSessionIDResponseElement
; _soap$ = edi
; _a$ = esi

; 4092 : 	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getSessionIDResponseElement))

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	eax, 20					; 00000014H
	call	_soap_reference
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_seria@2

; 4093 : 		(*a)->soap_serialize(soap);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	edi
	call	edx
$LN1@soap_seria@2:

; 4094 : }

	ret	0
?soap_serialize_PointerTo_ns2__getSessionIDResponseElement@@YAXPAUsoap@@PBQAV_ns2__getSessionIDResponseElement@@@Z ENDP ; soap_serialize_PointerTo_ns2__getSessionIDResponseElement
_TEXT	ENDS
PUBLIC	?soap_serialize_PointerTo_ns2__getSettingsFileElement@@YAXPAUsoap@@PBQAV_ns2__getSettingsFileElement@@@Z ; soap_serialize_PointerTo_ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_PointerTo_ns2__getSettingsFileElement@@YAXPAUsoap@@PBQAV_ns2__getSettingsFileElement@@@Z PROC ; soap_serialize_PointerTo_ns2__getSettingsFileElement
; _soap$ = edi
; _a$ = esi

; 4037 : 	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getSettingsFileElement))

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	eax, 21					; 00000015H
	call	_soap_reference
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_seria@3

; 4038 : 		(*a)->soap_serialize(soap);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	edi
	call	edx
$LN1@soap_seria@3:

; 4039 : }

	ret	0
?soap_serialize_PointerTo_ns2__getSettingsFileElement@@YAXPAUsoap@@PBQAV_ns2__getSettingsFileElement@@@Z ENDP ; soap_serialize_PointerTo_ns2__getSettingsFileElement
_TEXT	ENDS
PUBLIC	?soap_serialize_PointerTo_ns2__getSettingsFileResponseElement@@YAXPAUsoap@@PBQAV_ns2__getSettingsFileResponseElement@@@Z ; soap_serialize_PointerTo_ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_PointerTo_ns2__getSettingsFileResponseElement@@YAXPAUsoap@@PBQAV_ns2__getSettingsFileResponseElement@@@Z PROC ; soap_serialize_PointerTo_ns2__getSettingsFileResponseElement
; _soap$ = edi
; _a$ = esi

; 3982 : 	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getSettingsFileResponseElement))

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	eax, 22					; 00000016H
	call	_soap_reference
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_seria@4

; 3983 : 		(*a)->soap_serialize(soap);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	edi
	call	edx
$LN1@soap_seria@4:

; 3984 : }

	ret	0
?soap_serialize_PointerTo_ns2__getSettingsFileResponseElement@@YAXPAUsoap@@PBQAV_ns2__getSettingsFileResponseElement@@@Z ENDP ; soap_serialize_PointerTo_ns2__getSettingsFileResponseElement
_TEXT	ENDS
PUBLIC	?soap_serialize_PointerTo_ns2__submitEpochResultElement@@YAXPAUsoap@@PBQAV_ns2__submitEpochResultElement@@@Z ; soap_serialize_PointerTo_ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_PointerTo_ns2__submitEpochResultElement@@YAXPAUsoap@@PBQAV_ns2__submitEpochResultElement@@@Z PROC ; soap_serialize_PointerTo_ns2__submitEpochResultElement
; _soap$ = edi
; _a$ = esi

; 3927 : 	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__submitEpochResultElement))

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	eax, 23					; 00000017H
	call	_soap_reference
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_seria@5

; 3928 : 		(*a)->soap_serialize(soap);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	edi
	call	edx
$LN1@soap_seria@5:

; 3929 : }

	ret	0
?soap_serialize_PointerTo_ns2__submitEpochResultElement@@YAXPAUsoap@@PBQAV_ns2__submitEpochResultElement@@@Z ENDP ; soap_serialize_PointerTo_ns2__submitEpochResultElement
_TEXT	ENDS
PUBLIC	?soap_serialize_PointerTo_ns2__submitEpochResultResponseElement@@YAXPAUsoap@@PBQAV_ns2__submitEpochResultResponseElement@@@Z ; soap_serialize_PointerTo_ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_PointerTo_ns2__submitEpochResultResponseElement@@YAXPAUsoap@@PBQAV_ns2__submitEpochResultResponseElement@@@Z PROC ; soap_serialize_PointerTo_ns2__submitEpochResultResponseElement
; _soap$ = edi
; _a$ = esi

; 3872 : 	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__submitEpochResultResponseElement))

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	eax, 24					; 00000018H
	call	_soap_reference
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_seria@6

; 3873 : 		(*a)->soap_serialize(soap);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	edi
	call	edx
$LN1@soap_seria@6:

; 3874 : }

	ret	0
?soap_serialize_PointerTo_ns2__submitEpochResultResponseElement@@YAXPAUsoap@@PBQAV_ns2__submitEpochResultResponseElement@@@Z ENDP ; soap_serialize_PointerTo_ns2__submitEpochResultResponseElement
_TEXT	ENDS
PUBLIC	?soap_serialize___ns1__getSessionID@@YAXPAUsoap@@PBU__ns1__getSessionID@@@Z ; soap_serialize___ns1__getSessionID
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize___ns1__getSessionID@@YAXPAUsoap@@PBU__ns1__getSessionID@@@Z PROC ; soap_serialize___ns1__getSessionID
; _soap$ = edi
; _a$ = esi

; 3613 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 3614 : 	soap_serialize_PointerTo_ns2__getSessionIDElement(soap, &a->ns2__getSessionIDElement);

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	eax, 19					; 00000013H
	call	_soap_reference
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@soap_seria@7
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	edi
	call	edx
$LN3@soap_seria@7:

; 3615 : }

	ret	0
?soap_serialize___ns1__getSessionID@@YAXPAUsoap@@PBU__ns1__getSessionID@@@Z ENDP ; soap_serialize___ns1__getSessionID
_TEXT	ENDS
PUBLIC	?soap_serialize___ns1__getSettingsFile@@YAXPAUsoap@@PBU__ns1__getSettingsFile@@@Z ; soap_serialize___ns1__getSettingsFile
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize___ns1__getSettingsFile@@YAXPAUsoap@@PBU__ns1__getSettingsFile@@@Z PROC ; soap_serialize___ns1__getSettingsFile
; _soap$ = edi
; _a$ = esi

; 3513 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 3514 : 	soap_serialize_PointerTo_ns2__getSettingsFileElement(soap, &a->ns2__getSettingsFileElement);

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	eax, 21					; 00000015H
	call	_soap_reference
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@soap_seria@8
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	edi
	call	edx
$LN3@soap_seria@8:

; 3515 : }

	ret	0
?soap_serialize___ns1__getSettingsFile@@YAXPAUsoap@@PBU__ns1__getSettingsFile@@@Z ENDP ; soap_serialize___ns1__getSettingsFile
_TEXT	ENDS
PUBLIC	?soap_serialize___ns1__submitEpochResult@@YAXPAUsoap@@PBU__ns1__submitEpochResult@@@Z ; soap_serialize___ns1__submitEpochResult
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize___ns1__submitEpochResult@@YAXPAUsoap@@PBU__ns1__submitEpochResult@@@Z PROC ; soap_serialize___ns1__submitEpochResult
; _soap$ = edi
; _a$ = esi

; 3413 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 3414 : 	soap_serialize_PointerTo_ns2__submitEpochResultElement(soap, &a->ns2__submitEpochResultElement);

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	eax, 23					; 00000017H
	call	_soap_reference
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@soap_seria@9
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	edi
	call	edx
$LN3@soap_seria@9:

; 3415 : }

	ret	0
?soap_serialize___ns1__submitEpochResult@@YAXPAUsoap@@PBU__ns1__submitEpochResult@@@Z ENDP ; soap_serialize___ns1__submitEpochResult
_TEXT	ENDS
PUBLIC	?soap_serialize_SOAP_ENV__Code@@YAXPAUsoap@@PBUSOAP_ENV__Code@@@Z ; soap_serialize_SOAP_ENV__Code
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_SOAP_ENV__Code@@YAXPAUsoap@@PBUSOAP_ENV__Code@@@Z PROC ; soap_serialize_SOAP_ENV__Code
; _soap$ = edi
; _a$ = eax

; 3186 : {

	push	esi
	mov	esi, eax

; 3187 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 3188 : 	soap_serialize__QName(soap, &a->SOAP_ENV__Value);

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	eax, 4
	call	_soap_reference

; 3189 : 	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);

	mov	ecx, DWORD PTR [esi+4]
	add	esi, 4
	push	edi
	mov	eax, 41					; 00000029H
	call	_soap_reference
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@soap_seria@10
$LL10@soap_seria@10:
	mov	esi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	eax, 4
	call	_soap_reference
	mov	ecx, DWORD PTR [esi+4]
	add	esi, 4
	push	edi
	mov	eax, 41					; 00000029H
	call	_soap_reference
	add	esp, 8
	test	eax, eax
	je	SHORT $LL10@soap_seria@10
$LN7@soap_seria@10:
	pop	esi

; 3190 : }

	ret	0
?soap_serialize_SOAP_ENV__Code@@YAXPAUsoap@@PBUSOAP_ENV__Code@@@Z ENDP ; soap_serialize_SOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_serialize_SOAP_ENV__Reason@@YAXPAUsoap@@PBUSOAP_ENV__Reason@@@Z ; soap_serialize_SOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_SOAP_ENV__Reason@@YAXPAUsoap@@PBUSOAP_ENV__Reason@@@Z PROC ; soap_serialize_SOAP_ENV__Reason
; _soap$ = eax
; _a$ = ecx

; 2946 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 2947 : 	soap_serialize_string(soap, &a->SOAP_ENV__Text);

	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	eax, 4
	call	_soap_reference
	pop	ecx

; 2948 : }

	ret	0
?soap_serialize_SOAP_ENV__Reason@@YAXPAUsoap@@PBUSOAP_ENV__Reason@@@Z ENDP ; soap_serialize_SOAP_ENV__Reason
_TEXT	ENDS
PUBLIC	?soap_copy_xsd__anyType@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy_xsd__anyType
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_copy_xsd__anyType@@YAXPAUsoap@@HHPAXIPBXI@Z PROC	; soap_copy_xsd__anyType
; _p$ = ecx
; _q$ = eax

; 2737 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
; 2738 : 	*(xsd__anyType*)p = *(xsd__anyType*)q;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 2739 : }

	ret	0
?soap_copy_xsd__anyType@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP	; soap_copy_xsd__anyType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Exsd__anyType@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Exsd__anyType@@UAEPAXI@Z PROC			; xsd__anyType::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1xsd__anyType@@UAE@XZ		; xsd__anyType::~xsd__anyType
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	12					; 0000000cH
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector:
	mov	DWORD PTR [esi], OFFSET ??_7xsd__anyType@@6B@
	test	bl, 1
	je	SHORT $LN1@vector
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_Exsd__anyType@@UAEPAXI@Z ENDP			; xsd__anyType::`vector deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4xsd__boolean@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4xsd__boolean@@QAEAAV0@ABV0@@Z PROC			; xsd__boolean::operator=, COMDAT
; _this$ = eax
; ___that$ = ecx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	cl, BYTE PTR [ecx+12]
	mov	BYTE PTR [eax+12], cl
	ret	0
??4xsd__boolean@@QAEAAV0@ABV0@@Z ENDP			; xsd__boolean::operator=
_TEXT	ENDS
PUBLIC	?soap_copy_xsd__boolean@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy_xsd__boolean
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_copy_xsd__boolean@@YAXPAUsoap@@HHPAXIPBXI@Z PROC	; soap_copy_xsd__boolean
; _p$ = ecx
; _q$ = eax

; 2519 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean %p -> %p\n", q, p));
; 2520 : 	*(xsd__boolean*)p = *(xsd__boolean*)q;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	al, BYTE PTR [eax+12]
	mov	BYTE PTR [ecx+12], al

; 2521 : }

	ret	0
?soap_copy_xsd__boolean@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP	; soap_copy_xsd__boolean
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_default@xsd__boolean@@UAEXPAUsoap@@@Z PROC	; xsd__boolean::soap_default
; _this$ = ecx

; 2416 : 	this->soap = soap;

	mov	eax, DWORD PTR _soap$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 2417 : 	soap_default_bool(soap, &this->xsd__boolean::__item);

	xor	eax, eax
	mov	BYTE PTR [ecx+12], al

; 2418 : 	this->xsd__anyType::__item = NULL;

	mov	DWORD PTR [ecx+4], eax

; 2419 : 	/* transient soap skipped */
; 2420 : }

	ret	4
?soap_default@xsd__boolean@@UAEXPAUsoap@@@Z ENDP	; xsd__boolean::soap_default
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4xsd__float@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4xsd__float@@QAEAAV0@ABV0@@Z PROC			; xsd__float::operator=, COMDAT
; _this$ = eax
; ___that$ = ecx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+12]
	ret	0
??4xsd__float@@QAEAAV0@ABV0@@Z ENDP			; xsd__float::operator=
_TEXT	ENDS
PUBLIC	?soap_copy_xsd__float@@YAXPAUsoap@@HHPAXIPBXI@Z	; soap_copy_xsd__float
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_copy_xsd__float@@YAXPAUsoap@@HHPAXIPBXI@Z PROC	; soap_copy_xsd__float
; _p$ = ecx
; _q$ = eax

; 2410 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__float %p -> %p\n", q, p));
; 2411 : 	*(xsd__float*)p = *(xsd__float*)q;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	fld	DWORD PTR [eax+12]
	fstp	DWORD PTR [ecx+12]

; 2412 : }

	ret	0
?soap_copy_xsd__float@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP	; soap_copy_xsd__float
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_default@xsd__float@@UAEXPAUsoap@@@Z PROC		; xsd__float::soap_default
; _this$ = ecx

; 2307 : 	this->soap = soap;

	mov	eax, DWORD PTR _soap$[esp-4]

; 2308 : 	soap_default_float(soap, &this->xsd__float::__item);

	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx+8], eax
	movss	DWORD PTR [ecx+12], xmm0

; 2309 : 	this->xsd__anyType::__item = NULL;

	mov	DWORD PTR [ecx+4], 0

; 2310 : 	/* transient soap skipped */
; 2311 : }

	ret	4
?soap_default@xsd__float@@UAEXPAUsoap@@@Z ENDP		; xsd__float::soap_default
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4xsd__int@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4xsd__int@@QAEAAV0@ABV0@@Z PROC			; xsd__int::operator=, COMDAT
; _this$ = eax
; ___that$ = ecx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
	ret	0
??4xsd__int@@QAEAAV0@ABV0@@Z ENDP			; xsd__int::operator=
_TEXT	ENDS
PUBLIC	?soap_copy_xsd__int@@YAXPAUsoap@@HHPAXIPBXI@Z	; soap_copy_xsd__int
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_copy_xsd__int@@YAXPAUsoap@@HHPAXIPBXI@Z PROC	; soap_copy_xsd__int
; _p$ = ecx
; _q$ = eax

; 2301 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int %p -> %p\n", q, p));
; 2302 : 	*(xsd__int*)p = *(xsd__int*)q;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 2303 : }

	ret	0
?soap_copy_xsd__int@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP	; soap_copy_xsd__int
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_default@xsd__int@@UAEXPAUsoap@@@Z PROC		; xsd__int::soap_default
; _this$ = ecx

; 2198 : 	this->soap = soap;

	mov	eax, DWORD PTR _soap$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 2199 : 	soap_default_int(soap, &this->xsd__int::__item);

	xor	eax, eax
	mov	DWORD PTR [ecx+12], eax

; 2200 : 	this->xsd__anyType::__item = NULL;

	mov	DWORD PTR [ecx+4], eax

; 2201 : 	/* transient soap skipped */
; 2202 : }

	ret	4
?soap_default@xsd__int@@UAEXPAUsoap@@@Z ENDP		; xsd__int::soap_default
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4xsd__long@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4xsd__long@@QAEAAV0@ABV0@@Z PROC			; xsd__long::operator=, COMDAT
; _this$ = eax
; ___that$ = ecx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx
	ret	0
??4xsd__long@@QAEAAV0@ABV0@@Z ENDP			; xsd__long::operator=
_TEXT	ENDS
PUBLIC	?soap_copy_xsd__long@@YAXPAUsoap@@HHPAXIPBXI@Z	; soap_copy_xsd__long
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_copy_xsd__long@@YAXPAUsoap@@HHPAXIPBXI@Z PROC	; soap_copy_xsd__long
; _p$ = ecx
; _q$ = eax

; 2192 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__long %p -> %p\n", q, p));
; 2193 : 	*(xsd__long*)p = *(xsd__long*)q;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax

; 2194 : }

	ret	0
?soap_copy_xsd__long@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP	; soap_copy_xsd__long
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_default@xsd__long@@UAEXPAUsoap@@@Z PROC		; xsd__long::soap_default
; _this$ = ecx

; 2089 : 	this->soap = soap;

	mov	eax, DWORD PTR _soap$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 2090 : 	soap_default_LONG64(soap, &this->xsd__long::__item);

	xor	eax, eax
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax

; 2091 : 	this->xsd__anyType::__item = NULL;

	mov	DWORD PTR [ecx+4], eax

; 2092 : 	/* transient soap skipped */
; 2093 : }

	ret	4
?soap_default@xsd__long@@UAEXPAUsoap@@@Z ENDP		; xsd__long::soap_default
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_serialize@xsd__string@@UBEXPAUsoap@@@Z PROC	; xsd__string::soap_serialize
; _this$ = ecx

; 1986 : 	(void)soap; /* appease -Wall -Werror */
; 1987 : 	soap_embedded(soap, &this->xsd__string::__item, SOAP_TYPE_std__string);

	mov	edx, DWORD PTR _soap$[esp-4]
	add	ecx, 12					; 0000000cH
	call	_soap_embedded

; 1988 : 	soap_serialize_std__string(soap, &this->xsd__string::__item);
; 1989 : 	/* transient soap skipped */
; 1990 : }

	ret	4
?soap_serialize@xsd__string@@UBEXPAUsoap@@@Z ENDP	; xsd__string::soap_serialize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_E_ns2__getSessionIDElement@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_E_ns2__getSessionIDElement@@UAEPAXI@Z PROC		; _ns2__getSessionIDElement::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector@2
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1_ns2__getSessionIDElement@@UAE@XZ ; _ns2__getSessionIDElement::~_ns2__getSessionIDElement
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	12					; 0000000cH
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector@2
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@2:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector@2:
	mov	DWORD PTR [esi], OFFSET ??_7_ns2__getSessionIDElement@@6B@
	test	bl, 1
	je	SHORT $LN1@vector@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@2:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_E_ns2__getSessionIDElement@@UAEPAXI@Z ENDP		; _ns2__getSessionIDElement::`vector deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
_TEXT	SEGMENT
_soap$ = 8						; size = 4
?soap_serialize@_ns2__getSessionIDElement@@UBEXPAUsoap@@@Z PROC ; _ns2__getSessionIDElement::soap_serialize
; _this$ = ecx

; 1749 : 	(void)soap; /* appease -Wall -Werror */
; 1750 : 	soap_serialize_PointerTostd__string(soap, &this->_ns2__getSessionIDElement::String_USCORE1);

	mov	eax, DWORD PTR _soap$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	push	eax
	mov	eax, 18					; 00000012H
	call	_soap_reference
	pop	ecx

; 1751 : 	/* transient soap skipped */
; 1752 : }

	ret	4
?soap_serialize@_ns2__getSessionIDElement@@UBEXPAUsoap@@@Z ENDP ; _ns2__getSessionIDElement::soap_serialize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_E_ns2__getSessionIDResponseElement@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_E_ns2__getSessionIDResponseElement@@UAEPAXI@Z PROC	; _ns2__getSessionIDResponseElement::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector@3
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1_ns2__getSessionIDResponseElement@@UAE@XZ ; _ns2__getSessionIDResponseElement::~_ns2__getSessionIDResponseElement
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	12					; 0000000cH
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector@3
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@3:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector@3:
	mov	DWORD PTR [esi], OFFSET ??_7_ns2__getSessionIDResponseElement@@6B@
	test	bl, 1
	je	SHORT $LN1@vector@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@3:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_E_ns2__getSessionIDResponseElement@@UAEPAXI@Z ENDP	; _ns2__getSessionIDResponseElement::`vector deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
_TEXT	SEGMENT
_soap$ = 8						; size = 4
?soap_default@_ns2__getSessionIDResponseElement@@UAEXPAUsoap@@@Z PROC ; _ns2__getSessionIDResponseElement::soap_default
; _this$ = ecx

; 1599 : 	this->soap = soap;

	mov	eax, DWORD PTR _soap$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 1600 : 	soap_default_int(soap, &this->_ns2__getSessionIDResponseElement::result);

	mov	DWORD PTR [ecx+4], 0

; 1601 : 	/* transient soap skipped */
; 1602 : }

	ret	4
?soap_default@_ns2__getSessionIDResponseElement@@UAEXPAUsoap@@@Z ENDP ; _ns2__getSessionIDResponseElement::soap_default
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_E_ns2__getSettingsFileElement@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_E_ns2__getSettingsFileElement@@UAEPAXI@Z PROC	; _ns2__getSettingsFileElement::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector@4
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1_ns2__getSettingsFileElement@@UAE@XZ ; _ns2__getSettingsFileElement::~_ns2__getSettingsFileElement
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	12					; 0000000cH
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector@4
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@4:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector@4:
	mov	DWORD PTR [esi], OFFSET ??_7_ns2__getSettingsFileElement@@6B@
	test	bl, 1
	je	SHORT $LN1@vector@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@4:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_E_ns2__getSettingsFileElement@@UAEPAXI@Z ENDP	; _ns2__getSettingsFileElement::`vector deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
_TEXT	SEGMENT
_soap$ = 8						; size = 4
?soap_default@_ns2__getSettingsFileElement@@UAEXPAUsoap@@@Z PROC ; _ns2__getSettingsFileElement::soap_default
; _this$ = ecx

; 1458 : 	this->soap = soap;

	mov	eax, DWORD PTR _soap$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 1459 : 	soap_default_int(soap, &this->_ns2__getSettingsFileElement::int_USCORE1);

	mov	DWORD PTR [ecx+4], 0

; 1460 : 	/* transient soap skipped */
; 1461 : }

	ret	4
?soap_default@_ns2__getSettingsFileElement@@UAEXPAUsoap@@@Z ENDP ; _ns2__getSettingsFileElement::soap_default
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_E_ns2__getSettingsFileResponseElement@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_E_ns2__getSettingsFileResponseElement@@UAEPAXI@Z PROC ; _ns2__getSettingsFileResponseElement::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector@5
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1_ns2__getSettingsFileResponseElement@@UAE@XZ ; _ns2__getSettingsFileResponseElement::~_ns2__getSettingsFileResponseElement
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	12					; 0000000cH
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector@5
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@5:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector@5:
	mov	DWORD PTR [esi], OFFSET ??_7_ns2__getSettingsFileResponseElement@@6B@
	test	bl, 1
	je	SHORT $LN1@vector@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@5:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_E_ns2__getSettingsFileResponseElement@@UAEPAXI@Z ENDP ; _ns2__getSettingsFileResponseElement::`vector deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
_TEXT	SEGMENT
_soap$ = 8						; size = 4
?soap_serialize@_ns2__getSettingsFileResponseElement@@UBEXPAUsoap@@@Z PROC ; _ns2__getSettingsFileResponseElement::soap_serialize
; _this$ = ecx

; 1324 : 	(void)soap; /* appease -Wall -Werror */
; 1325 : 	soap_serialize_PointerTostd__string(soap, &this->_ns2__getSettingsFileResponseElement::result);

	mov	eax, DWORD PTR _soap$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	push	eax
	mov	eax, 18					; 00000012H
	call	_soap_reference
	pop	ecx

; 1326 : 	/* transient soap skipped */
; 1327 : }

	ret	4
?soap_serialize@_ns2__getSettingsFileResponseElement@@UBEXPAUsoap@@@Z ENDP ; _ns2__getSettingsFileResponseElement::soap_serialize
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
?soap_serialize@_ns2__submitEpochResultElement@@UBEXPAUsoap@@@Z PROC ; _ns2__submitEpochResultElement::soap_serialize
; _this$ = ecx

; 1134 : 	(void)soap; /* appease -Wall -Werror */
; 1135 : 	soap_serialize_PointerTostd__string(soap, &this->_ns2__submitEpochResultElement::sessionID);

	mov	eax, DWORD PTR _soap$[esp-4]
	mov	ecx, DWORD PTR [ecx+8]
	push	eax
	mov	eax, 18					; 00000012H
	call	_soap_reference
	pop	ecx

; 1136 : 	soap_serialize_std__vectorTemplateOfint(soap, &this->_ns2__submitEpochResultElement::channel);
; 1137 : 	soap_serialize_std__vectorTemplateOfint(soap, &this->_ns2__submitEpochResultElement::rank);
; 1138 : 	soap_serialize_std__vectorTemplateOffloat(soap, &this->_ns2__submitEpochResultElement::PsysACTSTBY);
; 1139 : 	soap_serialize_std__vectorTemplateOffloat(soap, &this->_ns2__submitEpochResultElement::PsysACT);
; 1140 : 	/* transient soap skipped */
; 1141 : }

	ret	4
?soap_serialize@_ns2__submitEpochResultElement@@UBEXPAUsoap@@@Z ENDP ; _ns2__submitEpochResultElement::soap_serialize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_E_ns2__submitEpochResultResponseElement@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_E_ns2__submitEpochResultResponseElement@@UAEPAXI@Z PROC ; _ns2__submitEpochResultResponseElement::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector@6
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1_ns2__submitEpochResultResponseElement@@UAE@XZ ; _ns2__submitEpochResultResponseElement::~_ns2__submitEpochResultResponseElement
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	12					; 0000000cH
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector@6
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@6:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector@6:
	mov	DWORD PTR [esi], OFFSET ??_7_ns2__submitEpochResultResponseElement@@6B@
	test	bl, 1
	je	SHORT $LN1@vector@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@6:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_E_ns2__submitEpochResultResponseElement@@UAEPAXI@Z ENDP ; _ns2__submitEpochResultResponseElement::`vector deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
_TEXT	SEGMENT
_soap$ = 8						; size = 4
?soap_default@_ns2__submitEpochResultResponseElement@@UAEXPAUsoap@@@Z PROC ; _ns2__submitEpochResultResponseElement::soap_default
; _this$ = ecx

; 977  : 	this->soap = soap;

	mov	eax, DWORD PTR _soap$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 978  : 	soap_default_bool(soap, &this->_ns2__submitEpochResultResponseElement::result);

	mov	BYTE PTR [ecx+4], 0

; 979  : 	/* transient soap skipped */
; 980  : }

	ret	4
?soap_default@_ns2__submitEpochResultResponseElement@@UAEXPAUsoap@@@Z ENDP ; _ns2__submitEpochResultResponseElement::soap_default
_TEXT	ENDS
PUBLIC	?soap_container_insert@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_container_insert
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_st$ = 12						; size = 4
_tt$ = 16						; size = 4
_p$ = 20						; size = 4
_len$ = 24						; size = 4
_q$ = 28						; size = 4
_n$ = 32						; size = 4
?soap_container_insert@@YAXPAUsoap@@HHPAXIPBXI@Z PROC	; soap_container_insert

; 736  : {	switch (tt)

	mov	eax, DWORD PTR _tt$[esp-4]
	sub	eax, 26					; 0000001aH
	push	esi
	push	edi
	je	SHORT $LN2@soap_conta
	sub	eax, 1
	jne	SHORT $LN1@soap_conta

; 737  : 	{
; 738  : 	case SOAP_TYPE_std__vectorTemplateOffloat:
; 739  : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
; 740  : 		(*(std::vector<float >*)p)[len] = *(float *)q;

	mov	esi, DWORD PTR _p$[esp+4]
	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR _len$[esp+4]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN8@soap_conta
	call	__invalid_parameter_noinfo
$LN8@soap_conta:
	mov	edx, DWORD PTR _q$[esp+4]
	mov	ecx, DWORD PTR [esi+12]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [ecx+edi*4]
	pop	edi
	pop	esi

; 745  : 		break;
; 746  : 	default:
; 747  : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
; 748  : 	}
; 749  : #ifdef WIN32
; 750  : #pragma warning(pop)
; 751  : #endif
; 752  : }

	ret	0
$LN2@soap_conta:

; 741  : 		break;
; 742  : 	case SOAP_TYPE_std__vectorTemplateOfint:
; 743  : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
; 744  : 		(*(std::vector<int >*)p)[len] = *(int *)q;

	mov	esi, DWORD PTR _p$[esp+4]
	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR _len$[esp+4]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN13@soap_conta
	call	__invalid_parameter_noinfo
$LN13@soap_conta:
	mov	edx, DWORD PTR _q$[esp+4]
	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+edi*4], eax
$LN1@soap_conta:
	pop	edi
	pop	esi

; 745  : 		break;
; 746  : 	default:
; 747  : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
; 748  : 	}
; 749  : #ifdef WIN32
; 750  : #pragma warning(pop)
; 751  : #endif
; 752  : }

	ret	0
?soap_container_insert@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP	; soap_container_insert
_TEXT	ENDS
PUBLIC	_soap_markelement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_markelement PROC
; _ptr$ = ecx
; _type$ = eax

; 427  : 	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
; 428  : 	switch (type)

	add	eax, -4					; fffffffcH
	push	edi
	mov	edi, DWORD PTR _soap$[esp]
	cmp	eax, 35					; 00000023H
	ja	$LN26@soap_marke
	push	esi
	jmp	DWORD PTR $LN43@soap_marke[eax*4]
$LN25@soap_marke:

; 429  : 	{
; 430  : 	case SOAP_TYPE__ns2__submitEpochResultResponseElement:
; 431  : 		((_ns2__submitEpochResultResponseElement *)ptr)->soap_serialize(soap);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	edi
	call	edx
	pop	esi
	pop	edi

; 504  : 		break;
; 505  : 	}
; 506  : }

	ret	0
$LN12@soap_marke:

; 432  : 		break;
; 433  : 	case SOAP_TYPE__ns2__submitEpochResultElement:
; 434  : 		((_ns2__submitEpochResultElement *)ptr)->soap_serialize(soap);
; 435  : 		break;
; 436  : 	case SOAP_TYPE__ns2__getSettingsFileResponseElement:
; 437  : 		((_ns2__getSettingsFileResponseElement *)ptr)->soap_serialize(soap);
; 438  : 		break;
; 439  : 	case SOAP_TYPE__ns2__getSettingsFileElement:
; 440  : 		((_ns2__getSettingsFileElement *)ptr)->soap_serialize(soap);
; 441  : 		break;
; 442  : 	case SOAP_TYPE__ns2__getSessionIDResponseElement:
; 443  : 		((_ns2__getSessionIDResponseElement *)ptr)->soap_serialize(soap);
; 444  : 		break;
; 445  : 	case SOAP_TYPE__ns2__getSessionIDElement:
; 446  : 		((_ns2__getSessionIDElement *)ptr)->soap_serialize(soap);
; 447  : 		break;
; 448  : 	case SOAP_TYPE_std__string:
; 449  : 		soap_serialize_std__string(soap, (const std::string *)ptr);
; 450  : 		break;
; 451  : 	case SOAP_TYPE_xsd__string:
; 452  : 		((xsd__string *)ptr)->soap_serialize(soap);
; 453  : 		break;
; 454  : 	case SOAP_TYPE_xsd__long:
; 455  : 		((xsd__long *)ptr)->soap_serialize(soap);
; 456  : 		break;
; 457  : 	case SOAP_TYPE_xsd__int:
; 458  : 		((xsd__int *)ptr)->soap_serialize(soap);
; 459  : 		break;
; 460  : 	case SOAP_TYPE_xsd__float:
; 461  : 		((xsd__float *)ptr)->soap_serialize(soap);
; 462  : 		break;
; 463  : 	case SOAP_TYPE_xsd__boolean:
; 464  : 		((xsd__boolean *)ptr)->soap_serialize(soap);
; 465  : 		break;
; 466  : 	case SOAP_TYPE_xsd__anyType:
; 467  : 		((xsd__anyType *)ptr)->soap_serialize(soap);
; 468  : 		break;
; 469  : 	case SOAP_TYPE___ns1__submitEpochResult:
; 470  : 		soap_serialize___ns1__submitEpochResult(soap, (const struct __ns1__submitEpochResult *)ptr);

	mov	esi, ecx
	call	?soap_serialize___ns1__submitEpochResult@@YAXPAUsoap@@PBU__ns1__submitEpochResult@@@Z ; soap_serialize___ns1__submitEpochResult
	pop	esi
	pop	edi

; 504  : 		break;
; 505  : 	}
; 506  : }

	ret	0
$LN11@soap_marke:

; 471  : 		break;
; 472  : 	case SOAP_TYPE___ns1__getSettingsFile:
; 473  : 		soap_serialize___ns1__getSettingsFile(soap, (const struct __ns1__getSettingsFile *)ptr);

	mov	esi, ecx
	call	?soap_serialize___ns1__getSettingsFile@@YAXPAUsoap@@PBU__ns1__getSettingsFile@@@Z ; soap_serialize___ns1__getSettingsFile
	pop	esi
	pop	edi

; 504  : 		break;
; 505  : 	}
; 506  : }

	ret	0
$LN10@soap_marke:

; 474  : 		break;
; 475  : 	case SOAP_TYPE___ns1__getSessionID:
; 476  : 		soap_serialize___ns1__getSessionID(soap, (const struct __ns1__getSessionID *)ptr);

	mov	esi, ecx
	call	?soap_serialize___ns1__getSessionID@@YAXPAUsoap@@PBU__ns1__getSessionID@@@Z ; soap_serialize___ns1__getSessionID
	pop	esi
	pop	edi

; 504  : 		break;
; 505  : 	}
; 506  : }

	ret	0
$LN9@soap_marke:

; 477  : 		break;
; 478  : 	case SOAP_TYPE_PointerTo_ns2__submitEpochResultResponseElement:
; 479  : 		soap_serialize_PointerTo_ns2__submitEpochResultResponseElement(soap, (_ns2__submitEpochResultResponseElement *const*)ptr);

	mov	esi, ecx
	call	?soap_serialize_PointerTo_ns2__submitEpochResultResponseElement@@YAXPAUsoap@@PBQAV_ns2__submitEpochResultResponseElement@@@Z ; soap_serialize_PointerTo_ns2__submitEpochResultResponseElement
	pop	esi
	pop	edi

; 504  : 		break;
; 505  : 	}
; 506  : }

	ret	0
$LN8@soap_marke:

; 480  : 		break;
; 481  : 	case SOAP_TYPE_PointerTo_ns2__submitEpochResultElement:
; 482  : 		soap_serialize_PointerTo_ns2__submitEpochResultElement(soap, (_ns2__submitEpochResultElement *const*)ptr);

	mov	esi, ecx
	call	?soap_serialize_PointerTo_ns2__submitEpochResultElement@@YAXPAUsoap@@PBQAV_ns2__submitEpochResultElement@@@Z ; soap_serialize_PointerTo_ns2__submitEpochResultElement
	pop	esi
	pop	edi

; 504  : 		break;
; 505  : 	}
; 506  : }

	ret	0
$LN7@soap_marke:

; 483  : 		break;
; 484  : 	case SOAP_TYPE_PointerTo_ns2__getSettingsFileResponseElement:
; 485  : 		soap_serialize_PointerTo_ns2__getSettingsFileResponseElement(soap, (_ns2__getSettingsFileResponseElement *const*)ptr);

	mov	esi, ecx
	call	?soap_serialize_PointerTo_ns2__getSettingsFileResponseElement@@YAXPAUsoap@@PBQAV_ns2__getSettingsFileResponseElement@@@Z ; soap_serialize_PointerTo_ns2__getSettingsFileResponseElement
	pop	esi
	pop	edi

; 504  : 		break;
; 505  : 	}
; 506  : }

	ret	0
$LN6@soap_marke:

; 486  : 		break;
; 487  : 	case SOAP_TYPE_PointerTo_ns2__getSettingsFileElement:
; 488  : 		soap_serialize_PointerTo_ns2__getSettingsFileElement(soap, (_ns2__getSettingsFileElement *const*)ptr);

	mov	esi, ecx
	call	?soap_serialize_PointerTo_ns2__getSettingsFileElement@@YAXPAUsoap@@PBQAV_ns2__getSettingsFileElement@@@Z ; soap_serialize_PointerTo_ns2__getSettingsFileElement
	pop	esi
	pop	edi

; 504  : 		break;
; 505  : 	}
; 506  : }

	ret	0
$LN5@soap_marke:

; 489  : 		break;
; 490  : 	case SOAP_TYPE_PointerTo_ns2__getSessionIDResponseElement:
; 491  : 		soap_serialize_PointerTo_ns2__getSessionIDResponseElement(soap, (_ns2__getSessionIDResponseElement *const*)ptr);

	mov	esi, ecx
	call	?soap_serialize_PointerTo_ns2__getSessionIDResponseElement@@YAXPAUsoap@@PBQAV_ns2__getSessionIDResponseElement@@@Z ; soap_serialize_PointerTo_ns2__getSessionIDResponseElement
	pop	esi
	pop	edi

; 504  : 		break;
; 505  : 	}
; 506  : }

	ret	0
$LN4@soap_marke:

; 492  : 		break;
; 493  : 	case SOAP_TYPE_PointerTo_ns2__getSessionIDElement:
; 494  : 		soap_serialize_PointerTo_ns2__getSessionIDElement(soap, (_ns2__getSessionIDElement *const*)ptr);

	mov	esi, ecx
	call	?soap_serialize_PointerTo_ns2__getSessionIDElement@@YAXPAUsoap@@PBQAV_ns2__getSessionIDElement@@@Z ; soap_serialize_PointerTo_ns2__getSessionIDElement
	pop	esi
	pop	edi

; 504  : 		break;
; 505  : 	}
; 506  : }

	ret	0
$LN3@soap_marke:

; 495  : 		break;
; 496  : 	case SOAP_TYPE_PointerTostd__string:
; 497  : 		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, 18					; 00000012H

; 498  : 		break;
; 499  : 	case SOAP_TYPE__QName:
; 500  : 		soap_serialize_string(soap, (char*const*)&ptr);
; 501  : 		break;
; 502  : 	case SOAP_TYPE_string:
; 503  : 		soap_serialize_string(soap, (char*const*)&ptr);

	push	edi
	call	_soap_reference
	add	esp, 4
	pop	esi
	pop	edi

; 504  : 		break;
; 505  : 	}
; 506  : }

	ret	0
$LN1@soap_marke:

; 498  : 		break;
; 499  : 	case SOAP_TYPE__QName:
; 500  : 		soap_serialize_string(soap, (char*const*)&ptr);
; 501  : 		break;
; 502  : 	case SOAP_TYPE_string:
; 503  : 		soap_serialize_string(soap, (char*const*)&ptr);

	mov	eax, 4
	push	edi
	call	_soap_reference
	add	esp, 4
$LN41@soap_marke:
	pop	esi
$LN26@soap_marke:
	pop	edi

; 504  : 		break;
; 505  : 	}
; 506  : }

	ret	0
	npad	2
$LN43@soap_marke:
	DD	$LN1@soap_marke
	DD	$LN1@soap_marke
	DD	$LN41@soap_marke
	DD	$LN41@soap_marke
	DD	$LN25@soap_marke
	DD	$LN41@soap_marke
	DD	$LN25@soap_marke
	DD	$LN41@soap_marke
	DD	$LN25@soap_marke
	DD	$LN41@soap_marke
	DD	$LN25@soap_marke
	DD	$LN25@soap_marke
	DD	$LN41@soap_marke
	DD	$LN25@soap_marke
	DD	$LN41@soap_marke
	DD	$LN25@soap_marke
	DD	$LN25@soap_marke
	DD	$LN25@soap_marke
	DD	$LN25@soap_marke
	DD	$LN25@soap_marke
	DD	$LN25@soap_marke
	DD	$LN3@soap_marke
	DD	$LN41@soap_marke
	DD	$LN41@soap_marke
	DD	$LN4@soap_marke
	DD	$LN5@soap_marke
	DD	$LN41@soap_marke
	DD	$LN10@soap_marke
	DD	$LN6@soap_marke
	DD	$LN7@soap_marke
	DD	$LN41@soap_marke
	DD	$LN11@soap_marke
	DD	$LN8@soap_marke
	DD	$LN9@soap_marke
	DD	$LN41@soap_marke
	DD	$LN12@soap_marke
_soap_markelement ENDP
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapstub.h
_TEXT	ENDS
;	COMDAT ??1xsd__long@@UAE@XZ
_TEXT	SEGMENT
??1xsd__long@@UAE@XZ PROC				; xsd__long::~xsd__long, COMDAT
; _this$ = ecx

; 128  : 	virtual ~xsd__long() { }

	mov	DWORD PTR [ecx], OFFSET ??_7xsd__anyType@@6B@
	ret	0
??1xsd__long@@UAE@XZ ENDP				; xsd__long::~xsd__long
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0xsd__long@@QAE@XZ
_TEXT	SEGMENT
??0xsd__long@@QAE@XZ PROC				; xsd__long::xsd__long, COMDAT
; _this$ = ecx

; 127  : 	xsd__long() : __item(0) { }

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], OFFSET ??_7xsd__long@@6B@
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	ret	0
??0xsd__long@@QAE@XZ ENDP				; xsd__long::xsd__long
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1xsd__int@@UAE@XZ
_TEXT	SEGMENT
??1xsd__int@@UAE@XZ PROC				; xsd__int::~xsd__int, COMDAT
; _this$ = ecx

; 108  : 	virtual ~xsd__int() { }

	mov	DWORD PTR [ecx], OFFSET ??_7xsd__anyType@@6B@
	ret	0
??1xsd__int@@UAE@XZ ENDP				; xsd__int::~xsd__int
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0xsd__int@@QAE@XZ
_TEXT	SEGMENT
??0xsd__int@@QAE@XZ PROC				; xsd__int::xsd__int, COMDAT
; _this$ = ecx

; 107  : 	xsd__int() : __item(0) { }

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], OFFSET ??_7xsd__int@@6B@
	mov	DWORD PTR [eax+12], ecx
	ret	0
??0xsd__int@@QAE@XZ ENDP				; xsd__int::xsd__int
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1xsd__float@@UAE@XZ
_TEXT	SEGMENT
??1xsd__float@@UAE@XZ PROC				; xsd__float::~xsd__float, COMDAT
; _this$ = ecx

; 88   : 	virtual ~xsd__float() { }

	mov	DWORD PTR [ecx], OFFSET ??_7xsd__anyType@@6B@
	ret	0
??1xsd__float@@UAE@XZ ENDP				; xsd__float::~xsd__float
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0xsd__float@@QAE@XZ
_TEXT	SEGMENT
??0xsd__float@@QAE@XZ PROC				; xsd__float::xsd__float, COMDAT
; _this$ = ecx

; 87   : 	xsd__float() : __item(0) { }

	xorps	xmm0, xmm0
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], OFFSET ??_7xsd__float@@6B@
	movss	DWORD PTR [eax+12], xmm0
	ret	0
??0xsd__float@@QAE@XZ ENDP				; xsd__float::xsd__float
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1xsd__boolean@@UAE@XZ
_TEXT	SEGMENT
??1xsd__boolean@@UAE@XZ PROC				; xsd__boolean::~xsd__boolean, COMDAT
; _this$ = ecx

; 68   : 	virtual ~xsd__boolean() { }

	mov	DWORD PTR [ecx], OFFSET ??_7xsd__anyType@@6B@
	ret	0
??1xsd__boolean@@UAE@XZ ENDP				; xsd__boolean::~xsd__boolean
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0xsd__boolean@@QAE@XZ
_TEXT	SEGMENT
??0xsd__boolean@@QAE@XZ PROC				; xsd__boolean::xsd__boolean, COMDAT
; _this$ = ecx

; 67   : 	xsd__boolean() : __item((bool)0) { }

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], OFFSET ??_7xsd__boolean@@6B@
	mov	BYTE PTR [eax+12], cl
	ret	0
??0xsd__boolean@@QAE@XZ ENDP				; xsd__boolean::xsd__boolean
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAMPAMV?$allocator@M@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAMPAMV?$allocator@M@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<float *,float *,std::allocator<float>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Uninit_mov@6
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Uninit_mov@6:
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAMPAMV?$allocator@M@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<float *,float *,std::allocator<float>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<float *,float *,std::allocator<float> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN30@Unchecked_@15
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN30@Unchecked_@15:
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<float *,float *,std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z
_TEXT	SEGMENT
??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z PROC ; std::vector<float,std::allocator<float> >::_Umove<float *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN32@Umove@8
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@Umove@8:
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	0
??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ENDP ; std::vector<float,std::allocator<float> >::_Umove<float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<float,std::allocator<float> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN20@operator@145
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@operator@145
$LN20@operator@145:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@145
$LN10@operator@145:
	xor	edx, edx
$LN11@operator@145:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@145
	test	eax, eax
	je	SHORT $LN16@operator@145
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@145
$LN16@operator@145:
	xor	eax, eax
$LN17@operator@145:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@145
$LN1@operator@145:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@145:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [esi+4], edi

; 165  : 		return (*this);

	mov	eax, esi
	pop	edi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<float,std::allocator<float> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<float,std::allocator<float> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN22@operator@146
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN12@operator@146
$LN22@operator@146:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN13@operator@146
$LN12@operator@146:
	xor	edx, edx
$LN13@operator@146:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN3@operator@146
	test	eax, eax
	je	SHORT $LN18@operator@146
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@146
$LN18@operator@146:
	xor	eax, eax
$LN19@operator@146:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN23@operator@146
$LN3@operator@146:
	call	__invalid_parameter_noinfo
$LN23@operator@146:
	add	DWORD PTR [esi+4], edi

; 376  : 		return (*this);

	mov	eax, esi
	pop	edi

; 377  : 		}

	ret	4
??Y?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<float,std::allocator<float> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@MV?$allocator@M@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@MV?$allocator@M@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<float,std::allocator<float> >::operator+, COMDAT
; _this$ = eax

; 380  : 		{	// return this + integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 381  : 		_Myt _Tmp = *this;

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN24@operator@147
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN15@operator@147:
	mov	ecx, DWORD PTR __Off$[esp+8]
	lea	edi, DWORD PTR [edi+ecx*4]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN5@operator@147
	test	esi, esi
	je	SHORT $LN20@operator@147
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN21@operator@147
$LN24@operator@147:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN15@operator@147
$LN20@operator@147:
	xor	eax, eax
$LN21@operator@147:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN6@operator@147
$LN5@operator@147:
	call	__invalid_parameter_noinfo
$LN6@operator@147:
	mov	DWORD PTR [ebx+4], edi

; 383  : 		}

	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	mov	eax, ebx
	pop	ebx
	ret	8
??H?$_Vector_iterator@MV?$allocator@M@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<float,std::allocator<float> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@148
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@148
$LN13@operator@148:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@148
$LN9@operator@148:
	xor	eax, eax
$LN10@operator@148:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@148
	call	__invalid_parameter_noinfo
$LN14@operator@148:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 4

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@149
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@149
$LN13@operator@149:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@149
$LN9@operator@149:
	xor	eax, eax
$LN10@operator@149:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@149
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN14@operator@149:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<float,std::allocator<float> >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@150
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@150
$LN13@operator@150:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@150
$LN9@operator@150:
	xor	eax, eax
$LN10@operator@150:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@150
	call	__invalid_parameter_noinfo
$LN14@operator@150:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 4

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<float,std::allocator<float> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBEABMXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBEABMXZ PROC ; std::_Vector_const_iterator<float,std::allocator<float> >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@151
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@151
$LN13@operator@151:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@151
$LN9@operator@151:
	xor	eax, eax
$LN10@operator@151:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@151
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN14@operator@151:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBEABMXZ ENDP ; std::_Vector_const_iterator<float,std::allocator<float> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@XZ PROC ; std::vector<float,std::allocator<float> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@27
	call	__invalid_parameter_noinfo
$LN4@end@27:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@XZ ENDP ; std::vector<float,std::allocator<float> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@XZ PROC ; std::vector<float,std::allocator<float> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@30
	call	__invalid_parameter_noinfo
$LN4@begin@30:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@XZ ENDP ; std::vector<float,std::allocator<float> >::begin
_TEXT	ENDS
PUBLIC	?soap_default_std__vectorTemplateOffloat@@YAXPAUsoap@@PAV?$vector@MV?$allocator@M@std@@@std@@@Z ; soap_default_std__vectorTemplateOffloat
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapc.cpp
_TEXT	SEGMENT
$T367061 = -8						; size = 4
$T367147 = -8						; size = 8
?soap_default_std__vectorTemplateOffloat@@YAXPAUsoap@@PAV?$vector@MV?$allocator@M@std@@@std@@@Z PROC ; soap_default_std__vectorTemplateOffloat
; _p$ = eax

; 4326 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, eax

; 4327 : 	p->clear();

	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	DWORD PTR $T367061[esp+24], eax
	cmp	DWORD PTR [esi+12], eax
	jbe	SHORT $LN10@soap_defau
	call	__invalid_parameter_noinfo
$LN10@soap_defau:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN26@soap_defau
	call	__invalid_parameter_noinfo
$LN26@soap_defau:
	mov	ecx, DWORD PTR $T367061[esp+24]
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	ebx
	push	edi
	push	eax
	lea	edx, DWORD PTR $T367147[esp+40]
	push	edx
	call	?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z ; std::vector<float,std::allocator<float> >::erase

; 4328 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?soap_default_std__vectorTemplateOffloat@@YAXPAUsoap@@PAV?$vector@MV?$allocator@M@std@@@std@@@Z ENDP ; soap_default_std__vectorTemplateOffloat
_TEXT	ENDS
PUBLIC	?soap_serialize_PointerToSOAP_ENV__Code@@YAXPAUsoap@@PBQAUSOAP_ENV__Code@@@Z ; soap_serialize_PointerToSOAP_ENV__Code
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_PointerToSOAP_ENV__Code@@YAXPAUsoap@@PBQAUSOAP_ENV__Code@@@Z PROC ; soap_serialize_PointerToSOAP_ENV__Code
; _soap$ = eax
; _a$ = esi

; 3819 : 	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	edi, eax
	push	edi
	mov	eax, 41					; 00000029H
	call	_soap_reference
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_seria@11

; 3820 : 		soap_serialize_SOAP_ENV__Code(soap, *a);

	mov	eax, DWORD PTR [esi]
	call	?soap_serialize_SOAP_ENV__Code@@YAXPAUsoap@@PBUSOAP_ENV__Code@@@Z ; soap_serialize_SOAP_ENV__Code
$LN1@soap_seria@11:
	pop	edi

; 3821 : }

	ret	0
?soap_serialize_PointerToSOAP_ENV__Code@@YAXPAUsoap@@PBQAUSOAP_ENV__Code@@@Z ENDP ; soap_serialize_PointerToSOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_serialize_PointerToSOAP_ENV__Reason@@YAXPAUsoap@@PBQAUSOAP_ENV__Reason@@@Z ; soap_serialize_PointerToSOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_PointerToSOAP_ENV__Reason@@YAXPAUsoap@@PBQAUSOAP_ENV__Reason@@@Z PROC ; soap_serialize_PointerToSOAP_ENV__Reason
; _soap$ = edi
; _a$ = esi

; 3709 : 	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	eax, 46					; 0000002eH
	call	_soap_reference
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@soap_seria@12

; 3710 : 		soap_serialize_SOAP_ENV__Reason(soap, *a);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx]
	push	edi
	mov	eax, 4
	call	_soap_reference
	pop	ecx
$LN6@soap_seria@12:

; 3711 : }

	ret	0
?soap_serialize_PointerToSOAP_ENV__Reason@@YAXPAUsoap@@PBQAUSOAP_ENV__Reason@@@Z ENDP ; soap_serialize_PointerToSOAP_ENV__Reason
_TEXT	ENDS
PUBLIC	?soap_serialize_SOAP_ENV__Detail@@YAXPAUsoap@@PBUSOAP_ENV__Detail@@@Z ; soap_serialize_SOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_SOAP_ENV__Detail@@YAXPAUsoap@@PBUSOAP_ENV__Detail@@@Z PROC ; soap_serialize_SOAP_ENV__Detail
; _soap$ = eax
; _a$ = ecx

; 3065 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 3066 : 	soap_markelement(soap, a->fault, a->__type);

	push	eax
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	call	_soap_markelement
	pop	ecx

; 3067 : }

	ret	0
?soap_serialize_SOAP_ENV__Detail@@YAXPAUsoap@@PBUSOAP_ENV__Detail@@@Z ENDP ; soap_serialize_SOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Exsd__boolean@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Exsd__boolean@@UAEPAXI@Z PROC			; xsd__boolean::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector@25
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1xsd__boolean@@UAE@XZ		; xsd__boolean::~xsd__boolean
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	16					; 00000010H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector@25
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@25:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector@25:
	mov	DWORD PTR [esi], OFFSET ??_7xsd__anyType@@6B@
	test	bl, 1
	je	SHORT $LN1@vector@25
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@25:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_Exsd__boolean@@UAEPAXI@Z ENDP			; xsd__boolean::`vector deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Exsd__float@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Exsd__float@@UAEPAXI@Z PROC				; xsd__float::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector@26
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1xsd__float@@UAE@XZ		; xsd__float::~xsd__float
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	16					; 00000010H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector@26
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@26:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector@26:
	mov	DWORD PTR [esi], OFFSET ??_7xsd__anyType@@6B@
	test	bl, 1
	je	SHORT $LN1@vector@26
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@26:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_Exsd__float@@UAEPAXI@Z ENDP				; xsd__float::`vector deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Exsd__int@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Exsd__int@@UAEPAXI@Z PROC				; xsd__int::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector@27
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1xsd__int@@UAE@XZ		; xsd__int::~xsd__int
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	16					; 00000010H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector@27
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@27:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector@27:
	mov	DWORD PTR [esi], OFFSET ??_7xsd__anyType@@6B@
	test	bl, 1
	je	SHORT $LN1@vector@27
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@27:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_Exsd__int@@UAEPAXI@Z ENDP				; xsd__int::`vector deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Exsd__long@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Exsd__long@@UAEPAXI@Z PROC				; xsd__long::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector@28
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1xsd__long@@UAE@XZ		; xsd__long::~xsd__long
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	24					; 00000018H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector@28
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@28:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector@28:
	mov	DWORD PTR [esi], OFFSET ??_7xsd__anyType@@6B@
	test	bl, 1
	je	SHORT $LN1@vector@28
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@28:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_Exsd__long@@UAEPAXI@Z ENDP				; xsd__long::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?soap_default_std__string@@YAXPAUsoap@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; soap_default_std__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_default_std__string@@YAXPAUsoap@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; soap_default_std__string
; _p$ = ecx

; 1880 : 	p->erase();

	push	-1
	push	0
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1881 : }

	ret	0
?soap_default_std__string@@YAXPAUsoap@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; soap_default_std__string
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_E_ns2__submitEpochResultElement@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_E_ns2__submitEpochResultElement@@UAEPAXI@Z PROC	; _ns2__submitEpochResultElement::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector@29
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1_ns2__submitEpochResultElement@@UAE@XZ ; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	136					; 00000088H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector@29
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@29:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector@29:
	call	??1_ns2__submitEpochResultElement@@UAE@XZ ; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement
	test	bl, 1
	je	SHORT $LN1@vector@29
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@29:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_E_ns2__submitEpochResultElement@@UAEPAXI@Z ENDP	; _ns2__submitEpochResultElement::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?soap_container_id_forward@@YAPAXPAUsoap@@PBDPAXIHHII@Z ; soap_container_id_forward
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_href$ = 12						; size = 4
_p$ = 16						; size = 4
_len$ = 20						; size = 4
?soap_container_id_forward@@YAPAXPAUsoap@@PBDPAXIHHII@Z PROC ; soap_container_id_forward
; _st$ = ecx
; _tt$ = eax

; 728  : {	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);

	mov	edx, DWORD PTR _len$[esp-4]
	push	OFFSET ?soap_container_insert@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_container_insert
	push	4
	push	eax
	mov	eax, DWORD PTR _p$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR _soap$[esp+12]
	push	edx
	push	eax
	mov	eax, DWORD PTR _href$[esp+20]
	push	ecx
	call	_soap_id_forward
	add	esp, 28					; 0000001cH

; 729  : }

	ret	0
?soap_container_id_forward@@YAPAXPAUsoap@@PBDPAXIHHII@Z ENDP ; soap_container_id_forward
_TEXT	ENDS
PUBLIC	??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ; std::vector<int,std::allocator<int> >::`vector deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z PROC	; std::vector<int,std::allocator<int> >::`vector deleting destructor', COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax-4]
	push	esi
	lea	esi, DWORD PTR [eax-4]
	push	OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
	push	ecx
	push	24					; 00000018H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, esi
	pop	esi
	ret	0
??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ENDP	; std::vector<int,std::allocator<int> >::`vector deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z PROC	; std::vector<int,std::allocator<int> >::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN9@scalar@25
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@scalar@25:
	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 8
	mov	eax, esi
	ret	0
??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ENDP	; std::vector<int,std::allocator<int> >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_E?$vector@MV?$allocator@M@std@@@std@@QAEPAXI@Z ; std::vector<float,std::allocator<float> >::`vector deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_E?$vector@MV?$allocator@M@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
??_E?$vector@MV?$allocator@M@std@@@std@@QAEPAXI@Z PROC	; std::vector<float,std::allocator<float> >::`vector deleting destructor', COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax-4]
	push	esi
	lea	esi, DWORD PTR [eax-4]
	push	OFFSET ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
	push	ecx
	push	24					; 00000018H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, esi
	pop	esi
	ret	0
??_E?$vector@MV?$allocator@M@std@@@std@@QAEPAXI@Z ENDP	; std::vector<float,std::allocator<float> >::`vector deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$vector@MV?$allocator@M@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
??_G?$vector@MV?$allocator@M@std@@@std@@QAEPAXI@Z PROC	; std::vector<float,std::allocator<float> >::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN9@scalar@26
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@scalar@26:
	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 8
	mov	eax, esi
	ret	0
??_G?$vector@MV?$allocator@M@std@@@std@@QAEPAXI@Z ENDP	; std::vector<float,std::allocator<float> >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_E?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_E?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor', COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax-4]
	push	esi
	lea	esi, DWORD PTR [eax-4]
	push	OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	ecx
	push	28					; 0000001cH
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, esi
	pop	esi
	ret	0
??_E?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapstub.h
_TEXT	ENDS
;	COMDAT ??1xsd__string@@UAE@XZ
_TEXT	SEGMENT
??1xsd__string@@UAE@XZ PROC				; xsd__string::~xsd__string, COMDAT
; _this$ = ecx

; 152  : 	virtual ~xsd__string() { }

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7xsd__string@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN19@xsd__strin
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@xsd__strin:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	DWORD PTR [esi], OFFSET ??_7xsd__anyType@@6B@
	pop	esi
	ret	0
??1xsd__string@@UAE@XZ ENDP				; xsd__string::~xsd__string
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0xsd__string@@QAE@XZ
_TEXT	SEGMENT
??0xsd__string@@QAE@XZ PROC				; xsd__string::xsd__string, COMDAT
; _this$ = ecx

; 151  : 	xsd__string()  { }

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], OFFSET ??_7xsd__string@@6B@
	mov	DWORD PTR [eax+36], 15			; 0000000fH
	mov	DWORD PTR [eax+32], ecx
	mov	BYTE PTR [eax+16], cl
	ret	0
??0xsd__string@@QAE@XZ ENDP				; xsd__string::xsd__string
PUBLIC	?soap_serialize_PointerToSOAP_ENV__Detail@@YAXPAUsoap@@PBQAUSOAP_ENV__Detail@@@Z ; soap_serialize_PointerToSOAP_ENV__Detail
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapc.cpp
_TEXT	SEGMENT
?soap_serialize_PointerToSOAP_ENV__Detail@@YAXPAUsoap@@PBQAUSOAP_ENV__Detail@@@Z PROC ; soap_serialize_PointerToSOAP_ENV__Detail
; _soap$ = edi
; _a$ = esi

; 3764 : 	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	eax, 43					; 0000002bH
	call	_soap_reference
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@soap_seria@13

; 3765 : 		soap_serialize_SOAP_ENV__Detail(soap, *a);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	push	edi
	call	_soap_markelement
	pop	ecx
$LN4@soap_seria@13:

; 3766 : }

	ret	0
?soap_serialize_PointerToSOAP_ENV__Detail@@YAXPAUsoap@@PBQAUSOAP_ENV__Detail@@@Z ENDP ; soap_serialize_PointerToSOAP_ENV__Detail
_TEXT	ENDS
PUBLIC	?soap_serialize_SOAP_ENV__Fault@@YAXPAUsoap@@PBUSOAP_ENV__Fault@@@Z ; soap_serialize_SOAP_ENV__Fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_serialize_SOAP_ENV__Fault@@YAXPAUsoap@@PBUSOAP_ENV__Fault@@@Z PROC ; soap_serialize_SOAP_ENV__Fault
; _soap$ = ecx
; _a$ = eax

; 2758 : {

	push	esi
	push	edi
	mov	esi, eax
	mov	edi, ecx

; 2759 : 	(void)soap; (void)a; /* appease -Wall -Werror */
; 2760 : 	soap_serialize__QName(soap, &a->faultcode);

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	eax, 4
	call	_soap_reference

; 2761 : 	soap_serialize_string(soap, &a->faultstring);

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	eax, 4
	call	_soap_reference

; 2762 : 	soap_serialize_string(soap, &a->faultactor);

	mov	ecx, DWORD PTR [esi+8]
	push	edi
	mov	eax, 4
	call	_soap_reference

; 2763 : 	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);

	mov	ecx, DWORD PTR [esi+12]
	push	edi
	mov	eax, 43					; 0000002bH
	call	_soap_reference
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN14@soap_seria@14
	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	push	edi
	call	_soap_markelement
	add	esp, 4
$LN14@soap_seria@14:

; 2764 : 	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);

	mov	ecx, DWORD PTR [esi+16]
	push	edi
	mov	eax, 41					; 00000029H
	call	_soap_reference
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@soap_seria@14
	mov	eax, DWORD PTR [esi+16]
	call	?soap_serialize_SOAP_ENV__Code@@YAXPAUsoap@@PBUSOAP_ENV__Code@@@Z ; soap_serialize_SOAP_ENV__Code
$LN16@soap_seria@14:

; 2765 : 	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);

	mov	ecx, DWORD PTR [esi+20]
	push	edi
	mov	eax, 46					; 0000002eH
	call	_soap_reference
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN24@soap_seria@14
	mov	ecx, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx]
	push	edi
	mov	eax, 4
	call	_soap_reference
	add	esp, 4
$LN24@soap_seria@14:

; 2766 : 	soap_serialize_string(soap, &a->SOAP_ENV__Node);

	mov	ecx, DWORD PTR [esi+24]
	push	edi
	mov	eax, 4
	call	_soap_reference

; 2767 : 	soap_serialize_string(soap, &a->SOAP_ENV__Role);

	mov	ecx, DWORD PTR [esi+28]
	push	edi
	mov	eax, 4
	call	_soap_reference

; 2768 : 	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);

	mov	ecx, DWORD PTR [esi+32]
	push	edi
	mov	eax, 43					; 0000002bH
	call	_soap_reference
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN33@soap_seria@14
	mov	esi, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	call	_soap_markelement
	add	esp, 4
$LN33@soap_seria@14:
	pop	edi
	pop	esi

; 2769 : }

	ret	0
?soap_serialize_SOAP_ENV__Fault@@YAXPAUsoap@@PBUSOAP_ENV__Fault@@@Z ENDP ; soap_serialize_SOAP_ENV__Fault
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Exsd__string@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Exsd__string@@UAEPAXI@Z PROC				; xsd__string::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector@35
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1xsd__string@@UAE@XZ		; xsd__string::~xsd__string
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	40					; 00000028H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector@35
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@35:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector@35:
	mov	DWORD PTR [esi], OFFSET ??_7xsd__string@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN24@vector@35
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@vector@35:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	DWORD PTR [esi], OFFSET ??_7xsd__anyType@@6B@
	test	bl, 1
	je	SHORT $LN1@vector@35
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@35:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_Exsd__string@@UAEPAXI@Z ENDP				; xsd__string::`vector deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
_TEXT	SEGMENT
_soap$ = 8						; size = 4
?soap_default@xsd__string@@UAEXPAUsoap@@@Z PROC		; xsd__string::soap_default
; _this$ = ecx

; 1978 : 	this->soap = soap;

	mov	eax, DWORD PTR _soap$[esp-4]
	push	esi
	mov	esi, ecx

; 1979 : 	soap_default_std__string(soap, &this->xsd__string::__item);

	push	-1
	push	0
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], eax
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1980 : 	this->xsd__anyType::__item = NULL;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 1981 : 	/* transient soap skipped */
; 1982 : }

	ret	4
?soap_default@xsd__string@@UAEXPAUsoap@@@Z ENDP		; xsd__string::soap_default
; Function compile flags: /Ogtpy
_p$ = 8						; size = 4
?soap_fdelete@@YAHPAUsoap_clist@@@Z PROC		; soap_fdelete

; 578  : {	switch (p->type)

	mov	eax, DWORD PTR _p$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, -8					; fffffff8H
	push	esi
	cmp	ecx, 39					; 00000027H
	ja	$LN1@soap_fdele
	movzx	ecx, BYTE PTR $LN159@soap_fdele[ecx]
	jmp	DWORD PTR $LN160@soap_fdele[ecx*4]
$LN70@soap_fdele:

; 579  : 	{
; 580  : 	case SOAP_TYPE_xsd__anyType:
; 581  : 		if (p->size < 0)

	cmp	DWORD PTR [eax+12], 0

; 582  : 			delete (xsd__anyType*)p->ptr;

	mov	eax, DWORD PTR [eax+4]
	jge	SHORT $LN69@soap_fdele
	test	eax, eax
	je	$LN157@soap_fdele
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+28]
	push	1
	call	eax

; 719  : 	}
; 720  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 721  : }

	ret	0
$LN69@soap_fdele:

; 583  : 		else
; 584  : 			delete[] (xsd__anyType*)p->ptr;

	test	eax, eax
	je	$LN157@soap_fdele
	cmp	DWORD PTR [eax-4], 0
	lea	ecx, DWORD PTR [eax-4]
	je	SHORT $LN77@soap_fdele
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+28]
	push	3
	call	eax

; 719  : 	}
; 720  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 721  : }

	ret	0
$LN55@soap_fdele:

; 585  : 		break;
; 586  : 	case SOAP_TYPE_xsd__boolean:
; 587  : 		if (p->size < 0)
; 588  : 			delete (xsd__boolean*)p->ptr;
; 589  : 		else
; 590  : 			delete[] (xsd__boolean*)p->ptr;
; 591  : 		break;
; 592  : 	case SOAP_TYPE_xsd__float:
; 593  : 		if (p->size < 0)
; 594  : 			delete (xsd__float*)p->ptr;
; 595  : 		else
; 596  : 			delete[] (xsd__float*)p->ptr;
; 597  : 		break;
; 598  : 	case SOAP_TYPE_xsd__int:
; 599  : 		if (p->size < 0)
; 600  : 			delete (xsd__int*)p->ptr;
; 601  : 		else
; 602  : 			delete[] (xsd__int*)p->ptr;
; 603  : 		break;
; 604  : 	case SOAP_TYPE_xsd__long:
; 605  : 		if (p->size < 0)
; 606  : 			delete (xsd__long*)p->ptr;
; 607  : 		else
; 608  : 			delete[] (xsd__long*)p->ptr;
; 609  : 		break;
; 610  : 	case SOAP_TYPE_std__string:
; 611  : 		if (p->size < 0)

	cmp	DWORD PTR [eax+12], 0

; 612  : 			delete (std::string*)p->ptr;

	mov	eax, DWORD PTR [eax+4]
	jge	SHORT $LN54@soap_fdele
	test	eax, eax
	je	$LN157@soap_fdele
	push	1
	mov	ecx, eax
	call	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z

; 719  : 	}
; 720  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 721  : }

	ret	0
$LN54@soap_fdele:

; 613  : 		else
; 614  : 			delete[] (std::string*)p->ptr;

	test	eax, eax
	je	$LN157@soap_fdele
	call	??_E?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z

; 719  : 	}
; 720  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 721  : }

	ret	0
$LN31@soap_fdele:

; 615  : 		break;
; 616  : 	case SOAP_TYPE_xsd__string:
; 617  : 		if (p->size < 0)
; 618  : 			delete (xsd__string*)p->ptr;
; 619  : 		else
; 620  : 			delete[] (xsd__string*)p->ptr;
; 621  : 		break;
; 622  : 	case SOAP_TYPE__ns2__getSessionIDElement:
; 623  : 		if (p->size < 0)
; 624  : 			delete (_ns2__getSessionIDElement*)p->ptr;
; 625  : 		else
; 626  : 			delete[] (_ns2__getSessionIDElement*)p->ptr;
; 627  : 		break;
; 628  : 	case SOAP_TYPE__ns2__getSessionIDResponseElement:
; 629  : 		if (p->size < 0)
; 630  : 			delete (_ns2__getSessionIDResponseElement*)p->ptr;
; 631  : 		else
; 632  : 			delete[] (_ns2__getSessionIDResponseElement*)p->ptr;
; 633  : 		break;
; 634  : 	case SOAP_TYPE__ns2__getSettingsFileElement:
; 635  : 		if (p->size < 0)
; 636  : 			delete (_ns2__getSettingsFileElement*)p->ptr;
; 637  : 		else
; 638  : 			delete[] (_ns2__getSettingsFileElement*)p->ptr;
; 639  : 		break;
; 640  : 	case SOAP_TYPE__ns2__getSettingsFileResponseElement:
; 641  : 		if (p->size < 0)
; 642  : 			delete (_ns2__getSettingsFileResponseElement*)p->ptr;
; 643  : 		else
; 644  : 			delete[] (_ns2__getSettingsFileResponseElement*)p->ptr;
; 645  : 		break;
; 646  : 	case SOAP_TYPE__ns2__submitEpochResultElement:
; 647  : 		if (p->size < 0)
; 648  : 			delete (_ns2__submitEpochResultElement*)p->ptr;
; 649  : 		else
; 650  : 			delete[] (_ns2__submitEpochResultElement*)p->ptr;
; 651  : 		break;
; 652  : 	case SOAP_TYPE__ns2__submitEpochResultResponseElement:
; 653  : 		if (p->size < 0)
; 654  : 			delete (_ns2__submitEpochResultResponseElement*)p->ptr;
; 655  : 		else
; 656  : 			delete[] (_ns2__submitEpochResultResponseElement*)p->ptr;
; 657  : 		break;
; 658  : 	case SOAP_TYPE___ns1__getSessionID:
; 659  : 		if (p->size < 0)

	cmp	DWORD PTR [eax+12], 0
	jge	SHORT $LN30@soap_fdele

; 660  : 			delete (struct __ns1__getSessionID*)p->ptr;

	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 719  : 	}
; 720  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 721  : }

	ret	0
$LN30@soap_fdele:

; 661  : 		else
; 662  : 			delete[] (struct __ns1__getSessionID*)p->ptr;

	mov	edx, DWORD PTR [eax+4]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 719  : 	}
; 720  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 721  : }

	ret	0
$LN28@soap_fdele:

; 663  : 		break;
; 664  : 	case SOAP_TYPE___ns1__getSettingsFile:
; 665  : 		if (p->size < 0)

	cmp	DWORD PTR [eax+12], 0
	jge	SHORT $LN27@soap_fdele

; 666  : 			delete (struct __ns1__getSettingsFile*)p->ptr;

	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 719  : 	}
; 720  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 721  : }

	ret	0
$LN27@soap_fdele:

; 667  : 		else
; 668  : 			delete[] (struct __ns1__getSettingsFile*)p->ptr;

	mov	ecx, DWORD PTR [eax+4]
$LN77@soap_fdele:
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 719  : 	}
; 720  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 721  : }

	ret	0
$LN25@soap_fdele:

; 669  : 		break;
; 670  : 	case SOAP_TYPE___ns1__submitEpochResult:
; 671  : 		if (p->size < 0)

	cmp	DWORD PTR [eax+12], 0
	jge	SHORT $LN24@soap_fdele

; 672  : 			delete (struct __ns1__submitEpochResult*)p->ptr;

	mov	edx, DWORD PTR [eax+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 719  : 	}
; 720  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 721  : }

	ret	0
$LN24@soap_fdele:

; 673  : 		else
; 674  : 			delete[] (struct __ns1__submitEpochResult*)p->ptr;

	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 719  : 	}
; 720  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 721  : }

	ret	0
$LN7@soap_fdele:

; 675  : 		break;
; 676  : 	case SOAP_TYPE_SOAP_ENV__Header:
; 677  : 		if (p->size < 0)
; 678  : 			delete (struct SOAP_ENV__Header*)p->ptr;
; 679  : 		else
; 680  : 			delete[] (struct SOAP_ENV__Header*)p->ptr;
; 681  : 		break;
; 682  : 	case SOAP_TYPE_SOAP_ENV__Code:
; 683  : 		if (p->size < 0)
; 684  : 			delete (struct SOAP_ENV__Code*)p->ptr;
; 685  : 		else
; 686  : 			delete[] (struct SOAP_ENV__Code*)p->ptr;
; 687  : 		break;
; 688  : 	case SOAP_TYPE_SOAP_ENV__Detail:
; 689  : 		if (p->size < 0)
; 690  : 			delete (struct SOAP_ENV__Detail*)p->ptr;
; 691  : 		else
; 692  : 			delete[] (struct SOAP_ENV__Detail*)p->ptr;
; 693  : 		break;
; 694  : 	case SOAP_TYPE_SOAP_ENV__Reason:
; 695  : 		if (p->size < 0)
; 696  : 			delete (struct SOAP_ENV__Reason*)p->ptr;
; 697  : 		else
; 698  : 			delete[] (struct SOAP_ENV__Reason*)p->ptr;
; 699  : 		break;
; 700  : 	case SOAP_TYPE_SOAP_ENV__Fault:
; 701  : 		if (p->size < 0)
; 702  : 			delete (struct SOAP_ENV__Fault*)p->ptr;
; 703  : 		else
; 704  : 			delete[] (struct SOAP_ENV__Fault*)p->ptr;
; 705  : 		break;
; 706  : 	case SOAP_TYPE_std__vectorTemplateOffloat:
; 707  : 		if (p->size < 0)

	cmp	DWORD PTR [eax+12], 0

; 708  : 			delete (std::vector<float >*)p->ptr;

	mov	eax, DWORD PTR [eax+4]
	jge	SHORT $LN6@soap_fdele
	test	eax, eax
	je	SHORT $LN157@soap_fdele
	mov	esi, eax
	call	??_G?$vector@MV?$allocator@M@std@@@std@@QAEPAXI@Z

; 719  : 	}
; 720  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 721  : }

	ret	0
$LN6@soap_fdele:

; 709  : 		else
; 710  : 			delete[] (std::vector<float >*)p->ptr;

	test	eax, eax
	je	SHORT $LN157@soap_fdele
	call	??_E?$vector@MV?$allocator@M@std@@@std@@QAEPAXI@Z

; 719  : 	}
; 720  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 721  : }

	ret	0
$LN4@soap_fdele:

; 711  : 		break;
; 712  : 	case SOAP_TYPE_std__vectorTemplateOfint:
; 713  : 		if (p->size < 0)

	cmp	DWORD PTR [eax+12], 0

; 714  : 			delete (std::vector<int >*)p->ptr;

	mov	eax, DWORD PTR [eax+4]
	jge	SHORT $LN3@soap_fdele
	test	eax, eax
	je	SHORT $LN157@soap_fdele
	mov	esi, eax
	call	??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z

; 719  : 	}
; 720  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 721  : }

	ret	0
$LN3@soap_fdele:

; 715  : 		else
; 716  : 			delete[] (std::vector<int >*)p->ptr;

	test	eax, eax
	je	SHORT $LN157@soap_fdele
	call	??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z
$LN157@soap_fdele:

; 719  : 	}
; 720  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 721  : }

	ret	0
$LN1@soap_fdele:

; 717  : 		break;
; 718  : 	default:	return SOAP_ERR;

	or	eax, -1
	pop	esi

; 721  : }

	ret	0
	npad	2
$LN160@soap_fdele:
	DD	$LN70@soap_fdele
	DD	$LN55@soap_fdele
	DD	$LN4@soap_fdele
	DD	$LN7@soap_fdele
	DD	$LN31@soap_fdele
	DD	$LN28@soap_fdele
	DD	$LN25@soap_fdele
	DD	$LN1@soap_fdele
$LN159@soap_fdele:
	DB	0
	DB	7
	DB	0
	DB	7
	DB	0
	DB	7
	DB	0
	DB	0
	DB	7
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	7
	DB	2
	DB	3
	DB	7
	DB	7
	DB	7
	DB	4
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	6
	DB	4
	DB	5
	DB	7
	DB	6
	DB	7
	DB	7
	DB	4
	DB	5
?soap_fdelete@@YAHPAUsoap_clist@@@Z ENDP		; soap_fdelete
PUBLIC	?soap_default_std__vectorTemplateOfint@@YAXPAUsoap@@PAV?$vector@HV?$allocator@H@std@@@std@@@Z ; soap_default_std__vectorTemplateOfint
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T457505 = -8						; size = 4
$T457591 = -8						; size = 8
?soap_default_std__vectorTemplateOfint@@YAXPAUsoap@@PAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; soap_default_std__vectorTemplateOfint
; _p$ = eax

; 4415 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, eax

; 4416 : 	p->clear();

	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	DWORD PTR $T457505[esp+24], eax
	cmp	DWORD PTR [esi+12], eax
	jbe	SHORT $LN10@soap_defau@2
	call	__invalid_parameter_noinfo
$LN10@soap_defau@2:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN26@soap_defau@2
	call	__invalid_parameter_noinfo
$LN26@soap_defau@2:
	mov	ecx, DWORD PTR $T457505[esp+24]
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	ebx
	push	edi
	push	eax
	lea	edx, DWORD PTR $T457591[esp+40]
	push	edx
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 4417 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?soap_default_std__vectorTemplateOfint@@YAXPAUsoap@@PAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; soap_default_std__vectorTemplateOfint
_TEXT	ENDS
PUBLIC	?soap_instantiate___ns1__getSessionID@@YAPAU__ns1__getSessionID@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate___ns1__getSessionID
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_size$ = 12						; size = 4
?soap_instantiate___ns1__getSessionID@@YAPAU__ns1__getSessionID@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate___ns1__getSessionID
; _n$ = edi

; 3677 : {

	push	ebx
	mov	ebx, DWORD PTR _size$[esp]
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+4]
	push	esi

; 3678 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSessionID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 3679 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSessionID, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN12@soap_insta
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 31			; 0000001fH
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebp+96], esi

; 3680 : 	if (!cp)
; 3681 : 		return NULL;
; 3682 : 	if (n < 0)

	test	edi, edi
	jge	SHORT $LN5@soap_insta

; 3683 : 	{	cp->ptr = (void*)new struct __ns1__getSessionID;

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 3684 : 		if (size)

	test	ebx, ebx
	je	SHORT $LN1@soap_insta

; 3685 : 			*size = sizeof(struct __ns1__getSessionID);

	mov	DWORD PTR [ebx], 4

; 3695 : 	}
; 3696 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 3697 : 	return (struct __ns1__getSessionID*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebp
	pop	ebx

; 3698 : }

	ret	0
$LN5@soap_insta:

; 3686 : 	}
; 3687 : 	else
; 3688 : 	{	cp->ptr = (void*)new struct __ns1__getSessionID[n];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 3689 : 		if (!cp->ptr)

	test	eax, eax
	jne	SHORT $LN2@soap_insta

; 3690 : 		{	soap->error = SOAP_EOM;

	mov	DWORD PTR [ebp+90460], 20		; 00000014H
$LN12@soap_insta:
	pop	esi
	pop	ebp

; 3691 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 3698 : }

	ret	0
$LN2@soap_insta:

; 3692 : 		}
; 3693 : 		if (size)

	test	ebx, ebx
	je	SHORT $LN1@soap_insta

; 3694 : 			*size = n * sizeof(struct __ns1__getSessionID);

	lea	eax, DWORD PTR [edi*4]
	mov	DWORD PTR [ebx], eax
$LN1@soap_insta:

; 3695 : 	}
; 3696 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 3697 : 	return (struct __ns1__getSessionID*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebp
	pop	ebx

; 3698 : }

	ret	0
?soap_instantiate___ns1__getSessionID@@YAPAU__ns1__getSessionID@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate___ns1__getSessionID
_TEXT	ENDS
PUBLIC	?soap_new___ns1__getSessionID@@YAPAU__ns1__getSessionID@@PAUsoap@@H@Z ; soap_new___ns1__getSessionID
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
?soap_new___ns1__getSessionID@@YAPAU__ns1__getSessionID@@PAUsoap@@H@Z PROC ; soap_new___ns1__getSessionID
; _n$ = edi

; 3669 : {	return soap_instantiate___ns1__getSessionID(soap, n, NULL, NULL, NULL);

	push	ebp
	mov	ebp, DWORD PTR _soap$[esp]
	push	esi
	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN14@soap_new__
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 31			; 0000001fH
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebp+96], esi
	test	edi, edi
	jge	SHORT $LN7@soap_new__
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
$LN4@soap_new__:
	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebp

; 3670 : }

	ret	0

; 3669 : {	return soap_instantiate___ns1__getSessionID(soap, n, NULL, NULL, NULL);

$LN7@soap_new__:
	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	jne	SHORT $LN4@soap_new__
	mov	DWORD PTR [ebp+90460], 20		; 00000014H
$LN14@soap_new__:
	pop	esi
	xor	eax, eax
	pop	ebp

; 3670 : }

	ret	0
?soap_new___ns1__getSessionID@@YAPAU__ns1__getSessionID@@PAUsoap@@H@Z ENDP ; soap_new___ns1__getSessionID
_TEXT	ENDS
PUBLIC	?soap_instantiate___ns1__getSettingsFile@@YAPAU__ns1__getSettingsFile@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate___ns1__getSettingsFile
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_size$ = 12						; size = 4
?soap_instantiate___ns1__getSettingsFile@@YAPAU__ns1__getSettingsFile@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate___ns1__getSettingsFile
; _n$ = edi

; 3577 : {

	push	ebx
	mov	ebx, DWORD PTR _size$[esp]
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+4]
	push	esi

; 3578 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSettingsFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 3579 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSettingsFile, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN12@soap_insta@2
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 35			; 00000023H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebp+96], esi

; 3580 : 	if (!cp)
; 3581 : 		return NULL;
; 3582 : 	if (n < 0)

	test	edi, edi
	jge	SHORT $LN5@soap_insta@2

; 3583 : 	{	cp->ptr = (void*)new struct __ns1__getSettingsFile;

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 3584 : 		if (size)

	test	ebx, ebx
	je	SHORT $LN1@soap_insta@2

; 3585 : 			*size = sizeof(struct __ns1__getSettingsFile);

	mov	DWORD PTR [ebx], 4

; 3595 : 	}
; 3596 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 3597 : 	return (struct __ns1__getSettingsFile*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebp
	pop	ebx

; 3598 : }

	ret	0
$LN5@soap_insta@2:

; 3586 : 	}
; 3587 : 	else
; 3588 : 	{	cp->ptr = (void*)new struct __ns1__getSettingsFile[n];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 3589 : 		if (!cp->ptr)

	test	eax, eax
	jne	SHORT $LN2@soap_insta@2

; 3590 : 		{	soap->error = SOAP_EOM;

	mov	DWORD PTR [ebp+90460], 20		; 00000014H
$LN12@soap_insta@2:
	pop	esi
	pop	ebp

; 3591 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 3598 : }

	ret	0
$LN2@soap_insta@2:

; 3592 : 		}
; 3593 : 		if (size)

	test	ebx, ebx
	je	SHORT $LN1@soap_insta@2

; 3594 : 			*size = n * sizeof(struct __ns1__getSettingsFile);

	lea	eax, DWORD PTR [edi*4]
	mov	DWORD PTR [ebx], eax
$LN1@soap_insta@2:

; 3595 : 	}
; 3596 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 3597 : 	return (struct __ns1__getSettingsFile*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebp
	pop	ebx

; 3598 : }

	ret	0
?soap_instantiate___ns1__getSettingsFile@@YAPAU__ns1__getSettingsFile@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate___ns1__getSettingsFile
_TEXT	ENDS
PUBLIC	?soap_new___ns1__getSettingsFile@@YAPAU__ns1__getSettingsFile@@PAUsoap@@H@Z ; soap_new___ns1__getSettingsFile
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
?soap_new___ns1__getSettingsFile@@YAPAU__ns1__getSettingsFile@@PAUsoap@@H@Z PROC ; soap_new___ns1__getSettingsFile
; _n$ = edi

; 3569 : {	return soap_instantiate___ns1__getSettingsFile(soap, n, NULL, NULL, NULL);

	push	ebp
	mov	ebp, DWORD PTR _soap$[esp]
	push	esi
	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN14@soap_new__@2
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 35			; 00000023H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebp+96], esi
	test	edi, edi
	jge	SHORT $LN7@soap_new__@2
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
$LN4@soap_new__@2:
	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebp

; 3570 : }

	ret	0

; 3569 : {	return soap_instantiate___ns1__getSettingsFile(soap, n, NULL, NULL, NULL);

$LN7@soap_new__@2:
	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	jne	SHORT $LN4@soap_new__@2
	mov	DWORD PTR [ebp+90460], 20		; 00000014H
$LN14@soap_new__@2:
	pop	esi
	xor	eax, eax
	pop	ebp

; 3570 : }

	ret	0
?soap_new___ns1__getSettingsFile@@YAPAU__ns1__getSettingsFile@@PAUsoap@@H@Z ENDP ; soap_new___ns1__getSettingsFile
_TEXT	ENDS
PUBLIC	?soap_instantiate___ns1__submitEpochResult@@YAPAU__ns1__submitEpochResult@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate___ns1__submitEpochResult
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_size$ = 12						; size = 4
?soap_instantiate___ns1__submitEpochResult@@YAPAU__ns1__submitEpochResult@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate___ns1__submitEpochResult
; _n$ = edi

; 3477 : {

	push	ebx
	mov	ebx, DWORD PTR _size$[esp]
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+4]
	push	esi

; 3478 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__submitEpochResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 3479 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__submitEpochResult, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN12@soap_insta@3
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 39			; 00000027H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebp+96], esi

; 3480 : 	if (!cp)
; 3481 : 		return NULL;
; 3482 : 	if (n < 0)

	test	edi, edi
	jge	SHORT $LN5@soap_insta@3

; 3483 : 	{	cp->ptr = (void*)new struct __ns1__submitEpochResult;

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 3484 : 		if (size)

	test	ebx, ebx
	je	SHORT $LN1@soap_insta@3

; 3485 : 			*size = sizeof(struct __ns1__submitEpochResult);

	mov	DWORD PTR [ebx], 4

; 3495 : 	}
; 3496 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 3497 : 	return (struct __ns1__submitEpochResult*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebp
	pop	ebx

; 3498 : }

	ret	0
$LN5@soap_insta@3:

; 3486 : 	}
; 3487 : 	else
; 3488 : 	{	cp->ptr = (void*)new struct __ns1__submitEpochResult[n];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 3489 : 		if (!cp->ptr)

	test	eax, eax
	jne	SHORT $LN2@soap_insta@3

; 3490 : 		{	soap->error = SOAP_EOM;

	mov	DWORD PTR [ebp+90460], 20		; 00000014H
$LN12@soap_insta@3:
	pop	esi
	pop	ebp

; 3491 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 3498 : }

	ret	0
$LN2@soap_insta@3:

; 3492 : 		}
; 3493 : 		if (size)

	test	ebx, ebx
	je	SHORT $LN1@soap_insta@3

; 3494 : 			*size = n * sizeof(struct __ns1__submitEpochResult);

	lea	eax, DWORD PTR [edi*4]
	mov	DWORD PTR [ebx], eax
$LN1@soap_insta@3:

; 3495 : 	}
; 3496 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 3497 : 	return (struct __ns1__submitEpochResult*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebp
	pop	ebx

; 3498 : }

	ret	0
?soap_instantiate___ns1__submitEpochResult@@YAPAU__ns1__submitEpochResult@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate___ns1__submitEpochResult
_TEXT	ENDS
PUBLIC	?soap_new___ns1__submitEpochResult@@YAPAU__ns1__submitEpochResult@@PAUsoap@@H@Z ; soap_new___ns1__submitEpochResult
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
?soap_new___ns1__submitEpochResult@@YAPAU__ns1__submitEpochResult@@PAUsoap@@H@Z PROC ; soap_new___ns1__submitEpochResult
; _n$ = edi

; 3469 : {	return soap_instantiate___ns1__submitEpochResult(soap, n, NULL, NULL, NULL);

	push	ebp
	mov	ebp, DWORD PTR _soap$[esp]
	push	esi
	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN14@soap_new__@3
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 39			; 00000027H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebp+96], esi
	test	edi, edi
	jge	SHORT $LN7@soap_new__@3
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
$LN4@soap_new__@3:
	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebp

; 3470 : }

	ret	0

; 3469 : {	return soap_instantiate___ns1__submitEpochResult(soap, n, NULL, NULL, NULL);

$LN7@soap_new__@3:
	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	jne	SHORT $LN4@soap_new__@3
	mov	DWORD PTR [ebp+90460], 20		; 00000014H
$LN14@soap_new__@3:
	pop	esi
	xor	eax, eax
	pop	ebp

; 3470 : }

	ret	0
?soap_new___ns1__submitEpochResult@@YAPAU__ns1__submitEpochResult@@PAUsoap@@H@Z ENDP ; soap_new___ns1__submitEpochResult
_TEXT	ENDS
PUBLIC	?soap_instantiate_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_SOAP_ENV__Header
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_size$ = 8						; size = 4
?soap_instantiate_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate_SOAP_ENV__Header
; _soap$ = edi

; 3375 : {

	push	ebx
	mov	ebx, DWORD PTR _size$[esp]
	push	esi

; 3376 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 3377 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN13@soap_insta@4
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 40			; 00000028H
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete

; 3380 : 	if (n < 0)
; 3381 : 	{	cp->ptr = (void*)new struct SOAP_ENV__Header;

	push	1
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 3382 : 		if (size)

	test	ebx, ebx
	je	SHORT $LN4@soap_insta@4

; 3383 : 			*size = sizeof(struct SOAP_ENV__Header);

	mov	DWORD PTR [ebx], 1
$LN4@soap_insta@4:

; 3384 : 	}
; 3385 : 	else
; 3386 : 	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
; 3387 : 		if (!cp->ptr)
; 3388 : 		{	soap->error = SOAP_EOM;
; 3389 : 			return NULL;
; 3390 : 		}
; 3391 : 		if (size)
; 3392 : 			*size = n * sizeof(struct SOAP_ENV__Header);
; 3393 : 	}
; 3394 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 3395 : 	return (struct SOAP_ENV__Header*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebx

; 3396 : }

	ret	0
$LN13@soap_insta@4:
	pop	esi

; 3378 : 	if (!cp)
; 3379 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 3396 : }

	ret	0
?soap_instantiate_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate_SOAP_ENV__Header
_TEXT	ENDS
PUBLIC	?soap_new_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@H@Z ; soap_new_SOAP_ENV__Header
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@H@Z PROC ; soap_new_SOAP_ENV__Header
; _soap$ = edi

; 3367 : {	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);

	push	esi
	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	eax, eax
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN9@soap_new_S
	mov	ecx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+8], 40			; 00000028H
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	push	1
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
$LN9@soap_new_S:
	pop	esi

; 3368 : }

	ret	0
?soap_new_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@H@Z ENDP ; soap_new_SOAP_ENV__Header
_TEXT	ENDS
PUBLIC	?soap_out_SOAP_ENV__Header@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Header@@1@Z ; soap_out_SOAP_ENV__Header
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_SOAP_ENV__Header@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Header@@1@Z PROC ; soap_out_SOAP_ENV__Header
; _id$ = eax
; _a$ = ecx

; 3322 : {

	push	esi
	mov	esi, DWORD PTR _tag$[esp]
	push	edi
	mov	edi, DWORD PTR _soap$[esp+4]

; 3323 : 	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))

	push	eax
	push	edi
	mov	eax, 40					; 00000028H
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN1@soap_out_S
	mov	ecx, DWORD PTR _type$[esp+4]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@soap_out_S
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN6@soap_out_S
$LN4@soap_out_S:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN6@soap_out_S:
	test	eax, eax
	je	SHORT $LN1@soap_out_S

; 3324 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 3326 : }

	ret	0
$LN1@soap_out_S:

; 3325 : 	return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi

; 3326 : }

	ret	0
?soap_out_SOAP_ENV__Header@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Header@@1@Z ENDP ; soap_out_SOAP_ENV__Header
_TEXT	ENDS
PUBLIC	?soap_instantiate_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_SOAP_ENV__Code
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_size$ = 8						; size = 4
?soap_instantiate_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate_SOAP_ENV__Code
; _soap$ = edi

; 3271 : {

	push	ebx
	mov	ebx, DWORD PTR _size$[esp]
	push	esi

; 3272 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 3273 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN13@soap_insta@5
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 41			; 00000029H
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete

; 3276 : 	if (n < 0)
; 3277 : 	{	cp->ptr = (void*)new struct SOAP_ENV__Code;

	push	8
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 3278 : 		if (size)

	test	ebx, ebx
	je	SHORT $LN4@soap_insta@5

; 3279 : 			*size = sizeof(struct SOAP_ENV__Code);

	mov	DWORD PTR [ebx], 8
$LN4@soap_insta@5:

; 3280 : 	}
; 3281 : 	else
; 3282 : 	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
; 3283 : 		if (!cp->ptr)
; 3284 : 		{	soap->error = SOAP_EOM;
; 3285 : 			return NULL;
; 3286 : 		}
; 3287 : 		if (size)
; 3288 : 			*size = n * sizeof(struct SOAP_ENV__Code);
; 3289 : 	}
; 3290 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 3291 : 	return (struct SOAP_ENV__Code*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebx

; 3292 : }

	ret	0
$LN13@soap_insta@5:
	pop	esi

; 3274 : 	if (!cp)
; 3275 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 3292 : }

	ret	0
?soap_instantiate_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate_SOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_new_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@H@Z ; soap_new_SOAP_ENV__Code
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@H@Z PROC ; soap_new_SOAP_ENV__Code
; _soap$ = edi

; 3263 : {	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);

	push	esi
	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	eax, eax
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN9@soap_new_S@2
	mov	ecx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+8], 41			; 00000029H
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	push	8
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
$LN9@soap_new_S@2:
	pop	esi

; 3264 : }

	ret	0
?soap_new_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@H@Z ENDP ; soap_new_SOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_instantiate_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_SOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_size$ = 8						; size = 4
?soap_instantiate_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate_SOAP_ENV__Detail
; _soap$ = edi

; 3146 : {

	push	ebx
	mov	ebx, DWORD PTR _size$[esp]
	push	esi

; 3147 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 3148 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN13@soap_insta@6
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 43			; 0000002bH
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete

; 3151 : 	if (n < 0)
; 3152 : 	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;

	push	12					; 0000000cH
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 3153 : 		if (size)

	test	ebx, ebx
	je	SHORT $LN4@soap_insta@6

; 3154 : 			*size = sizeof(struct SOAP_ENV__Detail);

	mov	DWORD PTR [ebx], 12			; 0000000cH
$LN4@soap_insta@6:

; 3155 : 	}
; 3156 : 	else
; 3157 : 	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
; 3158 : 		if (!cp->ptr)
; 3159 : 		{	soap->error = SOAP_EOM;
; 3160 : 			return NULL;
; 3161 : 		}
; 3162 : 		if (size)
; 3163 : 			*size = n * sizeof(struct SOAP_ENV__Detail);
; 3164 : 	}
; 3165 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 3166 : 	return (struct SOAP_ENV__Detail*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebx

; 3167 : }

	ret	0
$LN13@soap_insta@6:
	pop	esi

; 3149 : 	if (!cp)
; 3150 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 3167 : }

	ret	0
?soap_instantiate_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate_SOAP_ENV__Detail
_TEXT	ENDS
PUBLIC	?soap_new_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@H@Z ; soap_new_SOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@H@Z PROC ; soap_new_SOAP_ENV__Detail
; _soap$ = edi

; 3138 : {	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);

	push	esi
	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	eax, eax
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN9@soap_new_S@3
	mov	ecx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+8], 43			; 0000002bH
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	push	12					; 0000000cH
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
$LN9@soap_new_S@3:
	pop	esi

; 3139 : }

	ret	0
?soap_new_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@H@Z ENDP ; soap_new_SOAP_ENV__Detail
_TEXT	ENDS
PUBLIC	?soap_instantiate_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_SOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_size$ = 8						; size = 4
?soap_instantiate_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate_SOAP_ENV__Reason
; _soap$ = edi

; 3023 : {

	push	ebx
	mov	ebx, DWORD PTR _size$[esp]
	push	esi

; 3024 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 3025 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN13@soap_insta@7
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 46			; 0000002eH
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete

; 3028 : 	if (n < 0)
; 3029 : 	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;

	push	4
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 3030 : 		if (size)

	test	ebx, ebx
	je	SHORT $LN4@soap_insta@7

; 3031 : 			*size = sizeof(struct SOAP_ENV__Reason);

	mov	DWORD PTR [ebx], 4
$LN4@soap_insta@7:

; 3032 : 	}
; 3033 : 	else
; 3034 : 	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
; 3035 : 		if (!cp->ptr)
; 3036 : 		{	soap->error = SOAP_EOM;
; 3037 : 			return NULL;
; 3038 : 		}
; 3039 : 		if (size)
; 3040 : 			*size = n * sizeof(struct SOAP_ENV__Reason);
; 3041 : 	}
; 3042 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 3043 : 	return (struct SOAP_ENV__Reason*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebx

; 3044 : }

	ret	0
$LN13@soap_insta@7:
	pop	esi

; 3026 : 	if (!cp)
; 3027 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 3044 : }

	ret	0
?soap_instantiate_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate_SOAP_ENV__Reason
_TEXT	ENDS
PUBLIC	?soap_new_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@H@Z ; soap_new_SOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@H@Z PROC ; soap_new_SOAP_ENV__Reason
; _soap$ = edi

; 3015 : {	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);

	push	esi
	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	eax, eax
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN9@soap_new_S@4
	mov	ecx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+8], 46			; 0000002eH
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	push	4
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
$LN9@soap_new_S@4:
	pop	esi

; 3016 : }

	ret	0
?soap_new_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@H@Z ENDP ; soap_new_SOAP_ENV__Reason
_TEXT	ENDS
PUBLIC	?soap_instantiate_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_SOAP_ENV__Fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_size$ = 8						; size = 4
?soap_instantiate_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate_SOAP_ENV__Fault
; _soap$ = edi

; 2906 : {

	push	ebx
	mov	ebx, DWORD PTR _size$[esp]
	push	esi

; 2907 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 2908 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN13@soap_insta@8
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 47			; 0000002fH
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete

; 2911 : 	if (n < 0)
; 2912 : 	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;

	push	36					; 00000024H
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 2913 : 		if (size)

	test	ebx, ebx
	je	SHORT $LN4@soap_insta@8

; 2914 : 			*size = sizeof(struct SOAP_ENV__Fault);

	mov	DWORD PTR [ebx], 36			; 00000024H
$LN4@soap_insta@8:

; 2915 : 	}
; 2916 : 	else
; 2917 : 	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
; 2918 : 		if (!cp->ptr)
; 2919 : 		{	soap->error = SOAP_EOM;
; 2920 : 			return NULL;
; 2921 : 		}
; 2922 : 		if (size)
; 2923 : 			*size = n * sizeof(struct SOAP_ENV__Fault);
; 2924 : 	}
; 2925 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 2926 : 	return (struct SOAP_ENV__Fault*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebx

; 2927 : }

	ret	0
$LN13@soap_insta@8:
	pop	esi

; 2909 : 	if (!cp)
; 2910 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 2927 : }

	ret	0
?soap_instantiate_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate_SOAP_ENV__Fault
_TEXT	ENDS
PUBLIC	?soap_new_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@H@Z ; soap_new_SOAP_ENV__Fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@H@Z PROC ; soap_new_SOAP_ENV__Fault
; _soap$ = edi

; 2898 : {	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);

	push	esi
	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	eax, eax
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN9@soap_new_S@5
	mov	ecx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+8], 47			; 0000002fH
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	push	36					; 00000024H
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
$LN9@soap_new_S@5:
	pop	esi

; 2899 : }

	ret	0
?soap_new_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@H@Z ENDP ; soap_new_SOAP_ENV__Fault
_TEXT	ENDS
PUBLIC	?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__anyType
__unwindtable$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z$11
__ehfuncinfo$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T457975 = -16						; size = 4
$T457966 = -16						; size = 4
$T457957 = -16						; size = 4
$T457948 = -16						; size = 4
$T457939 = -16						; size = 4
$T457930 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_soap$ = 8						; size = 4
_type$ = 12						; size = 4
_size$ = 16						; size = 4
?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate_xsd__anyType
; _n$ = ecx

; 2600 : {

	push	-1
	push	__ehhandler$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR _type$[esp+32]
	mov	esi, ecx

; 2601 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 2602 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	ebp, eax
	xor	edi, edi
	add	esp, 4
	cmp	ebp, edi
	je	$LN126@soap_insta@9
	mov	eax, DWORD PTR _soap$[esp+32]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR [ebp], ecx
	mov	DWORD PTR [ebp+8], 8
	mov	DWORD PTR [ebp+12], esi
	mov	DWORD PTR [ebp+4], edi
	mov	DWORD PTR [ebp+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [eax+96], ebp

; 2603 : 	if (!cp)
; 2604 : 		return NULL;
; 2605 : 	if (type && !soap_match_tag(soap, type, "xsd:boolean"))

	cmp	ebx, edi
	je	$LN17@soap_insta@9
	mov	edx, eax
	push	ebx
	push	edx
	mov	edi, OFFSET ??_C@_0M@FGHMEICI@xsd?3boolean?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	$LN53@soap_insta@9

; 2606 : 	{	cp->type = SOAP_TYPE_xsd__boolean;
; 2607 : 		if (n < 0)

	xor	ebx, ebx
	cmp	esi, ebx
	mov	DWORD PTR [ebp+8], 10			; 0000000aH
	jge	SHORT $LN52@soap_insta@9

; 2608 : 		{	cp->ptr = (void*)new xsd__boolean;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN57@soap_insta@9
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax], OFFSET ??_7xsd__boolean@@6B@
	mov	BYTE PTR [eax+12], bl
	jmp	SHORT $LN58@soap_insta@9
$LN57@soap_insta@9:
	xor	eax, eax
$LN58@soap_insta@9:
	mov	DWORD PTR [ebp+4], eax

; 2609 : 			if (!cp->ptr)

	cmp	eax, ebx
	jne	SHORT $LN51@soap_insta@9

; 2610 : 			{	soap->error = SOAP_EOM;

	mov	eax, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [eax+90460], 20		; 00000014H
$LN126@soap_insta@9:

; 2611 : 				return NULL;

	xor	eax, eax

; 2734 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN51@soap_insta@9:

; 2612 : 			}
; 2613 : 			if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN50@soap_insta@9

; 2614 : 				*size = sizeof(xsd__boolean);

	mov	DWORD PTR [eax], 16			; 00000010H
$LN50@soap_insta@9:

; 2615 : 			((xsd__boolean*)cp->ptr)->soap = soap;

	mov	ecx, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [ecx+8], edx

; 2616 : 		}
; 2617 : 		else

	jmp	$LN1@soap_insta@9
$LN52@soap_insta@9:

; 2618 : 		{	cp->ptr = (void*)new xsd__boolean[n];

	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 16					; 00000010H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T457930[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	cmp	eax, ebx
	je	SHORT $LN59@soap_insta@9
	push	OFFSET ??1xsd__boolean@@UAE@XZ		; xsd__boolean::~xsd__boolean
	push	OFFSET ??0xsd__boolean@@QAE@XZ		; xsd__boolean::xsd__boolean
	push	esi
	lea	edi, DWORD PTR [eax+4]
	push	16					; 00000010H
	push	edi
	mov	DWORD PTR [eax], esi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	jmp	SHORT $LN60@soap_insta@9
$LN59@soap_insta@9:
	xor	edi, edi
$LN60@soap_insta@9:

; 2619 : 			if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	mov	DWORD PTR [ebp+4], edi
	cmp	eax, ebx
	je	SHORT $LN48@soap_insta@9

; 2620 : 				*size = n * sizeof(xsd__boolean);

	mov	ecx, esi
	shl	ecx, 4
	mov	DWORD PTR [eax], ecx
$LN48@soap_insta@9:

; 2621 : 			for (int i = 0; i < n; i++)

	cmp	esi, ebx
	jle	$LN1@soap_insta@9
	mov	ecx, DWORD PTR _soap$[esp+32]
	xor	eax, eax
	npad	8
$LL47@soap_insta@9:

; 2622 : 				((xsd__boolean*)cp->ptr)[i].soap = soap;

	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [edx+eax+8], ecx
	add	eax, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LL47@soap_insta@9

; 2623 : 		}
; 2624 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 2625 : 		return (xsd__boolean*)cp->ptr;

	jmp	$LN1@soap_insta@9
$LN53@soap_insta@9:

; 2626 : 	}
; 2627 : 	if (type && !soap_match_tag(soap, type, "xsd:float"))

	mov	eax, DWORD PTR _soap$[esp+32]
	push	ebx
	push	eax
	mov	edi, OFFSET ??_C@_09ILBLHFBD@xsd?3float?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	$LN44@soap_insta@9

; 2628 : 	{	cp->type = SOAP_TYPE_xsd__float;
; 2629 : 		if (n < 0)

	xor	ebx, ebx
	cmp	esi, ebx
	mov	DWORD PTR [ebp+8], 12			; 0000000cH
	jge	SHORT $LN43@soap_insta@9

; 2630 : 		{	cp->ptr = (void*)new xsd__float;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN61@soap_insta@9
	xorps	xmm0, xmm0
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax], OFFSET ??_7xsd__float@@6B@
	movss	DWORD PTR [eax+12], xmm0
	jmp	SHORT $LN62@soap_insta@9
$LN61@soap_insta@9:
	xor	eax, eax
$LN62@soap_insta@9:
	mov	DWORD PTR [ebp+4], eax

; 2631 : 			if (!cp->ptr)

	cmp	eax, ebx
	jne	SHORT $LN42@soap_insta@9
$LN129@soap_insta@9:

; 2632 : 			{	soap->error = SOAP_EOM;

	mov	ecx, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [ecx+90460], 20		; 00000014H

; 2633 : 				return NULL;

	xor	eax, eax

; 2734 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN42@soap_insta@9:

; 2634 : 			}
; 2635 : 			if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN41@soap_insta@9

; 2636 : 				*size = sizeof(xsd__float);

	mov	DWORD PTR [eax], 16			; 00000010H
$LN41@soap_insta@9:

; 2637 : 			((xsd__float*)cp->ptr)->soap = soap;

	mov	edx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [edx+8], eax

; 2638 : 		}
; 2639 : 		else

	jmp	$LN1@soap_insta@9
$LN43@soap_insta@9:

; 2640 : 		{	cp->ptr = (void*)new xsd__float[n];

	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 16					; 00000010H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T457939[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], 1
	cmp	eax, ebx
	je	SHORT $LN63@soap_insta@9
	push	OFFSET ??1xsd__float@@UAE@XZ		; xsd__float::~xsd__float
	push	OFFSET ??0xsd__float@@QAE@XZ		; xsd__float::xsd__float
	push	esi
	lea	edi, DWORD PTR [eax+4]
	push	16					; 00000010H
	push	edi
	mov	DWORD PTR [eax], esi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	jmp	SHORT $LN64@soap_insta@9
$LN63@soap_insta@9:
	xor	edi, edi
$LN64@soap_insta@9:

; 2641 : 			if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	mov	DWORD PTR [ebp+4], edi
	cmp	eax, ebx
	je	SHORT $LN39@soap_insta@9

; 2642 : 				*size = n * sizeof(xsd__float);

	mov	ecx, esi
	shl	ecx, 4
	mov	DWORD PTR [eax], ecx
$LN39@soap_insta@9:

; 2643 : 			for (int i = 0; i < n; i++)

	cmp	esi, ebx
	jle	$LN1@soap_insta@9
	mov	ecx, DWORD PTR _soap$[esp+32]
	xor	eax, eax
	npad	3
$LL38@soap_insta@9:

; 2644 : 				((xsd__float*)cp->ptr)[i].soap = soap;

	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [edx+eax+8], ecx
	add	eax, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LL38@soap_insta@9

; 2645 : 		}
; 2646 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 2647 : 		return (xsd__float*)cp->ptr;

	jmp	$LN1@soap_insta@9
$LN44@soap_insta@9:

; 2648 : 	}
; 2649 : 	if (type && !soap_match_tag(soap, type, "xsd:int"))

	mov	eax, DWORD PTR _soap$[esp+32]
	push	ebx
	push	eax
	mov	edi, OFFSET ??_C@_07PCIGPDP@xsd?3int?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	$LN35@soap_insta@9

; 2650 : 	{	cp->type = SOAP_TYPE_xsd__int;
; 2651 : 		if (n < 0)

	xor	ebx, ebx
	cmp	esi, ebx
	mov	DWORD PTR [ebp+8], 14			; 0000000eH
	jge	SHORT $LN34@soap_insta@9

; 2652 : 		{	cp->ptr = (void*)new xsd__int;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	$LN61@soap_insta@9
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax], OFFSET ??_7xsd__int@@6B@
	mov	DWORD PTR [eax+12], ebx
	jmp	$LN62@soap_insta@9
$LN34@soap_insta@9:

; 2653 : 			if (!cp->ptr)
; 2654 : 			{	soap->error = SOAP_EOM;
; 2655 : 				return NULL;
; 2656 : 			}
; 2657 : 			if (size)
; 2658 : 				*size = sizeof(xsd__int);
; 2659 : 			((xsd__int*)cp->ptr)->soap = soap;
; 2660 : 		}
; 2661 : 		else
; 2662 : 		{	cp->ptr = (void*)new xsd__int[n];

	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 16					; 00000010H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T457948[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], 2
	cmp	eax, ebx
	je	SHORT $LN67@soap_insta@9
	push	OFFSET ??1xsd__int@@UAE@XZ		; xsd__int::~xsd__int
	push	OFFSET ??0xsd__int@@QAE@XZ		; xsd__int::xsd__int
	push	esi
	lea	edi, DWORD PTR [eax+4]
	push	16					; 00000010H
	push	edi
	mov	DWORD PTR [eax], esi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	jmp	SHORT $LN68@soap_insta@9
$LN67@soap_insta@9:
	xor	edi, edi
$LN68@soap_insta@9:

; 2663 : 			if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	mov	DWORD PTR [ebp+4], edi
	cmp	eax, ebx
	je	SHORT $LN30@soap_insta@9

; 2664 : 				*size = n * sizeof(xsd__int);

	mov	ecx, esi
	shl	ecx, 4
	mov	DWORD PTR [eax], ecx
$LN30@soap_insta@9:

; 2665 : 			for (int i = 0; i < n; i++)

	cmp	esi, ebx
	jle	$LN1@soap_insta@9
	mov	ecx, DWORD PTR _soap$[esp+32]
	xor	eax, eax
$LL29@soap_insta@9:

; 2666 : 				((xsd__int*)cp->ptr)[i].soap = soap;

	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [edx+eax+8], ecx
	add	eax, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LL29@soap_insta@9

; 2667 : 		}
; 2668 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 2669 : 		return (xsd__int*)cp->ptr;

	jmp	$LN1@soap_insta@9
$LN35@soap_insta@9:

; 2670 : 	}
; 2671 : 	if (type && !soap_match_tag(soap, type, "xsd:long"))

	mov	eax, DWORD PTR _soap$[esp+32]
	push	ebx
	push	eax
	mov	edi, OFFSET ??_C@_08PNDIDGIB@xsd?3long?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	$LN26@soap_insta@9

; 2672 : 	{	cp->type = SOAP_TYPE_xsd__long;
; 2673 : 		if (n < 0)

	xor	ebx, ebx
	cmp	esi, ebx
	mov	DWORD PTR [ebp+8], 15			; 0000000fH
	jge	SHORT $LN25@soap_insta@9

; 2674 : 		{	cp->ptr = (void*)new xsd__long;

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN69@soap_insta@9
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax], OFFSET ??_7xsd__long@@6B@
	mov	DWORD PTR [eax+16], ebx
	mov	DWORD PTR [eax+20], ebx
	jmp	SHORT $LN70@soap_insta@9
$LN69@soap_insta@9:
	xor	eax, eax
$LN70@soap_insta@9:
	mov	DWORD PTR [ebp+4], eax

; 2675 : 			if (!cp->ptr)

	cmp	eax, ebx

; 2676 : 			{	soap->error = SOAP_EOM;
; 2677 : 				return NULL;

	je	$LN129@soap_insta@9

; 2678 : 			}
; 2679 : 			if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN23@soap_insta@9

; 2680 : 				*size = sizeof(xsd__long);

	mov	DWORD PTR [eax], 24			; 00000018H
$LN23@soap_insta@9:

; 2681 : 			((xsd__long*)cp->ptr)->soap = soap;

	mov	edx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [edx+8], eax

; 2682 : 		}
; 2683 : 		else

	jmp	$LN1@soap_insta@9
$LN25@soap_insta@9:

; 2684 : 		{	cp->ptr = (void*)new xsd__long[n];

	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 24					; 00000018H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T457957[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], 3
	cmp	eax, ebx
	je	SHORT $LN71@soap_insta@9
	push	OFFSET ??1xsd__long@@UAE@XZ		; xsd__long::~xsd__long
	push	OFFSET ??0xsd__long@@QAE@XZ		; xsd__long::xsd__long
	push	esi
	lea	edi, DWORD PTR [eax+4]
	push	24					; 00000018H
	push	edi
	mov	DWORD PTR [eax], esi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	jmp	SHORT $LN72@soap_insta@9
$LN71@soap_insta@9:
	xor	edi, edi
$LN72@soap_insta@9:

; 2685 : 			if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	mov	DWORD PTR [ebp+4], edi
	cmp	eax, ebx
	je	SHORT $LN21@soap_insta@9

; 2686 : 				*size = n * sizeof(xsd__long);

	lea	ecx, DWORD PTR [esi+esi*2]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR [eax], ecx
$LN21@soap_insta@9:

; 2687 : 			for (int i = 0; i < n; i++)

	cmp	esi, ebx
	jle	$LN1@soap_insta@9
	mov	ecx, DWORD PTR _soap$[esp+32]
	xor	eax, eax
$LL20@soap_insta@9:

; 2688 : 				((xsd__long*)cp->ptr)[i].soap = soap;

	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [edx+eax+8], ecx
	add	eax, 24					; 00000018H
	sub	esi, 1
	jne	SHORT $LL20@soap_insta@9

; 2689 : 		}
; 2690 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 2691 : 		return (xsd__long*)cp->ptr;

	jmp	$LN1@soap_insta@9
$LN26@soap_insta@9:

; 2692 : 	}
; 2693 : 	if (type && !soap_match_tag(soap, type, "xsd:string"))

	mov	eax, DWORD PTR _soap$[esp+32]
	push	ebx
	push	eax
	mov	edi, OFFSET ??_C@_0L@DIJPMJCO@xsd?3string?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	$LN127@soap_insta@9

; 2694 : 	{	cp->type = SOAP_TYPE_xsd__string;

	mov	DWORD PTR [ebp+8], 17			; 00000011H

; 2695 : 		if (n < 0)

	test	esi, esi
	jge	SHORT $LN16@soap_insta@9

; 2696 : 		{	cp->ptr = (void*)new xsd__string;

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN73@soap_insta@9
	mov	ecx, eax
	call	??0xsd__string@@QAE@XZ			; xsd__string::xsd__string
	jmp	SHORT $LN74@soap_insta@9
$LN73@soap_insta@9:
	xor	eax, eax
$LN74@soap_insta@9:
	mov	DWORD PTR [ebp+4], eax

; 2697 : 			if (!cp->ptr)

	test	eax, eax

; 2698 : 			{	soap->error = SOAP_EOM;
; 2699 : 				return NULL;

	je	$LN129@soap_insta@9

; 2700 : 			}
; 2701 : 			if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	test	eax, eax
	je	SHORT $LN14@soap_insta@9

; 2702 : 				*size = sizeof(xsd__string);

	mov	DWORD PTR [eax], 40			; 00000028H
$LN14@soap_insta@9:

; 2703 : 			((xsd__string*)cp->ptr)->soap = soap;

	mov	edx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [edx+8], eax

; 2704 : 		}
; 2705 : 		else

	jmp	$LN1@soap_insta@9
$LN16@soap_insta@9:

; 2706 : 		{	cp->ptr = (void*)new xsd__string[n];

	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 40					; 00000028H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T457966[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], 4
	test	eax, eax
	je	SHORT $LN75@soap_insta@9
	push	OFFSET ??1xsd__string@@UAE@XZ		; xsd__string::~xsd__string
	push	OFFSET ??0xsd__string@@QAE@XZ		; xsd__string::xsd__string
	push	esi
	lea	edi, DWORD PTR [eax+4]
	push	40					; 00000028H
	push	edi
	mov	DWORD PTR [eax], esi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	jmp	SHORT $LN76@soap_insta@9
$LN75@soap_insta@9:
	xor	edi, edi
$LN76@soap_insta@9:

; 2707 : 			if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	mov	DWORD PTR [ebp+4], edi
	test	eax, eax
	je	SHORT $LN12@soap_insta@9

; 2708 : 				*size = n * sizeof(xsd__string);

	lea	ecx, DWORD PTR [esi+esi*4]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR [eax], ecx
$LN12@soap_insta@9:

; 2709 : 			for (int i = 0; i < n; i++)

	test	esi, esi
	jle	$LN1@soap_insta@9
	mov	ecx, DWORD PTR _soap$[esp+32]
	xor	eax, eax
$LL11@soap_insta@9:

; 2710 : 				((xsd__string*)cp->ptr)[i].soap = soap;

	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [edx+eax+8], ecx
	add	eax, 40					; 00000028H
	sub	esi, 1
	jne	SHORT $LL11@soap_insta@9

; 2711 : 		}
; 2712 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 2713 : 		return (xsd__string*)cp->ptr;

	jmp	$LN1@soap_insta@9
$LN127@soap_insta@9:

; 2709 : 			for (int i = 0; i < n; i++)

	xor	edi, edi
$LN17@soap_insta@9:

; 2714 : 	}
; 2715 : 	if (n < 0)

	cmp	esi, edi
	jge	SHORT $LN8@soap_insta@9

; 2716 : 	{	cp->ptr = (void*)new xsd__anyType;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN77@soap_insta@9
	mov	DWORD PTR [eax], OFFSET ??_7xsd__anyType@@6B@
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	jmp	SHORT $LN78@soap_insta@9
$LN77@soap_insta@9:
	xor	eax, eax
$LN78@soap_insta@9:
	mov	DWORD PTR [ebp+4], eax

; 2717 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, edi
	je	SHORT $LN7@soap_insta@9

; 2718 : 			*size = sizeof(xsd__anyType);

	mov	DWORD PTR [eax], 12			; 0000000cH
$LN7@soap_insta@9:

; 2719 : 		((xsd__anyType*)cp->ptr)->soap = soap;

	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [eax+8], ecx

; 2720 : 	}
; 2721 : 	else

	jmp	$LN1@soap_insta@9
$LN8@soap_insta@9:

; 2722 : 	{	cp->ptr = (void*)new xsd__anyType[n];

	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 12					; 0000000cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T457975[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], 5
	cmp	eax, edi
	je	SHORT $LN79@soap_insta@9
	push	OFFSET ??1xsd__anyType@@UAE@XZ		; xsd__anyType::~xsd__anyType
	push	OFFSET ??0xsd__anyType@@QAE@XZ		; xsd__anyType::xsd__anyType
	push	esi
	lea	edi, DWORD PTR [eax+4]
	push	12					; 0000000cH
	push	edi
	mov	DWORD PTR [eax], esi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	jmp	SHORT $LN80@soap_insta@9
$LN79@soap_insta@9:
	xor	edi, edi
$LN80@soap_insta@9:
	mov	DWORD PTR [ebp+4], edi

; 2723 : 		if (!cp->ptr)

	test	edi, edi

; 2724 : 		{	soap->error = SOAP_EOM;
; 2725 : 			return NULL;

	je	$LN129@soap_insta@9

; 2726 : 		}
; 2727 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	test	eax, eax
	je	SHORT $LN4@soap_insta@9

; 2728 : 			*size = n * sizeof(xsd__anyType);

	lea	edx, DWORD PTR [esi+esi*2]
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR [eax], edx
$LN4@soap_insta@9:

; 2729 : 		for (int i = 0; i < n; i++)

	test	esi, esi
	jle	SHORT $LN1@soap_insta@9
	mov	ecx, DWORD PTR _soap$[esp+32]
	xor	eax, eax
	npad	9
$LL3@soap_insta@9:

; 2730 : 			((xsd__anyType*)cp->ptr)[i].soap = soap;

	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [edx+eax+8], ecx
	add	eax, 12					; 0000000cH
	sub	esi, 1
	jne	SHORT $LL3@soap_insta@9
$LN1@soap_insta@9:

; 2731 : 	}
; 2732 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 2733 : 	return (xsd__anyType*)cp->ptr;

	mov	eax, DWORD PTR [ebp+4]

; 2734 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
__unwindfunclet$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z$1:
	mov	eax, DWORD PTR $T457930[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__unwindfunclet$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z$3:
	mov	eax, DWORD PTR $T457939[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__unwindfunclet$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z$5:
	mov	eax, DWORD PTR $T457948[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__unwindfunclet$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z$7:
	mov	eax, DWORD PTR $T457957[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__unwindfunclet$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z$9:
	mov	eax, DWORD PTR $T457966[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__unwindfunclet$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z$11:
	mov	eax, DWORD PTR $T457975[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z
	jmp	___CxxFrameHandler3
?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate_xsd__anyType
PUBLIC	?soap_new_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@H@Z ; soap_new_xsd__anyType
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@H@Z PROC ; soap_new_xsd__anyType
; _soap$ = eax
; _n$ = ecx

; 2592 : {	return soap_instantiate_xsd__anyType(soap, n, NULL, NULL, NULL);

	push	0
	push	0
	push	eax
	call	?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__anyType
	add	esp, 12					; 0000000cH

; 2593 : }

	ret	0
?soap_new_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@H@Z ENDP ; soap_new_xsd__anyType
_TEXT	ENDS
PUBLIC	?soap_instantiate_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__boolean
__unwindtable$?soap_instantiate_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@HPBD1PAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@HPBD1PAI@Z$1
__ehfuncinfo$?soap_instantiate_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@HPBD1PAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?soap_instantiate_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@HPBD1PAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T458057 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_soap$ = 8						; size = 4
_size$ = 12						; size = 4
?soap_instantiate_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate_xsd__boolean
; _n$ = ecx

; 2492 : {

	push	-1
	push	__ehhandler$?soap_instantiate_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@HPBD1PAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 2493 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 2494 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__boolean, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	ebx, ebx
	add	esp, 4
	cmp	esi, ebx
	je	$LN27@soap_insta@10

; 2495 : 	if (!cp)
; 2496 : 		return NULL;
; 2497 : 	if (n < 0)

	cmp	edi, ebx
	mov	ebp, DWORD PTR _soap$[esp+32]
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 10			; 0000000aH
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebp+96], esi
	jge	SHORT $LN8@soap_insta@10

; 2498 : 	{	cp->ptr = (void*)new xsd__boolean;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN12@soap_insta@10
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax], OFFSET ??_7xsd__boolean@@6B@
	mov	BYTE PTR [eax+12], bl
	jmp	SHORT $LN13@soap_insta@10
$LN12@soap_insta@10:
	xor	eax, eax
$LN13@soap_insta@10:
	mov	DWORD PTR [esi+4], eax

; 2499 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN7@soap_insta@10

; 2500 : 			*size = sizeof(xsd__boolean);

	mov	DWORD PTR [eax], 16			; 00000010H
$LN7@soap_insta@10:

; 2501 : 		((xsd__boolean*)cp->ptr)->soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+8], ebp

; 2502 : 	}
; 2503 : 	else

	jmp	$LN1@soap_insta@10
$LN8@soap_insta@10:

; 2504 : 	{	cp->ptr = (void*)new xsd__boolean[n];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 16					; 00000010H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T458057[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	cmp	eax, ebx
	je	SHORT $LN14@soap_insta@10
	push	OFFSET ??1xsd__boolean@@UAE@XZ		; xsd__boolean::~xsd__boolean
	push	OFFSET ??0xsd__boolean@@QAE@XZ		; xsd__boolean::xsd__boolean
	push	edi
	lea	ebp, DWORD PTR [eax+4]
	push	16					; 00000010H
	push	ebp
	mov	DWORD PTR [eax], edi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	jmp	SHORT $LN15@soap_insta@10
$LN14@soap_insta@10:
	xor	ebp, ebp
$LN15@soap_insta@10:
	mov	DWORD PTR [esi+4], ebp

; 2505 : 		if (!cp->ptr)

	cmp	ebp, ebx
	jne	SHORT $LN5@soap_insta@10

; 2506 : 		{	soap->error = SOAP_EOM;

	mov	ecx, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [ecx+90460], 20		; 00000014H
$LN27@soap_insta@10:

; 2507 : 			return NULL;

	xor	eax, eax

; 2516 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN5@soap_insta@10:

; 2508 : 		}
; 2509 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN4@soap_insta@10

; 2510 : 			*size = n * sizeof(xsd__boolean);

	mov	edx, edi
	shl	edx, 4
	mov	DWORD PTR [eax], edx
$LN4@soap_insta@10:

; 2511 : 		for (int i = 0; i < n; i++)

	cmp	edi, ebx
	jle	SHORT $LN1@soap_insta@10
	xor	eax, eax
	npad	3
$LL3@soap_insta@10:

; 2512 : 			((xsd__boolean*)cp->ptr)[i].soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [eax+ecx+8], edx
	add	eax, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL3@soap_insta@10
$LN1@soap_insta@10:

; 2513 : 	}
; 2514 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 2515 : 	return (xsd__boolean*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]

; 2516 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
__unwindfunclet$?soap_instantiate_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@HPBD1PAI@Z$1:
	mov	eax, DWORD PTR $T458057[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?soap_instantiate_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@HPBD1PAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?soap_instantiate_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@HPBD1PAI@Z
	jmp	___CxxFrameHandler3
?soap_instantiate_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate_xsd__boolean
PUBLIC	?soap_new_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@H@Z ; soap_new_xsd__boolean
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@H@Z PROC ; soap_new_xsd__boolean
; _soap$ = eax
; _n$ = ecx

; 2484 : {	return soap_instantiate_xsd__boolean(soap, n, NULL, NULL, NULL);

	push	0
	push	eax
	call	?soap_instantiate_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__boolean
	add	esp, 8

; 2485 : }

	ret	0
?soap_new_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@H@Z ENDP ; soap_new_xsd__boolean
_TEXT	ENDS
PUBLIC	?soap_instantiate_xsd__float@@YAPAVxsd__float@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__float
__unwindtable$?soap_instantiate_xsd__float@@YAPAVxsd__float@@PAUsoap@@HPBD1PAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate_xsd__float@@YAPAVxsd__float@@PAUsoap@@HPBD1PAI@Z$1
__ehfuncinfo$?soap_instantiate_xsd__float@@YAPAVxsd__float@@PAUsoap@@HPBD1PAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?soap_instantiate_xsd__float@@YAPAVxsd__float@@PAUsoap@@HPBD1PAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T458090 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_soap$ = 8						; size = 4
_size$ = 12						; size = 4
?soap_instantiate_xsd__float@@YAPAVxsd__float@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate_xsd__float
; _n$ = ecx

; 2383 : {

	push	-1
	push	__ehhandler$?soap_instantiate_xsd__float@@YAPAVxsd__float@@PAUsoap@@HPBD1PAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ebp, DWORD PTR _soap$[esp+32]

; 2384 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__float(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 2385 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__float, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	ebx, ebx
	add	esp, 4
	cmp	esi, ebx
	je	$LN27@soap_insta@11

; 2386 : 	if (!cp)
; 2387 : 		return NULL;
; 2388 : 	if (n < 0)

	cmp	edi, ebx
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 12			; 0000000cH
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebp+96], esi
	jge	SHORT $LN8@soap_insta@11

; 2389 : 	{	cp->ptr = (void*)new xsd__float;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN12@soap_insta@11
	xorps	xmm0, xmm0
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax], OFFSET ??_7xsd__float@@6B@
	movss	DWORD PTR [eax+12], xmm0
	jmp	SHORT $LN13@soap_insta@11
$LN12@soap_insta@11:
	xor	eax, eax
$LN13@soap_insta@11:
	mov	DWORD PTR [esi+4], eax

; 2390 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN7@soap_insta@11

; 2391 : 			*size = sizeof(xsd__float);

	mov	DWORD PTR [eax], 16			; 00000010H
$LN7@soap_insta@11:

; 2392 : 		((xsd__float*)cp->ptr)->soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+8], ebp

; 2393 : 	}
; 2394 : 	else

	jmp	$LN1@soap_insta@11
$LN8@soap_insta@11:

; 2395 : 	{	cp->ptr = (void*)new xsd__float[n];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 16					; 00000010H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T458090[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	cmp	eax, ebx
	je	SHORT $LN14@soap_insta@11
	push	OFFSET ??1xsd__float@@UAE@XZ		; xsd__float::~xsd__float
	push	OFFSET ??0xsd__float@@QAE@XZ		; xsd__float::xsd__float
	push	edi
	lea	ebx, DWORD PTR [eax+4]
	push	16					; 00000010H
	push	ebx
	mov	DWORD PTR [eax], edi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
$LN14@soap_insta@11:
	mov	DWORD PTR [esi+4], ebx

; 2396 : 		if (!cp->ptr)

	test	ebx, ebx
	jne	SHORT $LN5@soap_insta@11

; 2397 : 		{	soap->error = SOAP_EOM;

	mov	DWORD PTR [ebp+90460], 20		; 00000014H
$LN27@soap_insta@11:

; 2398 : 			return NULL;

	xor	eax, eax

; 2407 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN5@soap_insta@11:

; 2399 : 		}
; 2400 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	test	eax, eax
	je	SHORT $LN4@soap_insta@11

; 2401 : 			*size = n * sizeof(xsd__float);

	mov	ecx, edi
	shl	ecx, 4
	mov	DWORD PTR [eax], ecx
$LN4@soap_insta@11:

; 2402 : 		for (int i = 0; i < n; i++)

	test	edi, edi
	jle	SHORT $LN1@soap_insta@11
	xor	eax, eax
	npad	6
$LL3@soap_insta@11:

; 2403 : 			((xsd__float*)cp->ptr)[i].soap = soap;

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+edx+8], ebp
	add	eax, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL3@soap_insta@11
$LN1@soap_insta@11:

; 2404 : 	}
; 2405 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 2406 : 	return (xsd__float*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]

; 2407 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
__unwindfunclet$?soap_instantiate_xsd__float@@YAPAVxsd__float@@PAUsoap@@HPBD1PAI@Z$1:
	mov	eax, DWORD PTR $T458090[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?soap_instantiate_xsd__float@@YAPAVxsd__float@@PAUsoap@@HPBD1PAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?soap_instantiate_xsd__float@@YAPAVxsd__float@@PAUsoap@@HPBD1PAI@Z
	jmp	___CxxFrameHandler3
?soap_instantiate_xsd__float@@YAPAVxsd__float@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate_xsd__float
PUBLIC	?soap_new_xsd__float@@YAPAVxsd__float@@PAUsoap@@H@Z ; soap_new_xsd__float
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new_xsd__float@@YAPAVxsd__float@@PAUsoap@@H@Z PROC ; soap_new_xsd__float
; _soap$ = eax
; _n$ = ecx

; 2375 : {	return soap_instantiate_xsd__float(soap, n, NULL, NULL, NULL);

	push	0
	push	eax
	call	?soap_instantiate_xsd__float@@YAPAVxsd__float@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__float
	add	esp, 8

; 2376 : }

	ret	0
?soap_new_xsd__float@@YAPAVxsd__float@@PAUsoap@@H@Z ENDP ; soap_new_xsd__float
_TEXT	ENDS
PUBLIC	?soap_instantiate_xsd__int@@YAPAVxsd__int@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__int
__unwindtable$?soap_instantiate_xsd__int@@YAPAVxsd__int@@PAUsoap@@HPBD1PAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate_xsd__int@@YAPAVxsd__int@@PAUsoap@@HPBD1PAI@Z$1
__ehfuncinfo$?soap_instantiate_xsd__int@@YAPAVxsd__int@@PAUsoap@@HPBD1PAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?soap_instantiate_xsd__int@@YAPAVxsd__int@@PAUsoap@@HPBD1PAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T458123 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_soap$ = 8						; size = 4
_size$ = 12						; size = 4
?soap_instantiate_xsd__int@@YAPAVxsd__int@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate_xsd__int
; _n$ = ecx

; 2274 : {

	push	-1
	push	__ehhandler$?soap_instantiate_xsd__int@@YAPAVxsd__int@@PAUsoap@@HPBD1PAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 2275 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 2276 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__int, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	ebp, ebp
	add	esp, 4
	cmp	esi, ebp
	je	$LN27@soap_insta@12

; 2277 : 	if (!cp)
; 2278 : 		return NULL;
; 2279 : 	if (n < 0)

	cmp	edi, ebp
	mov	ebx, DWORD PTR _soap$[esp+32]
	mov	eax, DWORD PTR [ebx+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 14			; 0000000eH
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], ebp
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebx+96], esi
	jge	SHORT $LN8@soap_insta@12

; 2280 : 	{	cp->ptr = (void*)new xsd__int;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebp
	je	SHORT $LN12@soap_insta@12
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax], OFFSET ??_7xsd__int@@6B@
	mov	DWORD PTR [eax+12], ebp
	jmp	SHORT $LN13@soap_insta@12
$LN12@soap_insta@12:
	xor	eax, eax
$LN13@soap_insta@12:
	mov	DWORD PTR [esi+4], eax

; 2281 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebp
	je	SHORT $LN7@soap_insta@12

; 2282 : 			*size = sizeof(xsd__int);

	mov	DWORD PTR [eax], 16			; 00000010H
$LN7@soap_insta@12:

; 2283 : 		((xsd__int*)cp->ptr)->soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+8], ebx

; 2284 : 	}
; 2285 : 	else

	jmp	$LN1@soap_insta@12
$LN8@soap_insta@12:

; 2286 : 	{	cp->ptr = (void*)new xsd__int[n];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 16					; 00000010H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T458123[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], ebp
	cmp	eax, ebp
	je	SHORT $LN14@soap_insta@12
	push	OFFSET ??1xsd__int@@UAE@XZ		; xsd__int::~xsd__int
	push	OFFSET ??0xsd__int@@QAE@XZ		; xsd__int::xsd__int
	push	edi
	lea	ebx, DWORD PTR [eax+4]
	push	16					; 00000010H
	push	ebx
	mov	DWORD PTR [eax], edi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	jmp	SHORT $LN15@soap_insta@12
$LN14@soap_insta@12:
	xor	ebx, ebx
$LN15@soap_insta@12:
	mov	DWORD PTR [esi+4], ebx

; 2287 : 		if (!cp->ptr)

	cmp	ebx, ebp
	jne	SHORT $LN5@soap_insta@12

; 2288 : 		{	soap->error = SOAP_EOM;

	mov	ecx, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [ecx+90460], 20		; 00000014H
$LN27@soap_insta@12:

; 2289 : 			return NULL;

	xor	eax, eax

; 2298 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN5@soap_insta@12:

; 2290 : 		}
; 2291 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebp
	je	SHORT $LN4@soap_insta@12

; 2292 : 			*size = n * sizeof(xsd__int);

	mov	edx, edi
	shl	edx, 4
	mov	DWORD PTR [eax], edx
$LN4@soap_insta@12:

; 2293 : 		for (int i = 0; i < n; i++)

	cmp	edi, ebp
	jle	SHORT $LN1@soap_insta@12
	xor	eax, eax
	npad	3
$LL3@soap_insta@12:

; 2294 : 			((xsd__int*)cp->ptr)[i].soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [eax+ecx+8], edx
	add	eax, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL3@soap_insta@12
$LN1@soap_insta@12:

; 2295 : 	}
; 2296 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 2297 : 	return (xsd__int*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]

; 2298 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
__unwindfunclet$?soap_instantiate_xsd__int@@YAPAVxsd__int@@PAUsoap@@HPBD1PAI@Z$1:
	mov	eax, DWORD PTR $T458123[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?soap_instantiate_xsd__int@@YAPAVxsd__int@@PAUsoap@@HPBD1PAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?soap_instantiate_xsd__int@@YAPAVxsd__int@@PAUsoap@@HPBD1PAI@Z
	jmp	___CxxFrameHandler3
?soap_instantiate_xsd__int@@YAPAVxsd__int@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate_xsd__int
PUBLIC	?soap_new_xsd__int@@YAPAVxsd__int@@PAUsoap@@H@Z	; soap_new_xsd__int
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new_xsd__int@@YAPAVxsd__int@@PAUsoap@@H@Z PROC	; soap_new_xsd__int
; _soap$ = eax
; _n$ = ecx

; 2266 : {	return soap_instantiate_xsd__int(soap, n, NULL, NULL, NULL);

	push	0
	push	eax
	call	?soap_instantiate_xsd__int@@YAPAVxsd__int@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__int
	add	esp, 8

; 2267 : }

	ret	0
?soap_new_xsd__int@@YAPAVxsd__int@@PAUsoap@@H@Z ENDP	; soap_new_xsd__int
_TEXT	ENDS
PUBLIC	?soap_instantiate_xsd__long@@YAPAVxsd__long@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__long
__unwindtable$?soap_instantiate_xsd__long@@YAPAVxsd__long@@PAUsoap@@HPBD1PAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate_xsd__long@@YAPAVxsd__long@@PAUsoap@@HPBD1PAI@Z$1
__ehfuncinfo$?soap_instantiate_xsd__long@@YAPAVxsd__long@@PAUsoap@@HPBD1PAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?soap_instantiate_xsd__long@@YAPAVxsd__long@@PAUsoap@@HPBD1PAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T458156 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_soap$ = 8						; size = 4
_size$ = 12						; size = 4
?soap_instantiate_xsd__long@@YAPAVxsd__long@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate_xsd__long
; _n$ = ecx

; 2165 : {

	push	-1
	push	__ehhandler$?soap_instantiate_xsd__long@@YAPAVxsd__long@@PAUsoap@@HPBD1PAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 2166 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__long(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 2167 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__long, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	ebp, ebp
	add	esp, 4
	cmp	esi, ebp
	je	$LN27@soap_insta@13

; 2168 : 	if (!cp)
; 2169 : 		return NULL;
; 2170 : 	if (n < 0)

	cmp	edi, ebp
	mov	ebx, DWORD PTR _soap$[esp+32]
	mov	eax, DWORD PTR [ebx+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 15			; 0000000fH
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], ebp
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebx+96], esi
	jge	SHORT $LN8@soap_insta@13

; 2171 : 	{	cp->ptr = (void*)new xsd__long;

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebp
	je	SHORT $LN12@soap_insta@13
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax], OFFSET ??_7xsd__long@@6B@
	mov	DWORD PTR [eax+16], ebp
	mov	DWORD PTR [eax+20], ebp
	jmp	SHORT $LN13@soap_insta@13
$LN12@soap_insta@13:
	xor	eax, eax
$LN13@soap_insta@13:
	mov	DWORD PTR [esi+4], eax

; 2172 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebp
	je	SHORT $LN7@soap_insta@13

; 2173 : 			*size = sizeof(xsd__long);

	mov	DWORD PTR [eax], 24			; 00000018H
$LN7@soap_insta@13:

; 2174 : 		((xsd__long*)cp->ptr)->soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+8], ebx

; 2175 : 	}
; 2176 : 	else

	jmp	$LN1@soap_insta@13
$LN8@soap_insta@13:

; 2177 : 	{	cp->ptr = (void*)new xsd__long[n];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 24					; 00000018H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T458156[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], ebp
	cmp	eax, ebp
	je	SHORT $LN14@soap_insta@13
	push	OFFSET ??1xsd__long@@UAE@XZ		; xsd__long::~xsd__long
	push	OFFSET ??0xsd__long@@QAE@XZ		; xsd__long::xsd__long
	push	edi
	lea	ebx, DWORD PTR [eax+4]
	push	24					; 00000018H
	push	ebx
	mov	DWORD PTR [eax], edi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	jmp	SHORT $LN15@soap_insta@13
$LN14@soap_insta@13:
	xor	ebx, ebx
$LN15@soap_insta@13:
	mov	DWORD PTR [esi+4], ebx

; 2178 : 		if (!cp->ptr)

	cmp	ebx, ebp
	jne	SHORT $LN5@soap_insta@13

; 2179 : 		{	soap->error = SOAP_EOM;

	mov	ecx, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [ecx+90460], 20		; 00000014H
$LN27@soap_insta@13:

; 2180 : 			return NULL;

	xor	eax, eax

; 2189 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN5@soap_insta@13:

; 2181 : 		}
; 2182 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebp
	je	SHORT $LN4@soap_insta@13

; 2183 : 			*size = n * sizeof(xsd__long);

	lea	edx, DWORD PTR [edi+edi*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR [eax], edx
$LN4@soap_insta@13:

; 2184 : 		for (int i = 0; i < n; i++)

	cmp	edi, ebp
	jle	SHORT $LN1@soap_insta@13
	xor	eax, eax
$LL3@soap_insta@13:

; 2185 : 			((xsd__long*)cp->ptr)[i].soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [eax+ecx+8], edx
	add	eax, 24					; 00000018H
	sub	edi, 1
	jne	SHORT $LL3@soap_insta@13
$LN1@soap_insta@13:

; 2186 : 	}
; 2187 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 2188 : 	return (xsd__long*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]

; 2189 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
__unwindfunclet$?soap_instantiate_xsd__long@@YAPAVxsd__long@@PAUsoap@@HPBD1PAI@Z$1:
	mov	eax, DWORD PTR $T458156[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?soap_instantiate_xsd__long@@YAPAVxsd__long@@PAUsoap@@HPBD1PAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?soap_instantiate_xsd__long@@YAPAVxsd__long@@PAUsoap@@HPBD1PAI@Z
	jmp	___CxxFrameHandler3
?soap_instantiate_xsd__long@@YAPAVxsd__long@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate_xsd__long
PUBLIC	?soap_new_xsd__long@@YAPAVxsd__long@@PAUsoap@@H@Z ; soap_new_xsd__long
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new_xsd__long@@YAPAVxsd__long@@PAUsoap@@H@Z PROC	; soap_new_xsd__long
; _soap$ = eax
; _n$ = ecx

; 2157 : {	return soap_instantiate_xsd__long(soap, n, NULL, NULL, NULL);

	push	0
	push	eax
	call	?soap_instantiate_xsd__long@@YAPAVxsd__long@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__long
	add	esp, 8

; 2158 : }

	ret	0
?soap_new_xsd__long@@YAPAVxsd__long@@PAUsoap@@H@Z ENDP	; soap_new_xsd__long
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4xsd__string@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4xsd__string@@QAEAAV0@ABV0@@Z PROC			; xsd__string::operator=, COMDAT
; _this$ = esi
; ___that$ = eax
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [eax+8]
	push	-1
	push	0
	add	eax, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, esi
	ret	0
??4xsd__string@@QAEAAV0@ABV0@@Z ENDP			; xsd__string::operator=
_TEXT	ENDS
PUBLIC	?soap_copy_xsd__string@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy_xsd__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_copy_xsd__string@@YAXPAUsoap@@HHPAXIPBXI@Z PROC	; soap_copy_xsd__string
; _p$ = ecx
; _q$ = eax

; 2083 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string %p -> %p\n", q, p));
; 2084 : 	*(xsd__string*)p = *(xsd__string*)q;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	push	-1
	push	0
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], edx
	push	eax
	add	ecx, 12					; 0000000cH
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2085 : }

	ret	0
?soap_copy_xsd__string@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP	; soap_copy_xsd__string
_TEXT	ENDS
PUBLIC	?soap_instantiate_xsd__string@@YAPAVxsd__string@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__string
__unwindtable$?soap_instantiate_xsd__string@@YAPAVxsd__string@@PAUsoap@@HPBD1PAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate_xsd__string@@YAPAVxsd__string@@PAUsoap@@HPBD1PAI@Z$1
__ehfuncinfo$?soap_instantiate_xsd__string@@YAPAVxsd__string@@PAUsoap@@HPBD1PAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?soap_instantiate_xsd__string@@YAPAVxsd__string@@PAUsoap@@HPBD1PAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T458224 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_soap$ = 8						; size = 4
_size$ = 12						; size = 4
?soap_instantiate_xsd__string@@YAPAVxsd__string@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate_xsd__string
; _n$ = ecx

; 2056 : {

	push	-1
	push	__ehhandler$?soap_instantiate_xsd__string@@YAPAVxsd__string@@PAUsoap@@HPBD1PAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 2057 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 2058 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__string, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	ebx, ebx
	add	esp, 4
	cmp	esi, ebx
	je	$LN59@soap_insta@14

; 2059 : 	if (!cp)
; 2060 : 		return NULL;
; 2061 : 	if (n < 0)

	cmp	edi, ebx
	mov	ebp, DWORD PTR _soap$[esp+32]
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 17			; 00000011H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebp+96], esi
	jge	SHORT $LN8@soap_insta@14

; 2062 : 	{	cp->ptr = (void*)new xsd__string;

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN12@soap_insta@14
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax], OFFSET ??_7xsd__string@@6B@
	mov	DWORD PTR [eax+36], 15			; 0000000fH
	mov	DWORD PTR [eax+32], ebx
	mov	BYTE PTR [eax+16], bl
	jmp	SHORT $LN13@soap_insta@14
$LN12@soap_insta@14:
	xor	eax, eax
$LN13@soap_insta@14:
	mov	DWORD PTR [esi+4], eax

; 2063 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN7@soap_insta@14

; 2064 : 			*size = sizeof(xsd__string);

	mov	DWORD PTR [eax], 40			; 00000028H
$LN7@soap_insta@14:

; 2065 : 		((xsd__string*)cp->ptr)->soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+8], ebp

; 2066 : 	}
; 2067 : 	else

	jmp	$LN1@soap_insta@14
$LN8@soap_insta@14:

; 2068 : 	{	cp->ptr = (void*)new xsd__string[n];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 40					; 00000028H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T458224[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	cmp	eax, ebx
	je	SHORT $LN14@soap_insta@14
	push	OFFSET ??1xsd__string@@UAE@XZ		; xsd__string::~xsd__string
	push	OFFSET ??0xsd__string@@QAE@XZ		; xsd__string::xsd__string
	push	edi
	lea	ebp, DWORD PTR [eax+4]
	push	40					; 00000028H
	push	ebp
	mov	DWORD PTR [eax], edi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	jmp	SHORT $LN15@soap_insta@14
$LN14@soap_insta@14:
	xor	ebp, ebp
$LN15@soap_insta@14:
	mov	DWORD PTR [esi+4], ebp

; 2069 : 		if (!cp->ptr)

	cmp	ebp, ebx
	jne	SHORT $LN5@soap_insta@14

; 2070 : 		{	soap->error = SOAP_EOM;

	mov	ecx, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [ecx+90460], 20		; 00000014H
$LN59@soap_insta@14:

; 2071 : 			return NULL;

	xor	eax, eax

; 2080 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN5@soap_insta@14:

; 2072 : 		}
; 2073 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN4@soap_insta@14

; 2074 : 			*size = n * sizeof(xsd__string);

	lea	edx, DWORD PTR [edi+edi*4]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR [eax], edx
$LN4@soap_insta@14:

; 2075 : 		for (int i = 0; i < n; i++)

	cmp	edi, ebx
	jle	SHORT $LN1@soap_insta@14
	xor	eax, eax
	npad	5
$LL3@soap_insta@14:

; 2076 : 			((xsd__string*)cp->ptr)[i].soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _soap$[esp+32]
	mov	DWORD PTR [eax+ecx+8], edx
	add	eax, 40					; 00000028H
	sub	edi, 1
	jne	SHORT $LL3@soap_insta@14
$LN1@soap_insta@14:

; 2077 : 	}
; 2078 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 2079 : 	return (xsd__string*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]

; 2080 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
__unwindfunclet$?soap_instantiate_xsd__string@@YAPAVxsd__string@@PAUsoap@@HPBD1PAI@Z$1:
	mov	eax, DWORD PTR $T458224[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?soap_instantiate_xsd__string@@YAPAVxsd__string@@PAUsoap@@HPBD1PAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?soap_instantiate_xsd__string@@YAPAVxsd__string@@PAUsoap@@HPBD1PAI@Z
	jmp	___CxxFrameHandler3
?soap_instantiate_xsd__string@@YAPAVxsd__string@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate_xsd__string
PUBLIC	?soap_new_xsd__string@@YAPAVxsd__string@@PAUsoap@@H@Z ; soap_new_xsd__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new_xsd__string@@YAPAVxsd__string@@PAUsoap@@H@Z PROC ; soap_new_xsd__string
; _soap$ = eax
; _n$ = ecx

; 2048 : {	return soap_instantiate_xsd__string(soap, n, NULL, NULL, NULL);

	push	0
	push	eax
	call	?soap_instantiate_xsd__string@@YAPAVxsd__string@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__string
	add	esp, 8

; 2049 : }

	ret	0
?soap_new_xsd__string@@YAPAVxsd__string@@PAUsoap@@H@Z ENDP ; soap_new_xsd__string
_TEXT	ENDS
PUBLIC	?soap_copy_std__string@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy_std__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_st$ = 12						; size = 4
_tt$ = 16						; size = 4
_p$ = 20						; size = 4
_len$ = 24						; size = 4
_q$ = 28						; size = 4
_n$ = 32						; size = 4
?soap_copy_std__string@@YAXPAUsoap@@HHPAXIPBXI@Z PROC	; soap_copy_std__string

; 1972 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
; 1973 : 	*(std::string*)p = *(std::string*)q;

	mov	eax, DWORD PTR _q$[esp-4]
	mov	ecx, DWORD PTR _p$[esp-4]
	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1974 : }

	ret	0
?soap_copy_std__string@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP	; soap_copy_std__string
_TEXT	ENDS
PUBLIC	?soap_instantiate_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_std__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_size$ = 8						; size = 4
?soap_instantiate_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate_std__string
; _soap$ = edi

; 1948 : {

	push	ebp
	mov	ebp, DWORD PTR _size$[esp]
	push	esi

; 1949 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 1950 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN51@soap_insta@15
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 18			; 00000012H
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete

; 1953 : 	if (n < 0)
; 1954 : 	{	cp->ptr = (void*)new std::string;

	push	28					; 0000001cH
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@soap_insta@15
	mov	DWORD PTR [eax+24], 15			; 0000000fH
	mov	DWORD PTR [eax+20], 0
	mov	BYTE PTR [eax+4], 0
	jmp	SHORT $LN10@soap_insta@15
$LN51@soap_insta@15:
	pop	esi

; 1951 : 	if (!cp)
; 1952 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 1969 : }

	ret	0
$LN9@soap_insta@15:

; 1953 : 	if (n < 0)
; 1954 : 	{	cp->ptr = (void*)new std::string;

	xor	eax, eax
$LN10@soap_insta@15:
	mov	DWORD PTR [esi+4], eax

; 1955 : 		if (size)

	test	ebp, ebp
	je	SHORT $LN4@soap_insta@15

; 1956 : 			*size = sizeof(std::string);

	mov	DWORD PTR [ebp], 28			; 0000001cH
$LN4@soap_insta@15:

; 1957 : 	}
; 1958 : 	else
; 1959 : 	{	cp->ptr = (void*)new std::string[n];
; 1960 : 		if (!cp->ptr)
; 1961 : 		{	soap->error = SOAP_EOM;
; 1962 : 			return NULL;
; 1963 : 		}
; 1964 : 		if (size)
; 1965 : 			*size = n * sizeof(std::string);
; 1966 : 	}
; 1967 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 1968 : 	return (std::string*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebp

; 1969 : }

	ret	0
?soap_instantiate_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate_std__string
_TEXT	ENDS
PUBLIC	?soap_new_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@H@Z ; soap_new_std__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@H@Z PROC ; soap_new_std__string
; _soap$ = edi

; 1940 : {	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);

	push	esi
	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN53@soap_new_s
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 18			; 00000012H
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	push	28					; 0000001cH
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@soap_new_s
	mov	DWORD PTR [eax+24], 15			; 0000000fH
	mov	DWORD PTR [eax+20], 0
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [esi+4], eax
	pop	esi

; 1941 : }

	ret	0
$LN53@soap_new_s:

; 1940 : {	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);

	xor	eax, eax
	pop	esi

; 1941 : }

	ret	0

; 1940 : {	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);

$LN11@soap_new_s:
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	pop	esi

; 1941 : }

	ret	0
?soap_new_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@H@Z ENDP ; soap_new_std__string
_TEXT	ENDS
PUBLIC	?soap_out_std__string@@YAHPAUsoap@@PBDHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; soap_out_std__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_std__string@@YAHPAUsoap@@PBDHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z PROC ; soap_out_std__string
; _tag$ = ecx
; _id$ = eax

; 1895 : {

	push	ebx
	mov	ebx, DWORD PTR _s$[esp]
	push	ebp
	mov	ebp, DWORD PTR _type$[esp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+12]

; 1896 : 	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())

	test	DWORD PTR [edi+8], 8388608		; 00800000H
	mov	esi, ecx
	je	SHORT $LN3@soap_out_s
	cmp	DWORD PTR [ebx+20], 0
	jne	SHORT $LN3@soap_out_s

; 1897 : 		return soap_element_null(soap, tag, id, type);

	push	ebp
	push	edi
	call	_soap_element_null
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1900 : 	return SOAP_OK;
; 1901 : }

	ret	0
$LN3@soap_out_s:

; 1898 : 	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))

	push	eax
	push	edi
	mov	eax, 18					; 00000012H
	mov	ecx, ebx
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN19@soap_out_s
	push	ebp
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@soap_out_s
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN10@soap_out_s
$LN8@soap_out_s:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN10@soap_out_s:
	test	eax, eax
	jne	SHORT $LN1@soap_out_s
$LN19@soap_out_s:
	cmp	DWORD PTR [ebx+24], 16			; 00000010H
	jb	SHORT $LN16@soap_out_s
	mov	eax, DWORD PTR [ebx+4]
	jmp	SHORT $LN17@soap_out_s
$LN16@soap_out_s:
	lea	eax, DWORD PTR [ebx+4]
$LN17@soap_out_s:
	push	0
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_out_s
	mov	eax, edi
	call	_soap_element_end_out
	test	eax, eax
	jne	SHORT $LN1@soap_out_s
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1900 : 	return SOAP_OK;
; 1901 : }

	ret	0
$LN1@soap_out_s:

; 1899 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1900 : 	return SOAP_OK;
; 1901 : }

	ret	0
?soap_out_std__string@@YAHPAUsoap@@PBDHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ENDP ; soap_out_std__string
_TEXT	ENDS
PUBLIC	?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSessionIDElement
__unwindtable$?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z$1
__ehfuncinfo$?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T458827 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_soap$ = 8						; size = 4
_size$ = 12						; size = 4
?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate__ns2__getSessionIDElement
; _n$ = ecx

; 1847 : {

	push	-1
	push	__ehhandler$?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ebp, DWORD PTR _soap$[esp+32]

; 1848 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getSessionIDElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 1849 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getSessionIDElement, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	ebx, ebx
	add	esp, 4
	cmp	esi, ebx
	je	$LN25@soap_insta@16

; 1850 : 	if (!cp)
; 1851 : 		return NULL;
; 1852 : 	if (n < 0)

	cmp	edi, ebx
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 19			; 00000013H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebp+96], esi
	jge	SHORT $LN8@soap_insta@16

; 1853 : 	{	cp->ptr = (void*)new _ns2__getSessionIDElement;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN12@soap_insta@16
	mov	DWORD PTR [eax], OFFSET ??_7_ns2__getSessionIDElement@@6B@
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN13@soap_insta@16
$LN12@soap_insta@16:
	xor	eax, eax
$LN13@soap_insta@16:
	mov	DWORD PTR [esi+4], eax

; 1854 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN7@soap_insta@16

; 1855 : 			*size = sizeof(_ns2__getSessionIDElement);

	mov	DWORD PTR [eax], 12			; 0000000cH
$LN7@soap_insta@16:

; 1856 : 		((_ns2__getSessionIDElement*)cp->ptr)->soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+8], ebp

; 1857 : 	}
; 1858 : 	else

	jmp	$LN1@soap_insta@16
$LN8@soap_insta@16:

; 1859 : 	{	cp->ptr = (void*)new _ns2__getSessionIDElement[n];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 12					; 0000000cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T458827[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	cmp	eax, ebx
	je	SHORT $LN14@soap_insta@16
	push	OFFSET ??1_ns2__getSessionIDElement@@UAE@XZ ; _ns2__getSessionIDElement::~_ns2__getSessionIDElement
	push	OFFSET ??0_ns2__getSessionIDElement@@QAE@XZ ; _ns2__getSessionIDElement::_ns2__getSessionIDElement
	push	edi
	lea	ebx, DWORD PTR [eax+4]
	push	12					; 0000000cH
	push	ebx
	mov	DWORD PTR [eax], edi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
$LN14@soap_insta@16:
	mov	DWORD PTR [esi+4], ebx

; 1860 : 		if (!cp->ptr)

	test	ebx, ebx
	jne	SHORT $LN5@soap_insta@16

; 1861 : 		{	soap->error = SOAP_EOM;

	mov	DWORD PTR [ebp+90460], 20		; 00000014H
$LN25@soap_insta@16:

; 1862 : 			return NULL;

	xor	eax, eax

; 1871 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN5@soap_insta@16:

; 1863 : 		}
; 1864 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	test	eax, eax
	je	SHORT $LN4@soap_insta@16

; 1865 : 			*size = n * sizeof(_ns2__getSessionIDElement);

	lea	ecx, DWORD PTR [edi+edi*2]
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR [eax], ecx
$LN4@soap_insta@16:

; 1866 : 		for (int i = 0; i < n; i++)

	test	edi, edi
	jle	SHORT $LN1@soap_insta@16
	xor	eax, eax
$LL3@soap_insta@16:

; 1867 : 			((_ns2__getSessionIDElement*)cp->ptr)[i].soap = soap;

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+edx+8], ebp
	add	eax, 12					; 0000000cH
	sub	edi, 1
	jne	SHORT $LL3@soap_insta@16
$LN1@soap_insta@16:

; 1868 : 	}
; 1869 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 1870 : 	return (_ns2__getSessionIDElement*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]

; 1871 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
__unwindfunclet$?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z$1:
	mov	eax, DWORD PTR $T458827[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z
	jmp	___CxxFrameHandler3
?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate__ns2__getSessionIDElement
PUBLIC	?soap_new__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@H@Z ; soap_new__ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@H@Z PROC ; soap_new__ns2__getSessionIDElement
; _soap$ = eax
; _n$ = ecx

; 1839 : {	return soap_instantiate__ns2__getSessionIDElement(soap, n, NULL, NULL, NULL);

	push	0
	push	eax
	call	?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSessionIDElement
	add	esp, 8

; 1840 : }

	ret	0
?soap_new__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@H@Z ENDP ; soap_new__ns2__getSessionIDElement
_TEXT	ENDS
PUBLIC	?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSessionIDResponseElement
__unwindtable$?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z$1
__ehfuncinfo$?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T458855 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_soap$ = 8						; size = 4
_size$ = 12						; size = 4
?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate__ns2__getSessionIDResponseElement
; _n$ = ecx

; 1709 : {

	push	-1
	push	__ehhandler$?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ebp, DWORD PTR _soap$[esp+32]

; 1710 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getSessionIDResponseElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 1711 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getSessionIDResponseElement, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	ebx, ebx
	add	esp, 4
	cmp	esi, ebx
	je	$LN25@soap_insta@17

; 1712 : 	if (!cp)
; 1713 : 		return NULL;
; 1714 : 	if (n < 0)

	cmp	edi, ebx
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 20			; 00000014H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebp+96], esi
	jge	SHORT $LN8@soap_insta@17

; 1715 : 	{	cp->ptr = (void*)new _ns2__getSessionIDResponseElement;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN12@soap_insta@17
	mov	DWORD PTR [eax], OFFSET ??_7_ns2__getSessionIDResponseElement@@6B@
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN13@soap_insta@17
$LN12@soap_insta@17:
	xor	eax, eax
$LN13@soap_insta@17:
	mov	DWORD PTR [esi+4], eax

; 1716 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN7@soap_insta@17

; 1717 : 			*size = sizeof(_ns2__getSessionIDResponseElement);

	mov	DWORD PTR [eax], 12			; 0000000cH
$LN7@soap_insta@17:

; 1718 : 		((_ns2__getSessionIDResponseElement*)cp->ptr)->soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+8], ebp

; 1719 : 	}
; 1720 : 	else

	jmp	$LN1@soap_insta@17
$LN8@soap_insta@17:

; 1721 : 	{	cp->ptr = (void*)new _ns2__getSessionIDResponseElement[n];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 12					; 0000000cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T458855[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	cmp	eax, ebx
	je	SHORT $LN14@soap_insta@17
	push	OFFSET ??1_ns2__getSessionIDResponseElement@@UAE@XZ ; _ns2__getSessionIDResponseElement::~_ns2__getSessionIDResponseElement
	push	OFFSET ??0_ns2__getSessionIDResponseElement@@QAE@XZ ; _ns2__getSessionIDResponseElement::_ns2__getSessionIDResponseElement
	push	edi
	lea	ebx, DWORD PTR [eax+4]
	push	12					; 0000000cH
	push	ebx
	mov	DWORD PTR [eax], edi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
$LN14@soap_insta@17:
	mov	DWORD PTR [esi+4], ebx

; 1722 : 		if (!cp->ptr)

	test	ebx, ebx
	jne	SHORT $LN5@soap_insta@17

; 1723 : 		{	soap->error = SOAP_EOM;

	mov	DWORD PTR [ebp+90460], 20		; 00000014H
$LN25@soap_insta@17:

; 1724 : 			return NULL;

	xor	eax, eax

; 1733 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN5@soap_insta@17:

; 1725 : 		}
; 1726 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	test	eax, eax
	je	SHORT $LN4@soap_insta@17

; 1727 : 			*size = n * sizeof(_ns2__getSessionIDResponseElement);

	lea	ecx, DWORD PTR [edi+edi*2]
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR [eax], ecx
$LN4@soap_insta@17:

; 1728 : 		for (int i = 0; i < n; i++)

	test	edi, edi
	jle	SHORT $LN1@soap_insta@17
	xor	eax, eax
$LL3@soap_insta@17:

; 1729 : 			((_ns2__getSessionIDResponseElement*)cp->ptr)[i].soap = soap;

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+edx+8], ebp
	add	eax, 12					; 0000000cH
	sub	edi, 1
	jne	SHORT $LL3@soap_insta@17
$LN1@soap_insta@17:

; 1730 : 	}
; 1731 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 1732 : 	return (_ns2__getSessionIDResponseElement*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]

; 1733 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
__unwindfunclet$?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z$1:
	mov	eax, DWORD PTR $T458855[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z
	jmp	___CxxFrameHandler3
?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate__ns2__getSessionIDResponseElement
PUBLIC	?soap_new__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@H@Z ; soap_new__ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@H@Z PROC ; soap_new__ns2__getSessionIDResponseElement
; _soap$ = eax
; _n$ = ecx

; 1701 : {	return soap_instantiate__ns2__getSessionIDResponseElement(soap, n, NULL, NULL, NULL);

	push	0
	push	eax
	call	?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSessionIDResponseElement
	add	esp, 8

; 1702 : }

	ret	0
?soap_new__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@H@Z ENDP ; soap_new__ns2__getSessionIDResponseElement
_TEXT	ENDS
PUBLIC	?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSettingsFileElement
__unwindtable$?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z$1
__ehfuncinfo$?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T458883 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_soap$ = 8						; size = 4
_size$ = 12						; size = 4
?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate__ns2__getSettingsFileElement
; _n$ = ecx

; 1566 : {

	push	-1
	push	__ehhandler$?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ebp, DWORD PTR _soap$[esp+32]

; 1567 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getSettingsFileElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 1568 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getSettingsFileElement, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	ebx, ebx
	add	esp, 4
	cmp	esi, ebx
	je	$LN25@soap_insta@18

; 1569 : 	if (!cp)
; 1570 : 		return NULL;
; 1571 : 	if (n < 0)

	cmp	edi, ebx
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 21			; 00000015H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebp+96], esi
	jge	SHORT $LN8@soap_insta@18

; 1572 : 	{	cp->ptr = (void*)new _ns2__getSettingsFileElement;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN12@soap_insta@18
	mov	DWORD PTR [eax], OFFSET ??_7_ns2__getSettingsFileElement@@6B@
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN13@soap_insta@18
$LN12@soap_insta@18:
	xor	eax, eax
$LN13@soap_insta@18:
	mov	DWORD PTR [esi+4], eax

; 1573 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN7@soap_insta@18

; 1574 : 			*size = sizeof(_ns2__getSettingsFileElement);

	mov	DWORD PTR [eax], 12			; 0000000cH
$LN7@soap_insta@18:

; 1575 : 		((_ns2__getSettingsFileElement*)cp->ptr)->soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+8], ebp

; 1576 : 	}
; 1577 : 	else

	jmp	$LN1@soap_insta@18
$LN8@soap_insta@18:

; 1578 : 	{	cp->ptr = (void*)new _ns2__getSettingsFileElement[n];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 12					; 0000000cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T458883[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	cmp	eax, ebx
	je	SHORT $LN14@soap_insta@18
	push	OFFSET ??1_ns2__getSettingsFileElement@@UAE@XZ ; _ns2__getSettingsFileElement::~_ns2__getSettingsFileElement
	push	OFFSET ??0_ns2__getSettingsFileElement@@QAE@XZ ; _ns2__getSettingsFileElement::_ns2__getSettingsFileElement
	push	edi
	lea	ebx, DWORD PTR [eax+4]
	push	12					; 0000000cH
	push	ebx
	mov	DWORD PTR [eax], edi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
$LN14@soap_insta@18:
	mov	DWORD PTR [esi+4], ebx

; 1579 : 		if (!cp->ptr)

	test	ebx, ebx
	jne	SHORT $LN5@soap_insta@18

; 1580 : 		{	soap->error = SOAP_EOM;

	mov	DWORD PTR [ebp+90460], 20		; 00000014H
$LN25@soap_insta@18:

; 1581 : 			return NULL;

	xor	eax, eax

; 1590 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN5@soap_insta@18:

; 1582 : 		}
; 1583 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	test	eax, eax
	je	SHORT $LN4@soap_insta@18

; 1584 : 			*size = n * sizeof(_ns2__getSettingsFileElement);

	lea	ecx, DWORD PTR [edi+edi*2]
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR [eax], ecx
$LN4@soap_insta@18:

; 1585 : 		for (int i = 0; i < n; i++)

	test	edi, edi
	jle	SHORT $LN1@soap_insta@18
	xor	eax, eax
$LL3@soap_insta@18:

; 1586 : 			((_ns2__getSettingsFileElement*)cp->ptr)[i].soap = soap;

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+edx+8], ebp
	add	eax, 12					; 0000000cH
	sub	edi, 1
	jne	SHORT $LL3@soap_insta@18
$LN1@soap_insta@18:

; 1587 : 	}
; 1588 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 1589 : 	return (_ns2__getSettingsFileElement*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]

; 1590 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
__unwindfunclet$?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z$1:
	mov	eax, DWORD PTR $T458883[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z
	jmp	___CxxFrameHandler3
?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate__ns2__getSettingsFileElement
PUBLIC	?soap_new__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@H@Z ; soap_new__ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@H@Z PROC ; soap_new__ns2__getSettingsFileElement
; _soap$ = eax
; _n$ = ecx

; 1558 : {	return soap_instantiate__ns2__getSettingsFileElement(soap, n, NULL, NULL, NULL);

	push	0
	push	eax
	call	?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSettingsFileElement
	add	esp, 8

; 1559 : }

	ret	0
?soap_new__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@H@Z ENDP ; soap_new__ns2__getSettingsFileElement
_TEXT	ENDS
PUBLIC	?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSettingsFileResponseElement
__unwindtable$?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z$1
__ehfuncinfo$?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T458911 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_soap$ = 8						; size = 4
_size$ = 12						; size = 4
?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate__ns2__getSettingsFileResponseElement
; _n$ = ecx

; 1425 : {

	push	-1
	push	__ehhandler$?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ebp, DWORD PTR _soap$[esp+32]

; 1426 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getSettingsFileResponseElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 1427 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getSettingsFileResponseElement, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	ebx, ebx
	add	esp, 4
	cmp	esi, ebx
	je	$LN25@soap_insta@19

; 1428 : 	if (!cp)
; 1429 : 		return NULL;
; 1430 : 	if (n < 0)

	cmp	edi, ebx
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 22			; 00000016H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebp+96], esi
	jge	SHORT $LN8@soap_insta@19

; 1431 : 	{	cp->ptr = (void*)new _ns2__getSettingsFileResponseElement;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN12@soap_insta@19
	mov	DWORD PTR [eax], OFFSET ??_7_ns2__getSettingsFileResponseElement@@6B@
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN13@soap_insta@19
$LN12@soap_insta@19:
	xor	eax, eax
$LN13@soap_insta@19:
	mov	DWORD PTR [esi+4], eax

; 1432 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN7@soap_insta@19

; 1433 : 			*size = sizeof(_ns2__getSettingsFileResponseElement);

	mov	DWORD PTR [eax], 12			; 0000000cH
$LN7@soap_insta@19:

; 1434 : 		((_ns2__getSettingsFileResponseElement*)cp->ptr)->soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+8], ebp

; 1435 : 	}
; 1436 : 	else

	jmp	$LN1@soap_insta@19
$LN8@soap_insta@19:

; 1437 : 	{	cp->ptr = (void*)new _ns2__getSettingsFileResponseElement[n];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 12					; 0000000cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T458911[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	cmp	eax, ebx
	je	SHORT $LN14@soap_insta@19
	push	OFFSET ??1_ns2__getSettingsFileResponseElement@@UAE@XZ ; _ns2__getSettingsFileResponseElement::~_ns2__getSettingsFileResponseElement
	push	OFFSET ??0_ns2__getSettingsFileResponseElement@@QAE@XZ ; _ns2__getSettingsFileResponseElement::_ns2__getSettingsFileResponseElement
	push	edi
	lea	ebx, DWORD PTR [eax+4]
	push	12					; 0000000cH
	push	ebx
	mov	DWORD PTR [eax], edi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
$LN14@soap_insta@19:
	mov	DWORD PTR [esi+4], ebx

; 1438 : 		if (!cp->ptr)

	test	ebx, ebx
	jne	SHORT $LN5@soap_insta@19

; 1439 : 		{	soap->error = SOAP_EOM;

	mov	DWORD PTR [ebp+90460], 20		; 00000014H
$LN25@soap_insta@19:

; 1440 : 			return NULL;

	xor	eax, eax

; 1449 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN5@soap_insta@19:

; 1441 : 		}
; 1442 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	test	eax, eax
	je	SHORT $LN4@soap_insta@19

; 1443 : 			*size = n * sizeof(_ns2__getSettingsFileResponseElement);

	lea	ecx, DWORD PTR [edi+edi*2]
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR [eax], ecx
$LN4@soap_insta@19:

; 1444 : 		for (int i = 0; i < n; i++)

	test	edi, edi
	jle	SHORT $LN1@soap_insta@19
	xor	eax, eax
$LL3@soap_insta@19:

; 1445 : 			((_ns2__getSettingsFileResponseElement*)cp->ptr)[i].soap = soap;

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+edx+8], ebp
	add	eax, 12					; 0000000cH
	sub	edi, 1
	jne	SHORT $LL3@soap_insta@19
$LN1@soap_insta@19:

; 1446 : 	}
; 1447 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 1448 : 	return (_ns2__getSettingsFileResponseElement*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]

; 1449 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
__unwindfunclet$?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z$1:
	mov	eax, DWORD PTR $T458911[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z
	jmp	___CxxFrameHandler3
?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate__ns2__getSettingsFileResponseElement
PUBLIC	?soap_new__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@H@Z ; soap_new__ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@H@Z PROC ; soap_new__ns2__getSettingsFileResponseElement
; _soap$ = eax
; _n$ = ecx

; 1417 : {	return soap_instantiate__ns2__getSettingsFileResponseElement(soap, n, NULL, NULL, NULL);

	push	0
	push	eax
	call	?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSettingsFileResponseElement
	add	esp, 8

; 1418 : }

	ret	0
?soap_new__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@H@Z ENDP ; soap_new__ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
$T459702 = -12						; size = 4
$T459486 = -12						; size = 4
$T459270 = -12						; size = 4
$T459054 = -12						; size = 4
$T459765 = -8						; size = 8
$T459549 = -8						; size = 8
$T459762 = -8						; size = 8
$T459333 = -8						; size = 8
$T459546 = -8						; size = 8
$T459330 = -8						; size = 8
$T459116 = -8						; size = 8
$T459113 = -8						; size = 8
_soap$ = 8						; size = 4
?soap_default@_ns2__submitEpochResultElement@@UAEXPAUsoap@@@Z PROC ; _ns2__submitEpochResultElement::soap_default
; _this$ = ecx

; 1119 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 1120 : 	this->soap = soap;

	mov	eax, DWORD PTR _soap$[ebp]
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi+128], eax

; 1121 : 	this->_ns2__submitEpochResultElement::sessionID = NULL;

	xor	eax, eax

; 1122 : 	soap_default_LONG64(soap, &this->_ns2__submitEpochResultElement::epoch);
; 1123 : 	soap_default_std__vectorTemplateOfint(soap, &this->_ns2__submitEpochResultElement::channel);

	lea	esi, DWORD PTR [edi+24]
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], eax
	mov	ebx, DWORD PTR [esi+16]
	cmp	DWORD PTR [esi+12], ebx
	jbe	SHORT $LN14@soap_defau@3
	call	__invalid_parameter_noinfo
$LN14@soap_defau@3:
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T459113[esp+24], ecx
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR $T459054[esp+24], ecx
	cmp	ecx, DWORD PTR [esi+16]
	jbe	SHORT $LN30@soap_defau@3
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR $T459054[esp+24]
$LN30@soap_defau@3:
	mov	edx, DWORD PTR $T459113[esp+24]
	mov	eax, DWORD PTR [esi]
	push	ebx
	push	edx
	push	ecx
	push	eax
	lea	eax, DWORD PTR $T459116[esp+40]
	push	eax
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 1124 : 	soap_default_std__vectorTemplateOfint(soap, &this->_ns2__submitEpochResultElement::rank);

	mov	ebx, DWORD PTR [edi+64]
	cmp	DWORD PTR [edi+60], ebx
	lea	esi, DWORD PTR [edi+48]
	jbe	SHORT $LN50@soap_defau@3
	call	__invalid_parameter_noinfo
$LN50@soap_defau@3:
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T459330[esp+24], ecx
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR $T459270[esp+24], ecx
	cmp	ecx, DWORD PTR [esi+16]
	jbe	SHORT $LN66@soap_defau@3
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR $T459270[esp+24]
$LN66@soap_defau@3:
	mov	edx, DWORD PTR $T459330[esp+24]
	mov	eax, DWORD PTR [esi]
	push	ebx
	push	edx
	push	ecx
	push	eax
	lea	eax, DWORD PTR $T459333[esp+40]
	push	eax
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 1125 : 	soap_default_std__vectorTemplateOffloat(soap, &this->_ns2__submitEpochResultElement::PsysACTSTBY);

	mov	ebx, DWORD PTR [edi+88]
	cmp	DWORD PTR [edi+84], ebx
	lea	esi, DWORD PTR [edi+72]
	jbe	SHORT $LN86@soap_defau@3
	call	__invalid_parameter_noinfo
$LN86@soap_defau@3:
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T459546[esp+24], ecx
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR $T459486[esp+24], ecx
	cmp	ecx, DWORD PTR [esi+16]
	jbe	SHORT $LN102@soap_defau@3
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR $T459486[esp+24]
$LN102@soap_defau@3:
	mov	edx, DWORD PTR $T459546[esp+24]
	mov	eax, DWORD PTR [esi]
	push	ebx
	push	edx
	push	ecx
	push	eax
	lea	eax, DWORD PTR $T459549[esp+40]
	push	eax
	call	?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z ; std::vector<float,std::allocator<float> >::erase

; 1126 : 	soap_default_std__vectorTemplateOffloat(soap, &this->_ns2__submitEpochResultElement::PsysACT);

	mov	ebx, DWORD PTR [edi+112]
	cmp	DWORD PTR [edi+108], ebx
	lea	esi, DWORD PTR [edi+96]
	jbe	SHORT $LN122@soap_defau@3
	call	__invalid_parameter_noinfo
$LN122@soap_defau@3:
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T459762[esp+24], ecx
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR $T459702[esp+24], ecx
	cmp	ecx, DWORD PTR [esi+16]
	jbe	SHORT $LN138@soap_defau@3
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR $T459702[esp+24]
$LN138@soap_defau@3:
	mov	edx, DWORD PTR $T459762[esp+24]
	mov	eax, DWORD PTR [esi]
	push	ebx
	push	edx
	push	ecx
	push	eax
	lea	eax, DWORD PTR $T459765[esp+40]
	push	eax
	call	?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z ; std::vector<float,std::allocator<float> >::erase

; 1127 : 	soap_default_float(soap, &this->_ns2__submitEpochResultElement::PsysRD);

	xorps	xmm0, xmm0
	movss	DWORD PTR [edi+120], xmm0

; 1128 : 	soap_default_float(soap, &this->_ns2__submitEpochResultElement::PsysWR);

	movss	DWORD PTR [edi+124], xmm0

; 1129 : 	/* transient soap skipped */
; 1130 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?soap_default@_ns2__submitEpochResultElement@@UAEXPAUsoap@@@Z ENDP ; _ns2__submitEpochResultElement::soap_default
_TEXT	ENDS
PUBLIC	?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__submitEpochResultResponseElement
__unwindtable$?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z$1
__ehfuncinfo$?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T459813 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_soap$ = 8						; size = 4
_size$ = 12						; size = 4
?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate__ns2__submitEpochResultResponseElement
; _n$ = ecx

; 1087 : {

	push	-1
	push	__ehhandler$?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ebx, DWORD PTR _soap$[esp+32]

; 1088 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__submitEpochResultResponseElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 1089 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__submitEpochResultResponseElement, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	ebp, ebp
	add	esp, 4
	cmp	esi, ebp
	je	$LN25@soap_insta@20

; 1090 : 	if (!cp)
; 1091 : 		return NULL;
; 1092 : 	if (n < 0)

	cmp	edi, ebp
	mov	eax, DWORD PTR [ebx+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 24			; 00000018H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], ebp
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebx+96], esi
	jge	SHORT $LN8@soap_insta@20

; 1093 : 	{	cp->ptr = (void*)new _ns2__submitEpochResultResponseElement;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebp
	je	SHORT $LN12@soap_insta@20
	mov	DWORD PTR [eax], OFFSET ??_7_ns2__submitEpochResultResponseElement@@6B@
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax+8], ebp
	jmp	SHORT $LN13@soap_insta@20
$LN12@soap_insta@20:
	xor	eax, eax
$LN13@soap_insta@20:
	mov	DWORD PTR [esi+4], eax

; 1094 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebp
	je	SHORT $LN7@soap_insta@20

; 1095 : 			*size = sizeof(_ns2__submitEpochResultResponseElement);

	mov	DWORD PTR [eax], 12			; 0000000cH
$LN7@soap_insta@20:

; 1096 : 		((_ns2__submitEpochResultResponseElement*)cp->ptr)->soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+8], ebx

; 1097 : 	}
; 1098 : 	else

	jmp	$LN1@soap_insta@20
$LN8@soap_insta@20:

; 1099 : 	{	cp->ptr = (void*)new _ns2__submitEpochResultResponseElement[n];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 12					; 0000000cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T459813[esp+36], eax
	xor	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+44], ebp
	cmp	eax, ebp
	je	SHORT $LN14@soap_insta@20
	push	OFFSET ??1_ns2__submitEpochResultResponseElement@@UAE@XZ ; _ns2__submitEpochResultResponseElement::~_ns2__submitEpochResultResponseElement
	push	OFFSET ??0_ns2__submitEpochResultResponseElement@@QAE@XZ ; _ns2__submitEpochResultResponseElement::_ns2__submitEpochResultResponseElement
	push	edi
	lea	ebp, DWORD PTR [eax+4]
	push	12					; 0000000cH
	push	ebp
	mov	DWORD PTR [eax], edi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
$LN14@soap_insta@20:
	mov	DWORD PTR [esi+4], ebp

; 1100 : 		if (!cp->ptr)

	test	ebp, ebp
	jne	SHORT $LN5@soap_insta@20

; 1101 : 		{	soap->error = SOAP_EOM;

	mov	DWORD PTR [ebx+90460], 20		; 00000014H
$LN25@soap_insta@20:

; 1102 : 			return NULL;

	xor	eax, eax

; 1111 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN5@soap_insta@20:

; 1103 : 		}
; 1104 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	test	eax, eax
	je	SHORT $LN4@soap_insta@20

; 1105 : 			*size = n * sizeof(_ns2__submitEpochResultResponseElement);

	lea	ecx, DWORD PTR [edi+edi*2]
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR [eax], ecx
$LN4@soap_insta@20:

; 1106 : 		for (int i = 0; i < n; i++)

	test	edi, edi
	jle	SHORT $LN1@soap_insta@20
	xor	eax, eax
	npad	9
$LL3@soap_insta@20:

; 1107 : 			((_ns2__submitEpochResultResponseElement*)cp->ptr)[i].soap = soap;

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+edx+8], ebx
	add	eax, 12					; 0000000cH
	sub	edi, 1
	jne	SHORT $LL3@soap_insta@20
$LN1@soap_insta@20:

; 1108 : 	}
; 1109 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 1110 : 	return (_ns2__submitEpochResultResponseElement*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]

; 1111 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
__unwindfunclet$?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z$1:
	mov	eax, DWORD PTR $T459813[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z
	jmp	___CxxFrameHandler3
?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate__ns2__submitEpochResultResponseElement
PUBLIC	?soap_new__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@H@Z ; soap_new__ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@H@Z PROC ; soap_new__ns2__submitEpochResultResponseElement
; _soap$ = eax
; _n$ = ecx

; 1079 : {	return soap_instantiate__ns2__submitEpochResultResponseElement(soap, n, NULL, NULL, NULL);

	push	0
	push	eax
	call	?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__submitEpochResultResponseElement
	add	esp, 8

; 1080 : }

	ret	0
?soap_new__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@H@Z ENDP ; soap_new__ns2__submitEpochResultResponseElement
_TEXT	ENDS
PUBLIC	?soap_out_bool@@YAHPAUsoap@@PBDHPB_N1@Z		; soap_out_bool
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_bool@@YAHPAUsoap@@PBDHPB_N1@Z PROC		; soap_out_bool
; _tag$ = ecx
; _id$ = eax

; 922  : {	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))

	push	ebx
	mov	ebx, DWORD PTR _a$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]
	push	eax
	mov	esi, ecx
	push	edi
	mov	eax, 11					; 0000000bH
	mov	ecx, ebx
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN24@soap_out_b
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_out_b
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_out_b
$LN5@soap_out_b:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_out_b:
	test	eax, eax
	jne	SHORT $LN1@soap_out_b
$LN24@soap_out_b:
	xor	ecx, ecx
	cmp	BYTE PTR [ebx], cl
	mov	eax, OFFSET _soap_codes_bool
	setne	cl
	test	ecx, ecx
	je	SHORT $LN11@soap_out_b
	npad	2
$LL12@soap_out_b:
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN11@soap_out_b
	add	eax, 8
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LL12@soap_out_b
$LN11@soap_out_b:
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN22@soap_out_b
	mov	eax, ecx
	lea	ebx, DWORD PTR [eax+1]
	npad	7
$LL23@soap_out_b:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL23@soap_out_b
	sub	eax, ebx
	push	eax
	push	ecx
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@soap_out_b
$LN22@soap_out_b:

; 924  : 	return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebx

; 925  : }

	ret	0
$LN1@soap_out_b:

; 923  : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 925  : }

	ret	0
?soap_out_bool@@YAHPAUsoap@@PBDHPB_N1@Z ENDP		; soap_out_bool
_TEXT	ENDS
PUBLIC	_soap_fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_fault PROC
; _soap$ = eax

; 49   : {

	push	ebx
	push	esi
	push	edi
	mov	edi, eax

; 50   : 	if (!soap->fault)

	xor	ebx, ebx
	cmp	DWORD PTR [edi+12208], ebx
	jne	SHORT $LN20@soap_fault

; 51   : 	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	cmp	esi, ebx
	je	$LN44@soap_fault
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 47			; 0000002fH
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	push	36					; 00000024H
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
$LN15@soap_fault:
	mov	DWORD PTR [edi+12208], eax

; 52   : 		if (!soap->fault)

	cmp	eax, ebx
	je	SHORT $LN42@soap_fault

; 53   : 			return;
; 54   : 		soap_default_SOAP_ENV__Fault(soap, soap->fault);

	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ebx
	mov	DWORD PTR [eax+20], ebx
	mov	DWORD PTR [eax+24], ebx
	mov	DWORD PTR [eax+28], ebx
	mov	DWORD PTR [eax+32], ebx
$LN20@soap_fault:

; 55   : 	}
; 56   : 	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)

	mov	esi, 2
	cmp	WORD PTR [edi+6], si
	jne	SHORT $LN42@soap_fault
	mov	ecx, DWORD PTR [edi+12208]
	cmp	DWORD PTR [ecx+16], ebx
	jne	SHORT $LN34@soap_fault

; 57   : 	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);

	call	?soap_new_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@H@Z ; soap_new_SOAP_ENV__Code
	mov	edx, DWORD PTR [edi+12208]
	mov	DWORD PTR [edx+16], eax

; 58   : 		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);

	mov	eax, DWORD PTR [edi+12208]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
$LN34@soap_fault:

; 59   : 	}
; 60   : 	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)

	cmp	WORD PTR [edi+6], si
	jne	SHORT $LN42@soap_fault
	mov	ecx, DWORD PTR [edi+12208]
	cmp	DWORD PTR [ecx+20], ebx
	jne	SHORT $LN42@soap_fault

; 61   : 	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);

	call	?soap_new_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@H@Z ; soap_new_SOAP_ENV__Reason
	mov	edx, DWORD PTR [edi+12208]
	mov	DWORD PTR [edx+20], eax

; 62   : 		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);

	mov	eax, DWORD PTR [edi+12208]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx], ebx
$LN42@soap_fault:
	pop	edi
	pop	esi
	pop	ebx

; 63   : 	}
; 64   : }

	ret	0
$LN44@soap_fault:

; 51   : 	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);

	xor	eax, eax
	jmp	$LN15@soap_fault
_soap_fault ENDP
_TEXT	ENDS
PUBLIC	_soap_header
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_header PROC
; _soap$ = edi

; 42   : 	if (!soap->header)

	cmp	DWORD PTR [edi+12204], 0
	jne	SHORT $LN17@soap_heade
	push	esi

; 43   : 	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN19@soap_heade
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 40			; 00000028H
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	push	1
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [edi+12204], eax
	pop	esi

; 44   : 		soap_default_SOAP_ENV__Header(soap, soap->header);

$LN17@soap_heade:

; 45   : 	}
; 46   : }

	ret	0
$LN19@soap_heade:

; 43   : 	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);

	xor	eax, eax
	mov	DWORD PTR [edi+12204], eax
	pop	esi

; 45   : 	}
; 46   : }

	ret	0
_soap_header ENDP
_TEXT	ENDS
PUBLIC	_soap_putheader
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_putheader PROC
; _soap$ = esi

; 23   : 	if (soap->header)

	mov	ecx, DWORD PTR [esi+12204]
	test	ecx, ecx
	je	SHORT $LN2@soap_puthe@2

; 24   : 	{	soap->part = SOAP_IN_HEADER;
; 25   : 		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))

	push	0
	mov	eax, 3
	mov	WORD PTR [esi+87304], ax
	push	OFFSET ??_C@_0BA@GBPDPHCK@SOAP?9ENV?3Header?$AA@
	push	esi
	xor	eax, eax
	call	?soap_out_SOAP_ENV__Header@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Header@@1@Z ; soap_out_SOAP_ENV__Header
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_puthe@2

; 26   : 			return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 30   : }

	ret	0
$LN1@soap_puthe@2:

; 27   : 		soap->part = SOAP_END_HEADER;

	mov	ecx, 4
	mov	WORD PTR [esi+87304], cx
$LN2@soap_puthe@2:

; 28   : 	}
; 29   : 	return SOAP_OK;

	xor	eax, eax

; 30   : }

	ret	0
_soap_putheader ENDP
PUBLIC	?soap_out_PointerTostd__string@@YAHPAUsoap@@PBDHPBQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; soap_out_PointerTostd__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_pp$498196 = 12						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_PointerTostd__string@@YAHPAUsoap@@PBDHPBQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z PROC ; soap_out_PointerTostd__string
; _soap$ = ecx
; _id$ = eax

; 4215 : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _a$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx

; 4216 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);

	mov	ecx, DWORD PTR [ebp]
	mov	esi, eax
	test	ecx, ecx
	je	$LN11@soap_out_P
	test	DWORD PTR [edi+8], 32768		; 00008000H
	je	SHORT $LN10@soap_out_P
$LN31@soap_out_P:
	xor	eax, eax
$LN1@soap_out_P:

; 4219 : 	return soap_out_std__string(soap, tag, id, *a, type);

	mov	edx, DWORD PTR _type$[esp+12]
	mov	ecx, DWORD PTR [ebp]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+20]
	push	edi
	call	?soap_out_std__string@@YAHPAUsoap@@PBDHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; soap_out_std__string
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4220 : }

	ret	0

; 4216 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);

$LN10@soap_out_P:
	test	eax, eax
	jge	SHORT $LN6@soap_out_P
	lea	edx, DWORD PTR _pp$498196[esp+12]
	mov	esi, 18					; 00000012H
	call	_soap_pointer_lookup
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN6@soap_out_P
	mov	ebx, DWORD PTR _pp$498196[esp+12]
	mov	ecx, ebx
	mov	eax, edi
	call	_soap_is_embedded
	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN5@soap_out_P
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	mov	eax, esi
	call	_soap_element_ref

; 4218 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4220 : }

	ret	0

; 4216 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);

$LN5@soap_out_P:
	mov	eax, ebx
	call	_soap_is_single
	test	eax, eax
	jne	SHORT $LN31@soap_out_P
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_set_embedded
$LN6@soap_out_P:
	mov	eax, esi

; 4217 : 	if (id < 0)

	test	esi, esi
	jge	SHORT $LN1@soap_out_P

; 4218 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4220 : }

	ret	0

; 4216 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);

$LN11@soap_out_P:
	mov	ecx, DWORD PTR _type$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+16]
	push	edi
	call	_soap_element_null

; 4218 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4220 : }

	ret	0
?soap_out_PointerTostd__string@@YAHPAUsoap@@PBDHPBQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ENDP ; soap_out_PointerTostd__string
_TEXT	ENDS
PUBLIC	?soap_out_PointerTo_ns2__getSessionIDElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSessionIDElement@@1@Z ; soap_out_PointerTo_ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_pp$498247 = 12						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_PointerTo_ns2__getSessionIDElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSessionIDElement@@1@Z PROC ; soap_out_PointerTo_ns2__getSessionIDElement
; _soap$ = ecx
; _id$ = eax

; 4160 : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _a$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx

; 4161 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSessionIDElement);

	mov	ecx, DWORD PTR [ebp]
	mov	esi, eax
	test	ecx, ecx
	je	$LN11@soap_out_P@2
	test	DWORD PTR [edi+8], 32768		; 00008000H
	je	SHORT $LN10@soap_out_P@2
$LN31@soap_out_P@2:
	xor	eax, eax
$LN1@soap_out_P@2:

; 4164 : 	return (*a)->soap_out(soap, tag, id, type);

	mov	esi, DWORD PTR _type$[esp+12]
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+16]
	push	esi
	push	eax
	mov	eax, DWORD PTR _tag$[esp+20]
	push	eax
	push	edi
	call	edx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4165 : }

	ret	0

; 4161 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSessionIDElement);

$LN10@soap_out_P@2:
	test	eax, eax
	jge	SHORT $LN6@soap_out_P@2
	lea	edx, DWORD PTR _pp$498247[esp+12]
	mov	esi, 19					; 00000013H
	call	_soap_pointer_lookup
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN6@soap_out_P@2
	mov	ebx, DWORD PTR _pp$498247[esp+12]
	mov	ecx, ebx
	mov	eax, edi
	call	_soap_is_embedded
	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN5@soap_out_P@2
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	mov	eax, esi
	call	_soap_element_ref

; 4163 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4165 : }

	ret	0

; 4161 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSessionIDElement);

$LN5@soap_out_P@2:
	mov	eax, ebx
	call	_soap_is_single
	test	eax, eax
	jne	SHORT $LN31@soap_out_P@2
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_set_embedded
$LN6@soap_out_P@2:
	mov	eax, esi

; 4162 : 	if (id < 0)

	test	esi, esi
	jge	SHORT $LN1@soap_out_P@2

; 4163 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4165 : }

	ret	0

; 4161 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSessionIDElement);

$LN11@soap_out_P@2:
	mov	ecx, DWORD PTR _type$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+16]
	push	edi
	call	_soap_element_null

; 4163 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4165 : }

	ret	0
?soap_out_PointerTo_ns2__getSessionIDElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSessionIDElement@@1@Z ENDP ; soap_out_PointerTo_ns2__getSessionIDElement
_TEXT	ENDS
PUBLIC	?soap_out_PointerTo_ns2__getSessionIDResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSessionIDResponseElement@@1@Z ; soap_out_PointerTo_ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_pp$498298 = 12						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_PointerTo_ns2__getSessionIDResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSessionIDResponseElement@@1@Z PROC ; soap_out_PointerTo_ns2__getSessionIDResponseElement
; _soap$ = ecx
; _id$ = eax

; 4105 : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _a$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx

; 4106 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSessionIDResponseElement);

	mov	ecx, DWORD PTR [ebp]
	mov	esi, eax
	test	ecx, ecx
	je	$LN11@soap_out_P@3
	test	DWORD PTR [edi+8], 32768		; 00008000H
	je	SHORT $LN10@soap_out_P@3
$LN31@soap_out_P@3:
	xor	eax, eax
$LN1@soap_out_P@3:

; 4109 : 	return (*a)->soap_out(soap, tag, id, type);

	mov	esi, DWORD PTR _type$[esp+12]
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+16]
	push	esi
	push	eax
	mov	eax, DWORD PTR _tag$[esp+20]
	push	eax
	push	edi
	call	edx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4110 : }

	ret	0

; 4106 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSessionIDResponseElement);

$LN10@soap_out_P@3:
	test	eax, eax
	jge	SHORT $LN6@soap_out_P@3
	lea	edx, DWORD PTR _pp$498298[esp+12]
	mov	esi, 20					; 00000014H
	call	_soap_pointer_lookup
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN6@soap_out_P@3
	mov	ebx, DWORD PTR _pp$498298[esp+12]
	mov	ecx, ebx
	mov	eax, edi
	call	_soap_is_embedded
	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN5@soap_out_P@3
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	mov	eax, esi
	call	_soap_element_ref

; 4108 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4110 : }

	ret	0

; 4106 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSessionIDResponseElement);

$LN5@soap_out_P@3:
	mov	eax, ebx
	call	_soap_is_single
	test	eax, eax
	jne	SHORT $LN31@soap_out_P@3
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_set_embedded
$LN6@soap_out_P@3:
	mov	eax, esi

; 4107 : 	if (id < 0)

	test	esi, esi
	jge	SHORT $LN1@soap_out_P@3

; 4108 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4110 : }

	ret	0

; 4106 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSessionIDResponseElement);

$LN11@soap_out_P@3:
	mov	ecx, DWORD PTR _type$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+16]
	push	edi
	call	_soap_element_null

; 4108 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4110 : }

	ret	0
?soap_out_PointerTo_ns2__getSessionIDResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSessionIDResponseElement@@1@Z ENDP ; soap_out_PointerTo_ns2__getSessionIDResponseElement
_TEXT	ENDS
PUBLIC	?soap_out_PointerTo_ns2__getSettingsFileElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSettingsFileElement@@1@Z ; soap_out_PointerTo_ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_pp$498349 = 12						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_PointerTo_ns2__getSettingsFileElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSettingsFileElement@@1@Z PROC ; soap_out_PointerTo_ns2__getSettingsFileElement
; _soap$ = ecx
; _id$ = eax

; 4050 : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _a$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx

; 4051 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSettingsFileElement);

	mov	ecx, DWORD PTR [ebp]
	mov	esi, eax
	test	ecx, ecx
	je	$LN11@soap_out_P@4
	test	DWORD PTR [edi+8], 32768		; 00008000H
	je	SHORT $LN10@soap_out_P@4
$LN31@soap_out_P@4:
	xor	eax, eax
$LN1@soap_out_P@4:

; 4054 : 	return (*a)->soap_out(soap, tag, id, type);

	mov	esi, DWORD PTR _type$[esp+12]
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+16]
	push	esi
	push	eax
	mov	eax, DWORD PTR _tag$[esp+20]
	push	eax
	push	edi
	call	edx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4055 : }

	ret	0

; 4051 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSettingsFileElement);

$LN10@soap_out_P@4:
	test	eax, eax
	jge	SHORT $LN6@soap_out_P@4
	lea	edx, DWORD PTR _pp$498349[esp+12]
	mov	esi, 21					; 00000015H
	call	_soap_pointer_lookup
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN6@soap_out_P@4
	mov	ebx, DWORD PTR _pp$498349[esp+12]
	mov	ecx, ebx
	mov	eax, edi
	call	_soap_is_embedded
	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN5@soap_out_P@4
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	mov	eax, esi
	call	_soap_element_ref

; 4053 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4055 : }

	ret	0

; 4051 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSettingsFileElement);

$LN5@soap_out_P@4:
	mov	eax, ebx
	call	_soap_is_single
	test	eax, eax
	jne	SHORT $LN31@soap_out_P@4
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_set_embedded
$LN6@soap_out_P@4:
	mov	eax, esi

; 4052 : 	if (id < 0)

	test	esi, esi
	jge	SHORT $LN1@soap_out_P@4

; 4053 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4055 : }

	ret	0

; 4051 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSettingsFileElement);

$LN11@soap_out_P@4:
	mov	ecx, DWORD PTR _type$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+16]
	push	edi
	call	_soap_element_null

; 4053 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4055 : }

	ret	0
?soap_out_PointerTo_ns2__getSettingsFileElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSettingsFileElement@@1@Z ENDP ; soap_out_PointerTo_ns2__getSettingsFileElement
_TEXT	ENDS
PUBLIC	?soap_out_PointerTo_ns2__getSettingsFileResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSettingsFileResponseElement@@1@Z ; soap_out_PointerTo_ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_pp$498400 = 12						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_PointerTo_ns2__getSettingsFileResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSettingsFileResponseElement@@1@Z PROC ; soap_out_PointerTo_ns2__getSettingsFileResponseElement
; _soap$ = ecx
; _id$ = eax

; 3995 : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _a$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx

; 3996 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSettingsFileResponseElement);

	mov	ecx, DWORD PTR [ebp]
	mov	esi, eax
	test	ecx, ecx
	je	$LN11@soap_out_P@5
	test	DWORD PTR [edi+8], 32768		; 00008000H
	je	SHORT $LN10@soap_out_P@5
$LN31@soap_out_P@5:
	xor	eax, eax
$LN1@soap_out_P@5:

; 3999 : 	return (*a)->soap_out(soap, tag, id, type);

	mov	esi, DWORD PTR _type$[esp+12]
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+16]
	push	esi
	push	eax
	mov	eax, DWORD PTR _tag$[esp+20]
	push	eax
	push	edi
	call	edx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4000 : }

	ret	0

; 3996 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSettingsFileResponseElement);

$LN10@soap_out_P@5:
	test	eax, eax
	jge	SHORT $LN6@soap_out_P@5
	lea	edx, DWORD PTR _pp$498400[esp+12]
	mov	esi, 22					; 00000016H
	call	_soap_pointer_lookup
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN6@soap_out_P@5
	mov	ebx, DWORD PTR _pp$498400[esp+12]
	mov	ecx, ebx
	mov	eax, edi
	call	_soap_is_embedded
	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN5@soap_out_P@5
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	mov	eax, esi
	call	_soap_element_ref

; 3998 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4000 : }

	ret	0

; 3996 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSettingsFileResponseElement);

$LN5@soap_out_P@5:
	mov	eax, ebx
	call	_soap_is_single
	test	eax, eax
	jne	SHORT $LN31@soap_out_P@5
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_set_embedded
$LN6@soap_out_P@5:
	mov	eax, esi

; 3997 : 	if (id < 0)

	test	esi, esi
	jge	SHORT $LN1@soap_out_P@5

; 3998 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4000 : }

	ret	0

; 3996 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getSettingsFileResponseElement);

$LN11@soap_out_P@5:
	mov	ecx, DWORD PTR _type$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+16]
	push	edi
	call	_soap_element_null

; 3998 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4000 : }

	ret	0
?soap_out_PointerTo_ns2__getSettingsFileResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSettingsFileResponseElement@@1@Z ENDP ; soap_out_PointerTo_ns2__getSettingsFileResponseElement
_TEXT	ENDS
PUBLIC	?soap_out_PointerTo_ns2__submitEpochResultElement@@YAHPAUsoap@@PBDHPBQAV_ns2__submitEpochResultElement@@1@Z ; soap_out_PointerTo_ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_pp$498451 = 12						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_PointerTo_ns2__submitEpochResultElement@@YAHPAUsoap@@PBDHPBQAV_ns2__submitEpochResultElement@@1@Z PROC ; soap_out_PointerTo_ns2__submitEpochResultElement
; _soap$ = ecx
; _id$ = eax

; 3940 : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _a$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx

; 3941 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__submitEpochResultElement);

	mov	ecx, DWORD PTR [ebp]
	mov	esi, eax
	test	ecx, ecx
	je	$LN11@soap_out_P@6
	test	DWORD PTR [edi+8], 32768		; 00008000H
	je	SHORT $LN10@soap_out_P@6
$LN31@soap_out_P@6:
	xor	eax, eax
$LN1@soap_out_P@6:

; 3944 : 	return (*a)->soap_out(soap, tag, id, type);

	mov	esi, DWORD PTR _type$[esp+12]
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+16]
	push	esi
	push	eax
	mov	eax, DWORD PTR _tag$[esp+20]
	push	eax
	push	edi
	call	edx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3945 : }

	ret	0

; 3941 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__submitEpochResultElement);

$LN10@soap_out_P@6:
	test	eax, eax
	jge	SHORT $LN6@soap_out_P@6
	lea	edx, DWORD PTR _pp$498451[esp+12]
	mov	esi, 23					; 00000017H
	call	_soap_pointer_lookup
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN6@soap_out_P@6
	mov	ebx, DWORD PTR _pp$498451[esp+12]
	mov	ecx, ebx
	mov	eax, edi
	call	_soap_is_embedded
	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN5@soap_out_P@6
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	mov	eax, esi
	call	_soap_element_ref

; 3943 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3945 : }

	ret	0

; 3941 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__submitEpochResultElement);

$LN5@soap_out_P@6:
	mov	eax, ebx
	call	_soap_is_single
	test	eax, eax
	jne	SHORT $LN31@soap_out_P@6
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_set_embedded
$LN6@soap_out_P@6:
	mov	eax, esi

; 3942 : 	if (id < 0)

	test	esi, esi
	jge	SHORT $LN1@soap_out_P@6

; 3943 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3945 : }

	ret	0

; 3941 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__submitEpochResultElement);

$LN11@soap_out_P@6:
	mov	ecx, DWORD PTR _type$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+16]
	push	edi
	call	_soap_element_null

; 3943 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3945 : }

	ret	0
?soap_out_PointerTo_ns2__submitEpochResultElement@@YAHPAUsoap@@PBDHPBQAV_ns2__submitEpochResultElement@@1@Z ENDP ; soap_out_PointerTo_ns2__submitEpochResultElement
_TEXT	ENDS
PUBLIC	?soap_out_PointerTo_ns2__submitEpochResultResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__submitEpochResultResponseElement@@1@Z ; soap_out_PointerTo_ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_pp$498502 = 12						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_PointerTo_ns2__submitEpochResultResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__submitEpochResultResponseElement@@1@Z PROC ; soap_out_PointerTo_ns2__submitEpochResultResponseElement
; _soap$ = ecx
; _id$ = eax

; 3885 : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _a$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx

; 3886 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__submitEpochResultResponseElement);

	mov	ecx, DWORD PTR [ebp]
	mov	esi, eax
	test	ecx, ecx
	je	$LN11@soap_out_P@7
	test	DWORD PTR [edi+8], 32768		; 00008000H
	je	SHORT $LN10@soap_out_P@7
$LN31@soap_out_P@7:
	xor	eax, eax
$LN1@soap_out_P@7:

; 3889 : 	return (*a)->soap_out(soap, tag, id, type);

	mov	esi, DWORD PTR _type$[esp+12]
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+16]
	push	esi
	push	eax
	mov	eax, DWORD PTR _tag$[esp+20]
	push	eax
	push	edi
	call	edx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3890 : }

	ret	0

; 3886 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__submitEpochResultResponseElement);

$LN10@soap_out_P@7:
	test	eax, eax
	jge	SHORT $LN6@soap_out_P@7
	lea	edx, DWORD PTR _pp$498502[esp+12]
	mov	esi, 24					; 00000018H
	call	_soap_pointer_lookup
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN6@soap_out_P@7
	mov	ebx, DWORD PTR _pp$498502[esp+12]
	mov	ecx, ebx
	mov	eax, edi
	call	_soap_is_embedded
	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN5@soap_out_P@7
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	mov	eax, esi
	call	_soap_element_ref

; 3888 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3890 : }

	ret	0

; 3886 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__submitEpochResultResponseElement);

$LN5@soap_out_P@7:
	mov	eax, ebx
	call	_soap_is_single
	test	eax, eax
	jne	SHORT $LN31@soap_out_P@7
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_set_embedded
$LN6@soap_out_P@7:
	mov	eax, esi

; 3887 : 	if (id < 0)

	test	esi, esi
	jge	SHORT $LN1@soap_out_P@7

; 3888 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3890 : }

	ret	0

; 3886 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__submitEpochResultResponseElement);

$LN11@soap_out_P@7:
	mov	ecx, DWORD PTR _type$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+16]
	push	edi
	call	_soap_element_null

; 3888 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3890 : }

	ret	0
?soap_out_PointerTo_ns2__submitEpochResultResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__submitEpochResultResponseElement@@1@Z ENDP ; soap_out_PointerTo_ns2__submitEpochResultResponseElement
_TEXT	ENDS
PUBLIC	?soap_out___ns1__getSessionID@@YAHPAUsoap@@PBDHPBU__ns1__getSessionID@@1@Z ; soap_out___ns1__getSessionID
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_out___ns1__getSessionID@@YAHPAUsoap@@PBDHPBU__ns1__getSessionID@@1@Z PROC ; soap_out___ns1__getSessionID
; _soap$ = esi
; _a$ = eax

; 3627 : 	if (soap_out_PointerTo_ns2__getSessionIDElement(soap, "ns2:getSessionIDElement", -1, &a->ns2__getSessionIDElement, ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0BI@CHGDHCPP@ns2?3getSessionIDElement?$AA@
	or	eax, -1
	mov	ecx, esi
	call	?soap_out_PointerTo_ns2__getSessionIDElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSessionIDElement@@1@Z ; soap_out_PointerTo_ns2__getSessionIDElement
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_out__

; 3628 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 3630 : }

	ret	0
$LN1@soap_out__:

; 3629 : 	return SOAP_OK;

	xor	eax, eax

; 3630 : }

	ret	0
?soap_out___ns1__getSessionID@@YAHPAUsoap@@PBDHPBU__ns1__getSessionID@@1@Z ENDP ; soap_out___ns1__getSessionID
_TEXT	ENDS
PUBLIC	?soap_put___ns1__getSessionID@@YAHPAUsoap@@PBU__ns1__getSessionID@@PBD2@Z ; soap_put___ns1__getSessionID
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_put___ns1__getSessionID@@YAHPAUsoap@@PBU__ns1__getSessionID@@PBD2@Z PROC ; soap_put___ns1__getSessionID
; _soap$ = esi
; _a$ = eax

; 3619 : 	register int id = 0;
; 3620 : 	if (soap_out___ns1__getSessionID(soap, tag, id, a, type))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0BI@CHGDHCPP@ns2?3getSessionIDElement?$AA@
	or	eax, -1
	mov	ecx, esi
	call	?soap_out_PointerTo_ns2__getSessionIDElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSessionIDElement@@1@Z ; soap_out_PointerTo_ns2__getSessionIDElement
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_put__
	mov	eax, DWORD PTR [esi+90460]
	test	eax, eax

; 3621 : 		return soap->error;

	jne	SHORT $LN2@soap_put__
$LN1@soap_put__:

; 3622 : 	return SOAP_OK;

	xor	eax, eax
$LN2@soap_put__:

; 3623 : }

	ret	0
?soap_put___ns1__getSessionID@@YAHPAUsoap@@PBU__ns1__getSessionID@@PBD2@Z ENDP ; soap_put___ns1__getSessionID
_TEXT	ENDS
PUBLIC	?soap_out___ns1__getSettingsFile@@YAHPAUsoap@@PBDHPBU__ns1__getSettingsFile@@1@Z ; soap_out___ns1__getSettingsFile
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_out___ns1__getSettingsFile@@YAHPAUsoap@@PBDHPBU__ns1__getSettingsFile@@1@Z PROC ; soap_out___ns1__getSettingsFile
; _soap$ = esi
; _a$ = eax

; 3527 : 	if (soap_out_PointerTo_ns2__getSettingsFileElement(soap, "ns2:getSettingsFileElement", -1, &a->ns2__getSettingsFileElement, ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0BL@EBHOCBLE@ns2?3getSettingsFileElement?$AA@
	or	eax, -1
	mov	ecx, esi
	call	?soap_out_PointerTo_ns2__getSettingsFileElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSettingsFileElement@@1@Z ; soap_out_PointerTo_ns2__getSettingsFileElement
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_out__@2

; 3528 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 3530 : }

	ret	0
$LN1@soap_out__@2:

; 3529 : 	return SOAP_OK;

	xor	eax, eax

; 3530 : }

	ret	0
?soap_out___ns1__getSettingsFile@@YAHPAUsoap@@PBDHPBU__ns1__getSettingsFile@@1@Z ENDP ; soap_out___ns1__getSettingsFile
_TEXT	ENDS
PUBLIC	?soap_put___ns1__getSettingsFile@@YAHPAUsoap@@PBU__ns1__getSettingsFile@@PBD2@Z ; soap_put___ns1__getSettingsFile
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_put___ns1__getSettingsFile@@YAHPAUsoap@@PBU__ns1__getSettingsFile@@PBD2@Z PROC ; soap_put___ns1__getSettingsFile
; _soap$ = esi
; _a$ = eax

; 3519 : 	register int id = 0;
; 3520 : 	if (soap_out___ns1__getSettingsFile(soap, tag, id, a, type))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0BL@EBHOCBLE@ns2?3getSettingsFileElement?$AA@
	or	eax, -1
	mov	ecx, esi
	call	?soap_out_PointerTo_ns2__getSettingsFileElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSettingsFileElement@@1@Z ; soap_out_PointerTo_ns2__getSettingsFileElement
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_put__@2
	mov	eax, DWORD PTR [esi+90460]
	test	eax, eax

; 3521 : 		return soap->error;

	jne	SHORT $LN2@soap_put__@2
$LN1@soap_put__@2:

; 3522 : 	return SOAP_OK;

	xor	eax, eax
$LN2@soap_put__@2:

; 3523 : }

	ret	0
?soap_put___ns1__getSettingsFile@@YAHPAUsoap@@PBU__ns1__getSettingsFile@@PBD2@Z ENDP ; soap_put___ns1__getSettingsFile
_TEXT	ENDS
PUBLIC	?soap_out___ns1__submitEpochResult@@YAHPAUsoap@@PBDHPBU__ns1__submitEpochResult@@1@Z ; soap_out___ns1__submitEpochResult
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_out___ns1__submitEpochResult@@YAHPAUsoap@@PBDHPBU__ns1__submitEpochResult@@1@Z PROC ; soap_out___ns1__submitEpochResult
; _soap$ = esi
; _a$ = eax

; 3427 : 	if (soap_out_PointerTo_ns2__submitEpochResultElement(soap, "ns2:submitEpochResultElement", -1, &a->ns2__submitEpochResultElement, ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0BN@LEHNEPKC@ns2?3submitEpochResultElement?$AA@
	or	eax, -1
	mov	ecx, esi
	call	?soap_out_PointerTo_ns2__submitEpochResultElement@@YAHPAUsoap@@PBDHPBQAV_ns2__submitEpochResultElement@@1@Z ; soap_out_PointerTo_ns2__submitEpochResultElement
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_out__@3

; 3428 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 3430 : }

	ret	0
$LN1@soap_out__@3:

; 3429 : 	return SOAP_OK;

	xor	eax, eax

; 3430 : }

	ret	0
?soap_out___ns1__submitEpochResult@@YAHPAUsoap@@PBDHPBU__ns1__submitEpochResult@@1@Z ENDP ; soap_out___ns1__submitEpochResult
_TEXT	ENDS
PUBLIC	?soap_put___ns1__submitEpochResult@@YAHPAUsoap@@PBU__ns1__submitEpochResult@@PBD2@Z ; soap_put___ns1__submitEpochResult
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_put___ns1__submitEpochResult@@YAHPAUsoap@@PBU__ns1__submitEpochResult@@PBD2@Z PROC ; soap_put___ns1__submitEpochResult
; _soap$ = esi
; _a$ = eax

; 3419 : 	register int id = 0;
; 3420 : 	if (soap_out___ns1__submitEpochResult(soap, tag, id, a, type))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0BN@LEHNEPKC@ns2?3submitEpochResultElement?$AA@
	or	eax, -1
	mov	ecx, esi
	call	?soap_out_PointerTo_ns2__submitEpochResultElement@@YAHPAUsoap@@PBDHPBQAV_ns2__submitEpochResultElement@@1@Z ; soap_out_PointerTo_ns2__submitEpochResultElement
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_put__@3
	mov	eax, DWORD PTR [esi+90460]
	test	eax, eax

; 3421 : 		return soap->error;

	jne	SHORT $LN2@soap_put__@3
$LN1@soap_put__@3:

; 3422 : 	return SOAP_OK;

	xor	eax, eax
$LN2@soap_put__@3:

; 3423 : }

	ret	0
?soap_put___ns1__submitEpochResult@@YAHPAUsoap@@PBU__ns1__submitEpochResult@@PBD2@Z ENDP ; soap_put___ns1__submitEpochResult
_TEXT	ENDS
PUBLIC	?soap_out_xsd__anyType@@YAHPAUsoap@@PBDHPBVxsd__anyType@@1@Z ; soap_out_xsd__anyType
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
?soap_out_xsd__anyType@@YAHPAUsoap@@PBDHPBVxsd__anyType@@1@Z PROC ; soap_out_xsd__anyType
; _tag$ = ecx
; _a$ = eax

; 2551 : 	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), NULL);

	add	eax, 4
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	call	_soap_outliteral
	add	esp, 8

; 2552 : }

	ret	0
?soap_out_xsd__anyType@@YAHPAUsoap@@PBDHPBVxsd__anyType@@1@Z ENDP ; soap_out_xsd__anyType
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
?soap_out@xsd__anyType@@UBEHPAUsoap@@PBDH1@Z PROC	; xsd__anyType::soap_out
; _this$ = ecx

; 2546 : 	return soap_out_xsd__anyType(soap, tag, id, this, type);

	mov	eax, DWORD PTR _tag$[esp-4]
	add	ecx, 4
	push	ecx
	push	eax
	mov	eax, DWORD PTR _soap$[esp+4]
	call	_soap_outliteral
	add	esp, 8

; 2547 : }

	ret	16					; 00000010H
?soap_out@xsd__anyType@@UBEHPAUsoap@@PBDH1@Z ENDP	; xsd__anyType::soap_out
_TEXT	ENDS
PUBLIC	?soap_out_xsd__boolean@@YAHPAUsoap@@PBDHPBVxsd__boolean@@1@Z ; soap_out_xsd__boolean
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_id$ = 12						; size = 4
?soap_out_xsd__boolean@@YAHPAUsoap@@PBDHPBVxsd__boolean@@1@Z PROC ; soap_out_xsd__boolean
; _soap$ = ecx
; _a$ = eax

; 2443 : 	return soap_out_bool(soap, tag, id, &(a->xsd__boolean::__item), "xsd:boolean");

	add	eax, 12					; 0000000cH
	push	OFFSET ??_C@_0M@FGHMEICI@xsd?3boolean?$AA@
	push	eax
	mov	eax, DWORD PTR _id$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+8]
	call	?soap_out_bool@@YAHPAUsoap@@PBDHPB_N1@Z	; soap_out_bool
	add	esp, 12					; 0000000cH

; 2444 : }

	ret	0
?soap_out_xsd__boolean@@YAHPAUsoap@@PBDHPBVxsd__boolean@@1@Z ENDP ; soap_out_xsd__boolean
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
?soap_out@xsd__boolean@@UBEHPAUsoap@@PBDH1@Z PROC	; xsd__boolean::soap_out
; _this$ = ecx

; 2438 : 	return soap_out_xsd__boolean(soap, tag, id, this, type);

	mov	eax, DWORD PTR _soap$[esp-4]
	add	ecx, 12					; 0000000cH
	push	OFFSET ??_C@_0M@FGHMEICI@xsd?3boolean?$AA@
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	eax
	mov	eax, DWORD PTR _id$[esp+8]
	call	?soap_out_bool@@YAHPAUsoap@@PBDHPB_N1@Z	; soap_out_bool
	add	esp, 12					; 0000000cH

; 2439 : }

	ret	16					; 00000010H
?soap_out@xsd__boolean@@UBEHPAUsoap@@PBDH1@Z ENDP	; xsd__boolean::soap_out
_TEXT	ENDS
PUBLIC	?soap_out_xsd__string@@YAHPAUsoap@@PBDHPBVxsd__string@@1@Z ; soap_out_xsd__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_id$ = 12						; size = 4
?soap_out_xsd__string@@YAHPAUsoap@@PBDHPBVxsd__string@@1@Z PROC ; soap_out_xsd__string
; _soap$ = ecx
; _a$ = eax

; 2007 : 	return soap_out_std__string(soap, tag, id, &(a->xsd__string::__item), "xsd:string");

	add	eax, 12					; 0000000cH
	push	OFFSET ??_C@_0L@DIJPMJCO@xsd?3string?$AA@
	push	eax
	mov	eax, DWORD PTR _id$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+8]
	call	?soap_out_std__string@@YAHPAUsoap@@PBDHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; soap_out_std__string
	add	esp, 12					; 0000000cH

; 2008 : }

	ret	0
?soap_out_xsd__string@@YAHPAUsoap@@PBDHPBVxsd__string@@1@Z ENDP ; soap_out_xsd__string
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
?soap_out@xsd__string@@UBEHPAUsoap@@PBDH1@Z PROC	; xsd__string::soap_out
; _this$ = ecx

; 2002 : 	return soap_out_xsd__string(soap, tag, id, this, type);

	mov	eax, DWORD PTR _soap$[esp-4]
	add	ecx, 12					; 0000000cH
	push	OFFSET ??_C@_0L@DIJPMJCO@xsd?3string?$AA@
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	eax
	mov	eax, DWORD PTR _id$[esp+8]
	call	?soap_out_std__string@@YAHPAUsoap@@PBDHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; soap_out_std__string
	add	esp, 12					; 0000000cH

; 2003 : }

	ret	16					; 00000010H
?soap_out@xsd__string@@UBEHPAUsoap@@PBDH1@Z ENDP	; xsd__string::soap_out
_TEXT	ENDS
PUBLIC	?soap_out__ns2__getSessionIDElement@@YAHPAUsoap@@PBDHPBV_ns2__getSessionIDElement@@1@Z ; soap_out__ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out__ns2__getSessionIDElement@@YAHPAUsoap@@PBDHPBV_ns2__getSessionIDElement@@1@Z PROC ; soap_out__ns2__getSessionIDElement
; _tag$ = ecx
; _id$ = eax

; 1768 : {

	push	ebx
	mov	ebx, DWORD PTR _a$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 1769 : 	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getSessionIDElement), type))

	push	eax
	mov	esi, ecx
	push	edi
	mov	eax, 19					; 00000013H
	mov	ecx, ebx
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN2@soap_out__@4
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_out__@4
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_out__@4
$LN5@soap_out__@4:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_out__@4:
	test	eax, eax
	je	SHORT $LN2@soap_out__@4
$LN9@soap_out__@4:

; 1770 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 1775 : }

	ret	0
$LN2@soap_out__@4:

; 1771 : 	if (soap_out_PointerTostd__string(soap, "ns2:String_1", -1, &(a->_ns2__getSessionIDElement::String_USCORE1), ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	add	ebx, 4
	push	ebx
	push	OFFSET ??_C@_0N@EOBKMJFL@ns2?3String_1?$AA@
	or	eax, -1
	mov	ecx, edi
	call	?soap_out_PointerTostd__string@@YAHPAUsoap@@PBDHPBQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; soap_out_PointerTostd__string
	add	esp, 12					; 0000000cH
	test	eax, eax

; 1772 : 		return soap->error;

	jne	SHORT $LN9@soap_out__@4

; 1773 : 	/* transient soap skipped */
; 1774 : 	return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebx

; 1775 : }

	ret	0
?soap_out__ns2__getSessionIDElement@@YAHPAUsoap@@PBDHPBV_ns2__getSessionIDElement@@1@Z ENDP ; soap_out__ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
?soap_out@_ns2__getSessionIDElement@@UBEHPAUsoap@@PBDH1@Z PROC ; _ns2__getSessionIDElement::soap_out
; _this$ = ecx

; 1764 : 	return soap_out__ns2__getSessionIDElement(soap, tag, id, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _id$[esp]
	push	ecx
	mov	ecx, DWORD PTR _soap$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+8]
	call	?soap_out__ns2__getSessionIDElement@@YAHPAUsoap@@PBDHPBV_ns2__getSessionIDElement@@1@Z ; soap_out__ns2__getSessionIDElement
	add	esp, 12					; 0000000cH

; 1765 : }

	ret	16					; 00000010H
?soap_out@_ns2__getSessionIDElement@@UBEHPAUsoap@@PBDH1@Z ENDP ; _ns2__getSessionIDElement::soap_out
_TEXT	ENDS
PUBLIC	?soap_out__ns2__getSettingsFileResponseElement@@YAHPAUsoap@@PBDHPBV_ns2__getSettingsFileResponseElement@@1@Z ; soap_out__ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out__ns2__getSettingsFileResponseElement@@YAHPAUsoap@@PBDHPBV_ns2__getSettingsFileResponseElement@@1@Z PROC ; soap_out__ns2__getSettingsFileResponseElement
; _tag$ = ecx
; _id$ = eax

; 1343 : {

	push	ebx
	mov	ebx, DWORD PTR _a$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 1344 : 	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getSettingsFileResponseElement), type))

	push	eax
	mov	esi, ecx
	push	edi
	mov	eax, 22					; 00000016H
	mov	ecx, ebx
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN3@soap_out__@5
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_out__@5
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN8@soap_out__@5
$LN6@soap_out__@5:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN8@soap_out__@5:
	test	eax, eax
	je	SHORT $LN3@soap_out__@5
$LN10@soap_out__@5:

; 1345 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 1352 : }

	ret	0
$LN3@soap_out__@5:

; 1346 : 	if (a->result)

	add	ebx, 4
	cmp	DWORD PTR [ebx], 0
	je	SHORT $LN2@soap_out__@5

; 1347 : 		soap_element_result(soap, "ns2:result");

	mov	eax, edi
	call	_soap_element_result
$LN2@soap_out__@5:

; 1348 : 	if (soap_out_PointerTostd__string(soap, "ns2:result", -1, &(a->_ns2__getSettingsFileResponseElement::result), ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	ebx
	push	OFFSET ??_C@_0L@FEKNHBLL@ns2?3result?$AA@
	or	eax, -1
	mov	ecx, edi
	call	?soap_out_PointerTostd__string@@YAHPAUsoap@@PBDHPBQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; soap_out_PointerTostd__string
	add	esp, 12					; 0000000cH
	test	eax, eax

; 1349 : 		return soap->error;

	jne	SHORT $LN10@soap_out__@5

; 1350 : 	/* transient soap skipped */
; 1351 : 	return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebx

; 1352 : }

	ret	0
?soap_out__ns2__getSettingsFileResponseElement@@YAHPAUsoap@@PBDHPBV_ns2__getSettingsFileResponseElement@@1@Z ENDP ; soap_out__ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
?soap_out@_ns2__getSettingsFileResponseElement@@UBEHPAUsoap@@PBDH1@Z PROC ; _ns2__getSettingsFileResponseElement::soap_out
; _this$ = ecx

; 1339 : 	return soap_out__ns2__getSettingsFileResponseElement(soap, tag, id, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _id$[esp]
	push	ecx
	mov	ecx, DWORD PTR _soap$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+8]
	call	?soap_out__ns2__getSettingsFileResponseElement@@YAHPAUsoap@@PBDHPBV_ns2__getSettingsFileResponseElement@@1@Z ; soap_out__ns2__getSettingsFileResponseElement
	add	esp, 12					; 0000000cH

; 1340 : }

	ret	16					; 00000010H
?soap_out@_ns2__getSettingsFileResponseElement@@UBEHPAUsoap@@PBDH1@Z ENDP ; _ns2__getSettingsFileResponseElement::soap_out
_TEXT	ENDS
PUBLIC	?soap_out__ns2__submitEpochResultResponseElement@@YAHPAUsoap@@PBDHPBV_ns2__submitEpochResultResponseElement@@1@Z ; soap_out__ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out__ns2__submitEpochResultResponseElement@@YAHPAUsoap@@PBDHPBV_ns2__submitEpochResultResponseElement@@1@Z PROC ; soap_out__ns2__submitEpochResultResponseElement
; _tag$ = ecx
; _id$ = eax

; 1002 : {

	push	ebx
	mov	ebx, DWORD PTR _a$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 1003 : 	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__submitEpochResultResponseElement), type))

	push	eax
	mov	esi, ecx
	push	edi
	mov	eax, 24					; 00000018H
	mov	ecx, ebx
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN2@soap_out__@6
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_out__@6
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_out__@6
$LN5@soap_out__@6:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_out__@6:
	test	eax, eax
	je	SHORT $LN2@soap_out__@6
$LN9@soap_out__@6:

; 1004 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 1010 : }

	ret	0
$LN2@soap_out__@6:

; 1005 : 	soap_element_result(soap, "ns2:result");

	mov	eax, edi
	call	_soap_element_result

; 1006 : 	if (soap_out_bool(soap, "ns2:result", -1, &(a->_ns2__submitEpochResultResponseElement::result), ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	add	ebx, 4
	push	ebx
	push	edi
	or	eax, -1
	mov	ecx, OFFSET ??_C@_0L@FEKNHBLL@ns2?3result?$AA@
	call	?soap_out_bool@@YAHPAUsoap@@PBDHPB_N1@Z	; soap_out_bool
	add	esp, 12					; 0000000cH
	test	eax, eax

; 1007 : 		return soap->error;

	jne	SHORT $LN9@soap_out__@6

; 1008 : 	/* transient soap skipped */
; 1009 : 	return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebx

; 1010 : }

	ret	0
?soap_out__ns2__submitEpochResultResponseElement@@YAHPAUsoap@@PBDHPBV_ns2__submitEpochResultResponseElement@@1@Z ENDP ; soap_out__ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
?soap_out@_ns2__submitEpochResultResponseElement@@UBEHPAUsoap@@PBDH1@Z PROC ; _ns2__submitEpochResultResponseElement::soap_out
; _this$ = ecx

; 998  : 	return soap_out__ns2__submitEpochResultResponseElement(soap, tag, id, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _id$[esp]
	push	ecx
	mov	ecx, DWORD PTR _soap$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+8]
	call	?soap_out__ns2__submitEpochResultResponseElement@@YAHPAUsoap@@PBDHPBV_ns2__submitEpochResultResponseElement@@1@Z ; soap_out__ns2__submitEpochResultResponseElement
	add	esp, 12					; 0000000cH

; 999  : }

	ret	16					; 00000010H
?soap_out@_ns2__submitEpochResultResponseElement@@UBEHPAUsoap@@PBDH1@Z ENDP ; _ns2__submitEpochResultResponseElement::soap_out
_TEXT	ENDS
PUBLIC	?soap_out_float@@YAHPAUsoap@@PBDHPBM1@Z		; soap_out_float
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
?soap_out_float@@YAHPAUsoap@@PBDHPBM1@Z PROC		; soap_out_float
; _a$ = ecx
; _type$ = eax

; 878  : 	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);

	mov	edx, DWORD PTR _soap$[esp-4]
	push	eax
	mov	eax, DWORD PTR _id$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	edx
	call	_soap_outfloat
	add	esp, 12					; 0000000cH

; 879  : }

	ret	0
?soap_out_float@@YAHPAUsoap@@PBDHPBM1@Z ENDP		; soap_out_float
_TEXT	ENDS
PUBLIC	?soap_out_LONG64@@YAHPAUsoap@@PBDHPB_J1@Z	; soap_out_LONG64
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_a$ = 16						; size = 4
?soap_out_LONG64@@YAHPAUsoap@@PBDHPB_J1@Z PROC		; soap_out_LONG64
; _tag$ = ecx
; _type$ = eax

; 843  : 	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);

	mov	edx, DWORD PTR _soap$[esp-4]
	push	eax
	mov	eax, DWORD PTR _id$[esp]
	push	ecx
	mov	ecx, DWORD PTR _a$[esp+4]
	push	edx
	call	_soap_outLONG64
	add	esp, 12					; 0000000cH

; 844  : }

	ret	0
?soap_out_LONG64@@YAHPAUsoap@@PBDHPB_J1@Z ENDP		; soap_out_LONG64
_TEXT	ENDS
PUBLIC	?soap_out_int@@YAHPAUsoap@@PBDHPBH1@Z		; soap_out_int
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
?soap_out_int@@YAHPAUsoap@@PBDHPBH1@Z PROC		; soap_out_int
; _a$ = ecx
; _type$ = eax

; 808  : 	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);

	mov	edx, DWORD PTR _soap$[esp-4]
	push	eax
	mov	eax, DWORD PTR _id$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	edx
	call	_soap_outint
	add	esp, 12					; 0000000cH

; 809  : }

	ret	0
?soap_out_int@@YAHPAUsoap@@PBDHPBH1@Z ENDP		; soap_out_int
_TEXT	ENDS
PUBLIC	?soap_out_byte@@YAHPAUsoap@@PBDH11@Z		; soap_out_byte
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
?soap_out_byte@@YAHPAUsoap@@PBDH11@Z PROC		; soap_out_byte
; _a$ = ecx
; _type$ = eax

; 773  : 	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);

	mov	edx, DWORD PTR _soap$[esp-4]
	push	eax
	mov	eax, DWORD PTR _id$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	edx
	call	_soap_outbyte
	add	esp, 12					; 0000000cH

; 774  : }

	ret	0
?soap_out_byte@@YAHPAUsoap@@PBDH11@Z ENDP		; soap_out_byte
_TEXT	ENDS
PUBLIC	_soap_faultdetail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_faultdetail PROC
; _soap$ = eax

; 115  : {

	push	edi
	mov	edi, eax

; 116  : 	soap_fault(soap);

	call	_soap_fault

; 117  : 	if (soap->version == 1)

	cmp	WORD PTR [edi+6], 1
	jne	SHORT $LN3@soap_fault@2

; 118  : 	{	if (!soap->fault->detail)

	mov	eax, DWORD PTR [edi+12208]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN6@soap_fault@2

; 119  : 		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));

	mov	eax, 12					; 0000000cH
	call	_soap_malloc
	mov	ecx, DWORD PTR [edi+12208]
	mov	DWORD PTR [ecx+12], eax

; 120  : 			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);

	mov	edx, DWORD PTR [edi+12208]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
$LN6@soap_fault@2:

; 121  : 		}
; 122  : 		return (const char**)&soap->fault->detail->__any;

	mov	eax, DWORD PTR [edi+12208]
	mov	eax, DWORD PTR [eax+12]

; 127  : 	}
; 128  : 	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;

	add	eax, 8
	pop	edi

; 129  : }

	ret	0
$LN3@soap_fault@2:

; 123  : 	}
; 124  : 	if (!soap->fault->SOAP_ENV__Detail)

	mov	ecx, DWORD PTR [edi+12208]
	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN8@soap_fault@2

; 125  : 	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);

	call	?soap_new_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@H@Z ; soap_new_SOAP_ENV__Detail
	mov	edx, DWORD PTR [edi+12208]
	mov	DWORD PTR [edx+32], eax

; 126  : 		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);

	mov	eax, DWORD PTR [edi+12208]
	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
$LN8@soap_fault@2:

; 127  : 	}
; 128  : 	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;

	mov	ecx, DWORD PTR [edi+12208]
	mov	eax, DWORD PTR [ecx+32]
	add	eax, 8
	pop	edi

; 129  : }

	ret	0
_soap_faultdetail ENDP
_TEXT	ENDS
PUBLIC	_soap_faultstring
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_faultstring PROC
; _soap$ = esi

; 108  : 	soap_fault(soap);

	mov	eax, esi
	call	_soap_fault

; 109  : 	if (soap->version == 2)

	cmp	WORD PTR [esi+6], 2

; 110  : 		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;

	mov	eax, DWORD PTR [esi+12208]
	jne	SHORT $LN1@soap_fault@3
	mov	eax, DWORD PTR [eax+20]

; 112  : }

	ret	0
$LN1@soap_fault@3:

; 111  : 	return (const char**)&soap->fault->faultstring;

	add	eax, 4

; 112  : }

	ret	0
_soap_faultstring ENDP
_TEXT	ENDS
PUBLIC	_soap_faultsubcode
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_faultsubcode PROC
; _soap$ = eax

; 94   : {

	push	edi
	mov	edi, eax

; 95   : 	soap_fault(soap);

	call	_soap_fault

; 96   : 	if (soap->version == 2)

	cmp	WORD PTR [edi+6], 2

; 97   : 	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)

	mov	eax, DWORD PTR [edi+12208]
	jne	SHORT $LN3@soap_fault@4
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN5@soap_fault@4

; 98   : 		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);

	call	?soap_new_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@H@Z ; soap_new_SOAP_ENV__Code
	mov	edx, DWORD PTR [edi+12208]
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+4], eax

; 99   : 			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);

	mov	edx, DWORD PTR [edi+12208]
	mov	eax, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN5@soap_fault@4:

; 100  : 		}
; 101  : 		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;

	mov	ecx, DWORD PTR [edi+12208]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
$LN3@soap_fault@4:
	pop	edi

; 102  : 	}
; 103  : 	return (const char**)&soap->fault->faultcode;
; 104  : }

	ret	0
_soap_faultsubcode ENDP
_TEXT	ENDS
PUBLIC	_soap_faultcode
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_faultcode PROC
; _soap$ = esi

; 87   : 	soap_fault(soap);

	mov	eax, esi
	call	_soap_fault

; 88   : 	if (soap->version == 2)

	cmp	WORD PTR [esi+6], 2

; 89   : 		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;

	mov	eax, DWORD PTR [esi+12208]
	jne	SHORT $LN2@soap_fault@5
	mov	eax, DWORD PTR [eax+16]
$LN2@soap_fault@5:

; 90   : 	return (const char**)&soap->fault->faultcode;
; 91   : }

	ret	0
_soap_faultcode ENDP
_TEXT	ENDS
PUBLIC	_soap_serializefault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_serializefault PROC
; _soap$ = esi

; 68   : 	soap_fault(soap);

	mov	eax, esi
	call	_soap_fault

; 69   : 	if (soap->fault)

	mov	eax, DWORD PTR [esi+12208]
	test	eax, eax
	je	SHORT $LN1@soap_seria@15

; 70   : 		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);

	mov	ecx, esi
	jmp	?soap_serialize_SOAP_ENV__Fault@@YAXPAUsoap@@PBUSOAP_ENV__Fault@@@Z ; soap_serialize_SOAP_ENV__Fault
$LN1@soap_seria@15:

; 71   : }

	ret	0
_soap_serializefault ENDP
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z
_TEXT	SEGMENT
__Tmp$88913 = 8						; size = 4
__Tmp$88903 = 8						; size = 4
__Val$ = 8						; size = 4
__Where$ = 12						; size = 8
?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z PROC ; std::vector<float,std::allocator<float> >::_Insert_n, COMDAT
; _this$ = eax

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR [esi+12]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN29@Insert_n@3
	xor	ebp, ebp
	jmp	SHORT $LN205@Insert_n@3
$LN29@Insert_n@3:
	mov	ebp, DWORD PTR [esi+20]
	sub	ebp, ecx
	sar	ebp, 2
$LN205@Insert_n@3:

; 1162 : 
; 1163 : 		if (_Count == 0)
; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+16]
	mov	eax, ebx
	sub	eax, ecx
	sar	eax, 2
	mov	ecx, 1073741823				; 3fffffffH
	sub	ecx, eax
	cmp	ecx, 1
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ; std::vector<float,std::allocator<float> >::_Xlen
$LN207@Insert_n@3:
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	inc	eax
	cmp	ebp, eax
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, ebp
	shr	ecx, 1
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, ecx
	cmp	edx, ebp
	jae	SHORT $LN17@Insert_n@3
	xor	ebp, ebp
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	add	ebp, ecx
$LN18@Insert_n@3:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ebp, eax

; 1172 : 				_Capacity = size() + _Count;

	cmovb	ebp, eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, ebp
	call	?allocate@?$allocator@M@std@@QAEPAMI@Z	; std::allocator<float>::allocate

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edi, DWORD PTR __Where$[esp+16]
	sub	edi, DWORD PTR [esi+12]
	mov	ebx, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+12]
	fld	DWORD PTR [eax]
	sar	edi, 2
	fstp	DWORD PTR [ebx+edi*4]

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	ecx, DWORD PTR [esi+12]
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN102@Insert_n@3
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	ebx
	call	_memmove_s
	mov	edx, DWORD PTR __Where$[esp+32]
	add	esp, 16					; 00000010H
$LN102@Insert_n@3:

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+16]
	sub	eax, edx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN133@Insert_n@3
	add	eax, eax
	add	eax, eax
	push	eax
	push	edx
	push	eax
	lea	ecx, DWORD PTR [ebx+edi*4+4]
	push	ecx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN133@Insert_n@3:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+16]
	sub	edi, eax
	sar	edi, 2
	inc	edi

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN140@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN140@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	lea	edx, DWORD PTR [ebx+ebp*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	eax, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+20], edx
	mov	DWORD PTR [esi+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+12], ebx

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	12					; 0000000cH
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edi, DWORD PTR __Where$[esp+16]
	mov	ecx, ebx
	sub	ecx, edi
	sar	ecx, 2
	cmp	ecx, 1
	jae	SHORT $LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[esp+12]
	movss	xmm0, DWORD PTR [edx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	edx, DWORD PTR [edi+4]
	mov	eax, ebx
	movss	DWORD PTR __Tmp$88903[esp+12], xmm0
	call	??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ; std::vector<float,std::allocator<float> >::_Umove<float *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Where$[esp+16]
	mov	edx, edi
	sub	edx, eax
	sar	edx, 2
	mov	ecx, 1
	sub	ecx, edx
	je	SHORT $LN162@Insert_n@3
	mov	eax, DWORD PTR __Tmp$88903[esp+12]
	rep stosd
	mov	eax, DWORD PTR __Where$[esp+16]
$LN162@Insert_n@3:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+16], 4
	mov	esi, DWORD PTR [esi+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	ecx, DWORD PTR [esi-4]
	cmp	eax, ecx
	je	SHORT $LN190@Insert_n@3
	movss	xmm0, DWORD PTR __Tmp$88903[esp+12]
$LL177@Insert_n@3:
	movss	DWORD PTR [eax], xmm0
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL177@Insert_n@3

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	12					; 0000000cH
$LN3@Insert_n@3:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[esp+12]
	movss	xmm0, DWORD PTR [eax]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [ebx-4]
	mov	edx, ebx
	mov	eax, ebx
	movss	DWORD PTR __Tmp$88913[esp+12], xmm0
	call	??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ; std::vector<float,std::allocator<float> >::_Umove<float *>
	mov	DWORD PTR [esi+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, edi
	mov	edi, DWORD PTR __Where$[esp+16]
	mov	ecx, ebx
	call	??$_Unchecked_move_backward@PAMPAM@stdext@@YAPAMPAM00@Z ; stdext::_Unchecked_move_backward<float *,float *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	ecx, DWORD PTR [eax+4]
	cmp	eax, ecx
	je	SHORT $LN190@Insert_n@3
	movss	xmm0, DWORD PTR __Tmp$88913[esp+12]
$LL192@Insert_n@3:
	movss	DWORD PTR [eax], xmm0
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL192@Insert_n@3
$LN190@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	12					; 0000000cH
$LN206@Insert_n@3:
?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z ENDP ; std::vector<float,std::allocator<float> >::_Insert_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@ABM@Z
_TEXT	SEGMENT
__Tmp$576302 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?insert@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@ABM@Z PROC ; std::vector<float,std::allocator<float> >::insert, COMDAT
; _this$ = eax

; 875  : 		{	// insert _Val at _Where

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR [esi+12]
	mov	ecx, eax
	sub	ecx, edi
	test	ecx, -4					; fffffffcH
	jne	SHORT $LN3@insert@16
	xor	ebx, ebx
	jmp	SHORT $LN4@insert@16
$LN3@insert@16:
	cmp	edi, eax
	jbe	SHORT $LN12@insert@16
	call	__invalid_parameter_noinfo
$LN12@insert@16:
	mov	ecx, DWORD PTR __Where$[esp+24]
	mov	eax, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN23@insert@16
	cmp	ecx, eax
	je	SHORT $LN24@insert@16
$LN23@insert@16:
	call	__invalid_parameter_noinfo
$LN24@insert@16:
	mov	ebx, DWORD PTR __Where$[esp+28]
	sub	ebx, edi
	sar	ebx, 2
$LN4@insert@16:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Where$[esp+28]
	mov	eax, DWORD PTR __Where$[esp+24]
	mov	ecx, DWORD PTR __Val$[esp+24]
	push	edx
	push	eax
	push	ecx
	mov	eax, esi
	call	?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z ; std::vector<float,std::allocator<float> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edi, DWORD PTR [esi+12]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN36@insert@16
	call	__invalid_parameter_noinfo
$LN36@insert@16:
	mov	esi, DWORD PTR [esi]
	mov	ebp, esi
	mov	DWORD PTR __Tmp$576302[esp+32], edi
	test	esi, esi
	jne	SHORT $LN70@insert@16
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN61@insert@16:
	lea	edi, DWORD PTR [edi+ebx*4]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN51@insert@16
	test	esi, esi
	je	SHORT $LN66@insert@16
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN67@insert@16
$LN70@insert@16:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN61@insert@16
$LN66@insert@16:
	xor	esi, esi
$LN67@insert@16:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN52@insert@16
$LN51@insert@16:
	call	__invalid_parameter_noinfo
$LN52@insert@16:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax+4], edi

; 879  : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
?insert@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@ABM@Z ENDP ; std::vector<float,std::allocator<float> >::insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@MV?$allocator@M@std@@@std@@QAEXABM@Z
_TEXT	SEGMENT
$T576309 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@MV?$allocator@M@std@@@std@@QAEXABM@Z PROC ; std::vector<float,std::allocator<float> >::push_back, COMDAT
; _this$ = edi

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [edi+12]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
	push	esi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@4
	xor	eax, eax
	jmp	SHORT $LN10@push_back@4
$LN9@push_back@4:
	mov	eax, DWORD PTR [edi+20]
	sub	eax, ecx
	sar	eax, 2
$LN10@push_back@4:
	mov	esi, DWORD PTR [edi+16]
	mov	edx, esi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN2@push_back@4

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	fld	DWORD PTR [ebx]
	add	esi, 4
	fstp	DWORD PTR [esi-4]
	mov	DWORD PTR [edi+16], esi

; 824  : 		}

	pop	esi
	pop	ebx
	add	esp, 8
	ret	4
$LN2@push_back@4:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	cmp	ecx, esi
	jbe	SHORT $LN39@push_back@4
	call	__invalid_parameter_noinfo
$LN39@push_back@4:
	mov	eax, DWORD PTR [edi]
	push	esi
	push	eax
	push	ebx
	lea	eax, DWORD PTR $T576309[esp+28]
	push	eax
	mov	eax, edi
	call	?insert@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@ABM@Z ; std::vector<float,std::allocator<float> >::insert

; 824  : 		}

	pop	esi
	pop	ebx
	add	esp, 8
	ret	4
?push_back@?$vector@MV?$allocator@M@std@@@std@@QAEXABM@Z ENDP ; std::vector<float,std::allocator<float> >::push_back
_TEXT	ENDS
PUBLIC	?soap_copy_std__vectorTemplateOfint@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy_std__vectorTemplateOfint
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapc.cpp
_TEXT	SEGMENT
_p$ = 8							; size = 4
?soap_copy_std__vectorTemplateOfint@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy_std__vectorTemplateOfint
; _q$ = eax

; 4499 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<int > %p -> %p\n", q, p));
; 4500 : 	*(std::vector<int >*)p = *(std::vector<int >*)q;

	push	eax
	mov	eax, DWORD PTR _p$[esp]
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=

; 4501 : }

	ret	0
?soap_copy_std__vectorTemplateOfint@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy_std__vectorTemplateOfint
_TEXT	ENDS
PUBLIC	?soap_instantiate_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_std__vectorTemplateOfint
__unwindtable$?soap_instantiate_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@HPBD1PAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@HPBD1PAI@Z$0
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?soap_instantiate_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@HPBD1PAI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?soap_instantiate_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@HPBD1PAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T576555 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_size$ = 8						; size = 4
?soap_instantiate_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate_std__vectorTemplateOfint
; _soap$ = edi

; 4475 : {

	push	-1
	push	__ehhandler$?soap_instantiate_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@HPBD1PAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebp
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _size$[esp+28]

; 4476 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 4477 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN19@soap_insta@21
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 26			; 0000001aH
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete

; 4480 : 	if (n < 0)
; 4481 : 	{	cp->ptr = (void*)new std::vector<int >;

	push	24					; 00000018H
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T576555[esp+32], eax
	mov	DWORD PTR __$EHRec$[esp+40], 0
	test	eax, eax
	je	SHORT $LN9@soap_insta@21
	mov	ecx, eax
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	jmp	SHORT $LN10@soap_insta@21
$LN19@soap_insta@21:

; 4478 : 	if (!cp)
; 4479 : 		return NULL;

	xor	eax, eax

; 4496 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	add	esp, 20					; 00000014H
	ret	0
$LN9@soap_insta@21:

; 4480 : 	if (n < 0)
; 4481 : 	{	cp->ptr = (void*)new std::vector<int >;

	xor	eax, eax
$LN10@soap_insta@21:
	mov	DWORD PTR [esi+4], eax

; 4482 : 		if (size)

	test	ebp, ebp
	je	SHORT $LN4@soap_insta@21

; 4483 : 			*size = sizeof(std::vector<int >);

	mov	DWORD PTR [ebp], 24			; 00000018H
$LN4@soap_insta@21:

; 4484 : 	}
; 4485 : 	else
; 4486 : 	{	cp->ptr = (void*)new std::vector<int >[n];
; 4487 : 		if (!cp->ptr)
; 4488 : 		{	soap->error = SOAP_EOM;
; 4489 : 			return NULL;
; 4490 : 		}
; 4491 : 		if (size)
; 4492 : 			*size = n * sizeof(std::vector<int >);
; 4493 : 	}
; 4494 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 4495 : 	return (std::vector<int >*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]

; 4496 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	add	esp, 20					; 00000014H
	ret	0
__unwindfunclet$?soap_instantiate_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@HPBD1PAI@Z$0:
	mov	eax, DWORD PTR $T576555[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?soap_instantiate_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@HPBD1PAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?soap_instantiate_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@HPBD1PAI@Z
	jmp	___CxxFrameHandler3
?soap_instantiate_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate_std__vectorTemplateOfint
PUBLIC	?soap_new_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@H@Z ; soap_new_std__vectorTemplateOfint
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@H@Z PROC ; soap_new_std__vectorTemplateOfint
; _soap$ = edi

; 4467 : {	return soap_instantiate_std__vectorTemplateOfint(soap, n, NULL, NULL, NULL);

	push	ecx
	push	0
	call	?soap_instantiate_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_std__vectorTemplateOfint
	add	esp, 4
	pop	ecx

; 4468 : }

	ret	0
?soap_new_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@H@Z ENDP ; soap_new_std__vectorTemplateOfint
_TEXT	ENDS
PUBLIC	?soap_out_std__vectorTemplateOfint@@YAHPAUsoap@@PBDHPBV?$vector@HV?$allocator@H@std@@@std@@1@Z ; soap_out_std__vectorTemplateOfint
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_a$ = 16						; size = 4
?soap_out_std__vectorTemplateOfint@@YAHPAUsoap@@PBDHPBV?$vector@HV?$allocator@H@std@@@std@@1@Z PROC ; soap_out_std__vectorTemplateOfint

; 4424 : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _a$[esp+4]
	push	esi

; 4425 : 	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)

	mov	esi, DWORD PTR [ebp+12]
	push	edi
	cmp	esi, DWORD PTR [ebp+16]
	jbe	SHORT $LN10@soap_out_s@2
	call	__invalid_parameter_noinfo
$LN10@soap_out_s@2:
	mov	edi, DWORD PTR [ebp]
$LL23@soap_out_s@2:
	mov	ebx, DWORD PTR [ebp+16]
	cmp	DWORD PTR [ebp+12], ebx
	jbe	SHORT $LN36@soap_out_s@2
	call	__invalid_parameter_noinfo
$LN36@soap_out_s@2:
	mov	eax, DWORD PTR [ebp]
	test	edi, edi
	je	SHORT $LN49@soap_out_s@2
	cmp	edi, eax
	je	SHORT $LN50@soap_out_s@2
$LN49@soap_out_s@2:
	call	__invalid_parameter_noinfo
$LN50@soap_out_s@2:
	cmp	esi, ebx
	je	SHORT $LN2@soap_out_s@2

; 4426 : 	{
; 4427 : 		if (soap_out_int(soap, tag, id, &(*i), ""))

	test	edi, edi
	jne	SHORT $LN74@soap_out_s@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN66@soap_out_s@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN57@soap_out_s@2
	call	__invalid_parameter_noinfo
$LN57@soap_out_s@2:
	mov	ebx, DWORD PTR _soap$[esp+12]
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	esi
	push	ebx
	or	eax, -1
	call	_soap_outint
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN72@soap_out_s@2

; 4425 : 	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)

	test	edi, edi
	jne	SHORT $LN73@soap_out_s@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN30@soap_out_s@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN21@soap_out_s@2
	call	__invalid_parameter_noinfo
$LN21@soap_out_s@2:
	add	esi, 4
	jmp	SHORT $LL23@soap_out_s@2
$LN74@soap_out_s@2:

; 4426 : 	{
; 4427 : 		if (soap_out_int(soap, tag, id, &(*i), ""))

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN66@soap_out_s@2
$LN73@soap_out_s@2:

; 4425 : 	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN30@soap_out_s@2
$LN72@soap_out_s@2:

; 4428 : 			return soap->error;

	mov	eax, DWORD PTR [ebx+90460]

; 4429 : 	}
; 4430 : 	return SOAP_OK;
; 4431 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
$LN2@soap_out_s@2:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx
	ret	0
?soap_out_std__vectorTemplateOfint@@YAHPAUsoap@@PBDHPBV?$vector@HV?$allocator@H@std@@@std@@1@Z ENDP ; soap_out_std__vectorTemplateOfint
_TEXT	ENDS
PUBLIC	?soap_copy_std__vectorTemplateOffloat@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy_std__vectorTemplateOffloat
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_p$ = 8							; size = 4
?soap_copy_std__vectorTemplateOffloat@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy_std__vectorTemplateOffloat
; _q$ = eax

; 4410 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<float > %p -> %p\n", q, p));
; 4411 : 	*(std::vector<float >*)p = *(std::vector<float >*)q;

	push	eax
	mov	eax, DWORD PTR _p$[esp]
	call	??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<float,std::allocator<float> >::operator=

; 4412 : }

	ret	0
?soap_copy_std__vectorTemplateOffloat@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy_std__vectorTemplateOffloat
_TEXT	ENDS
PUBLIC	?soap_instantiate_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_std__vectorTemplateOffloat
__unwindtable$?soap_instantiate_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@HPBD1PAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@HPBD1PAI@Z$0
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?soap_instantiate_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@HPBD1PAI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?soap_instantiate_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@HPBD1PAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T576768 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_size$ = 8						; size = 4
?soap_instantiate_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate_std__vectorTemplateOffloat
; _soap$ = edi

; 4386 : {

	push	-1
	push	__ehhandler$?soap_instantiate_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@HPBD1PAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebp
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _size$[esp+28]

; 4387 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOffloat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 4388 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOffloat, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN19@soap_insta@22
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 27			; 0000001bH
	mov	DWORD PTR [esi+12], -1
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete

; 4391 : 	if (n < 0)
; 4392 : 	{	cp->ptr = (void*)new std::vector<float >;

	push	24					; 00000018H
	mov	DWORD PTR [edi+96], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T576768[esp+32], eax
	mov	DWORD PTR __$EHRec$[esp+40], 0
	test	eax, eax
	je	SHORT $LN9@soap_insta@22
	mov	ecx, eax
	call	??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	jmp	SHORT $LN10@soap_insta@22
$LN19@soap_insta@22:

; 4389 : 	if (!cp)
; 4390 : 		return NULL;

	xor	eax, eax

; 4407 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	add	esp, 20					; 00000014H
	ret	0
$LN9@soap_insta@22:

; 4391 : 	if (n < 0)
; 4392 : 	{	cp->ptr = (void*)new std::vector<float >;

	xor	eax, eax
$LN10@soap_insta@22:
	mov	DWORD PTR [esi+4], eax

; 4393 : 		if (size)

	test	ebp, ebp
	je	SHORT $LN4@soap_insta@22

; 4394 : 			*size = sizeof(std::vector<float >);

	mov	DWORD PTR [ebp], 24			; 00000018H
$LN4@soap_insta@22:

; 4395 : 	}
; 4396 : 	else
; 4397 : 	{	cp->ptr = (void*)new std::vector<float >[n];
; 4398 : 		if (!cp->ptr)
; 4399 : 		{	soap->error = SOAP_EOM;
; 4400 : 			return NULL;
; 4401 : 		}
; 4402 : 		if (size)
; 4403 : 			*size = n * sizeof(std::vector<float >);
; 4404 : 	}
; 4405 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 4406 : 	return (std::vector<float >*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]

; 4407 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	add	esp, 20					; 00000014H
	ret	0
__unwindfunclet$?soap_instantiate_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@HPBD1PAI@Z$0:
	mov	eax, DWORD PTR $T576768[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?soap_instantiate_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@HPBD1PAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?soap_instantiate_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@HPBD1PAI@Z
	jmp	___CxxFrameHandler3
?soap_instantiate_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate_std__vectorTemplateOffloat
PUBLIC	?soap_new_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@H@Z ; soap_new_std__vectorTemplateOffloat
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@H@Z PROC ; soap_new_std__vectorTemplateOffloat
; _soap$ = edi

; 4378 : {	return soap_instantiate_std__vectorTemplateOffloat(soap, n, NULL, NULL, NULL);

	push	ecx
	push	0
	call	?soap_instantiate_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_std__vectorTemplateOffloat
	add	esp, 4
	pop	ecx

; 4379 : }

	ret	0
?soap_new_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@H@Z ENDP ; soap_new_std__vectorTemplateOffloat
_TEXT	ENDS
PUBLIC	?soap_out_std__vectorTemplateOffloat@@YAHPAUsoap@@PBDHPBV?$vector@MV?$allocator@M@std@@@std@@1@Z ; soap_out_std__vectorTemplateOffloat
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_a$ = 16						; size = 4
?soap_out_std__vectorTemplateOffloat@@YAHPAUsoap@@PBDHPBV?$vector@MV?$allocator@M@std@@@std@@1@Z PROC ; soap_out_std__vectorTemplateOffloat

; 4335 : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _a$[esp+4]
	push	esi

; 4336 : 	for (std::vector<float >::const_iterator i = a->begin(); i != a->end(); ++i)

	mov	esi, DWORD PTR [ebp+12]
	push	edi
	cmp	esi, DWORD PTR [ebp+16]
	jbe	SHORT $LN10@soap_out_s@3
	call	__invalid_parameter_noinfo
$LN10@soap_out_s@3:
	mov	edi, DWORD PTR [ebp]
$LL23@soap_out_s@3:
	mov	ebx, DWORD PTR [ebp+16]
	cmp	DWORD PTR [ebp+12], ebx
	jbe	SHORT $LN36@soap_out_s@3
	call	__invalid_parameter_noinfo
$LN36@soap_out_s@3:
	mov	eax, DWORD PTR [ebp]
	test	edi, edi
	je	SHORT $LN49@soap_out_s@3
	cmp	edi, eax
	je	SHORT $LN50@soap_out_s@3
$LN49@soap_out_s@3:
	call	__invalid_parameter_noinfo
$LN50@soap_out_s@3:
	cmp	esi, ebx
	je	SHORT $LN2@soap_out_s@3

; 4337 : 	{
; 4338 : 		if (soap_out_float(soap, tag, id, &(*i), ""))

	test	edi, edi
	jne	SHORT $LN74@soap_out_s@3
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN66@soap_out_s@3:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN57@soap_out_s@3
	call	__invalid_parameter_noinfo
$LN57@soap_out_s@3:
	mov	ebx, DWORD PTR _soap$[esp+12]
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	esi
	push	ebx
	or	eax, -1
	call	_soap_outfloat
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN72@soap_out_s@3

; 4336 : 	for (std::vector<float >::const_iterator i = a->begin(); i != a->end(); ++i)

	test	edi, edi
	jne	SHORT $LN73@soap_out_s@3
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN30@soap_out_s@3:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN21@soap_out_s@3
	call	__invalid_parameter_noinfo
$LN21@soap_out_s@3:
	add	esi, 4
	jmp	SHORT $LL23@soap_out_s@3
$LN74@soap_out_s@3:

; 4337 : 	{
; 4338 : 		if (soap_out_float(soap, tag, id, &(*i), ""))

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN66@soap_out_s@3
$LN73@soap_out_s@3:

; 4336 : 	for (std::vector<float >::const_iterator i = a->begin(); i != a->end(); ++i)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN30@soap_out_s@3
$LN72@soap_out_s@3:

; 4339 : 			return soap->error;

	mov	eax, DWORD PTR [ebx+90460]

; 4340 : 	}
; 4341 : 	return SOAP_OK;
; 4342 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
$LN2@soap_out_s@3:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx
	ret	0
?soap_out_std__vectorTemplateOffloat@@YAHPAUsoap@@PBDHPBV?$vector@MV?$allocator@M@std@@@std@@1@Z ENDP ; soap_out_std__vectorTemplateOffloat
_TEXT	ENDS
PUBLIC	?soap_out_string@@YAHPAUsoap@@PBDHPBQAD1@Z	; soap_out_string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
?soap_out_string@@YAHPAUsoap@@PBDHPBQAD1@Z PROC		; soap_out_string
; _a$ = ecx
; _type$ = eax

; 4309 : 	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);

	mov	edx, DWORD PTR _tag$[esp-4]
	push	4
	push	eax
	mov	eax, DWORD PTR _id$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR _soap$[esp+8]
	push	edx
	call	_soap_outstring
	add	esp, 16					; 00000010H

; 4310 : }

	ret	0
?soap_out_string@@YAHPAUsoap@@PBDHPBQAD1@Z ENDP		; soap_out_string
_TEXT	ENDS
PUBLIC	?soap_out__QName@@YAHPAUsoap@@PBDHPBQAD1@Z	; soap_out__QName
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
?soap_out__QName@@YAHPAUsoap@@PBDHPBQAD1@Z PROC		; soap_out__QName
; _a$ = ecx
; _type$ = eax

; 4269 : 	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);

	mov	edx, DWORD PTR _tag$[esp-4]
	push	5
	push	eax
	mov	eax, DWORD PTR _id$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR _soap$[esp+8]
	push	edx
	call	_soap_outstring
	add	esp, 16					; 00000010H

; 4270 : }

	ret	0
?soap_out__QName@@YAHPAUsoap@@PBDHPBQAD1@Z ENDP		; soap_out__QName
_TEXT	ENDS
PUBLIC	?soap_in_PointerTo_ns2__getSessionIDElement@@YAPAPAV_ns2__getSessionIDElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
?soap_in_PointerTo_ns2__getSessionIDElement@@YAPAPAV_ns2__getSessionIDElement@@PAUsoap@@PBDPAPAV1@1@Z PROC ; soap_in_PointerTo_ns2__getSessionIDElement
; _soap$ = ecx
; _a$ = eax

; 4176 : {

	push	ebx
	mov	ebx, DWORD PTR _tag$[esp]
	push	esi
	push	edi
	mov	edi, eax
	mov	esi, ecx

; 4177 : 	if (soap_element_begin_in(soap, tag, 1, NULL))
; 4178 : 		return NULL;
; 4179 : 	if (!a)

	test	edi, edi
	jne	SHORT $LN6@soap_in_Po

; 4180 : 		if (!(a = (_ns2__getSessionIDElement **)soap_malloc(soap, sizeof(_ns2__getSessionIDElement *))))

	lea	eax, DWORD PTR [edi+4]
	mov	edi, esi
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi

; 4181 : 			return NULL;

	je	SHORT $LN19@soap_in_Po
$LN6@soap_in_Po:

; 4182 : 	*a = NULL;

	mov	DWORD PTR [edi], 0

; 4183 : 	if (!soap->null && *soap->href != '#')

	cmp	WORD PTR [esi+87300], 0
	jne	SHORT $LN5@soap_in_Po
	cmp	BYTE PTR [esi+82100], 35		; 00000023H
	je	SHORT $LN5@soap_in_Po

; 4184 : 	{	soap_revert(soap);

	or	ecx, -1
	cmp	WORD PTR [esi+87308], 0
	jne	SHORT $LN15@soap_in_Po
	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	WORD PTR [esi+87308], ax
	je	SHORT $LN15@soap_in_Po
	add	DWORD PTR [esi+12444], ecx
$LN15@soap_in_Po:

; 4185 : 		if (!(*a = (_ns2__getSessionIDElement *)soap_instantiate__ns2__getSessionIDElement(soap, -1, soap->type, soap->arrayType, NULL)))

	push	0
	push	esi
	call	?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSessionIDElement
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax

; 4186 : 			return NULL;

	je	SHORT $LN19@soap_in_Po

; 4187 : 		(*a)->soap_default(soap);

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	push	esi
	call	eax

; 4188 : 		if (!(*a)->soap_in(soap, tag, NULL))

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	push	0
	push	ebx
	push	esi
	call	eax
	test	eax, eax
	jne	SHORT $LN1@soap_in_Po
$LN19@soap_in_Po:
	pop	edi
	pop	esi

; 4189 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 4198 : }

	ret	0
$LN5@soap_in_Po:

; 4190 : 	}
; 4191 : 	else
; 4192 : 	{	_ns2__getSessionIDElement ** p = (_ns2__getSessionIDElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getSessionIDElement, sizeof(_ns2__getSessionIDElement), 0);

	push	12					; 0000000cH
	push	19					; 00000013H
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	mov	ecx, esi
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH

; 4193 : 		a = p;
; 4194 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in_Po
	push	ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 4195 : 			return NULL;

	jne	SHORT $LN19@soap_in_Po
$LN1@soap_in_Po:

; 4196 : 	}
; 4197 : 	return a;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 4198 : }

	ret	0
?soap_in_PointerTo_ns2__getSessionIDElement@@YAPAPAV_ns2__getSessionIDElement@@PAUsoap@@PBDPAPAV1@1@Z ENDP ; soap_in_PointerTo_ns2__getSessionIDElement
_TEXT	ENDS
PUBLIC	?soap_in_PointerTo_ns2__getSessionIDResponseElement@@YAPAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
?soap_in_PointerTo_ns2__getSessionIDResponseElement@@YAPAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PBDPAPAV1@1@Z PROC ; soap_in_PointerTo_ns2__getSessionIDResponseElement
; _soap$ = ecx
; _a$ = eax

; 4121 : {

	push	ebx
	mov	ebx, DWORD PTR _tag$[esp]
	push	esi
	push	edi
	mov	edi, eax
	mov	esi, ecx

; 4122 : 	if (soap_element_begin_in(soap, tag, 1, NULL))
; 4123 : 		return NULL;
; 4124 : 	if (!a)

	test	edi, edi
	jne	SHORT $LN6@soap_in_Po@2

; 4125 : 		if (!(a = (_ns2__getSessionIDResponseElement **)soap_malloc(soap, sizeof(_ns2__getSessionIDResponseElement *))))

	lea	eax, DWORD PTR [edi+4]
	mov	edi, esi
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi

; 4126 : 			return NULL;

	je	SHORT $LN19@soap_in_Po@2
$LN6@soap_in_Po@2:

; 4127 : 	*a = NULL;

	mov	DWORD PTR [edi], 0

; 4128 : 	if (!soap->null && *soap->href != '#')

	cmp	WORD PTR [esi+87300], 0
	jne	SHORT $LN5@soap_in_Po@2
	cmp	BYTE PTR [esi+82100], 35		; 00000023H
	je	SHORT $LN5@soap_in_Po@2

; 4129 : 	{	soap_revert(soap);

	or	ecx, -1
	cmp	WORD PTR [esi+87308], 0
	jne	SHORT $LN15@soap_in_Po@2
	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	WORD PTR [esi+87308], ax
	je	SHORT $LN15@soap_in_Po@2
	add	DWORD PTR [esi+12444], ecx
$LN15@soap_in_Po@2:

; 4130 : 		if (!(*a = (_ns2__getSessionIDResponseElement *)soap_instantiate__ns2__getSessionIDResponseElement(soap, -1, soap->type, soap->arrayType, NULL)))

	push	0
	push	esi
	call	?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSessionIDResponseElement
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax

; 4131 : 			return NULL;

	je	SHORT $LN19@soap_in_Po@2

; 4132 : 		(*a)->soap_default(soap);

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	push	esi
	call	eax

; 4133 : 		if (!(*a)->soap_in(soap, tag, NULL))

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	push	0
	push	ebx
	push	esi
	call	eax
	test	eax, eax
	jne	SHORT $LN1@soap_in_Po@2
$LN19@soap_in_Po@2:
	pop	edi
	pop	esi

; 4134 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 4143 : }

	ret	0
$LN5@soap_in_Po@2:

; 4135 : 	}
; 4136 : 	else
; 4137 : 	{	_ns2__getSessionIDResponseElement ** p = (_ns2__getSessionIDResponseElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getSessionIDResponseElement, sizeof(_ns2__getSessionIDResponseElement), 0);

	push	12					; 0000000cH
	push	20					; 00000014H
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	mov	ecx, esi
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH

; 4138 : 		a = p;
; 4139 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in_Po@2
	push	ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 4140 : 			return NULL;

	jne	SHORT $LN19@soap_in_Po@2
$LN1@soap_in_Po@2:

; 4141 : 	}
; 4142 : 	return a;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 4143 : }

	ret	0
?soap_in_PointerTo_ns2__getSessionIDResponseElement@@YAPAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PBDPAPAV1@1@Z ENDP ; soap_in_PointerTo_ns2__getSessionIDResponseElement
_TEXT	ENDS
PUBLIC	?soap_in_PointerTo_ns2__getSettingsFileElement@@YAPAPAV_ns2__getSettingsFileElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
?soap_in_PointerTo_ns2__getSettingsFileElement@@YAPAPAV_ns2__getSettingsFileElement@@PAUsoap@@PBDPAPAV1@1@Z PROC ; soap_in_PointerTo_ns2__getSettingsFileElement
; _soap$ = ecx
; _a$ = eax

; 4066 : {

	push	ebx
	mov	ebx, DWORD PTR _tag$[esp]
	push	esi
	push	edi
	mov	edi, eax
	mov	esi, ecx

; 4067 : 	if (soap_element_begin_in(soap, tag, 1, NULL))
; 4068 : 		return NULL;
; 4069 : 	if (!a)

	test	edi, edi
	jne	SHORT $LN6@soap_in_Po@3

; 4070 : 		if (!(a = (_ns2__getSettingsFileElement **)soap_malloc(soap, sizeof(_ns2__getSettingsFileElement *))))

	lea	eax, DWORD PTR [edi+4]
	mov	edi, esi
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi

; 4071 : 			return NULL;

	je	SHORT $LN19@soap_in_Po@3
$LN6@soap_in_Po@3:

; 4072 : 	*a = NULL;

	mov	DWORD PTR [edi], 0

; 4073 : 	if (!soap->null && *soap->href != '#')

	cmp	WORD PTR [esi+87300], 0
	jne	SHORT $LN5@soap_in_Po@3
	cmp	BYTE PTR [esi+82100], 35		; 00000023H
	je	SHORT $LN5@soap_in_Po@3

; 4074 : 	{	soap_revert(soap);

	or	ecx, -1
	cmp	WORD PTR [esi+87308], 0
	jne	SHORT $LN15@soap_in_Po@3
	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	WORD PTR [esi+87308], ax
	je	SHORT $LN15@soap_in_Po@3
	add	DWORD PTR [esi+12444], ecx
$LN15@soap_in_Po@3:

; 4075 : 		if (!(*a = (_ns2__getSettingsFileElement *)soap_instantiate__ns2__getSettingsFileElement(soap, -1, soap->type, soap->arrayType, NULL)))

	push	0
	push	esi
	call	?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSettingsFileElement
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax

; 4076 : 			return NULL;

	je	SHORT $LN19@soap_in_Po@3

; 4077 : 		(*a)->soap_default(soap);

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	push	esi
	call	eax

; 4078 : 		if (!(*a)->soap_in(soap, tag, NULL))

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	push	0
	push	ebx
	push	esi
	call	eax
	test	eax, eax
	jne	SHORT $LN1@soap_in_Po@3
$LN19@soap_in_Po@3:
	pop	edi
	pop	esi

; 4079 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 4088 : }

	ret	0
$LN5@soap_in_Po@3:

; 4080 : 	}
; 4081 : 	else
; 4082 : 	{	_ns2__getSettingsFileElement ** p = (_ns2__getSettingsFileElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getSettingsFileElement, sizeof(_ns2__getSettingsFileElement), 0);

	push	12					; 0000000cH
	push	21					; 00000015H
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	mov	ecx, esi
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH

; 4083 : 		a = p;
; 4084 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in_Po@3
	push	ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 4085 : 			return NULL;

	jne	SHORT $LN19@soap_in_Po@3
$LN1@soap_in_Po@3:

; 4086 : 	}
; 4087 : 	return a;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 4088 : }

	ret	0
?soap_in_PointerTo_ns2__getSettingsFileElement@@YAPAPAV_ns2__getSettingsFileElement@@PAUsoap@@PBDPAPAV1@1@Z ENDP ; soap_in_PointerTo_ns2__getSettingsFileElement
_TEXT	ENDS
PUBLIC	?soap_in_PointerTo_ns2__getSettingsFileResponseElement@@YAPAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
?soap_in_PointerTo_ns2__getSettingsFileResponseElement@@YAPAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PBDPAPAV1@1@Z PROC ; soap_in_PointerTo_ns2__getSettingsFileResponseElement
; _soap$ = ecx
; _a$ = eax

; 4011 : {

	push	ebx
	mov	ebx, DWORD PTR _tag$[esp]
	push	esi
	push	edi
	mov	edi, eax
	mov	esi, ecx

; 4012 : 	if (soap_element_begin_in(soap, tag, 1, NULL))
; 4013 : 		return NULL;
; 4014 : 	if (!a)

	test	edi, edi
	jne	SHORT $LN6@soap_in_Po@4

; 4015 : 		if (!(a = (_ns2__getSettingsFileResponseElement **)soap_malloc(soap, sizeof(_ns2__getSettingsFileResponseElement *))))

	lea	eax, DWORD PTR [edi+4]
	mov	edi, esi
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi

; 4016 : 			return NULL;

	je	SHORT $LN19@soap_in_Po@4
$LN6@soap_in_Po@4:

; 4017 : 	*a = NULL;

	mov	DWORD PTR [edi], 0

; 4018 : 	if (!soap->null && *soap->href != '#')

	cmp	WORD PTR [esi+87300], 0
	jne	SHORT $LN5@soap_in_Po@4
	cmp	BYTE PTR [esi+82100], 35		; 00000023H
	je	SHORT $LN5@soap_in_Po@4

; 4019 : 	{	soap_revert(soap);

	or	ecx, -1
	cmp	WORD PTR [esi+87308], 0
	jne	SHORT $LN15@soap_in_Po@4
	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	WORD PTR [esi+87308], ax
	je	SHORT $LN15@soap_in_Po@4
	add	DWORD PTR [esi+12444], ecx
$LN15@soap_in_Po@4:

; 4020 : 		if (!(*a = (_ns2__getSettingsFileResponseElement *)soap_instantiate__ns2__getSettingsFileResponseElement(soap, -1, soap->type, soap->arrayType, NULL)))

	push	0
	push	esi
	call	?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSettingsFileResponseElement
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax

; 4021 : 			return NULL;

	je	SHORT $LN19@soap_in_Po@4

; 4022 : 		(*a)->soap_default(soap);

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	push	esi
	call	eax

; 4023 : 		if (!(*a)->soap_in(soap, tag, NULL))

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	push	0
	push	ebx
	push	esi
	call	eax
	test	eax, eax
	jne	SHORT $LN1@soap_in_Po@4
$LN19@soap_in_Po@4:
	pop	edi
	pop	esi

; 4024 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 4033 : }

	ret	0
$LN5@soap_in_Po@4:

; 4025 : 	}
; 4026 : 	else
; 4027 : 	{	_ns2__getSettingsFileResponseElement ** p = (_ns2__getSettingsFileResponseElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getSettingsFileResponseElement, sizeof(_ns2__getSettingsFileResponseElement), 0);

	push	12					; 0000000cH
	push	22					; 00000016H
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	mov	ecx, esi
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH

; 4028 : 		a = p;
; 4029 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in_Po@4
	push	ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 4030 : 			return NULL;

	jne	SHORT $LN19@soap_in_Po@4
$LN1@soap_in_Po@4:

; 4031 : 	}
; 4032 : 	return a;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 4033 : }

	ret	0
?soap_in_PointerTo_ns2__getSettingsFileResponseElement@@YAPAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PBDPAPAV1@1@Z ENDP ; soap_in_PointerTo_ns2__getSettingsFileResponseElement
_TEXT	ENDS
PUBLIC	?soap_in_PointerTo_ns2__submitEpochResultResponseElement@@YAPAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
?soap_in_PointerTo_ns2__submitEpochResultResponseElement@@YAPAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PBDPAPAV1@1@Z PROC ; soap_in_PointerTo_ns2__submitEpochResultResponseElement
; _soap$ = ecx
; _a$ = eax

; 3901 : {

	push	ebx
	mov	ebx, DWORD PTR _tag$[esp]
	push	esi
	push	edi
	mov	edi, eax
	mov	esi, ecx

; 3902 : 	if (soap_element_begin_in(soap, tag, 1, NULL))
; 3903 : 		return NULL;
; 3904 : 	if (!a)

	test	edi, edi
	jne	SHORT $LN6@soap_in_Po@5

; 3905 : 		if (!(a = (_ns2__submitEpochResultResponseElement **)soap_malloc(soap, sizeof(_ns2__submitEpochResultResponseElement *))))

	lea	eax, DWORD PTR [edi+4]
	mov	edi, esi
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi

; 3906 : 			return NULL;

	je	SHORT $LN19@soap_in_Po@5
$LN6@soap_in_Po@5:

; 3907 : 	*a = NULL;

	mov	DWORD PTR [edi], 0

; 3908 : 	if (!soap->null && *soap->href != '#')

	cmp	WORD PTR [esi+87300], 0
	jne	SHORT $LN5@soap_in_Po@5
	cmp	BYTE PTR [esi+82100], 35		; 00000023H
	je	SHORT $LN5@soap_in_Po@5

; 3909 : 	{	soap_revert(soap);

	or	ecx, -1
	cmp	WORD PTR [esi+87308], 0
	jne	SHORT $LN15@soap_in_Po@5
	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	WORD PTR [esi+87308], ax
	je	SHORT $LN15@soap_in_Po@5
	add	DWORD PTR [esi+12444], ecx
$LN15@soap_in_Po@5:

; 3910 : 		if (!(*a = (_ns2__submitEpochResultResponseElement *)soap_instantiate__ns2__submitEpochResultResponseElement(soap, -1, soap->type, soap->arrayType, NULL)))

	push	0
	push	esi
	call	?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__submitEpochResultResponseElement
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax

; 3911 : 			return NULL;

	je	SHORT $LN19@soap_in_Po@5

; 3912 : 		(*a)->soap_default(soap);

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	push	esi
	call	eax

; 3913 : 		if (!(*a)->soap_in(soap, tag, NULL))

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	push	0
	push	ebx
	push	esi
	call	eax
	test	eax, eax
	jne	SHORT $LN1@soap_in_Po@5
$LN19@soap_in_Po@5:
	pop	edi
	pop	esi

; 3914 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 3923 : }

	ret	0
$LN5@soap_in_Po@5:

; 3915 : 	}
; 3916 : 	else
; 3917 : 	{	_ns2__submitEpochResultResponseElement ** p = (_ns2__submitEpochResultResponseElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__submitEpochResultResponseElement, sizeof(_ns2__submitEpochResultResponseElement), 0);

	push	12					; 0000000cH
	push	24					; 00000018H
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	mov	ecx, esi
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH

; 3918 : 		a = p;
; 3919 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in_Po@5
	push	ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 3920 : 			return NULL;

	jne	SHORT $LN19@soap_in_Po@5
$LN1@soap_in_Po@5:

; 3921 : 	}
; 3922 : 	return a;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3923 : }

	ret	0
?soap_in_PointerTo_ns2__submitEpochResultResponseElement@@YAPAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PBDPAPAV1@1@Z ENDP ; soap_in_PointerTo_ns2__submitEpochResultResponseElement
_TEXT	ENDS
PUBLIC	?soap_in___ns1__getSessionID@@YAPAU__ns1__getSessionID@@PAUsoap@@PBDPAU1@1@Z ; soap_in___ns1__getSessionID
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_flag$ = -4					; size = 2
?soap_in___ns1__getSessionID@@YAPAU__ns1__getSessionID@@PAUsoap@@PBDPAU1@1@Z PROC ; soap_in___ns1__getSessionID
; _soap$ = esi
; _a$ = eax

; 3641 : {

	push	ecx
	push	ebx
	push	ebp

; 3642 : 	size_t soap_flag_ns2__getSessionIDElement = 1;
; 3643 : 	short soap_flag;
; 3644 : 	a = (struct __ns1__getSessionID *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSessionID, sizeof(struct __ns1__getSessionID), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	4
	push	31					; 0000001fH
	push	eax
	push	esi
	xor	eax, eax
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ebp, 1
	call	_soap_id_enter
	mov	ebx, eax
	add	esp, 24					; 00000018H

; 3645 : 	if (!a)

	test	ebx, ebx
	jne	SHORT $LN10@soap_in___
	pop	ebp
	pop	ebx

; 3666 : }

	pop	ecx
	ret	0
$LN10@soap_in___:

; 3646 : 		return NULL;
; 3647 : 	soap_default___ns1__getSessionID(soap, a);

	mov	DWORD PTR [ebx], 0

; 3648 : 		for (soap_flag = 0;; soap_flag = 1)

	mov	DWORD PTR _soap_flag$[esp+12], 0
	push	edi
	npad	6
$LL9@soap_in___:

; 3649 : 		{	soap->error = SOAP_TAG_MISMATCH;

	mov	edi, 3
	mov	DWORD PTR [esi+90460], edi

; 3650 : 			if (soap_flag_ns2__getSessionIDElement && soap->error == SOAP_TAG_MISMATCH)

	test	ebp, ebp
	je	$LN46@soap_in___

; 3651 : 				if (soap_in_PointerTo_ns2__getSessionIDElement(soap, "ns2:getSessionIDElement", &a->ns2__getSessionIDElement, ""))

	mov	eax, esi
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN47@soap_in___
	cmp	WORD PTR [esi+87220], ax
	je	SHORT $LN35@soap_in___
	mov	DWORD PTR [esi+90460], edi
	jmp	SHORT $LN46@soap_in___
$LN35@soap_in___:
	lea	ecx, DWORD PTR [esi+80052]
	push	ecx
	push	esi
	mov	edi, OFFSET ??_C@_0BI@CHGDHCPP@ns2?3getSessionIDElement?$AA@
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	jne	SHORT $LN47@soap_in___
	xor	edx, edx
	mov	WORD PTR [esi+87308], dx
	cmp	WORD PTR [esi+12442], dx
	je	SHORT $LN47@soap_in___
	inc	DWORD PTR [esi+12444]
$LN47@soap_in___:
	cmp	DWORD PTR [esi+90460], 0
	jne	SHORT $LN5@soap_in___
	push	OFFSET ??_C@_0BI@CHGDHCPP@ns2?3getSessionIDElement?$AA@
	mov	eax, ebx
	mov	ecx, esi
	call	?soap_in_PointerTo_ns2__getSessionIDElement@@YAPAPAV_ns2__getSessionIDElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__getSessionIDElement
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@soap_in___

; 3652 : 				{	soap_flag_ns2__getSessionIDElement--;

	dec	ebp
	mov	DWORD PTR _soap_flag$[esp+16], 1
	jmp	$LL9@soap_in___
$LN5@soap_in___:

; 3653 : 					continue;
; 3654 : 				}
; 3655 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], 3
	jne	SHORT $LN48@soap_in___
$LN46@soap_in___:

; 3656 : 				if (soap_flag)

	cmp	WORD PTR _soap_flag$[esp+16], 0
	jne	SHORT $LN42@soap_in___
$LN48@soap_in___:

; 3658 : 					break;
; 3659 : 				}
; 3660 : 			if (soap->error == SOAP_NO_TAG)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 6
	je	SHORT $LN43@soap_in___

; 3661 : 				break;
; 3662 : 			if (soap->error)

	test	eax, eax
	jne	SHORT $LN44@soap_in___

; 3648 : 		for (soap_flag = 0;; soap_flag = 1)

	mov	DWORD PTR _soap_flag$[esp+16], 1
	jmp	$LL9@soap_in___
$LN42@soap_in___:

; 3657 : 				{	soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0
$LN43@soap_in___:
	pop	edi
	pop	ebp

; 3664 : 		}
; 3665 : 	return a;

	mov	eax, ebx
	pop	ebx

; 3666 : }

	pop	ecx
	ret	0
$LN44@soap_in___:
	pop	edi
	pop	ebp

; 3663 : 				return NULL;

	xor	eax, eax
	pop	ebx

; 3666 : }

	pop	ecx
	ret	0
?soap_in___ns1__getSessionID@@YAPAU__ns1__getSessionID@@PAUsoap@@PBDPAU1@1@Z ENDP ; soap_in___ns1__getSessionID
_TEXT	ENDS
PUBLIC	?soap_in___ns1__getSettingsFile@@YAPAU__ns1__getSettingsFile@@PAUsoap@@PBDPAU1@1@Z ; soap_in___ns1__getSettingsFile
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_flag$ = -4					; size = 2
?soap_in___ns1__getSettingsFile@@YAPAU__ns1__getSettingsFile@@PAUsoap@@PBDPAU1@1@Z PROC ; soap_in___ns1__getSettingsFile
; _soap$ = esi
; _a$ = eax

; 3541 : {

	push	ecx
	push	ebx
	push	ebp

; 3542 : 	size_t soap_flag_ns2__getSettingsFileElement = 1;
; 3543 : 	short soap_flag;
; 3544 : 	a = (struct __ns1__getSettingsFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSettingsFile, sizeof(struct __ns1__getSettingsFile), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	4
	push	35					; 00000023H
	push	eax
	push	esi
	xor	eax, eax
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ebp, 1
	call	_soap_id_enter
	mov	ebx, eax
	add	esp, 24					; 00000018H

; 3545 : 	if (!a)

	test	ebx, ebx
	jne	SHORT $LN10@soap_in___@2
	pop	ebp
	pop	ebx

; 3566 : }

	pop	ecx
	ret	0
$LN10@soap_in___@2:

; 3546 : 		return NULL;
; 3547 : 	soap_default___ns1__getSettingsFile(soap, a);

	mov	DWORD PTR [ebx], 0

; 3548 : 		for (soap_flag = 0;; soap_flag = 1)

	mov	DWORD PTR _soap_flag$[esp+12], 0
	push	edi
	npad	6
$LL9@soap_in___@2:

; 3549 : 		{	soap->error = SOAP_TAG_MISMATCH;

	mov	edi, 3
	mov	DWORD PTR [esi+90460], edi

; 3550 : 			if (soap_flag_ns2__getSettingsFileElement && soap->error == SOAP_TAG_MISMATCH)

	test	ebp, ebp
	je	$LN46@soap_in___@2

; 3551 : 				if (soap_in_PointerTo_ns2__getSettingsFileElement(soap, "ns2:getSettingsFileElement", &a->ns2__getSettingsFileElement, ""))

	mov	eax, esi
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN47@soap_in___@2
	cmp	WORD PTR [esi+87220], ax
	je	SHORT $LN35@soap_in___@2
	mov	DWORD PTR [esi+90460], edi
	jmp	SHORT $LN46@soap_in___@2
$LN35@soap_in___@2:
	lea	ecx, DWORD PTR [esi+80052]
	push	ecx
	push	esi
	mov	edi, OFFSET ??_C@_0BL@EBHOCBLE@ns2?3getSettingsFileElement?$AA@
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	jne	SHORT $LN47@soap_in___@2
	xor	edx, edx
	mov	WORD PTR [esi+87308], dx
	cmp	WORD PTR [esi+12442], dx
	je	SHORT $LN47@soap_in___@2
	inc	DWORD PTR [esi+12444]
$LN47@soap_in___@2:
	cmp	DWORD PTR [esi+90460], 0
	jne	SHORT $LN5@soap_in___@2
	push	OFFSET ??_C@_0BL@EBHOCBLE@ns2?3getSettingsFileElement?$AA@
	mov	eax, ebx
	mov	ecx, esi
	call	?soap_in_PointerTo_ns2__getSettingsFileElement@@YAPAPAV_ns2__getSettingsFileElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__getSettingsFileElement
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@soap_in___@2

; 3552 : 				{	soap_flag_ns2__getSettingsFileElement--;

	dec	ebp
	mov	DWORD PTR _soap_flag$[esp+16], 1
	jmp	$LL9@soap_in___@2
$LN5@soap_in___@2:

; 3553 : 					continue;
; 3554 : 				}
; 3555 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], 3
	jne	SHORT $LN48@soap_in___@2
$LN46@soap_in___@2:

; 3556 : 				if (soap_flag)

	cmp	WORD PTR _soap_flag$[esp+16], 0
	jne	SHORT $LN42@soap_in___@2
$LN48@soap_in___@2:

; 3558 : 					break;
; 3559 : 				}
; 3560 : 			if (soap->error == SOAP_NO_TAG)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 6
	je	SHORT $LN43@soap_in___@2

; 3561 : 				break;
; 3562 : 			if (soap->error)

	test	eax, eax
	jne	SHORT $LN44@soap_in___@2

; 3548 : 		for (soap_flag = 0;; soap_flag = 1)

	mov	DWORD PTR _soap_flag$[esp+16], 1
	jmp	$LL9@soap_in___@2
$LN42@soap_in___@2:

; 3557 : 				{	soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0
$LN43@soap_in___@2:
	pop	edi
	pop	ebp

; 3564 : 		}
; 3565 : 	return a;

	mov	eax, ebx
	pop	ebx

; 3566 : }

	pop	ecx
	ret	0
$LN44@soap_in___@2:
	pop	edi
	pop	ebp

; 3563 : 				return NULL;

	xor	eax, eax
	pop	ebx

; 3566 : }

	pop	ecx
	ret	0
?soap_in___ns1__getSettingsFile@@YAPAU__ns1__getSettingsFile@@PAUsoap@@PBDPAU1@1@Z ENDP ; soap_in___ns1__getSettingsFile
_TEXT	ENDS
PUBLIC	?soap_out_PointerToSOAP_ENV__Code@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Code@@1@Z ; soap_out_PointerToSOAP_ENV__Code
PUBLIC	?soap_out_SOAP_ENV__Code@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Code@@1@Z ; soap_out_SOAP_ENV__Code
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_tmp_SOAP_ENV__Value$ = -4				; size = 4
_id$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_SOAP_ENV__Code@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Code@@1@Z PROC ; soap_out_SOAP_ENV__Code
; _soap$ = ecx
; _tag$ = eax

; 3201 : {

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _a$[esp+4]
	push	esi
	push	edi
	mov	esi, eax

; 3202 : 	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);

	mov	eax, DWORD PTR [ebx]
	mov	edi, ecx
	push	eax
	push	edi
	call	_soap_QName2s

; 3203 : 	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))

	mov	ecx, DWORD PTR _id$[esp+20]
	push	ecx
	mov	DWORD PTR _soap_tmp_SOAP_ENV__Value$[esp+28], eax
	push	edi
	mov	eax, 41					; 00000029H
	mov	ecx, ebx
	call	_soap_embedded_id
	add	esp, 16					; 00000010H
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN3@soap_out_S@2
	mov	edx, DWORD PTR _type$[esp+12]
	push	edx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@soap_out_S@2
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN8@soap_out_S@2
$LN6@soap_out_S@2:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN8@soap_out_S@2:
	test	eax, eax
	je	SHORT $LN3@soap_out_S@2
$LN41@soap_out_S@2:

; 3204 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 3210 : }

	pop	ecx
	ret	0
$LN3@soap_out_S@2:

; 3205 : 	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))

	push	5
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	eax, DWORD PTR _soap_tmp_SOAP_ENV__Value$[esp+24]
	push	eax
	push	OFFSET ??_C@_0P@FNBDNHP@SOAP?9ENV?3Value?$AA@
	or	eax, -1
	mov	ecx, edi
	call	_soap_outstring
	add	esp, 16					; 00000010H
	test	eax, eax

; 3206 : 		return soap->error;

	jne	SHORT $LN41@soap_out_S@2

; 3207 : 	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	add	ebx, 4
	push	ebx
	push	-1
	push	OFFSET ??_C@_0BB@MGPNIFGI@SOAP?9ENV?3Subcode?$AA@
	push	edi
	call	?soap_out_PointerToSOAP_ENV__Code@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Code@@1@Z ; soap_out_PointerToSOAP_ENV__Code
	add	esp, 20					; 00000014H
	test	eax, eax

; 3208 : 		return soap->error;

	jne	SHORT $LN41@soap_out_S@2

; 3209 : 	return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebx

; 3210 : }

	pop	ecx
	ret	0
?soap_out_SOAP_ENV__Code@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Code@@1@Z ENDP ; soap_out_SOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_out_SOAP_ENV__Reason@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Reason@@1@Z ; soap_out_SOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_SOAP_ENV__Reason@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Reason@@1@Z PROC ; soap_out_SOAP_ENV__Reason
; _tag$ = ecx
; _id$ = eax

; 2959 : {

	push	ebx
	mov	ebx, DWORD PTR _a$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 2960 : 	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))

	push	eax
	mov	esi, ecx
	push	edi
	mov	eax, 46					; 0000002eH
	mov	ecx, ebx
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN2@soap_out_S@3
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_out_S@3
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_out_S@3
$LN5@soap_out_S@3:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_out_S@3:
	test	eax, eax
	je	SHORT $LN2@soap_out_S@3
$LN11@soap_out_S@3:

; 2961 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 2968 : }

	ret	0
$LN2@soap_out_S@3:

; 2962 : 	/*
; 2963 : 	if (soap->lang)
; 2964 : 		soap_set_attr(soap, "xml:lang", soap->lang);*/
; 2965 : 	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))

	push	4
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	ebx
	push	OFFSET ??_C@_0O@BLCEAHMK@SOAP?9ENV?3Text?$AA@
	or	eax, -1
	mov	ecx, edi
	call	_soap_outstring
	add	esp, 16					; 00000010H
	test	eax, eax

; 2966 : 		return soap->error;

	jne	SHORT $LN11@soap_out_S@3

; 2967 : 	return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebx

; 2968 : }

	ret	0
?soap_out_SOAP_ENV__Reason@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Reason@@1@Z ENDP ; soap_out_SOAP_ENV__Reason
_TEXT	ENDS
PUBLIC	?soap_out_xsd__float@@YAHPAUsoap@@PBDHPBVxsd__float@@1@Z ; soap_out_xsd__float
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_id$ = 12						; size = 4
?soap_out_xsd__float@@YAHPAUsoap@@PBDHPBVxsd__float@@1@Z PROC ; soap_out_xsd__float
; _soap$ = ecx
; _a$ = eax

; 2334 : 	return soap_out_float(soap, tag, id, &(a->xsd__float::__item), "xsd:float");

	add	eax, 12					; 0000000cH
	push	OFFSET ??_C@_09ILBLHFBD@xsd?3float?$AA@
	push	eax
	mov	eax, DWORD PTR _id$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+8]
	call	_soap_outfloat
	add	esp, 12					; 0000000cH

; 2335 : }

	ret	0
?soap_out_xsd__float@@YAHPAUsoap@@PBDHPBVxsd__float@@1@Z ENDP ; soap_out_xsd__float
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
?soap_out@xsd__float@@UBEHPAUsoap@@PBDH1@Z PROC		; xsd__float::soap_out
; _this$ = ecx

; 2329 : 	return soap_out_xsd__float(soap, tag, id, this, type);

	mov	eax, DWORD PTR _soap$[esp-4]
	add	ecx, 12					; 0000000cH
	push	OFFSET ??_C@_09ILBLHFBD@xsd?3float?$AA@
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	eax
	mov	eax, DWORD PTR _id$[esp+8]
	call	_soap_outfloat
	add	esp, 12					; 0000000cH

; 2330 : }

	ret	16					; 00000010H
?soap_out@xsd__float@@UBEHPAUsoap@@PBDH1@Z ENDP		; xsd__float::soap_out
_TEXT	ENDS
PUBLIC	?soap_out_xsd__int@@YAHPAUsoap@@PBDHPBVxsd__int@@1@Z ; soap_out_xsd__int
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_id$ = 12						; size = 4
?soap_out_xsd__int@@YAHPAUsoap@@PBDHPBVxsd__int@@1@Z PROC ; soap_out_xsd__int
; _soap$ = ecx
; _a$ = eax

; 2225 : 	return soap_out_int(soap, tag, id, &(a->xsd__int::__item), "xsd:int");

	add	eax, 12					; 0000000cH
	push	OFFSET ??_C@_07PCIGPDP@xsd?3int?$AA@
	push	eax
	mov	eax, DWORD PTR _id$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+8]
	call	_soap_outint
	add	esp, 12					; 0000000cH

; 2226 : }

	ret	0
?soap_out_xsd__int@@YAHPAUsoap@@PBDHPBVxsd__int@@1@Z ENDP ; soap_out_xsd__int
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
?soap_out@xsd__int@@UBEHPAUsoap@@PBDH1@Z PROC		; xsd__int::soap_out
; _this$ = ecx

; 2220 : 	return soap_out_xsd__int(soap, tag, id, this, type);

	mov	eax, DWORD PTR _soap$[esp-4]
	add	ecx, 12					; 0000000cH
	push	OFFSET ??_C@_07PCIGPDP@xsd?3int?$AA@
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	eax
	mov	eax, DWORD PTR _id$[esp+8]
	call	_soap_outint
	add	esp, 12					; 0000000cH

; 2221 : }

	ret	16					; 00000010H
?soap_out@xsd__int@@UBEHPAUsoap@@PBDH1@Z ENDP		; xsd__int::soap_out
_TEXT	ENDS
PUBLIC	?soap_out_xsd__long@@YAHPAUsoap@@PBDHPBVxsd__long@@1@Z ; soap_out_xsd__long
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
?soap_out_xsd__long@@YAHPAUsoap@@PBDHPBVxsd__long@@1@Z PROC ; soap_out_xsd__long
; _tag$ = eax
; _a$ = ecx

; 2116 : 	return soap_out_LONG64(soap, tag, id, &(a->xsd__long::__item), "xsd:long");

	mov	edx, DWORD PTR _soap$[esp-4]
	push	OFFSET ??_C@_08PNDIDGIB@xsd?3long?$AA@
	push	eax
	mov	eax, DWORD PTR _id$[esp+4]
	add	ecx, 16					; 00000010H
	push	edx
	call	_soap_outLONG64
	add	esp, 12					; 0000000cH

; 2117 : }

	ret	0
?soap_out_xsd__long@@YAHPAUsoap@@PBDHPBVxsd__long@@1@Z ENDP ; soap_out_xsd__long
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
?soap_out@xsd__long@@UBEHPAUsoap@@PBDH1@Z PROC		; xsd__long::soap_out
; _this$ = ecx

; 2111 : 	return soap_out_xsd__long(soap, tag, id, this, type);

	mov	eax, DWORD PTR _tag$[esp-4]
	mov	edx, DWORD PTR _soap$[esp-4]
	push	OFFSET ??_C@_08PNDIDGIB@xsd?3long?$AA@
	push	eax
	mov	eax, DWORD PTR _id$[esp+4]
	add	ecx, 16					; 00000010H
	push	edx
	call	_soap_outLONG64
	add	esp, 12					; 0000000cH

; 2112 : }

	ret	16					; 00000010H
?soap_out@xsd__long@@UBEHPAUsoap@@PBDH1@Z ENDP		; xsd__long::soap_out
_TEXT	ENDS
PUBLIC	?soap_out__ns2__getSessionIDResponseElement@@YAHPAUsoap@@PBDHPBV_ns2__getSessionIDResponseElement@@1@Z ; soap_out__ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out__ns2__getSessionIDResponseElement@@YAHPAUsoap@@PBDHPBV_ns2__getSessionIDResponseElement@@1@Z PROC ; soap_out__ns2__getSessionIDResponseElement
; _tag$ = ecx
; _id$ = eax

; 1624 : {

	push	ebx
	mov	ebx, DWORD PTR _a$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 1625 : 	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getSessionIDResponseElement), type))

	push	eax
	mov	esi, ecx
	push	edi
	mov	eax, 20					; 00000014H
	mov	ecx, ebx
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN2@soap_out__@7
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_out__@7
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_out__@7
$LN5@soap_out__@7:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_out__@7:
	test	eax, eax
	je	SHORT $LN2@soap_out__@7
$LN11@soap_out__@7:

; 1626 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 1632 : }

	ret	0
$LN2@soap_out__@7:

; 1627 : 	soap_element_result(soap, "ns2:result");

	mov	eax, edi
	call	_soap_element_result

; 1628 : 	if (soap_out_int(soap, "ns2:result", -1, &(a->_ns2__getSessionIDResponseElement::result), ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	add	ebx, 4
	push	ebx
	push	edi
	or	eax, -1
	mov	ecx, OFFSET ??_C@_0L@FEKNHBLL@ns2?3result?$AA@
	call	_soap_outint
	add	esp, 12					; 0000000cH
	test	eax, eax

; 1629 : 		return soap->error;

	jne	SHORT $LN11@soap_out__@7

; 1630 : 	/* transient soap skipped */
; 1631 : 	return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebx

; 1632 : }

	ret	0
?soap_out__ns2__getSessionIDResponseElement@@YAHPAUsoap@@PBDHPBV_ns2__getSessionIDResponseElement@@1@Z ENDP ; soap_out__ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
?soap_out@_ns2__getSessionIDResponseElement@@UBEHPAUsoap@@PBDH1@Z PROC ; _ns2__getSessionIDResponseElement::soap_out
; _this$ = ecx

; 1620 : 	return soap_out__ns2__getSessionIDResponseElement(soap, tag, id, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _id$[esp]
	push	ecx
	mov	ecx, DWORD PTR _soap$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+8]
	call	?soap_out__ns2__getSessionIDResponseElement@@YAHPAUsoap@@PBDHPBV_ns2__getSessionIDResponseElement@@1@Z ; soap_out__ns2__getSessionIDResponseElement
	add	esp, 12					; 0000000cH

; 1621 : }

	ret	16					; 00000010H
?soap_out@_ns2__getSessionIDResponseElement@@UBEHPAUsoap@@PBDH1@Z ENDP ; _ns2__getSessionIDResponseElement::soap_out
_TEXT	ENDS
PUBLIC	?soap_out__ns2__getSettingsFileElement@@YAHPAUsoap@@PBDHPBV_ns2__getSettingsFileElement@@1@Z ; soap_out__ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out__ns2__getSettingsFileElement@@YAHPAUsoap@@PBDHPBV_ns2__getSettingsFileElement@@1@Z PROC ; soap_out__ns2__getSettingsFileElement
; _tag$ = ecx
; _id$ = eax

; 1483 : {

	push	ebx
	mov	ebx, DWORD PTR _a$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 1484 : 	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getSettingsFileElement), type))

	push	eax
	mov	esi, ecx
	push	edi
	mov	eax, 21					; 00000015H
	mov	ecx, ebx
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN2@soap_out__@8
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_out__@8
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_out__@8
$LN5@soap_out__@8:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_out__@8:
	test	eax, eax
	je	SHORT $LN2@soap_out__@8
$LN11@soap_out__@8:

; 1485 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 1490 : }

	ret	0
$LN2@soap_out__@8:

; 1486 : 	if (soap_out_int(soap, "ns2:int_1", -1, &(a->_ns2__getSettingsFileElement::int_USCORE1), ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	add	ebx, 4
	push	ebx
	push	edi
	or	eax, -1
	mov	ecx, OFFSET ??_C@_09JNJHDMAM@ns2?3int_1?$AA@
	call	_soap_outint
	add	esp, 12					; 0000000cH
	test	eax, eax

; 1487 : 		return soap->error;

	jne	SHORT $LN11@soap_out__@8

; 1488 : 	/* transient soap skipped */
; 1489 : 	return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebx

; 1490 : }

	ret	0
?soap_out__ns2__getSettingsFileElement@@YAHPAUsoap@@PBDHPBV_ns2__getSettingsFileElement@@1@Z ENDP ; soap_out__ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
?soap_out@_ns2__getSettingsFileElement@@UBEHPAUsoap@@PBDH1@Z PROC ; _ns2__getSettingsFileElement::soap_out
; _this$ = ecx

; 1479 : 	return soap_out__ns2__getSettingsFileElement(soap, tag, id, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _id$[esp]
	push	ecx
	mov	ecx, DWORD PTR _soap$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+8]
	call	?soap_out__ns2__getSettingsFileElement@@YAHPAUsoap@@PBDHPBV_ns2__getSettingsFileElement@@1@Z ; soap_out__ns2__getSettingsFileElement
	add	esp, 12					; 0000000cH

; 1480 : }

	ret	16					; 00000010H
?soap_out@_ns2__getSettingsFileElement@@UBEHPAUsoap@@PBDH1@Z ENDP ; _ns2__getSettingsFileElement::soap_out
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4_ns2__submitEpochResultElement@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4_ns2__submitEpochResultElement@@QAEAAV0@ABV0@@Z PROC	; _ns2__submitEpochResultElement::operator=, COMDAT
; _this$ = esi
; ___that$ = edi
	push	ecx
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax
	mov	ecx, DWORD PTR [edi+16]
	lea	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [edi+20]
	push	eax
	lea	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+20], edx
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
	lea	ecx, DWORD PTR [edi+48]
	push	ecx
	lea	eax, DWORD PTR [esi+48]
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
	lea	edx, DWORD PTR [edi+72]
	push	edx
	lea	eax, DWORD PTR [esi+72]
	call	??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<float,std::allocator<float> >::operator=
	lea	eax, DWORD PTR [edi+96]
	push	eax
	lea	eax, DWORD PTR [esi+96]
	call	??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<float,std::allocator<float> >::operator=
	fld	DWORD PTR [edi+120]
	fstp	DWORD PTR [esi+120]
	mov	eax, esi
	fld	DWORD PTR [edi+124]
	fstp	DWORD PTR [esi+124]
	mov	ecx, DWORD PTR [edi+128]
	mov	DWORD PTR [esi+128], ecx
	pop	ecx
	ret	0
??4_ns2__submitEpochResultElement@@QAEAAV0@ABV0@@Z ENDP	; _ns2__submitEpochResultElement::operator=
_TEXT	ENDS
PUBLIC	?soap_copy__ns2__submitEpochResultElement@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy__ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_st$ = 12						; size = 4
_tt$ = 16						; size = 4
_p$ = 20						; size = 4
_len$ = 24						; size = 4
_q$ = 28						; size = 4
_n$ = 32						; size = 4
?soap_copy__ns2__submitEpochResultElement@@YAXPAUsoap@@HHPAXIPBXI@Z PROC ; soap_copy__ns2__submitEpochResultElement

; 1310 : {

	push	esi

; 1311 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__submitEpochResultElement %p -> %p\n", q, p));
; 1312 : 	*(_ns2__submitEpochResultElement*)p = *(_ns2__submitEpochResultElement*)q;

	mov	esi, DWORD PTR _p$[esp]
	push	edi
	mov	edi, DWORD PTR _q$[esp+4]
	call	??4_ns2__submitEpochResultElement@@QAEAAV0@ABV0@@Z

; 1313 : }

	pop	edi
	pop	esi
	ret	0
?soap_copy__ns2__submitEpochResultElement@@YAXPAUsoap@@HHPAXIPBXI@Z ENDP ; soap_copy__ns2__submitEpochResultElement
_TEXT	ENDS
PUBLIC	?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__submitEpochResultElement
__unwindtable$?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z$1
__ehfuncinfo$?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T577294 = -16						; size = 4
$T577289 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_soap$ = 8						; size = 4
_size$ = 12						; size = 4
?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z PROC ; soap_instantiate__ns2__submitEpochResultElement
; _n$ = ecx

; 1284 : {

	push	-1
	push	__ehhandler$?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ebp, DWORD PTR _soap$[esp+32]

; 1285 : 	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__submitEpochResultElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
; 1286 : 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__submitEpochResultElement, n, soap_fdelete);

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	ebx, ebx
	add	esp, 4
	cmp	esi, ebx
	je	$LN23@soap_insta@23

; 1287 : 	if (!cp)
; 1288 : 		return NULL;
; 1289 : 	if (n < 0)

	cmp	edi, ebx
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 23			; 00000017H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete
	mov	DWORD PTR [ebp+96], esi
	jge	SHORT $LN8@soap_insta@23

; 1290 : 	{	cp->ptr = (void*)new _ns2__submitEpochResultElement;

	push	136					; 00000088H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T577289[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	cmp	eax, ebx
	je	SHORT $LN12@soap_insta@23
	mov	ecx, eax
	call	??0_ns2__submitEpochResultElement@@QAE@XZ ; _ns2__submitEpochResultElement::_ns2__submitEpochResultElement
	jmp	SHORT $LN13@soap_insta@23
$LN12@soap_insta@23:
	xor	eax, eax
$LN13@soap_insta@23:
	mov	DWORD PTR [esi+4], eax

; 1291 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN7@soap_insta@23

; 1292 : 			*size = sizeof(_ns2__submitEpochResultElement);

	mov	DWORD PTR [eax], 136			; 00000088H
$LN7@soap_insta@23:

; 1293 : 		((_ns2__submitEpochResultElement*)cp->ptr)->soap = soap;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+128], ebp

; 1294 : 	}
; 1295 : 	else

	jmp	$LN1@soap_insta@23
$LN8@soap_insta@23:

; 1296 : 	{	cp->ptr = (void*)new _ns2__submitEpochResultElement[n];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 136				; 00000088H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T577294[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], 1
	cmp	eax, ebx
	je	SHORT $LN14@soap_insta@23
	push	OFFSET ??1_ns2__submitEpochResultElement@@UAE@XZ ; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement
	push	OFFSET ??0_ns2__submitEpochResultElement@@QAE@XZ ; _ns2__submitEpochResultElement::_ns2__submitEpochResultElement
	push	edi
	lea	ebx, DWORD PTR [eax+4]
	push	136					; 00000088H
	push	ebx
	mov	DWORD PTR [eax], edi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
$LN14@soap_insta@23:
	mov	DWORD PTR [esi+4], ebx

; 1297 : 		if (!cp->ptr)

	test	ebx, ebx
	jne	SHORT $LN5@soap_insta@23

; 1298 : 		{	soap->error = SOAP_EOM;

	mov	DWORD PTR [ebp+90460], 20		; 00000014H
$LN23@soap_insta@23:

; 1299 : 			return NULL;

	xor	eax, eax

; 1308 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN5@soap_insta@23:

; 1300 : 		}
; 1301 : 		if (size)

	mov	eax, DWORD PTR _size$[esp+32]
	test	eax, eax
	je	SHORT $LN4@soap_insta@23

; 1302 : 			*size = n * sizeof(_ns2__submitEpochResultElement);

	mov	ecx, edi
	imul	ecx, 136				; 00000088H
	mov	DWORD PTR [eax], ecx
$LN4@soap_insta@23:

; 1303 : 		for (int i = 0; i < n; i++)

	test	edi, edi
	jle	SHORT $LN1@soap_insta@23
	xor	eax, eax
	npad	11
$LL3@soap_insta@23:

; 1304 : 			((_ns2__submitEpochResultElement*)cp->ptr)[i].soap = soap;

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+edx+128], ebp
	add	eax, 136				; 00000088H
	sub	edi, 1
	jne	SHORT $LL3@soap_insta@23
$LN1@soap_insta@23:

; 1305 : 	}
; 1306 : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
; 1307 : 	return (_ns2__submitEpochResultElement*)cp->ptr;

	mov	eax, DWORD PTR [esi+4]

; 1308 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
__unwindfunclet$?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z$0:
	mov	eax, DWORD PTR $T577289[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z$1:
	mov	eax, DWORD PTR $T577294[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z
	jmp	___CxxFrameHandler3
?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z ENDP ; soap_instantiate__ns2__submitEpochResultElement
PUBLIC	?soap_new__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@H@Z ; soap_new__ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_new__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@H@Z PROC ; soap_new__ns2__submitEpochResultElement
; _soap$ = eax
; _n$ = ecx

; 1276 : {	return soap_instantiate__ns2__submitEpochResultElement(soap, n, NULL, NULL, NULL);

	push	0
	push	eax
	call	?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__submitEpochResultElement
	add	esp, 8

; 1277 : }

	ret	0
?soap_new__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@H@Z ENDP ; soap_new__ns2__submitEpochResultElement
_TEXT	ENDS
PUBLIC	?soap_out__ns2__submitEpochResultElement@@YAHPAUsoap@@PBDHPBV_ns2__submitEpochResultElement@@1@Z ; soap_out__ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out__ns2__submitEpochResultElement@@YAHPAUsoap@@PBDHPBV_ns2__submitEpochResultElement@@1@Z PROC ; soap_out__ns2__submitEpochResultElement
; _tag$ = ecx
; _id$ = eax

; 1157 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _a$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[ebp]

; 1158 : 	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__submitEpochResultElement), type))

	push	eax
	mov	esi, ecx
	push	edi
	mov	eax, 23					; 00000017H
	mov	ecx, ebx
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN9@soap_out__@9
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@soap_out__@9
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN14@soap_out__@9
$LN12@soap_out__@9:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN14@soap_out__@9:
	test	eax, eax
	je	SHORT $LN9@soap_out__@9
$LN22@soap_out__@9:

; 1159 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]

; 1178 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@soap_out__@9:

; 1160 : 	if (soap_out_PointerTostd__string(soap, "ns2:String_1", -1, &(a->_ns2__submitEpochResultElement::sessionID), ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	edx, DWORD PTR [ebx+8]
	push	edx
	push	OFFSET ??_C@_0N@EOBKMJFL@ns2?3String_1?$AA@
	or	eax, -1
	mov	ecx, edi
	call	?soap_out_PointerTostd__string@@YAHPAUsoap@@PBDHPBQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; soap_out_PointerTostd__string
	add	esp, 12					; 0000000cH
	test	eax, eax

; 1161 : 		return soap->error;

	jne	SHORT $LN22@soap_out__@9

; 1162 : 	if (soap_out_LONG64(soap, "ns2:int_2", -1, &(a->_ns2__submitEpochResultElement::epoch), ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_09LGLKGPMP@ns2?3int_2?$AA@
	lea	ecx, DWORD PTR [ebx+16]
	push	edi
	or	eax, -1
	call	_soap_outLONG64
	add	esp, 12					; 0000000cH
	test	eax, eax

; 1163 : 		return soap->error;

	jne	SHORT $LN22@soap_out__@9

; 1164 : 	if (soap_out_std__vectorTemplateOfint(soap, "ns2:arrayOfint_3", -1, &(a->_ns2__submitEpochResultElement::channel), ""))

	lea	eax, DWORD PTR [ebx+24]
	push	eax
	push	OFFSET ??_C@_0BB@FGDEMAEK@ns2?3arrayOfint_3?$AA@
	push	edi
	call	?soap_out_std__vectorTemplateOfint@@YAHPAUsoap@@PBDHPBV?$vector@HV?$allocator@H@std@@@std@@1@Z ; soap_out_std__vectorTemplateOfint
	add	esp, 12					; 0000000cH
	test	eax, eax

; 1165 : 		return soap->error;

	jne	SHORT $LN22@soap_out__@9

; 1166 : 	if (soap_out_std__vectorTemplateOfint(soap, "ns2:arrayOfint_4", -1, &(a->_ns2__submitEpochResultElement::rank), ""))

	lea	ecx, DWORD PTR [ebx+48]
	push	ecx
	push	OFFSET ??_C@_0BB@BJHFFGIN@ns2?3arrayOfint_4?$AA@
	push	edi
	call	?soap_out_std__vectorTemplateOfint@@YAHPAUsoap@@PBDHPBV?$vector@HV?$allocator@H@std@@@std@@1@Z ; soap_out_std__vectorTemplateOfint
	add	esp, 12					; 0000000cH
	test	eax, eax

; 1167 : 		return soap->error;

	jne	SHORT $LN22@soap_out__@9

; 1168 : 	if (soap_out_std__vectorTemplateOffloat(soap, "ns2:arrayOffloat_5", -1, &(a->_ns2__submitEpochResultElement::PsysACTSTBY), ""))

	lea	edx, DWORD PTR [ebx+72]
	push	edx
	push	OFFSET ??_C@_0BD@GLFPAPIO@ns2?3arrayOffloat_5?$AA@
	push	edi
	call	?soap_out_std__vectorTemplateOffloat@@YAHPAUsoap@@PBDHPBV?$vector@MV?$allocator@M@std@@@std@@1@Z ; soap_out_std__vectorTemplateOffloat
	add	esp, 12					; 0000000cH
	test	eax, eax

; 1169 : 		return soap->error;

	jne	$LN22@soap_out__@9

; 1170 : 	if (soap_out_std__vectorTemplateOffloat(soap, "ns2:arrayOffloat_6", -1, &(a->_ns2__submitEpochResultElement::PsysACT), ""))

	lea	eax, DWORD PTR [ebx+96]
	push	eax
	push	OFFSET ??_C@_0BD@EAHCFMEN@ns2?3arrayOffloat_6?$AA@
	push	edi
	call	?soap_out_std__vectorTemplateOffloat@@YAHPAUsoap@@PBDHPBV?$vector@MV?$allocator@M@std@@@std@@1@Z ; soap_out_std__vectorTemplateOffloat
	add	esp, 12					; 0000000cH
	test	eax, eax

; 1171 : 		return soap->error;

	jne	$LN22@soap_out__@9

; 1172 : 	if (soap_out_float(soap, "ns2:float_7", -1, &(a->_ns2__submitEpochResultElement::PsysRD), ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR [ebx+120]
	push	ecx
	push	edi
	or	eax, -1
	mov	ecx, OFFSET ??_C@_0M@OBEIDIJA@ns2?3float_7?$AA@
	call	_soap_outfloat
	add	esp, 12					; 0000000cH
	test	eax, eax

; 1173 : 		return soap->error;

	jne	$LN22@soap_out__@9

; 1174 : 	if (soap_out_float(soap, "ns2:float_8", -1, &(a->_ns2__submitEpochResultElement::PsysWR), ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	add	ebx, 124				; 0000007cH
	push	ebx
	push	edi
	or	eax, -1
	mov	ecx, OFFSET ??_C@_0M@GGNACEFP@ns2?3float_8?$AA@
	call	_soap_outfloat
	add	esp, 12					; 0000000cH
	test	eax, eax

; 1175 : 		return soap->error;

	jne	$LN22@soap_out__@9

; 1176 : 	/* transient soap skipped */
; 1177 : 	return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out

; 1178 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?soap_out__ns2__submitEpochResultElement@@YAHPAUsoap@@PBDHPBV_ns2__submitEpochResultElement@@1@Z ENDP ; soap_out__ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_type$ = 20						; size = 4
?soap_out@_ns2__submitEpochResultElement@@UBEHPAUsoap@@PBDH1@Z PROC ; _ns2__submitEpochResultElement::soap_out
; _this$ = ecx

; 1153 : 	return soap_out__ns2__submitEpochResultElement(soap, tag, id, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _id$[esp]
	push	ecx
	mov	ecx, DWORD PTR _soap$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+8]
	call	?soap_out__ns2__submitEpochResultElement@@YAHPAUsoap@@PBDHPBV_ns2__submitEpochResultElement@@1@Z ; soap_out__ns2__submitEpochResultElement
	add	esp, 12					; 0000000cH

; 1154 : }

	ret	16					; 00000010H
?soap_out@_ns2__submitEpochResultElement@@UBEHPAUsoap@@PBDH1@Z ENDP ; _ns2__submitEpochResultElement::soap_out
_TEXT	ENDS
PUBLIC	?soap_in_bool@@YAPA_NPAUsoap@@PBDPA_N1@Z	; soap_in_bool
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in_bool@@YAPA_NPAUsoap@@PBDPA_N1@Z PROC		; soap_in_bool
; _soap$ = eax

; 953  : {

	push	ebp
	mov	ebp, DWORD PTR _tag$[esp]
	push	esi
	mov	esi, eax

; 954  : 	if (soap_element_begin_in(soap, tag, 0, NULL))

	push	0
	push	0
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@soap_in_bo
	pop	esi

; 955  : 		return NULL;

	xor	eax, eax
	pop	ebp

; 973  : }

	ret	0
$LN8@soap_in_bo:

; 956  : 	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))

	cmp	BYTE PTR [esi+83124], 0
	push	ebx
	lea	ebx, DWORD PTR [esi+83124]
	push	edi
	je	SHORT $LN11@soap_in_bo
	mov	edi, DWORD PTR _type$[esp+12]
	push	ebx
	push	esi
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@soap_in_bo
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_08FGCKPNBL@?3boolean?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@soap_in_bo
	pop	edi
	pop	ebx

; 957  : 	{	soap->error = SOAP_TYPE;

	mov	DWORD PTR [esi+90460], 4
	pop	esi

; 958  : 		return NULL;

	xor	eax, eax
	pop	ebp

; 973  : }

	ret	0
$LN11@soap_in_bo:

; 959  : 	}
; 960  : 	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);

	mov	eax, DWORD PTR _a$[esp+12]
	push	0
	push	0
	push	1
	push	11					; 0000000bH
	push	eax
	lea	ecx, DWORD PTR [esi+81076]
	push	esi
	xor	eax, eax
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H

; 961  : 	if (!a)

	test	edi, edi

; 962  : 		return NULL;

	je	SHORT $LN3@soap_in_bo

; 963  : 	if (soap->body && !*soap->href)

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN5@soap_in_bo
	cmp	BYTE PTR [esi+82100], 0
	jne	SHORT $LN5@soap_in_bo

; 964  : 	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))

	push	edi
	push	esi
	call	_soap_value
	add	esp, 4
	mov	ecx, esi
	call	?soap_s2bool@@YAHPAUsoap@@PBDPA_N@Z	; soap_s2bool
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@soap_in_bo
$LN14@soap_in_bo:
	push	ebp
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_in_bo
$LN3@soap_in_bo:
	pop	edi
	pop	ebx
	pop	esi

; 965  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 973  : }

	ret	0
$LN5@soap_in_bo:

; 966  : 	}
; 967  : 	else
; 968  : 	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);

	push	0
	push	1
	push	0
	push	11					; 0000000bH
	push	0
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH

; 969  : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax

; 970  : 			return NULL;

	jne	SHORT $LN14@soap_in_bo
$LN1@soap_in_bo:

; 971  : 	}
; 972  : 	return a;

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 973  : }

	ret	0
?soap_in_bool@@YAPA_NPAUsoap@@PBDPA_N1@Z ENDP		; soap_in_bool
_TEXT	ENDS
PUBLIC	?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z	; soap_instantiate
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_t$ = 12						; size = 4
_type$ = 16						; size = 4
_arrayType$ = 20					; size = 4
_n$ = 24						; size = 4
?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z PROC	; soap_instantiate

; 515  : 	switch (t)

	mov	eax, DWORD PTR _t$[esp-4]
	add	eax, -8					; fffffff8H
	push	edi
	cmp	eax, 39					; 00000027H
	ja	$LN24@soap_insta@24
	movzx	eax, BYTE PTR $LN28@soap_insta@24[eax]
	jmp	DWORD PTR $LN29@soap_insta@24[eax*4]
$LN23@soap_insta@24:

; 516  : 	{
; 517  : 	case SOAP_TYPE_xsd__anyType:
; 518  : 		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);

	mov	ecx, DWORD PTR _n$[esp]
	mov	edx, DWORD PTR _type$[esp]
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	push	edx
	push	eax
	or	ecx, -1
	call	?soap_instantiate_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__anyType
	add	esp, 12					; 0000000cH
	pop	edi

; 575  : }

	ret	0
$LN22@soap_insta@24:

; 519  : 	case SOAP_TYPE_xsd__boolean:
; 520  : 		return (void*)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);

	mov	ecx, DWORD PTR _n$[esp]
	mov	edx, DWORD PTR _soap$[esp]
	push	ecx
	push	edx
	or	ecx, -1
	call	?soap_instantiate_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__boolean
	add	esp, 8
	pop	edi

; 575  : }

	ret	0
$LN21@soap_insta@24:

; 521  : 	case SOAP_TYPE_xsd__float:
; 522  : 		return (void*)soap_instantiate_xsd__float(soap, -1, type, arrayType, n);

	mov	eax, DWORD PTR _n$[esp]
	mov	ecx, DWORD PTR _soap$[esp]
	push	eax
	push	ecx
	or	ecx, -1
	call	?soap_instantiate_xsd__float@@YAPAVxsd__float@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__float
	add	esp, 8
	pop	edi

; 575  : }

	ret	0
$LN20@soap_insta@24:

; 523  : 	case SOAP_TYPE_xsd__int:
; 524  : 		return (void*)soap_instantiate_xsd__int(soap, -1, type, arrayType, n);

	mov	edx, DWORD PTR _n$[esp]
	mov	eax, DWORD PTR _soap$[esp]
	push	edx
	push	eax
	or	ecx, -1
	call	?soap_instantiate_xsd__int@@YAPAVxsd__int@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__int
	add	esp, 8
	pop	edi

; 575  : }

	ret	0
$LN19@soap_insta@24:

; 525  : 	case SOAP_TYPE_xsd__long:
; 526  : 		return (void*)soap_instantiate_xsd__long(soap, -1, type, arrayType, n);

	mov	ecx, DWORD PTR _n$[esp]
	mov	edx, DWORD PTR _soap$[esp]
	push	ecx
	push	edx
	or	ecx, -1
	call	?soap_instantiate_xsd__long@@YAPAVxsd__long@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__long
	add	esp, 8
	pop	edi

; 575  : }

	ret	0
$LN18@soap_insta@24:

; 527  : 	case SOAP_TYPE_std__string:
; 528  : 		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);

	mov	eax, DWORD PTR _n$[esp]
	mov	edi, DWORD PTR _soap$[esp]
	push	eax
	call	?soap_instantiate_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_std__string
	add	esp, 4
	pop	edi

; 575  : }

	ret	0
$LN17@soap_insta@24:

; 529  : 	case SOAP_TYPE_xsd__string:
; 530  : 		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);

	mov	ecx, DWORD PTR _n$[esp]
	mov	edx, DWORD PTR _soap$[esp]
	push	ecx
	push	edx
	or	ecx, -1
	call	?soap_instantiate_xsd__string@@YAPAVxsd__string@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_xsd__string
	add	esp, 8
	pop	edi

; 575  : }

	ret	0
$LN16@soap_insta@24:

; 531  : 	case SOAP_TYPE__ns2__getSessionIDElement:
; 532  : 		return (void*)soap_instantiate__ns2__getSessionIDElement(soap, -1, type, arrayType, n);

	mov	eax, DWORD PTR _n$[esp]
	mov	ecx, DWORD PTR _soap$[esp]
	push	eax
	push	ecx
	or	ecx, -1
	call	?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSessionIDElement
	add	esp, 8
	pop	edi

; 575  : }

	ret	0
$LN15@soap_insta@24:

; 533  : 	case SOAP_TYPE__ns2__getSessionIDResponseElement:
; 534  : 		return (void*)soap_instantiate__ns2__getSessionIDResponseElement(soap, -1, type, arrayType, n);

	mov	edx, DWORD PTR _n$[esp]
	mov	eax, DWORD PTR _soap$[esp]
	push	edx
	push	eax
	or	ecx, -1
	call	?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSessionIDResponseElement
	add	esp, 8
	pop	edi

; 575  : }

	ret	0
$LN14@soap_insta@24:

; 535  : 	case SOAP_TYPE__ns2__getSettingsFileElement:
; 536  : 		return (void*)soap_instantiate__ns2__getSettingsFileElement(soap, -1, type, arrayType, n);

	mov	ecx, DWORD PTR _n$[esp]
	mov	edx, DWORD PTR _soap$[esp]
	push	ecx
	push	edx
	or	ecx, -1
	call	?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSettingsFileElement
	add	esp, 8
	pop	edi

; 575  : }

	ret	0
$LN13@soap_insta@24:

; 537  : 	case SOAP_TYPE__ns2__getSettingsFileResponseElement:
; 538  : 		return (void*)soap_instantiate__ns2__getSettingsFileResponseElement(soap, -1, type, arrayType, n);

	mov	eax, DWORD PTR _n$[esp]
	mov	ecx, DWORD PTR _soap$[esp]
	push	eax
	push	ecx
	or	ecx, -1
	call	?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSettingsFileResponseElement
	add	esp, 8
	pop	edi

; 575  : }

	ret	0
$LN12@soap_insta@24:

; 539  : 	case SOAP_TYPE__ns2__submitEpochResultElement:
; 540  : 		return (void*)soap_instantiate__ns2__submitEpochResultElement(soap, -1, type, arrayType, n);

	mov	edx, DWORD PTR _n$[esp]
	mov	eax, DWORD PTR _soap$[esp]
	push	edx
	push	eax
	or	ecx, -1
	call	?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__submitEpochResultElement
	add	esp, 8
	pop	edi

; 575  : }

	ret	0
$LN11@soap_insta@24:

; 541  : 	case SOAP_TYPE__ns2__submitEpochResultResponseElement:
; 542  : 		return (void*)soap_instantiate__ns2__submitEpochResultResponseElement(soap, -1, type, arrayType, n);

	mov	ecx, DWORD PTR _n$[esp]
	mov	edx, DWORD PTR _soap$[esp]
	push	ecx
	push	edx
	or	ecx, -1
	call	?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__submitEpochResultResponseElement
	add	esp, 8
	pop	edi

; 575  : }

	ret	0
$LN10@soap_insta@24:

; 543  : 	case SOAP_TYPE___ns1__getSessionID:
; 544  : 		return (void*)soap_instantiate___ns1__getSessionID(soap, -1, type, arrayType, n);

	mov	eax, DWORD PTR _n$[esp]
	mov	ecx, DWORD PTR _soap$[esp]
	push	eax
	push	ecx
	or	edi, -1
	call	?soap_instantiate___ns1__getSessionID@@YAPAU__ns1__getSessionID@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate___ns1__getSessionID
	add	esp, 8
	pop	edi

; 575  : }

	ret	0
$LN9@soap_insta@24:

; 545  : 	case SOAP_TYPE___ns1__getSettingsFile:
; 546  : 		return (void*)soap_instantiate___ns1__getSettingsFile(soap, -1, type, arrayType, n);

	mov	edx, DWORD PTR _n$[esp]
	mov	eax, DWORD PTR _soap$[esp]
	push	edx
	push	eax
	or	edi, -1
	call	?soap_instantiate___ns1__getSettingsFile@@YAPAU__ns1__getSettingsFile@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate___ns1__getSettingsFile
	add	esp, 8
	pop	edi

; 575  : }

	ret	0
$LN8@soap_insta@24:

; 547  : 	case SOAP_TYPE___ns1__submitEpochResult:
; 548  : 		return (void*)soap_instantiate___ns1__submitEpochResult(soap, -1, type, arrayType, n);

	mov	ecx, DWORD PTR _n$[esp]
	mov	edx, DWORD PTR _soap$[esp]
	push	ecx
	push	edx
	or	edi, -1
	call	?soap_instantiate___ns1__submitEpochResult@@YAPAU__ns1__submitEpochResult@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate___ns1__submitEpochResult
	add	esp, 8
	pop	edi

; 575  : }

	ret	0
$LN7@soap_insta@24:

; 549  : #ifndef WITH_NOGLOBAL
; 550  : 	case SOAP_TYPE_SOAP_ENV__Header:
; 551  : 		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);

	mov	eax, DWORD PTR _n$[esp]
	mov	edi, DWORD PTR _soap$[esp]
	push	eax
	call	?soap_instantiate_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_SOAP_ENV__Header
	add	esp, 4
	pop	edi

; 575  : }

	ret	0
$LN6@soap_insta@24:

; 552  : #endif
; 553  : #ifndef WITH_NOGLOBAL
; 554  : 	case SOAP_TYPE_SOAP_ENV__Code:
; 555  : 		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);

	mov	ecx, DWORD PTR _n$[esp]
	mov	edi, DWORD PTR _soap$[esp]
	push	ecx
	call	?soap_instantiate_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_SOAP_ENV__Code
	add	esp, 4
	pop	edi

; 575  : }

	ret	0
$LN5@soap_insta@24:

; 556  : #endif
; 557  : #ifndef WITH_NOGLOBAL
; 558  : 	case SOAP_TYPE_SOAP_ENV__Detail:
; 559  : 		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);

	mov	edx, DWORD PTR _n$[esp]
	mov	edi, DWORD PTR _soap$[esp]
	push	edx
	call	?soap_instantiate_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_SOAP_ENV__Detail
	add	esp, 4
	pop	edi

; 575  : }

	ret	0
$LN4@soap_insta@24:

; 560  : #endif
; 561  : #ifndef WITH_NOGLOBAL
; 562  : 	case SOAP_TYPE_SOAP_ENV__Reason:
; 563  : 		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);

	mov	eax, DWORD PTR _n$[esp]
	mov	edi, DWORD PTR _soap$[esp]
	push	eax
	call	?soap_instantiate_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_SOAP_ENV__Reason
	add	esp, 4
	pop	edi

; 575  : }

	ret	0
$LN3@soap_insta@24:

; 564  : #endif
; 565  : #ifndef WITH_NOGLOBAL
; 566  : 	case SOAP_TYPE_SOAP_ENV__Fault:
; 567  : 		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);

	mov	ecx, DWORD PTR _n$[esp]
	mov	edi, DWORD PTR _soap$[esp]
	push	ecx
	call	?soap_instantiate_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_SOAP_ENV__Fault
	add	esp, 4
	pop	edi

; 575  : }

	ret	0
$LN2@soap_insta@24:

; 568  : #endif
; 569  : 	case SOAP_TYPE_std__vectorTemplateOffloat:
; 570  : 		return (void*)soap_instantiate_std__vectorTemplateOffloat(soap, -1, type, arrayType, n);

	mov	edx, DWORD PTR _n$[esp]
	mov	edi, DWORD PTR _soap$[esp]
	push	edx
	call	?soap_instantiate_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_std__vectorTemplateOffloat
	add	esp, 4
	pop	edi

; 575  : }

	ret	0
$LN1@soap_insta@24:

; 571  : 	case SOAP_TYPE_std__vectorTemplateOfint:
; 572  : 		return (void*)soap_instantiate_std__vectorTemplateOfint(soap, -1, type, arrayType, n);

	mov	eax, DWORD PTR _n$[esp]
	mov	edi, DWORD PTR _soap$[esp]
	push	eax
	call	?soap_instantiate_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_std__vectorTemplateOfint
	add	esp, 4
	pop	edi

; 575  : }

	ret	0
$LN24@soap_insta@24:

; 573  : 	}
; 574  : 	return NULL;

	xor	eax, eax
	pop	edi

; 575  : }

	ret	0
	npad	3
$LN29@soap_insta@24:
	DD	$LN23@soap_insta@24
	DD	$LN22@soap_insta@24
	DD	$LN21@soap_insta@24
	DD	$LN20@soap_insta@24
	DD	$LN19@soap_insta@24
	DD	$LN17@soap_insta@24
	DD	$LN18@soap_insta@24
	DD	$LN16@soap_insta@24
	DD	$LN15@soap_insta@24
	DD	$LN14@soap_insta@24
	DD	$LN13@soap_insta@24
	DD	$LN12@soap_insta@24
	DD	$LN11@soap_insta@24
	DD	$LN1@soap_insta@24
	DD	$LN2@soap_insta@24
	DD	$LN10@soap_insta@24
	DD	$LN9@soap_insta@24
	DD	$LN8@soap_insta@24
	DD	$LN7@soap_insta@24
	DD	$LN6@soap_insta@24
	DD	$LN5@soap_insta@24
	DD	$LN4@soap_insta@24
	DD	$LN3@soap_insta@24
	DD	$LN24@soap_insta@24
$LN28@soap_insta@24:
	DB	0
	DB	23					; 00000017H
	DB	1
	DB	23					; 00000017H
	DB	2
	DB	23					; 00000017H
	DB	3
	DB	4
	DB	23					; 00000017H
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	23					; 00000017H
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	15					; 0000000fH
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	16					; 00000010H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	23					; 00000017H
	DB	20					; 00000014H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	21					; 00000015H
	DB	22					; 00000016H
?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ENDP	; soap_instantiate
_TEXT	ENDS
PUBLIC	_soap_putelement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
_soap_putelement PROC
; _soap$ = ecx
; _id$ = eax

; 354  : {

	mov	edx, DWORD PTR _ptr$[esp-4]
	push	esi
	mov	esi, DWORD PTR _tag$[esp]
	push	edi

; 355  : 	switch (type)

	mov	edi, DWORD PTR _type$[esp+4]
	dec	edi
	cmp	edi, 36					; 00000024H
	ja	$LN28@soap_putel
	jmp	DWORD PTR $LN44@soap_putel[edi*4]
$LN27@soap_putel:

; 356  : 	{
; 357  : 	case SOAP_TYPE_byte:
; 358  : 		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");

	push	OFFSET ??_C@_08BEPNMEIH@xsd?3byte?$AA@
	push	edx
	push	ecx
	mov	ecx, esi
	call	_soap_outbyte
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN26@soap_putel:

; 359  : 	case SOAP_TYPE_int:
; 360  : 		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");

	push	OFFSET ??_C@_07PCIGPDP@xsd?3int?$AA@
	push	edx
	push	ecx
	mov	ecx, esi
	call	_soap_outint
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN25@soap_putel:

; 361  : 	case SOAP_TYPE_LONG64:
; 362  : 		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");

	push	OFFSET ??_C@_08PNDIDGIB@xsd?3long?$AA@
	push	esi
	push	ecx
	mov	ecx, edx
	call	_soap_outLONG64
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN24@soap_putel:

; 363  : 	case SOAP_TYPE_float:
; 364  : 		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");

	push	OFFSET ??_C@_09ILBLHFBD@xsd?3float?$AA@
	push	edx
	push	ecx
	mov	ecx, esi
	call	_soap_outfloat
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN23@soap_putel:

; 365  : 	case SOAP_TYPE_bool:
; 366  : 		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");

	push	OFFSET ??_C@_0M@FGHMEICI@xsd?3boolean?$AA@
	push	edx
	push	ecx
	mov	ecx, esi
	call	?soap_out_bool@@YAHPAUsoap@@PBDHPB_N1@Z	; soap_out_bool
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN22@soap_putel:

; 367  : 	case SOAP_TYPE__ns2__submitEpochResultResponseElement:
; 368  : 		return ((_ns2__submitEpochResultResponseElement *)ptr)->soap_out(soap, "ns2:submitEpochResultResponseElement", id, NULL);

	mov	esi, DWORD PTR [edx]
	push	0
	push	eax
	mov	eax, DWORD PTR [esi+16]
	push	OFFSET ??_C@_0CF@HCKJIEH@ns2?3submitEpochResultResponseEle@
	push	ecx
	mov	ecx, edx
	call	eax
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN21@soap_putel:

; 369  : 	case SOAP_TYPE__ns2__submitEpochResultElement:
; 370  : 		return ((_ns2__submitEpochResultElement *)ptr)->soap_out(soap, "ns2:submitEpochResultElement", id, NULL);

	mov	esi, DWORD PTR [edx]
	push	0
	push	eax
	push	OFFSET ??_C@_0BN@LEHNEPKC@ns2?3submitEpochResultElement?$AA@
	push	ecx
	mov	ecx, edx
	mov	edx, DWORD PTR [esi+16]
	call	edx
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN20@soap_putel:

; 371  : 	case SOAP_TYPE__ns2__getSettingsFileResponseElement:
; 372  : 		return ((_ns2__getSettingsFileResponseElement *)ptr)->soap_out(soap, "ns2:getSettingsFileResponseElement", id, NULL);

	mov	esi, DWORD PTR [edx]
	push	0
	push	eax
	mov	eax, DWORD PTR [esi+16]
	push	OFFSET ??_C@_0CD@GADHDKNA@ns2?3getSettingsFileResponseEleme@
	push	ecx
	mov	ecx, edx
	call	eax
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN19@soap_putel:

; 373  : 	case SOAP_TYPE__ns2__getSettingsFileElement:
; 374  : 		return ((_ns2__getSettingsFileElement *)ptr)->soap_out(soap, "ns2:getSettingsFileElement", id, NULL);

	mov	esi, DWORD PTR [edx]
	push	0
	push	eax
	push	OFFSET ??_C@_0BL@EBHOCBLE@ns2?3getSettingsFileElement?$AA@
	push	ecx
	mov	ecx, edx
	mov	edx, DWORD PTR [esi+16]
	call	edx
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN18@soap_putel:

; 375  : 	case SOAP_TYPE__ns2__getSessionIDResponseElement:
; 376  : 		return ((_ns2__getSessionIDResponseElement *)ptr)->soap_out(soap, "ns2:getSessionIDResponseElement", id, NULL);

	mov	esi, DWORD PTR [edx]
	push	0
	push	eax
	mov	eax, DWORD PTR [esi+16]
	push	OFFSET ??_C@_0CA@KPMHIEOJ@ns2?3getSessionIDResponseElement?$AA@
	push	ecx
	mov	ecx, edx
	call	eax
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN17@soap_putel:

; 377  : 	case SOAP_TYPE__ns2__getSessionIDElement:
; 378  : 		return ((_ns2__getSessionIDElement *)ptr)->soap_out(soap, "ns2:getSessionIDElement", id, NULL);

	mov	esi, DWORD PTR [edx]
	push	0
	push	eax
	push	OFFSET ??_C@_0BI@CHGDHCPP@ns2?3getSessionIDElement?$AA@
	push	ecx
	mov	ecx, edx
	mov	edx, DWORD PTR [esi+16]
	call	edx
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN16@soap_putel:

; 379  : 	case SOAP_TYPE_std__string:
; 380  : 		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");

	push	OFFSET ??_C@_0L@DIJPMJCO@xsd?3string?$AA@
	push	edx
	push	ecx
	mov	ecx, esi
	call	?soap_out_std__string@@YAHPAUsoap@@PBDHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; soap_out_std__string
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN15@soap_putel:

; 381  : 	case SOAP_TYPE_xsd__string:
; 382  : 		return ((xsd__string *)ptr)->soap_out(soap, tag, id, "xsd:string");

	mov	edi, DWORD PTR [edx]
	push	OFFSET ??_C@_0L@DIJPMJCO@xsd?3string?$AA@
	push	eax
	mov	eax, DWORD PTR [edi+16]
	push	esi
	push	ecx
	mov	ecx, edx
	call	eax
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN14@soap_putel:

; 383  : 	case SOAP_TYPE_xsd__long:
; 384  : 		return ((xsd__long *)ptr)->soap_out(soap, tag, id, "xsd:long");

	mov	edi, DWORD PTR [edx]
	push	OFFSET ??_C@_08PNDIDGIB@xsd?3long?$AA@
	push	eax
	push	esi
	push	ecx
	mov	ecx, edx
	mov	edx, DWORD PTR [edi+16]
	call	edx
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN13@soap_putel:

; 385  : 	case SOAP_TYPE_xsd__int:
; 386  : 		return ((xsd__int *)ptr)->soap_out(soap, tag, id, "xsd:int");

	mov	edi, DWORD PTR [edx]
	push	OFFSET ??_C@_07PCIGPDP@xsd?3int?$AA@
	push	eax
	mov	eax, DWORD PTR [edi+16]
	push	esi
	push	ecx
	mov	ecx, edx
	call	eax
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN12@soap_putel:

; 387  : 	case SOAP_TYPE_xsd__float:
; 388  : 		return ((xsd__float *)ptr)->soap_out(soap, tag, id, "xsd:float");

	mov	edi, DWORD PTR [edx]
	push	OFFSET ??_C@_09ILBLHFBD@xsd?3float?$AA@
	push	eax
	push	esi
	push	ecx
	mov	ecx, edx
	mov	edx, DWORD PTR [edi+16]
	call	edx
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN11@soap_putel:

; 389  : 	case SOAP_TYPE_xsd__boolean:
; 390  : 		return ((xsd__boolean *)ptr)->soap_out(soap, tag, id, "xsd:boolean");

	mov	edi, DWORD PTR [edx]
	push	OFFSET ??_C@_0M@FGHMEICI@xsd?3boolean?$AA@
	push	eax
	mov	eax, DWORD PTR [edi+16]
	push	esi
	push	ecx
	mov	ecx, edx
	call	eax
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN10@soap_putel:

; 391  : 	case SOAP_TYPE_xsd__anyType:
; 392  : 		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");

	mov	edi, DWORD PTR [edx]
	push	OFFSET ??_C@_0M@NOIFKOBF@xsd?3anyType?$AA@
	push	eax
	push	esi
	push	ecx
	mov	ecx, edx
	mov	edx, DWORD PTR [edi+16]
	call	edx
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN9@soap_putel:

; 393  : 	case SOAP_TYPE_PointerTo_ns2__submitEpochResultResponseElement:
; 394  : 		return soap_out_PointerTo_ns2__submitEpochResultResponseElement(soap, tag, id, (_ns2__submitEpochResultResponseElement *const*)ptr, "ns2:submitEpochResultResponseElement");

	push	OFFSET ??_C@_0CF@HCKJIEH@ns2?3submitEpochResultResponseEle@
	push	edx
	push	esi
	call	?soap_out_PointerTo_ns2__submitEpochResultResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__submitEpochResultResponseElement@@1@Z ; soap_out_PointerTo_ns2__submitEpochResultResponseElement
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN8@soap_putel:

; 395  : 	case SOAP_TYPE_PointerTo_ns2__submitEpochResultElement:
; 396  : 		return soap_out_PointerTo_ns2__submitEpochResultElement(soap, tag, id, (_ns2__submitEpochResultElement *const*)ptr, "ns2:submitEpochResultElement");

	push	OFFSET ??_C@_0BN@LEHNEPKC@ns2?3submitEpochResultElement?$AA@
	push	edx
	push	esi
	call	?soap_out_PointerTo_ns2__submitEpochResultElement@@YAHPAUsoap@@PBDHPBQAV_ns2__submitEpochResultElement@@1@Z ; soap_out_PointerTo_ns2__submitEpochResultElement
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN7@soap_putel:

; 397  : 	case SOAP_TYPE_PointerTo_ns2__getSettingsFileResponseElement:
; 398  : 		return soap_out_PointerTo_ns2__getSettingsFileResponseElement(soap, tag, id, (_ns2__getSettingsFileResponseElement *const*)ptr, "ns2:getSettingsFileResponseElement");

	push	OFFSET ??_C@_0CD@GADHDKNA@ns2?3getSettingsFileResponseEleme@
	push	edx
	push	esi
	call	?soap_out_PointerTo_ns2__getSettingsFileResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSettingsFileResponseElement@@1@Z ; soap_out_PointerTo_ns2__getSettingsFileResponseElement
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN6@soap_putel:

; 399  : 	case SOAP_TYPE_PointerTo_ns2__getSettingsFileElement:
; 400  : 		return soap_out_PointerTo_ns2__getSettingsFileElement(soap, tag, id, (_ns2__getSettingsFileElement *const*)ptr, "ns2:getSettingsFileElement");

	push	OFFSET ??_C@_0BL@EBHOCBLE@ns2?3getSettingsFileElement?$AA@
	push	edx
	push	esi
	call	?soap_out_PointerTo_ns2__getSettingsFileElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSettingsFileElement@@1@Z ; soap_out_PointerTo_ns2__getSettingsFileElement
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN5@soap_putel:

; 401  : 	case SOAP_TYPE_PointerTo_ns2__getSessionIDResponseElement:
; 402  : 		return soap_out_PointerTo_ns2__getSessionIDResponseElement(soap, tag, id, (_ns2__getSessionIDResponseElement *const*)ptr, "ns2:getSessionIDResponseElement");

	push	OFFSET ??_C@_0CA@KPMHIEOJ@ns2?3getSessionIDResponseElement?$AA@
	push	edx
	push	esi
	call	?soap_out_PointerTo_ns2__getSessionIDResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSessionIDResponseElement@@1@Z ; soap_out_PointerTo_ns2__getSessionIDResponseElement
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN4@soap_putel:

; 403  : 	case SOAP_TYPE_PointerTo_ns2__getSessionIDElement:
; 404  : 		return soap_out_PointerTo_ns2__getSessionIDElement(soap, tag, id, (_ns2__getSessionIDElement *const*)ptr, "ns2:getSessionIDElement");

	push	OFFSET ??_C@_0BI@CHGDHCPP@ns2?3getSessionIDElement?$AA@
	push	edx
	push	esi
	call	?soap_out_PointerTo_ns2__getSessionIDElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSessionIDElement@@1@Z ; soap_out_PointerTo_ns2__getSessionIDElement
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN3@soap_putel:

; 405  : 	case SOAP_TYPE_PointerTostd__string:
; 406  : 		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");

	push	OFFSET ??_C@_0L@DIJPMJCO@xsd?3string?$AA@
	push	edx
	push	esi
	call	?soap_out_PointerTostd__string@@YAHPAUsoap@@PBDHPBQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; soap_out_PointerTostd__string
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN2@soap_putel:

; 407  : 	case SOAP_TYPE__QName:
; 408  : 		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);

	push	4
	push	0
	lea	edx, DWORD PTR _ptr$[esp+12]
	push	edx
	push	OFFSET ??_C@_09JDHJJDCF@xsd?3QName?$AA@
	call	_soap_outstring
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN1@soap_putel:

; 409  : 	case SOAP_TYPE_string:
; 410  : 		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");

	push	4
	push	OFFSET ??_C@_0L@DIJPMJCO@xsd?3string?$AA@
	lea	edx, DWORD PTR _ptr$[esp+12]
	push	edx
	push	esi
	call	_soap_outstring
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 413  : }

	ret	0
$LN28@soap_putel:
	pop	edi

; 411  : 	}
; 412  : 	return SOAP_OK;

	xor	eax, eax
	pop	esi

; 413  : }

	ret	0
	npad	3
$LN44@soap_putel:
	DD	$LN26@soap_putel
	DD	$LN28@soap_putel
	DD	$LN27@soap_putel
	DD	$LN1@soap_putel
	DD	$LN2@soap_putel
	DD	$LN28@soap_putel
	DD	$LN28@soap_putel
	DD	$LN10@soap_putel
	DD	$LN28@soap_putel
	DD	$LN11@soap_putel
	DD	$LN23@soap_putel
	DD	$LN12@soap_putel
	DD	$LN24@soap_putel
	DD	$LN13@soap_putel
	DD	$LN14@soap_putel
	DD	$LN25@soap_putel
	DD	$LN15@soap_putel
	DD	$LN16@soap_putel
	DD	$LN17@soap_putel
	DD	$LN18@soap_putel
	DD	$LN19@soap_putel
	DD	$LN20@soap_putel
	DD	$LN21@soap_putel
	DD	$LN22@soap_putel
	DD	$LN3@soap_putel
	DD	$LN28@soap_putel
	DD	$LN28@soap_putel
	DD	$LN4@soap_putel
	DD	$LN5@soap_putel
	DD	$LN28@soap_putel
	DD	$LN28@soap_putel
	DD	$LN6@soap_putel
	DD	$LN7@soap_putel
	DD	$LN28@soap_putel
	DD	$LN28@soap_putel
	DD	$LN8@soap_putel
	DD	$LN9@soap_putel
_soap_putelement ENDP
_TEXT	ENDS
PUBLIC	?soap_putindependent@@YAHPAUsoap@@@Z		; soap_putindependent
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
?soap_putindependent@@YAHPAUsoap@@@Z PROC		; soap_putindependent

; 335  : {

	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]

; 336  : 	int i;
; 337  : 	struct soap_plist *pp;
; 338  : 	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))

	cmp	WORD PTR [ebx+6], 1
	push	ebp
	push	esi
	push	edi
	jne	SHORT $LN7@soap_putin
	cmp	DWORD PTR [ebx+40], 0
	je	SHORT $LN7@soap_putin
	test	DWORD PTR [ebx+8], 98304		; 00018000H
	jne	SHORT $LN7@soap_putin

; 339  : 		for (i = 0; i < SOAP_PTRHASH; i++)

	xor	edi, edi
	lea	ebp, DWORD PTR [ebx+8100]
$LL9@soap_putin:

; 340  : 			for (pp = soap->pht[i]; pp; pp = pp->next)

	mov	esi, DWORD PTR [ebp]
	test	esi, esi
	je	SHORT $LN8@soap_putin
	npad	3
$LL6@soap_putin:

; 341  : 				if (pp->mark1 == 2 || pp->mark2 == 2)

	cmp	BYTE PTR [esi+20], 2
	je	SHORT $LN2@soap_putin
	cmp	BYTE PTR [esi+21], 2
	jne	SHORT $LN5@soap_putin
$LN2@soap_putin:

; 342  : 					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi+16]
	push	OFFSET ??_C@_02EGCJHIOB@id?$AA@
	push	ecx
	mov	ecx, ebx
	call	_soap_putelement
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@soap_putin
$LN5@soap_putin:

; 340  : 			for (pp = soap->pht[i]; pp; pp = pp->next)

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL6@soap_putin
$LN8@soap_putin:

; 339  : 		for (i = 0; i < SOAP_PTRHASH; i++)

	inc	edi
	add	ebp, 4
	cmp	edi, 1024				; 00000400H
	jl	SHORT $LL9@soap_putin
$LN7@soap_putin:
	pop	edi
	pop	esi
	pop	ebp

; 344  : 	return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 345  : }

	ret	0
$LN15@soap_putin:

; 343  : 						return soap->error;

	mov	eax, DWORD PTR [ebx+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 345  : }

	ret	0
?soap_putindependent@@YAHPAUsoap@@@Z ENDP		; soap_putindependent
_TEXT	ENDS
PUBLIC	_soap_getelement
PUBLIC	?soap_ignore_element@@YAHPAUsoap@@@Z		; soap_ignore_element
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_t$82957 = -4						; size = 4
_soap$ = 8						; size = 4
?soap_ignore_element@@YAHPAUsoap@@@Z PROC		; soap_ignore_element

; 304  : {

	push	ecx
	push	ebx
	push	esi

; 305  : 	if (!soap_peek_element(soap))

	mov	esi, DWORD PTR _soap$[esp+8]
	mov	eax, esi
	call	_soap_peek_element
	test	eax, eax
	jne	$LN1@soap_ignor

; 306  : 	{	int t;
; 307  : 		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
; 308  : 		if (soap->mustUnderstand && !soap->other)

	cmp	WORD PTR [esi+87298], ax
	je	SHORT $LN12@soap_ignor
	cmp	WORD PTR [esi+87220], ax
	jne	SHORT $LN12@soap_ignor

; 309  : 			return soap->error = SOAP_MUSTUNDERSTAND;

	mov	eax, 8
	mov	DWORD PTR [esi+90460], eax
	pop	esi
	pop	ebx

; 331  : }

	pop	ecx
	ret	0
$LN12@soap_ignor:

; 310  : 		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))

	test	DWORD PTR [esi+8], 4096			; 00001000H
	je	SHORT $LN9@soap_ignor
	cmp	WORD PTR [esi+87304], 3
	jne	SHORT $LN10@soap_ignor
$LN9@soap_ignor:
	push	edi
	lea	ebx, DWORD PTR [esi+80052]
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_09JEONCPHE@SOAP?9ENV?3?$AA@
	call	_soap_match_tag
	add	esp, 8
	pop	edi
	test	eax, eax
	jne	SHORT $LN11@soap_ignor
$LN10@soap_ignor:

; 311  : 		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
; 312  : 			return soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], 3
	pop	esi
	mov	eax, 3
	pop	ebx

; 331  : }

	pop	ecx
	ret	0
$LN11@soap_ignor:

; 313  : 		}
; 314  : 		if (!*soap->id || !soap_getelement(soap, &t))

	cmp	BYTE PTR [esi+81076], 0
	je	SHORT $LN7@soap_ignor
	lea	eax, DWORD PTR _t$82957[esp+12]
	push	eax
	push	esi
	call	_soap_getelement
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@soap_ignor
$LN7@soap_ignor:

; 315  : 		{	soap->peeked = 0;
; 316  : 			if (soap->fignore)

	mov	eax, DWORD PTR [esi+12324]
	xor	ecx, ecx
	mov	WORD PTR [esi+87308], cx
	test	eax, eax
	je	SHORT $LN6@soap_ignor

; 317  : 				soap->error = soap->fignore(soap, soap->tag);

	push	ebx
	push	esi
	call	eax
	add	esp, 8
	mov	DWORD PTR [esi+90460], eax

; 318  : 			else

	jmp	SHORT $LN5@soap_ignor
$LN6@soap_ignor:

; 319  : 				soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], ecx
$LN5@soap_ignor:

; 320  : 			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
; 321  : 			if (!soap->error && soap->body)

	cmp	DWORD PTR [esi+90460], 0
	jne	SHORT $LN1@soap_ignor
	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN1@soap_ignor

; 322  : 			{	soap->level++;

	inc	DWORD PTR [esi+12444]
$LL3@soap_ignor:

; 323  : 				while (!soap_ignore_element(soap))

	push	esi
	call	?soap_ignore_element@@YAHPAUsoap@@@Z	; soap_ignore_element
	add	esp, 4
	test	eax, eax
	je	SHORT $LL3@soap_ignor

; 324  : 					;
; 325  : 				if (soap->error == SOAP_NO_TAG)

	cmp	DWORD PTR [esi+90460], 6
	jne	SHORT $LN1@soap_ignor

; 326  : 					soap->error = soap_element_end_in(soap, NULL);

	push	0
	call	_soap_element_end_in
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
$LN1@soap_ignor:

; 327  : 			}
; 328  : 		}
; 329  : 	}
; 330  : 	return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	esi
	pop	ebx

; 331  : }

	pop	ecx
	ret	0
?soap_ignore_element@@YAHPAUsoap@@@Z ENDP		; soap_ignore_element
PUBLIC	?soap_in_string@@YAPAPADPAUsoap@@PBDPAPAD1@Z	; soap_in_string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_a$ = 8							; size = 4
?soap_in_string@@YAPAPADPAUsoap@@PBDPAPAD1@Z PROC	; soap_in_string
; _soap$ = ecx
; _tag$ = eax

; 4322 : 	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);

	push	1
	push	4
	push	eax
	mov	eax, DWORD PTR _a$[esp+8]
	call	_soap_instring
	add	esp, 12					; 0000000cH

; 4323 : }

	ret	0
?soap_in_string@@YAPAPADPAUsoap@@PBDPAPAD1@Z ENDP	; soap_in_string
_TEXT	ENDS
PUBLIC	?soap_put_string@@YAHPAUsoap@@PBQADPBD2@Z	; soap_put_string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_string@@YAHPAUsoap@@PBQADPBD2@Z PROC		; soap_put_string
; _soap$ = esi
; _a$ = edi

; 4301 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);

	push	esi
	mov	edx, 4
	mov	eax, edi
	call	_soap_embed

; 4302 : 	if (soap_out_string(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	mov	edx, DWORD PTR _tag$[esp]
	push	4
	push	ecx
	push	edi
	push	edx
	mov	ecx, esi
	call	_soap_outstring
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN1@soap_put_s

; 4303 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 4305 : }

	ret	0
$LN1@soap_put_s:

; 4304 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 4305 : }

	ret	0
?soap_put_string@@YAHPAUsoap@@PBQADPBD2@Z ENDP		; soap_put_string
_TEXT	ENDS
PUBLIC	?soap_in__QName@@YAPAPADPAUsoap@@PBDPAPAD1@Z	; soap_in__QName
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_a$ = 8							; size = 4
?soap_in__QName@@YAPAPADPAUsoap@@PBDPAPAD1@Z PROC	; soap_in__QName
; _soap$ = ecx
; _tag$ = eax

; 4282 : 	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);

	push	2
	push	5
	push	eax
	mov	eax, DWORD PTR _a$[esp+8]
	call	_soap_instring
	add	esp, 12					; 0000000cH

; 4283 : }

	ret	0
?soap_in__QName@@YAPAPADPAUsoap@@PBDPAPAD1@Z ENDP	; soap_in__QName
_TEXT	ENDS
PUBLIC	?soap_put__QName@@YAHPAUsoap@@PBQADPBD2@Z	; soap_put__QName
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put__QName@@YAHPAUsoap@@PBQADPBD2@Z PROC		; soap_put__QName
; _soap$ = esi
; _a$ = edi

; 4261 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);

	push	esi
	mov	edx, 5
	mov	eax, edi
	call	_soap_embed

; 4262 : 	if (soap_out__QName(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	mov	edx, DWORD PTR _tag$[esp]
	push	5
	push	ecx
	push	edi
	push	edx
	mov	ecx, esi
	call	_soap_outstring
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN1@soap_put__@4

; 4263 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 4265 : }

	ret	0
$LN1@soap_put__@4:

; 4264 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 4265 : }

	ret	0
?soap_put__QName@@YAHPAUsoap@@PBQADPBD2@Z ENDP		; soap_put__QName
_TEXT	ENDS
PUBLIC	?soap_put_PointerTostd__string@@YAHPAUsoap@@PBQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD2@Z ; soap_put_PointerTostd__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_PointerTostd__string@@YAHPAUsoap@@PBQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD2@Z PROC ; soap_put_PointerTostd__string
; _soap$ = esi
; _a$ = edi

; 4208 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);

	push	esi
	mov	edx, 25					; 00000019H
	mov	eax, edi
	call	_soap_embed

; 4209 : 	if (soap_out_PointerTostd__string(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	mov	edx, DWORD PTR _tag$[esp]
	push	ecx
	push	edi
	push	edx
	mov	ecx, esi
	call	?soap_out_PointerTostd__string@@YAHPAUsoap@@PBDHPBQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; soap_out_PointerTostd__string
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_P

; 4210 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 4212 : }

	ret	0
$LN1@soap_put_P:

; 4211 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 4212 : }

	ret	0
?soap_put_PointerTostd__string@@YAHPAUsoap@@PBQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD2@Z ENDP ; soap_put_PointerTostd__string
_TEXT	ENDS
PUBLIC	?soap_put_PointerTo_ns2__getSessionIDElement@@YAHPAUsoap@@PBQAV_ns2__getSessionIDElement@@PBD2@Z ; soap_put_PointerTo_ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_PointerTo_ns2__getSessionIDElement@@YAHPAUsoap@@PBQAV_ns2__getSessionIDElement@@PBD2@Z PROC ; soap_put_PointerTo_ns2__getSessionIDElement
; _soap$ = esi
; _a$ = edi

; 4153 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getSessionIDElement);

	push	esi
	mov	edx, 28					; 0000001cH
	mov	eax, edi
	call	_soap_embed

; 4154 : 	if (soap_out_PointerTo_ns2__getSessionIDElement(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	mov	edx, DWORD PTR _tag$[esp]
	push	ecx
	push	edi
	push	edx
	mov	ecx, esi
	call	?soap_out_PointerTo_ns2__getSessionIDElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSessionIDElement@@1@Z ; soap_out_PointerTo_ns2__getSessionIDElement
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_P@2

; 4155 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 4157 : }

	ret	0
$LN1@soap_put_P@2:

; 4156 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 4157 : }

	ret	0
?soap_put_PointerTo_ns2__getSessionIDElement@@YAHPAUsoap@@PBQAV_ns2__getSessionIDElement@@PBD2@Z ENDP ; soap_put_PointerTo_ns2__getSessionIDElement
_TEXT	ENDS
PUBLIC	?soap_put_PointerTo_ns2__getSessionIDResponseElement@@YAHPAUsoap@@PBQAV_ns2__getSessionIDResponseElement@@PBD2@Z ; soap_put_PointerTo_ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_PointerTo_ns2__getSessionIDResponseElement@@YAHPAUsoap@@PBQAV_ns2__getSessionIDResponseElement@@PBD2@Z PROC ; soap_put_PointerTo_ns2__getSessionIDResponseElement
; _soap$ = esi
; _a$ = edi

; 4098 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getSessionIDResponseElement);

	push	esi
	mov	edx, 29					; 0000001dH
	mov	eax, edi
	call	_soap_embed

; 4099 : 	if (soap_out_PointerTo_ns2__getSessionIDResponseElement(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	mov	edx, DWORD PTR _tag$[esp]
	push	ecx
	push	edi
	push	edx
	mov	ecx, esi
	call	?soap_out_PointerTo_ns2__getSessionIDResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSessionIDResponseElement@@1@Z ; soap_out_PointerTo_ns2__getSessionIDResponseElement
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_P@3

; 4100 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 4102 : }

	ret	0
$LN1@soap_put_P@3:

; 4101 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 4102 : }

	ret	0
?soap_put_PointerTo_ns2__getSessionIDResponseElement@@YAHPAUsoap@@PBQAV_ns2__getSessionIDResponseElement@@PBD2@Z ENDP ; soap_put_PointerTo_ns2__getSessionIDResponseElement
_TEXT	ENDS
PUBLIC	?soap_put_PointerTo_ns2__getSettingsFileElement@@YAHPAUsoap@@PBQAV_ns2__getSettingsFileElement@@PBD2@Z ; soap_put_PointerTo_ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_PointerTo_ns2__getSettingsFileElement@@YAHPAUsoap@@PBQAV_ns2__getSettingsFileElement@@PBD2@Z PROC ; soap_put_PointerTo_ns2__getSettingsFileElement
; _soap$ = esi
; _a$ = edi

; 4043 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getSettingsFileElement);

	push	esi
	mov	edx, 32					; 00000020H
	mov	eax, edi
	call	_soap_embed

; 4044 : 	if (soap_out_PointerTo_ns2__getSettingsFileElement(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	mov	edx, DWORD PTR _tag$[esp]
	push	ecx
	push	edi
	push	edx
	mov	ecx, esi
	call	?soap_out_PointerTo_ns2__getSettingsFileElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSettingsFileElement@@1@Z ; soap_out_PointerTo_ns2__getSettingsFileElement
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_P@4

; 4045 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 4047 : }

	ret	0
$LN1@soap_put_P@4:

; 4046 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 4047 : }

	ret	0
?soap_put_PointerTo_ns2__getSettingsFileElement@@YAHPAUsoap@@PBQAV_ns2__getSettingsFileElement@@PBD2@Z ENDP ; soap_put_PointerTo_ns2__getSettingsFileElement
_TEXT	ENDS
PUBLIC	?soap_put_PointerTo_ns2__getSettingsFileResponseElement@@YAHPAUsoap@@PBQAV_ns2__getSettingsFileResponseElement@@PBD2@Z ; soap_put_PointerTo_ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_PointerTo_ns2__getSettingsFileResponseElement@@YAHPAUsoap@@PBQAV_ns2__getSettingsFileResponseElement@@PBD2@Z PROC ; soap_put_PointerTo_ns2__getSettingsFileResponseElement
; _soap$ = esi
; _a$ = edi

; 3988 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getSettingsFileResponseElement);

	push	esi
	mov	edx, 33					; 00000021H
	mov	eax, edi
	call	_soap_embed

; 3989 : 	if (soap_out_PointerTo_ns2__getSettingsFileResponseElement(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	mov	edx, DWORD PTR _tag$[esp]
	push	ecx
	push	edi
	push	edx
	mov	ecx, esi
	call	?soap_out_PointerTo_ns2__getSettingsFileResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__getSettingsFileResponseElement@@1@Z ; soap_out_PointerTo_ns2__getSettingsFileResponseElement
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_P@5

; 3990 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 3992 : }

	ret	0
$LN1@soap_put_P@5:

; 3991 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 3992 : }

	ret	0
?soap_put_PointerTo_ns2__getSettingsFileResponseElement@@YAHPAUsoap@@PBQAV_ns2__getSettingsFileResponseElement@@PBD2@Z ENDP ; soap_put_PointerTo_ns2__getSettingsFileResponseElement
_TEXT	ENDS
PUBLIC	?soap_in_PointerTo_ns2__submitEpochResultElement@@YAPAPAV_ns2__submitEpochResultElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
?soap_in_PointerTo_ns2__submitEpochResultElement@@YAPAPAV_ns2__submitEpochResultElement@@PAUsoap@@PBDPAPAV1@1@Z PROC ; soap_in_PointerTo_ns2__submitEpochResultElement
; _soap$ = ecx
; _a$ = eax

; 3956 : {

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _tag$[esp+4]
	push	esi
	push	edi
	mov	edi, eax
	mov	esi, ecx

; 3957 : 	if (soap_element_begin_in(soap, tag, 1, NULL))
; 3958 : 		return NULL;
; 3959 : 	if (!a)

	test	edi, edi
	jne	SHORT $LN6@soap_in_Po@6

; 3960 : 		if (!(a = (_ns2__submitEpochResultElement **)soap_malloc(soap, sizeof(_ns2__submitEpochResultElement *))))

	lea	eax, DWORD PTR [edi+4]
	mov	edi, esi
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi

; 3961 : 			return NULL;

	je	SHORT $LN19@soap_in_Po@6
$LN6@soap_in_Po@6:

; 3962 : 	*a = NULL;

	mov	DWORD PTR [edi], 0

; 3963 : 	if (!soap->null && *soap->href != '#')

	cmp	WORD PTR [esi+87300], 0
	jne	SHORT $LN5@soap_in_Po@6
	cmp	BYTE PTR [esi+82100], 35		; 00000023H
	je	SHORT $LN5@soap_in_Po@6

; 3964 : 	{	soap_revert(soap);

	or	ecx, -1
	cmp	WORD PTR [esi+87308], 0
	jne	SHORT $LN15@soap_in_Po@6
	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	WORD PTR [esi+87308], ax
	je	SHORT $LN15@soap_in_Po@6
	add	DWORD PTR [esi+12444], ecx
$LN15@soap_in_Po@6:

; 3965 : 		if (!(*a = (_ns2__submitEpochResultElement *)soap_instantiate__ns2__submitEpochResultElement(soap, -1, soap->type, soap->arrayType, NULL)))

	push	0
	push	esi
	call	?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__submitEpochResultElement
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax

; 3966 : 			return NULL;

	je	SHORT $LN19@soap_in_Po@6

; 3967 : 		(*a)->soap_default(soap);

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	push	esi
	call	eax

; 3968 : 		if (!(*a)->soap_in(soap, tag, NULL))

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	push	0
	push	ebx
	push	esi
	call	eax
	test	eax, eax
	jne	SHORT $LN1@soap_in_Po@6
$LN19@soap_in_Po@6:

; 3969 : 			return NULL;

	xor	eax, eax

; 3978 : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ecx
	ret	0
$LN5@soap_in_Po@6:

; 3970 : 	}
; 3971 : 	else
; 3972 : 	{	_ns2__submitEpochResultElement ** p = (_ns2__submitEpochResultElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__submitEpochResultElement, sizeof(_ns2__submitEpochResultElement), 0);

	push	136					; 00000088H
	push	23					; 00000017H
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	mov	ecx, esi
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH

; 3973 : 		a = p;
; 3974 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in_Po@6
	push	ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 3975 : 			return NULL;

	jne	SHORT $LN19@soap_in_Po@6
$LN1@soap_in_Po@6:

; 3976 : 	}
; 3977 : 	return a;

	mov	eax, edi

; 3978 : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ecx
	ret	0
?soap_in_PointerTo_ns2__submitEpochResultElement@@YAPAPAV_ns2__submitEpochResultElement@@PAUsoap@@PBDPAPAV1@1@Z ENDP ; soap_in_PointerTo_ns2__submitEpochResultElement
_TEXT	ENDS
PUBLIC	?soap_put_PointerTo_ns2__submitEpochResultElement@@YAHPAUsoap@@PBQAV_ns2__submitEpochResultElement@@PBD2@Z ; soap_put_PointerTo_ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_PointerTo_ns2__submitEpochResultElement@@YAHPAUsoap@@PBQAV_ns2__submitEpochResultElement@@PBD2@Z PROC ; soap_put_PointerTo_ns2__submitEpochResultElement
; _soap$ = esi
; _a$ = edi

; 3933 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__submitEpochResultElement);

	push	esi
	mov	edx, 36					; 00000024H
	mov	eax, edi
	call	_soap_embed

; 3934 : 	if (soap_out_PointerTo_ns2__submitEpochResultElement(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	mov	edx, DWORD PTR _tag$[esp]
	push	ecx
	push	edi
	push	edx
	mov	ecx, esi
	call	?soap_out_PointerTo_ns2__submitEpochResultElement@@YAHPAUsoap@@PBDHPBQAV_ns2__submitEpochResultElement@@1@Z ; soap_out_PointerTo_ns2__submitEpochResultElement
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_P@6

; 3935 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 3937 : }

	ret	0
$LN1@soap_put_P@6:

; 3936 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 3937 : }

	ret	0
?soap_put_PointerTo_ns2__submitEpochResultElement@@YAHPAUsoap@@PBQAV_ns2__submitEpochResultElement@@PBD2@Z ENDP ; soap_put_PointerTo_ns2__submitEpochResultElement
_TEXT	ENDS
PUBLIC	?soap_put_PointerTo_ns2__submitEpochResultResponseElement@@YAHPAUsoap@@PBQAV_ns2__submitEpochResultResponseElement@@PBD2@Z ; soap_put_PointerTo_ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_PointerTo_ns2__submitEpochResultResponseElement@@YAHPAUsoap@@PBQAV_ns2__submitEpochResultResponseElement@@PBD2@Z PROC ; soap_put_PointerTo_ns2__submitEpochResultResponseElement
; _soap$ = esi
; _a$ = edi

; 3878 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__submitEpochResultResponseElement);

	push	esi
	mov	edx, 37					; 00000025H
	mov	eax, edi
	call	_soap_embed

; 3879 : 	if (soap_out_PointerTo_ns2__submitEpochResultResponseElement(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	mov	edx, DWORD PTR _tag$[esp]
	push	ecx
	push	edi
	push	edx
	mov	ecx, esi
	call	?soap_out_PointerTo_ns2__submitEpochResultResponseElement@@YAHPAUsoap@@PBDHPBQAV_ns2__submitEpochResultResponseElement@@1@Z ; soap_out_PointerTo_ns2__submitEpochResultResponseElement
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_P@7

; 3880 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 3882 : }

	ret	0
$LN1@soap_put_P@7:

; 3881 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 3882 : }

	ret	0
?soap_put_PointerTo_ns2__submitEpochResultResponseElement@@YAHPAUsoap@@PBQAV_ns2__submitEpochResultResponseElement@@PBD2@Z ENDP ; soap_put_PointerTo_ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_pp$603942 = 20						; size = 4
_a$ = 20						; size = 4
_type$ = 24						; size = 4
?soap_out_PointerToSOAP_ENV__Code@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Code@@1@Z PROC ; soap_out_PointerToSOAP_ENV__Code

; 3833 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);

	mov	eax, DWORD PTR _id$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _a$[esp+4]
	mov	ecx, DWORD PTR [ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+12]
	mov	esi, eax
	test	ecx, ecx
	je	$LN11@soap_out_P@8
	test	DWORD PTR [edi+8], 32768		; 00008000H
	je	SHORT $LN10@soap_out_P@8
$LN31@soap_out_P@8:
	xor	eax, eax
$LN1@soap_out_P@8:

; 3836 : 	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);

	mov	edx, DWORD PTR _type$[esp+12]
	mov	ecx, DWORD PTR [ebp]
	push	edx
	push	ecx
	push	eax
	mov	eax, DWORD PTR _tag$[esp+24]
	mov	ecx, edi
	call	?soap_out_SOAP_ENV__Code@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Code@@1@Z ; soap_out_SOAP_ENV__Code
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3837 : }

	ret	0

; 3833 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);

$LN10@soap_out_P@8:
	test	eax, eax
	jge	SHORT $LN6@soap_out_P@8
	lea	edx, DWORD PTR _pp$603942[esp+12]
	mov	esi, 41					; 00000029H
	call	_soap_pointer_lookup
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN6@soap_out_P@8
	mov	ebx, DWORD PTR _pp$603942[esp+12]
	mov	ecx, ebx
	mov	eax, edi
	call	_soap_is_embedded
	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN5@soap_out_P@8
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	mov	eax, esi
	call	_soap_element_ref

; 3835 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3837 : }

	ret	0

; 3833 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);

$LN5@soap_out_P@8:
	mov	eax, ebx
	call	_soap_is_single
	test	eax, eax
	jne	SHORT $LN31@soap_out_P@8
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_set_embedded
$LN6@soap_out_P@8:
	mov	eax, esi

; 3834 : 	if (id < 0)

	test	esi, esi
	jge	SHORT $LN1@soap_out_P@8

; 3835 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3837 : }

	ret	0

; 3833 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);

$LN11@soap_out_P@8:
	mov	ecx, DWORD PTR _type$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+16]
	push	edi
	call	_soap_element_null

; 3835 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3837 : }

	ret	0
?soap_out_PointerToSOAP_ENV__Code@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Code@@1@Z ENDP ; soap_out_PointerToSOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_put_PointerToSOAP_ENV__Code@@YAHPAUsoap@@PBQAUSOAP_ENV__Code@@PBD2@Z ; soap_put_PointerToSOAP_ENV__Code
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_PointerToSOAP_ENV__Code@@YAHPAUsoap@@PBQAUSOAP_ENV__Code@@PBD2@Z PROC ; soap_put_PointerToSOAP_ENV__Code
; _soap$ = esi
; _a$ = edi

; 3825 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);

	push	esi
	mov	edx, 42					; 0000002aH
	mov	eax, edi
	call	_soap_embed

; 3826 : 	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	mov	edx, DWORD PTR _tag$[esp]
	push	ecx
	push	edi
	push	eax
	push	edx
	push	esi
	call	?soap_out_PointerToSOAP_ENV__Code@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Code@@1@Z ; soap_out_PointerToSOAP_ENV__Code
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN1@soap_put_P@8

; 3827 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 3829 : }

	ret	0
$LN1@soap_put_P@8:

; 3828 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 3829 : }

	ret	0
?soap_put_PointerToSOAP_ENV__Code@@YAHPAUsoap@@PBQAUSOAP_ENV__Code@@PBD2@Z ENDP ; soap_put_PointerToSOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_out_PointerToSOAP_ENV__Reason@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Reason@@1@Z ; soap_out_PointerToSOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_pp$603994 = 12						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_PointerToSOAP_ENV__Reason@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Reason@@1@Z PROC ; soap_out_PointerToSOAP_ENV__Reason
; _soap$ = ecx
; _id$ = eax

; 3722 : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _a$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx

; 3723 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);

	mov	ecx, DWORD PTR [ebp]
	mov	esi, eax
	test	ecx, ecx
	je	$LN11@soap_out_P@9
	test	DWORD PTR [edi+8], 32768		; 00008000H
	je	SHORT $LN10@soap_out_P@9
$LN31@soap_out_P@9:
	xor	eax, eax
$LN1@soap_out_P@9:

; 3726 : 	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);

	mov	edx, DWORD PTR _type$[esp+12]
	mov	ecx, DWORD PTR [ebp]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+20]
	push	edi
	call	?soap_out_SOAP_ENV__Reason@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Reason@@1@Z ; soap_out_SOAP_ENV__Reason
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3727 : }

	ret	0

; 3723 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);

$LN10@soap_out_P@9:
	test	eax, eax
	jge	SHORT $LN6@soap_out_P@9
	lea	edx, DWORD PTR _pp$603994[esp+12]
	mov	esi, 46					; 0000002eH
	call	_soap_pointer_lookup
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN6@soap_out_P@9
	mov	ebx, DWORD PTR _pp$603994[esp+12]
	mov	ecx, ebx
	mov	eax, edi
	call	_soap_is_embedded
	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN5@soap_out_P@9
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	mov	eax, esi
	call	_soap_element_ref

; 3725 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3727 : }

	ret	0

; 3723 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);

$LN5@soap_out_P@9:
	mov	eax, ebx
	call	_soap_is_single
	test	eax, eax
	jne	SHORT $LN31@soap_out_P@9
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_set_embedded
$LN6@soap_out_P@9:
	mov	eax, esi

; 3724 : 	if (id < 0)

	test	esi, esi
	jge	SHORT $LN1@soap_out_P@9

; 3725 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3727 : }

	ret	0

; 3723 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);

$LN11@soap_out_P@9:
	mov	ecx, DWORD PTR _type$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+16]
	push	edi
	call	_soap_element_null

; 3725 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3727 : }

	ret	0
?soap_out_PointerToSOAP_ENV__Reason@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Reason@@1@Z ENDP ; soap_out_PointerToSOAP_ENV__Reason
_TEXT	ENDS
PUBLIC	?soap_put_PointerToSOAP_ENV__Reason@@YAHPAUsoap@@PBQAUSOAP_ENV__Reason@@PBD2@Z ; soap_put_PointerToSOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_PointerToSOAP_ENV__Reason@@YAHPAUsoap@@PBQAUSOAP_ENV__Reason@@PBD2@Z PROC ; soap_put_PointerToSOAP_ENV__Reason
; _soap$ = esi
; _a$ = edi

; 3715 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);

	push	esi
	mov	edx, 49					; 00000031H
	mov	eax, edi
	call	_soap_embed

; 3716 : 	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	mov	edx, DWORD PTR _tag$[esp]
	push	ecx
	push	edi
	push	edx
	mov	ecx, esi
	call	?soap_out_PointerToSOAP_ENV__Reason@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Reason@@1@Z ; soap_out_PointerToSOAP_ENV__Reason
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_P@9

; 3717 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 3719 : }

	ret	0
$LN1@soap_put_P@9:

; 3718 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 3719 : }

	ret	0
?soap_put_PointerToSOAP_ENV__Reason@@YAHPAUsoap@@PBQAUSOAP_ENV__Reason@@PBD2@Z ENDP ; soap_put_PointerToSOAP_ENV__Reason
_TEXT	ENDS
PUBLIC	?soap_in___ns1__submitEpochResult@@YAPAU__ns1__submitEpochResult@@PAUsoap@@PBDPAU1@1@Z ; soap_in___ns1__submitEpochResult
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_flag$ = -4					; size = 2
?soap_in___ns1__submitEpochResult@@YAPAU__ns1__submitEpochResult@@PAUsoap@@PBDPAU1@1@Z PROC ; soap_in___ns1__submitEpochResult
; _soap$ = esi
; _a$ = eax

; 3441 : {

	push	ecx
	push	ebx
	push	ebp

; 3442 : 	size_t soap_flag_ns2__submitEpochResultElement = 1;
; 3443 : 	short soap_flag;
; 3444 : 	a = (struct __ns1__submitEpochResult *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__submitEpochResult, sizeof(struct __ns1__submitEpochResult), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	4
	push	39					; 00000027H
	push	eax
	push	esi
	xor	eax, eax
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ebp, 1
	call	_soap_id_enter
	mov	ebx, eax
	add	esp, 24					; 00000018H

; 3445 : 	if (!a)

	test	ebx, ebx
	jne	SHORT $LN10@soap_in___@3
	pop	ebp
	pop	ebx

; 3466 : }

	pop	ecx
	ret	0
$LN10@soap_in___@3:

; 3446 : 		return NULL;
; 3447 : 	soap_default___ns1__submitEpochResult(soap, a);

	mov	DWORD PTR [ebx], 0

; 3448 : 		for (soap_flag = 0;; soap_flag = 1)

	mov	DWORD PTR _soap_flag$[esp+12], 0
	push	edi
	npad	6
$LL9@soap_in___@3:

; 3449 : 		{	soap->error = SOAP_TAG_MISMATCH;

	mov	edi, 3
	mov	DWORD PTR [esi+90460], edi

; 3450 : 			if (soap_flag_ns2__submitEpochResultElement && soap->error == SOAP_TAG_MISMATCH)

	test	ebp, ebp
	je	$LN46@soap_in___@3

; 3451 : 				if (soap_in_PointerTo_ns2__submitEpochResultElement(soap, "ns2:submitEpochResultElement", &a->ns2__submitEpochResultElement, ""))

	mov	eax, esi
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN47@soap_in___@3
	cmp	WORD PTR [esi+87220], ax
	je	SHORT $LN35@soap_in___@3
	mov	DWORD PTR [esi+90460], edi
	jmp	SHORT $LN46@soap_in___@3
$LN35@soap_in___@3:
	lea	ecx, DWORD PTR [esi+80052]
	push	ecx
	push	esi
	mov	edi, OFFSET ??_C@_0BN@LEHNEPKC@ns2?3submitEpochResultElement?$AA@
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	jne	SHORT $LN47@soap_in___@3
	xor	edx, edx
	mov	WORD PTR [esi+87308], dx
	cmp	WORD PTR [esi+12442], dx
	je	SHORT $LN47@soap_in___@3
	inc	DWORD PTR [esi+12444]
$LN47@soap_in___@3:
	cmp	DWORD PTR [esi+90460], 0
	jne	SHORT $LN5@soap_in___@3
	push	OFFSET ??_C@_0BN@LEHNEPKC@ns2?3submitEpochResultElement?$AA@
	mov	eax, ebx
	mov	ecx, esi
	call	?soap_in_PointerTo_ns2__submitEpochResultElement@@YAPAPAV_ns2__submitEpochResultElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__submitEpochResultElement
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@soap_in___@3

; 3452 : 				{	soap_flag_ns2__submitEpochResultElement--;

	dec	ebp
	mov	DWORD PTR _soap_flag$[esp+16], 1
	jmp	$LL9@soap_in___@3
$LN5@soap_in___@3:

; 3453 : 					continue;
; 3454 : 				}
; 3455 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], 3
	jne	SHORT $LN48@soap_in___@3
$LN46@soap_in___@3:

; 3456 : 				if (soap_flag)

	cmp	WORD PTR _soap_flag$[esp+16], 0
	jne	SHORT $LN42@soap_in___@3
$LN48@soap_in___@3:

; 3458 : 					break;
; 3459 : 				}
; 3460 : 			if (soap->error == SOAP_NO_TAG)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 6
	je	SHORT $LN43@soap_in___@3

; 3461 : 				break;
; 3462 : 			if (soap->error)

	test	eax, eax
	jne	SHORT $LN44@soap_in___@3

; 3448 : 		for (soap_flag = 0;; soap_flag = 1)

	mov	DWORD PTR _soap_flag$[esp+16], 1
	jmp	$LL9@soap_in___@3
$LN42@soap_in___@3:

; 3457 : 				{	soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0
$LN43@soap_in___@3:
	pop	edi
	pop	ebp

; 3464 : 		}
; 3465 : 	return a;

	mov	eax, ebx
	pop	ebx

; 3466 : }

	pop	ecx
	ret	0
$LN44@soap_in___@3:
	pop	edi
	pop	ebp

; 3463 : 				return NULL;

	xor	eax, eax
	pop	ebx

; 3466 : }

	pop	ecx
	ret	0
?soap_in___ns1__submitEpochResult@@YAPAU__ns1__submitEpochResult@@PAUsoap@@PBDPAU1@1@Z ENDP ; soap_in___ns1__submitEpochResult
_TEXT	ENDS
PUBLIC	?soap_in_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Header
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
?soap_in_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@PBDPAU1@1@Z PROC ; soap_in_SOAP_ENV__Header
; _soap$ = ecx
; _a$ = eax

; 3337 : {

	push	ebp
	mov	ebp, DWORD PTR _tag$[esp]
	push	esi
	push	edi

; 3338 : 	if (soap_element_begin_in(soap, tag, 0, type))
; 3339 : 		return NULL;
; 3340 : 	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);

	push	0
	push	0
	push	1
	push	40					; 00000028H
	mov	esi, ecx
	push	eax
	lea	ecx, DWORD PTR [esi+81076]
	push	esi
	xor	eax, eax
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H

; 3341 : 	if (!a)

	test	edi, edi

; 3342 : 		return NULL;

	je	SHORT $LN22@soap_in_SO

; 3343 : 	soap_default_SOAP_ENV__Header(soap, a);
; 3344 : 	if (soap->body && !*soap->href)

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN9@soap_in_SO
	cmp	BYTE PTR [esi+82100], 0
	jne	SHORT $LN9@soap_in_SO
	npad	4
$LL8@soap_in_SO:

; 3345 : 	{
; 3346 : 		for (;;)
; 3347 : 		{	soap->error = SOAP_TAG_MISMATCH;
; 3348 : 			if (soap->error == SOAP_TAG_MISMATCH)
; 3349 : 				soap->error = soap_ignore_element(soap);

	push	esi
	mov	DWORD PTR [esi+90460], 3
	call	?soap_ignore_element@@YAHPAUsoap@@@Z	; soap_ignore_element
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax

; 3350 : 			if (soap->error == SOAP_NO_TAG)

	cmp	eax, 6
	je	SHORT $LN21@soap_in_SO

; 3351 : 				break;
; 3352 : 			if (soap->error)

	test	eax, eax
	je	SHORT $LL8@soap_in_SO
	pop	edi
	pop	esi

; 3356 : 			return NULL;

	xor	eax, eax
	pop	ebp

; 3364 : }

	ret	0
$LN21@soap_in_SO:

; 3353 : 				return NULL;
; 3354 : 		}
; 3355 : 		if (soap_element_end_in(soap, tag))

	push	ebp
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_in_SO
$LN22@soap_in_SO:
	pop	edi
	pop	esi

; 3356 : 			return NULL;

	xor	eax, eax
	pop	ebp

; 3364 : }

	ret	0
$LN9@soap_in_SO:

; 3357 : 	}
; 3358 : 	else
; 3359 : 	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);

	push	0
	push	1
	push	0
	push	40					; 00000028H
	push	0
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH

; 3360 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax

; 3361 : 			return NULL;

	jne	SHORT $LN21@soap_in_SO
$LN1@soap_in_SO:

; 3362 : 	}
; 3363 : 	return a;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp

; 3364 : }

	ret	0
?soap_in_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@PBDPAU1@1@Z ENDP ; soap_in_SOAP_ENV__Header
_TEXT	ENDS
PUBLIC	?soap_put_SOAP_ENV__Header@@YAHPAUsoap@@PBUSOAP_ENV__Header@@PBD2@Z ; soap_put_SOAP_ENV__Header
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_SOAP_ENV__Header@@YAHPAUsoap@@PBUSOAP_ENV__Header@@PBD2@Z PROC ; soap_put_SOAP_ENV__Header
; _soap$ = esi
; _a$ = edi

; 3315 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);

	push	esi
	mov	edx, 40					; 00000028H
	mov	eax, edi
	call	_soap_embed

; 3316 : 	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	mov	edx, DWORD PTR _tag$[esp]
	push	ecx
	push	edx
	push	esi
	mov	ecx, edi
	call	?soap_out_SOAP_ENV__Header@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Header@@1@Z ; soap_out_SOAP_ENV__Header
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_S

; 3317 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 3319 : }

	ret	0
$LN1@soap_put_S:

; 3318 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 3319 : }

	ret	0
?soap_put_SOAP_ENV__Header@@YAHPAUsoap@@PBUSOAP_ENV__Header@@PBD2@Z ENDP ; soap_put_SOAP_ENV__Header
_TEXT	ENDS
PUBLIC	?soap_in_PointerToSOAP_ENV__Code@@YAPAPAUSOAP_ENV__Code@@PAUsoap@@PBDPAPAU1@1@Z ; soap_in_PointerToSOAP_ENV__Code
PUBLIC	?soap_in_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Code
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_flag_SOAP_ENV__Subcode$ = -4			; size = 4
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
?soap_in_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@PBDPAU1@1@Z PROC ; soap_in_SOAP_ENV__Code
; _soap$ = ecx
; _type$ = eax

; 3221 : {

	push	ecx
	push	ebx
	push	ebp

; 3222 : 	size_t soap_flag_SOAP_ENV__Value = 1;
; 3223 : 	size_t soap_flag_SOAP_ENV__Subcode = 1;
; 3224 : 	if (soap_element_begin_in(soap, tag, 0, type))

	mov	ebp, DWORD PTR _tag$[esp+8]
	push	esi
	push	eax
	mov	ebx, 1
	mov	esi, ecx
	push	0
	mov	eax, ebp
	mov	DWORD PTR _soap_flag_SOAP_ENV__Subcode$[esp+24], ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@soap_in_SO@2
	pop	esi
	pop	ebp

; 3225 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 3260 : }

	pop	ecx
	ret	0
$LN16@soap_in_SO@2:

; 3226 : 	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);

	mov	ecx, DWORD PTR _a$[esp+12]
	push	edi
	push	0
	push	0
	push	8
	push	41					; 00000029H
	push	ecx
	lea	ecx, DWORD PTR [esi+81076]
	push	esi
	xor	eax, eax
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H

; 3227 : 	if (!a)

	test	edi, edi

; 3228 : 		return NULL;

	je	$LN51@soap_in_SO@2

; 3229 : 	soap_default_SOAP_ENV__Code(soap, a);

	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], 0

; 3230 : 	if (soap->body && !*soap->href)

	cmp	WORD PTR [esi+12442], 0
	je	$LN14@soap_in_SO@2
	cmp	BYTE PTR [esi+82100], 0
	jne	$LN14@soap_in_SO@2
	mov	ebp, 3
$LL13@soap_in_SO@2:

; 3231 : 	{
; 3232 : 		for (;;)
; 3233 : 		{	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], ebp

; 3234 : 			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))

	test	ebx, ebx
	je	SHORT $LN52@soap_in_SO@2

; 3235 : 				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))

	push	2
	push	5
	push	OFFSET ??_C@_0P@FNBDNHP@SOAP?9ENV?3Value?$AA@
	mov	eax, edi
	mov	ecx, esi
	call	_soap_instring
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN52@soap_in_SO@2

; 3236 : 				{	soap_flag_SOAP_ENV__Value--;

	dec	ebx

; 3237 : 					continue;

	jmp	SHORT $LL13@soap_in_SO@2
$LN52@soap_in_SO@2:

; 3238 : 				}
; 3239 : 			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR _soap_flag_SOAP_ENV__Subcode$[esp+20], 0
	je	SHORT $LN53@soap_in_SO@2
	cmp	DWORD PTR [esi+90460], ebp
	jne	SHORT $LN6@soap_in_SO@2

; 3240 : 				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	eax, DWORD PTR [edi+4]
	push	eax
	push	OFFSET ??_C@_0BB@MGPNIFGI@SOAP?9ENV?3Subcode?$AA@
	push	esi
	call	?soap_in_PointerToSOAP_ENV__Code@@YAPAPAUSOAP_ENV__Code@@PAUsoap@@PBDPAPAU1@1@Z ; soap_in_PointerToSOAP_ENV__Code
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN53@soap_in_SO@2

; 3241 : 				{	soap_flag_SOAP_ENV__Subcode--;

	dec	DWORD PTR _soap_flag_SOAP_ENV__Subcode$[esp+20]

; 3242 : 					continue;

	jmp	SHORT $LL13@soap_in_SO@2
$LN53@soap_in_SO@2:

; 3243 : 				}
; 3244 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], ebp
	jne	SHORT $LN6@soap_in_SO@2

; 3245 : 				soap->error = soap_ignore_element(soap);

	push	esi
	call	?soap_ignore_element@@YAHPAUsoap@@@Z	; soap_ignore_element
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
$LN6@soap_in_SO@2:

; 3246 : 			if (soap->error == SOAP_NO_TAG)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 6
	je	SHORT $LN50@soap_in_SO@2

; 3247 : 				break;
; 3248 : 			if (soap->error)

	test	eax, eax
	je	SHORT $LL13@soap_in_SO@2
	pop	edi
	pop	esi
	pop	ebp

; 3257 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 3260 : }

	pop	ecx
	ret	0
$LN50@soap_in_SO@2:

; 3249 : 				return NULL;
; 3250 : 		}
; 3251 : 		if (soap_element_end_in(soap, tag))

	mov	edx, DWORD PTR _tag$[esp+16]
	push	edx

; 3252 : 			return NULL;

	jmp	SHORT $LN55@soap_in_SO@2
$LN14@soap_in_SO@2:

; 3253 : 	}
; 3254 : 	else
; 3255 : 	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);

	push	0
	push	8
	push	0
	push	41					; 00000029H
	push	0
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH

; 3256 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in_SO@2
	push	ebp
$LN55@soap_in_SO@2:
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_in_SO@2
$LN51@soap_in_SO@2:
	pop	edi
	pop	esi
	pop	ebp

; 3257 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 3260 : }

	pop	ecx
	ret	0
$LN1@soap_in_SO@2:

; 3258 : 	}
; 3259 : 	return a;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3260 : }

	pop	ecx
	ret	0
?soap_in_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@PBDPAU1@1@Z ENDP ; soap_in_SOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_put_SOAP_ENV__Code@@YAHPAUsoap@@PBUSOAP_ENV__Code@@PBD2@Z ; soap_put_SOAP_ENV__Code
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_SOAP_ENV__Code@@YAHPAUsoap@@PBUSOAP_ENV__Code@@PBD2@Z PROC ; soap_put_SOAP_ENV__Code
; _soap$ = esi
; _a$ = edi

; 3194 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);

	push	esi
	mov	edx, 41					; 00000029H
	mov	eax, edi
	call	_soap_embed

; 3195 : 	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	push	ecx
	push	edi
	push	eax
	mov	eax, DWORD PTR _tag$[esp+12]
	mov	ecx, esi
	call	?soap_out_SOAP_ENV__Code@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Code@@1@Z ; soap_out_SOAP_ENV__Code
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_S@2

; 3196 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 3198 : }

	ret	0
$LN1@soap_put_S@2:

; 3197 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 3198 : }

	ret	0
?soap_put_SOAP_ENV__Code@@YAHPAUsoap@@PBUSOAP_ENV__Code@@PBD2@Z ENDP ; soap_put_SOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_out_SOAP_ENV__Detail@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Detail@@1@Z ; soap_out_SOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_SOAP_ENV__Detail@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Detail@@1@Z PROC ; soap_out_SOAP_ENV__Detail
; _tag$ = ecx
; _id$ = eax

; 3078 : {

	push	ebx
	mov	ebx, DWORD PTR _a$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 3079 : 	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))

	push	eax
	mov	esi, ecx
	push	edi
	mov	eax, 43					; 0000002bH
	mov	ecx, ebx
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN2@soap_out_S@4
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_out_S@4
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_out_S@4
$LN5@soap_out_S@4:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_out_S@4:
	test	eax, eax
	je	SHORT $LN2@soap_out_S@4
$LN9@soap_out_S@4:

; 3080 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 3085 : }

	ret	0
$LN2@soap_out_S@4:

; 3081 : 	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx+4]
	push	edx
	push	OFFSET ??_C@_05GCLNDCPO@fault?$AA@
	push	eax
	or	eax, -1
	mov	ecx, edi
	call	_soap_putelement
	add	esp, 12					; 0000000cH
	test	eax, eax

; 3082 : 		return soap->error;

	jne	SHORT $LN9@soap_out_S@4

; 3083 : 	soap_outliteral(soap, "-any", &a->__any, NULL);

	add	ebx, 8
	push	ebx
	push	OFFSET ??_C@_04DPKCFHKE@?9any?$AA@
	mov	eax, edi
	call	_soap_outliteral
	add	esp, 8

; 3084 : 	return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebx

; 3085 : }

	ret	0
?soap_out_SOAP_ENV__Detail@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Detail@@1@Z ENDP ; soap_out_SOAP_ENV__Detail
_TEXT	ENDS
PUBLIC	?soap_put_SOAP_ENV__Detail@@YAHPAUsoap@@PBUSOAP_ENV__Detail@@PBD2@Z ; soap_put_SOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_SOAP_ENV__Detail@@YAHPAUsoap@@PBUSOAP_ENV__Detail@@PBD2@Z PROC ; soap_put_SOAP_ENV__Detail
; _soap$ = esi
; _a$ = edi

; 3071 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);

	push	esi
	mov	edx, 43					; 0000002bH
	mov	eax, edi
	call	_soap_embed

; 3072 : 	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	edi
	push	esi
	call	?soap_out_SOAP_ENV__Detail@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Detail@@1@Z ; soap_out_SOAP_ENV__Detail
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_S@3

; 3073 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 3075 : }

	ret	0
$LN1@soap_put_S@3:

; 3074 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 3075 : }

	ret	0
?soap_put_SOAP_ENV__Detail@@YAHPAUsoap@@PBUSOAP_ENV__Detail@@PBD2@Z ENDP ; soap_put_SOAP_ENV__Detail
_TEXT	ENDS
PUBLIC	?soap_in_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
?soap_in_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@PBDPAU1@1@Z PROC ; soap_in_SOAP_ENV__Reason
; _soap$ = ecx
; _type$ = eax

; 2979 : {

	push	ebx
	push	ebp

; 2980 : 	size_t soap_flag_SOAP_ENV__Text = 1;
; 2981 : 	if (soap_element_begin_in(soap, tag, 0, type))

	mov	ebp, DWORD PTR _tag$[esp+4]
	push	esi
	push	eax
	mov	esi, ecx
	push	0
	mov	eax, ebp
	mov	ebx, 1
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@soap_in_SO@3
	pop	esi
	pop	ebp

; 2982 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 3012 : }

	ret	0
$LN14@soap_in_SO@3:

; 2983 : 	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);

	mov	ecx, DWORD PTR _a$[esp+8]
	push	edi
	push	0
	push	0
	push	4
	push	46					; 0000002eH
	push	ecx
	lea	ecx, DWORD PTR [esi+81076]
	push	esi
	xor	eax, eax
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H

; 2984 : 	if (!a)

	test	edi, edi

; 2985 : 		return NULL;

	je	$LN26@soap_in_SO@3

; 2986 : 	soap_default_SOAP_ENV__Reason(soap, a);

	mov	DWORD PTR [edi], 0

; 2987 : 	if (soap->body && !*soap->href)

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN12@soap_in_SO@3
	cmp	BYTE PTR [esi+82100], 0
	jne	SHORT $LN12@soap_in_SO@3
	mov	ebp, 3
	npad	4
$LL11@soap_in_SO@3:

; 2988 : 	{
; 2989 : 		for (;;)
; 2990 : 		{	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], ebp

; 2991 : 			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))

	test	ebx, ebx
	je	SHORT $LN27@soap_in_SO@3

; 2992 : 				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))

	push	1
	push	4
	push	OFFSET ??_C@_0O@BLCEAHMK@SOAP?9ENV?3Text?$AA@
	mov	eax, edi
	mov	ecx, esi
	call	_soap_instring
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@soap_in_SO@3

; 2993 : 				{	soap_flag_SOAP_ENV__Text--;

	dec	ebx

; 2994 : 					continue;

	jmp	SHORT $LL11@soap_in_SO@3
$LN7@soap_in_SO@3:

; 2995 : 				}
; 2996 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], ebp
	jne	SHORT $LN6@soap_in_SO@3
$LN27@soap_in_SO@3:

; 2997 : 				soap->error = soap_ignore_element(soap);

	push	esi
	call	?soap_ignore_element@@YAHPAUsoap@@@Z	; soap_ignore_element
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
$LN6@soap_in_SO@3:

; 2998 : 			if (soap->error == SOAP_NO_TAG)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 6
	je	SHORT $LN25@soap_in_SO@3

; 2999 : 				break;
; 3000 : 			if (soap->error)

	test	eax, eax
	je	SHORT $LL11@soap_in_SO@3
	pop	edi
	pop	esi
	pop	ebp

; 3009 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 3012 : }

	ret	0
$LN25@soap_in_SO@3:

; 3001 : 				return NULL;
; 3002 : 		}
; 3003 : 		if (soap_element_end_in(soap, tag))

	mov	edx, DWORD PTR _tag$[esp+12]
	push	edx

; 3004 : 			return NULL;

	jmp	SHORT $LN29@soap_in_SO@3
$LN12@soap_in_SO@3:

; 3005 : 	}
; 3006 : 	else
; 3007 : 	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);

	push	0
	push	4
	push	0
	push	46					; 0000002eH
	push	0
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH

; 3008 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in_SO@3
	push	ebp
$LN29@soap_in_SO@3:
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_in_SO@3
$LN26@soap_in_SO@3:
	pop	edi
	pop	esi
	pop	ebp

; 3009 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 3012 : }

	ret	0
$LN1@soap_in_SO@3:

; 3010 : 	}
; 3011 : 	return a;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3012 : }

	ret	0
?soap_in_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@PBDPAU1@1@Z ENDP ; soap_in_SOAP_ENV__Reason
_TEXT	ENDS
PUBLIC	?soap_put_SOAP_ENV__Reason@@YAHPAUsoap@@PBUSOAP_ENV__Reason@@PBD2@Z ; soap_put_SOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_SOAP_ENV__Reason@@YAHPAUsoap@@PBUSOAP_ENV__Reason@@PBD2@Z PROC ; soap_put_SOAP_ENV__Reason
; _soap$ = esi
; _a$ = edi

; 2952 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);

	push	esi
	mov	edx, 46					; 0000002eH
	mov	eax, edi
	call	_soap_embed

; 2953 : 	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	edi
	push	esi
	call	?soap_out_SOAP_ENV__Reason@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Reason@@1@Z ; soap_out_SOAP_ENV__Reason
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_S@4

; 2954 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 2956 : }

	ret	0
$LN1@soap_put_S@4:

; 2955 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 2956 : }

	ret	0
?soap_put_SOAP_ENV__Reason@@YAHPAUsoap@@PBUSOAP_ENV__Reason@@PBD2@Z ENDP ; soap_put_SOAP_ENV__Reason
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_put@xsd__anyType@@UBEHPAUsoap@@PBD1@Z PROC	; xsd__anyType::soap_put
; _this$ = ecx

; 2537 : {

	push	esi
	push	edi

; 2538 : 	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);

	mov	edi, DWORD PTR _soap$[esp+4]
	mov	esi, ecx
	push	edi
	mov	edx, 8
	mov	eax, esi
	call	_soap_embed

; 2539 : 	if (this->soap_out(soap, tag, id, type))

	mov	ecx, DWORD PTR _type$[esp+8]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	add	esp, 4
	push	ecx
	push	eax
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	push	edi
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN1@soap_put

; 2540 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 2542 : }

	ret	12					; 0000000cH
$LN1@soap_put:

; 2541 : 	return soap_putindependent(soap);

	push	edi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4
	pop	edi
	pop	esi

; 2542 : }

	ret	12					; 0000000cH
?soap_put@xsd__anyType@@UBEHPAUsoap@@PBD1@Z ENDP	; xsd__anyType::soap_put
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_put@xsd__boolean@@UBEHPAUsoap@@PBD1@Z PROC	; xsd__boolean::soap_put
; _this$ = ecx

; 2429 : {

	push	esi
	push	edi

; 2430 : 	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__boolean);

	mov	edi, DWORD PTR _soap$[esp+4]
	mov	esi, ecx
	push	edi
	mov	edx, 10					; 0000000aH
	mov	eax, esi
	call	_soap_embed

; 2431 : 	if (this->soap_out(soap, tag, id, type))

	mov	ecx, DWORD PTR _type$[esp+8]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	add	esp, 4
	push	ecx
	push	eax
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	push	edi
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN1@soap_put@2

; 2432 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 2434 : }

	ret	12					; 0000000cH
$LN1@soap_put@2:

; 2433 : 	return soap_putindependent(soap);

	push	edi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4
	pop	edi
	pop	esi

; 2434 : }

	ret	12					; 0000000cH
?soap_put@xsd__boolean@@UBEHPAUsoap@@PBD1@Z ENDP	; xsd__boolean::soap_put
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_put@xsd__float@@UBEHPAUsoap@@PBD1@Z PROC		; xsd__float::soap_put
; _this$ = ecx

; 2320 : {

	push	esi
	push	edi

; 2321 : 	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__float);

	mov	edi, DWORD PTR _soap$[esp+4]
	mov	esi, ecx
	push	edi
	mov	edx, 12					; 0000000cH
	mov	eax, esi
	call	_soap_embed

; 2322 : 	if (this->soap_out(soap, tag, id, type))

	mov	ecx, DWORD PTR _type$[esp+8]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	add	esp, 4
	push	ecx
	push	eax
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	push	edi
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN1@soap_put@3

; 2323 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 2325 : }

	ret	12					; 0000000cH
$LN1@soap_put@3:

; 2324 : 	return soap_putindependent(soap);

	push	edi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4
	pop	edi
	pop	esi

; 2325 : }

	ret	12					; 0000000cH
?soap_put@xsd__float@@UBEHPAUsoap@@PBD1@Z ENDP		; xsd__float::soap_put
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_put@xsd__int@@UBEHPAUsoap@@PBD1@Z PROC		; xsd__int::soap_put
; _this$ = ecx

; 2211 : {

	push	esi
	push	edi

; 2212 : 	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__int);

	mov	edi, DWORD PTR _soap$[esp+4]
	mov	esi, ecx
	push	edi
	mov	edx, 14					; 0000000eH
	mov	eax, esi
	call	_soap_embed

; 2213 : 	if (this->soap_out(soap, tag, id, type))

	mov	ecx, DWORD PTR _type$[esp+8]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	add	esp, 4
	push	ecx
	push	eax
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	push	edi
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN1@soap_put@4

; 2214 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 2216 : }

	ret	12					; 0000000cH
$LN1@soap_put@4:

; 2215 : 	return soap_putindependent(soap);

	push	edi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4
	pop	edi
	pop	esi

; 2216 : }

	ret	12					; 0000000cH
?soap_put@xsd__int@@UBEHPAUsoap@@PBD1@Z ENDP		; xsd__int::soap_put
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_put@xsd__long@@UBEHPAUsoap@@PBD1@Z PROC		; xsd__long::soap_put
; _this$ = ecx

; 2102 : {

	push	esi
	push	edi

; 2103 : 	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__long);

	mov	edi, DWORD PTR _soap$[esp+4]
	mov	esi, ecx
	push	edi
	mov	edx, 15					; 0000000fH
	mov	eax, esi
	call	_soap_embed

; 2104 : 	if (this->soap_out(soap, tag, id, type))

	mov	ecx, DWORD PTR _type$[esp+8]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	add	esp, 4
	push	ecx
	push	eax
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	push	edi
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN1@soap_put@5

; 2105 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 2107 : }

	ret	12					; 0000000cH
$LN1@soap_put@5:

; 2106 : 	return soap_putindependent(soap);

	push	edi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4
	pop	edi
	pop	esi

; 2107 : }

	ret	12					; 0000000cH
?soap_put@xsd__long@@UBEHPAUsoap@@PBD1@Z ENDP		; xsd__long::soap_put
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_put@xsd__string@@UBEHPAUsoap@@PBD1@Z PROC		; xsd__string::soap_put
; _this$ = ecx

; 1993 : {

	push	esi
	push	edi

; 1994 : 	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__string);

	mov	edi, DWORD PTR _soap$[esp+4]
	mov	esi, ecx
	push	edi
	mov	edx, 17					; 00000011H
	mov	eax, esi
	call	_soap_embed

; 1995 : 	if (this->soap_out(soap, tag, id, type))

	mov	ecx, DWORD PTR _type$[esp+8]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	add	esp, 4
	push	ecx
	push	eax
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	push	edi
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN1@soap_put@6

; 1996 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 1998 : }

	ret	12					; 0000000cH
$LN1@soap_put@6:

; 1997 : 	return soap_putindependent(soap);

	push	edi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4
	pop	edi
	pop	esi

; 1998 : }

	ret	12					; 0000000cH
?soap_put@xsd__string@@UBEHPAUsoap@@PBD1@Z ENDP		; xsd__string::soap_put
_TEXT	ENDS
PUBLIC	?soap_put_std__string@@YAHPAUsoap@@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD2@Z ; soap_put_std__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_std__string@@YAHPAUsoap@@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD2@Z PROC ; soap_put_std__string
; _soap$ = esi
; _a$ = edi

; 1889 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);

	push	esi
	mov	edx, 18					; 00000012H
	mov	eax, edi
	call	_soap_embed

; 1890 : 	if (soap_out_std__string(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	edi
	push	esi
	call	?soap_out_std__string@@YAHPAUsoap@@PBDHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; soap_out_std__string
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_s@2

; 1891 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 1893 : }

	ret	0
$LN1@soap_put_s@2:

; 1892 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 1893 : }

	ret	0
?soap_put_std__string@@YAHPAUsoap@@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD2@Z ENDP ; soap_put_std__string
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_put@_ns2__getSessionIDElement@@UBEHPAUsoap@@PBD1@Z PROC ; _ns2__getSessionIDElement::soap_put
; _this$ = ecx

; 1755 : {

	push	esi
	push	edi

; 1756 : 	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getSessionIDElement);

	mov	edi, DWORD PTR _soap$[esp+4]
	mov	esi, ecx
	push	edi
	mov	edx, 19					; 00000013H
	mov	eax, esi
	call	_soap_embed

; 1757 : 	if (this->soap_out(soap, tag, id, type))

	mov	ecx, DWORD PTR _type$[esp+8]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	add	esp, 4
	push	ecx
	push	eax
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	push	edi
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN1@soap_put@7

; 1758 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 1760 : }

	ret	12					; 0000000cH
$LN1@soap_put@7:

; 1759 : 	return soap_putindependent(soap);

	push	edi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4
	pop	edi
	pop	esi

; 1760 : }

	ret	12					; 0000000cH
?soap_put@_ns2__getSessionIDElement@@UBEHPAUsoap@@PBD1@Z ENDP ; _ns2__getSessionIDElement::soap_put
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_put@_ns2__getSessionIDResponseElement@@UBEHPAUsoap@@PBD1@Z PROC ; _ns2__getSessionIDResponseElement::soap_put
; _this$ = ecx

; 1611 : {

	push	esi
	push	edi

; 1612 : 	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getSessionIDResponseElement);

	mov	edi, DWORD PTR _soap$[esp+4]
	mov	esi, ecx
	push	edi
	mov	edx, 20					; 00000014H
	mov	eax, esi
	call	_soap_embed

; 1613 : 	if (this->soap_out(soap, tag, id, type))

	mov	ecx, DWORD PTR _type$[esp+8]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	add	esp, 4
	push	ecx
	push	eax
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	push	edi
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN1@soap_put@8

; 1614 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 1616 : }

	ret	12					; 0000000cH
$LN1@soap_put@8:

; 1615 : 	return soap_putindependent(soap);

	push	edi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4
	pop	edi
	pop	esi

; 1616 : }

	ret	12					; 0000000cH
?soap_put@_ns2__getSessionIDResponseElement@@UBEHPAUsoap@@PBD1@Z ENDP ; _ns2__getSessionIDResponseElement::soap_put
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_put@_ns2__getSettingsFileElement@@UBEHPAUsoap@@PBD1@Z PROC ; _ns2__getSettingsFileElement::soap_put
; _this$ = ecx

; 1470 : {

	push	esi
	push	edi

; 1471 : 	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getSettingsFileElement);

	mov	edi, DWORD PTR _soap$[esp+4]
	mov	esi, ecx
	push	edi
	mov	edx, 21					; 00000015H
	mov	eax, esi
	call	_soap_embed

; 1472 : 	if (this->soap_out(soap, tag, id, type))

	mov	ecx, DWORD PTR _type$[esp+8]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	add	esp, 4
	push	ecx
	push	eax
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	push	edi
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN1@soap_put@9

; 1473 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 1475 : }

	ret	12					; 0000000cH
$LN1@soap_put@9:

; 1474 : 	return soap_putindependent(soap);

	push	edi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4
	pop	edi
	pop	esi

; 1475 : }

	ret	12					; 0000000cH
?soap_put@_ns2__getSettingsFileElement@@UBEHPAUsoap@@PBD1@Z ENDP ; _ns2__getSettingsFileElement::soap_put
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_put@_ns2__getSettingsFileResponseElement@@UBEHPAUsoap@@PBD1@Z PROC ; _ns2__getSettingsFileResponseElement::soap_put
; _this$ = ecx

; 1330 : {

	push	esi
	push	edi

; 1331 : 	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getSettingsFileResponseElement);

	mov	edi, DWORD PTR _soap$[esp+4]
	mov	esi, ecx
	push	edi
	mov	edx, 22					; 00000016H
	mov	eax, esi
	call	_soap_embed

; 1332 : 	if (this->soap_out(soap, tag, id, type))

	mov	ecx, DWORD PTR _type$[esp+8]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	add	esp, 4
	push	ecx
	push	eax
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	push	edi
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN1@soap_put@10

; 1333 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 1335 : }

	ret	12					; 0000000cH
$LN1@soap_put@10:

; 1334 : 	return soap_putindependent(soap);

	push	edi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4
	pop	edi
	pop	esi

; 1335 : }

	ret	12					; 0000000cH
?soap_put@_ns2__getSettingsFileResponseElement@@UBEHPAUsoap@@PBD1@Z ENDP ; _ns2__getSettingsFileResponseElement::soap_put
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_put@_ns2__submitEpochResultElement@@UBEHPAUsoap@@PBD1@Z PROC ; _ns2__submitEpochResultElement::soap_put
; _this$ = ecx

; 1144 : {

	push	esi
	push	edi

; 1145 : 	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__submitEpochResultElement);

	mov	edi, DWORD PTR _soap$[esp+4]
	mov	esi, ecx
	push	edi
	mov	edx, 23					; 00000017H
	mov	eax, esi
	call	_soap_embed

; 1146 : 	if (this->soap_out(soap, tag, id, type))

	mov	ecx, DWORD PTR _type$[esp+8]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	add	esp, 4
	push	ecx
	push	eax
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	push	edi
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN1@soap_put@11

; 1147 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 1149 : }

	ret	12					; 0000000cH
$LN1@soap_put@11:

; 1148 : 	return soap_putindependent(soap);

	push	edi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4
	pop	edi
	pop	esi

; 1149 : }

	ret	12					; 0000000cH
?soap_put@_ns2__submitEpochResultElement@@UBEHPAUsoap@@PBD1@Z ENDP ; _ns2__submitEpochResultElement::soap_put
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_put@_ns2__submitEpochResultResponseElement@@UBEHPAUsoap@@PBD1@Z PROC ; _ns2__submitEpochResultResponseElement::soap_put
; _this$ = ecx

; 989  : {

	push	esi
	push	edi

; 990  : 	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__submitEpochResultResponseElement);

	mov	edi, DWORD PTR _soap$[esp+4]
	mov	esi, ecx
	push	edi
	mov	edx, 24					; 00000018H
	mov	eax, esi
	call	_soap_embed

; 991  : 	if (this->soap_out(soap, tag, id, type))

	mov	ecx, DWORD PTR _type$[esp+8]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+16]
	add	esp, 4
	push	ecx
	push	eax
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	push	edi
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN1@soap_put@12

; 992  : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 994  : }

	ret	12					; 0000000cH
$LN1@soap_put@12:

; 993  : 	return soap_putindependent(soap);

	push	edi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4
	pop	edi
	pop	esi

; 994  : }

	ret	12					; 0000000cH
?soap_put@_ns2__submitEpochResultResponseElement@@UBEHPAUsoap@@PBD1@Z ENDP ; _ns2__submitEpochResultResponseElement::soap_put
_TEXT	ENDS
PUBLIC	?soap_put_bool@@YAHPAUsoap@@PB_NPBD2@Z		; soap_put_bool
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_bool@@YAHPAUsoap@@PB_NPBD2@Z PROC		; soap_put_bool
; _soap$ = esi
; _a$ = edi

; 905  : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);

	push	esi
	mov	edx, 11					; 0000000bH
	mov	eax, edi
	call	_soap_embed

; 906  : 	if (soap_out_bool(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	edi
	push	esi
	call	?soap_out_bool@@YAHPAUsoap@@PBDHPB_N1@Z	; soap_out_bool
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_b

; 907  : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 909  : }

	ret	0
$LN1@soap_put_b:

; 908  : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 909  : }

	ret	0
?soap_put_bool@@YAHPAUsoap@@PB_NPBD2@Z ENDP		; soap_put_bool
_TEXT	ENDS
PUBLIC	?soap_in_float@@YAPAMPAUsoap@@PBDPAM1@Z		; soap_in_float
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_in_float@@YAPAMPAUsoap@@PBDPAM1@Z PROC		; soap_in_float
; _a$ = ecx
; _type$ = eax

; 891  : 	return soap_infloat(soap, tag, a, type, SOAP_TYPE_float);

	mov	edx, DWORD PTR _tag$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	push	edx
	push	eax
	call	_soap_infloat
	add	esp, 16					; 00000010H

; 892  : }

	ret	0
?soap_in_float@@YAPAMPAUsoap@@PBDPAM1@Z ENDP		; soap_in_float
_TEXT	ENDS
PUBLIC	?soap_put_float@@YAHPAUsoap@@PBMPBD2@Z		; soap_put_float
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_float@@YAHPAUsoap@@PBMPBD2@Z PROC		; soap_put_float
; _soap$ = esi
; _a$ = edi

; 870  : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);

	push	esi
	mov	edx, 13					; 0000000dH
	mov	eax, edi
	call	_soap_embed

; 871  : 	if (soap_out_float(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	edi
	push	esi
	call	_soap_outfloat
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_f

; 872  : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 874  : }

	ret	0
$LN1@soap_put_f:

; 873  : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 874  : }

	ret	0
?soap_put_float@@YAHPAUsoap@@PBMPBD2@Z ENDP		; soap_put_float
_TEXT	ENDS
PUBLIC	?soap_in_LONG64@@YAPA_JPAUsoap@@PBDPA_J1@Z	; soap_in_LONG64
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_in_LONG64@@YAPA_JPAUsoap@@PBDPA_J1@Z PROC		; soap_in_LONG64
; _a$ = ecx
; _type$ = eax

; 856  : 	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);

	mov	edx, DWORD PTR _tag$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	push	edx
	call	_soap_inLONG64
	add	esp, 12					; 0000000cH

; 857  : }

	ret	0
?soap_in_LONG64@@YAPA_JPAUsoap@@PBDPA_J1@Z ENDP		; soap_in_LONG64
_TEXT	ENDS
PUBLIC	?soap_put_LONG64@@YAHPAUsoap@@PB_JPBD2@Z	; soap_put_LONG64
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_LONG64@@YAHPAUsoap@@PB_JPBD2@Z PROC		; soap_put_LONG64
; _soap$ = esi
; _a$ = edi

; 835  : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);

	push	esi
	mov	edx, 16					; 00000010H
	mov	eax, edi
	call	_soap_embed

; 836  : 	if (soap_out_LONG64(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	mov	edx, DWORD PTR _tag$[esp]
	push	ecx
	push	edx
	push	esi
	mov	ecx, edi
	call	_soap_outLONG64
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_L

; 837  : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 839  : }

	ret	0
$LN1@soap_put_L:

; 838  : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 839  : }

	ret	0
?soap_put_LONG64@@YAHPAUsoap@@PB_JPBD2@Z ENDP		; soap_put_LONG64
_TEXT	ENDS
PUBLIC	?soap_in_int@@YAPAHPAUsoap@@PBDPAH1@Z		; soap_in_int
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_in_int@@YAPAHPAUsoap@@PBDPAH1@Z PROC		; soap_in_int
; _a$ = ecx
; _type$ = eax

; 821  : 	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);

	mov	edx, DWORD PTR _tag$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	push	edx
	push	eax
	call	_soap_inint
	add	esp, 16					; 00000010H

; 822  : }

	ret	0
?soap_in_int@@YAPAHPAUsoap@@PBDPAH1@Z ENDP		; soap_in_int
_TEXT	ENDS
PUBLIC	?soap_put_int@@YAHPAUsoap@@PBHPBD2@Z		; soap_put_int
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_int@@YAHPAUsoap@@PBHPBD2@Z PROC		; soap_put_int
; _soap$ = esi
; _a$ = edi

; 800  : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);

	push	esi
	mov	edx, 1
	mov	eax, edi
	call	_soap_embed

; 801  : 	if (soap_out_int(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	edi
	push	esi
	call	_soap_outint
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_i

; 802  : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 804  : }

	ret	0
$LN1@soap_put_i:

; 803  : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 804  : }

	ret	0
?soap_put_int@@YAHPAUsoap@@PBHPBD2@Z ENDP		; soap_put_int
_TEXT	ENDS
PUBLIC	?soap_in_byte@@YAPADPAUsoap@@PBDPAD1@Z		; soap_in_byte
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_in_byte@@YAPADPAUsoap@@PBDPAD1@Z PROC		; soap_in_byte
; _a$ = ecx
; _type$ = eax

; 786  : 	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);

	mov	edx, DWORD PTR _tag$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	push	edx
	push	eax
	call	_soap_inbyte
	add	esp, 16					; 00000010H

; 787  : }

	ret	0
?soap_in_byte@@YAPADPAUsoap@@PBDPAD1@Z ENDP		; soap_in_byte
_TEXT	ENDS
PUBLIC	?soap_put_byte@@YAHPAUsoap@@PBD11@Z		; soap_put_byte
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_byte@@YAHPAUsoap@@PBD11@Z PROC		; soap_put_byte
; _soap$ = esi
; _a$ = edi

; 765  : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);

	push	esi
	mov	edx, 3
	mov	eax, edi
	call	_soap_embed

; 766  : 	if (soap_out_byte(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	edi
	push	esi
	call	_soap_outbyte
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_b@2

; 767  : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 769  : }

	ret	0
$LN1@soap_put_b@2:

; 768  : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 769  : }

	ret	0
?soap_put_byte@@YAHPAUsoap@@PBD11@Z ENDP		; soap_put_byte
_TEXT	ENDS
PUBLIC	?soap_class_id_enter@@YAPAXPAUsoap@@PBDPAXHI11@Z ; soap_class_id_enter
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_p$ = 16						; size = 4
_t$ = 20						; size = 4
_n$ = 24						; size = 4
?soap_class_id_enter@@YAPAXPAUsoap@@PBDPAXHI11@Z PROC	; soap_class_id_enter
; _type$ = ecx
; _arrayType$ = eax

; 724  : {	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);

	mov	edx, DWORD PTR _n$[esp-4]
	push	eax
	mov	eax, DWORD PTR _t$[esp]
	push	ecx
	mov	ecx, DWORD PTR _p$[esp+4]
	push	edx
	mov	edx, DWORD PTR _soap$[esp+8]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _id$[esp+16]
	push	edx
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	call	_soap_id_enter
	add	esp, 24					; 00000018H

; 725  : }

	ret	0
?soap_class_id_enter@@YAPAXPAUsoap@@PBDPAXHI11@Z ENDP	; soap_class_id_enter
_TEXT	ENDS
PUBLIC	_soap_getheader
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_getheader PROC
; _soap$ = eax

; 33   : {

	push	esi
	mov	esi, eax

; 34   : 	soap->part = SOAP_IN_HEADER;

	mov	eax, 3
	mov	WORD PTR [esi+87304], ax

; 35   : 	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);

	push	0
	push	0
	mov	eax, OFFSET ??_C@_0BA@GBPDPHCK@SOAP?9ENV?3Header?$AA@
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@soap_gethe@2
	xor	eax, eax
	jmp	SHORT $LN14@soap_gethe@2
$LN19@soap_gethe@2:
	push	OFFSET ??_C@_0BA@GBPDPHCK@SOAP?9ENV?3Header?$AA@
	xor	eax, eax
	mov	ecx, esi
	call	?soap_in_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Header
	add	esp, 4
$LN14@soap_gethe@2:

; 36   : 	soap->part = SOAP_END_HEADER;
; 37   : 	return soap->header == NULL;

	xor	edx, edx
	test	eax, eax
	sete	dl
	mov	ecx, 4
	mov	DWORD PTR [esi+12204], eax
	mov	WORD PTR [esi+87304], cx
	pop	esi
	mov	eax, edx

; 38   : }

	ret	0
_soap_getheader ENDP
PUBLIC	?soap_in_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@PBDPAV12@1@Z ; soap_in_std__vectorTemplateOfint
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_flag$ = -16					; size = 2
$T622987 = -12						; size = 8
_tag$ = 8						; size = 4
_n$ = 12						; size = 4
_a$ = 12						; size = 4
?soap_in_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@PBDPAV12@1@Z PROC ; soap_in_std__vectorTemplateOfint
; _soap$ = esi

; 4434 : {

	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, DWORD PTR _tag$[esp+16]
	push	ebp
	mov	ebp, DWORD PTR _a$[esp+20]
	push	edi

; 4435 : 	if (soap_element_begin_in(soap, tag, 1, NULL))
; 4436 : 		return NULL;
; 4437 : 	if (!a && !(a = soap_new_std__vectorTemplateOfint(soap, -1)))

	test	ebp, ebp
	jne	SHORT $LN13@soap_in_st
	push	ebp
	mov	edi, esi
	call	?soap_instantiate_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_std__vectorTemplateOfint
	mov	ebp, eax
	add	esp, 4
	test	ebp, ebp

; 4438 : 		return NULL;

	je	$LN2@soap_in_st
$LN13@soap_in_st:

; 4439 : 	int n;
; 4440 : 	short soap_flag = 0;

	mov	DWORD PTR _soap_flag$[esp+28], 0
$LN12@soap_in_st:

; 4441 : 	do
; 4442 : 	{	soap_revert(soap);

	cmp	WORD PTR [esi+87308], 0
	jne	SHORT $LN25@soap_in_st
	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	WORD PTR [esi+87308], ax
	je	SHORT $LN25@soap_in_st
	dec	DWORD PTR [esi+12444]
$LN25@soap_in_st:

; 4443 : 		soap_default_int(soap, &n);
; 4444 : 		if (*soap->id || *soap->href)

	cmp	BYTE PTR [esi+81076], 0
	lea	eax, DWORD PTR [esi+81076]
	mov	DWORD PTR _n$[esp+24], 0
	jne	SHORT $LN17@soap_in_st
	cmp	BYTE PTR [esi+82100], 0
	lea	eax, DWORD PTR [esi+82100]
	jne	SHORT $LN17@soap_in_st

; 4448 : 				break;
; 4449 : 		}
; 4450 : 		else
; 4451 : 		{
; 4452 : 			if (!soap_in_int(soap, tag, &n, "xsd:int"))

	push	OFFSET ??_C@_07PCIGPDP@xsd?3int?$AA@
	lea	ecx, DWORD PTR _n$[esp+28]
	push	ecx
	jmp	SHORT $LN118@soap_in_st
$LN17@soap_in_st:

; 4445 : 		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0))

	mov	ecx, DWORD PTR [ebp+16]
	sub	ecx, DWORD PTR [ebp+12]
	push	OFFSET ?soap_container_insert@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_container_insert
	push	4
	push	26					; 0000001aH
	push	1
	sar	ecx, 2
	push	ecx
	push	ebp
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	$LN10@soap_in_st

; 4446 : 				break;
; 4447 : 			if (!soap_in_int(soap, tag, NULL, "xsd:int"))

	push	OFFSET ??_C@_07PCIGPDP@xsd?3int?$AA@
	push	0
$LN118@soap_in_st:
	push	ebx
	push	esi
	call	_soap_inint
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN10@soap_in_st

; 4453 : 				break;
; 4454 : 		}
; 4455 : 		a->push_back(n);

	mov	ecx, DWORD PTR [ebp+12]
	test	ecx, ecx
	jne	SHORT $LN47@soap_in_st
	xor	eax, eax
	jmp	SHORT $LN48@soap_in_st
$LN47@soap_in_st:
	mov	eax, DWORD PTR [ebp+20]
	sub	eax, ecx
	sar	eax, 2
$LN48@soap_in_st:
	mov	edi, DWORD PTR [ebp+16]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN40@soap_in_st
	mov	eax, DWORD PTR _n$[esp+24]
	mov	DWORD PTR [edi], eax
	add	edi, 4
	mov	DWORD PTR [ebp+16], edi
	jmp	SHORT $LN39@soap_in_st
$LN40@soap_in_st:
	cmp	ecx, edi
	jbe	SHORT $LN77@soap_in_st
	call	__invalid_parameter_noinfo
$LN77@soap_in_st:
	mov	eax, DWORD PTR [ebp]
	push	edi
	push	eax
	lea	ecx, DWORD PTR _n$[esp+32]
	push	ecx
	lea	edx, DWORD PTR $T622987[esp+40]
	push	edx
	mov	eax, ebp
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
$LN39@soap_in_st:

; 4456 : 		soap_flag = 1;

	mov	DWORD PTR _soap_flag$[esp+28], 1

; 4457 : 	}
; 4458 : 	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));

	test	ebx, ebx
	je	$LN105@soap_in_st
	cmp	BYTE PTR [ebx], 45			; 0000002dH
	je	$LN105@soap_in_st
	mov	eax, esi
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN96@soap_in_st
	cmp	WORD PTR [esi+87220], ax
	jne	SHORT $LN107@soap_in_st
	cmp	BYTE PTR [ebx], 45			; 0000002dH
	je	$LN12@soap_in_st
	lea	eax, DWORD PTR [esi+80052]
	push	eax
	push	esi
	mov	edi, ebx
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	jne	SHORT $LN88@soap_in_st
	xor	ecx, ecx
	mov	WORD PTR [esi+87308], cx
	cmp	WORD PTR [esi+12442], cx
	je	SHORT $LN88@soap_in_st
	inc	DWORD PTR [esi+12444]
	jmp	SHORT $LN88@soap_in_st
$LN96@soap_in_st:
	cmp	DWORD PTR [esi+90460], 6
	jne	SHORT $LN88@soap_in_st
	cmp	BYTE PTR [ebx], 45			; 0000002dH
	jne	SHORT $LN88@soap_in_st
	mov	DWORD PTR [esi+90460], 0
$LN88@soap_in_st:
	cmp	DWORD PTR [esi+90460], 0
	je	$LN12@soap_in_st
	jmp	SHORT $LN105@soap_in_st
$LN107@soap_in_st:
	mov	DWORD PTR [esi+90460], 3
	jmp	SHORT $LN105@soap_in_st
$LN10@soap_in_st:

; 4459 : 	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))

	cmp	WORD PTR _soap_flag$[esp+28], 0
	je	SHORT $LN2@soap_in_st
$LN105@soap_in_st:
	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 3
	je	SHORT $LN1@soap_in_st
	cmp	eax, 6
	jne	SHORT $LN2@soap_in_st
$LN1@soap_in_st:

; 4460 : 	{	soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0

; 4461 : 		return a;

	mov	eax, ebp

; 4462 : 	}
; 4463 : 	return NULL;
; 4464 : }

	pop	edi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN2@soap_in_st:
	pop	edi
	pop	ebp
	xor	eax, eax
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
?soap_in_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@PBDPAV12@1@Z ENDP ; soap_in_std__vectorTemplateOfint
_TEXT	ENDS
PUBLIC	?soap_in_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@PBDPAV12@1@Z ; soap_in_std__vectorTemplateOffloat
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_flag$ = -16					; size = 2
$T623358 = -12						; size = 8
_tag$ = 8						; size = 4
_n$ = 12						; size = 4
_a$ = 12						; size = 4
?soap_in_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@PBDPAV12@1@Z PROC ; soap_in_std__vectorTemplateOffloat
; _soap$ = esi

; 4345 : {

	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, DWORD PTR _tag$[esp+16]
	push	ebp
	mov	ebp, DWORD PTR _a$[esp+20]
	push	edi

; 4346 : 	if (soap_element_begin_in(soap, tag, 1, NULL))
; 4347 : 		return NULL;
; 4348 : 	if (!a && !(a = soap_new_std__vectorTemplateOffloat(soap, -1)))

	test	ebp, ebp
	jne	SHORT $LN13@soap_in_st@2
	push	ebp
	mov	edi, esi
	call	?soap_instantiate_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate_std__vectorTemplateOffloat
	mov	ebp, eax
	add	esp, 4
	test	ebp, ebp

; 4349 : 		return NULL;

	je	$LN2@soap_in_st@2
$LN13@soap_in_st@2:

; 4350 : 	float n;
; 4351 : 	short soap_flag = 0;

	mov	DWORD PTR _soap_flag$[esp+28], 0
$LN12@soap_in_st@2:

; 4352 : 	do
; 4353 : 	{	soap_revert(soap);

	cmp	WORD PTR [esi+87308], 0
	jne	SHORT $LN25@soap_in_st@2
	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	WORD PTR [esi+87308], ax
	je	SHORT $LN25@soap_in_st@2
	dec	DWORD PTR [esi+12444]
$LN25@soap_in_st@2:

; 4354 : 		soap_default_float(soap, &n);
; 4355 : 		if (*soap->id || *soap->href)

	cmp	BYTE PTR [esi+81076], 0
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+81076]
	movss	DWORD PTR _n$[esp+24], xmm0
	jne	SHORT $LN17@soap_in_st@2
	cmp	BYTE PTR [esi+82100], 0
	lea	eax, DWORD PTR [esi+82100]
	jne	SHORT $LN17@soap_in_st@2

; 4359 : 				break;
; 4360 : 		}
; 4361 : 		else
; 4362 : 		{
; 4363 : 			if (!soap_in_float(soap, tag, &n, "xsd:float"))

	push	OFFSET ??_C@_09ILBLHFBD@xsd?3float?$AA@
	lea	ecx, DWORD PTR _n$[esp+28]
	push	ecx
	jmp	SHORT $LN117@soap_in_st@2
$LN17@soap_in_st@2:

; 4356 : 		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_float, SOAP_TYPE_std__vectorTemplateOffloat, sizeof(float), 0))

	mov	ecx, DWORD PTR [ebp+16]
	sub	ecx, DWORD PTR [ebp+12]
	push	OFFSET ?soap_container_insert@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_container_insert
	push	4
	push	27					; 0000001bH
	push	13					; 0000000dH
	sar	ecx, 2
	push	ecx
	push	ebp
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	$LN10@soap_in_st@2

; 4357 : 				break;
; 4358 : 			if (!soap_in_float(soap, tag, NULL, "xsd:float"))

	push	OFFSET ??_C@_09ILBLHFBD@xsd?3float?$AA@
	push	0
$LN117@soap_in_st@2:
	push	ebx
	push	esi
	call	_soap_infloat
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN10@soap_in_st@2

; 4364 : 				break;
; 4365 : 		}
; 4366 : 		a->push_back(n);

	mov	ecx, DWORD PTR [ebp+12]
	test	ecx, ecx
	jne	SHORT $LN47@soap_in_st@2
	xor	eax, eax
	jmp	SHORT $LN48@soap_in_st@2
$LN47@soap_in_st@2:
	mov	eax, DWORD PTR [ebp+20]
	sub	eax, ecx
	sar	eax, 2
$LN48@soap_in_st@2:
	mov	edi, DWORD PTR [ebp+16]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN40@soap_in_st@2
	movss	xmm0, DWORD PTR _n$[esp+24]
	movss	DWORD PTR [edi], xmm0
	add	edi, 4
	mov	DWORD PTR [ebp+16], edi
	jmp	SHORT $LN39@soap_in_st@2
$LN40@soap_in_st@2:
	cmp	ecx, edi
	jbe	SHORT $LN77@soap_in_st@2
	call	__invalid_parameter_noinfo
$LN77@soap_in_st@2:
	mov	eax, DWORD PTR [ebp]
	push	edi
	push	eax
	lea	eax, DWORD PTR _n$[esp+32]
	push	eax
	lea	ecx, DWORD PTR $T623358[esp+40]
	push	ecx
	mov	eax, ebp
	call	?insert@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@ABM@Z ; std::vector<float,std::allocator<float> >::insert
$LN39@soap_in_st@2:

; 4367 : 		soap_flag = 1;

	mov	DWORD PTR _soap_flag$[esp+28], 1

; 4368 : 	}
; 4369 : 	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));

	test	ebx, ebx
	je	$LN105@soap_in_st@2
	cmp	BYTE PTR [ebx], 45			; 0000002dH
	je	$LN105@soap_in_st@2
	mov	eax, esi
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN96@soap_in_st@2
	cmp	WORD PTR [esi+87220], ax
	jne	SHORT $LN107@soap_in_st@2
	cmp	BYTE PTR [ebx], 45			; 0000002dH
	je	$LN12@soap_in_st@2
	lea	edx, DWORD PTR [esi+80052]
	push	edx
	push	esi
	mov	edi, ebx
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	jne	SHORT $LN88@soap_in_st@2
	mov	WORD PTR [esi+87308], ax
	cmp	WORD PTR [esi+12442], ax
	je	SHORT $LN88@soap_in_st@2
	inc	DWORD PTR [esi+12444]
	jmp	SHORT $LN88@soap_in_st@2
$LN96@soap_in_st@2:
	cmp	DWORD PTR [esi+90460], 6
	jne	SHORT $LN88@soap_in_st@2
	cmp	BYTE PTR [ebx], 45			; 0000002dH
	jne	SHORT $LN88@soap_in_st@2
	mov	DWORD PTR [esi+90460], 0
$LN88@soap_in_st@2:
	cmp	DWORD PTR [esi+90460], 0
	je	$LN12@soap_in_st@2
	jmp	SHORT $LN105@soap_in_st@2
$LN107@soap_in_st@2:
	mov	DWORD PTR [esi+90460], 3
	jmp	SHORT $LN105@soap_in_st@2
$LN10@soap_in_st@2:

; 4370 : 	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))

	cmp	WORD PTR _soap_flag$[esp+28], 0
	je	SHORT $LN2@soap_in_st@2
$LN105@soap_in_st@2:
	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 3
	je	SHORT $LN1@soap_in_st@2
	cmp	eax, 6
	jne	SHORT $LN2@soap_in_st@2
$LN1@soap_in_st@2:

; 4371 : 	{	soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0

; 4372 : 		return a;

	mov	eax, ebp

; 4373 : 	}
; 4374 : 	return NULL;
; 4375 : }

	pop	edi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
$LN2@soap_in_st@2:
	pop	edi
	pop	ebp
	xor	eax, eax
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
?soap_in_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@PBDPAV12@1@Z ENDP ; soap_in_std__vectorTemplateOffloat
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_a$ = 16						; size = 4
_type$ = 20						; size = 4
?soap_in_PointerToSOAP_ENV__Code@@YAPAPAUSOAP_ENV__Code@@PAUsoap@@PBDPAPAU1@1@Z PROC ; soap_in_PointerToSOAP_ENV__Code

; 3848 : {

	push	ebx

; 3849 : 	if (soap_element_begin_in(soap, tag, 1, NULL))

	mov	ebx, DWORD PTR _tag$[esp]
	push	esi
	mov	esi, DWORD PTR _soap$[esp+4]
	push	0
	push	1
	mov	eax, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_in_Po@7
	pop	esi

; 3850 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 3866 : }

	ret	0
$LN7@soap_in_Po@7:
	push	edi

; 3851 : 	if (!a)

	mov	edi, DWORD PTR _a$[esp+8]
	test	edi, edi
	jne	SHORT $LN5@soap_in_Po@7

; 3852 : 		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))

	lea	eax, DWORD PTR [edi+4]
	mov	edi, esi
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi

; 3853 : 			return NULL;

	je	SHORT $LN11@soap_in_Po@7
$LN5@soap_in_Po@7:

; 3854 : 	*a = NULL;

	mov	DWORD PTR [edi], 0

; 3855 : 	if (!soap->null && *soap->href != '#')

	cmp	WORD PTR [esi+87300], 0
	jne	SHORT $LN4@soap_in_Po@7
	cmp	BYTE PTR [esi+82100], 35		; 00000023H
	je	SHORT $LN4@soap_in_Po@7

; 3856 : 	{	soap_revert(soap);

	mov	eax, esi
	call	_soap_revert

; 3857 : 		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))

	mov	eax, DWORD PTR [edi]
	push	eax
	mov	eax, DWORD PTR _type$[esp+12]
	push	ebx
	mov	ecx, esi
	call	?soap_in_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Code
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax
	jne	SHORT $LN1@soap_in_Po@7
$LN11@soap_in_Po@7:
	pop	edi
	pop	esi

; 3858 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 3866 : }

	ret	0
$LN4@soap_in_Po@7:

; 3859 : 	}
; 3860 : 	else
; 3861 : 	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);

	push	8
	push	41					; 00000029H
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	mov	ecx, esi
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH

; 3862 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in_Po@7
	push	ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 3863 : 			return NULL;

	jne	SHORT $LN11@soap_in_Po@7
$LN1@soap_in_Po@7:

; 3864 : 	}
; 3865 : 	return a;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3866 : }

	ret	0
?soap_in_PointerToSOAP_ENV__Code@@YAPAPAUSOAP_ENV__Code@@PAUsoap@@PBDPAPAU1@1@Z ENDP ; soap_in_PointerToSOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_out_PointerToSOAP_ENV__Detail@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Detail@@1@Z ; soap_out_PointerToSOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_pp$623473 = 12						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_out_PointerToSOAP_ENV__Detail@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Detail@@1@Z PROC ; soap_out_PointerToSOAP_ENV__Detail
; _soap$ = ecx
; _id$ = eax

; 3777 : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _a$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx

; 3778 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);

	mov	ecx, DWORD PTR [ebp]
	mov	esi, eax
	test	ecx, ecx
	je	$LN11@soap_out_P@10
	test	DWORD PTR [edi+8], 32768		; 00008000H
	je	SHORT $LN10@soap_out_P@10
$LN31@soap_out_P@10:
	xor	eax, eax
$LN1@soap_out_P@10:

; 3781 : 	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);

	mov	edx, DWORD PTR _type$[esp+12]
	mov	ecx, DWORD PTR [ebp]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+20]
	push	edi
	call	?soap_out_SOAP_ENV__Detail@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Detail@@1@Z ; soap_out_SOAP_ENV__Detail
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3782 : }

	ret	0

; 3778 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);

$LN10@soap_out_P@10:
	test	eax, eax
	jge	SHORT $LN6@soap_out_P@10
	lea	edx, DWORD PTR _pp$623473[esp+12]
	mov	esi, 43					; 0000002bH
	call	_soap_pointer_lookup
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN6@soap_out_P@10
	mov	ebx, DWORD PTR _pp$623473[esp+12]
	mov	ecx, ebx
	mov	eax, edi
	call	_soap_is_embedded
	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN5@soap_out_P@10
	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax
	mov	eax, esi
	call	_soap_element_ref

; 3780 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3782 : }

	ret	0

; 3778 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);

$LN5@soap_out_P@10:
	mov	eax, ebx
	call	_soap_is_single
	test	eax, eax
	jne	SHORT $LN31@soap_out_P@10
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_set_embedded
$LN6@soap_out_P@10:
	mov	eax, esi

; 3779 : 	if (id < 0)

	test	esi, esi
	jge	SHORT $LN1@soap_out_P@10

; 3780 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3782 : }

	ret	0

; 3778 : 	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);

$LN11@soap_out_P@10:
	mov	ecx, DWORD PTR _type$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+16]
	push	edi
	call	_soap_element_null

; 3780 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3782 : }

	ret	0
?soap_out_PointerToSOAP_ENV__Detail@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Detail@@1@Z ENDP ; soap_out_PointerToSOAP_ENV__Detail
_TEXT	ENDS
PUBLIC	?soap_put_PointerToSOAP_ENV__Detail@@YAHPAUsoap@@PBQAUSOAP_ENV__Detail@@PBD2@Z ; soap_put_PointerToSOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_put_PointerToSOAP_ENV__Detail@@YAHPAUsoap@@PBQAUSOAP_ENV__Detail@@PBD2@Z PROC ; soap_put_PointerToSOAP_ENV__Detail
; _soap$ = esi
; _a$ = edi

; 3770 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);

	push	esi
	mov	edx, 48					; 00000030H
	mov	eax, edi
	call	_soap_embed

; 3771 : 	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))

	mov	ecx, DWORD PTR _type$[esp]
	mov	edx, DWORD PTR _tag$[esp]
	push	ecx
	push	edi
	push	edx
	mov	ecx, esi
	call	?soap_out_PointerToSOAP_ENV__Detail@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Detail@@1@Z ; soap_out_PointerToSOAP_ENV__Detail
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@soap_put_P@10

; 3772 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 3774 : }

	ret	0
$LN1@soap_put_P@10:

; 3773 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 3774 : }

	ret	0
?soap_put_PointerToSOAP_ENV__Detail@@YAHPAUsoap@@PBQAUSOAP_ENV__Detail@@PBD2@Z ENDP ; soap_put_PointerToSOAP_ENV__Detail
_TEXT	ENDS
PUBLIC	?soap_in_PointerToSOAP_ENV__Reason@@YAPAPAUSOAP_ENV__Reason@@PAUsoap@@PBDPAPAU1@1@Z ; soap_in_PointerToSOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_in_PointerToSOAP_ENV__Reason@@YAPAPAUSOAP_ENV__Reason@@PAUsoap@@PBDPAPAU1@1@Z PROC ; soap_in_PointerToSOAP_ENV__Reason
; _soap$ = ecx
; _a$ = eax

; 3738 : {

	push	ebx
	mov	ebx, DWORD PTR _tag$[esp]
	push	esi
	push	edi
	mov	edi, eax

; 3739 : 	if (soap_element_begin_in(soap, tag, 1, NULL))

	push	0
	mov	esi, ecx
	push	1
	mov	eax, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax

; 3740 : 		return NULL;

	jne	SHORT $LN10@soap_in_Po@8

; 3741 : 	if (!a)

	test	edi, edi
	jne	SHORT $LN5@soap_in_Po@8

; 3742 : 		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))

	lea	eax, DWORD PTR [edi+4]
	mov	edi, esi
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi

; 3743 : 			return NULL;

	je	SHORT $LN10@soap_in_Po@8
$LN5@soap_in_Po@8:

; 3744 : 	*a = NULL;

	mov	DWORD PTR [edi], 0

; 3745 : 	if (!soap->null && *soap->href != '#')

	cmp	WORD PTR [esi+87300], 0
	jne	SHORT $LN4@soap_in_Po@8
	cmp	BYTE PTR [esi+82100], 35		; 00000023H
	je	SHORT $LN4@soap_in_Po@8

; 3746 : 	{	soap_revert(soap);

	mov	eax, esi
	call	_soap_revert

; 3747 : 		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))

	mov	eax, DWORD PTR [edi]
	push	eax
	mov	eax, DWORD PTR _type$[esp+12]
	push	ebx
	mov	ecx, esi
	call	?soap_in_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Reason
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax
	jne	SHORT $LN1@soap_in_Po@8
$LN10@soap_in_Po@8:
	pop	edi
	pop	esi

; 3748 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 3756 : }

	ret	0
$LN4@soap_in_Po@8:

; 3749 : 	}
; 3750 : 	else
; 3751 : 	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);

	push	4
	push	46					; 0000002eH
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	mov	ecx, esi
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH

; 3752 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in_Po@8
	push	ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 3753 : 			return NULL;

	jne	SHORT $LN10@soap_in_Po@8
$LN1@soap_in_Po@8:

; 3754 : 	}
; 3755 : 	return a;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3756 : }

	ret	0
?soap_in_PointerToSOAP_ENV__Reason@@YAPAPAUSOAP_ENV__Reason@@PAUsoap@@PBDPAPAU1@1@Z ENDP ; soap_in_PointerToSOAP_ENV__Reason
_TEXT	ENDS
PUBLIC	?soap_out_SOAP_ENV__Fault@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Fault@@1@Z ; soap_out_SOAP_ENV__Fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_tmp_faultcode$ = -4				; size = 4
_id$ = 8						; size = 4
?soap_out_SOAP_ENV__Fault@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Fault@@1@Z PROC ; soap_out_SOAP_ENV__Fault
; _soap$ = ecx
; _a$ = eax

; 2780 : {

	push	ecx
	push	esi
	mov	esi, eax

; 2781 : 	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);

	mov	eax, DWORD PTR [esi]
	push	edi
	mov	edi, ecx
	push	eax
	push	edi
	call	_soap_QName2s

; 2782 : 	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))

	mov	ecx, DWORD PTR _id$[esp+16]
	push	ecx
	mov	DWORD PTR _soap_tmp_faultcode$[esp+24], eax
	push	edi
	mov	eax, 47					; 0000002fH
	mov	ecx, esi
	call	_soap_embedded_id
	push	0
	push	eax
	push	OFFSET ??_C@_0P@GLDIJMBO@SOAP?9ENV?3Fault?$AA@
	mov	eax, edi
	call	_soap_element
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN13@soap_out_S@5
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN15@soap_out_S@5
$LN13@soap_out_S@5:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN15@soap_out_S@5:
	test	eax, eax
	je	SHORT $LN10@soap_out_S@5
$LN27@soap_out_S@5:

; 2783 : 		return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 2803 : }

	pop	ecx
	ret	0
$LN10@soap_out_S@5:

; 2784 : 	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))

	push	5
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	edx, DWORD PTR _soap_tmp_faultcode$[esp+20]
	push	edx
	push	OFFSET ??_C@_09FJACJGDN@faultcode?$AA@
	or	eax, -1
	mov	ecx, edi
	call	_soap_outstring
	add	esp, 16					; 00000010H
	test	eax, eax

; 2785 : 		return soap->error;

	jne	SHORT $LN27@soap_out_S@5

; 2786 : 	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))

	push	4
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	eax, DWORD PTR [esi+4]
	push	eax
	push	OFFSET ??_C@_0M@LAMIIPIL@faultstring?$AA@
	or	eax, -1
	mov	ecx, edi
	call	_soap_outstring
	add	esp, 16					; 00000010H
	test	eax, eax

; 2787 : 		return soap->error;

	jne	SHORT $LN27@soap_out_S@5

; 2788 : 	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))

	push	4
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	push	OFFSET ??_C@_0L@JAIOMLLA@faultactor?$AA@
	or	eax, -1
	mov	ecx, edi
	call	_soap_outstring
	add	esp, 16					; 00000010H
	test	eax, eax

; 2789 : 		return soap->error;

	jne	SHORT $LN27@soap_out_S@5

; 2790 : 	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	edx, DWORD PTR [esi+12]
	push	edx
	push	OFFSET ??_C@_06EENFNEPD@detail?$AA@
	or	eax, -1
	mov	ecx, edi
	call	?soap_out_PointerToSOAP_ENV__Detail@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Detail@@1@Z ; soap_out_PointerToSOAP_ENV__Detail
	add	esp, 12					; 0000000cH
	test	eax, eax

; 2791 : 		return soap->error;

	jne	$LN27@soap_out_S@5

; 2792 : 	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	eax, DWORD PTR [esi+16]
	push	eax
	push	-1
	push	OFFSET ??_C@_0O@OALMNFDI@SOAP?9ENV?3Code?$AA@
	push	edi
	call	?soap_out_PointerToSOAP_ENV__Code@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Code@@1@Z ; soap_out_PointerToSOAP_ENV__Code
	add	esp, 20					; 00000014H
	test	eax, eax

; 2793 : 		return soap->error;

	jne	$LN27@soap_out_S@5

; 2794 : 	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR [esi+20]
	push	ecx
	push	OFFSET ??_C@_0BA@IEHDIDAH@SOAP?9ENV?3Reason?$AA@
	or	eax, -1
	mov	ecx, edi
	call	?soap_out_PointerToSOAP_ENV__Reason@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Reason@@1@Z ; soap_out_PointerToSOAP_ENV__Reason
	add	esp, 12					; 0000000cH
	test	eax, eax

; 2795 : 		return soap->error;

	jne	$LN27@soap_out_S@5

; 2796 : 	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))

	push	4
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	edx, DWORD PTR [esi+24]
	push	edx
	push	OFFSET ??_C@_0O@BICMBBIJ@SOAP?9ENV?3Node?$AA@
	or	eax, -1
	mov	ecx, edi
	call	_soap_outstring
	add	esp, 16					; 00000010H
	test	eax, eax

; 2797 : 		return soap->error;

	jne	$LN27@soap_out_S@5

; 2798 : 	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))

	push	4
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	eax, DWORD PTR [esi+28]
	push	eax
	push	OFFSET ??_C@_0O@LDCPDKLC@SOAP?9ENV?3Role?$AA@
	or	eax, -1
	mov	ecx, edi
	call	_soap_outstring
	add	esp, 16					; 00000010H
	test	eax, eax

; 2799 : 		return soap->error;

	jne	$LN27@soap_out_S@5

; 2800 : 	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	add	esi, 32					; 00000020H
	push	esi
	push	OFFSET ??_C@_0BA@OENGLDCF@SOAP?9ENV?3Detail?$AA@
	or	eax, -1
	mov	ecx, edi
	call	?soap_out_PointerToSOAP_ENV__Detail@@YAHPAUsoap@@PBDHPBQAUSOAP_ENV__Detail@@1@Z ; soap_out_PointerToSOAP_ENV__Detail
	add	esp, 12					; 0000000cH
	test	eax, eax

; 2801 : 		return soap->error;

	jne	$LN27@soap_out_S@5

; 2802 : 	return soap_element_end_out(soap, tag);

	mov	esi, OFFSET ??_C@_0P@GLDIJMBO@SOAP?9ENV?3Fault?$AA@
	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi

; 2803 : }

	pop	ecx
	ret	0
?soap_out_SOAP_ENV__Fault@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Fault@@1@Z ENDP ; soap_out_SOAP_ENV__Fault
_TEXT	ENDS
PUBLIC	?soap_put_SOAP_ENV__Fault@@YAHPAUsoap@@PBUSOAP_ENV__Fault@@PBD2@Z ; soap_put_SOAP_ENV__Fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_put_SOAP_ENV__Fault@@YAHPAUsoap@@PBUSOAP_ENV__Fault@@PBD2@Z PROC ; soap_put_SOAP_ENV__Fault
; _soap$ = esi
; _a$ = edi

; 2773 : 	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);

	push	esi
	mov	edx, 47					; 0000002fH
	mov	eax, edi
	call	_soap_embed

; 2774 : 	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))

	push	eax
	mov	eax, edi
	mov	ecx, esi
	call	?soap_out_SOAP_ENV__Fault@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Fault@@1@Z ; soap_out_SOAP_ENV__Fault
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_put_S@5

; 2775 : 		return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 2777 : }

	ret	0
$LN1@soap_put_S@5:

; 2776 : 	return soap_putindependent(soap);

	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4

; 2777 : }

	ret	0
?soap_put_SOAP_ENV__Fault@@YAHPAUsoap@@PBUSOAP_ENV__Fault@@PBD2@Z ENDP ; soap_put_SOAP_ENV__Fault
_TEXT	ENDS
PUBLIC	?soap_in_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__anyType
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@PBDPAV1@1@Z PROC ; soap_in_xsd__anyType
; _soap$ = eax

; 2572 : {

	push	ebp
	mov	ebp, DWORD PTR _tag$[esp]
	push	esi
	mov	esi, eax

; 2573 : 	if (soap_element_begin_in(soap, tag, 1, NULL))

	push	0
	push	1
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@soap_in_xs@4
	pop	esi

; 2574 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 2587 : 		return NULL;
; 2588 : 	return a;
; 2589 : }

	ret	0
$LN5@soap_in_xs@4:

; 2575 : 	if (!(a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType)))

	mov	edx, DWORD PTR _a$[esp+4]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	lea	ecx, DWORD PTR [esi+83124]
	push	ecx
	push	12					; 0000000cH
	push	8
	push	edx
	lea	ebx, DWORD PTR [esi+81076]
	push	esi
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	mov	ecx, ebx
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H
	test	edi, edi
	jne	SHORT $LN4@soap_in_xs@4
	pop	edi
	pop	ebx

; 2576 : 	{	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], 3
	pop	esi
	pop	ebp

; 2587 : 		return NULL;
; 2588 : 	return a;
; 2589 : }

	ret	0
$LN4@soap_in_xs@4:

; 2577 : 		return NULL;
; 2578 : 	}
; 2579 : 	soap_revert(soap);

	cmp	WORD PTR [esi+87308], 0
	jne	SHORT $LN10@soap_in_xs@4
	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	WORD PTR [esi+87308], ax
	je	SHORT $LN10@soap_in_xs@4
	dec	DWORD PTR [esi+12444]
$LN10@soap_in_xs@4:

; 2580 : 	*soap->id = '\0';
; 2581 : 	if (soap->alloced)

	cmp	WORD PTR [esi+87306], 0
	mov	BYTE PTR [ebx], 0
	je	SHORT $LN2@soap_in_xs@4

; 2582 : 	{	a->soap_default(soap);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]
	push	esi
	mov	ecx, edi
	call	eax

; 2583 : 		if (soap->clist->type != SOAP_TYPE_xsd__anyType)

	mov	ecx, DWORD PTR [esi+96]
	cmp	DWORD PTR [ecx+8], 8
	je	SHORT $LN2@soap_in_xs@4

; 2584 : 			return (xsd__anyType *)a->soap_in(soap, tag, type);

	mov	eax, DWORD PTR _type$[esp+12]
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+24]
	push	eax
	push	ebp
	push	esi
	mov	ecx, edi
	call	edx
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 2587 : 		return NULL;
; 2588 : 	return a;
; 2589 : }

	ret	0
$LN2@soap_in_xs@4:

; 2585 : 	}
; 2586 : 	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))

	lea	eax, DWORD PTR [edi+4]
	push	ebp
	mov	ecx, esi
	call	_soap_inliteral
	add	esp, 4
	neg	eax
	sbb	eax, eax
	and	eax, edi
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 2587 : 		return NULL;
; 2588 : 	return a;
; 2589 : }

	ret	0
?soap_in_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@PBDPAV1@1@Z ENDP ; soap_in_xsd__anyType
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in@xsd__anyType@@UAEPAXPAUsoap@@PBD1@Z PROC	; xsd__anyType::soap_in
; _this$ = ecx

; 2568 : {	return soap_in_xsd__anyType(soap, tag, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	ecx
	call	?soap_in_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__anyType
	add	esp, 12					; 0000000cH

; 2569 : }

	ret	12					; 0000000cH
?soap_in@xsd__anyType@@UAEPAXPAUsoap@@PBD1@Z ENDP	; xsd__anyType::soap_in
_TEXT	ENDS
PUBLIC	?soap_in_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__boolean
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@PBDPAV1@1@Z PROC ; soap_in_xsd__boolean
; _soap$ = eax

; 2464 : {

	push	ebp
	mov	ebp, DWORD PTR _tag$[esp]
	push	esi
	mov	esi, eax

; 2465 : 	if (soap_element_begin_in(soap, tag, 1, NULL))

	push	0
	push	1
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@soap_in_xs@5
	pop	esi

; 2466 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 2479 : 		return NULL;
; 2480 : 	return a;
; 2481 : }

	ret	0
$LN5@soap_in_xs@5:

; 2467 : 	if (!(a = (xsd__boolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), soap->type, soap->arrayType)))

	mov	edx, DWORD PTR _a$[esp+4]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	lea	ecx, DWORD PTR [esi+83124]
	push	ecx
	push	16					; 00000010H
	push	10					; 0000000aH
	push	edx
	lea	ebx, DWORD PTR [esi+81076]
	push	esi
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	mov	ecx, ebx
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H
	test	edi, edi
	jne	SHORT $LN4@soap_in_xs@5
	pop	edi
	pop	ebx

; 2468 : 	{	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], 3
	pop	esi
	pop	ebp

; 2479 : 		return NULL;
; 2480 : 	return a;
; 2481 : }

	ret	0
$LN4@soap_in_xs@5:

; 2469 : 		return NULL;
; 2470 : 	}
; 2471 : 	soap_revert(soap);

	cmp	WORD PTR [esi+87308], 0
	jne	SHORT $LN10@soap_in_xs@5
	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	WORD PTR [esi+87308], ax
	je	SHORT $LN10@soap_in_xs@5
	dec	DWORD PTR [esi+12444]
$LN10@soap_in_xs@5:

; 2472 : 	*soap->id = '\0';
; 2473 : 	if (soap->alloced)

	cmp	WORD PTR [esi+87306], 0
	mov	BYTE PTR [ebx], 0
	je	SHORT $LN2@soap_in_xs@5

; 2474 : 	{	a->soap_default(soap);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]
	push	esi
	mov	ecx, edi
	call	eax

; 2475 : 		if (soap->clist->type != SOAP_TYPE_xsd__boolean)

	mov	ecx, DWORD PTR [esi+96]
	cmp	DWORD PTR [ecx+8], 10			; 0000000aH
	je	SHORT $LN2@soap_in_xs@5

; 2476 : 			return (xsd__boolean *)a->soap_in(soap, tag, type);

	mov	eax, DWORD PTR _type$[esp+12]
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+24]
	push	eax
	push	ebp
	push	esi
	mov	ecx, edi
	call	edx
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 2479 : 		return NULL;
; 2480 : 	return a;
; 2481 : }

	ret	0
$LN2@soap_in_xs@5:

; 2477 : 	}
; 2478 : 	if (!soap_in_bool(soap, tag, &(a->xsd__boolean::__item), "xsd:boolean"))

	push	OFFSET ??_C@_0M@FGHMEICI@xsd?3boolean?$AA@
	lea	eax, DWORD PTR [edi+12]
	push	eax
	push	ebp
	mov	eax, esi
	call	?soap_in_bool@@YAPA_NPAUsoap@@PBDPA_N1@Z ; soap_in_bool
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	and	eax, edi
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 2479 : 		return NULL;
; 2480 : 	return a;
; 2481 : }

	ret	0
?soap_in_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@PBDPAV1@1@Z ENDP ; soap_in_xsd__boolean
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in@xsd__boolean@@UAEPAXPAUsoap@@PBD1@Z PROC	; xsd__boolean::soap_in
; _this$ = ecx

; 2460 : {	return soap_in_xsd__boolean(soap, tag, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	ecx
	call	?soap_in_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__boolean
	add	esp, 12					; 0000000cH

; 2461 : }

	ret	12					; 0000000cH
?soap_in@xsd__boolean@@UAEPAXPAUsoap@@PBD1@Z ENDP	; xsd__boolean::soap_in
_TEXT	ENDS
PUBLIC	?soap_in_xsd__float@@YAPAVxsd__float@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__float
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in_xsd__float@@YAPAVxsd__float@@PAUsoap@@PBDPAV1@1@Z PROC ; soap_in_xsd__float
; _soap$ = eax

; 2355 : {

	push	ebp
	mov	ebp, DWORD PTR _tag$[esp]
	push	esi
	mov	esi, eax

; 2356 : 	if (soap_element_begin_in(soap, tag, 1, NULL))

	push	0
	push	1
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@soap_in_xs@6
	pop	esi

; 2357 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 2370 : 		return NULL;
; 2371 : 	return a;
; 2372 : }

	ret	0
$LN5@soap_in_xs@6:

; 2358 : 	if (!(a = (xsd__float *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__float, sizeof(xsd__float), soap->type, soap->arrayType)))

	mov	edx, DWORD PTR _a$[esp+4]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	lea	ecx, DWORD PTR [esi+83124]
	push	ecx
	push	16					; 00000010H
	push	12					; 0000000cH
	push	edx
	lea	ebx, DWORD PTR [esi+81076]
	push	esi
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	mov	ecx, ebx
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H
	test	edi, edi
	jne	SHORT $LN4@soap_in_xs@6
	pop	edi
	pop	ebx

; 2359 : 	{	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], 3
	pop	esi
	pop	ebp

; 2370 : 		return NULL;
; 2371 : 	return a;
; 2372 : }

	ret	0
$LN4@soap_in_xs@6:

; 2360 : 		return NULL;
; 2361 : 	}
; 2362 : 	soap_revert(soap);

	cmp	WORD PTR [esi+87308], 0
	jne	SHORT $LN10@soap_in_xs@6
	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	WORD PTR [esi+87308], ax
	je	SHORT $LN10@soap_in_xs@6
	dec	DWORD PTR [esi+12444]
$LN10@soap_in_xs@6:

; 2363 : 	*soap->id = '\0';
; 2364 : 	if (soap->alloced)

	cmp	WORD PTR [esi+87306], 0
	mov	BYTE PTR [ebx], 0
	je	SHORT $LN2@soap_in_xs@6

; 2365 : 	{	a->soap_default(soap);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]
	push	esi
	mov	ecx, edi
	call	eax

; 2366 : 		if (soap->clist->type != SOAP_TYPE_xsd__float)

	mov	ecx, DWORD PTR [esi+96]
	cmp	DWORD PTR [ecx+8], 12			; 0000000cH
	je	SHORT $LN2@soap_in_xs@6

; 2367 : 			return (xsd__float *)a->soap_in(soap, tag, type);

	mov	eax, DWORD PTR _type$[esp+12]
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+24]
	push	eax
	push	ebp
	push	esi
	mov	ecx, edi
	call	edx
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 2370 : 		return NULL;
; 2371 : 	return a;
; 2372 : }

	ret	0
$LN2@soap_in_xs@6:

; 2368 : 	}
; 2369 : 	if (!soap_in_float(soap, tag, &(a->xsd__float::__item), "xsd:float"))

	push	OFFSET ??_C@_09ILBLHFBD@xsd?3float?$AA@
	lea	eax, DWORD PTR [edi+12]
	push	eax
	push	ebp
	push	esi
	call	_soap_infloat
	add	esp, 16					; 00000010H
	neg	eax
	sbb	eax, eax
	and	eax, edi
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 2370 : 		return NULL;
; 2371 : 	return a;
; 2372 : }

	ret	0
?soap_in_xsd__float@@YAPAVxsd__float@@PAUsoap@@PBDPAV1@1@Z ENDP ; soap_in_xsd__float
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in@xsd__float@@UAEPAXPAUsoap@@PBD1@Z PROC		; xsd__float::soap_in
; _this$ = ecx

; 2351 : {	return soap_in_xsd__float(soap, tag, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	ecx
	call	?soap_in_xsd__float@@YAPAVxsd__float@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__float
	add	esp, 12					; 0000000cH

; 2352 : }

	ret	12					; 0000000cH
?soap_in@xsd__float@@UAEPAXPAUsoap@@PBD1@Z ENDP		; xsd__float::soap_in
_TEXT	ENDS
PUBLIC	?soap_in_xsd__int@@YAPAVxsd__int@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__int
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in_xsd__int@@YAPAVxsd__int@@PAUsoap@@PBDPAV1@1@Z PROC ; soap_in_xsd__int
; _soap$ = eax

; 2246 : {

	push	ebp
	mov	ebp, DWORD PTR _tag$[esp]
	push	esi
	mov	esi, eax

; 2247 : 	if (soap_element_begin_in(soap, tag, 1, NULL))

	push	0
	push	1
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@soap_in_xs@7
	pop	esi

; 2248 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 2261 : 		return NULL;
; 2262 : 	return a;
; 2263 : }

	ret	0
$LN5@soap_in_xs@7:

; 2249 : 	if (!(a = (xsd__int *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int, sizeof(xsd__int), soap->type, soap->arrayType)))

	mov	edx, DWORD PTR _a$[esp+4]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	lea	ecx, DWORD PTR [esi+83124]
	push	ecx
	push	16					; 00000010H
	push	14					; 0000000eH
	push	edx
	lea	ebx, DWORD PTR [esi+81076]
	push	esi
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	mov	ecx, ebx
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H
	test	edi, edi
	jne	SHORT $LN4@soap_in_xs@7
	pop	edi
	pop	ebx

; 2250 : 	{	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], 3
	pop	esi
	pop	ebp

; 2261 : 		return NULL;
; 2262 : 	return a;
; 2263 : }

	ret	0
$LN4@soap_in_xs@7:

; 2251 : 		return NULL;
; 2252 : 	}
; 2253 : 	soap_revert(soap);

	cmp	WORD PTR [esi+87308], 0
	jne	SHORT $LN10@soap_in_xs@7
	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	WORD PTR [esi+87308], ax
	je	SHORT $LN10@soap_in_xs@7
	dec	DWORD PTR [esi+12444]
$LN10@soap_in_xs@7:

; 2254 : 	*soap->id = '\0';
; 2255 : 	if (soap->alloced)

	cmp	WORD PTR [esi+87306], 0
	mov	BYTE PTR [ebx], 0
	je	SHORT $LN2@soap_in_xs@7

; 2256 : 	{	a->soap_default(soap);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]
	push	esi
	mov	ecx, edi
	call	eax

; 2257 : 		if (soap->clist->type != SOAP_TYPE_xsd__int)

	mov	ecx, DWORD PTR [esi+96]
	cmp	DWORD PTR [ecx+8], 14			; 0000000eH
	je	SHORT $LN2@soap_in_xs@7

; 2258 : 			return (xsd__int *)a->soap_in(soap, tag, type);

	mov	eax, DWORD PTR _type$[esp+12]
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+24]
	push	eax
	push	ebp
	push	esi
	mov	ecx, edi
	call	edx
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 2261 : 		return NULL;
; 2262 : 	return a;
; 2263 : }

	ret	0
$LN2@soap_in_xs@7:

; 2259 : 	}
; 2260 : 	if (!soap_in_int(soap, tag, &(a->xsd__int::__item), "xsd:int"))

	push	OFFSET ??_C@_07PCIGPDP@xsd?3int?$AA@
	lea	eax, DWORD PTR [edi+12]
	push	eax
	push	ebp
	push	esi
	call	_soap_inint
	add	esp, 16					; 00000010H
	neg	eax
	sbb	eax, eax
	and	eax, edi
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 2261 : 		return NULL;
; 2262 : 	return a;
; 2263 : }

	ret	0
?soap_in_xsd__int@@YAPAVxsd__int@@PAUsoap@@PBDPAV1@1@Z ENDP ; soap_in_xsd__int
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in@xsd__int@@UAEPAXPAUsoap@@PBD1@Z PROC		; xsd__int::soap_in
; _this$ = ecx

; 2242 : {	return soap_in_xsd__int(soap, tag, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	ecx
	call	?soap_in_xsd__int@@YAPAVxsd__int@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__int
	add	esp, 12					; 0000000cH

; 2243 : }

	ret	12					; 0000000cH
?soap_in@xsd__int@@UAEPAXPAUsoap@@PBD1@Z ENDP		; xsd__int::soap_in
_TEXT	ENDS
PUBLIC	?soap_in_xsd__long@@YAPAVxsd__long@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__long
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in_xsd__long@@YAPAVxsd__long@@PAUsoap@@PBDPAV1@1@Z PROC ; soap_in_xsd__long
; _soap$ = eax

; 2137 : {

	push	ebp
	mov	ebp, DWORD PTR _tag$[esp]
	push	esi
	mov	esi, eax

; 2138 : 	if (soap_element_begin_in(soap, tag, 1, NULL))

	push	0
	push	1
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@soap_in_xs@8
	pop	esi

; 2139 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 2152 : 		return NULL;
; 2153 : 	return a;
; 2154 : }

	ret	0
$LN5@soap_in_xs@8:

; 2140 : 	if (!(a = (xsd__long *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__long, sizeof(xsd__long), soap->type, soap->arrayType)))

	mov	edx, DWORD PTR _a$[esp+4]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	lea	ecx, DWORD PTR [esi+83124]
	push	ecx
	push	24					; 00000018H
	push	15					; 0000000fH
	push	edx
	lea	ebx, DWORD PTR [esi+81076]
	push	esi
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	mov	ecx, ebx
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H
	test	edi, edi
	jne	SHORT $LN4@soap_in_xs@8
	pop	edi
	pop	ebx

; 2141 : 	{	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], 3
	pop	esi
	pop	ebp

; 2152 : 		return NULL;
; 2153 : 	return a;
; 2154 : }

	ret	0
$LN4@soap_in_xs@8:

; 2142 : 		return NULL;
; 2143 : 	}
; 2144 : 	soap_revert(soap);

	cmp	WORD PTR [esi+87308], 0
	jne	SHORT $LN10@soap_in_xs@8
	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	WORD PTR [esi+87308], ax
	je	SHORT $LN10@soap_in_xs@8
	dec	DWORD PTR [esi+12444]
$LN10@soap_in_xs@8:

; 2145 : 	*soap->id = '\0';
; 2146 : 	if (soap->alloced)

	cmp	WORD PTR [esi+87306], 0
	mov	BYTE PTR [ebx], 0
	je	SHORT $LN2@soap_in_xs@8

; 2147 : 	{	a->soap_default(soap);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]
	push	esi
	mov	ecx, edi
	call	eax

; 2148 : 		if (soap->clist->type != SOAP_TYPE_xsd__long)

	mov	ecx, DWORD PTR [esi+96]
	cmp	DWORD PTR [ecx+8], 15			; 0000000fH
	je	SHORT $LN2@soap_in_xs@8

; 2149 : 			return (xsd__long *)a->soap_in(soap, tag, type);

	mov	eax, DWORD PTR _type$[esp+12]
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+24]
	push	eax
	push	ebp
	push	esi
	mov	ecx, edi
	call	edx
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 2152 : 		return NULL;
; 2153 : 	return a;
; 2154 : }

	ret	0
$LN2@soap_in_xs@8:

; 2150 : 	}
; 2151 : 	if (!soap_in_LONG64(soap, tag, &(a->xsd__long::__item), "xsd:long"))

	push	OFFSET ??_C@_08PNDIDGIB@xsd?3long?$AA@
	lea	eax, DWORD PTR [edi+16]
	push	eax
	push	ebp
	mov	eax, esi
	call	_soap_inLONG64
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	and	eax, edi
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 2152 : 		return NULL;
; 2153 : 	return a;
; 2154 : }

	ret	0
?soap_in_xsd__long@@YAPAVxsd__long@@PAUsoap@@PBDPAV1@1@Z ENDP ; soap_in_xsd__long
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in@xsd__long@@UAEPAXPAUsoap@@PBD1@Z PROC		; xsd__long::soap_in
; _this$ = ecx

; 2133 : {	return soap_in_xsd__long(soap, tag, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	ecx
	call	?soap_in_xsd__long@@YAPAVxsd__long@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__long
	add	esp, 12					; 0000000cH

; 2134 : }

	ret	12					; 0000000cH
?soap_in@xsd__long@@UAEPAXPAUsoap@@PBD1@Z ENDP		; xsd__long::soap_in
_TEXT	ENDS
PUBLIC	?soap_in_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAV12@1@Z ; soap_in_std__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
?soap_in_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAV12@1@Z PROC ; soap_in_std__string
; _soap$ = ecx
; _s$ = eax

; 1912 : {

	push	esi
	push	edi
	mov	edi, eax
	mov	esi, ecx

; 1913 : 	if (soap_element_begin_in(soap, tag, 1, NULL))
; 1914 : 		return NULL;
; 1915 : 	if (!s)

	test	edi, edi
	jne	SHORT $LN9@soap_in_st@3

; 1916 : 		s = soap_new_std__string(soap, -1);

	mov	edi, esi
	call	?soap_new_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@H@Z ; soap_new_std__string
	mov	edi, eax
$LN9@soap_in_st@3:

; 1917 : 	if (soap->null)

	cmp	WORD PTR [esi+87300], 0
	je	SHORT $LN7@soap_in_st@3

; 1918 : 		if (s)

	test	edi, edi
	je	SHORT $LN7@soap_in_st@3

; 1919 : 			s->erase();

	push	-1
	push	0
	mov	ecx, edi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
$LN7@soap_in_st@3:

; 1920 : 	if (soap->body && !*soap->href)

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN6@soap_in_st@3
	cmp	BYTE PTR [esi+82100], 0
	jne	SHORT $LN6@soap_in_st@3

; 1921 : 	{	
; 1922 : 		char *t;
; 1923 : 		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);

	lea	eax, DWORD PTR [esi+84148]
	push	eax
	lea	ecx, DWORD PTR [esi+83124]
	push	ecx
	push	28					; 0000001cH
	push	18					; 00000012H
	push	edi
	lea	ecx, DWORD PTR [esi+81076]
	push	esi
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H

; 1924 : 		if (s)

	test	edi, edi
	je	SHORT $LN2@soap_in_st@3

; 1925 : 		{
; 1926 : 			if ((t = soap_string_in(soap, 1, -1, -1)))

	push	1
	mov	ecx, esi
	call	_soap_string_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@soap_in_st@3

; 1927 : 				s->assign(t);

	push	eax
	mov	ecx, edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1928 : 			else

	jmp	SHORT $LN2@soap_in_st@3
$LN4@soap_in_st@3:
	pop	edi

; 1929 : 				return NULL;

	xor	eax, eax
	pop	esi

; 1937 : }

	ret	0
$LN6@soap_in_st@3:

; 1930 : 		}
; 1931 : 	}
; 1932 : 	else
; 1933 : 		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);

	lea	edx, DWORD PTR [esi+84148]
	push	edx
	lea	eax, DWORD PTR [esi+83124]
	push	eax
	push	28					; 0000001cH
	push	18					; 00000012H
	push	edi
	lea	ecx, DWORD PTR [esi+81076]
	push	esi
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	call	_soap_id_enter
	push	OFFSET ?soap_copy_std__string@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy_std__string
	push	28					; 0000001cH
	push	0
	push	18					; 00000012H
	push	0
	push	eax
	lea	eax, DWORD PTR [esi+82100]
	push	esi
	call	_soap_id_forward
	add	esp, 52					; 00000034H
	mov	edi, eax
$LN2@soap_in_st@3:

; 1934 : 	if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN1@soap_in_st@3
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	ecx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 1935 : 		return NULL;

	jne	SHORT $LN4@soap_in_st@3
$LN1@soap_in_st@3:

; 1936 : 	return s;

	mov	eax, edi
	pop	edi
	pop	esi

; 1937 : }

	ret	0
?soap_in_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAV12@1@Z ENDP ; soap_in_std__string
_TEXT	ENDS
PUBLIC	?soap_in__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PBDPAV1@1@Z PROC ; soap_in__ns2__getSessionIDResponseElement
; _soap$ = eax

; 1652 : {

	push	ebp

; 1653 : 	if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	ebp, DWORD PTR _tag$[esp]
	push	esi
	mov	esi, eax
	push	0
	push	0
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@soap_in__n
	pop	esi

; 1654 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 1698 : }

	ret	0
$LN16@soap_in__n:

; 1655 : 	a = (_ns2__getSessionIDResponseElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getSessionIDResponseElement, sizeof(_ns2__getSessionIDResponseElement), soap->type, soap->arrayType);

	mov	edx, DWORD PTR _a$[esp+4]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	lea	ecx, DWORD PTR [esi+83124]
	push	ecx
	push	12					; 0000000cH
	push	20					; 00000014H
	push	edx
	lea	ebx, DWORD PTR [esi+81076]
	push	esi
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	mov	ecx, ebx
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H

; 1656 : 	if (!a)

	test	edi, edi

; 1657 : 		return NULL;

	je	$LN32@soap_in__n

; 1658 : 	if (soap->alloced)

	cmp	WORD PTR [esi+87306], 0
	je	SHORT $LN35@soap_in__n

; 1659 : 	{	a->soap_default(soap);

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+4]
	push	esi
	mov	ecx, edi
	call	edx

; 1660 : 		if (soap->clist->type != SOAP_TYPE__ns2__getSessionIDResponseElement)

	mov	eax, DWORD PTR [esi+96]
	cmp	DWORD PTR [eax+8], 20			; 00000014H
	je	SHORT $LN35@soap_in__n

; 1661 : 		{	soap_revert(soap);

	mov	eax, esi
	call	_soap_revert

; 1662 : 			*soap->id = '\0';
; 1663 : 			return (_ns2__getSessionIDResponseElement *)a->soap_in(soap, tag, type);

	mov	eax, DWORD PTR _type$[esp+12]
	push	eax
	mov	BYTE PTR [ebx], 0
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+24]
	push	ebp
	push	esi
	mov	ecx, edi
	call	edx
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 1698 : }

	ret	0
$LN35@soap_in__n:

; 1664 : 		}
; 1665 : 	}
; 1666 : 	size_t soap_flag_result1 = 1;
; 1667 : 	if (soap->body && !*soap->href)

	cmp	WORD PTR [esi+12442], 0
	mov	ebx, 1
	je	$LN12@soap_in__n
	cmp	BYTE PTR [esi+82100], 0
	jne	$LN12@soap_in__n
	mov	ebp, 3
	npad	7
$LL11@soap_in__n:

; 1668 : 	{
; 1669 : 		for (;;)
; 1670 : 		{	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], ebp

; 1671 : 			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)

	test	ebx, ebx
	je	SHORT $LN34@soap_in__n

; 1672 : 				if (soap_in_int(soap, "ns2:result", &(a->_ns2__getSessionIDResponseElement::result), "xsd:int"))

	push	OFFSET ??_C@_07PCIGPDP@xsd?3int?$AA@
	lea	eax, DWORD PTR [edi+4]
	push	eax
	push	OFFSET ??_C@_0L@FEKNHBLL@ns2?3result?$AA@
	push	esi
	call	_soap_inint
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN34@soap_in__n

; 1673 : 				{	soap_flag_result1--;

	dec	ebx

; 1674 : 					continue;

	jmp	SHORT $LL11@soap_in__n
$LN34@soap_in__n:

; 1675 : 				}
; 1676 : 			/* transient soap skipped */
; 1677 : 			soap_check_result(soap, "ns2:result");

	cmp	WORD PTR [esi+6], 2
	jne	SHORT $LN23@soap_in__n
	mov	eax, esi
	call	_soap_check_result
$LN23@soap_in__n:

; 1678 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], ebp
	jne	SHORT $LN7@soap_in__n

; 1679 : 				soap->error = soap_ignore_element(soap);

	push	esi
	call	?soap_ignore_element@@YAHPAUsoap@@@Z	; soap_ignore_element
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
$LN7@soap_in__n:

; 1680 : 			if (soap->error == SOAP_NO_TAG)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 6
	je	SHORT $LN31@soap_in__n

; 1681 : 				break;
; 1682 : 			if (soap->error)

	test	eax, eax
	je	SHORT $LL11@soap_in__n
	pop	edi
	pop	ebx
	pop	esi

; 1695 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 1698 : }

	ret	0
$LN31@soap_in__n:

; 1683 : 				return NULL;
; 1684 : 		}
; 1685 : 		if (soap_element_end_in(soap, tag))

	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@soap_in__n
	pop	edi
	pop	ebx
	pop	esi

; 1686 : 			return NULL;

	xor	eax, eax
	pop	ebp

; 1698 : }

	ret	0
$LN12@soap_in__n:

; 1687 : 	}
; 1688 : 	else
; 1689 : 	{	a = (_ns2__getSessionIDResponseElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getSessionIDResponseElement, 0, sizeof(_ns2__getSessionIDResponseElement), 0, soap_copy__ns2__getSessionIDResponseElement);

	push	OFFSET ?soap_copy__ns2__getSessionIDResponseElement@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy__ns2__getSessionIDResponseElement
	push	12					; 0000000cH
	push	0
	push	20					; 00000014H
	push	0
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH

; 1690 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN33@soap_in__n
	push	ebp
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN33@soap_in__n
	pop	edi
	pop	ebx
	pop	esi

; 1691 : 			return NULL;

	xor	eax, eax
	pop	ebp

; 1698 : }

	ret	0
$LN2@soap_in__n:

; 1692 : 	}
; 1693 : 	if ((soap_flag_result1 > 0))

	test	ebx, ebx
	jbe	SHORT $LN1@soap_in__n
$LN33@soap_in__n:

; 1694 : 	{	soap->error = SOAP_OCCURS;

	mov	DWORD PTR [esi+90460], 44		; 0000002cH
$LN32@soap_in__n:
	pop	edi
	pop	ebx
	pop	esi

; 1695 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 1698 : }

	ret	0
$LN1@soap_in__n:

; 1696 : 	}
; 1697 : 	return a;

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 1698 : }

	ret	0
?soap_in__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PBDPAV1@1@Z ENDP ; soap_in__ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in@_ns2__getSessionIDResponseElement@@UAEPAXPAUsoap@@PBD1@Z PROC ; _ns2__getSessionIDResponseElement::soap_in
; _this$ = ecx

; 1648 : {	return soap_in__ns2__getSessionIDResponseElement(soap, tag, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	ecx
	call	?soap_in__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSessionIDResponseElement
	add	esp, 12					; 0000000cH

; 1649 : }

	ret	12					; 0000000cH
?soap_in@_ns2__getSessionIDResponseElement@@UAEPAXPAUsoap@@PBD1@Z ENDP ; _ns2__getSessionIDResponseElement::soap_in
_TEXT	ENDS
PUBLIC	?soap_in__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@PBDPAV1@1@Z PROC ; soap_in__ns2__getSettingsFileElement
; _soap$ = eax

; 1510 : {

	push	ebp

; 1511 : 	if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	ebp, DWORD PTR _tag$[esp]
	push	esi
	mov	esi, eax
	push	0
	push	0
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@soap_in__n@2
	pop	esi

; 1512 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 1555 : }

	ret	0
$LN16@soap_in__n@2:

; 1513 : 	a = (_ns2__getSettingsFileElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getSettingsFileElement, sizeof(_ns2__getSettingsFileElement), soap->type, soap->arrayType);

	mov	edx, DWORD PTR _a$[esp+4]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	lea	ecx, DWORD PTR [esi+83124]
	push	ecx
	push	12					; 0000000cH
	push	21					; 00000015H
	push	edx
	lea	ebx, DWORD PTR [esi+81076]
	push	esi
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	mov	ecx, ebx
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H

; 1514 : 	if (!a)

	test	edi, edi

; 1515 : 		return NULL;

	je	$LN26@soap_in__n@2

; 1516 : 	if (soap->alloced)

	cmp	WORD PTR [esi+87306], 0
	je	SHORT $LN29@soap_in__n@2

; 1517 : 	{	a->soap_default(soap);

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+4]
	push	esi
	mov	ecx, edi
	call	edx

; 1518 : 		if (soap->clist->type != SOAP_TYPE__ns2__getSettingsFileElement)

	mov	eax, DWORD PTR [esi+96]
	cmp	DWORD PTR [eax+8], 21			; 00000015H
	je	SHORT $LN29@soap_in__n@2

; 1519 : 		{	soap_revert(soap);

	mov	eax, esi
	call	_soap_revert

; 1520 : 			*soap->id = '\0';
; 1521 : 			return (_ns2__getSettingsFileElement *)a->soap_in(soap, tag, type);

	mov	eax, DWORD PTR _type$[esp+12]
	push	eax
	mov	BYTE PTR [ebx], 0
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+24]
	push	ebp
	push	esi
	mov	ecx, edi
	call	edx
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 1555 : }

	ret	0
$LN29@soap_in__n@2:

; 1522 : 		}
; 1523 : 	}
; 1524 : 	size_t soap_flag_int_USCORE11 = 1;
; 1525 : 	if (soap->body && !*soap->href)

	cmp	WORD PTR [esi+12442], 0
	mov	ebx, 1
	je	SHORT $LN12@soap_in__n@2
	cmp	BYTE PTR [esi+82100], 0
	jne	SHORT $LN12@soap_in__n@2
	mov	ebp, 3
$LL11@soap_in__n@2:

; 1526 : 	{
; 1527 : 		for (;;)
; 1528 : 		{	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], ebp

; 1529 : 			if (soap_flag_int_USCORE11 && soap->error == SOAP_TAG_MISMATCH)

	test	ebx, ebx
	je	SHORT $LN28@soap_in__n@2

; 1530 : 				if (soap_in_int(soap, "ns2:int_1", &(a->_ns2__getSettingsFileElement::int_USCORE1), "xsd:int"))

	push	OFFSET ??_C@_07PCIGPDP@xsd?3int?$AA@
	lea	eax, DWORD PTR [edi+4]
	push	eax
	push	OFFSET ??_C@_09JNJHDMAM@ns2?3int_1?$AA@
	push	esi
	call	_soap_inint
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN8@soap_in__n@2

; 1531 : 				{	soap_flag_int_USCORE11--;

	dec	ebx

; 1532 : 					continue;

	jmp	SHORT $LL11@soap_in__n@2
$LN8@soap_in__n@2:

; 1533 : 				}
; 1534 : 			/* transient soap skipped */
; 1535 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], ebp
	jne	SHORT $LN7@soap_in__n@2
$LN28@soap_in__n@2:

; 1536 : 				soap->error = soap_ignore_element(soap);

	push	esi
	call	?soap_ignore_element@@YAHPAUsoap@@@Z	; soap_ignore_element
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
$LN7@soap_in__n@2:

; 1537 : 			if (soap->error == SOAP_NO_TAG)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 6
	je	SHORT $LN25@soap_in__n@2

; 1538 : 				break;
; 1539 : 			if (soap->error)

	test	eax, eax
	je	SHORT $LL11@soap_in__n@2
	pop	edi
	pop	ebx
	pop	esi

; 1552 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 1555 : }

	ret	0
$LN25@soap_in__n@2:

; 1540 : 				return NULL;
; 1541 : 		}
; 1542 : 		if (soap_element_end_in(soap, tag))

	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@soap_in__n@2
	pop	edi
	pop	ebx
	pop	esi

; 1543 : 			return NULL;

	xor	eax, eax
	pop	ebp

; 1555 : }

	ret	0
$LN12@soap_in__n@2:

; 1544 : 	}
; 1545 : 	else
; 1546 : 	{	a = (_ns2__getSettingsFileElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getSettingsFileElement, 0, sizeof(_ns2__getSettingsFileElement), 0, soap_copy__ns2__getSettingsFileElement);

	push	OFFSET ?soap_copy__ns2__getSettingsFileElement@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy__ns2__getSettingsFileElement
	push	12					; 0000000cH
	push	0
	push	21					; 00000015H
	push	0
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH

; 1547 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN27@soap_in__n@2
	push	ebp
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN27@soap_in__n@2
	pop	edi
	pop	ebx
	pop	esi

; 1548 : 			return NULL;

	xor	eax, eax
	pop	ebp

; 1555 : }

	ret	0
$LN2@soap_in__n@2:

; 1549 : 	}
; 1550 : 	if ((soap_flag_int_USCORE11 > 0))

	test	ebx, ebx
	jbe	SHORT $LN1@soap_in__n@2
$LN27@soap_in__n@2:

; 1551 : 	{	soap->error = SOAP_OCCURS;

	mov	DWORD PTR [esi+90460], 44		; 0000002cH
$LN26@soap_in__n@2:
	pop	edi
	pop	ebx
	pop	esi

; 1552 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 1555 : }

	ret	0
$LN1@soap_in__n@2:

; 1553 : 	}
; 1554 : 	return a;

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 1555 : }

	ret	0
?soap_in__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@PBDPAV1@1@Z ENDP ; soap_in__ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in@_ns2__getSettingsFileElement@@UAEPAXPAUsoap@@PBD1@Z PROC ; _ns2__getSettingsFileElement::soap_in
; _this$ = ecx

; 1506 : {	return soap_in__ns2__getSettingsFileElement(soap, tag, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	ecx
	call	?soap_in__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSettingsFileElement
	add	esp, 12					; 0000000cH

; 1507 : }

	ret	12					; 0000000cH
?soap_in@_ns2__getSettingsFileElement@@UAEPAXPAUsoap@@PBD1@Z ENDP ; _ns2__getSettingsFileElement::soap_in
_TEXT	ENDS
PUBLIC	?soap_in__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PBDPAV1@1@Z PROC ; soap_in__ns2__submitEpochResultResponseElement
; _soap$ = eax

; 1030 : {

	push	ebp

; 1031 : 	if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	ebp, DWORD PTR _tag$[esp]
	push	esi
	mov	esi, eax
	push	0
	push	0
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@soap_in__n@3
	pop	esi

; 1032 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 1076 : }

	ret	0
$LN16@soap_in__n@3:

; 1033 : 	a = (_ns2__submitEpochResultResponseElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__submitEpochResultResponseElement, sizeof(_ns2__submitEpochResultResponseElement), soap->type, soap->arrayType);

	mov	edx, DWORD PTR _a$[esp+4]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	lea	ecx, DWORD PTR [esi+83124]
	push	ecx
	push	12					; 0000000cH
	push	24					; 00000018H
	push	edx
	lea	ebx, DWORD PTR [esi+81076]
	push	esi
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	mov	ecx, ebx
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H

; 1034 : 	if (!a)

	test	edi, edi

; 1035 : 		return NULL;

	je	$LN30@soap_in__n@3

; 1036 : 	if (soap->alloced)

	cmp	WORD PTR [esi+87306], 0
	je	SHORT $LN33@soap_in__n@3

; 1037 : 	{	a->soap_default(soap);

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+4]
	push	esi
	mov	ecx, edi
	call	edx

; 1038 : 		if (soap->clist->type != SOAP_TYPE__ns2__submitEpochResultResponseElement)

	mov	eax, DWORD PTR [esi+96]
	cmp	DWORD PTR [eax+8], 24			; 00000018H
	je	SHORT $LN33@soap_in__n@3

; 1039 : 		{	soap_revert(soap);

	mov	eax, esi
	call	_soap_revert

; 1040 : 			*soap->id = '\0';
; 1041 : 			return (_ns2__submitEpochResultResponseElement *)a->soap_in(soap, tag, type);

	mov	eax, DWORD PTR _type$[esp+12]
	push	eax
	mov	BYTE PTR [ebx], 0
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+24]
	push	ebp
	push	esi
	mov	ecx, edi
	call	edx
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 1076 : }

	ret	0
$LN33@soap_in__n@3:

; 1042 : 		}
; 1043 : 	}
; 1044 : 	size_t soap_flag_result1 = 1;
; 1045 : 	if (soap->body && !*soap->href)

	cmp	WORD PTR [esi+12442], 0
	mov	ebx, 1
	je	$LN12@soap_in__n@3
	cmp	BYTE PTR [esi+82100], 0
	jne	$LN12@soap_in__n@3
	mov	ebp, 3
	npad	7
$LL11@soap_in__n@3:

; 1046 : 	{
; 1047 : 		for (;;)
; 1048 : 		{	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], ebp

; 1049 : 			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)

	test	ebx, ebx
	je	SHORT $LN32@soap_in__n@3

; 1050 : 				if (soap_in_bool(soap, "ns2:result", &(a->_ns2__submitEpochResultResponseElement::result), "xsd:boolean"))

	push	OFFSET ??_C@_0M@FGHMEICI@xsd?3boolean?$AA@
	lea	eax, DWORD PTR [edi+4]
	push	eax
	push	OFFSET ??_C@_0L@FEKNHBLL@ns2?3result?$AA@
	mov	eax, esi
	call	?soap_in_bool@@YAPA_NPAUsoap@@PBDPA_N1@Z ; soap_in_bool
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN32@soap_in__n@3

; 1051 : 				{	soap_flag_result1--;

	dec	ebx

; 1052 : 					continue;

	jmp	SHORT $LL11@soap_in__n@3
$LN32@soap_in__n@3:

; 1053 : 				}
; 1054 : 			/* transient soap skipped */
; 1055 : 			soap_check_result(soap, "ns2:result");

	cmp	WORD PTR [esi+6], 2
	jne	SHORT $LN21@soap_in__n@3
	mov	eax, esi
	call	_soap_check_result
$LN21@soap_in__n@3:

; 1056 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], ebp
	jne	SHORT $LN7@soap_in__n@3

; 1057 : 				soap->error = soap_ignore_element(soap);

	push	esi
	call	?soap_ignore_element@@YAHPAUsoap@@@Z	; soap_ignore_element
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
$LN7@soap_in__n@3:

; 1058 : 			if (soap->error == SOAP_NO_TAG)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 6
	je	SHORT $LN29@soap_in__n@3

; 1059 : 				break;
; 1060 : 			if (soap->error)

	test	eax, eax
	je	SHORT $LL11@soap_in__n@3
	pop	edi
	pop	ebx
	pop	esi

; 1073 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 1076 : }

	ret	0
$LN29@soap_in__n@3:

; 1061 : 				return NULL;
; 1062 : 		}
; 1063 : 		if (soap_element_end_in(soap, tag))

	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@soap_in__n@3
	pop	edi
	pop	ebx
	pop	esi

; 1064 : 			return NULL;

	xor	eax, eax
	pop	ebp

; 1076 : }

	ret	0
$LN12@soap_in__n@3:

; 1065 : 	}
; 1066 : 	else
; 1067 : 	{	a = (_ns2__submitEpochResultResponseElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__submitEpochResultResponseElement, 0, sizeof(_ns2__submitEpochResultResponseElement), 0, soap_copy__ns2__submitEpochResultResponseElement);

	push	OFFSET ?soap_copy__ns2__submitEpochResultResponseElement@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy__ns2__submitEpochResultResponseElement
	push	12					; 0000000cH
	push	0
	push	24					; 00000018H
	push	0
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH

; 1068 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN31@soap_in__n@3
	push	ebp
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN31@soap_in__n@3
	pop	edi
	pop	ebx
	pop	esi

; 1069 : 			return NULL;

	xor	eax, eax
	pop	ebp

; 1076 : }

	ret	0
$LN2@soap_in__n@3:

; 1070 : 	}
; 1071 : 	if ((soap_flag_result1 > 0))

	test	ebx, ebx
	jbe	SHORT $LN1@soap_in__n@3
$LN31@soap_in__n@3:

; 1072 : 	{	soap->error = SOAP_OCCURS;

	mov	DWORD PTR [esi+90460], 44		; 0000002cH
$LN30@soap_in__n@3:
	pop	edi
	pop	ebx
	pop	esi

; 1073 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 1076 : }

	ret	0
$LN1@soap_in__n@3:

; 1074 : 	}
; 1075 : 	return a;

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 1076 : }

	ret	0
?soap_in__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PBDPAV1@1@Z ENDP ; soap_in__ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in@_ns2__submitEpochResultResponseElement@@UAEPAXPAUsoap@@PBD1@Z PROC ; _ns2__submitEpochResultResponseElement::soap_in
; _this$ = ecx

; 1026 : {	return soap_in__ns2__submitEpochResultResponseElement(soap, tag, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	ecx
	call	?soap_in__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__submitEpochResultResponseElement
	add	esp, 12					; 0000000cH

; 1027 : }

	ret	12					; 0000000cH
?soap_in@_ns2__submitEpochResultResponseElement@@UAEPAXPAUsoap@@PBD1@Z ENDP ; _ns2__submitEpochResultResponseElement::soap_in
_TEXT	ENDS
PUBLIC	_soap_putfault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_putfault PROC
; _soap$ = esi

; 74   : {

	push	edi

; 75   : 	if (soap->fault)

	mov	edi, DWORD PTR [esi+12208]
	test	edi, edi
	je	SHORT $LN1@soap_putfa

; 76   : 		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);

	push	esi
	mov	edx, 47					; 0000002fH
	mov	eax, edi
	call	_soap_embed
	push	eax
	mov	eax, edi
	mov	ecx, esi
	call	?soap_out_SOAP_ENV__Fault@@YAHPAUsoap@@PBDHPBUSOAP_ENV__Fault@@1@Z ; soap_out_SOAP_ENV__Fault
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@soap_putfa
	mov	eax, DWORD PTR [esi+90460]
	pop	edi

; 78   : }

	ret	0

; 76   : 		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);

$LN4@soap_putfa:
	push	esi
	call	?soap_putindependent@@YAHPAUsoap@@@Z	; soap_putindependent
	add	esp, 4
	pop	edi

; 78   : }

	ret	0
$LN1@soap_putfa:

; 77   : 	return SOAP_OK;

	xor	eax, eax
	pop	edi

; 78   : }

	ret	0
_soap_putfault ENDP
PUBLIC	?soap_in_PointerTostd__string@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAPAV12@1@Z ; soap_in_PointerTostd__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
?soap_in_PointerTostd__string@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAPAV12@1@Z PROC ; soap_in_PointerTostd__string
; _soap$ = ecx
; _a$ = eax

; 4231 : {

	push	ebx
	mov	ebx, DWORD PTR _tag$[esp]
	push	esi
	push	edi
	mov	edi, eax

; 4232 : 	if (soap_element_begin_in(soap, tag, 1, NULL))

	push	0
	mov	esi, ecx
	push	1
	mov	eax, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax

; 4233 : 		return NULL;

	jne	SHORT $LN26@soap_in_Po@9

; 4234 : 	if (!a)

	test	edi, edi
	jne	SHORT $LN5@soap_in_Po@9

; 4235 : 		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))

	lea	eax, DWORD PTR [edi+4]
	mov	edi, esi
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi

; 4236 : 			return NULL;

	je	SHORT $LN26@soap_in_Po@9
$LN5@soap_in_Po@9:

; 4237 : 	*a = NULL;

	mov	DWORD PTR [edi], 0

; 4238 : 	if (!soap->null && *soap->href != '#')

	cmp	WORD PTR [esi+87300], 0
	jne	SHORT $LN4@soap_in_Po@9
	cmp	BYTE PTR [esi+82100], 35		; 00000023H
	je	SHORT $LN4@soap_in_Po@9
	push	ebp

; 4239 : 	{	soap_revert(soap);

	mov	eax, esi
	call	_soap_revert

; 4240 : 		if (!(*a = soap_in_std__string(soap, tag, *a, type)))

	mov	ebp, DWORD PTR [edi]
	push	0
	push	1
	mov	eax, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@soap_in_Po@9
	xor	eax, eax
	jmp	SHORT $LN20@soap_in_Po@9
$LN25@soap_in_Po@9:
	push	ebx
	mov	eax, ebp
	mov	ecx, esi
	call	?soap_in_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAV12@1@Z ; soap_in_std__string
	add	esp, 4
$LN20@soap_in_Po@9:
	mov	DWORD PTR [edi], eax
	pop	ebp
	test	eax, eax
	jne	SHORT $LN1@soap_in_Po@9
$LN26@soap_in_Po@9:
	pop	edi
	pop	esi

; 4241 : 			return NULL;

	xor	eax, eax
	pop	ebx

; 4249 : }

	ret	0
$LN4@soap_in_Po@9:

; 4242 : 	}
; 4243 : 	else
; 4244 : 	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);

	push	28					; 0000001cH
	push	18					; 00000012H
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	mov	ecx, esi
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH

; 4245 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in_Po@9
	push	ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 4246 : 			return NULL;

	jne	SHORT $LN26@soap_in_Po@9
$LN1@soap_in_Po@9:

; 4247 : 	}
; 4248 : 	return a;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 4249 : }

	ret	0
?soap_in_PointerTostd__string@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAPAV12@1@Z ENDP ; soap_in_PointerTostd__string
_TEXT	ENDS
PUBLIC	?soap_in_xsd__string@@YAPAVxsd__string@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in_xsd__string@@YAPAVxsd__string@@PAUsoap@@PBDPAV1@1@Z PROC ; soap_in_xsd__string
; _soap$ = eax

; 2028 : {

	push	ebp
	mov	ebp, DWORD PTR _tag$[esp]
	push	esi
	mov	esi, eax

; 2029 : 	if (soap_element_begin_in(soap, tag, 1, NULL))

	push	0
	push	1
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@soap_in_xs@9
	pop	esi

; 2030 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 2045 : }

	ret	0
$LN5@soap_in_xs@9:

; 2031 : 	if (!(a = (xsd__string *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string, sizeof(xsd__string), soap->type, soap->arrayType)))

	mov	edx, DWORD PTR _a$[esp+4]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	lea	ecx, DWORD PTR [esi+83124]
	push	ecx
	push	40					; 00000028H
	push	17					; 00000011H
	push	edx
	lea	ebx, DWORD PTR [esi+81076]
	push	esi
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	mov	ecx, ebx
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H
	test	edi, edi
	jne	SHORT $LN4@soap_in_xs@9

; 2032 : 	{	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], 3
$LN30@soap_in_xs@9:
	pop	edi
	pop	ebx
	pop	esi

; 2033 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 2045 : }

	ret	0
$LN4@soap_in_xs@9:

; 2034 : 	}
; 2035 : 	soap_revert(soap);

	cmp	WORD PTR [esi+87308], 0
	jne	SHORT $LN31@soap_in_xs@9
	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	WORD PTR [esi+87308], ax
	je	SHORT $LN31@soap_in_xs@9
	dec	DWORD PTR [esi+12444]
$LN31@soap_in_xs@9:

; 2036 : 	*soap->id = '\0';
; 2037 : 	if (soap->alloced)

	cmp	WORD PTR [esi+87306], 0
	mov	BYTE PTR [ebx], 0
	je	SHORT $LN32@soap_in_xs@9

; 2038 : 	{	a->soap_default(soap);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]
	push	esi
	mov	ecx, edi
	call	eax

; 2039 : 		if (soap->clist->type != SOAP_TYPE_xsd__string)

	mov	ecx, DWORD PTR [esi+96]
	cmp	DWORD PTR [ecx+8], 17			; 00000011H
	je	SHORT $LN32@soap_in_xs@9

; 2040 : 			return (xsd__string *)a->soap_in(soap, tag, type);

	mov	eax, DWORD PTR _type$[esp+12]
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+24]
	push	eax
	push	ebp
	push	esi
	mov	ecx, edi
	call	edx
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 2045 : }

	ret	0
$LN32@soap_in_xs@9:

; 2041 : 	}
; 2042 : 	if (!soap_in_std__string(soap, tag, &(a->xsd__string::__item), "xsd:string"))

	push	0
	push	1
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@soap_in_xs@9
	lea	eax, DWORD PTR [edi+12]
	push	ebp
	mov	ecx, esi
	call	?soap_in_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAV12@1@Z ; soap_in_std__string
	add	esp, 4
	test	eax, eax

; 2043 : 		return NULL;

	je	$LN30@soap_in_xs@9

; 2044 : 	return a;

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 2045 : }

	ret	0
?soap_in_xsd__string@@YAPAVxsd__string@@PAUsoap@@PBDPAV1@1@Z ENDP ; soap_in_xsd__string
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in@xsd__string@@UAEPAXPAUsoap@@PBD1@Z PROC	; xsd__string::soap_in
; _this$ = ecx

; 2024 : {	return soap_in_xsd__string(soap, tag, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	ecx
	call	?soap_in_xsd__string@@YAPAVxsd__string@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__string
	add	esp, 12					; 0000000cH

; 2025 : }

	ret	12					; 0000000cH
?soap_in@xsd__string@@UAEPAXPAUsoap@@PBD1@Z ENDP	; xsd__string::soap_in
_TEXT	ENDS
PUBLIC	?soap_in__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@PBDPAV1@1@Z PROC ; soap_in__ns2__getSessionIDElement
; _soap$ = eax

; 1795 : {

	push	ebp

; 1796 : 	if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	ebp, DWORD PTR _tag$[esp]
	push	esi
	mov	esi, eax
	push	0
	push	0
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@soap_in__n@4
	pop	esi

; 1797 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 1836 : }

	ret	0
$LN16@soap_in__n@4:

; 1798 : 	a = (_ns2__getSessionIDElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getSessionIDElement, sizeof(_ns2__getSessionIDElement), soap->type, soap->arrayType);

	mov	edx, DWORD PTR _a$[esp+4]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	lea	ecx, DWORD PTR [esi+83124]
	push	ecx
	push	12					; 0000000cH
	push	19					; 00000013H
	push	edx
	lea	ebx, DWORD PTR [esi+81076]
	push	esi
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	mov	ecx, ebx
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H

; 1799 : 	if (!a)

	test	edi, edi

; 1800 : 		return NULL;

	je	$LN24@soap_in__n@4

; 1801 : 	if (soap->alloced)

	cmp	WORD PTR [esi+87306], 0
	je	SHORT $LN26@soap_in__n@4

; 1802 : 	{	a->soap_default(soap);

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+4]
	push	esi
	mov	ecx, edi
	call	edx

; 1803 : 		if (soap->clist->type != SOAP_TYPE__ns2__getSessionIDElement)

	mov	eax, DWORD PTR [esi+96]
	cmp	DWORD PTR [eax+8], 19			; 00000013H
	je	SHORT $LN26@soap_in__n@4

; 1804 : 		{	soap_revert(soap);

	mov	eax, esi
	call	_soap_revert

; 1805 : 			*soap->id = '\0';
; 1806 : 			return (_ns2__getSessionIDElement *)a->soap_in(soap, tag, type);

	mov	eax, DWORD PTR _type$[esp+12]
	push	eax
	mov	BYTE PTR [ebx], 0
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+24]
	push	ebp
	push	esi
	mov	ecx, edi
	call	edx
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 1836 : }

	ret	0
$LN26@soap_in__n@4:

; 1807 : 		}
; 1808 : 	}
; 1809 : 	size_t soap_flag_String_USCORE11 = 1;
; 1810 : 	if (soap->body && !*soap->href)

	cmp	WORD PTR [esi+12442], 0
	mov	ebx, 1
	je	SHORT $LN12@soap_in__n@4
	cmp	BYTE PTR [esi+82100], 0
	jne	SHORT $LN12@soap_in__n@4
	mov	ebp, 3
$LL11@soap_in__n@4:

; 1811 : 	{
; 1812 : 		for (;;)
; 1813 : 		{	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], ebp

; 1814 : 			if (soap_flag_String_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))

	test	ebx, ebx
	je	SHORT $LN25@soap_in__n@4

; 1815 : 				if (soap_in_PointerTostd__string(soap, "ns2:String_1", &(a->_ns2__getSessionIDElement::String_USCORE1), "xsd:string"))

	lea	eax, DWORD PTR [edi+4]
	push	OFFSET ??_C@_0N@EOBKMJFL@ns2?3String_1?$AA@
	mov	ecx, esi
	call	?soap_in_PointerTostd__string@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAPAV12@1@Z ; soap_in_PointerTostd__string
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@soap_in__n@4

; 1816 : 				{	soap_flag_String_USCORE11--;

	dec	ebx

; 1817 : 					continue;

	jmp	SHORT $LL11@soap_in__n@4
$LN7@soap_in__n@4:

; 1818 : 				}
; 1819 : 			/* transient soap skipped */
; 1820 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], ebp
	jne	SHORT $LN6@soap_in__n@4
$LN25@soap_in__n@4:

; 1821 : 				soap->error = soap_ignore_element(soap);

	push	esi
	call	?soap_ignore_element@@YAHPAUsoap@@@Z	; soap_ignore_element
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
$LN6@soap_in__n@4:

; 1822 : 			if (soap->error == SOAP_NO_TAG)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 6
	je	SHORT $LN23@soap_in__n@4

; 1823 : 				break;
; 1824 : 			if (soap->error)

	test	eax, eax
	je	SHORT $LL11@soap_in__n@4
	pop	edi
	pop	ebx
	pop	esi

; 1833 : 			return NULL;

	xor	eax, eax
	pop	ebp

; 1836 : }

	ret	0
$LN23@soap_in__n@4:

; 1825 : 				return NULL;
; 1826 : 		}
; 1827 : 		if (soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax

; 1828 : 			return NULL;

	jmp	SHORT $LN30@soap_in__n@4
$LN12@soap_in__n@4:

; 1829 : 	}
; 1830 : 	else
; 1831 : 	{	a = (_ns2__getSessionIDElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getSessionIDElement, 0, sizeof(_ns2__getSessionIDElement), 0, soap_copy__ns2__getSessionIDElement);

	push	OFFSET ?soap_copy__ns2__getSessionIDElement@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy__ns2__getSessionIDElement
	push	12					; 0000000cH
	push	0
	push	19					; 00000013H
	push	0
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH

; 1832 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in__n@4
	push	ebp
$LN30@soap_in__n@4:
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_in__n@4
$LN24@soap_in__n@4:
	pop	edi
	pop	ebx
	pop	esi

; 1833 : 			return NULL;

	xor	eax, eax
	pop	ebp

; 1836 : }

	ret	0
$LN1@soap_in__n@4:

; 1834 : 	}
; 1835 : 	return a;

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 1836 : }

	ret	0
?soap_in__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@PBDPAV1@1@Z ENDP ; soap_in__ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in@_ns2__getSessionIDElement@@UAEPAXPAUsoap@@PBD1@Z PROC ; _ns2__getSessionIDElement::soap_in
; _this$ = ecx

; 1791 : {	return soap_in__ns2__getSessionIDElement(soap, tag, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	ecx
	call	?soap_in__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSessionIDElement
	add	esp, 12					; 0000000cH

; 1792 : }

	ret	12					; 0000000cH
?soap_in@_ns2__getSessionIDElement@@UAEPAXPAUsoap@@PBD1@Z ENDP ; _ns2__getSessionIDElement::soap_in
_TEXT	ENDS
PUBLIC	?soap_in__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PBDPAV1@1@Z PROC ; soap_in__ns2__getSettingsFileResponseElement
; _soap$ = eax

; 1372 : {

	push	ebp

; 1373 : 	if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	ebp, DWORD PTR _tag$[esp]
	push	esi
	mov	esi, eax
	push	0
	push	0
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@soap_in__n@5
	pop	esi

; 1374 : 		return NULL;

	xor	eax, eax
	pop	ebp

; 1414 : }

	ret	0
$LN16@soap_in__n@5:

; 1375 : 	a = (_ns2__getSettingsFileResponseElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getSettingsFileResponseElement, sizeof(_ns2__getSettingsFileResponseElement), soap->type, soap->arrayType);

	mov	edx, DWORD PTR _a$[esp+4]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	lea	ecx, DWORD PTR [esi+83124]
	push	ecx
	push	12					; 0000000cH
	push	22					; 00000016H
	push	edx
	lea	ebx, DWORD PTR [esi+81076]
	push	esi
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	mov	ecx, ebx
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H

; 1376 : 	if (!a)

	test	edi, edi

; 1377 : 		return NULL;

	je	$LN30@soap_in__n@5

; 1378 : 	if (soap->alloced)

	cmp	WORD PTR [esi+87306], 0
	je	SHORT $LN32@soap_in__n@5

; 1379 : 	{	a->soap_default(soap);

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+4]
	push	esi
	mov	ecx, edi
	call	edx

; 1380 : 		if (soap->clist->type != SOAP_TYPE__ns2__getSettingsFileResponseElement)

	mov	eax, DWORD PTR [esi+96]
	cmp	DWORD PTR [eax+8], 22			; 00000016H
	je	SHORT $LN32@soap_in__n@5

; 1381 : 		{	soap_revert(soap);

	mov	eax, esi
	call	_soap_revert

; 1382 : 			*soap->id = '\0';
; 1383 : 			return (_ns2__getSettingsFileResponseElement *)a->soap_in(soap, tag, type);

	mov	eax, DWORD PTR _type$[esp+12]
	push	eax
	mov	BYTE PTR [ebx], 0
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+24]
	push	ebp
	push	esi
	mov	ecx, edi
	call	edx
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 1414 : }

	ret	0
$LN32@soap_in__n@5:

; 1384 : 		}
; 1385 : 	}
; 1386 : 	size_t soap_flag_result1 = 1;
; 1387 : 	if (soap->body && !*soap->href)

	cmp	WORD PTR [esi+12442], 0
	mov	ebx, 1
	je	SHORT $LN12@soap_in__n@5
	cmp	BYTE PTR [esi+82100], 0
	jne	SHORT $LN12@soap_in__n@5
	mov	ebp, 3
$LL11@soap_in__n@5:

; 1388 : 	{
; 1389 : 		for (;;)
; 1390 : 		{	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], ebp

; 1391 : 			if (soap_flag_result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))

	test	ebx, ebx
	je	SHORT $LN31@soap_in__n@5

; 1392 : 				if (soap_in_PointerTostd__string(soap, "ns2:result", &(a->_ns2__getSettingsFileResponseElement::result), "xsd:string"))

	lea	eax, DWORD PTR [edi+4]
	push	OFFSET ??_C@_0L@FEKNHBLL@ns2?3result?$AA@
	mov	ecx, esi
	call	?soap_in_PointerTostd__string@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAPAV12@1@Z ; soap_in_PointerTostd__string
	add	esp, 4
	test	eax, eax
	je	SHORT $LN31@soap_in__n@5

; 1393 : 				{	soap_flag_result1--;

	dec	ebx

; 1394 : 					continue;

	jmp	SHORT $LL11@soap_in__n@5
$LN31@soap_in__n@5:

; 1395 : 				}
; 1396 : 			/* transient soap skipped */
; 1397 : 			soap_check_result(soap, "ns2:result");

	cmp	WORD PTR [esi+6], 2
	jne	SHORT $LN21@soap_in__n@5
	mov	eax, esi
	call	_soap_check_result
$LN21@soap_in__n@5:

; 1398 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], ebp
	jne	SHORT $LN6@soap_in__n@5

; 1399 : 				soap->error = soap_ignore_element(soap);

	push	esi
	call	?soap_ignore_element@@YAHPAUsoap@@@Z	; soap_ignore_element
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
$LN6@soap_in__n@5:

; 1400 : 			if (soap->error == SOAP_NO_TAG)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 6
	je	SHORT $LN29@soap_in__n@5

; 1401 : 				break;
; 1402 : 			if (soap->error)

	test	eax, eax
	je	SHORT $LL11@soap_in__n@5
	pop	edi
	pop	ebx
	pop	esi

; 1411 : 			return NULL;

	xor	eax, eax
	pop	ebp

; 1414 : }

	ret	0
$LN29@soap_in__n@5:

; 1403 : 				return NULL;
; 1404 : 		}
; 1405 : 		if (soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _tag$[esp+12]
	push	eax

; 1406 : 			return NULL;

	jmp	SHORT $LN36@soap_in__n@5
$LN12@soap_in__n@5:

; 1407 : 	}
; 1408 : 	else
; 1409 : 	{	a = (_ns2__getSettingsFileResponseElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getSettingsFileResponseElement, 0, sizeof(_ns2__getSettingsFileResponseElement), 0, soap_copy__ns2__getSettingsFileResponseElement);

	push	OFFSET ?soap_copy__ns2__getSettingsFileResponseElement@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy__ns2__getSettingsFileResponseElement
	push	12					; 0000000cH
	push	0
	push	22					; 00000016H
	push	0
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH

; 1410 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in__n@5
	push	ebp
$LN36@soap_in__n@5:
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_in__n@5
$LN30@soap_in__n@5:
	pop	edi
	pop	ebx
	pop	esi

; 1411 : 			return NULL;

	xor	eax, eax
	pop	ebp

; 1414 : }

	ret	0
$LN1@soap_in__n@5:

; 1412 : 	}
; 1413 : 	return a;

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 1414 : }

	ret	0
?soap_in__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PBDPAV1@1@Z ENDP ; soap_in__ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in@_ns2__getSettingsFileResponseElement@@UAEPAXPAUsoap@@PBD1@Z PROC ; _ns2__getSettingsFileResponseElement::soap_in
; _this$ = ecx

; 1368 : {	return soap_in__ns2__getSettingsFileResponseElement(soap, tag, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	ecx
	call	?soap_in__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSettingsFileResponseElement
	add	esp, 12					; 0000000cH

; 1369 : }

	ret	12					; 0000000cH
?soap_in@_ns2__getSettingsFileResponseElement@@UAEPAXPAUsoap@@PBD1@Z ENDP ; _ns2__getSettingsFileResponseElement::soap_in
_TEXT	ENDS
PUBLIC	?soap_in__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_flag_int_USCORE21$ = -16				; size = 4
_soap_flag_float_USCORE71$ = -12			; size = 4
_soap_flag_float_USCORE81$ = -8				; size = 4
_soap_flag_String_USCORE11$ = -4			; size = 4
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@PBDPAV1@1@Z PROC ; soap_in__ns2__submitEpochResultElement
; _soap$ = eax

; 1198 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	esi, eax

; 1199 : 	if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	eax, DWORD PTR _tag$[ebp]
	push	0
	push	0
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax

; 1200 : 		return NULL;

	jne	$LN207@soap_in__n@6

; 1201 : 	a = (_ns2__submitEpochResultElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__submitEpochResultElement, sizeof(_ns2__submitEpochResultElement), soap->type, soap->arrayType);

	mov	edx, DWORD PTR _a$[ebp]
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	lea	ecx, DWORD PTR [esi+83124]
	push	ecx
	push	136					; 00000088H
	push	23					; 00000017H
	push	edx
	lea	edi, DWORD PTR [esi+81076]
	push	esi
	mov	eax, OFFSET ?soap_instantiate@@YAPAXPAUsoap@@HPBD1PAI@Z ; soap_instantiate
	mov	ecx, edi
	call	_soap_id_enter
	mov	ebx, eax
	add	esp, 24					; 00000018H

; 1202 : 	if (!a)

	test	ebx, ebx

; 1203 : 		return NULL;

	je	$LN207@soap_in__n@6

; 1204 : 	if (soap->alloced)

	cmp	WORD PTR [esi+87306], 0
	je	SHORT $LN29@soap_in__n@6

; 1205 : 	{	a->soap_default(soap);

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+4]
	push	esi
	mov	ecx, ebx
	call	edx

; 1206 : 		if (soap->clist->type != SOAP_TYPE__ns2__submitEpochResultElement)

	mov	eax, DWORD PTR [esi+96]
	cmp	DWORD PTR [eax+8], 23			; 00000017H
	je	SHORT $LN29@soap_in__n@6

; 1207 : 		{	soap_revert(soap);

	mov	eax, esi
	call	_soap_revert

; 1208 : 			*soap->id = '\0';
; 1209 : 			return (_ns2__submitEpochResultElement *)a->soap_in(soap, tag, type);

	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR _tag$[ebp]
	push	eax
	mov	BYTE PTR [edi], 0
	mov	edx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [edx+24]
	push	ecx
	push	esi
	mov	ecx, ebx
	call	edx

; 1273 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@soap_in__n@6:

; 1210 : 		}
; 1211 : 	}
; 1212 : 	size_t soap_flag_String_USCORE11 = 1;
; 1213 : 	size_t soap_flag_int_USCORE21 = 1;
; 1214 : 	size_t soap_flag_float_USCORE71 = 1;
; 1215 : 	size_t soap_flag_float_USCORE81 = 1;
; 1216 : 	if (soap->body && !*soap->href)

	cmp	WORD PTR [esi+12442], 0
	mov	eax, 1
	mov	DWORD PTR _soap_flag_String_USCORE11$[esp+32], eax
	mov	DWORD PTR _soap_flag_int_USCORE21$[esp+32], eax
	mov	DWORD PTR _soap_flag_float_USCORE71$[esp+32], eax
	mov	DWORD PTR _soap_flag_float_USCORE81$[esp+32], eax
	je	$LN28@soap_in__n@6
	cmp	BYTE PTR [esi+82100], 0
	jne	$LN28@soap_in__n@6
$LN27@soap_in__n@6:

; 1217 : 	{
; 1218 : 		for (;;)
; 1219 : 		{	soap->error = SOAP_TAG_MISMATCH;
; 1220 : 			if (soap_flag_String_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))

	cmp	DWORD PTR _soap_flag_String_USCORE11$[esp+32], 0
	mov	edi, 3
	mov	DWORD PTR [esi+90460], edi
	je	SHORT $LN23@soap_in__n@6

; 1221 : 				if (soap_in_PointerTostd__string(soap, "ns2:String_1", &(a->_ns2__submitEpochResultElement::sessionID), "xsd:string"))

	lea	eax, DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0N@EOBKMJFL@ns2?3String_1?$AA@
	mov	ecx, esi
	call	?soap_in_PointerTostd__string@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAPAV12@1@Z ; soap_in_PointerTostd__string
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@soap_in__n@6

; 1222 : 				{	soap_flag_String_USCORE11--;

	dec	DWORD PTR _soap_flag_String_USCORE11$[esp+32]

; 1223 : 					continue;

	jmp	SHORT $LN27@soap_in__n@6
$LN23@soap_in__n@6:

; 1224 : 				}
; 1225 : 			if (soap_flag_int_USCORE21 && soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR _soap_flag_int_USCORE21$[esp+32], 0
	je	SHORT $LN21@soap_in__n@6
	cmp	DWORD PTR [esi+90460], edi
	jne	$LN13@soap_in__n@6

; 1226 : 				if (soap_in_LONG64(soap, "ns2:int_2", &(a->_ns2__submitEpochResultElement::epoch), "xsd:long"))

	push	OFFSET ??_C@_08PNDIDGIB@xsd?3long?$AA@
	lea	eax, DWORD PTR [ebx+16]
	push	eax
	push	OFFSET ??_C@_09LGLKGPMP@ns2?3int_2?$AA@
	mov	eax, esi
	call	_soap_inLONG64
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN21@soap_in__n@6

; 1227 : 				{	soap_flag_int_USCORE21--;

	dec	DWORD PTR _soap_flag_int_USCORE21$[esp+32]

; 1228 : 					continue;

	jmp	SHORT $LN27@soap_in__n@6
$LN21@soap_in__n@6:

; 1229 : 				}
; 1230 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], edi
	jne	$LN13@soap_in__n@6

; 1231 : 				if (soap_in_std__vectorTemplateOfint(soap, "ns2:arrayOfint_3", &(a->_ns2__submitEpochResultElement::channel), "xsd:int"))

	mov	eax, esi
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN63@soap_in__n@6
	cmp	WORD PTR [esi+87220], ax
	je	SHORT $LN67@soap_in__n@6
	mov	DWORD PTR [esi+90460], edi
	jmp	SHORT $LN190@soap_in__n@6
$LN67@soap_in__n@6:
	lea	ecx, DWORD PTR [esi+80052]
	push	ecx
	push	esi
	mov	edi, OFFSET ??_C@_0BB@FGDEMAEK@ns2?3arrayOfint_3?$AA@
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	jne	SHORT $LN198@soap_in__n@6
	xor	edx, edx
	mov	WORD PTR [esi+87308], dx
	cmp	WORD PTR [esi+12442], dx
	je	SHORT $LN198@soap_in__n@6
	inc	DWORD PTR [esi+12444]
$LN198@soap_in__n@6:
	mov	edi, 3
$LN63@soap_in__n@6:
	cmp	DWORD PTR [esi+90460], 0
	jne	SHORT $LN19@soap_in__n@6
	lea	eax, DWORD PTR [ebx+24]
	push	eax
	push	OFFSET ??_C@_0BB@FGDEMAEK@ns2?3arrayOfint_3?$AA@
	call	?soap_in_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@PBDPAV12@1@Z ; soap_in_std__vectorTemplateOfint
	add	esp, 8
	test	eax, eax
	jne	$LN27@soap_in__n@6
$LN19@soap_in__n@6:

; 1232 : 					continue;
; 1233 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], edi
	jne	$LN13@soap_in__n@6
$LN190@soap_in__n@6:

; 1234 : 				if (soap_in_std__vectorTemplateOfint(soap, "ns2:arrayOfint_4", &(a->_ns2__submitEpochResultElement::rank), "xsd:int"))

	mov	eax, esi
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN96@soap_in__n@6
	cmp	WORD PTR [esi+87220], ax
	je	SHORT $LN100@soap_in__n@6
	mov	DWORD PTR [esi+90460], edi
	jmp	SHORT $LN191@soap_in__n@6
$LN100@soap_in__n@6:
	lea	ecx, DWORD PTR [esi+80052]
	push	ecx
	push	esi
	mov	edi, OFFSET ??_C@_0BB@BJHFFGIN@ns2?3arrayOfint_4?$AA@
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	jne	SHORT $LN200@soap_in__n@6
	xor	edx, edx
	mov	WORD PTR [esi+87308], dx
	cmp	WORD PTR [esi+12442], dx
	je	SHORT $LN200@soap_in__n@6
	inc	DWORD PTR [esi+12444]
$LN200@soap_in__n@6:
	mov	edi, 3
$LN96@soap_in__n@6:
	cmp	DWORD PTR [esi+90460], 0
	jne	SHORT $LN17@soap_in__n@6
	lea	eax, DWORD PTR [ebx+48]
	push	eax
	push	OFFSET ??_C@_0BB@BJHFFGIN@ns2?3arrayOfint_4?$AA@
	call	?soap_in_std__vectorTemplateOfint@@YAPAV?$vector@HV?$allocator@H@std@@@std@@PAUsoap@@PBDPAV12@1@Z ; soap_in_std__vectorTemplateOfint
	add	esp, 8
	test	eax, eax
	jne	$LN27@soap_in__n@6
$LN17@soap_in__n@6:

; 1235 : 					continue;
; 1236 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], edi
	jne	$LN13@soap_in__n@6
$LN191@soap_in__n@6:

; 1237 : 				if (soap_in_std__vectorTemplateOffloat(soap, "ns2:arrayOffloat_5", &(a->_ns2__submitEpochResultElement::PsysACTSTBY), "xsd:float"))

	mov	eax, esi
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN129@soap_in__n@6
	cmp	WORD PTR [esi+87220], ax
	je	SHORT $LN133@soap_in__n@6
	mov	DWORD PTR [esi+90460], edi
	jmp	SHORT $LN192@soap_in__n@6
$LN133@soap_in__n@6:
	lea	ecx, DWORD PTR [esi+80052]
	push	ecx
	push	esi
	mov	edi, OFFSET ??_C@_0BD@GLFPAPIO@ns2?3arrayOffloat_5?$AA@
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	jne	SHORT $LN201@soap_in__n@6
	xor	edx, edx
	mov	WORD PTR [esi+87308], dx
	cmp	WORD PTR [esi+12442], dx
	je	SHORT $LN201@soap_in__n@6
	inc	DWORD PTR [esi+12444]
$LN201@soap_in__n@6:
	mov	edi, 3
$LN129@soap_in__n@6:
	cmp	DWORD PTR [esi+90460], 0
	jne	SHORT $LN15@soap_in__n@6
	lea	eax, DWORD PTR [ebx+72]
	push	eax
	push	OFFSET ??_C@_0BD@GLFPAPIO@ns2?3arrayOffloat_5?$AA@
	call	?soap_in_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@PBDPAV12@1@Z ; soap_in_std__vectorTemplateOffloat
	add	esp, 8
	test	eax, eax
	jne	$LN27@soap_in__n@6
$LN15@soap_in__n@6:

; 1238 : 					continue;
; 1239 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], edi
	jne	SHORT $LN13@soap_in__n@6
$LN192@soap_in__n@6:

; 1240 : 				if (soap_in_std__vectorTemplateOffloat(soap, "ns2:arrayOffloat_6", &(a->_ns2__submitEpochResultElement::PsysACT), "xsd:float"))

	mov	eax, esi
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN162@soap_in__n@6
	cmp	WORD PTR [esi+87220], ax
	je	SHORT $LN166@soap_in__n@6
	mov	DWORD PTR [esi+90460], edi
	jmp	SHORT $LN13@soap_in__n@6
$LN166@soap_in__n@6:
	lea	ecx, DWORD PTR [esi+80052]
	push	ecx
	push	esi
	mov	edi, OFFSET ??_C@_0BD@EAHCFMEN@ns2?3arrayOffloat_6?$AA@
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	jne	SHORT $LN202@soap_in__n@6
	xor	edx, edx
	mov	WORD PTR [esi+87308], dx
	cmp	WORD PTR [esi+12442], dx
	je	SHORT $LN202@soap_in__n@6
	inc	DWORD PTR [esi+12444]
$LN202@soap_in__n@6:
	mov	edi, 3
$LN162@soap_in__n@6:
	cmp	DWORD PTR [esi+90460], 0
	jne	SHORT $LN13@soap_in__n@6
	lea	eax, DWORD PTR [ebx+96]
	push	eax
	push	OFFSET ??_C@_0BD@EAHCFMEN@ns2?3arrayOffloat_6?$AA@
	call	?soap_in_std__vectorTemplateOffloat@@YAPAV?$vector@MV?$allocator@M@std@@@std@@PAUsoap@@PBDPAV12@1@Z ; soap_in_std__vectorTemplateOffloat
	add	esp, 8
	test	eax, eax
	jne	$LN27@soap_in__n@6
$LN13@soap_in__n@6:

; 1241 : 					continue;
; 1242 : 			if (soap_flag_float_USCORE71 && soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR _soap_flag_float_USCORE71$[esp+32], 0
	je	SHORT $LN11@soap_in__n@6
	cmp	DWORD PTR [esi+90460], edi
	jne	SHORT $LN11@soap_in__n@6

; 1243 : 				if (soap_in_float(soap, "ns2:float_7", &(a->_ns2__submitEpochResultElement::PsysRD), "xsd:float"))

	push	OFFSET ??_C@_09ILBLHFBD@xsd?3float?$AA@
	lea	ecx, DWORD PTR [ebx+120]
	push	ecx
	push	OFFSET ??_C@_0M@OBEIDIJA@ns2?3float_7?$AA@
	push	esi
	call	_soap_infloat
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN11@soap_in__n@6

; 1244 : 				{	soap_flag_float_USCORE71--;

	dec	DWORD PTR _soap_flag_float_USCORE71$[esp+32]

; 1245 : 					continue;

	jmp	$LN27@soap_in__n@6
$LN11@soap_in__n@6:

; 1246 : 				}
; 1247 : 			if (soap_flag_float_USCORE81 && soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR _soap_flag_float_USCORE81$[esp+32], 0
	je	SHORT $LN9@soap_in__n@6
	cmp	DWORD PTR [esi+90460], edi
	jne	SHORT $LN8@soap_in__n@6

; 1248 : 				if (soap_in_float(soap, "ns2:float_8", &(a->_ns2__submitEpochResultElement::PsysWR), "xsd:float"))

	push	OFFSET ??_C@_09ILBLHFBD@xsd?3float?$AA@
	lea	edx, DWORD PTR [ebx+124]
	push	edx
	push	OFFSET ??_C@_0M@GGNACEFP@ns2?3float_8?$AA@
	push	esi
	call	_soap_infloat
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN9@soap_in__n@6

; 1249 : 				{	soap_flag_float_USCORE81--;

	dec	DWORD PTR _soap_flag_float_USCORE81$[esp+32]

; 1250 : 					continue;

	jmp	$LN27@soap_in__n@6
$LN9@soap_in__n@6:

; 1251 : 				}
; 1252 : 			/* transient soap skipped */
; 1253 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], edi
	jne	SHORT $LN8@soap_in__n@6

; 1254 : 				soap->error = soap_ignore_element(soap);

	push	esi
	call	?soap_ignore_element@@YAHPAUsoap@@@Z	; soap_ignore_element
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
$LN8@soap_in__n@6:

; 1255 : 			if (soap->error == SOAP_NO_TAG)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 6
	je	SHORT $LN184@soap_in__n@6

; 1256 : 				break;
; 1257 : 			if (soap->error)

	test	eax, eax
	je	$LN27@soap_in__n@6

; 1270 : 		return NULL;

	xor	eax, eax

; 1273 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN184@soap_in__n@6:

; 1258 : 				return NULL;
; 1259 : 		}
; 1260 : 		if (soap_element_end_in(soap, tag))

	mov	eax, DWORD PTR _tag$[ebp]
	push	eax
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN207@soap_in__n@6

; 1267 : 	}
; 1268 : 	if ((soap_flag_int_USCORE21 > 0 || soap_flag_float_USCORE71 > 0 || soap_flag_float_USCORE81 > 0))

	cmp	DWORD PTR _soap_flag_int_USCORE21$[esp+32], eax
	ja	SHORT $LN1@soap_in__n@6
	cmp	DWORD PTR _soap_flag_float_USCORE71$[esp+32], eax
	ja	SHORT $LN1@soap_in__n@6
	cmp	DWORD PTR _soap_flag_float_USCORE81$[esp+32], eax
	ja	SHORT $LN1@soap_in__n@6

; 1271 : 	}
; 1272 : 	return a;

	mov	eax, ebx

; 1273 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@soap_in__n@6:

; 1261 : 			return NULL;
; 1262 : 	}
; 1263 : 	else
; 1264 : 	{	a = (_ns2__submitEpochResultElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__submitEpochResultElement, 0, sizeof(_ns2__submitEpochResultElement), 0, soap_copy__ns2__submitEpochResultElement);

	push	OFFSET ?soap_copy__ns2__submitEpochResultElement@@YAXPAUsoap@@HHPAXIPBXI@Z ; soap_copy__ns2__submitEpochResultElement
	push	136					; 00000088H
	push	0
	push	23					; 00000017H
	push	0
	push	ebx
	lea	eax, DWORD PTR [esi+82100]
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH

; 1265 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN1@soap_in__n@6
	mov	ecx, DWORD PTR _tag$[ebp]
	push	ecx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 1266 : 			return NULL;

	jne	SHORT $LN207@soap_in__n@6
$LN1@soap_in__n@6:

; 1269 : 	{	soap->error = SOAP_OCCURS;

	mov	DWORD PTR [esi+90460], 44		; 0000002cH
$LN207@soap_in__n@6:

; 1273 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?soap_in__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@PBDPAV1@1@Z ENDP ; soap_in__ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_in@_ns2__submitEpochResultElement@@UAEPAXPAUsoap@@PBD1@Z PROC ; _ns2__submitEpochResultElement::soap_in
; _this$ = ecx

; 1194 : {	return soap_in__ns2__submitEpochResultElement(soap, tag, this, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+4]
	push	ecx
	call	?soap_in__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__submitEpochResultElement
	add	esp, 12					; 0000000cH

; 1195 : }

	ret	12					; 0000000cH
?soap_in@_ns2__submitEpochResultElement@@UAEPAXPAUsoap@@PBD1@Z ENDP ; _ns2__submitEpochResultElement::soap_in
; Function compile flags: /Ogtpy
$T654284 = -8						; size = 4
$T654238 = -4						; size = 4
_soap$ = 8						; size = 4
_type$ = 12						; size = 4
_soap_getelement PROC

; 153  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx

; 154  : 	if (soap_peek_element(soap))

	mov	ebx, DWORD PTR _soap$[ebp]
	push	esi
	push	edi
	mov	eax, ebx
	call	_soap_peek_element
	test	eax, eax

; 155  : 		return NULL;

	jne	$LN396@soap_getel

; 156  : 	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))

	mov	edi, DWORD PTR _type$[ebp]
	cmp	BYTE PTR [ebx+81076], al
	lea	esi, DWORD PTR [ebx+81076]
	je	SHORT $LN45@soap_getel
	test	esi, esi
	je	SHORT $LN56@soap_getel
	cmp	BYTE PTR [esi], al
	je	SHORT $LN56@soap_getel
	push	ebx
	call	_soap_lookup
	add	esp, 4
	test	eax, eax
	je	SHORT $LN56@soap_getel
	mov	eax, DWORD PTR [eax+4]
	jmp	SHORT $LN58@soap_getel
$LN56@soap_getel:
	xor	eax, eax
$LN58@soap_getel:
	mov	DWORD PTR [edi], eax
	test	eax, eax
	jne	SHORT $LN46@soap_getel
$LN45@soap_getel:

; 157  : 		*type = soap_lookup_type(soap, soap->href);

	lea	esi, DWORD PTR [ebx+82100]
	test	esi, esi
	je	SHORT $LN60@soap_getel
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN60@soap_getel
	push	ebx
	call	_soap_lookup
	add	esp, 4
	test	eax, eax
	je	SHORT $LN60@soap_getel
	mov	eax, DWORD PTR [eax+4]
	jmp	SHORT $LN62@soap_getel
$LN60@soap_getel:
	xor	eax, eax
$LN62@soap_getel:
	mov	DWORD PTR [edi], eax
$LN46@soap_getel:

; 158  : 	switch (*type)

	mov	eax, DWORD PTR [edi]
	dec	eax
	cmp	eax, 36					; 00000024H
	ja	$LN22@soap_getel
	movzx	eax, BYTE PTR $LN387@soap_getel[eax]
	jmp	DWORD PTR $LN400@soap_getel[eax*4]
$LN42@soap_getel:

; 159  : 	{
; 160  : 	case SOAP_TYPE_byte:
; 161  : 		return soap_in_byte(soap, NULL, NULL, "xsd:byte");

	push	OFFSET ??_C@_08BEPNMEIH@xsd?3byte?$AA@
	push	0
	push	0
	push	ebx
	call	_soap_inbyte
	add	esp, 16					; 00000010H

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@soap_getel:

; 162  : 	case SOAP_TYPE_int:
; 163  : 		return soap_in_int(soap, NULL, NULL, "xsd:int");

	push	OFFSET ??_C@_07PCIGPDP@xsd?3int?$AA@
	push	0
	push	0
	push	ebx
	call	_soap_inint
	add	esp, 16					; 00000010H

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@soap_getel:

; 164  : 	case SOAP_TYPE_LONG64:
; 165  : 		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");

	push	OFFSET ??_C@_08PNDIDGIB@xsd?3long?$AA@
	push	0
	push	0
	mov	eax, ebx
	call	_soap_inLONG64
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@soap_getel:

; 166  : 	case SOAP_TYPE_float:
; 167  : 		return soap_in_float(soap, NULL, NULL, "xsd:float");

	push	OFFSET ??_C@_09ILBLHFBD@xsd?3float?$AA@
	push	0
	push	0
	push	ebx
	call	_soap_infloat
	add	esp, 16					; 00000010H

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@soap_getel:

; 168  : 	case SOAP_TYPE_bool:
; 169  : 		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");

	push	OFFSET ??_C@_0M@FGHMEICI@xsd?3boolean?$AA@
	push	0
	push	0
	mov	eax, ebx
	call	?soap_in_bool@@YAPA_NPAUsoap@@PBDPA_N1@Z ; soap_in_bool
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@soap_getel:

; 170  : 	case SOAP_TYPE_std__string:
; 171  : 		return soap_in_std__string(soap, NULL, NULL, "xsd:string");

	mov	eax, ebx
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN90@soap_getel
	cmp	WORD PTR [ebx+87220], ax
	jne	$LN1@soap_getel
	lea	ecx, DWORD PTR [ebx+80052]
	push	ecx
	push	ebx
	xor	edi, edi
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [ebx+90460], eax
	test	eax, eax
	jne	SHORT $LN90@soap_getel
	xor	edx, edx
	mov	WORD PTR [ebx+87308], dx
	cmp	WORD PTR [ebx+12442], dx
	je	SHORT $LN90@soap_getel
	inc	DWORD PTR [ebx+12444]
$LN90@soap_getel:
	cmp	DWORD PTR [ebx+90460], 0
	jne	$LN396@soap_getel
$LN87@soap_getel:
	push	0
	xor	eax, eax
	mov	ecx, ebx
	call	?soap_in_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAV12@1@Z ; soap_in_std__string
	add	esp, 4

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@soap_getel:

; 172  : 	case SOAP_TYPE_xsd__string:
; 173  : 		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");

	push	OFFSET ??_C@_0L@DIJPMJCO@xsd?3string?$AA@
	push	0
	push	0
	mov	eax, ebx
	call	?soap_in_xsd__string@@YAPAVxsd__string@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__string
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@soap_getel:

; 174  : 	case SOAP_TYPE_xsd__long:
; 175  : 		return soap_in_xsd__long(soap, NULL, NULL, "xsd:long");

	push	OFFSET ??_C@_08PNDIDGIB@xsd?3long?$AA@
	push	0
	push	0
	mov	eax, ebx
	call	?soap_in_xsd__long@@YAPAVxsd__long@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__long
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@soap_getel:

; 176  : 	case SOAP_TYPE_xsd__int:
; 177  : 		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");

	push	OFFSET ??_C@_07PCIGPDP@xsd?3int?$AA@
	push	0
	push	0
	mov	eax, ebx
	call	?soap_in_xsd__int@@YAPAVxsd__int@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__int
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@soap_getel:

; 178  : 	case SOAP_TYPE_xsd__float:
; 179  : 		return soap_in_xsd__float(soap, NULL, NULL, "xsd:float");

	push	OFFSET ??_C@_09ILBLHFBD@xsd?3float?$AA@
	push	0
	push	0
	mov	eax, ebx
	call	?soap_in_xsd__float@@YAPAVxsd__float@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__float
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@soap_getel:

; 180  : 	case SOAP_TYPE_xsd__boolean:
; 181  : 		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");

	push	OFFSET ??_C@_0M@FGHMEICI@xsd?3boolean?$AA@
	push	0
	push	0
	mov	eax, ebx
	call	?soap_in_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__boolean
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@soap_getel:

; 182  : 	case SOAP_TYPE_xsd__anyType:
; 183  : 		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");

	push	OFFSET ??_C@_0M@NOIFKOBF@xsd?3anyType?$AA@
	push	0
	push	0
	mov	eax, ebx
	call	?soap_in_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__anyType
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@soap_getel:

; 184  : 	case SOAP_TYPE_PointerTo_ns2__submitEpochResultResponseElement:
; 185  : 		return soap_in_PointerTo_ns2__submitEpochResultResponseElement(soap, NULL, NULL, "ns2:submitEpochResultResponseElement");

	mov	eax, ebx
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN111@soap_getel
	cmp	WORD PTR [ebx+87220], ax
	jne	$LN1@soap_getel
	lea	eax, DWORD PTR [ebx+80052]
	push	eax
	push	ebx
	xor	edi, edi
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [ebx+90460], eax
	test	eax, eax
	jne	SHORT $LN111@soap_getel
	xor	ecx, ecx
	mov	WORD PTR [ebx+87308], cx
	cmp	WORD PTR [ebx+12442], cx
	je	SHORT $LN111@soap_getel
	inc	DWORD PTR [ebx+12444]
$LN111@soap_getel:
	cmp	DWORD PTR [ebx+90460], 0
	jne	$LN396@soap_getel
	mov	eax, 4
	mov	edi, ebx
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi
	je	$LN396@soap_getel
	mov	DWORD PTR [edi], 0
	cmp	WORD PTR [ebx+87300], 0
	jne	SHORT $LN103@soap_getel
	cmp	BYTE PTR [ebx+82100], 35		; 00000023H
	je	SHORT $LN103@soap_getel
	mov	eax, ebx
	call	_soap_revert
	push	0
	push	ebx
	or	ecx, -1
	call	?soap_instantiate__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__submitEpochResultResponseElement
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax
	je	$LN396@soap_getel
$LN102@soap_getel:
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	push	ebx
	call	eax
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	push	0
	push	0
	push	ebx
	call	eax
	test	eax, eax
	jne	SHORT $LN99@soap_getel

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0

; 184  : 	case SOAP_TYPE_PointerTo_ns2__submitEpochResultResponseElement:
; 185  : 		return soap_in_PointerTo_ns2__submitEpochResultResponseElement(soap, NULL, NULL, "ns2:submitEpochResultResponseElement");

$LN103@soap_getel:
	push	12					; 0000000cH
	push	24					; 00000018H
	push	edi
	lea	eax, DWORD PTR [ebx+82100]
	mov	ecx, ebx
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH
	cmp	WORD PTR [ebx+12442], 0
	mov	edi, eax
	je	SHORT $LN99@soap_getel
	push	0
	mov	esi, ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	jne	$LN396@soap_getel
$LN99@soap_getel:
	mov	eax, edi

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@soap_getel:

; 186  : 	case SOAP_TYPE_PointerTo_ns2__submitEpochResultElement:
; 187  : 		return soap_in_PointerTo_ns2__submitEpochResultElement(soap, NULL, NULL, "ns2:submitEpochResultElement");

	mov	eax, ebx
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN132@soap_getel
	cmp	WORD PTR [ebx+87220], ax
	jne	$LN1@soap_getel
	lea	ecx, DWORD PTR [ebx+80052]
	push	ecx
	push	ebx
	xor	edi, edi
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [ebx+90460], eax
	test	eax, eax
	jne	SHORT $LN132@soap_getel
	xor	edx, edx
	mov	WORD PTR [ebx+87308], dx
	cmp	WORD PTR [ebx+12442], dx
	je	SHORT $LN132@soap_getel
	inc	DWORD PTR [ebx+12444]
$LN132@soap_getel:
	cmp	DWORD PTR [ebx+90460], 0
	jne	$LN396@soap_getel
	mov	eax, 4
	mov	edi, ebx
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi
	je	$LN396@soap_getel
	mov	DWORD PTR [edi], 0
	cmp	WORD PTR [ebx+87300], 0
	jne	SHORT $LN124@soap_getel
	cmp	BYTE PTR [ebx+82100], 35		; 00000023H
	je	SHORT $LN124@soap_getel
	mov	eax, ebx
	call	_soap_revert
	push	0
	push	ebx
	or	ecx, -1
	call	?soap_instantiate__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__submitEpochResultElement
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax
	jne	$LN102@soap_getel

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0

; 186  : 	case SOAP_TYPE_PointerTo_ns2__submitEpochResultElement:
; 187  : 		return soap_in_PointerTo_ns2__submitEpochResultElement(soap, NULL, NULL, "ns2:submitEpochResultElement");

$LN124@soap_getel:
	push	136					; 00000088H
	push	23					; 00000017H
$LN397@soap_getel:
	push	edi
	lea	eax, DWORD PTR [ebx+82100]
	mov	ecx, ebx
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH
	cmp	WORD PTR [ebx+12442], 0
	mov	edi, eax
	je	$LN99@soap_getel
	push	0
	mov	esi, ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	$LN99@soap_getel

; 295  : 	return NULL;

	xor	eax, eax

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@soap_getel:

; 188  : 	case SOAP_TYPE_PointerTo_ns2__getSettingsFileResponseElement:
; 189  : 		return soap_in_PointerTo_ns2__getSettingsFileResponseElement(soap, NULL, NULL, "ns2:getSettingsFileResponseElement");

	mov	eax, ebx
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN153@soap_getel
	cmp	WORD PTR [ebx+87220], ax
	jne	$LN1@soap_getel
	lea	ecx, DWORD PTR [ebx+80052]
	push	ecx
	push	ebx
	xor	edi, edi
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [ebx+90460], eax
	test	eax, eax
	jne	SHORT $LN153@soap_getel
	xor	edx, edx
	mov	WORD PTR [ebx+87308], dx
	cmp	WORD PTR [ebx+12442], dx
	je	SHORT $LN153@soap_getel
	inc	DWORD PTR [ebx+12444]
$LN153@soap_getel:
	cmp	DWORD PTR [ebx+90460], 0
	jne	$LN396@soap_getel
	mov	eax, 4
	mov	edi, ebx
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi
	je	$LN396@soap_getel
	mov	DWORD PTR [edi], 0
	cmp	WORD PTR [ebx+87300], 0
	jne	SHORT $LN145@soap_getel
	cmp	BYTE PTR [ebx+82100], 35		; 00000023H
	je	SHORT $LN145@soap_getel
	mov	eax, ebx
	call	_soap_revert
	push	0
	push	ebx
	or	ecx, -1
	call	?soap_instantiate__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSettingsFileResponseElement
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax
	jne	$LN102@soap_getel

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0

; 188  : 	case SOAP_TYPE_PointerTo_ns2__getSettingsFileResponseElement:
; 189  : 		return soap_in_PointerTo_ns2__getSettingsFileResponseElement(soap, NULL, NULL, "ns2:getSettingsFileResponseElement");

$LN145@soap_getel:
	push	12					; 0000000cH
	push	22					; 00000016H
	jmp	$LN397@soap_getel
$LN27@soap_getel:

; 190  : 	case SOAP_TYPE_PointerTo_ns2__getSettingsFileElement:
; 191  : 		return soap_in_PointerTo_ns2__getSettingsFileElement(soap, NULL, NULL, "ns2:getSettingsFileElement");

	mov	eax, ebx
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN174@soap_getel
	cmp	WORD PTR [ebx+87220], ax
	jne	$LN1@soap_getel
	lea	ecx, DWORD PTR [ebx+80052]
	push	ecx
	push	ebx
	xor	edi, edi
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [ebx+90460], eax
	test	eax, eax
	jne	SHORT $LN174@soap_getel
	xor	edx, edx
	mov	WORD PTR [ebx+87308], dx
	cmp	WORD PTR [ebx+12442], dx
	je	SHORT $LN174@soap_getel
	inc	DWORD PTR [ebx+12444]
$LN174@soap_getel:
	cmp	DWORD PTR [ebx+90460], 0
	jne	$LN396@soap_getel
	mov	eax, 4
	mov	edi, ebx
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi
	je	$LN396@soap_getel
	mov	DWORD PTR [edi], 0
	cmp	WORD PTR [ebx+87300], 0
	jne	SHORT $LN166@soap_getel
	cmp	BYTE PTR [ebx+82100], 35		; 00000023H
	je	SHORT $LN166@soap_getel
	mov	eax, ebx
	call	_soap_revert
	push	0
	push	ebx
	or	ecx, -1
	call	?soap_instantiate__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSettingsFileElement
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax
	jne	$LN102@soap_getel

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0

; 190  : 	case SOAP_TYPE_PointerTo_ns2__getSettingsFileElement:
; 191  : 		return soap_in_PointerTo_ns2__getSettingsFileElement(soap, NULL, NULL, "ns2:getSettingsFileElement");

$LN166@soap_getel:
	push	12					; 0000000cH
	push	21					; 00000015H
	jmp	$LN397@soap_getel
$LN26@soap_getel:

; 192  : 	case SOAP_TYPE_PointerTo_ns2__getSessionIDResponseElement:
; 193  : 		return soap_in_PointerTo_ns2__getSessionIDResponseElement(soap, NULL, NULL, "ns2:getSessionIDResponseElement");

	mov	eax, ebx
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN195@soap_getel
	cmp	WORD PTR [ebx+87220], ax
	jne	$LN1@soap_getel
	lea	ecx, DWORD PTR [ebx+80052]
	push	ecx
	push	ebx
	xor	edi, edi
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [ebx+90460], eax
	test	eax, eax
	jne	SHORT $LN195@soap_getel
	xor	edx, edx
	mov	WORD PTR [ebx+87308], dx
	cmp	WORD PTR [ebx+12442], dx
	je	SHORT $LN195@soap_getel
	inc	DWORD PTR [ebx+12444]
$LN195@soap_getel:
	cmp	DWORD PTR [ebx+90460], 0
	jne	$LN396@soap_getel
	mov	eax, 4
	mov	edi, ebx
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi
	je	$LN396@soap_getel
	mov	DWORD PTR [edi], 0
	cmp	WORD PTR [ebx+87300], 0
	jne	SHORT $LN187@soap_getel
	cmp	BYTE PTR [ebx+82100], 35		; 00000023H
	je	SHORT $LN187@soap_getel
	mov	eax, ebx
	call	_soap_revert
	push	0
	push	ebx
	or	ecx, -1
	call	?soap_instantiate__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSessionIDResponseElement
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax
	jne	$LN102@soap_getel

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0

; 192  : 	case SOAP_TYPE_PointerTo_ns2__getSessionIDResponseElement:
; 193  : 		return soap_in_PointerTo_ns2__getSessionIDResponseElement(soap, NULL, NULL, "ns2:getSessionIDResponseElement");

$LN187@soap_getel:
	push	12					; 0000000cH
	push	20					; 00000014H
	jmp	$LN397@soap_getel
$LN25@soap_getel:

; 194  : 	case SOAP_TYPE_PointerTo_ns2__getSessionIDElement:
; 195  : 		return soap_in_PointerTo_ns2__getSessionIDElement(soap, NULL, NULL, "ns2:getSessionIDElement");

	mov	eax, ebx
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN216@soap_getel
	cmp	WORD PTR [ebx+87220], ax
	jne	$LN1@soap_getel
	lea	ecx, DWORD PTR [ebx+80052]
	push	ecx
	push	ebx
	xor	edi, edi
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [ebx+90460], eax
	test	eax, eax
	jne	SHORT $LN216@soap_getel
	xor	edx, edx
	mov	WORD PTR [ebx+87308], dx
	cmp	WORD PTR [ebx+12442], dx
	je	SHORT $LN216@soap_getel
	inc	DWORD PTR [ebx+12444]
$LN216@soap_getel:
	cmp	DWORD PTR [ebx+90460], 0
	jne	$LN396@soap_getel
	mov	eax, 4
	mov	edi, ebx
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi
	je	$LN396@soap_getel
	mov	DWORD PTR [edi], 0
	cmp	WORD PTR [ebx+87300], 0
	jne	SHORT $LN208@soap_getel
	cmp	BYTE PTR [ebx+82100], 35		; 00000023H
	je	SHORT $LN208@soap_getel
	mov	eax, ebx
	call	_soap_revert
	push	0
	push	ebx
	or	ecx, -1
	call	?soap_instantiate__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@HPBD1PAI@Z ; soap_instantiate__ns2__getSessionIDElement
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax
	jne	$LN102@soap_getel

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0

; 194  : 	case SOAP_TYPE_PointerTo_ns2__getSessionIDElement:
; 195  : 		return soap_in_PointerTo_ns2__getSessionIDElement(soap, NULL, NULL, "ns2:getSessionIDElement");

$LN208@soap_getel:
	push	12					; 0000000cH
	push	19					; 00000013H
	jmp	$LN397@soap_getel
$LN24@soap_getel:

; 196  : 	case SOAP_TYPE_PointerTostd__string:
; 197  : 		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");

	mov	eax, ebx
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN236@soap_getel
	cmp	WORD PTR [ebx+87220], ax
	jne	$LN1@soap_getel
	lea	ecx, DWORD PTR [ebx+80052]
	push	ecx
	push	ebx
	xor	edi, edi
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [ebx+90460], eax
	test	eax, eax
	jne	SHORT $LN236@soap_getel
	xor	edx, edx
	mov	WORD PTR [ebx+87308], dx
	cmp	WORD PTR [ebx+12442], dx
	je	SHORT $LN236@soap_getel
	inc	DWORD PTR [ebx+12444]
$LN236@soap_getel:
	cmp	DWORD PTR [ebx+90460], 0
	jne	$LN396@soap_getel
	mov	eax, 4
	mov	edi, ebx
	call	_soap_malloc
	mov	esi, eax
	mov	DWORD PTR $T654284[esp+24], esi
	test	esi, esi
	je	$LN396@soap_getel
	mov	DWORD PTR [esi], 0
	cmp	WORD PTR [ebx+87300], 0
	jne	$LN228@soap_getel
	cmp	BYTE PTR [ebx+82100], 35		; 00000023H
	je	$LN228@soap_getel
	mov	eax, ebx
	call	_soap_revert
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T654238[esp+24], eax
	mov	eax, ebx
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN263@soap_getel
	cmp	WORD PTR [ebx+87220], ax
	je	SHORT $LN268@soap_getel
	mov	DWORD PTR [ebx+90460], 3
	jmp	SHORT $LN255@soap_getel
$LN268@soap_getel:
	lea	ecx, DWORD PTR [ebx+80052]
	push	ecx
	push	ebx
	xor	edi, edi
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [ebx+90460], eax
	test	eax, eax
	jne	SHORT $LN263@soap_getel
	xor	edx, edx
	mov	WORD PTR [ebx+87308], dx
	cmp	WORD PTR [ebx+12442], di
	je	SHORT $LN263@soap_getel
	inc	DWORD PTR [ebx+12444]
$LN263@soap_getel:
	cmp	DWORD PTR [ebx+90460], 0
	je	SHORT $LN260@soap_getel
	xor	eax, eax
	jmp	SHORT $LN255@soap_getel
$LN260@soap_getel:
	mov	eax, DWORD PTR $T654238[esp+24]
	push	0
	mov	ecx, ebx
	call	?soap_in_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAV12@1@Z ; soap_in_std__string
	add	esp, 4
$LN255@soap_getel:
	mov	DWORD PTR [esi], eax
	test	eax, eax
	jne	SHORT $LN225@soap_getel

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0

; 196  : 	case SOAP_TYPE_PointerTostd__string:
; 197  : 		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");

$LN228@soap_getel:
	push	28					; 0000001cH
	push	18					; 00000012H
	push	esi
	lea	eax, DWORD PTR [ebx+82100]
	mov	ecx, ebx
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH
	cmp	WORD PTR [ebx+12442], 0
	mov	DWORD PTR $T654284[esp+24], eax
	je	SHORT $LN225@soap_getel
	push	0
	mov	esi, ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	jne	$LN396@soap_getel
$LN225@soap_getel:
	mov	eax, DWORD PTR $T654284[esp+24]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@soap_getel:

; 198  : 	case SOAP_TYPE_string:
; 199  : 	{	char **s;
; 200  : 		s = soap_in_string(soap, NULL, NULL, "xsd:string");

	push	0
	push	1
	xor	eax, eax
	mov	esi, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	jne	$LN396@soap_getel
	mov	eax, 4
	mov	edi, ebx
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi
	je	$LN396@soap_getel
	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN284@soap_getel
	push	1
	mov	ecx, ebx
	call	_soap_string_in
	add	esp, 4
	mov	DWORD PTR [edi], eax
	test	eax, eax
	je	$LN396@soap_getel
	push	0
	push	0
	push	4
	push	4
	push	eax
	push	ebx
	xor	eax, eax
	lea	ecx, DWORD PTR [ebx+81076]
	call	_soap_id_enter
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN276@soap_getel

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0

; 198  : 	case SOAP_TYPE_string:
; 199  : 	{	char **s;
; 200  : 		s = soap_in_string(soap, NULL, NULL, "xsd:string");

$LN284@soap_getel:
	cmp	WORD PTR [ebx+87300], 0
	je	SHORT $LN277@soap_getel
	mov	DWORD PTR [edi], 0
	jmp	SHORT $LN276@soap_getel
$LN277@soap_getel:
	push	OFFSET _soap_padding
	push	ebx
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR [edi], eax
$LN276@soap_getel:
	cmp	BYTE PTR [ebx+82100], 0
	lea	eax, DWORD PTR [ebx+82100]
	je	SHORT $LN275@soap_getel
	push	4
	push	4
	push	edi
	mov	ecx, ebx
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH
	mov	edi, eax
$LN275@soap_getel:
	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN274@soap_getel
	push	0
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	jne	$LN396@soap_getel
$LN274@soap_getel:

; 201  : 		return s ? *s : NULL;

	test	edi, edi
	je	$LN396@soap_getel
	mov	eax, DWORD PTR [edi]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@soap_getel:

; 202  : 	}
; 203  : 	default:
; 204  : 	{	const char *t = soap->type;
; 205  : 		if (!*t)

	cmp	BYTE PTR [ebx+83124], 0
	lea	esi, DWORD PTR [ebx+83124]
	jne	SHORT $LN21@soap_getel

; 206  : 			t = soap->tag;

	lea	esi, DWORD PTR [ebx+80052]
$LN21@soap_getel:

; 207  : 		if (!soap_match_tag(soap, t, "xsd:string"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0L@DIJPMJCO@xsd?3string?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@soap_getel

; 208  : 		{	*type = SOAP_TYPE_std__string;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax], 18			; 00000012H

; 209  : 			return soap_in_std__string(soap, NULL, NULL, NULL);

	mov	eax, ebx
	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN310@soap_getel
	cmp	WORD PTR [ebx+87220], ax
	jne	$LN1@soap_getel
	lea	ecx, DWORD PTR [ebx+80052]
	push	ecx
	push	ebx
	xor	edi, edi
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [ebx+90460], eax
	test	eax, eax
	jne	SHORT $LN310@soap_getel
	xor	edx, edx
	mov	WORD PTR [ebx+87308], dx
	cmp	WORD PTR [ebx+12442], dx
	je	SHORT $LN310@soap_getel
	inc	DWORD PTR [ebx+12444]
$LN310@soap_getel:
	cmp	DWORD PTR [ebx+90460], 0
	je	$LN87@soap_getel

; 295  : 	return NULL;

	xor	eax, eax

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@soap_getel:

; 210  : 		}
; 211  : 		if (!soap_match_tag(soap, t, "xsd:string"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0L@DIJPMJCO@xsd?3string?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@soap_getel

; 212  : 		{	*type = SOAP_TYPE_xsd__string;

	mov	eax, DWORD PTR _type$[ebp]

; 213  : 			return soap_in_xsd__string(soap, NULL, NULL, NULL);

	push	0
	mov	DWORD PTR [eax], 17			; 00000011H
	push	0
	push	0
	mov	eax, ebx
	call	?soap_in_xsd__string@@YAPAVxsd__string@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__string
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@soap_getel:

; 214  : 		}
; 215  : 		if (!soap_match_tag(soap, t, "xsd:long"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_08PNDIDGIB@xsd?3long?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@soap_getel

; 216  : 		{	*type = SOAP_TYPE_xsd__long;

	mov	ecx, DWORD PTR _type$[ebp]

; 217  : 			return soap_in_xsd__long(soap, NULL, NULL, NULL);

	push	eax
	push	eax
	push	eax
	mov	eax, ebx
	mov	DWORD PTR [ecx], 15			; 0000000fH
	call	?soap_in_xsd__long@@YAPAVxsd__long@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__long
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@soap_getel:

; 218  : 		}
; 219  : 		if (!soap_match_tag(soap, t, "xsd:int"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_07PCIGPDP@xsd?3int?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@soap_getel

; 220  : 		{	*type = SOAP_TYPE_xsd__int;

	mov	edx, DWORD PTR _type$[ebp]

; 221  : 			return soap_in_xsd__int(soap, NULL, NULL, NULL);

	push	eax
	push	eax
	push	eax
	mov	eax, ebx
	mov	DWORD PTR [edx], 14			; 0000000eH
	call	?soap_in_xsd__int@@YAPAVxsd__int@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__int
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@soap_getel:

; 222  : 		}
; 223  : 		if (!soap_match_tag(soap, t, "xsd:float"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_09ILBLHFBD@xsd?3float?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@soap_getel

; 224  : 		{	*type = SOAP_TYPE_xsd__float;

	mov	eax, DWORD PTR _type$[ebp]

; 225  : 			return soap_in_xsd__float(soap, NULL, NULL, NULL);

	push	0
	mov	DWORD PTR [eax], 12			; 0000000cH
	push	0
	push	0
	mov	eax, ebx
	call	?soap_in_xsd__float@@YAPAVxsd__float@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__float
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@soap_getel:

; 226  : 		}
; 227  : 		if (!soap_match_tag(soap, t, "xsd:boolean"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0M@FGHMEICI@xsd?3boolean?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@soap_getel

; 228  : 		{	*type = SOAP_TYPE_xsd__boolean;

	mov	ecx, DWORD PTR _type$[ebp]

; 229  : 			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);

	push	eax
	push	eax
	push	eax
	mov	eax, ebx
	mov	DWORD PTR [ecx], 10			; 0000000aH
	call	?soap_in_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__boolean
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@soap_getel:

; 230  : 		}
; 231  : 		if (!soap_match_tag(soap, t, "xsd:anyType"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0M@NOIFKOBF@xsd?3anyType?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@soap_getel

; 232  : 		{	*type = SOAP_TYPE_xsd__anyType;

	mov	edx, DWORD PTR _type$[ebp]

; 233  : 			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);

	push	eax
	push	eax
	push	eax
	mov	eax, ebx
	mov	DWORD PTR [edx], 8
	call	?soap_in_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__anyType
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@soap_getel:

; 234  : 		}
; 235  : 		if (!soap_match_tag(soap, t, "xsd:byte"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_08BEPNMEIH@xsd?3byte?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@soap_getel

; 236  : 		{	*type = SOAP_TYPE_byte;

	mov	eax, DWORD PTR _type$[ebp]

; 237  : 			return soap_in_byte(soap, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	ebx
	mov	DWORD PTR [eax], 3
	call	_soap_inbyte
	add	esp, 16					; 00000010H

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@soap_getel:

; 238  : 		}
; 239  : 		if (!soap_match_tag(soap, t, "xsd:int"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_07PCIGPDP@xsd?3int?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@soap_getel

; 240  : 		{	*type = SOAP_TYPE_int;

	mov	ecx, DWORD PTR _type$[ebp]

; 241  : 			return soap_in_int(soap, NULL, NULL, NULL);

	push	eax
	push	eax
	push	eax
	push	ebx
	mov	DWORD PTR [ecx], 1
	call	_soap_inint
	add	esp, 16					; 00000010H

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@soap_getel:

; 242  : 		}
; 243  : 		if (!soap_match_tag(soap, t, "xsd:long"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_08PNDIDGIB@xsd?3long?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@soap_getel

; 244  : 		{	*type = SOAP_TYPE_LONG64;

	mov	edx, DWORD PTR _type$[ebp]

; 245  : 			return soap_in_LONG64(soap, NULL, NULL, NULL);

	push	eax
	push	eax
	push	eax
	mov	eax, ebx
	mov	DWORD PTR [edx], 16			; 00000010H
	call	_soap_inLONG64
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@soap_getel:

; 246  : 		}
; 247  : 		if (!soap_match_tag(soap, t, "xsd:float"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_09ILBLHFBD@xsd?3float?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@soap_getel

; 248  : 		{	*type = SOAP_TYPE_float;

	mov	eax, DWORD PTR _type$[ebp]

; 249  : 			return soap_in_float(soap, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	ebx
	mov	DWORD PTR [eax], 13			; 0000000dH
	call	_soap_infloat
	add	esp, 16					; 00000010H

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@soap_getel:

; 250  : 		}
; 251  : 		if (!soap_match_tag(soap, t, "xsd:boolean"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0M@FGHMEICI@xsd?3boolean?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@soap_getel

; 252  : 		{	*type = SOAP_TYPE_bool;

	mov	ecx, DWORD PTR _type$[ebp]

; 253  : 			return soap_in_bool(soap, NULL, NULL, NULL);

	push	eax
	push	eax
	push	eax
	mov	eax, ebx
	mov	DWORD PTR [ecx], 11			; 0000000bH
	call	?soap_in_bool@@YAPA_NPAUsoap@@PBDPA_N1@Z ; soap_in_bool
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@soap_getel:

; 254  : 		}
; 255  : 		if (!soap_match_tag(soap, t, "xsd:string"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0L@DIJPMJCO@xsd?3string?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	$LN8@soap_getel

; 256  : 		{	char **s;
; 257  : 			*type = SOAP_TYPE_string;

	mov	edx, DWORD PTR _type$[ebp]

; 258  : 			s = soap_in_string(soap, NULL, NULL, NULL);

	push	eax
	push	1
	mov	esi, ebx
	mov	DWORD PTR [edx], 4
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	jne	$LN396@soap_getel
	mov	eax, 4
	mov	edi, ebx
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi
	je	$LN396@soap_getel
	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN339@soap_getel
	push	1
	mov	ecx, ebx
	call	_soap_string_in
	add	esp, 4
	mov	DWORD PTR [edi], eax
	test	eax, eax
	je	$LN396@soap_getel
	push	0
	push	0
	push	4
	push	4
	push	eax
	push	ebx
	xor	eax, eax
	lea	ecx, DWORD PTR [ebx+81076]
	call	_soap_id_enter
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN331@soap_getel

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0

; 258  : 			s = soap_in_string(soap, NULL, NULL, NULL);

$LN339@soap_getel:
	cmp	WORD PTR [ebx+87300], 0
	je	SHORT $LN332@soap_getel
	mov	DWORD PTR [edi], 0
	jmp	SHORT $LN331@soap_getel
$LN332@soap_getel:
	push	OFFSET _soap_padding
	push	ebx
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR [edi], eax
$LN331@soap_getel:
	cmp	BYTE PTR [ebx+82100], 0
	lea	eax, DWORD PTR [ebx+82100]
	je	SHORT $LN330@soap_getel
	push	4
	push	4
	push	edi
	mov	ecx, ebx
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH
	mov	edi, eax
$LN330@soap_getel:
	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN329@soap_getel
	push	0
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	jne	$LN396@soap_getel
$LN329@soap_getel:

; 259  : 			return s ? *s : NULL;

	test	edi, edi
	je	$LN396@soap_getel
	mov	eax, DWORD PTR [edi]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@soap_getel:

; 260  : 		}
; 261  : 		t = soap->tag;

	lea	esi, DWORD PTR [ebx+80052]

; 262  : 		if (!soap_match_tag(soap, t, "ns2:submitEpochResultResponseElement"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0CF@HCKJIEH@ns2?3submitEpochResultResponseEle@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@soap_getel

; 263  : 		{	*type = SOAP_TYPE__ns2__submitEpochResultResponseElement;

	mov	eax, DWORD PTR _type$[ebp]

; 264  : 			return soap_in__ns2__submitEpochResultResponseElement(soap, NULL, NULL, NULL);

	push	0
	mov	DWORD PTR [eax], 24			; 00000018H
	push	0
	push	0
	mov	eax, ebx
	call	?soap_in__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__submitEpochResultResponseElement
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@soap_getel:

; 265  : 		}
; 266  : 		if (!soap_match_tag(soap, t, "ns2:submitEpochResultElement"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0BN@LEHNEPKC@ns2?3submitEpochResultElement?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@soap_getel

; 267  : 		{	*type = SOAP_TYPE__ns2__submitEpochResultElement;

	mov	ecx, DWORD PTR _type$[ebp]

; 268  : 			return soap_in__ns2__submitEpochResultElement(soap, NULL, NULL, NULL);

	push	eax
	push	eax
	push	eax
	mov	eax, ebx
	mov	DWORD PTR [ecx], 23			; 00000017H
	call	?soap_in__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__submitEpochResultElement
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@soap_getel:

; 269  : 		}
; 270  : 		if (!soap_match_tag(soap, t, "ns2:getSettingsFileResponseElement"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0CD@GADHDKNA@ns2?3getSettingsFileResponseEleme@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@soap_getel

; 271  : 		{	*type = SOAP_TYPE__ns2__getSettingsFileResponseElement;

	mov	edx, DWORD PTR _type$[ebp]

; 272  : 			return soap_in__ns2__getSettingsFileResponseElement(soap, NULL, NULL, NULL);

	push	eax
	push	eax
	push	eax
	mov	eax, ebx
	mov	DWORD PTR [edx], 22			; 00000016H
	call	?soap_in__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSettingsFileResponseElement
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@soap_getel:

; 273  : 		}
; 274  : 		if (!soap_match_tag(soap, t, "ns2:getSettingsFileElement"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0BL@EBHOCBLE@ns2?3getSettingsFileElement?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@soap_getel

; 275  : 		{	*type = SOAP_TYPE__ns2__getSettingsFileElement;

	mov	eax, DWORD PTR _type$[ebp]

; 276  : 			return soap_in__ns2__getSettingsFileElement(soap, NULL, NULL, NULL);

	push	0
	mov	DWORD PTR [eax], 21			; 00000015H
	push	0
	push	0
	mov	eax, ebx
	call	?soap_in__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSettingsFileElement
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@soap_getel:

; 277  : 		}
; 278  : 		if (!soap_match_tag(soap, t, "ns2:getSessionIDResponseElement"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0CA@KPMHIEOJ@ns2?3getSessionIDResponseElement?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@soap_getel

; 279  : 		{	*type = SOAP_TYPE__ns2__getSessionIDResponseElement;

	mov	ecx, DWORD PTR _type$[ebp]

; 280  : 			return soap_in__ns2__getSessionIDResponseElement(soap, NULL, NULL, NULL);

	push	eax
	push	eax
	push	eax
	mov	eax, ebx
	mov	DWORD PTR [ecx], 20			; 00000014H
	call	?soap_in__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSessionIDResponseElement
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@soap_getel:

; 281  : 		}
; 282  : 		if (!soap_match_tag(soap, t, "ns2:getSessionIDElement"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0BI@CHGDHCPP@ns2?3getSessionIDElement?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@soap_getel

; 283  : 		{	*type = SOAP_TYPE__ns2__getSessionIDElement;

	mov	edx, DWORD PTR _type$[ebp]

; 284  : 			return soap_in__ns2__getSessionIDElement(soap, NULL, NULL, NULL);

	push	eax
	push	eax
	push	eax
	mov	eax, ebx
	mov	DWORD PTR [edx], 19			; 00000013H
	call	?soap_in__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSessionIDElement
	add	esp, 12					; 0000000cH

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@soap_getel:

; 285  : 		}
; 286  : 		if (!soap_match_tag(soap, t, "xsd:QName"))

	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_09JDHJJDCF@xsd?3QName?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	$LN1@soap_getel

; 287  : 		{	char **s;
; 288  : 			*type = SOAP_TYPE__QName;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax], 5

; 289  : 			s = soap_in__QName(soap, NULL, NULL, NULL);

	push	0
	push	1
	xor	eax, eax
	mov	esi, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	jne	$LN396@soap_getel
	mov	eax, 4
	mov	edi, ebx
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi
	je	$LN396@soap_getel
	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN359@soap_getel
	push	2
	mov	ecx, ebx
	call	_soap_string_in
	add	esp, 4
	mov	DWORD PTR [edi], eax
	test	eax, eax
	je	$LN396@soap_getel
	push	0
	push	0
	push	4
	push	5
	push	eax
	push	ebx
	xor	eax, eax
	lea	ecx, DWORD PTR [ebx+81076]
	call	_soap_id_enter
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN351@soap_getel

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0

; 289  : 			s = soap_in__QName(soap, NULL, NULL, NULL);

$LN359@soap_getel:
	cmp	WORD PTR [ebx+87300], 0
	je	SHORT $LN352@soap_getel
	mov	DWORD PTR [edi], 0
	jmp	SHORT $LN351@soap_getel
$LN352@soap_getel:
	push	OFFSET _soap_padding
	push	ebx
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR [edi], eax
$LN351@soap_getel:
	cmp	BYTE PTR [ebx+82100], 0
	lea	eax, DWORD PTR [ebx+82100]
	je	SHORT $LN350@soap_getel
	push	4
	push	5
	push	edi
	mov	ecx, ebx
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH
	mov	edi, eax
$LN350@soap_getel:
	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN349@soap_getel
	push	0
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN396@soap_getel
$LN349@soap_getel:

; 290  : 			return s ? *s : NULL;

	test	edi, edi
	je	SHORT $LN396@soap_getel
	mov	eax, DWORD PTR [edi]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@soap_getel:

; 291  : 		}
; 292  : 	}
; 293  : 	}
; 294  : 	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [ebx+90460], 3
$LN396@soap_getel:

; 296  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN400@soap_getel:
	DD	$LN41@soap_getel
	DD	$LN42@soap_getel
	DD	$LN23@soap_getel
	DD	$LN31@soap_getel
	DD	$LN32@soap_getel
	DD	$LN38@soap_getel
	DD	$LN33@soap_getel
	DD	$LN39@soap_getel
	DD	$LN34@soap_getel
	DD	$LN35@soap_getel
	DD	$LN40@soap_getel
	DD	$LN36@soap_getel
	DD	$LN37@soap_getel
	DD	$LN24@soap_getel
	DD	$LN25@soap_getel
	DD	$LN26@soap_getel
	DD	$LN27@soap_getel
	DD	$LN28@soap_getel
	DD	$LN29@soap_getel
	DD	$LN30@soap_getel
	DD	$LN22@soap_getel
$LN387@soap_getel:
	DB	0
	DB	20					; 00000014H
	DB	1
	DB	2
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	3
	DB	20					; 00000014H
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	13					; 0000000dH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	18					; 00000012H
	DB	19					; 00000013H
_soap_getelement ENDP
_TEXT	ENDS
PUBLIC	?soap_getindependent@@YAHPAUsoap@@@Z		; soap_getindependent
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_t$ = -4						; size = 4
?soap_getindependent@@YAHPAUsoap@@@Z PROC		; soap_getindependent
; _soap$ = esi

; 135  : {

	push	ecx
$LL7@soap_getin:

; 136  : 	int t;
; 137  : 	for (;;)
; 138  : 		if (!soap_getelement(soap, &t))

	lea	eax, DWORD PTR _t$[esp+4]
	push	eax
	push	esi
	call	_soap_getelement
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL7@soap_getin

; 139  : 			if (soap->error || soap_ignore_element(soap))

	cmp	DWORD PTR [esi+90460], eax
	jne	SHORT $LN3@soap_getin
	push	esi
	call	?soap_ignore_element@@YAHPAUsoap@@@Z	; soap_ignore_element
	add	esp, 4
	test	eax, eax

; 140  : 				break;
; 141  : 	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)

	je	SHORT $LL7@soap_getin
$LN3@soap_getin:
	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 6
	je	SHORT $LN1@soap_getin
	cmp	eax, -1
	jne	SHORT $LN2@soap_getin
$LN1@soap_getin:

; 142  : 		soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0

; 143  : 	return soap->error;

	mov	eax, DWORD PTR [esi+90460]
$LN2@soap_getin:

; 144  : }

	pop	ecx
	ret	0
?soap_getindependent@@YAHPAUsoap@@@Z ENDP		; soap_getindependent
PUBLIC	?soap_get_string@@YAPAPADPAUsoap@@PAPADPBD2@Z	; soap_get_string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_p$ = 8							; size = 4
?soap_get_string@@YAPAPADPAUsoap@@PAPADPBD2@Z PROC	; soap_get_string
; _soap$ = ecx
; _tag$ = eax

; 4313 : {

	push	esi
	push	edi

; 4314 : 	if ((p = soap_in_string(soap, tag, p, type)))

	push	1
	push	4
	push	eax
	mov	eax, DWORD PTR _p$[esp+16]
	mov	esi, ecx
	call	_soap_instring
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get_s

; 4315 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_s
	pop	edi

; 4316 : 			return NULL;

	xor	eax, eax
	pop	esi

; 4318 : }

	ret	0
$LN1@soap_get_s:

; 4317 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 4318 : }

	ret	0
?soap_get_string@@YAPAPADPAUsoap@@PAPADPBD2@Z ENDP	; soap_get_string
_TEXT	ENDS
PUBLIC	?soap_get__QName@@YAPAPADPAUsoap@@PAPADPBD2@Z	; soap_get__QName
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_p$ = 8							; size = 4
?soap_get__QName@@YAPAPADPAUsoap@@PAPADPBD2@Z PROC	; soap_get__QName
; _soap$ = ecx
; _tag$ = eax

; 4273 : {

	push	esi
	push	edi

; 4274 : 	if ((p = soap_in__QName(soap, tag, p, type)))

	push	2
	push	5
	push	eax
	mov	eax, DWORD PTR _p$[esp+16]
	mov	esi, ecx
	call	_soap_instring
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get__

; 4275 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get__
	pop	edi

; 4276 : 			return NULL;

	xor	eax, eax
	pop	esi

; 4278 : }

	ret	0
$LN1@soap_get__:

; 4277 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 4278 : }

	ret	0
?soap_get__QName@@YAPAPADPAUsoap@@PAPADPBD2@Z ENDP	; soap_get__QName
_TEXT	ENDS
PUBLIC	?soap_get_PointerTostd__string@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PAPAV12@PBD2@Z ; soap_get_PointerTostd__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_p$ = 8							; size = 4
?soap_get_PointerTostd__string@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PAPAV12@PBD2@Z PROC ; soap_get_PointerTostd__string
; _soap$ = ecx
; _tag$ = eax

; 4223 : {

	push	esi
	push	edi

; 4224 : 	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))

	push	eax
	mov	eax, DWORD PTR _p$[esp+8]
	mov	esi, ecx
	call	?soap_in_PointerTostd__string@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAPAV12@1@Z ; soap_in_PointerTostd__string
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN1@soap_get_P

; 4225 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_P
	pop	edi

; 4226 : 			return NULL;

	xor	eax, eax
	pop	esi

; 4228 : }

	ret	0
$LN1@soap_get_P:

; 4227 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 4228 : }

	ret	0
?soap_get_PointerTostd__string@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PAPAV12@PBD2@Z ENDP ; soap_get_PointerTostd__string
_TEXT	ENDS
PUBLIC	?soap_get_PointerTo_ns2__getSessionIDElement@@YAPAPAV_ns2__getSessionIDElement@@PAUsoap@@PAPAV1@PBD2@Z ; soap_get_PointerTo_ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_p$ = 8							; size = 4
?soap_get_PointerTo_ns2__getSessionIDElement@@YAPAPAV_ns2__getSessionIDElement@@PAUsoap@@PAPAV1@PBD2@Z PROC ; soap_get_PointerTo_ns2__getSessionIDElement
; _soap$ = ecx
; _tag$ = eax

; 4168 : {

	push	esi
	push	edi

; 4169 : 	if ((p = soap_in_PointerTo_ns2__getSessionIDElement(soap, tag, p, type)))

	push	0
	mov	esi, ecx
	push	1
	mov	edi, eax
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@soap_get_P@2
	xor	edi, edi
$LN1@soap_get_P@2:

; 4172 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 4173 : }

	ret	0

; 4169 : 	if ((p = soap_in_PointerTo_ns2__getSessionIDElement(soap, tag, p, type)))

$LN18@soap_get_P@2:
	mov	eax, DWORD PTR _p$[esp+4]
	push	edi
	mov	ecx, esi
	call	?soap_in_PointerTo_ns2__getSessionIDElement@@YAPAPAV_ns2__getSessionIDElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__getSessionIDElement
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN1@soap_get_P@2

; 4170 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_P@2
	pop	edi

; 4171 : 			return NULL;

	xor	eax, eax
	pop	esi

; 4173 : }

	ret	0
?soap_get_PointerTo_ns2__getSessionIDElement@@YAPAPAV_ns2__getSessionIDElement@@PAUsoap@@PAPAV1@PBD2@Z ENDP ; soap_get_PointerTo_ns2__getSessionIDElement
_TEXT	ENDS
PUBLIC	?soap_get_PointerTo_ns2__getSessionIDResponseElement@@YAPAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PAPAV1@PBD2@Z ; soap_get_PointerTo_ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_p$ = 8							; size = 4
?soap_get_PointerTo_ns2__getSessionIDResponseElement@@YAPAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PAPAV1@PBD2@Z PROC ; soap_get_PointerTo_ns2__getSessionIDResponseElement
; _soap$ = ecx
; _tag$ = eax

; 4113 : {

	push	esi
	push	edi

; 4114 : 	if ((p = soap_in_PointerTo_ns2__getSessionIDResponseElement(soap, tag, p, type)))

	push	0
	mov	esi, ecx
	push	1
	mov	edi, eax
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@soap_get_P@3
	xor	edi, edi
$LN1@soap_get_P@3:

; 4117 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 4118 : }

	ret	0

; 4114 : 	if ((p = soap_in_PointerTo_ns2__getSessionIDResponseElement(soap, tag, p, type)))

$LN18@soap_get_P@3:
	mov	eax, DWORD PTR _p$[esp+4]
	push	edi
	mov	ecx, esi
	call	?soap_in_PointerTo_ns2__getSessionIDResponseElement@@YAPAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__getSessionIDResponseElement
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN1@soap_get_P@3

; 4115 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_P@3
	pop	edi

; 4116 : 			return NULL;

	xor	eax, eax
	pop	esi

; 4118 : }

	ret	0
?soap_get_PointerTo_ns2__getSessionIDResponseElement@@YAPAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PAPAV1@PBD2@Z ENDP ; soap_get_PointerTo_ns2__getSessionIDResponseElement
_TEXT	ENDS
PUBLIC	?soap_get_PointerTo_ns2__getSettingsFileElement@@YAPAPAV_ns2__getSettingsFileElement@@PAUsoap@@PAPAV1@PBD2@Z ; soap_get_PointerTo_ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_p$ = 8							; size = 4
?soap_get_PointerTo_ns2__getSettingsFileElement@@YAPAPAV_ns2__getSettingsFileElement@@PAUsoap@@PAPAV1@PBD2@Z PROC ; soap_get_PointerTo_ns2__getSettingsFileElement
; _soap$ = ecx
; _tag$ = eax

; 4058 : {

	push	esi
	push	edi

; 4059 : 	if ((p = soap_in_PointerTo_ns2__getSettingsFileElement(soap, tag, p, type)))

	push	0
	mov	esi, ecx
	push	1
	mov	edi, eax
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@soap_get_P@4
	xor	edi, edi
$LN1@soap_get_P@4:

; 4062 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 4063 : }

	ret	0

; 4059 : 	if ((p = soap_in_PointerTo_ns2__getSettingsFileElement(soap, tag, p, type)))

$LN18@soap_get_P@4:
	mov	eax, DWORD PTR _p$[esp+4]
	push	edi
	mov	ecx, esi
	call	?soap_in_PointerTo_ns2__getSettingsFileElement@@YAPAPAV_ns2__getSettingsFileElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__getSettingsFileElement
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN1@soap_get_P@4

; 4060 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_P@4
	pop	edi

; 4061 : 			return NULL;

	xor	eax, eax
	pop	esi

; 4063 : }

	ret	0
?soap_get_PointerTo_ns2__getSettingsFileElement@@YAPAPAV_ns2__getSettingsFileElement@@PAUsoap@@PAPAV1@PBD2@Z ENDP ; soap_get_PointerTo_ns2__getSettingsFileElement
_TEXT	ENDS
PUBLIC	?soap_get_PointerTo_ns2__getSettingsFileResponseElement@@YAPAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PAPAV1@PBD2@Z ; soap_get_PointerTo_ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_p$ = 8							; size = 4
?soap_get_PointerTo_ns2__getSettingsFileResponseElement@@YAPAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PAPAV1@PBD2@Z PROC ; soap_get_PointerTo_ns2__getSettingsFileResponseElement
; _soap$ = ecx
; _tag$ = eax

; 4003 : {

	push	esi
	push	edi

; 4004 : 	if ((p = soap_in_PointerTo_ns2__getSettingsFileResponseElement(soap, tag, p, type)))

	push	0
	mov	esi, ecx
	push	1
	mov	edi, eax
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@soap_get_P@5
	xor	edi, edi
$LN1@soap_get_P@5:

; 4007 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 4008 : }

	ret	0

; 4004 : 	if ((p = soap_in_PointerTo_ns2__getSettingsFileResponseElement(soap, tag, p, type)))

$LN18@soap_get_P@5:
	mov	eax, DWORD PTR _p$[esp+4]
	push	edi
	mov	ecx, esi
	call	?soap_in_PointerTo_ns2__getSettingsFileResponseElement@@YAPAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__getSettingsFileResponseElement
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN1@soap_get_P@5

; 4005 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_P@5
	pop	edi

; 4006 : 			return NULL;

	xor	eax, eax
	pop	esi

; 4008 : }

	ret	0
?soap_get_PointerTo_ns2__getSettingsFileResponseElement@@YAPAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PAPAV1@PBD2@Z ENDP ; soap_get_PointerTo_ns2__getSettingsFileResponseElement
_TEXT	ENDS
PUBLIC	?soap_get_PointerTo_ns2__submitEpochResultElement@@YAPAPAV_ns2__submitEpochResultElement@@PAUsoap@@PAPAV1@PBD2@Z ; soap_get_PointerTo_ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_p$ = 8							; size = 4
?soap_get_PointerTo_ns2__submitEpochResultElement@@YAPAPAV_ns2__submitEpochResultElement@@PAUsoap@@PAPAV1@PBD2@Z PROC ; soap_get_PointerTo_ns2__submitEpochResultElement
; _soap$ = ecx
; _tag$ = eax

; 3948 : {

	push	esi
	push	edi

; 3949 : 	if ((p = soap_in_PointerTo_ns2__submitEpochResultElement(soap, tag, p, type)))

	push	0
	mov	esi, ecx
	push	1
	mov	edi, eax
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@soap_get_P@6
	xor	edi, edi
$LN1@soap_get_P@6:

; 3952 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 3953 : }

	ret	0

; 3949 : 	if ((p = soap_in_PointerTo_ns2__submitEpochResultElement(soap, tag, p, type)))

$LN18@soap_get_P@6:
	mov	eax, DWORD PTR _p$[esp+4]
	push	edi
	mov	ecx, esi
	call	?soap_in_PointerTo_ns2__submitEpochResultElement@@YAPAPAV_ns2__submitEpochResultElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__submitEpochResultElement
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN1@soap_get_P@6

; 3950 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_P@6
	pop	edi

; 3951 : 			return NULL;

	xor	eax, eax
	pop	esi

; 3953 : }

	ret	0
?soap_get_PointerTo_ns2__submitEpochResultElement@@YAPAPAV_ns2__submitEpochResultElement@@PAUsoap@@PAPAV1@PBD2@Z ENDP ; soap_get_PointerTo_ns2__submitEpochResultElement
_TEXT	ENDS
PUBLIC	?soap_get_PointerTo_ns2__submitEpochResultResponseElement@@YAPAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PAPAV1@PBD2@Z ; soap_get_PointerTo_ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_p$ = 8							; size = 4
?soap_get_PointerTo_ns2__submitEpochResultResponseElement@@YAPAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PAPAV1@PBD2@Z PROC ; soap_get_PointerTo_ns2__submitEpochResultResponseElement
; _soap$ = ecx
; _tag$ = eax

; 3893 : {

	push	esi
	push	edi

; 3894 : 	if ((p = soap_in_PointerTo_ns2__submitEpochResultResponseElement(soap, tag, p, type)))

	push	0
	mov	esi, ecx
	push	1
	mov	edi, eax
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@soap_get_P@7
	xor	edi, edi
$LN1@soap_get_P@7:

; 3897 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 3898 : }

	ret	0

; 3894 : 	if ((p = soap_in_PointerTo_ns2__submitEpochResultResponseElement(soap, tag, p, type)))

$LN18@soap_get_P@7:
	mov	eax, DWORD PTR _p$[esp+4]
	push	edi
	mov	ecx, esi
	call	?soap_in_PointerTo_ns2__submitEpochResultResponseElement@@YAPAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PBDPAPAV1@1@Z ; soap_in_PointerTo_ns2__submitEpochResultResponseElement
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN1@soap_get_P@7

; 3895 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_P@7
	pop	edi

; 3896 : 			return NULL;

	xor	eax, eax
	pop	esi

; 3898 : }

	ret	0
?soap_get_PointerTo_ns2__submitEpochResultResponseElement@@YAPAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PAPAV1@PBD2@Z ENDP ; soap_get_PointerTo_ns2__submitEpochResultResponseElement
_TEXT	ENDS
PUBLIC	?soap_get_PointerToSOAP_ENV__Code@@YAPAPAUSOAP_ENV__Code@@PAUsoap@@PAPAU1@PBD2@Z ; soap_get_PointerToSOAP_ENV__Code
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get_PointerToSOAP_ENV__Code@@YAPAPAUSOAP_ENV__Code@@PAUsoap@@PAPAU1@PBD2@Z PROC ; soap_get_PointerToSOAP_ENV__Code
; _p$ = ecx
; _type$ = eax

; 3841 : 	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	push	esi
	call	?soap_in_PointerToSOAP_ENV__Code@@YAPAPAUSOAP_ENV__Code@@PAUsoap@@PBDPAPAU1@1@Z ; soap_in_PointerToSOAP_ENV__Code
	mov	edi, eax
	add	esp, 16					; 00000010H
	test	edi, edi
	je	SHORT $LN1@soap_get_P@8

; 3842 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_P@8
	pop	edi

; 3843 : 			return NULL;

	xor	eax, eax
	pop	esi

; 3845 : }

	ret	0
$LN1@soap_get_P@8:

; 3844 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 3845 : }

	ret	0
?soap_get_PointerToSOAP_ENV__Code@@YAPAPAUSOAP_ENV__Code@@PAUsoap@@PAPAU1@PBD2@Z ENDP ; soap_get_PointerToSOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_get_PointerToSOAP_ENV__Reason@@YAPAPAUSOAP_ENV__Reason@@PAUsoap@@PAPAU1@PBD2@Z ; soap_get_PointerToSOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
?soap_get_PointerToSOAP_ENV__Reason@@YAPAPAUSOAP_ENV__Reason@@PAUsoap@@PAPAU1@PBD2@Z PROC ; soap_get_PointerToSOAP_ENV__Reason
; _tag$ = ecx
; _type$ = eax

; 3730 : {

	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi

; 3731 : 	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))

	push	eax
	mov	eax, DWORD PTR _p$[esp+8]
	push	ecx
	mov	ecx, esi
	call	?soap_in_PointerToSOAP_ENV__Reason@@YAPAPAUSOAP_ENV__Reason@@PAUsoap@@PBDPAPAU1@1@Z ; soap_in_PointerToSOAP_ENV__Reason
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN1@soap_get_P@9

; 3732 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_P@9
	pop	edi

; 3733 : 			return NULL;

	xor	eax, eax
	pop	esi

; 3735 : }

	ret	0
$LN1@soap_get_P@9:

; 3734 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 3735 : }

	ret	0
?soap_get_PointerToSOAP_ENV__Reason@@YAPAPAUSOAP_ENV__Reason@@PAUsoap@@PAPAU1@PBD2@Z ENDP ; soap_get_PointerToSOAP_ENV__Reason
_TEXT	ENDS
PUBLIC	?soap_get___ns1__getSessionID@@YAPAU__ns1__getSessionID@@PAUsoap@@PAU1@PBD2@Z ; soap_get___ns1__getSessionID
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_get___ns1__getSessionID@@YAPAU__ns1__getSessionID@@PAUsoap@@PAU1@PBD2@Z PROC ; soap_get___ns1__getSessionID
; _soap$ = ecx
; _p$ = eax

; 3633 : {

	push	esi
	push	edi
	mov	esi, ecx

; 3634 : 	if ((p = soap_in___ns1__getSessionID(soap, tag, p, type)))

	call	?soap_in___ns1__getSessionID@@YAPAU__ns1__getSessionID@@PAUsoap@@PBDPAU1@1@Z ; soap_in___ns1__getSessionID
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN1@soap_get__@2

; 3635 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get__@2
	pop	edi

; 3636 : 			return NULL;

	xor	eax, eax
	pop	esi

; 3638 : }

	ret	0
$LN1@soap_get__@2:

; 3637 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 3638 : }

	ret	0
?soap_get___ns1__getSessionID@@YAPAU__ns1__getSessionID@@PAUsoap@@PAU1@PBD2@Z ENDP ; soap_get___ns1__getSessionID
_TEXT	ENDS
PUBLIC	?soap_get___ns1__getSettingsFile@@YAPAU__ns1__getSettingsFile@@PAUsoap@@PAU1@PBD2@Z ; soap_get___ns1__getSettingsFile
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_get___ns1__getSettingsFile@@YAPAU__ns1__getSettingsFile@@PAUsoap@@PAU1@PBD2@Z PROC ; soap_get___ns1__getSettingsFile
; _soap$ = ecx
; _p$ = eax

; 3533 : {

	push	esi
	push	edi
	mov	esi, ecx

; 3534 : 	if ((p = soap_in___ns1__getSettingsFile(soap, tag, p, type)))

	call	?soap_in___ns1__getSettingsFile@@YAPAU__ns1__getSettingsFile@@PAUsoap@@PBDPAU1@1@Z ; soap_in___ns1__getSettingsFile
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN1@soap_get__@3

; 3535 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get__@3
	pop	edi

; 3536 : 			return NULL;

	xor	eax, eax
	pop	esi

; 3538 : }

	ret	0
$LN1@soap_get__@3:

; 3537 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 3538 : }

	ret	0
?soap_get___ns1__getSettingsFile@@YAPAU__ns1__getSettingsFile@@PAUsoap@@PAU1@PBD2@Z ENDP ; soap_get___ns1__getSettingsFile
_TEXT	ENDS
PUBLIC	?soap_get___ns1__submitEpochResult@@YAPAU__ns1__submitEpochResult@@PAUsoap@@PAU1@PBD2@Z ; soap_get___ns1__submitEpochResult
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_get___ns1__submitEpochResult@@YAPAU__ns1__submitEpochResult@@PAUsoap@@PAU1@PBD2@Z PROC ; soap_get___ns1__submitEpochResult
; _soap$ = ecx
; _p$ = eax

; 3433 : {

	push	esi
	push	edi
	mov	esi, ecx

; 3434 : 	if ((p = soap_in___ns1__submitEpochResult(soap, tag, p, type)))

	call	?soap_in___ns1__submitEpochResult@@YAPAU__ns1__submitEpochResult@@PAUsoap@@PBDPAU1@1@Z ; soap_in___ns1__submitEpochResult
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN1@soap_get__@4

; 3435 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get__@4
	pop	edi

; 3436 : 			return NULL;

	xor	eax, eax
	pop	esi

; 3438 : }

	ret	0
$LN1@soap_get__@4:

; 3437 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 3438 : }

	ret	0
?soap_get___ns1__submitEpochResult@@YAPAU__ns1__submitEpochResult@@PAUsoap@@PAU1@PBD2@Z ENDP ; soap_get___ns1__submitEpochResult
_TEXT	ENDS
PUBLIC	?soap_get_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@PAU1@PBD2@Z ; soap_get_SOAP_ENV__Header
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
?soap_get_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@PAU1@PBD2@Z PROC ; soap_get_SOAP_ENV__Header
; _tag$ = ecx
; _type$ = eax

; 3329 : {

	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi

; 3330 : 	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))

	push	eax
	mov	edi, ecx
	push	0
	mov	eax, edi
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@soap_get_S@10
	xor	edi, edi
$LN1@soap_get_S@10:

; 3333 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 3334 : }

	ret	0

; 3330 : 	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))

$LN21@soap_get_S@10:
	mov	eax, DWORD PTR _p$[esp+4]
	push	edi
	mov	ecx, esi
	call	?soap_in_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Header
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN1@soap_get_S@10

; 3331 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_S@10
	pop	edi

; 3332 : 			return NULL;

	xor	eax, eax
	pop	esi

; 3334 : }

	ret	0
?soap_get_SOAP_ENV__Header@@YAPAUSOAP_ENV__Header@@PAUsoap@@PAU1@PBD2@Z ENDP ; soap_get_SOAP_ENV__Header
_TEXT	ENDS
PUBLIC	?soap_get_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@PAU1@PBD2@Z ; soap_get_SOAP_ENV__Code
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_get_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@PAU1@PBD2@Z PROC ; soap_get_SOAP_ENV__Code
; _p$ = eax
; _tag$ = ecx

; 3213 : {

	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi

; 3214 : 	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))

	push	eax
	mov	eax, DWORD PTR _type$[esp+8]
	push	ecx
	mov	ecx, esi
	call	?soap_in_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Code
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN1@soap_get_S@11

; 3215 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_S@11
	pop	edi

; 3216 : 			return NULL;

	xor	eax, eax
	pop	esi

; 3218 : }

	ret	0
$LN1@soap_get_S@11:

; 3217 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 3218 : }

	ret	0
?soap_get_SOAP_ENV__Code@@YAPAUSOAP_ENV__Code@@PAUsoap@@PAU1@PBD2@Z ENDP ; soap_get_SOAP_ENV__Code
_TEXT	ENDS
PUBLIC	?soap_in_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_flag___any$ = -4					; size = 4
_tag$ = 8						; size = 4
_a$ = 12						; size = 4
?soap_in_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@PBDPAU1@1@Z PROC ; soap_in_SOAP_ENV__Detail
; _soap$ = ecx
; _type$ = eax

; 3096 : {

	push	ecx
	push	ebx
	push	ebp

; 3097 : 	size_t soap_flag_fault = 1;
; 3098 : 	size_t soap_flag___any = 1;
; 3099 : 	if (soap_element_begin_in(soap, tag, 0, type))

	mov	ebp, DWORD PTR _tag$[esp+8]
	push	esi
	push	edi
	push	eax
	mov	ebx, 1
	mov	esi, ecx
	push	0
	mov	eax, ebp
	mov	DWORD PTR _soap_flag___any$[esp+28], ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax

; 3100 : 		return NULL;

	jne	$LN29@soap_in_SO@4

; 3101 : 	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);

	mov	ecx, DWORD PTR _a$[esp+16]
	push	eax
	push	eax
	push	12					; 0000000cH
	push	43					; 0000002bH
	push	ecx
	lea	ecx, DWORD PTR [esi+81076]
	push	esi
	call	_soap_id_enter
	mov	edi, eax

; 3102 : 	if (!a)

	xor	eax, eax
	add	esp, 24					; 00000018H
	cmp	edi, eax

; 3103 : 		return NULL;

	je	$LN29@soap_in_SO@4

; 3104 : 	soap_default_SOAP_ENV__Detail(soap, a);

	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax

; 3105 : 	if (soap->body && !*soap->href)

	cmp	WORD PTR [esi+12442], ax
	je	$LN14@soap_in_SO@4
	cmp	BYTE PTR [esi+82100], al
	jne	$LN14@soap_in_SO@4
	mov	ebp, 3
$LL13@soap_in_SO@4:

; 3106 : 	{
; 3107 : 		for (;;)
; 3108 : 		{	soap->error = SOAP_TAG_MISMATCH;

	mov	DWORD PTR [esi+90460], ebp

; 3109 : 			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)

	test	ebx, ebx
	je	SHORT $LN10@soap_in_SO@4

; 3110 : 				if ((a->fault = soap_getelement(soap, &a->__type)))

	push	edi
	push	esi
	call	_soap_getelement
	add	esp, 8
	mov	DWORD PTR [edi+4], eax
	test	eax, eax
	je	SHORT $LN10@soap_in_SO@4

; 3111 : 				{	soap_flag_fault = 0;

	xor	ebx, ebx

; 3112 : 					continue;

	jmp	SHORT $LL13@soap_in_SO@4
$LN10@soap_in_SO@4:

; 3113 : 				}
; 3114 : 			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))

	cmp	DWORD PTR _soap_flag___any$[esp+20], 0
	je	SHORT $LN7@soap_in_SO@4
	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, ebp
	je	SHORT $LN8@soap_in_SO@4
	cmp	eax, 6
	jne	SHORT $LN7@soap_in_SO@4
$LN8@soap_in_SO@4:

; 3115 : 				if (soap_inliteral(soap, "-any", &a->__any))

	push	OFFSET ??_C@_04DPKCFHKE@?9any?$AA@
	lea	eax, DWORD PTR [edi+8]
	mov	ecx, esi
	call	_soap_inliteral
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@soap_in_SO@4

; 3116 : 				{	soap_flag___any--;

	dec	DWORD PTR _soap_flag___any$[esp+20]

; 3117 : 					continue;

	jmp	SHORT $LL13@soap_in_SO@4
$LN7@soap_in_SO@4:

; 3118 : 				}
; 3119 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], ebp
	jne	SHORT $LN6@soap_in_SO@4

; 3120 : 				soap->error = soap_ignore_element(soap);

	push	esi
	call	?soap_ignore_element@@YAHPAUsoap@@@Z	; soap_ignore_element
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
$LN6@soap_in_SO@4:

; 3121 : 			if (soap->error == SOAP_NO_TAG)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 6
	je	SHORT $LN24@soap_in_SO@4

; 3122 : 				break;
; 3123 : 			if (soap->error)

	test	eax, eax
	je	SHORT $LL13@soap_in_SO@4

; 3127 : 			return NULL;

	xor	eax, eax

; 3135 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
$LN24@soap_in_SO@4:

; 3124 : 				return NULL;
; 3125 : 		}
; 3126 : 		if (soap_element_end_in(soap, tag))

	mov	edx, DWORD PTR _tag$[esp+16]
	push	edx
$LN30@soap_in_SO@4:
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_in_SO@4
$LN29@soap_in_SO@4:

; 3127 : 			return NULL;

	xor	eax, eax

; 3135 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
$LN14@soap_in_SO@4:

; 3128 : 	}
; 3129 : 	else
; 3130 : 	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);

	push	eax
	push	12					; 0000000cH
	push	eax
	push	43					; 0000002bH
	push	eax
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH

; 3131 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in_SO@4
	push	ebp

; 3132 : 			return NULL;

	jmp	SHORT $LN30@soap_in_SO@4
$LN1@soap_in_SO@4:

; 3133 : 	}
; 3134 : 	return a;

	mov	eax, edi

; 3135 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
?soap_in_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@PBDPAU1@1@Z ENDP ; soap_in_SOAP_ENV__Detail
_TEXT	ENDS
PUBLIC	?soap_get_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@PAU1@PBD2@Z ; soap_get_SOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_get_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@PAU1@PBD2@Z PROC ; soap_get_SOAP_ENV__Detail
; _p$ = eax
; _tag$ = ecx

; 3088 : {

	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi

; 3089 : 	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))

	push	eax
	mov	eax, DWORD PTR _type$[esp+8]
	push	ecx
	mov	ecx, esi
	call	?soap_in_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Detail
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN1@soap_get_S@12

; 3090 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_S@12
	pop	edi

; 3091 : 			return NULL;

	xor	eax, eax
	pop	esi

; 3093 : }

	ret	0
$LN1@soap_get_S@12:

; 3092 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 3093 : }

	ret	0
?soap_get_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@PAU1@PBD2@Z ENDP ; soap_get_SOAP_ENV__Detail
_TEXT	ENDS
PUBLIC	?soap_get_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@PAU1@PBD2@Z ; soap_get_SOAP_ENV__Reason
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_get_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@PAU1@PBD2@Z PROC ; soap_get_SOAP_ENV__Reason
; _p$ = eax
; _tag$ = ecx

; 2971 : {

	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi

; 2972 : 	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))

	push	eax
	mov	eax, DWORD PTR _type$[esp+8]
	push	ecx
	mov	ecx, esi
	call	?soap_in_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Reason
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN1@soap_get_S@13

; 2973 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_S@13
	pop	edi

; 2974 : 			return NULL;

	xor	eax, eax
	pop	esi

; 2976 : }

	ret	0
$LN1@soap_get_S@13:

; 2975 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 2976 : }

	ret	0
?soap_get_SOAP_ENV__Reason@@YAPAUSOAP_ENV__Reason@@PAUsoap@@PAU1@PBD2@Z ENDP ; soap_get_SOAP_ENV__Reason
_TEXT	ENDS
PUBLIC	?soap_get_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@PAV1@PBD2@Z ; soap_get_xsd__anyType
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@PAV1@PBD2@Z PROC ; soap_get_xsd__anyType
; _p$ = ecx
; _type$ = eax

; 2561 : 	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	call	?soap_in_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__anyType
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get_x@2

; 2562 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_x@2
	pop	edi

; 2563 : 			return NULL;

	xor	eax, eax
	pop	esi

; 2565 : }

	ret	0
$LN1@soap_get_x@2:

; 2564 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 2565 : }

	ret	0
?soap_get_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@PAV1@PBD2@Z ENDP ; soap_get_xsd__anyType
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_get@xsd__anyType@@UAEPAXPAUsoap@@PBD1@Z PROC	; xsd__anyType::soap_get
; _this$ = ecx

; 2556 : 	return soap_get_xsd__anyType(soap, this, tag, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	eax, esi
	call	?soap_in_xsd__anyType@@YAPAVxsd__anyType@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__anyType
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN3@soap_get@2
	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN3@soap_get@2
	pop	edi
	xor	eax, eax
	pop	esi

; 2557 : }

	ret	12					; 0000000cH

; 2556 : 	return soap_get_xsd__anyType(soap, this, tag, type);

$LN3@soap_get@2:
	mov	eax, edi
	pop	edi
	pop	esi

; 2557 : }

	ret	12					; 0000000cH
?soap_get@xsd__anyType@@UAEPAXPAUsoap@@PBD1@Z ENDP	; xsd__anyType::soap_get
_TEXT	ENDS
PUBLIC	?soap_get_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@PAV1@PBD2@Z ; soap_get_xsd__boolean
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@PAV1@PBD2@Z PROC ; soap_get_xsd__boolean
; _p$ = ecx
; _type$ = eax

; 2453 : 	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	call	?soap_in_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__boolean
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get_x@3

; 2454 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_x@3
	pop	edi

; 2455 : 			return NULL;

	xor	eax, eax
	pop	esi

; 2457 : }

	ret	0
$LN1@soap_get_x@3:

; 2456 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 2457 : }

	ret	0
?soap_get_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@PAV1@PBD2@Z ENDP ; soap_get_xsd__boolean
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_get@xsd__boolean@@UAEPAXPAUsoap@@PBD1@Z PROC	; xsd__boolean::soap_get
; _this$ = ecx

; 2448 : 	return soap_get_xsd__boolean(soap, this, tag, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	eax, esi
	call	?soap_in_xsd__boolean@@YAPAVxsd__boolean@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__boolean
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN3@soap_get@3
	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN3@soap_get@3
	pop	edi
	xor	eax, eax
	pop	esi

; 2449 : }

	ret	12					; 0000000cH

; 2448 : 	return soap_get_xsd__boolean(soap, this, tag, type);

$LN3@soap_get@3:
	mov	eax, edi
	pop	edi
	pop	esi

; 2449 : }

	ret	12					; 0000000cH
?soap_get@xsd__boolean@@UAEPAXPAUsoap@@PBD1@Z ENDP	; xsd__boolean::soap_get
_TEXT	ENDS
PUBLIC	?soap_get_xsd__float@@YAPAVxsd__float@@PAUsoap@@PAV1@PBD2@Z ; soap_get_xsd__float
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get_xsd__float@@YAPAVxsd__float@@PAUsoap@@PAV1@PBD2@Z PROC ; soap_get_xsd__float
; _p$ = ecx
; _type$ = eax

; 2344 : 	if ((p = soap_in_xsd__float(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	call	?soap_in_xsd__float@@YAPAVxsd__float@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__float
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get_x@4

; 2345 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_x@4
	pop	edi

; 2346 : 			return NULL;

	xor	eax, eax
	pop	esi

; 2348 : }

	ret	0
$LN1@soap_get_x@4:

; 2347 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 2348 : }

	ret	0
?soap_get_xsd__float@@YAPAVxsd__float@@PAUsoap@@PAV1@PBD2@Z ENDP ; soap_get_xsd__float
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_get@xsd__float@@UAEPAXPAUsoap@@PBD1@Z PROC	; xsd__float::soap_get
; _this$ = ecx

; 2339 : 	return soap_get_xsd__float(soap, this, tag, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	eax, esi
	call	?soap_in_xsd__float@@YAPAVxsd__float@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__float
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN3@soap_get@4
	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN3@soap_get@4
	pop	edi
	xor	eax, eax
	pop	esi

; 2340 : }

	ret	12					; 0000000cH

; 2339 : 	return soap_get_xsd__float(soap, this, tag, type);

$LN3@soap_get@4:
	mov	eax, edi
	pop	edi
	pop	esi

; 2340 : }

	ret	12					; 0000000cH
?soap_get@xsd__float@@UAEPAXPAUsoap@@PBD1@Z ENDP	; xsd__float::soap_get
_TEXT	ENDS
PUBLIC	?soap_get_xsd__int@@YAPAVxsd__int@@PAUsoap@@PAV1@PBD2@Z ; soap_get_xsd__int
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get_xsd__int@@YAPAVxsd__int@@PAUsoap@@PAV1@PBD2@Z PROC ; soap_get_xsd__int
; _p$ = ecx
; _type$ = eax

; 2235 : 	if ((p = soap_in_xsd__int(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	call	?soap_in_xsd__int@@YAPAVxsd__int@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__int
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get_x@5

; 2236 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_x@5
	pop	edi

; 2237 : 			return NULL;

	xor	eax, eax
	pop	esi

; 2239 : }

	ret	0
$LN1@soap_get_x@5:

; 2238 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 2239 : }

	ret	0
?soap_get_xsd__int@@YAPAVxsd__int@@PAUsoap@@PAV1@PBD2@Z ENDP ; soap_get_xsd__int
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_get@xsd__int@@UAEPAXPAUsoap@@PBD1@Z PROC		; xsd__int::soap_get
; _this$ = ecx

; 2230 : 	return soap_get_xsd__int(soap, this, tag, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	eax, esi
	call	?soap_in_xsd__int@@YAPAVxsd__int@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__int
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN3@soap_get@5
	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN3@soap_get@5
	pop	edi
	xor	eax, eax
	pop	esi

; 2231 : }

	ret	12					; 0000000cH

; 2230 : 	return soap_get_xsd__int(soap, this, tag, type);

$LN3@soap_get@5:
	mov	eax, edi
	pop	edi
	pop	esi

; 2231 : }

	ret	12					; 0000000cH
?soap_get@xsd__int@@UAEPAXPAUsoap@@PBD1@Z ENDP		; xsd__int::soap_get
_TEXT	ENDS
PUBLIC	?soap_get_xsd__long@@YAPAVxsd__long@@PAUsoap@@PAV1@PBD2@Z ; soap_get_xsd__long
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get_xsd__long@@YAPAVxsd__long@@PAUsoap@@PAV1@PBD2@Z PROC ; soap_get_xsd__long
; _p$ = ecx
; _type$ = eax

; 2126 : 	if ((p = soap_in_xsd__long(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	call	?soap_in_xsd__long@@YAPAVxsd__long@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__long
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get_x@6

; 2127 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_x@6
	pop	edi

; 2128 : 			return NULL;

	xor	eax, eax
	pop	esi

; 2130 : }

	ret	0
$LN1@soap_get_x@6:

; 2129 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 2130 : }

	ret	0
?soap_get_xsd__long@@YAPAVxsd__long@@PAUsoap@@PAV1@PBD2@Z ENDP ; soap_get_xsd__long
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_get@xsd__long@@UAEPAXPAUsoap@@PBD1@Z PROC		; xsd__long::soap_get
; _this$ = ecx

; 2121 : 	return soap_get_xsd__long(soap, this, tag, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	eax, esi
	call	?soap_in_xsd__long@@YAPAVxsd__long@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__long
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN3@soap_get@6
	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN3@soap_get@6
	pop	edi
	xor	eax, eax
	pop	esi

; 2122 : }

	ret	12					; 0000000cH

; 2121 : 	return soap_get_xsd__long(soap, this, tag, type);

$LN3@soap_get@6:
	mov	eax, edi
	pop	edi
	pop	esi

; 2122 : }

	ret	12					; 0000000cH
?soap_get@xsd__long@@UAEPAXPAUsoap@@PBD1@Z ENDP		; xsd__long::soap_get
_TEXT	ENDS
PUBLIC	?soap_get_xsd__string@@YAPAVxsd__string@@PAUsoap@@PAV1@PBD2@Z ; soap_get_xsd__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get_xsd__string@@YAPAVxsd__string@@PAUsoap@@PAV1@PBD2@Z PROC ; soap_get_xsd__string
; _p$ = ecx
; _type$ = eax

; 2017 : 	if ((p = soap_in_xsd__string(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	call	?soap_in_xsd__string@@YAPAVxsd__string@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__string
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get_x@7

; 2018 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_x@7
	pop	edi

; 2019 : 			return NULL;

	xor	eax, eax
	pop	esi

; 2021 : }

	ret	0
$LN1@soap_get_x@7:

; 2020 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 2021 : }

	ret	0
?soap_get_xsd__string@@YAPAVxsd__string@@PAUsoap@@PAV1@PBD2@Z ENDP ; soap_get_xsd__string
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_get@xsd__string@@UAEPAXPAUsoap@@PBD1@Z PROC	; xsd__string::soap_get
; _this$ = ecx

; 2012 : 	return soap_get_xsd__string(soap, this, tag, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	eax, esi
	call	?soap_in_xsd__string@@YAPAVxsd__string@@PAUsoap@@PBDPAV1@1@Z ; soap_in_xsd__string
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN3@soap_get@7
	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN3@soap_get@7
	pop	edi
	xor	eax, eax
	pop	esi

; 2013 : }

	ret	12					; 0000000cH

; 2012 : 	return soap_get_xsd__string(soap, this, tag, type);

$LN3@soap_get@7:
	mov	eax, edi
	pop	edi
	pop	esi

; 2013 : }

	ret	12					; 0000000cH
?soap_get@xsd__string@@UAEPAXPAUsoap@@PBD1@Z ENDP	; xsd__string::soap_get
_TEXT	ENDS
PUBLIC	?soap_get_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PAV12@PBD2@Z ; soap_get_std__string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_p$ = 8							; size = 4
?soap_get_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PAV12@PBD2@Z PROC ; soap_get_std__string
; _soap$ = ecx
; _tag$ = eax

; 1904 : {

	push	esi
	push	edi

; 1905 : 	if ((p = soap_in_std__string(soap, tag, p, type)))

	push	0
	mov	esi, ecx
	push	1
	mov	edi, eax
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@soap_get_s@2
	xor	edi, edi
$LN1@soap_get_s@2:

; 1908 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 1909 : }

	ret	0

; 1905 : 	if ((p = soap_in_std__string(soap, tag, p, type)))

$LN20@soap_get_s@2:
	mov	eax, DWORD PTR _p$[esp+4]
	push	edi
	mov	ecx, esi
	call	?soap_in_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PBDPAV12@1@Z ; soap_in_std__string
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN1@soap_get_s@2

; 1906 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_s@2
	pop	edi

; 1907 : 			return NULL;

	xor	eax, eax
	pop	esi

; 1909 : }

	ret	0
?soap_get_std__string@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUsoap@@PAV12@PBD2@Z ENDP ; soap_get_std__string
_TEXT	ENDS
PUBLIC	?soap_get__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@PAV1@PBD2@Z ; soap_get__ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@PAV1@PBD2@Z PROC ; soap_get__ns2__getSessionIDElement
; _p$ = ecx
; _type$ = eax

; 1784 : 	if ((p = soap_in__ns2__getSessionIDElement(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	call	?soap_in__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSessionIDElement
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get__@5

; 1785 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get__@5
	pop	edi

; 1786 : 			return NULL;

	xor	eax, eax
	pop	esi

; 1788 : }

	ret	0
$LN1@soap_get__@5:

; 1787 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 1788 : }

	ret	0
?soap_get__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@PAV1@PBD2@Z ENDP ; soap_get__ns2__getSessionIDElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_get@_ns2__getSessionIDElement@@UAEPAXPAUsoap@@PBD1@Z PROC ; _ns2__getSessionIDElement::soap_get
; _this$ = ecx

; 1779 : 	return soap_get__ns2__getSessionIDElement(soap, this, tag, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	eax, esi
	call	?soap_in__ns2__getSessionIDElement@@YAPAV_ns2__getSessionIDElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSessionIDElement
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN3@soap_get@8
	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN3@soap_get@8
	pop	edi
	xor	eax, eax
	pop	esi

; 1780 : }

	ret	12					; 0000000cH

; 1779 : 	return soap_get__ns2__getSessionIDElement(soap, this, tag, type);

$LN3@soap_get@8:
	mov	eax, edi
	pop	edi
	pop	esi

; 1780 : }

	ret	12					; 0000000cH
?soap_get@_ns2__getSessionIDElement@@UAEPAXPAUsoap@@PBD1@Z ENDP ; _ns2__getSessionIDElement::soap_get
_TEXT	ENDS
PUBLIC	?soap_get__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PAV1@PBD2@Z ; soap_get__ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PAV1@PBD2@Z PROC ; soap_get__ns2__getSessionIDResponseElement
; _p$ = ecx
; _type$ = eax

; 1641 : 	if ((p = soap_in__ns2__getSessionIDResponseElement(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	call	?soap_in__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSessionIDResponseElement
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get__@6

; 1642 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get__@6
	pop	edi

; 1643 : 			return NULL;

	xor	eax, eax
	pop	esi

; 1645 : }

	ret	0
$LN1@soap_get__@6:

; 1644 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 1645 : }

	ret	0
?soap_get__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PAV1@PBD2@Z ENDP ; soap_get__ns2__getSessionIDResponseElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_get@_ns2__getSessionIDResponseElement@@UAEPAXPAUsoap@@PBD1@Z PROC ; _ns2__getSessionIDResponseElement::soap_get
; _this$ = ecx

; 1636 : 	return soap_get__ns2__getSessionIDResponseElement(soap, this, tag, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	eax, esi
	call	?soap_in__ns2__getSessionIDResponseElement@@YAPAV_ns2__getSessionIDResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSessionIDResponseElement
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN3@soap_get@9
	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN3@soap_get@9
	pop	edi
	xor	eax, eax
	pop	esi

; 1637 : }

	ret	12					; 0000000cH

; 1636 : 	return soap_get__ns2__getSessionIDResponseElement(soap, this, tag, type);

$LN3@soap_get@9:
	mov	eax, edi
	pop	edi
	pop	esi

; 1637 : }

	ret	12					; 0000000cH
?soap_get@_ns2__getSessionIDResponseElement@@UAEPAXPAUsoap@@PBD1@Z ENDP ; _ns2__getSessionIDResponseElement::soap_get
_TEXT	ENDS
PUBLIC	?soap_get__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@PAV1@PBD2@Z ; soap_get__ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@PAV1@PBD2@Z PROC ; soap_get__ns2__getSettingsFileElement
; _p$ = ecx
; _type$ = eax

; 1499 : 	if ((p = soap_in__ns2__getSettingsFileElement(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	call	?soap_in__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSettingsFileElement
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get__@7

; 1500 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get__@7
	pop	edi

; 1501 : 			return NULL;

	xor	eax, eax
	pop	esi

; 1503 : }

	ret	0
$LN1@soap_get__@7:

; 1502 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 1503 : }

	ret	0
?soap_get__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@PAV1@PBD2@Z ENDP ; soap_get__ns2__getSettingsFileElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_get@_ns2__getSettingsFileElement@@UAEPAXPAUsoap@@PBD1@Z PROC ; _ns2__getSettingsFileElement::soap_get
; _this$ = ecx

; 1494 : 	return soap_get__ns2__getSettingsFileElement(soap, this, tag, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	eax, esi
	call	?soap_in__ns2__getSettingsFileElement@@YAPAV_ns2__getSettingsFileElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSettingsFileElement
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN3@soap_get@10
	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN3@soap_get@10
	pop	edi
	xor	eax, eax
	pop	esi

; 1495 : }

	ret	12					; 0000000cH

; 1494 : 	return soap_get__ns2__getSettingsFileElement(soap, this, tag, type);

$LN3@soap_get@10:
	mov	eax, edi
	pop	edi
	pop	esi

; 1495 : }

	ret	12					; 0000000cH
?soap_get@_ns2__getSettingsFileElement@@UAEPAXPAUsoap@@PBD1@Z ENDP ; _ns2__getSettingsFileElement::soap_get
_TEXT	ENDS
PUBLIC	?soap_get__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PAV1@PBD2@Z ; soap_get__ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PAV1@PBD2@Z PROC ; soap_get__ns2__getSettingsFileResponseElement
; _p$ = ecx
; _type$ = eax

; 1361 : 	if ((p = soap_in__ns2__getSettingsFileResponseElement(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	call	?soap_in__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSettingsFileResponseElement
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get__@8

; 1362 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get__@8
	pop	edi

; 1363 : 			return NULL;

	xor	eax, eax
	pop	esi

; 1365 : }

	ret	0
$LN1@soap_get__@8:

; 1364 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 1365 : }

	ret	0
?soap_get__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PAV1@PBD2@Z ENDP ; soap_get__ns2__getSettingsFileResponseElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_get@_ns2__getSettingsFileResponseElement@@UAEPAXPAUsoap@@PBD1@Z PROC ; _ns2__getSettingsFileResponseElement::soap_get
; _this$ = ecx

; 1356 : 	return soap_get__ns2__getSettingsFileResponseElement(soap, this, tag, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	eax, esi
	call	?soap_in__ns2__getSettingsFileResponseElement@@YAPAV_ns2__getSettingsFileResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__getSettingsFileResponseElement
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN3@soap_get@11
	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN3@soap_get@11
	pop	edi
	xor	eax, eax
	pop	esi

; 1357 : }

	ret	12					; 0000000cH

; 1356 : 	return soap_get__ns2__getSettingsFileResponseElement(soap, this, tag, type);

$LN3@soap_get@11:
	mov	eax, edi
	pop	edi
	pop	esi

; 1357 : }

	ret	12					; 0000000cH
?soap_get@_ns2__getSettingsFileResponseElement@@UAEPAXPAUsoap@@PBD1@Z ENDP ; _ns2__getSettingsFileResponseElement::soap_get
_TEXT	ENDS
PUBLIC	?soap_get__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@PAV1@PBD2@Z ; soap_get__ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@PAV1@PBD2@Z PROC ; soap_get__ns2__submitEpochResultElement
; _p$ = ecx
; _type$ = eax

; 1187 : 	if ((p = soap_in__ns2__submitEpochResultElement(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	call	?soap_in__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__submitEpochResultElement
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get__@9

; 1188 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get__@9
	pop	edi

; 1189 : 			return NULL;

	xor	eax, eax
	pop	esi

; 1191 : }

	ret	0
$LN1@soap_get__@9:

; 1190 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 1191 : }

	ret	0
?soap_get__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@PAV1@PBD2@Z ENDP ; soap_get__ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_get@_ns2__submitEpochResultElement@@UAEPAXPAUsoap@@PBD1@Z PROC ; _ns2__submitEpochResultElement::soap_get
; _this$ = ecx

; 1182 : 	return soap_get__ns2__submitEpochResultElement(soap, this, tag, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	eax, esi
	call	?soap_in__ns2__submitEpochResultElement@@YAPAV_ns2__submitEpochResultElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__submitEpochResultElement
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN3@soap_get@12
	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN3@soap_get@12
	pop	edi
	xor	eax, eax
	pop	esi

; 1183 : }

	ret	12					; 0000000cH

; 1182 : 	return soap_get__ns2__submitEpochResultElement(soap, this, tag, type);

$LN3@soap_get@12:
	mov	eax, edi
	pop	edi
	pop	esi

; 1183 : }

	ret	12					; 0000000cH
?soap_get@_ns2__submitEpochResultElement@@UAEPAXPAUsoap@@PBD1@Z ENDP ; _ns2__submitEpochResultElement::soap_get
_TEXT	ENDS
PUBLIC	?soap_get__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PAV1@PBD2@Z ; soap_get__ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PAV1@PBD2@Z PROC ; soap_get__ns2__submitEpochResultResponseElement
; _p$ = ecx
; _type$ = eax

; 1019 : 	if ((p = soap_in__ns2__submitEpochResultResponseElement(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	call	?soap_in__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__submitEpochResultResponseElement
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get__@10

; 1020 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get__@10
	pop	edi

; 1021 : 			return NULL;

	xor	eax, eax
	pop	esi

; 1023 : }

	ret	0
$LN1@soap_get__@10:

; 1022 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 1023 : }

	ret	0
?soap_get__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PAV1@PBD2@Z ENDP ; soap_get__ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
?soap_get@_ns2__submitEpochResultResponseElement@@UAEPAXPAUsoap@@PBD1@Z PROC ; _ns2__submitEpochResultResponseElement::soap_get
; _this$ = ecx

; 1014 : 	return soap_get__ns2__submitEpochResultResponseElement(soap, this, tag, type);

	mov	eax, DWORD PTR _type$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	eax, esi
	call	?soap_in__ns2__submitEpochResultResponseElement@@YAPAV_ns2__submitEpochResultResponseElement@@PAUsoap@@PBDPAV1@1@Z ; soap_in__ns2__submitEpochResultResponseElement
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN3@soap_get@13
	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN3@soap_get@13
	pop	edi
	xor	eax, eax
	pop	esi

; 1015 : }

	ret	12					; 0000000cH

; 1014 : 	return soap_get__ns2__submitEpochResultResponseElement(soap, this, tag, type);

$LN3@soap_get@13:
	mov	eax, edi
	pop	edi
	pop	esi

; 1015 : }

	ret	12					; 0000000cH
?soap_get@_ns2__submitEpochResultResponseElement@@UAEPAXPAUsoap@@PBD1@Z ENDP ; _ns2__submitEpochResultResponseElement::soap_get
_TEXT	ENDS
PUBLIC	?soap_get_bool@@YAPA_NPAUsoap@@PA_NPBD2@Z	; soap_get_bool
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get_bool@@YAPA_NPAUsoap@@PA_NPBD2@Z PROC		; soap_get_bool
; _p$ = ecx
; _type$ = eax

; 929  : 	if ((p = soap_in_bool(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	call	?soap_in_bool@@YAPA_NPAUsoap@@PBDPA_N1@Z ; soap_in_bool
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get_b

; 930  : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_b
	pop	edi

; 931  : 			return NULL;

	xor	eax, eax
	pop	esi

; 933  : }

	ret	0
$LN1@soap_get_b:

; 932  : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 933  : }

	ret	0
?soap_get_bool@@YAPA_NPAUsoap@@PA_NPBD2@Z ENDP		; soap_get_bool
_TEXT	ENDS
PUBLIC	?soap_get_float@@YAPAMPAUsoap@@PAMPBD2@Z	; soap_get_float
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get_float@@YAPAMPAUsoap@@PAMPBD2@Z PROC		; soap_get_float
; _p$ = ecx
; _type$ = eax

; 883  : 	if ((p = soap_in_float(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_soap_infloat
	mov	edi, eax
	add	esp, 16					; 00000010H
	test	edi, edi
	je	SHORT $LN1@soap_get_f

; 884  : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_f
	pop	edi

; 885  : 			return NULL;

	xor	eax, eax
	pop	esi

; 887  : }

	ret	0
$LN1@soap_get_f:

; 886  : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 887  : }

	ret	0
?soap_get_float@@YAPAMPAUsoap@@PAMPBD2@Z ENDP		; soap_get_float
_TEXT	ENDS
PUBLIC	?soap_get_LONG64@@YAPA_JPAUsoap@@PA_JPBD2@Z	; soap_get_LONG64
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get_LONG64@@YAPA_JPAUsoap@@PA_JPBD2@Z PROC	; soap_get_LONG64
; _p$ = ecx
; _type$ = eax

; 848  : 	if ((p = soap_in_LONG64(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	call	_soap_inLONG64
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN1@soap_get_L@2

; 849  : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_L@2
	pop	edi

; 850  : 			return NULL;

	xor	eax, eax
	pop	esi

; 852  : }

	ret	0
$LN1@soap_get_L@2:

; 851  : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 852  : }

	ret	0
?soap_get_LONG64@@YAPA_JPAUsoap@@PA_JPBD2@Z ENDP	; soap_get_LONG64
_TEXT	ENDS
PUBLIC	?soap_get_int@@YAPAHPAUsoap@@PAHPBD2@Z		; soap_get_int
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get_int@@YAPAHPAUsoap@@PAHPBD2@Z PROC		; soap_get_int
; _p$ = ecx
; _type$ = eax

; 813  : 	if ((p = soap_in_int(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_soap_inint
	mov	edi, eax
	add	esp, 16					; 00000010H
	test	edi, edi
	je	SHORT $LN1@soap_get_i

; 814  : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_i
	pop	edi

; 815  : 			return NULL;

	xor	eax, eax
	pop	esi

; 817  : }

	ret	0
$LN1@soap_get_i:

; 816  : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 817  : }

	ret	0
?soap_get_int@@YAPAHPAUsoap@@PAHPBD2@Z ENDP		; soap_get_int
_TEXT	ENDS
PUBLIC	?soap_get_byte@@YAPADPAUsoap@@PADPBD2@Z		; soap_get_byte
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
?soap_get_byte@@YAPADPAUsoap@@PADPBD2@Z PROC		; soap_get_byte
; _p$ = ecx
; _type$ = eax

; 778  : 	if ((p = soap_in_byte(soap, tag, p, type)))

	mov	edx, DWORD PTR _tag$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_soap_inbyte
	mov	edi, eax
	add	esp, 16					; 00000010H
	test	edi, edi
	je	SHORT $LN1@soap_get_b@2

; 779  : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_b@2
	pop	edi

; 780  : 			return NULL;

	xor	eax, eax
	pop	esi

; 782  : }

	ret	0
$LN1@soap_get_b@2:

; 781  : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 782  : }

	ret	0
?soap_get_byte@@YAPADPAUsoap@@PADPBD2@Z ENDP		; soap_get_byte
PUBLIC	?soap_in_PointerToSOAP_ENV__Detail@@YAPAPAUSOAP_ENV__Detail@@PAUsoap@@PBDPAPAU1@1@Z ; soap_in_PointerToSOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_type$ = 12						; size = 4
?soap_in_PointerToSOAP_ENV__Detail@@YAPAPAUSOAP_ENV__Detail@@PAUsoap@@PBDPAPAU1@1@Z PROC ; soap_in_PointerToSOAP_ENV__Detail
; _soap$ = ecx
; _a$ = eax

; 3793 : {

	push	ebx
	mov	ebx, DWORD PTR _tag$[esp]
	push	esi
	push	edi
	mov	edi, eax

; 3794 : 	if (soap_element_begin_in(soap, tag, 1, NULL))

	push	0
	mov	esi, ecx
	push	1
	mov	eax, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax

; 3795 : 		return NULL;

	jne	SHORT $LN10@soap_in_Po@10

; 3796 : 	if (!a)

	test	edi, edi
	jne	SHORT $LN5@soap_in_Po@10

; 3797 : 		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))

	lea	eax, DWORD PTR [edi+4]
	mov	edi, esi
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi

; 3798 : 			return NULL;

	je	SHORT $LN10@soap_in_Po@10
$LN5@soap_in_Po@10:

; 3799 : 	*a = NULL;

	mov	DWORD PTR [edi], 0

; 3800 : 	if (!soap->null && *soap->href != '#')

	cmp	WORD PTR [esi+87300], 0
	jne	SHORT $LN4@soap_in_Po@10
	cmp	BYTE PTR [esi+82100], 35		; 00000023H
	je	SHORT $LN4@soap_in_Po@10

; 3801 : 	{	soap_revert(soap);

	mov	eax, esi
	call	_soap_revert

; 3802 : 		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))

	mov	eax, DWORD PTR [edi]
	push	eax
	mov	eax, DWORD PTR _type$[esp+12]
	push	ebx
	mov	ecx, esi
	call	?soap_in_SOAP_ENV__Detail@@YAPAUSOAP_ENV__Detail@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Detail
	add	esp, 8
	mov	DWORD PTR [edi], eax
	test	eax, eax
	jne	SHORT $LN1@soap_in_Po@10
$LN10@soap_in_Po@10:

; 3803 : 			return NULL;

	xor	eax, eax

; 3811 : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
$LN4@soap_in_Po@10:

; 3804 : 	}
; 3805 : 	else
; 3806 : 	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);

	push	12					; 0000000cH
	push	43					; 0000002bH
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	mov	ecx, esi
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH

; 3807 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax
	je	SHORT $LN1@soap_in_Po@10
	push	ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 3808 : 			return NULL;

	jne	SHORT $LN10@soap_in_Po@10
$LN1@soap_in_Po@10:

; 3809 : 	}
; 3810 : 	return a;

	mov	eax, edi

; 3811 : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?soap_in_PointerToSOAP_ENV__Detail@@YAPAPAUSOAP_ENV__Detail@@PAUsoap@@PBDPAPAU1@1@Z ENDP ; soap_in_PointerToSOAP_ENV__Detail
_TEXT	ENDS
PUBLIC	?soap_get_PointerToSOAP_ENV__Detail@@YAPAPAUSOAP_ENV__Detail@@PAUsoap@@PAPAU1@PBD2@Z ; soap_get_PointerToSOAP_ENV__Detail
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
?soap_get_PointerToSOAP_ENV__Detail@@YAPAPAUSOAP_ENV__Detail@@PAUsoap@@PAPAU1@PBD2@Z PROC ; soap_get_PointerToSOAP_ENV__Detail
; _tag$ = ecx
; _type$ = eax

; 3785 : {

	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi

; 3786 : 	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))

	push	eax
	mov	eax, DWORD PTR _p$[esp+8]
	push	ecx
	mov	ecx, esi
	call	?soap_in_PointerToSOAP_ENV__Detail@@YAPAPAUSOAP_ENV__Detail@@PAUsoap@@PBDPAPAU1@1@Z ; soap_in_PointerToSOAP_ENV__Detail
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN1@soap_get_P@10

; 3787 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_P@10
	pop	edi

; 3788 : 			return NULL;

	xor	eax, eax
	pop	esi

; 3790 : }

	ret	0
$LN1@soap_get_P@10:

; 3789 : 	return p;

	mov	eax, edi
	pop	edi
	pop	esi

; 3790 : }

	ret	0
?soap_get_PointerToSOAP_ENV__Detail@@YAPAPAUSOAP_ENV__Detail@@PAUsoap@@PAPAU1@PBD2@Z ENDP ; soap_get_PointerToSOAP_ENV__Detail
_TEXT	ENDS
PUBLIC	?soap_in_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_flag_faultcode$ = -36				; size = 4
_soap_flag_faultstring$ = -32				; size = 4
_soap_flag_faultactor$ = -28				; size = 4
_soap_flag_detail$ = -24				; size = 4
_soap_flag_SOAP_ENV__Code$ = -20			; size = 4
_soap_flag_SOAP_ENV__Reason$ = -16			; size = 4
_soap_flag_SOAP_ENV__Node$ = -12			; size = 4
_soap_flag_SOAP_ENV__Role$ = -8				; size = 4
_soap_flag_SOAP_ENV__Detail$ = -4			; size = 4
?soap_in_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@PBDPAU1@1@Z PROC ; soap_in_SOAP_ENV__Fault
; _soap$ = eax

; 2814 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 2815 : 	size_t soap_flag_faultcode = 1;

	mov	eax, 1
	push	edi
	mov	DWORD PTR _soap_flag_faultcode$[esp+52], eax

; 2816 : 	size_t soap_flag_faultstring = 1;

	mov	DWORD PTR _soap_flag_faultstring$[esp+52], eax

; 2817 : 	size_t soap_flag_faultactor = 1;

	mov	DWORD PTR _soap_flag_faultactor$[esp+52], eax

; 2818 : 	size_t soap_flag_detail = 1;

	mov	DWORD PTR _soap_flag_detail$[esp+52], eax

; 2819 : 	size_t soap_flag_SOAP_ENV__Code = 1;

	mov	DWORD PTR _soap_flag_SOAP_ENV__Code$[esp+52], eax

; 2820 : 	size_t soap_flag_SOAP_ENV__Reason = 1;

	mov	DWORD PTR _soap_flag_SOAP_ENV__Reason$[esp+52], eax

; 2821 : 	size_t soap_flag_SOAP_ENV__Node = 1;

	mov	DWORD PTR _soap_flag_SOAP_ENV__Node$[esp+52], eax

; 2822 : 	size_t soap_flag_SOAP_ENV__Role = 1;

	mov	DWORD PTR _soap_flag_SOAP_ENV__Role$[esp+52], eax

; 2823 : 	size_t soap_flag_SOAP_ENV__Detail = 1;

	mov	DWORD PTR _soap_flag_SOAP_ENV__Detail$[esp+52], eax

; 2824 : 	if (soap_element_begin_in(soap, tag, 0, type))

	push	0
	push	0
	mov	eax, OFFSET ??_C@_0P@GLDIJMBO@SOAP?9ENV?3Fault?$AA@
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax

; 2825 : 		return NULL;

	jne	$LN83@soap_in_SO@5

; 2826 : 	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);

	push	eax
	push	eax
	push	36					; 00000024H
	push	47					; 0000002fH
	push	eax
	lea	ecx, DWORD PTR [esi+81076]
	push	esi
	call	_soap_id_enter
	mov	edi, eax
	add	esp, 24					; 00000018H

; 2827 : 	if (!a)

	test	edi, edi

; 2828 : 		return NULL;

	je	$LN83@soap_in_SO@5

; 2829 : 	soap_default_SOAP_ENV__Fault(soap, a);

	lea	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [ebp], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+20], 0
	mov	DWORD PTR [edi+24], 0
	mov	DWORD PTR [edi+28], 0
	mov	DWORD PTR [edi+32], 0

; 2830 : 	if (soap->body && !*soap->href)

	cmp	WORD PTR [esi+12442], 0
	je	$LN32@soap_in_SO@5
	cmp	BYTE PTR [esi+82100], 0
	jne	$LN32@soap_in_SO@5
	mov	ebx, 3
	npad	4
$LL31@soap_in_SO@5:

; 2831 : 	{
; 2832 : 		for (;;)
; 2833 : 		{	soap->error = SOAP_TAG_MISMATCH;
; 2834 : 			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))

	cmp	DWORD PTR _soap_flag_faultcode$[esp+52], 0
	mov	DWORD PTR [esi+90460], ebx
	je	SHORT $LN27@soap_in_SO@5

; 2835 : 				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))

	push	2
	push	5
	push	OFFSET ??_C@_09FJACJGDN@faultcode?$AA@
	mov	eax, edi
	mov	ecx, esi
	call	_soap_instring
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN27@soap_in_SO@5

; 2836 : 				{	soap_flag_faultcode--;

	dec	DWORD PTR _soap_flag_faultcode$[esp+52]

; 2837 : 					continue;

	jmp	SHORT $LL31@soap_in_SO@5
$LN27@soap_in_SO@5:

; 2838 : 				}
; 2839 : 			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))

	cmp	DWORD PTR _soap_flag_faultstring$[esp+52], 0
	je	SHORT $LN24@soap_in_SO@5
	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, ebx
	je	SHORT $LN25@soap_in_SO@5
	cmp	eax, 6
	jne	SHORT $LN24@soap_in_SO@5
$LN25@soap_in_SO@5:

; 2840 : 				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))

	push	1
	push	4
	push	OFFSET ??_C@_0M@LAMIIPIL@faultstring?$AA@
	mov	eax, ebp
	mov	ecx, esi
	call	_soap_instring
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN24@soap_in_SO@5

; 2841 : 				{	soap_flag_faultstring--;

	dec	DWORD PTR _soap_flag_faultstring$[esp+52]

; 2842 : 					continue;

	jmp	SHORT $LL31@soap_in_SO@5
$LN24@soap_in_SO@5:

; 2843 : 				}
; 2844 : 			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))

	cmp	DWORD PTR _soap_flag_faultactor$[esp+52], 0
	je	SHORT $LN21@soap_in_SO@5
	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, ebx
	je	SHORT $LN22@soap_in_SO@5
	cmp	eax, 6
	jne	SHORT $LN21@soap_in_SO@5
$LN22@soap_in_SO@5:

; 2845 : 				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))

	push	1
	push	4
	push	OFFSET ??_C@_0L@JAIOMLLA@faultactor?$AA@
	lea	eax, DWORD PTR [edi+8]
	mov	ecx, esi
	call	_soap_instring
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN21@soap_in_SO@5

; 2846 : 				{	soap_flag_faultactor--;

	dec	DWORD PTR _soap_flag_faultactor$[esp+52]

; 2847 : 					continue;

	jmp	$LL31@soap_in_SO@5
$LN21@soap_in_SO@5:

; 2848 : 				}
; 2849 : 			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR _soap_flag_detail$[esp+52], 0
	je	SHORT $LN19@soap_in_SO@5
	cmp	DWORD PTR [esi+90460], ebx
	jne	SHORT $LN19@soap_in_SO@5

; 2850 : 				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_06EENFNEPD@detail?$AA@
	lea	eax, DWORD PTR [edi+12]
	mov	ecx, esi
	call	?soap_in_PointerToSOAP_ENV__Detail@@YAPAPAUSOAP_ENV__Detail@@PAUsoap@@PBDPAPAU1@1@Z ; soap_in_PointerToSOAP_ENV__Detail
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@soap_in_SO@5

; 2851 : 				{	soap_flag_detail--;

	dec	DWORD PTR _soap_flag_detail$[esp+52]

; 2852 : 					continue;

	jmp	$LL31@soap_in_SO@5
$LN19@soap_in_SO@5:

; 2853 : 				}
; 2854 : 			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR _soap_flag_SOAP_ENV__Code$[esp+52], 0
	je	SHORT $LN17@soap_in_SO@5
	cmp	DWORD PTR [esi+90460], ebx
	jne	SHORT $LN17@soap_in_SO@5

; 2855 : 				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	eax, DWORD PTR [edi+16]
	push	eax
	push	OFFSET ??_C@_0O@OALMNFDI@SOAP?9ENV?3Code?$AA@
	push	esi
	call	?soap_in_PointerToSOAP_ENV__Code@@YAPAPAUSOAP_ENV__Code@@PAUsoap@@PBDPAPAU1@1@Z ; soap_in_PointerToSOAP_ENV__Code
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN17@soap_in_SO@5

; 2856 : 				{	soap_flag_SOAP_ENV__Code--;

	dec	DWORD PTR _soap_flag_SOAP_ENV__Code$[esp+52]

; 2857 : 					continue;

	jmp	$LL31@soap_in_SO@5
$LN17@soap_in_SO@5:

; 2858 : 				}
; 2859 : 			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR _soap_flag_SOAP_ENV__Reason$[esp+52], 0
	je	SHORT $LN15@soap_in_SO@5
	cmp	DWORD PTR [esi+90460], ebx
	jne	SHORT $LN15@soap_in_SO@5

; 2860 : 				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BA@IEHDIDAH@SOAP?9ENV?3Reason?$AA@
	lea	eax, DWORD PTR [edi+20]
	mov	ecx, esi
	call	?soap_in_PointerToSOAP_ENV__Reason@@YAPAPAUSOAP_ENV__Reason@@PAUsoap@@PBDPAPAU1@1@Z ; soap_in_PointerToSOAP_ENV__Reason
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@soap_in_SO@5

; 2861 : 				{	soap_flag_SOAP_ENV__Reason--;

	dec	DWORD PTR _soap_flag_SOAP_ENV__Reason$[esp+52]

; 2862 : 					continue;

	jmp	$LL31@soap_in_SO@5
$LN15@soap_in_SO@5:

; 2863 : 				}
; 2864 : 			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))

	cmp	DWORD PTR _soap_flag_SOAP_ENV__Node$[esp+52], 0
	je	SHORT $LN12@soap_in_SO@5
	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, ebx
	je	SHORT $LN13@soap_in_SO@5
	cmp	eax, 6
	jne	SHORT $LN12@soap_in_SO@5
$LN13@soap_in_SO@5:

; 2865 : 				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))

	push	1
	push	4
	push	OFFSET ??_C@_0O@BICMBBIJ@SOAP?9ENV?3Node?$AA@
	lea	eax, DWORD PTR [edi+24]
	mov	ecx, esi
	call	_soap_instring
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@soap_in_SO@5

; 2866 : 				{	soap_flag_SOAP_ENV__Node--;

	dec	DWORD PTR _soap_flag_SOAP_ENV__Node$[esp+52]

; 2867 : 					continue;

	jmp	$LL31@soap_in_SO@5
$LN12@soap_in_SO@5:

; 2868 : 				}
; 2869 : 			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))

	cmp	DWORD PTR _soap_flag_SOAP_ENV__Role$[esp+52], 0
	je	SHORT $LN9@soap_in_SO@5
	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, ebx
	je	SHORT $LN10@soap_in_SO@5
	cmp	eax, 6
	jne	SHORT $LN9@soap_in_SO@5
$LN10@soap_in_SO@5:

; 2870 : 				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))

	push	1
	push	4
	push	OFFSET ??_C@_0O@LDCPDKLC@SOAP?9ENV?3Role?$AA@
	lea	eax, DWORD PTR [edi+28]
	mov	ecx, esi
	call	_soap_instring
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@soap_in_SO@5

; 2871 : 				{	soap_flag_SOAP_ENV__Role--;

	dec	DWORD PTR _soap_flag_SOAP_ENV__Role$[esp+52]

; 2872 : 					continue;

	jmp	$LL31@soap_in_SO@5
$LN9@soap_in_SO@5:

; 2873 : 				}
; 2874 : 			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR _soap_flag_SOAP_ENV__Detail$[esp+52], 0
	je	SHORT $LN7@soap_in_SO@5
	cmp	DWORD PTR [esi+90460], ebx
	jne	SHORT $LN6@soap_in_SO@5

; 2875 : 				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BA@OENGLDCF@SOAP?9ENV?3Detail?$AA@
	lea	eax, DWORD PTR [edi+32]
	mov	ecx, esi
	call	?soap_in_PointerToSOAP_ENV__Detail@@YAPAPAUSOAP_ENV__Detail@@PAUsoap@@PBDPAPAU1@1@Z ; soap_in_PointerToSOAP_ENV__Detail
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_in_SO@5

; 2876 : 				{	soap_flag_SOAP_ENV__Detail--;

	dec	DWORD PTR _soap_flag_SOAP_ENV__Detail$[esp+52]

; 2877 : 					continue;

	jmp	$LL31@soap_in_SO@5
$LN7@soap_in_SO@5:

; 2878 : 				}
; 2879 : 			if (soap->error == SOAP_TAG_MISMATCH)

	cmp	DWORD PTR [esi+90460], ebx
	jne	SHORT $LN6@soap_in_SO@5

; 2880 : 				soap->error = soap_ignore_element(soap);

	push	esi
	call	?soap_ignore_element@@YAHPAUsoap@@@Z	; soap_ignore_element
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
$LN6@soap_in_SO@5:

; 2881 : 			if (soap->error == SOAP_NO_TAG)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 6
	je	SHORT $LN71@soap_in_SO@5

; 2882 : 				break;
; 2883 : 			if (soap->error)

	test	eax, eax
	je	$LL31@soap_in_SO@5

; 2887 : 			return NULL;

	xor	eax, eax

; 2895 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
$LN71@soap_in_SO@5:

; 2884 : 				return NULL;
; 2885 : 		}
; 2886 : 		if (soap_element_end_in(soap, tag))

	push	OFFSET ??_C@_0P@GLDIJMBO@SOAP?9ENV?3Fault?$AA@
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_in_SO@5
$LN83@soap_in_SO@5:

; 2887 : 			return NULL;

	xor	eax, eax

; 2895 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
$LN32@soap_in_SO@5:

; 2888 : 	}
; 2889 : 	else
; 2890 : 	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);

	push	0
	push	36					; 00000024H
	push	0
	push	47					; 0000002fH
	push	0
	push	edi
	lea	eax, DWORD PTR [esi+82100]
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH

; 2891 : 		if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	mov	edi, eax

; 2892 : 			return NULL;

	jne	SHORT $LN71@soap_in_SO@5
$LN1@soap_in_SO@5:

; 2893 : 	}
; 2894 : 	return a;

	mov	eax, edi

; 2895 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
?soap_in_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@PBDPAU1@1@Z ENDP ; soap_in_SOAP_ENV__Fault
_TEXT	ENDS
PUBLIC	?soap_get_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@PAU1@PBD2@Z ; soap_get_SOAP_ENV__Fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?soap_get_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@PAU1@PBD2@Z PROC ; soap_get_SOAP_ENV__Fault
; _soap$ = eax

; 2806 : {

	push	ecx
	push	esi
	push	edi
	mov	esi, eax

; 2807 : 	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))

	call	?soap_in_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Fault
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN1@soap_get_S@14

; 2808 : 		if (soap_getindependent(soap))

	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN1@soap_get_S@14

; 2809 : 			return NULL;

	xor	eax, eax

; 2811 : }

	pop	edi
	pop	esi
	pop	ecx
	ret	0
$LN1@soap_get_S@14:

; 2810 : 	return p;

	mov	eax, edi

; 2811 : }

	pop	edi
	pop	esi
	pop	ecx
	ret	0
?soap_get_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@PAU1@PBD2@Z ENDP ; soap_get_SOAP_ENV__Fault
_TEXT	ENDS
PUBLIC	_soap_getfault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_getfault PROC
; _soap$ = eax

; 81   : {

	push	ecx
	push	esi
	push	edi
	mov	esi, eax

; 82   : 	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;

	call	?soap_in_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Fault
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN3@soap_getfa
	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN3@soap_getfa
	xor	eax, eax
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	mov	DWORD PTR [esi+12208], eax
	mov	eax, ecx

; 83   : }

	pop	edi
	pop	esi
	pop	ecx
	ret	0

; 82   : 	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;

$LN3@soap_getfa:
	mov	eax, edi
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	mov	DWORD PTR [esi+12208], eax

; 83   : }

	pop	edi
	pop	esi
	mov	eax, ecx
	pop	ecx
	ret	0
_soap_getfault ENDP
END
