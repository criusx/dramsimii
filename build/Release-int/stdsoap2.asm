; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\CriuS\Documents\Visual Studio 2008\Projects\DRAMsimIIhg\src\reporting\stdsoap2.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4soap@@6B@					; soap::`RTTI Complete Object Locator'
PUBLIC	??_R3soap@@8					; soap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2soap@@8					; soap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@soap@@8				; soap::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUsoap@@@8				; soap `RTTI Type Descriptor'
PUBLIC	??_C@_07JJJGGCEE@x?9token?$AA@			; `string'
PUBLIC	??_C@_0L@EPBKNKII@ietf?9token?$AA@		; `string'
PUBLIC	??_C@_06JEFEFGEJ@base64?$AA@			; `string'
PUBLIC	??_C@_0BB@CAHAECFA@quoted?9printable?$AA@	; `string'
PUBLIC	??_C@_06FNFBAEBE@binary?$AA@			; `string'
PUBLIC	??_C@_04DFPGIIHA@8bit?$AA@			; `string'
PUBLIC	??_C@_04LHKGBPKB@7bit?$AA@			; `string'
PUBLIC	??_C@_0BL@GBBFKFHI@HTTP?5Version?5not?5supported?$AA@ ; `string'
PUBLIC	??_C@_0BB@PHMOGCPC@Gateway?5Time?9out?$AA@	; `string'
PUBLIC	??_C@_0BE@NGHLFKBN@Service?5Unavailable?$AA@	; `string'
PUBLIC	??_C@_0M@BNCNLPGM@Bad?5Gateway?$AA@		; `string'
PUBLIC	??_C@_0BA@JGKGKAME@Not?5Implemented?$AA@	; `string'
PUBLIC	??_C@_0BG@NJGANGCC@Internal?5Server?5Error?$AA@	; `string'
PUBLIC	??_C@_0BD@NDMHPAED@Expectation?5Failed?$AA@	; `string'
PUBLIC	??_C@_0CA@KGJNFKJM@Requested?5range?5not?5satisfiable?$AA@ ; `string'
PUBLIC	??_C@_0BH@HLJJIAEN@Unsupported?5Media?5Type?$AA@ ; `string'
PUBLIC	??_C@_0BG@PMALKKB@Request?9URI?5Too?5Large?$AA@	; `string'
PUBLIC	??_C@_0BJ@MMEIEOIG@Request?5Entity?5Too?5Large?$AA@ ; `string'
PUBLIC	??_C@_0BE@BBDBJOM@Precondition?5Failed?$AA@	; `string'
PUBLIC	??_C@_0BA@JCKHPIPI@Length?5Required?$AA@	; `string'
PUBLIC	??_C@_04OKIIBCCG@Gone?$AA@			; `string'
PUBLIC	??_C@_08OJCIFGDF@Conflict?$AA@			; `string'
PUBLIC	??_C@_0BB@GKNJPEJG@Request?5Time?9out?$AA@	; `string'
PUBLIC	??_C@_0BO@ONPAAOGI@Proxy?5Authentication?5Required?$AA@ ; `string'
PUBLIC	??_C@_0P@HHIDFAOI@Not?5Acceptable?$AA@		; `string'
PUBLIC	??_C@_0BD@CCIPIALO@Method?5Not?5Allowed?$AA@	; `string'
PUBLIC	??_C@_09CFCBFJND@Not?5Found?$AA@		; `string'
PUBLIC	??_C@_09LMDIMFJD@Forbidden?$AA@			; `string'
PUBLIC	??_C@_0BB@LMPIHCBH@Payment?5Required?$AA@	; `string'
PUBLIC	??_C@_0N@OOAPMOJA@Unauthorized?$AA@		; `string'
PUBLIC	??_C@_0M@LNAIDEEG@Bad?5Request?$AA@		; `string'
PUBLIC	??_C@_0BD@PJMNAMDM@Temporary?5Redirect?$AA@	; `string'
PUBLIC	??_C@_09JFBGBFIM@Use?5Proxy?$AA@		; `string'
PUBLIC	??_C@_0N@IFEFAIJB@Not?5Modified?$AA@		; `string'
PUBLIC	??_C@_09FAMPMKIP@See?5Other?$AA@		; `string'
PUBLIC	??_C@_05JDGHEPJG@Found?$AA@			; `string'
PUBLIC	??_C@_0BC@BPBCNFPI@Moved?5Permanently?$AA@	; `string'
PUBLIC	??_C@_0BB@HLFEHKPE@Multiple?5Choices?$AA@	; `string'
PUBLIC	??_C@_0BA@NNLNHGMN@Partial?5Content?$AA@	; `string'
PUBLIC	??_C@_0O@BFFLKCLE@Reset?5Content?$AA@		; `string'
PUBLIC	??_C@_0L@FDPJCNGK@No?5Content?$AA@		; `string'
PUBLIC	??_C@_0BO@NKBPKPBI@Non?9Authoritative?5Information?$AA@ ; `string'
PUBLIC	??_C@_08DOBOODLA@Accepted?$AA@			; `string'
PUBLIC	??_C@_07BBIDHECN@Created?$AA@			; `string'
PUBLIC	??_C@_02GIPFHKNO@OK?$AA@			; `string'
PUBLIC	??_C@_0L@GGLPAOMP@No?5Address?$AA@		; `string'
PUBLIC	??_C@_07NNGPDNPG@No?5Data?$AA@			; `string'
PUBLIC	??_C@_0M@IFLIHMFH@No?5Recovery?$AA@		; `string'
PUBLIC	??_C@_09NOIJLNLL@Try?5Again?$AA@		; `string'
PUBLIC	??_C@_0P@CAFMJNJH@Host?5not?5found?$AA@		; `string'
PUBLIC	??_C@_04BILJKGCK@yuml?$AA@			; `string'
PUBLIC	??_C@_05LIICDAEF@thorn?$AA@			; `string'
PUBLIC	??_C@_06BBMKGLNL@yacute?$AA@			; `string'
PUBLIC	??_C@_04NNEJELCL@uuml?$AA@			; `string'
PUBLIC	??_C@_05JEMLPDGA@ucirc?$AA@			; `string'
PUBLIC	??_C@_06NGGKABKP@uacute?$AA@			; `string'
PUBLIC	??_C@_06IBEMEICG@ugrave?$AA@			; `string'
PUBLIC	??_C@_06LGBAFOGO@oslash?$AA@			; `string'
PUBLIC	??_C@_06FFHJEHBN@divide?$AA@			; `string'
PUBLIC	??_C@_04PHBJMEAI@ouml?$AA@			; `string'
PUBLIC	??_C@_06DNFIPCMD@otilde?$AA@			; `string'
PUBLIC	??_C@_05DGIGNCJN@ocirc?$AA@			; `string'
PUBLIC	??_C@_06BFMEMCCP@oacute?$AA@			; `string'
PUBLIC	??_C@_06ECOCILKG@ograve?$AA@			; `string'
PUBLIC	??_C@_06JLCPPJHH@ntilde?$AA@			; `string'
PUBLIC	??_C@_03CMJPAGPB@eth?$AA@			; `string'
PUBLIC	??_C@_04HIFJDBKI@iuml?$AA@			; `string'
PUBLIC	??_C@_05OANPDBIA@icirc?$AA@			; `string'
PUBLIC	??_C@_06HGBEPHBF@iacute?$AA@			; `string'
PUBLIC	??_C@_06CBDCLOJM@igrave?$AA@			; `string'
PUBLIC	??_C@_04LNKJNMKJ@euml?$AA@			; `string'
PUBLIC	??_C@_05JHBNPBPL@ecirc?$AA@			; `string'
PUBLIC	??_C@_06LBLEJNGB@eacute?$AA@			; `string'
PUBLIC	??_C@_06OGJCNEOI@egrave?$AA@			; `string'
PUBLIC	??_C@_06DNHFEHGA@ccedil?$AA@			; `string'
PUBLIC	??_C@_05MAANDPOK@aelig?$AA@			; `string'
PUBLIC	??_C@_05CAFMJCMP@aring?$AA@			; `string'
PUBLIC	??_C@_04EICJHKGJ@auml?$AA@			; `string'
PUBLIC	??_C@_06GNGHIJJO@atilde?$AA@			; `string'
PUBLIC	??_C@_05MIMLDON@acirc?$AA@			; `string'
PUBLIC	??_C@_06EFPLLJHC@aacute?$AA@			; `string'
PUBLIC	??_C@_06BCNNPAPL@agrave?$AA@			; `string'
PUBLIC	??_C@_05GMKDJMCJ@szlig?$AA@			; `string'
PUBLIC	??_C@_05HDBENHAL@THORN?$AA@			; `string'
PUBLIC	??_C@_06NOHHFCEH@Yacute?$AA@			; `string'
PUBLIC	??_C@_04BMIIGECP@Uuml?$AA@			; `string'
PUBLIC	??_C@_05JDGHPGFG@Ucirc?$AA@			; `string'
PUBLIC	??_C@_06BJNHDIDD@Uacute?$AA@			; `string'
PUBLIC	??_C@_06EOPBHBLK@Ugrave?$AA@			; `string'
PUBLIC	??_C@_06HJKNGHPC@Oslash?$AA@			; `string'
PUBLIC	??_C@_05MJOOAIJH@times?$AA@			; `string'
PUBLIC	??_C@_04DGNIOLAM@Ouml?$AA@			; `string'
PUBLIC	??_C@_06PCOFMLFP@Otilde?$AA@			; `string'
PUBLIC	??_C@_05DBCKNHKL@Ocirc?$AA@			; `string'
PUBLIC	??_C@_06NKHJPLLD@Oacute?$AA@			; `string'
PUBLIC	??_C@_06INFPLCDK@Ograve?$AA@			; `string'
PUBLIC	??_C@_06FEJCMAOL@Ntilde?$AA@			; `string'
PUBLIC	??_C@_03CBGEMLIN@ETH?$AA@			; `string'
PUBLIC	??_C@_04LJJIBOKM@Iuml?$AA@			; `string'
PUBLIC	??_C@_05OHHDDELG@Icirc?$AA@			; `string'
PUBLIC	??_C@_06LJKJMOIJ@Iacute?$AA@			; `string'
PUBLIC	??_C@_06OOIPIHAA@Igrave?$AA@			; `string'
PUBLIC	??_C@_04HMGIPDKN@Euml?$AA@			; `string'
PUBLIC	??_C@_05JALBPEMN@Ecirc?$AA@			; `string'
PUBLIC	??_C@_06HOAJKEPN@Eacute?$AA@			; `string'
PUBLIC	??_C@_06CJCPONHE@Egrave?$AA@			; `string'
PUBLIC	??_C@_06PCMIHOPM@Ccedil?$AA@			; `string'
PUBLIC	??_C@_05GGABFNI@AElig?$AA@			; `string'
PUBLIC	??_C@_05CHPAJHPJ@Aring?$AA@			; `string'
PUBLIC	??_C@_04IJOIFFGN@Auml?$AA@			; `string'
PUBLIC	??_C@_06KCNKLAAC@Atilde?$AA@			; `string'
PUBLIC	??_C@_05LCALGNL@Acirc?$AA@			; `string'
PUBLIC	??_C@_06IKEGIAOO@Aacute?$AA@			; `string'
PUBLIC	??_C@_06NNGAMJGH@Agrave?$AA@			; `string'
PUBLIC	??_C@_06JMONPFKG@iquest?$AA@			; `string'
PUBLIC	??_C@_06NMNJFLLK@frac34?$AA@			; `string'
PUBLIC	??_C@_06IJAHCIFC@frac12?$AA@			; `string'
PUBLIC	??_C@_06NPFNIPNE@frac14?$AA@			; `string'
PUBLIC	??_C@_05MPFJLGEB@raquo?$AA@			; `string'
PUBLIC	??_C@_04HMAEPGHP@ordm?$AA@			; `string'
PUBLIC	??_C@_04EJOCKNLB@sup1?$AA@			; `string'
PUBLIC	??_C@_05KLIFGPMF@cedil?$AA@			; `string'
PUBLIC	??_C@_06HHCHNCAA@middot?$AA@			; `string'
PUBLIC	??_C@_04GIAGJOJD@para?$AA@			; `string'
PUBLIC	??_C@_05PCPGMEFP@micro?$AA@			; `string'
PUBLIC	??_C@_05EEJEIAPO@acute?$AA@			; `string'
PUBLIC	??_C@_04HLNEMPDD@sup3?$AA@			; `string'
PUBLIC	??_C@_04GCMPPOHC@sup2?$AA@			; `string'
PUBLIC	??_C@_06CAEEBBM@plusmn?$AA@			; `string'
PUBLIC	??_C@_03OFPLEBM@deg?$AA@			; `string'
PUBLIC	??_C@_04IMHNEFHF@macr?$AA@			; `string'
PUBLIC	??_C@_03HLCNLMFP@reg?$AA@			; `string'
PUBLIC	??_C@_03BPAIHHLG@shy?$AA@			; `string'
PUBLIC	??_C@_03NJKJADM@not?$AA@			; `string'
PUBLIC	??_C@_05PGIFNFKK@laquo?$AA@			; `string'
PUBLIC	??_C@_04JPPACPLE@ordf?$AA@			; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
PUBLIC	??_C@_03LBNAMJF@uml?$AA@			; `string'
PUBLIC	??_C@_04IKJFFMEH@sect?$AA@			; `string'
PUBLIC	??_C@_06ILPBEBAD@brvbar?$AA@			; `string'
PUBLIC	??_C@_03HNOOIABH@yen?$AA@			; `string'
PUBLIC	??_C@_06HEGEHONB@curren?$AA@			; `string'
PUBLIC	??_C@_05EBEEKLCG@pound?$AA@			; `string'
PUBLIC	??_C@_04OCKNFIJG@cent?$AA@			; `string'
PUBLIC	??_C@_05BNEGCBFC@iexcl?$AA@			; `string'
PUBLIC	??_C@_04PHHIFBLJ@nbsp?$AA@			; `string'
PUBLIC	?strstr@@YAPADPADPBD@Z				; strstr
PUBLIC	?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z ; std::basic_ostream<char,std::char_traits<char> >::write
PUBLIC	?_Sgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPADIH@Z ; std::basic_streambuf<char,std::char_traits<char> >::_Sgetn_s
PUBLIC	?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z ; std::basic_istream<char,std::char_traits<char> >::_Read_s
PUBLIC	?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z ; std::basic_istream<char,std::char_traits<char> >::read
PUBLIC	?gcount@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEHXZ ; std::basic_istream<char,std::char_traits<char> >::gcount
PUBLIC	?strrchr@@YAPADPADH@Z				; strrchr
PUBLIC	?strchr@@YAPADPADH@Z				; strchr
PUBLIC	??_Gsoap@@UAEPAXI@Z				; soap::`scalar deleting destructor'
PUBLIC	_soap_double_nan
PUBLIC	??_C@_07FCIFDIFE@?$AN?6?$CFlX?$AN?6?$AA@	; `string'
PUBLIC	??_C@_02KCAKIFL@lt?$AA@				; `string'
PUBLIC	??_C@_02GHFEHLK@gt?$AA@				; `string'
PUBLIC	??_C@_03DCBBJBAA@amp?$AA@			; `string'
PUBLIC	??_C@_04KJFGKBNM@quot?$AA@			; `string'
PUBLIC	??_C@_04LBCJFAKL@apos?$AA@			; `string'
PUBLIC	??_C@_04ONHKJKNE@xml?5?$AA@			; `string'
PUBLIC	??_C@_0L@GJNPICMJ@?5encoding?$DN?$AA@		; `string'
PUBLIC	??_C@_0M@CIPLLKIK@iso?98859?91?$CK?$AA@		; `string'
PUBLIC	??_C@_07KFPCELGH@latin1?$CK?$AA@		; `string'
PUBLIC	??_C@_06ENEJBNNE@utf?98?$CK?$AA@		; `string'
PUBLIC	??_C@_0M@BMFKMGMG@xop?3Include?$AA@		; `string'
PUBLIC	??_C@_05IEDFPCMN@?$CFs?$FL?$CFd?$AA@		; `string'
PUBLIC	??_C@_03EBJOKFHF@?5?$CFd?$AA@			; `string'
PUBLIC	??_C@_03LEIBKMN@?0?$CFd?$AA@			; `string'
PUBLIC	??_C@_03PNKAICOI@?$FL?$CFd?$AA@			; `string'
PUBLIC	??_C@_03PJHHNEEI@xml?$AA@			; `string'
PUBLIC	??_C@_0M@NANEACJL@xsd?3ur?9type?$AA@		; `string'
PUBLIC	??_C@_0BC@NFJDOJIM@WSAStartup?5failed?$AA@	; `string'
PUBLIC	??_C@_0BE@GDJAADON@TCP?1UDP?5IP?5error?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CB@DBACHNOG@TCP?5init?5failed?5in?5tcp_connect?$CI?$CJ@ ; `string'
PUBLIC	??_C@_0BP@IBLNNK@socket?5failed?5in?5tcp_connect?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CN@JFNFHAEF@setsockopt?5SO_LINGER?5failed?5in?5t@ ; `string'
PUBLIC	??_C@_0CD@GCKLAJL@setsockopt?5failed?5in?5tcp_connect@ ; `string'
PUBLIC	??_C@_0DA@GNDCAGOP@setsockopt?5SO_KEEPALIVE?5failed?5i@ ; `string'
PUBLIC	??_C@_0CN@CAACJAKC@setsockopt?5SO_SNDBUF?5failed?5in?5t@ ; `string'
PUBLIC	??_C@_0CN@JLLHDGBH@setsockopt?5SO_RCVBUF?5failed?5in?5t@ ; `string'
PUBLIC	??_C@_0CP@ECDFPEN@setsockopt?5TCP_NODELAY?5failed?5in@ ; `string'
PUBLIC	??_C@_0CP@BEACMDAL@get?5proxy?5host?5by?5name?5failed?5in@ ; `string'
PUBLIC	??_C@_0CJ@HHNLALCP@get?5host?5by?5name?5failed?5in?5tcp_c@ ; `string'
PUBLIC	??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_07MKALMBDJ@Timeout?$AA@			; `string'
PUBLIC	??_C@_07NHIIGDKE@https?3?$CK?$AA@		; `string'
PUBLIC	??_C@_0BP@EOFJAGHM@TCP?5init?5failed?5in?5soap_bind?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BN@LIAJIIPM@socket?5failed?5in?5soap_bind?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CB@LHEHKJOM@setsockopt?5failed?5in?5soap_bind?$CI?$CJ@ ; `string'
PUBLIC	??_C@_0CO@IMNBHKGL@setsockopt?5SO_KEEPALIVE?5failed?5i@ ; `string'
PUBLIC	??_C@_0CL@HDDANLDN@setsockopt?5SO_SNDBUF?5failed?5in?5s@ ; `string'
PUBLIC	??_C@_0CL@JJJGHOEP@setsockopt?5SO_RCVBUF?5failed?5in?5s@ ; `string'
PUBLIC	??_C@_0CN@KADDKKPF@setsockopt?5TCP_NODELAY?5failed?5in@ ; `string'
PUBLIC	??_C@_0CH@FGHBILAG@get?5host?5by?5name?5failed?5in?5soap_@ ; `string'
PUBLIC	??_C@_0BL@GFJLCODA@bind?5failed?5in?5soap_bind?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BN@GKFGOOJD@listen?5failed?5in?5soap_bind?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BN@DONKIDPM@select?5failed?5in?5soap_poll?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BP@HJFOKHGA@accept?5failed?5in?5soap_accept?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CN@IPOEJJJL@setsockopt?5SO_LINGER?5failed?5in?5s@ ; `string'
PUBLIC	??_C@_0CD@BMBLFJEF@setsockopt?5failed?5in?5soap_accept@ ; `string'
PUBLIC	??_C@_0DA@HHADOPDB@setsockopt?5SO_KEEPALIVE?5failed?5i@ ; `string'
PUBLIC	??_C@_0CN@DKDDHJHM@setsockopt?5SO_SNDBUF?5failed?5in?5s@ ; `string'
PUBLIC	??_C@_0CN@IBIGNPMJ@setsockopt?5SO_RCVBUF?5failed?5in?5s@ ; `string'
PUBLIC	??_C@_0CP@BOBCLGJD@setsockopt?5TCP_NODELAY?5failed?5in@ ; `string'
PUBLIC	??_C@_0CC@JGPGJFPH@no?5master?5socket?5in?5soap_accept?$CI@ ; `string'
PUBLIC	??_C@_04CMBCJJJD@href?$AA@			; `string'
PUBLIC	??_C@_04MLBGAAHD@cid?3?$AA@			; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO?$AA@			; `string'
PUBLIC	??_C@_07MEMIDCKI@?$AN?60?$AN?6?$AN?6?$AA@	; `string'
PUBLIC	??_C@_02BOGAIONP@ab?$AA@			; `string'
PUBLIC	??_C@_01MCMALHOG@a?$AA@				; `string'
PUBLIC	??_C@_04OEJDHHEG@?$CF?49G?$AA@			; `string'
PUBLIC	??_C@_06MNPIOIFE@?$CF?417lG?$AA@		; `string'
PUBLIC	??_C@_08HGNFPOFN@cid?3id?$CFd?$AA@		; `string'
PUBLIC	??_C@_03GCKCNDHP@1?41?$AA@			; `string'
PUBLIC	??_C@_0CI@FMJEECLD@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCUT@ ; `string'
PUBLIC	??_C@_01MNNFJEPP@?$DM?$AA@			; `string'
PUBLIC	??_C@_08HMPLFLKJ@xmlns?3?$CFs?$AA@		; `string'
PUBLIC	??_C@_03HCMCBFLP@_?$CFd?$AA@			; `string'
PUBLIC	??_C@_08JNIDGPLJ@xsi?3type?$AA@			; `string'
PUBLIC	??_C@_0BC@LJIIOGEO@SOAP?9ENC?3position?$AA@	; `string'
PUBLIC	??_C@_0O@HCOOBFLG@SOAP?9ENV?3role?$AA@		; `string'
PUBLIC	??_C@_0P@OHPBIEEK@SOAP?9ENV?3actor?$AA@		; `string'
PUBLIC	??_C@_0BI@ENKFHJBH@SOAP?9ENV?3mustUnderstand?$AA@ ; `string'
PUBLIC	??_C@_0BH@DOAGFCPF@SOAP?9ENV?3encodingStyle?$AA@ ; `string'
PUBLIC	??_C@_0P@EFIHKLBM@SOAP?9ENC?3Array?$AA@		; `string'
PUBLIC	??_C@_0BC@GCPDJBOG@SOAP?9ENC?3itemType?$AA@	; `string'
PUBLIC	??_C@_0BD@IKLKJNBD@SOAP?9ENC?3arraySize?$AA@	; `string'
PUBLIC	??_C@_0BA@CCJOJBBI@SOAP?9ENC?3offset?$AA@	; `string'
PUBLIC	??_C@_0BD@GFBEJDEK@SOAP?9ENC?3arrayType?$AA@	; `string'
PUBLIC	??_C@_02ILLPBGAO@?$DN?$CC?$AA@			; `string'
PUBLIC	??_C@_02HCGKDMEN@?1?$DO?$AA@			; `string'
PUBLIC	??_C@_02DPNDACHE@?$DM?1?$AA@			; `string'
PUBLIC	??_C@_0N@HAMJFIGF@SOAP?9ENC?3ref?$AA@		; `string'
PUBLIC	??_C@_04BDMFGIGK@?$CD_?$CFd?$AA@		; `string'
PUBLIC	??_C@_07KJDFMKIE@xsi?3nil?$AA@			; `string'
PUBLIC	??_C@_0BA@JOBDACAK@SOAP?9RPC?3result?$AA@	; `string'
PUBLIC	??_C@_0P@CNMICKND@xmlns?3SOAP?9RPC?$AA@		; `string'
PUBLIC	??_C@_07EFBDHEMP@?3result?$AA@			; `string'
PUBLIC	??_C@_06PNFLLAEF@xmlns?3?$AA@			; `string'
PUBLIC	??_C@_05PPEFOGKI@xmlns?$AA@			; `string'
PUBLIC	??_C@_06BGJENONN@wsu?3Id?$AA@			; `string'
PUBLIC	??_C@_08DJPLLOHP@xsi?3null?$AA@			; `string'
PUBLIC	??_C@_0O@BGJHDLJG@SOAP?9ENC?3root?$AA@		; `string'
PUBLIC	??_C@_0CL@EFBJIKLI@http?3?1?1schemas?4xmlsoap?4org?1soap?1@ ; `string'
PUBLIC	??_C@_03GCDGINBO@ref?$AA@			; `string'
PUBLIC	??_C@_0DC@KBJFLDJI@http?3?1?1www?4w3?4org?12003?105?1soap?9e@ ; `string'
PUBLIC	??_C@_05KACKFEPH@?$CG?$CDx9?$DL?$AA@		; `string'
PUBLIC	??_C@_05PKMIGNBP@?$CG?$CDxA?$DL?$AA@		; `string'
PUBLIC	??_C@_05PMADKPPE@?$CG?$CDxD?$DL?$AA@		; `string'
PUBLIC	??_C@_05JKJFEODM@?$CGamp?$DL?$AA@		; `string'
PUBLIC	??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@		; `string'
PUBLIC	??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@		; `string'
PUBLIC	??_C@_06DDLNFFBN@?$CGquot?$DL?$AA@		; `string'
PUBLIC	??_C@_03MAABEHOM@lt?$DL?$AA@			; `string'
PUBLIC	??_C@_03BHAAMAON@gt?$DL?$AA@			; `string'
PUBLIC	??_C@_04DMIAPOKJ@amp?$DL?$AA@			; `string'
PUBLIC	??_C@_05LDHOCHGG@quot?$DL?$AA@			; `string'
PUBLIC	??_C@_05HNAHLMAI@apos?$DL?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_04JNHIEKJE@?3int?$AA@			; `string'
PUBLIC	??_C@_06DFBHHOOH@?3short?$AA@			; `string'
PUBLIC	??_C@_05FFGLOOMC@?3byte?$AA@			; `string'
PUBLIC	??_C@_03JALODAI@?$CFld?$AA@			; `string'
PUBLIC	??_C@_05LLAMLEHD@?$CFI64d?$AA@			; `string'
PUBLIC	??_C@_08ICEBEHNK@?3integer?$AA@			; `string'
PUBLIC	??_C@_0BB@NDNOKOEA@?3positiveInteger?$AA@	; `string'
PUBLIC	??_C@_0BB@FHGJHLHJ@?3negativeInteger?$AA@	; `string'
PUBLIC	??_C@_0BE@HIKONPMJ@?3nonPositiveInteger?$AA@	; `string'
PUBLIC	??_C@_0BE@PMBJAKPA@?3nonNegativeInteger?$AA@	; `string'
PUBLIC	??_C@_05LMKOBMME@?3long?$AA@			; `string'
PUBLIC	??_C@_03ICJPMMHB@NaN?$AA@			; `string'
PUBLIC	??_C@_03OEIAHPBN@INF?$AA@			; `string'
PUBLIC	??_C@_04DKLHLMKJ@?9INF?$AA@			; `string'
PUBLIC	??_C@_04LFPHEJAJ@?$CLINF?$AA@			; `string'
PUBLIC	??_C@_02BEIEFPIG@?$CFg?$AA@			; `string'
PUBLIC	??_C@_06INOMFGCG@?3float?$AA@			; `string'
PUBLIC	??_C@_07PBNBEHML@?3double?$AA@			; `string'
PUBLIC	??_C@_08HMJFKOLE@?3decimal?$AA@			; `string'
PUBLIC	??_C@_0O@FKBEEKGD@?3unsignedLong?$AA@		; `string'
PUBLIC	??_C@_0N@EEHCOMNL@?3unsignedInt?$AA@		; `string'
PUBLIC	??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@		; `string'
PUBLIC	??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@		; `string'
PUBLIC	??_C@_03CCCGLAML@?$CFlg?$AA@			; `string'
PUBLIC	??_C@_03FKNCMABI@?$CFlu?$AA@			; `string'
PUBLIC	??_C@_05OINFJHGD@?$CFI64u?$AA@			; `string'
PUBLIC	??_C@_04FNFHGAAP@xml?3?$AA@			; `string'
PUBLIC	??_C@_02JMMFPCED@?$CC?$CC?$AA@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_09MCFEFMEO@xmlns?3_?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BC@EJFCONBF@?$CFY?9?$CFm?9?$CFdT?$CFH?3?$CFM?3?$CFS?$AA@ ; `string'
PUBLIC	??_C@_0L@PEBBIKFI@?$CF?$CL03d?3?$CF02d?$AA@	; `string'
PUBLIC	??_C@_0BF@KNOONEPL@1969?912?931T23?359?359Z?$AA@ ; `string'
PUBLIC	??_C@_0BG@CNJMEEAL@?$CFd?9?$CFd?9?$CFdT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@ ; `string'
PUBLIC	??_C@_0BH@OJGJFHHH@?$CF4d?$CF2d?$CF2dT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@ ; `string'
PUBLIC	??_C@_0BI@KJDFMOL@?$CF4d?$CF2d?$CF2dT?$CF2d?$CF2d?$CF2d?$CF31s?$AA@ ; `string'
PUBLIC	??_C@_05NFGPCJDJ@?$CFd?3?$CFd?$AA@		; `string'
PUBLIC	??_C@_09ONEMIJDH@?3dateTime?$AA@		; `string'
PUBLIC	??_C@_0L@BJKBKLJG@Content?9ID?$AA@		; `string'
PUBLIC	??_C@_0BB@EPBMDIDM@Content?9Location?$AA@	; `string'
PUBLIC	??_C@_0BE@LMOOGHBG@Content?9Disposition?$AA@	; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_0N@LAFFMKKA@Content?9Type?$AA@		; `string'
PUBLIC	??_C@_0BE@CDHADPEM@Content?9Description?$AA@	; `string'
PUBLIC	??_C@_0BK@MJFMDPAI@Content?9Transfer?9Encoding?$AA@ ; `string'
PUBLIC	??_C@_03KBLJEPNL@?6?9?9?$AA@			; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6?$AA@			; `string'
PUBLIC	??_C@_04LOEPKDGL@?$AN?6?9?9?$AA@		; `string'
PUBLIC	??_C@_0P@GJMOGDPG@Content?9Type?3?5?$AA@	; `string'
PUBLIC	??_C@_0BM@MCMHCKIN@Content?9Transfer?9Encoding?3?5?$AA@ ; `string'
PUBLIC	??_C@_0N@NKGHAKLJ@Content?9ID?3?5?$AA@		; `string'
PUBLIC	??_C@_0BD@OHIJMKJJ@Content?9Location?3?5?$AA@	; `string'
PUBLIC	??_C@_0BG@FGNCEKKA@Content?9Description?3?5?$AA@ ; `string'
PUBLIC	??_C@_02BAABKJLB@?9?9?$AA@			; `string'
PUBLIC	??_C@_02EGOFBIJA@?$DN?$DN?$AA@			; `string'
PUBLIC	??_C@_0BE@MKHJBFJG@?$DMSOAP?9ENV?3Envelope?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BB@KDHCEMMM@application?1dime?$AA@	; `string'
PUBLIC	??_C@_05FKGKDBHO@HTTP?1?$AA@			; `string'
PUBLIC	??_C@_05LPJJJLLB@POST?5?$AA@			; `string'
PUBLIC	??_C@_04IBPFIGHK@GET?5?$AA@			; `string'
PUBLIC	??_C@_04DCMJKHH@PUT?5?$AA@			; `string'
PUBLIC	??_C@_07GOAKFIAN@DELETE?5?$AA@			; `string'
PUBLIC	??_C@_05PMJKDPIC@HEAD?5?$AA@			; `string'
PUBLIC	??_C@_0L@LOBKJNKF@HTTP?5Error?$AA@		; `string'
PUBLIC	??_C@_04CPPPJGME@Host?$AA@			; `string'
PUBLIC	??_C@_07FGAOOBMN@http?3?1?1?$AA@		; `string'
PUBLIC	??_C@_0BC@GGLOKPIO@multipart?1related?$AA@	; `string'
PUBLIC	??_C@_0BE@PILCJFLE@multipart?1form?9data?$AA@	; `string'
PUBLIC	??_C@_08KIKGFOKI@boundary?$AA@			; `string'
PUBLIC	??_C@_05FAGFPHJG@start?$AA@			; `string'
PUBLIC	??_C@_06DDLLCOJG@action?$AA@			; `string'
PUBLIC	??_C@_0P@HOJGPHBA@Content?9Length?$AA@		; `string'
PUBLIC	??_C@_0BB@KFPPKJHF@Content?9Encoding?$AA@	; `string'
PUBLIC	??_C@_07FNHFFEJG@deflate?$AA@			; `string'
PUBLIC	??_C@_04HOHEGKBO@gzip?$AA@			; `string'
PUBLIC	??_C@_0BC@ELHLFCNH@Transfer?9Encoding?$AA@	; `string'
PUBLIC	??_C@_07KCKHAHHI@chunked?$AA@			; `string'
PUBLIC	??_C@_0L@PJJKMLL@Connection?$AA@		; `string'
PUBLIC	??_C@_0L@FFDPOIEG@keep?9alive?$AA@		; `string'
PUBLIC	??_C@_05LBOHBHFK@close?$AA@			; `string'
PUBLIC	??_C@_0O@NAFGPKMI@Authorization?$AA@		; `string'
PUBLIC	??_C@_07LLIFBKCB@Basic?5?$CK?$AA@		; `string'
PUBLIC	??_C@_0BB@KEDJJIFI@WWW?9Authenticate?$AA@	; `string'
PUBLIC	??_C@_05ELABLNGD@realm?$AA@			; `string'
PUBLIC	??_C@_06GHDJNLIG@Expect?$AA@			; `string'
PUBLIC	??_C@_0N@IOPAKPOD@100?9continue?$AA@		; `string'
PUBLIC	??_C@_0BG@NPCCMLBA@HTTP?11?41?5100?5Continue?$AA@ ; `string'
PUBLIC	??_C@_0L@BIMPHKBC@SOAPAction?$AA@		; `string'
PUBLIC	??_C@_08KDOEBHGA@Location?$AA@			; `string'
PUBLIC	??_C@_0BA@HEMDDLEL@X?9Forwarded?9For?$AA@	; `string'
PUBLIC	??_C@_03NBBPFACD@?$DN?0?$DL?$AA@		; `string'
PUBLIC	??_C@_02NFLHGFB@?0?$DL?$AA@			; `string'
PUBLIC	??_C@_0EA@OLHLLNHK@application?1xop?$CLxml?$DL?5charset?$DNutf@ ; `string'
PUBLIC	??_C@_0CE@HOOLIGFB@application?1soap?$CLxml?$DL?5charset?$DNut@ ; `string'
PUBLIC	??_C@_0BI@JFLEALON@text?1xml?$DL?5charset?$DNutf?98?$AA@ ; `string'
PUBLIC	??_C@_0EO@EHIFGEMB@?9?9?$CFs?$AN?6Content?9Type?3?5?$CFs?$AN?6Content?9@ ; `string'
PUBLIC	??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@	; `string'
PUBLIC	??_C@_04PNIFHPHN@html?$AA@			; `string'
PUBLIC	??_C@_04MJIIEFNN@Body?$AA@			; `string'
PUBLIC	??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@		; `string'
PUBLIC	??_C@_09LLHAEKON@soap?4udp?3?$AA@		; `string'
PUBLIC	??_C@_0BJ@CDMHJEKP@text?1html?$DL?5charset?$DNutf?98?$AA@ ; `string'
PUBLIC	??_C@_0CD@GGDEJPLO@application?1xop?$CLxml?$DL?5charset?$DNutf@ ; `string'
PUBLIC	??_C@_0CJ@HGDIJJKJ@multipart?1related?$DL?5boundary?$DN?$CC?$CFs?$CC@ ; `string'
PUBLIC	??_C@_0L@ENHEIJFK@?$CC?$DL?5start?$DN?$CC?$AA@	; `string'
PUBLIC	??_C@_0P@KJFFOCGK@?$DL?5start?9info?$DN?$CC?$AA@ ; `string'
PUBLIC	??_C@_03HAPOJHBM@GET?$AA@			; `string'
PUBLIC	??_C@_04HCJEIHPL@POST?$AA@			; `string'
PUBLIC	??_C@_06GLIDCHCJ@http?3?$CK?$AA@		; `string'
PUBLIC	??_C@_06EFCFIIJL@httpg?3?$AA@			; `string'
PUBLIC	??_C@_0O@FAODEEBC@?$CFs?5?$CFs?5HTTP?1?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0P@PENEPKMC@?$CFs?5?1?$CFs?5HTTP?1?$CFs?$AA@ ; `string'
PUBLIC	??_C@_05HKPGCKL@?$CFs?3?$CFd?$AA@		; `string'
PUBLIC	??_C@_09MBLJBAGJ@gSOAP?12?47?$AA@		; `string'
PUBLIC	??_C@_0L@DMPACEMJ@User?9Agent?$AA@		; `string'
PUBLIC	??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@		; `string'
PUBLIC	??_C@_06FFOGOLGD@Basic?5?$AA@			; `string'
PUBLIC	??_C@_0BE@DCLKKIPG@Proxy?9Authorization?$AA@	; `string'
PUBLIC	??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@		; `string'
PUBLIC	??_C@_06DAENNINM@200?5OK?$AA@			; `string'
PUBLIC	??_C@_0N@GGGJJCHF@202?5ACCEPTED?$AA@		; `string'
PUBLIC	??_C@_0L@HINEDFNI@HTTP?1?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_06PGDKHFME@Status?$AA@			; `string'
PUBLIC	??_C@_0O@OIHDPKBJ@HTTP?1?$CFs?5?$CFd?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BC@NIIEEHHB@gSOAP?5Web?5Service?$AA@	; `string'
PUBLIC	??_C@_0BB@GEFAMELB@Basic?5realm?$DN?$CC?$CFs?$CC?$AA@ ; `string'
PUBLIC	??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@	; `string'
PUBLIC	??_C@_0BA@NLEABOII@400?5Bad?5Request?$AA@	; `string'
PUBLIC	??_C@_0BK@FNMKOGBN@500?5Internal?5Server?5Error?$AA@ ; `string'
PUBLIC	??_C@_06LGMEBDBC@Server?$AA@			; `string'
PUBLIC	??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@ ; `string'
PUBLIC	??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@ ; `string'
PUBLIC	??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@	; `string'
PUBLIC	??_C@_0N@JOEFJCHK@Client?5fault?$AA@		; `string'
PUBLIC	??_C@_0N@LCJPOAAP@Server?5fault?$AA@		; `string'
PUBLIC	??_C@_0BP@EDHHHBAK@tag?5name?5or?5namespace?5mismatch?$AA@ ; `string'
PUBLIC	??_C@_0BE@GBNPKFOD@data?5type?5mismatch?5?$AA@	; `string'
PUBLIC	??_C@_0BK@BDHDOCNN@Well?9formedness?5violation?$AA@ ; `string'
PUBLIC	??_C@_0BD@HDMBMFLH@No?5XML?5element?5tag?$AA@	; `string'
PUBLIC	??_C@_0BI@MFGAEHIJ@SOAP?9ENV?3MustUnderstand?$AA@ ; `string'
PUBLIC	??_C@_0EC@DIEDGBJC@The?5data?5in?5element?5?8?$CFs?8?5must?5be@ ; `string'
PUBLIC	??_C@_0BJ@OACCBMEJ@SOAP?9ENV?3VersionMismatch?$AA@ ; `string'
PUBLIC	??_C@_0CO@JCAMFCDG@Invalid?5SOAP?5message?5or?5SOAP?5ver@ ; `string'
PUBLIC	??_C@_0BN@OABEEJDM@SOAP?9ENV?3DataEncodingUnknown?$AA@ ; `string'
PUBLIC	??_C@_0BP@NKHANBGK@Unsupported?5SOAP?5data?5encoding?$AA@ ; `string'
PUBLIC	??_C@_0BA@DMKNFBBB@namespace?5error?$AA@	; `string'
PUBLIC	??_C@_0L@PDEMLIEM@User?5error?$AA@		; `string'
PUBLIC	??_C@_0M@HCPCIMCN@Fatal?5error?$AA@		; `string'
PUBLIC	??_C@_0EF@HBJFOFK@Method?5?8?$CFs?8?5not?5implemented?3?5met@ ; `string'
PUBLIC	??_C@_0BM@MENEPEMK@Data?5required?5for?5operation?$AA@ ; `string'
PUBLIC	??_C@_0CA@BHFEEBKL@HTTP?5GET?5method?5not?5implemented?$AA@ ; `string'
PUBLIC	??_C@_0CA@DBKHPHAA@HTTP?5PUT?5method?5not?5implemented?$AA@ ; `string'
PUBLIC	??_C@_0CB@GICAEFAM@HTTP?5HEAD?5method?5not?5implemented@ ; `string'
PUBLIC	??_C@_0BM@KGAMDCLK@HTTP?5method?5not?5implemented?$AA@ ; `string'
PUBLIC	??_C@_0O@NALGGDJF@Out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_0CL@HFBNDNPH@Memory?5overflow?5or?5memory?5corrup@ ; `string'
PUBLIC	??_C@_0BF@GFHEHPAM@Header?5line?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BK@IJNJOFHI@Array?5index?5out?5of?5bounds?$AA@ ; `string'
PUBLIC	??_C@_0BA@NJOHCEBG@nil?5not?5allowed?$AA@	; `string'
PUBLIC	??_C@_0BM@BCCCPBMJ@multiple?5definitions?5of?5id?5?$AA@ ; `string'
PUBLIC	??_C@_0BF@NPKHDOOL@SOAP?9ENC?3DuplicateID?$AA@	; `string'
PUBLIC	??_C@_0BE@MPBPOAHN@missing?5id?5for?5ref?5?$AA@	; `string'
PUBLIC	??_C@_0BD@NNKPGICN@SOAP?9ENC?3MissingID?$AA@	; `string'
PUBLIC	??_C@_0CG@KLBPBEIF@incompatible?5object?5type?5ref?1id?5@ ; `string'
PUBLIC	??_C@_0CB@LLFCFDEP@Message?5too?5large?5for?5UDP?5packet@ ; `string'
PUBLIC	??_C@_0CC@KGMKOPGF@An?5HTTP?5processing?5error?5occurre@ ; `string'
PUBLIC	??_C@_0DF@GLMBMACG@OpenSSL?5not?5installed?3?5recompile@ ; `string'
PUBLIC	??_C@_0BG@IBFEEHMP@Plugin?5registry?5error?$AA@	; `string'
PUBLIC	??_C@_0BC@JILKAMFB@DIME?5format?5error?$AA@	; `string'
PUBLIC	??_C@_0CA@OHINPGEO@DIME?5href?5to?5missing?5attachment?$AA@ ; `string'
PUBLIC	??_C@_0CA@FOKLPDEJ@DIME?5version?1transmission?5error?$AA@ ; `string'
PUBLIC	??_C@_0BC@DMDFBBON@End?5of?5DIME?5error?$AA@	; `string'
PUBLIC	??_C@_0BC@GALJBELM@MIME?5format?5error?$AA@	; `string'
PUBLIC	??_C@_0CA@PFEDMHLA@MIME?5href?5to?5missing?5attachment?$AA@ ; `string'
PUBLIC	??_C@_0BC@EHHICPGI@End?5of?5MIME?5error?$AA@	; `string'
PUBLIC	??_C@_0EI@DMDOKJJA@Zlib?1gzip?5not?5installed?5for?5?$CIde?$CJ@ ; `string'
PUBLIC	??_C@_0BL@IAKLNEOE@missing?5required?5attribute?$AA@ ; `string'
PUBLIC	??_C@_0BN@FOFAKJF@prohibited?5attribute?5present?$AA@ ; `string'
PUBLIC	??_C@_0BF@NAKMPMCF@occurrence?5violation?$AA@	; `string'
PUBLIC	??_C@_0BJ@BEFALLEK@content?5length?5violation?$AA@ ; `string'
PUBLIC	??_C@_0CP@LKNNNLAG@Maximum?5number?5of?5open?5connectio@ ; `string'
PUBLIC	??_C@_0BK@GDNDADLI@Stopped?3?5no?5response?5sent?$AA@ ; `string'
PUBLIC	??_C@_0BK@LNBGPKAI@End?5of?5file?5or?5no?5input?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BC@BJFDHNPP@HTTP?5Error?3?5?$CFd?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_08PNOEHBEA@Error?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BA@NJHKENFI@SOAP?9ENV?3Server?$AA@	; `string'
PUBLIC	??_C@_0BC@DABIKIOO@SOAP?9ENV?3Receiver?$AA@	; `string'
PUBLIC	??_C@_0EH@OEKCJEEM@Operation?5interrupted?5or?5timed?5o@ ; `string'
PUBLIC	??_C@_0DL@HBKFNCEG@Operation?5interrupted?5or?5timed?5o@ ; `string'
PUBLIC	??_C@_0CD@EBMJBALC@Operation?5interrupted?5or?5timed?5o@ ; `string'
PUBLIC	??_C@_0CK@KAKMECOH@Error?3?5soap?5struct?5state?5not?5ini@ ; `string'
PUBLIC	??_C@_0M@NIEENCAP@?$FLno?5detail?$FN?$AA@	; `string'
PUBLIC	??_C@_0M@NEEDGNL@?$FLno?5reason?$FN?$AA@	; `string'
PUBLIC	??_C@_0L@HPHPPAL@no?5subcode?$AA@		; `string'
PUBLIC	??_C@_07IBLMOOJE@SOAP?51?4?$AA@			; `string'
PUBLIC	??_C@_06BAOMBKPD@Error?5?$AA@			; `string'
PUBLIC	??_C@_0CF@JFPNHCMD@?$CFs?$CFd?5fault?3?5?$CFs?5?$FL?$CFs?$FN?6?$CC?$CFs?$CC?6Detail?3@ ; `string'
PUBLIC	??_C@_08IAKGCGCB@Detail?3?5?$AA@		; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL?$AA@			; `string'
PUBLIC	??_C@_08PPEKPCIO@?5fault?3?5?$AA@		; `string'
PUBLIC	??_C@_0CD@LNJDOMMI@Error?3?5soap?5struct?5not?5initializ@ ; `string'
PUBLIC	??_C@_0BK@GONPECDN@?$CFs?$CFc?6?$DM?$CB?9?9?5?$CK?$CK?5HERE?5?$CK?$CK?5?9?9?$DO?6?$AA@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_7soap@@6B@					; soap::`vftable'
EXTRN	_WSACleanup@0:PROC
EXTRN	_bind@12:PROC
EXTRN	_htonl@4:PROC
EXTRN	_listen@8:PROC
EXTRN	_ntohs@4:PROC
EXTRN	_fopen:PROC
EXTRN	_strstr:PROC
EXTRN	_rand:PROC
EXTRN	_write:PROC
EXTRN	_send@16:PROC
EXTRN	_sendto@24:PROC
EXTRN	_read:PROC
EXTRN	_ntohl@4:PROC
EXTRN	_recvfrom@24:PROC
EXTRN	_inet_addr@4:PROC
EXTRN	_gethostbyname@4:PROC
EXTRN	_connect@12:PROC
EXTRN	_ioctlsocket@12:PROC
EXTRN	_getsockopt@20:PROC
EXTRN	_htons@4:PROC
EXTRN	_setsockopt@20:PROC
EXTRN	_socket@12:PROC
EXTRN	_WSAGetLastError@0:PROC
EXTRN	_WSAStartup@8:PROC
EXTRN	_accept@12:PROC
EXTRN	_closesocket@4:PROC
EXTRN	_shutdown@8:PROC
EXTRN	_strrchr:PROC
EXTRN	_mbtowc:PROC
EXTRN	____mb_cur_max_func:PROC
EXTRN	_wctomb:PROC
EXTRN	_strtol:PROC
EXTRN	__isnan:PROC
EXTRN	_strtod:PROC
EXTRN	_strtoul:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__gmtime64:PROC
EXTRN	__ftime64:PROC
EXTRN	_strftime:PROC
EXTRN	__localtime64:PROC
EXTRN	_sscanf:PROC
EXTRN	__mktime64:PROC
EXTRN	__setmode:PROC
EXTRN	_atol:PROC
EXTRN	_strncmp:PROC
EXTRN	_strchr:PROC
EXTRN	_strncat:PROC
EXTRN	_memmove:PROC
EXTRN	_sprintf:PROC
EXTRN	__imp__FormatMessageA@28:PROC
EXTRN	___WSAFDIsSet@8:PROC
EXTRN	_recv@16:PROC
EXTRN	_select@20:PROC
EXTRN	__snprintf:PROC
EXTRN	_strncpy:PROC
EXTRN	_fprintf:PROC
EXTRN	_malloc:PROC
EXTRN	??_Esoap@@UAEPAXI@Z:PROC			; soap::`vector deleting destructor'
_tcp_done DD	01H DUP (?)
;	COMDAT ??_7soap@@6B@
CONST	SEGMENT
??_7soap@@6B@ DD FLAT:??_R4soap@@6B@			; soap::`vftable'
	DD	FLAT:??_Esoap@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4soap@@6B@
rdata$r	SEGMENT
??_R4soap@@6B@ DD 00H					; soap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUsoap@@@8
	DD	FLAT:??_R3soap@@8
rdata$r	ENDS
;	COMDAT ??_R3soap@@8
rdata$r	SEGMENT
??_R3soap@@8 DD	00H					; soap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2soap@@8
rdata$r	ENDS
;	COMDAT ??_R2soap@@8
rdata$r	SEGMENT
??_R2soap@@8 DD	FLAT:??_R1A@?0A@EA@soap@@8		; soap::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@soap@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@soap@@8 DD FLAT:??_R0?AUsoap@@@8		; soap::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3soap@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUsoap@@@8
_DATA	SEGMENT
??_R0?AUsoap@@@8 DD FLAT:??_7type_info@@6B@		; soap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUsoap@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GONPECDN@?$CFs?$CFc?6?$DM?$CB?9?9?5?$CK?$CK?5HERE?5?$CK?$CK?5?9?9?$DO?6?$AA@
CONST	SEGMENT
??_C@_0BK@GONPECDN@?$CFs?$CFc?6?$DM?$CB?9?9?5?$CK?$CK?5HERE?5?$CK?$CK?5?9?9?$DO?6?$AA@ DB '%'
	DB	's%c', 0aH, '<!-- ** HERE ** -->', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LNJDOMMI@Error?3?5soap?5struct?5not?5initializ@
CONST	SEGMENT
??_C@_0CD@LNJDOMMI@Error?3?5soap?5struct?5not?5initializ@ DB 'Error: soap'
	DB	' struct not initialized', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PPEKPCIO@?5fault?3?5?$AA@
CONST	SEGMENT
??_C@_08PPEKPCIO@?5fault?3?5?$AA@ DB ' fault: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL?$AA@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL?$AA@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08IAKGCGCB@Detail?3?5?$AA@
CONST	SEGMENT
??_C@_08IAKGCGCB@Detail?3?5?$AA@ DB 'Detail: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JFPNHCMD@?$CFs?$CFd?5fault?3?5?$CFs?5?$FL?$CFs?$FN?6?$CC?$CFs?$CC?6Detail?3@
CONST	SEGMENT
??_C@_0CF@JFPNHCMD@?$CFs?$CFd?5fault?3?5?$CFs?5?$FL?$CFs?$FN?6?$CC?$CFs?$CC?6Detail?3@ DB '%'
	DB	's%d fault: %s [%s]', 0aH, '"%s"', 0aH, 'Detail: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BAOMBKPD@Error?5?$AA@
CONST	SEGMENT
??_C@_06BAOMBKPD@Error?5?$AA@ DB 'Error ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IBLMOOJE@SOAP?51?4?$AA@
CONST	SEGMENT
??_C@_07IBLMOOJE@SOAP?51?4?$AA@ DB 'SOAP 1.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HPHPPAL@no?5subcode?$AA@
CONST	SEGMENT
??_C@_0L@HPHPPAL@no?5subcode?$AA@ DB 'no subcode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NEEDGNL@?$FLno?5reason?$FN?$AA@
CONST	SEGMENT
??_C@_0M@NEEDGNL@?$FLno?5reason?$FN?$AA@ DB '[no reason]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NIEENCAP@?$FLno?5detail?$FN?$AA@
CONST	SEGMENT
??_C@_0M@NIEENCAP@?$FLno?5detail?$FN?$AA@ DB '[no detail]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KAKMECOH@Error?3?5soap?5struct?5state?5not?5ini@
CONST	SEGMENT
??_C@_0CK@KAKMECOH@Error?3?5soap?5struct?5state?5not?5ini@ DB 'Error: soa'
	DB	'p struct state not initialized', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EBMJBALC@Operation?5interrupted?5or?5timed?5o@
CONST	SEGMENT
??_C@_0CD@EBMJBALC@Operation?5interrupted?5or?5timed?5o@ DB 'Operation in'
	DB	'terrupted or timed out', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HBKFNCEG@Operation?5interrupted?5or?5timed?5o@
CONST	SEGMENT
??_C@_0DL@HBKFNCEG@Operation?5interrupted?5or?5timed?5o@ DB 'Operation in'
	DB	'terrupted or timed out after %ds receive delay', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@OEKCJEEM@Operation?5interrupted?5or?5timed?5o@
CONST	SEGMENT
??_C@_0EH@OEKCJEEM@Operation?5interrupted?5or?5timed?5o@ DB 'Operation in'
	DB	'terrupted or timed out after %ds send or %ds receive delay', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DABIKIOO@SOAP?9ENV?3Receiver?$AA@
CONST	SEGMENT
??_C@_0BC@DABIKIOO@SOAP?9ENV?3Receiver?$AA@ DB 'SOAP-ENV:Receiver', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NJHKENFI@SOAP?9ENV?3Server?$AA@
CONST	SEGMENT
??_C@_0BA@NJHKENFI@SOAP?9ENV?3Server?$AA@ DB 'SOAP-ENV:Server', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PNOEHBEA@Error?5?$CFd?$AA@
CONST	SEGMENT
??_C@_08PNOEHBEA@Error?5?$CFd?$AA@ DB 'Error %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BJFDHNPP@HTTP?5Error?3?5?$CFd?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BC@BJFDHNPP@HTTP?5Error?3?5?$CFd?5?$CFs?$AA@ DB 'HTTP Error: %d %s'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LNBGPKAI@End?5of?5file?5or?5no?5input?3?5?$AA@
CONST	SEGMENT
??_C@_0BK@LNBGPKAI@End?5of?5file?5or?5no?5input?3?5?$AA@ DB 'End of file '
	DB	'or no input: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GDNDADLI@Stopped?3?5no?5response?5sent?$AA@
CONST	SEGMENT
??_C@_0BK@GDNDADLI@Stopped?3?5no?5response?5sent?$AA@ DB 'Stopped: no res'
	DB	'ponse sent', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LKNNNLAG@Maximum?5number?5of?5open?5connectio@
CONST	SEGMENT
??_C@_0CP@LKNNNLAG@Maximum?5number?5of?5open?5connectio@ DB 'Maximum numb'
	DB	'er of open connections was reached', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BEFALLEK@content?5length?5violation?$AA@
CONST	SEGMENT
??_C@_0BJ@BEFALLEK@content?5length?5violation?$AA@ DB 'content length vio'
	DB	'lation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NAKMPMCF@occurrence?5violation?$AA@
CONST	SEGMENT
??_C@_0BF@NAKMPMCF@occurrence?5violation?$AA@ DB 'occurrence violation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FOFAKJF@prohibited?5attribute?5present?$AA@
CONST	SEGMENT
??_C@_0BN@FOFAKJF@prohibited?5attribute?5present?$AA@ DB 'prohibited attr'
	DB	'ibute present', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IAKLNEOE@missing?5required?5attribute?$AA@
CONST	SEGMENT
??_C@_0BL@IAKLNEOE@missing?5required?5attribute?$AA@ DB 'missing required'
	DB	' attribute', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@DMDOKJJA@Zlib?1gzip?5not?5installed?5for?5?$CIde?$CJ@
CONST	SEGMENT
??_C@_0EI@DMDOKJJA@Zlib?1gzip?5not?5installed?5for?5?$CIde?$CJ@ DB 'Zlib/'
	DB	'gzip not installed for (de)compression: recompile with -DWITH'
	DB	'_GZIP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EHHICPGI@End?5of?5MIME?5error?$AA@
CONST	SEGMENT
??_C@_0BC@EHHICPGI@End?5of?5MIME?5error?$AA@ DB 'End of MIME error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PFEDMHLA@MIME?5href?5to?5missing?5attachment?$AA@
CONST	SEGMENT
??_C@_0CA@PFEDMHLA@MIME?5href?5to?5missing?5attachment?$AA@ DB 'MIME href'
	DB	' to missing attachment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GALJBELM@MIME?5format?5error?$AA@
CONST	SEGMENT
??_C@_0BC@GALJBELM@MIME?5format?5error?$AA@ DB 'MIME format error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DMDFBBON@End?5of?5DIME?5error?$AA@
CONST	SEGMENT
??_C@_0BC@DMDFBBON@End?5of?5DIME?5error?$AA@ DB 'End of DIME error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FOKLPDEJ@DIME?5version?1transmission?5error?$AA@
CONST	SEGMENT
??_C@_0CA@FOKLPDEJ@DIME?5version?1transmission?5error?$AA@ DB 'DIME versi'
	DB	'on/transmission error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OHINPGEO@DIME?5href?5to?5missing?5attachment?$AA@
CONST	SEGMENT
??_C@_0CA@OHINPGEO@DIME?5href?5to?5missing?5attachment?$AA@ DB 'DIME href'
	DB	' to missing attachment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JILKAMFB@DIME?5format?5error?$AA@
CONST	SEGMENT
??_C@_0BC@JILKAMFB@DIME?5format?5error?$AA@ DB 'DIME format error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IBFEEHMP@Plugin?5registry?5error?$AA@
CONST	SEGMENT
??_C@_0BG@IBFEEHMP@Plugin?5registry?5error?$AA@ DB 'Plugin registry error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GLMBMACG@OpenSSL?5not?5installed?3?5recompile@
CONST	SEGMENT
??_C@_0DF@GLMBMACG@OpenSSL?5not?5installed?3?5recompile@ DB 'OpenSSL not '
	DB	'installed: recompile with -DWITH_OPENSSL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KGMKOPGF@An?5HTTP?5processing?5error?5occurre@
CONST	SEGMENT
??_C@_0CC@KGMKOPGF@An?5HTTP?5processing?5error?5occurre@ DB 'An HTTP proc'
	DB	'essing error occurred', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LLFCFDEP@Message?5too?5large?5for?5UDP?5packet@
CONST	SEGMENT
??_C@_0CB@LLFCFDEP@Message?5too?5large?5for?5UDP?5packet@ DB 'Message too'
	DB	' large for UDP packet', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KLBPBEIF@incompatible?5object?5type?5ref?1id?5@
CONST	SEGMENT
??_C@_0CG@KLBPBEIF@incompatible?5object?5type?5ref?1id?5@ DB 'incompatibl'
	DB	'e object type ref/id pair ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NNKPGICN@SOAP?9ENC?3MissingID?$AA@
CONST	SEGMENT
??_C@_0BD@NNKPGICN@SOAP?9ENC?3MissingID?$AA@ DB 'SOAP-ENC:MissingID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MPBPOAHN@missing?5id?5for?5ref?5?$AA@
CONST	SEGMENT
??_C@_0BE@MPBPOAHN@missing?5id?5for?5ref?5?$AA@ DB 'missing id for ref ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NPKHDOOL@SOAP?9ENC?3DuplicateID?$AA@
CONST	SEGMENT
??_C@_0BF@NPKHDOOL@SOAP?9ENC?3DuplicateID?$AA@ DB 'SOAP-ENC:DuplicateID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BCCCPBMJ@multiple?5definitions?5of?5id?5?$AA@
CONST	SEGMENT
??_C@_0BM@BCCCPBMJ@multiple?5definitions?5of?5id?5?$AA@ DB 'multiple defi'
	DB	'nitions of id ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NJOHCEBG@nil?5not?5allowed?$AA@
CONST	SEGMENT
??_C@_0BA@NJOHCEBG@nil?5not?5allowed?$AA@ DB 'nil not allowed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IJNJOFHI@Array?5index?5out?5of?5bounds?$AA@
CONST	SEGMENT
??_C@_0BK@IJNJOFHI@Array?5index?5out?5of?5bounds?$AA@ DB 'Array index out'
	DB	' of bounds', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GFHEHPAM@Header?5line?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BF@GFHEHPAM@Header?5line?5too?5long?$AA@ DB 'Header line too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HFBNDNPH@Memory?5overflow?5or?5memory?5corrup@
CONST	SEGMENT
??_C@_0CL@HFBNDNPH@Memory?5overflow?5or?5memory?5corrup@ DB 'Memory overf'
	DB	'low or memory corruption error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NALGGDJF@Out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@NALGGDJF@Out?5of?5memory?$AA@ DB 'Out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KGAMDCLK@HTTP?5method?5not?5implemented?$AA@
CONST	SEGMENT
??_C@_0BM@KGAMDCLK@HTTP?5method?5not?5implemented?$AA@ DB 'HTTP method no'
	DB	't implemented', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GICAEFAM@HTTP?5HEAD?5method?5not?5implemented@
CONST	SEGMENT
??_C@_0CB@GICAEFAM@HTTP?5HEAD?5method?5not?5implemented@ DB 'HTTP HEAD me'
	DB	'thod not implemented', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DBKHPHAA@HTTP?5PUT?5method?5not?5implemented?$AA@
CONST	SEGMENT
??_C@_0CA@DBKHPHAA@HTTP?5PUT?5method?5not?5implemented?$AA@ DB 'HTTP PUT '
	DB	'method not implemented', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BHFEEBKL@HTTP?5GET?5method?5not?5implemented?$AA@
CONST	SEGMENT
??_C@_0CA@BHFEEBKL@HTTP?5GET?5method?5not?5implemented?$AA@ DB 'HTTP GET '
	DB	'method not implemented', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MENEPEMK@Data?5required?5for?5operation?$AA@
CONST	SEGMENT
??_C@_0BM@MENEPEMK@Data?5required?5for?5operation?$AA@ DB 'Data required '
	DB	'for operation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@HBJFOFK@Method?5?8?$CFs?8?5not?5implemented?3?5met@
CONST	SEGMENT
??_C@_0EF@HBJFOFK@Method?5?8?$CFs?8?5not?5implemented?3?5met@ DB 'Method '
	DB	'''%s'' not implemented: method name or namespace not recogniz'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HCPCIMCN@Fatal?5error?$AA@
CONST	SEGMENT
??_C@_0M@HCPCIMCN@Fatal?5error?$AA@ DB 'Fatal error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PDEMLIEM@User?5error?$AA@
CONST	SEGMENT
??_C@_0L@PDEMLIEM@User?5error?$AA@ DB 'User error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DMKNFBBB@namespace?5error?$AA@
CONST	SEGMENT
??_C@_0BA@DMKNFBBB@namespace?5error?$AA@ DB 'namespace error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NKHANBGK@Unsupported?5SOAP?5data?5encoding?$AA@
CONST	SEGMENT
??_C@_0BP@NKHANBGK@Unsupported?5SOAP?5data?5encoding?$AA@ DB 'Unsupported'
	DB	' SOAP data encoding', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OABEEJDM@SOAP?9ENV?3DataEncodingUnknown?$AA@
CONST	SEGMENT
??_C@_0BN@OABEEJDM@SOAP?9ENV?3DataEncodingUnknown?$AA@ DB 'SOAP-ENV:DataE'
	DB	'ncodingUnknown', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JCAMFCDG@Invalid?5SOAP?5message?5or?5SOAP?5ver@
CONST	SEGMENT
??_C@_0CO@JCAMFCDG@Invalid?5SOAP?5message?5or?5SOAP?5ver@ DB 'Invalid SOA'
	DB	'P message or SOAP version mismatch', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OACCBMEJ@SOAP?9ENV?3VersionMismatch?$AA@
CONST	SEGMENT
??_C@_0BJ@OACCBMEJ@SOAP?9ENV?3VersionMismatch?$AA@ DB 'SOAP-ENV:VersionMi'
	DB	'smatch', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@DIEDGBJC@The?5data?5in?5element?5?8?$CFs?8?5must?5be@
CONST	SEGMENT
??_C@_0EC@DIEDGBJC@The?5data?5in?5element?5?8?$CFs?8?5must?5be@ DB 'The d'
	DB	'ata in element ''%s'' must be understood but cannot be handle'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MFGAEHIJ@SOAP?9ENV?3MustUnderstand?$AA@
CONST	SEGMENT
??_C@_0BI@MFGAEHIJ@SOAP?9ENV?3MustUnderstand?$AA@ DB 'SOAP-ENV:MustUnders'
	DB	'tand', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HDMBMFLH@No?5XML?5element?5tag?$AA@
CONST	SEGMENT
??_C@_0BD@HDMBMFLH@No?5XML?5element?5tag?$AA@ DB 'No XML element tag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BDHDOCNN@Well?9formedness?5violation?$AA@
CONST	SEGMENT
??_C@_0BK@BDHDOCNN@Well?9formedness?5violation?$AA@ DB 'Well-formedness v'
	DB	'iolation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GBNPKFOD@data?5type?5mismatch?5?$AA@
CONST	SEGMENT
??_C@_0BE@GBNPKFOD@data?5type?5mismatch?5?$AA@ DB 'data type mismatch ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EDHHHBAK@tag?5name?5or?5namespace?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BP@EDHHHBAK@tag?5name?5or?5namespace?5mismatch?$AA@ DB 'tag name o'
	DB	'r namespace mismatch', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LCJPOAAP@Server?5fault?$AA@
CONST	SEGMENT
??_C@_0N@LCJPOAAP@Server?5fault?$AA@ DB 'Server fault', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JOEFJCHK@Client?5fault?$AA@
CONST	SEGMENT
??_C@_0N@JOEFJCHK@Client?5fault?$AA@ DB 'Client fault', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@
CONST	SEGMENT
??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@ DB 'SOAP-ENV:Client', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@
CONST	SEGMENT
??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@ DB 'Validation co'
	DB	'nstraint violation: %s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@
CONST	SEGMENT
??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@ DB 'Validation co'
	DB	'nstraint violation: %s%s in element <%s>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LGMEBDBC@Server?$AA@
CONST	SEGMENT
??_C@_06LGMEBDBC@Server?$AA@ DB 'Server', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FNMKOGBN@500?5Internal?5Server?5Error?$AA@
CONST	SEGMENT
??_C@_0BK@FNMKOGBN@500?5Internal?5Server?5Error?$AA@ DB '500 Internal Ser'
	DB	'ver Error', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NLEABOII@400?5Bad?5Request?$AA@
CONST	SEGMENT
??_C@_0BA@NLEABOII@400?5Bad?5Request?$AA@ DB '400 Bad Request', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@
CONST	SEGMENT
??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@ DB 'SOAP-ENV:Sender', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GEFAMELB@Basic?5realm?$DN?$CC?$CFs?$CC?$AA@
CONST	SEGMENT
??_C@_0BB@GEFAMELB@Basic?5realm?$DN?$CC?$CFs?$CC?$AA@ DB 'Basic realm="%s'
	DB	'"', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NIIEEHHB@gSOAP?5Web?5Service?$AA@
CONST	SEGMENT
??_C@_0BC@NIIEEHHB@gSOAP?5Web?5Service?$AA@ DB 'gSOAP Web Service', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OIHDPKBJ@HTTP?1?$CFs?5?$CFd?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0O@OIHDPKBJ@HTTP?1?$CFs?5?$CFd?5?$CFs?$AA@ DB 'HTTP/%s %d %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PGDKHFME@Status?$AA@
CONST	SEGMENT
??_C@_06PGDKHFME@Status?$AA@ DB 'Status', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HINEDFNI@HTTP?1?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@HINEDFNI@HTTP?1?$CFs?5?$CFs?$AA@ DB 'HTTP/%s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GGGJJCHF@202?5ACCEPTED?$AA@
CONST	SEGMENT
??_C@_0N@GGGJJCHF@202?5ACCEPTED?$AA@ DB '202 ACCEPTED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DAENNINM@200?5OK?$AA@
CONST	SEGMENT
??_C@_06DAENNINM@200?5OK?$AA@ DB '200 OK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
CONST	SEGMENT
??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@ DB '"%s"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DCLKKIPG@Proxy?9Authorization?$AA@
CONST	SEGMENT
??_C@_0BE@DCLKKIPG@Proxy?9Authorization?$AA@ DB 'Proxy-Authorization', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFOGOLGD@Basic?5?$AA@
CONST	SEGMENT
??_C@_06FFOGOLGD@Basic?5?$AA@ DB 'Basic ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@
CONST	SEGMENT
??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@ DB '%s:%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMPACEMJ@User?9Agent?$AA@
CONST	SEGMENT
??_C@_0L@DMPACEMJ@User?9Agent?$AA@ DB 'User-Agent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBLJBAGJ@gSOAP?12?47?$AA@
CONST	SEGMENT
??_C@_09MBLJBAGJ@gSOAP?12?47?$AA@ DB 'gSOAP/2.7', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKPGCKL@?$CFs?3?$CFd?$AA@
CONST	SEGMENT
??_C@_05HKPGCKL@?$CFs?3?$CFd?$AA@ DB '%s:%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PENEPKMC@?$CFs?5?1?$CFs?5HTTP?1?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@PENEPKMC@?$CFs?5?1?$CFs?5HTTP?1?$CFs?$AA@ DB '%s /%s HTTP/%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FAODEEBC@?$CFs?5?$CFs?5HTTP?1?$CFs?$AA@
CONST	SEGMENT
??_C@_0O@FAODEEBC@?$CFs?5?$CFs?5HTTP?1?$CFs?$AA@ DB '%s %s HTTP/%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EFCFIIJL@httpg?3?$AA@
CONST	SEGMENT
??_C@_06EFCFIIJL@httpg?3?$AA@ DB 'httpg:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLIDCHCJ@http?3?$CK?$AA@
CONST	SEGMENT
??_C@_06GLIDCHCJ@http?3?$CK?$AA@ DB 'http:*', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCJEIHPL@POST?$AA@
CONST	SEGMENT
??_C@_04HCJEIHPL@POST?$AA@ DB 'POST', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HAPOJHBM@GET?$AA@
CONST	SEGMENT
??_C@_03HAPOJHBM@GET?$AA@ DB 'GET', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KJFFOCGK@?$DL?5start?9info?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_0P@KJFFOCGK@?$DL?5start?9info?$DN?$CC?$AA@ DB '; start-info="', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ENHEIJFK@?$CC?$DL?5start?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_0L@ENHEIJFK@?$CC?$DL?5start?$DN?$CC?$AA@ DB '"; start="', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HGDIJJKJ@multipart?1related?$DL?5boundary?$DN?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0CJ@HGDIJJKJ@multipart?1related?$DL?5boundary?$DN?$CC?$CFs?$CC@ DB 'm'
	DB	'ultipart/related; boundary="%s"; type="', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GGDEJPLO@application?1xop?$CLxml?$DL?5charset?$DNutf@
CONST	SEGMENT
??_C@_0CD@GGDEJPLO@application?1xop?$CLxml?$DL?5charset?$DNutf@ DB 'appli'
	DB	'cation/xop+xml; charset=utf-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CDMHJEKP@text?1html?$DL?5charset?$DNutf?98?$AA@
CONST	SEGMENT
??_C@_0BJ@CDMHJEKP@text?1html?$DL?5charset?$DNutf?98?$AA@ DB 'text/html; '
	DB	'charset=utf-8', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09LLHAEKON@soap?4udp?3?$AA@
CONST	SEGMENT
??_C@_09LLHAEKON@soap?4udp?3?$AA@ DB 'soap.udp:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@
CONST	SEGMENT
??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@ DB 'SOAP-ENV:Body', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MJIIEFNN@Body?$AA@
CONST	SEGMENT
??_C@_04MJIIEFNN@Body?$AA@ DB 'Body', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNIFHPHN@html?$AA@
CONST	SEGMENT
??_C@_04PNIFHPHN@html?$AA@ DB 'html', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@
CONST	SEGMENT
??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@ DB 'SOAP-ENV:Envelope', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@EHIFGEMB@?9?9?$CFs?$AN?6Content?9Type?3?5?$CFs?$AN?6Content?9@
CONST	SEGMENT
??_C@_0EO@EHIFGEMB@?9?9?$CFs?$AN?6Content?9Type?3?5?$CFs?$AN?6Content?9@ DB '-'
	DB	'-%s', 0dH, 0aH, 'Content-Type: %s', 0dH, 0aH, 'Content-Transf'
	DB	'er-Encoding: binary', 0dH, 0aH, 'Content-ID: %s', 0dH, 0aH, 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JFLEALON@text?1xml?$DL?5charset?$DNutf?98?$AA@
CONST	SEGMENT
??_C@_0BI@JFLEALON@text?1xml?$DL?5charset?$DNutf?98?$AA@ DB 'text/xml; ch'
	DB	'arset=utf-8', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HOOLIGFB@application?1soap?$CLxml?$DL?5charset?$DNut@
CONST	SEGMENT
??_C@_0CE@HOOLIGFB@application?1soap?$CLxml?$DL?5charset?$DNut@ DB 'appli'
	DB	'cation/soap+xml; charset=utf-8', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@OLHLLNHK@application?1xop?$CLxml?$DL?5charset?$DNutf@
CONST	SEGMENT
??_C@_0EA@OLHLLNHK@application?1xop?$CLxml?$DL?5charset?$DNutf@ DB 'appli'
	DB	'cation/xop+xml; charset=utf-8; type="application/soap+xml"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02NFLHGFB@?0?$DL?$AA@
CONST	SEGMENT
??_C@_02NFLHGFB@?0?$DL?$AA@ DB ',;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NBBPFACD@?$DN?0?$DL?$AA@
CONST	SEGMENT
??_C@_03NBBPFACD@?$DN?0?$DL?$AA@ DB '=,;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HEMDDLEL@X?9Forwarded?9For?$AA@
CONST	SEGMENT
??_C@_0BA@HEMDDLEL@X?9Forwarded?9For?$AA@ DB 'X-Forwarded-For', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KDOEBHGA@Location?$AA@
CONST	SEGMENT
??_C@_08KDOEBHGA@Location?$AA@ DB 'Location', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BIMPHKBC@SOAPAction?$AA@
CONST	SEGMENT
??_C@_0L@BIMPHKBC@SOAPAction?$AA@ DB 'SOAPAction', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NPCCMLBA@HTTP?11?41?5100?5Continue?$AA@
CONST	SEGMENT
??_C@_0BG@NPCCMLBA@HTTP?11?41?5100?5Continue?$AA@ DB 'HTTP/1.1 100 Contin'
	DB	'ue', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IOPAKPOD@100?9continue?$AA@
CONST	SEGMENT
??_C@_0N@IOPAKPOD@100?9continue?$AA@ DB '100-continue', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GHDJNLIG@Expect?$AA@
CONST	SEGMENT
??_C@_06GHDJNLIG@Expect?$AA@ DB 'Expect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ELABLNGD@realm?$AA@
CONST	SEGMENT
??_C@_05ELABLNGD@realm?$AA@ DB 'realm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KEDJJIFI@WWW?9Authenticate?$AA@
CONST	SEGMENT
??_C@_0BB@KEDJJIFI@WWW?9Authenticate?$AA@ DB 'WWW-Authenticate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LLIFBKCB@Basic?5?$CK?$AA@
CONST	SEGMENT
??_C@_07LLIFBKCB@Basic?5?$CK?$AA@ DB 'Basic *', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NAFGPKMI@Authorization?$AA@
CONST	SEGMENT
??_C@_0O@NAFGPKMI@Authorization?$AA@ DB 'Authorization', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LBOHBHFK@close?$AA@
CONST	SEGMENT
??_C@_05LBOHBHFK@close?$AA@ DB 'close', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FFDPOIEG@keep?9alive?$AA@
CONST	SEGMENT
??_C@_0L@FFDPOIEG@keep?9alive?$AA@ DB 'keep-alive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PJJKMLL@Connection?$AA@
CONST	SEGMENT
??_C@_0L@PJJKMLL@Connection?$AA@ DB 'Connection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KCKHAHHI@chunked?$AA@
CONST	SEGMENT
??_C@_07KCKHAHHI@chunked?$AA@ DB 'chunked', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ELHLFCNH@Transfer?9Encoding?$AA@
CONST	SEGMENT
??_C@_0BC@ELHLFCNH@Transfer?9Encoding?$AA@ DB 'Transfer-Encoding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HOHEGKBO@gzip?$AA@
CONST	SEGMENT
??_C@_04HOHEGKBO@gzip?$AA@ DB 'gzip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FNHFFEJG@deflate?$AA@
CONST	SEGMENT
??_C@_07FNHFFEJG@deflate?$AA@ DB 'deflate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KFPPKJHF@Content?9Encoding?$AA@
CONST	SEGMENT
??_C@_0BB@KFPPKJHF@Content?9Encoding?$AA@ DB 'Content-Encoding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HOJGPHBA@Content?9Length?$AA@
CONST	SEGMENT
??_C@_0P@HOJGPHBA@Content?9Length?$AA@ DB 'Content-Length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DDLLCOJG@action?$AA@
CONST	SEGMENT
??_C@_06DDLLCOJG@action?$AA@ DB 'action', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FAGFPHJG@start?$AA@
CONST	SEGMENT
??_C@_05FAGFPHJG@start?$AA@ DB 'start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KIKGFOKI@boundary?$AA@
CONST	SEGMENT
??_C@_08KIKGFOKI@boundary?$AA@ DB 'boundary', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PILCJFLE@multipart?1form?9data?$AA@
CONST	SEGMENT
??_C@_0BE@PILCJFLE@multipart?1form?9data?$AA@ DB 'multipart/form-data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GGLOKPIO@multipart?1related?$AA@
CONST	SEGMENT
??_C@_0BC@GGLOKPIO@multipart?1related?$AA@ DB 'multipart/related', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FGAOOBMN@http?3?1?1?$AA@
CONST	SEGMENT
??_C@_07FGAOOBMN@http?3?1?1?$AA@ DB 'http://', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CPPPJGME@Host?$AA@
CONST	SEGMENT
??_C@_04CPPPJGME@Host?$AA@ DB 'Host', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LOBKJNKF@HTTP?5Error?$AA@
CONST	SEGMENT
??_C@_0L@LOBKJNKF@HTTP?5Error?$AA@ DB 'HTTP Error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PMJKDPIC@HEAD?5?$AA@
CONST	SEGMENT
??_C@_05PMJKDPIC@HEAD?5?$AA@ DB 'HEAD ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GOAKFIAN@DELETE?5?$AA@
CONST	SEGMENT
??_C@_07GOAKFIAN@DELETE?5?$AA@ DB 'DELETE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DCMJKHH@PUT?5?$AA@
CONST	SEGMENT
??_C@_04DCMJKHH@PUT?5?$AA@ DB 'PUT ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IBPFIGHK@GET?5?$AA@
CONST	SEGMENT
??_C@_04IBPFIGHK@GET?5?$AA@ DB 'GET ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LPJJJLLB@POST?5?$AA@
CONST	SEGMENT
??_C@_05LPJJJLLB@POST?5?$AA@ DB 'POST ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKGKDBHO@HTTP?1?$AA@
CONST	SEGMENT
??_C@_05FKGKDBHO@HTTP?1?$AA@ DB 'HTTP/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KDHCEMMM@application?1dime?$AA@
CONST	SEGMENT
??_C@_0BB@KDHCEMMM@application?1dime?$AA@ DB 'application/dime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MKHJBFJG@?$DMSOAP?9ENV?3Envelope?$DO?$AA@
CONST	SEGMENT
??_C@_0BE@MKHJBFJG@?$DMSOAP?9ENV?3Envelope?$DO?$AA@ DB '<SOAP-ENV:Envelop'
	DB	'e>', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGOFBIJA@?$DN?$DN?$AA@
CONST	SEGMENT
??_C@_02EGOFBIJA@?$DN?$DN?$AA@ DB '==', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02BAABKJLB@?9?9?$AA@
CONST	SEGMENT
??_C@_02BAABKJLB@?9?9?$AA@ DB '--', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FGNCEKKA@Content?9Description?3?5?$AA@
CONST	SEGMENT
??_C@_0BG@FGNCEKKA@Content?9Description?3?5?$AA@ DB 'Content-Description:'
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OHIJMKJJ@Content?9Location?3?5?$AA@
CONST	SEGMENT
??_C@_0BD@OHIJMKJJ@Content?9Location?3?5?$AA@ DB 'Content-Location: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NKGHAKLJ@Content?9ID?3?5?$AA@
CONST	SEGMENT
??_C@_0N@NKGHAKLJ@Content?9ID?3?5?$AA@ DB 'Content-ID: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MCMHCKIN@Content?9Transfer?9Encoding?3?5?$AA@
CONST	SEGMENT
??_C@_0BM@MCMHCKIN@Content?9Transfer?9Encoding?3?5?$AA@ DB 'Content-Trans'
	DB	'fer-Encoding: ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GJMOGDPG@Content?9Type?3?5?$AA@
CONST	SEGMENT
??_C@_0P@GJMOGDPG@Content?9Type?3?5?$AA@ DB 'Content-Type: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOEPKDGL@?$AN?6?9?9?$AA@
CONST	SEGMENT
??_C@_04LOEPKDGL@?$AN?6?9?9?$AA@ DB 0dH, 0aH, '--', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KBLJEPNL@?6?9?9?$AA@
CONST	SEGMENT
??_C@_03KBLJEPNL@?6?9?9?$AA@ DB 0aH, '--', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MJFMDPAI@Content?9Transfer?9Encoding?$AA@
CONST	SEGMENT
??_C@_0BK@MJFMDPAI@Content?9Transfer?9Encoding?$AA@ DB 'Content-Transfer-'
	DB	'Encoding', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CDHADPEM@Content?9Description?$AA@
CONST	SEGMENT
??_C@_0BE@CDHADPEM@Content?9Description?$AA@ DB 'Content-Description', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LAFFMKKA@Content?9Type?$AA@
CONST	SEGMENT
??_C@_0N@LAFFMKKA@Content?9Type?$AA@ DB 'Content-Type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LMOOGHBG@Content?9Disposition?$AA@
CONST	SEGMENT
??_C@_0BE@LMOOGHBG@Content?9Disposition?$AA@ DB 'Content-Disposition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EPBMDIDM@Content?9Location?$AA@
CONST	SEGMENT
??_C@_0BB@EPBMDIDM@Content?9Location?$AA@ DB 'Content-Location', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BJKBKLJG@Content?9ID?$AA@
CONST	SEGMENT
??_C@_0L@BJKBKLJG@Content?9ID?$AA@ DB 'Content-ID', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ONEMIJDH@?3dateTime?$AA@
CONST	SEGMENT
??_C@_09ONEMIJDH@?3dateTime?$AA@ DB ':dateTime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NFGPCJDJ@?$CFd?3?$CFd?$AA@
CONST	SEGMENT
??_C@_05NFGPCJDJ@?$CFd?3?$CFd?$AA@ DB '%d:%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KJDFMOL@?$CF4d?$CF2d?$CF2dT?$CF2d?$CF2d?$CF2d?$CF31s?$AA@
CONST	SEGMENT
??_C@_0BI@KJDFMOL@?$CF4d?$CF2d?$CF2dT?$CF2d?$CF2d?$CF2d?$CF31s?$AA@ DB '%'
	DB	'4d%2d%2dT%2d%2d%2d%31s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OJGJFHHH@?$CF4d?$CF2d?$CF2dT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@
CONST	SEGMENT
??_C@_0BH@OJGJFHHH@?$CF4d?$CF2d?$CF2dT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@ DB '%'
	DB	'4d%2d%2dT%d:%d:%d%31s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CNJMEEAL@?$CFd?9?$CFd?9?$CFdT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@
CONST	SEGMENT
??_C@_0BG@CNJMEEAL@?$CFd?9?$CFd?9?$CFdT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@ DB '%'
	DB	'd-%d-%dT%d:%d:%d%31s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KNOONEPL@1969?912?931T23?359?359Z?$AA@
CONST	SEGMENT
??_C@_0BF@KNOONEPL@1969?912?931T23?359?359Z?$AA@ DB '1969-12-31T23:59:59Z'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PEBBIKFI@?$CF?$CL03d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0L@PEBBIKFI@?$CF?$CL03d?3?$CF02d?$AA@ DB '%+03d:%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EJFCONBF@?$CFY?9?$CFm?9?$CFdT?$CFH?3?$CFM?3?$CFS?$AA@
CONST	SEGMENT
??_C@_0BC@EJFCONBF@?$CFY?9?$CFm?9?$CFdT?$CFH?3?$CFM?3?$CFS?$AA@ DB '%Y-%m'
	DB	'-%dT%H:%M:%S', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09MCFEFMEO@xmlns?3_?$CFd?$AA@
CONST	SEGMENT
??_C@_09MCFEFMEO@xmlns?3_?$CFd?$AA@ DB 'xmlns:_%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JMMFPCED@?$CC?$CC?$AA@
CONST	SEGMENT
??_C@_02JMMFPCED@?$CC?$CC?$AA@ DB '""', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FNFHGAAP@xml?3?$AA@
CONST	SEGMENT
??_C@_04FNFHGAAP@xml?3?$AA@ DB 'xml:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OINFJHGD@?$CFI64u?$AA@
CONST	SEGMENT
??_C@_05OINFJHGD@?$CFI64u?$AA@ DB '%I64u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKNCMABI@?$CFlu?$AA@
CONST	SEGMENT
??_C@_03FKNCMABI@?$CFlu?$AA@ DB '%lu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CCCGLAML@?$CFlg?$AA@
CONST	SEGMENT
??_C@_03CCCGLAML@?$CFlg?$AA@ DB '%lg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@
CONST	SEGMENT
??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@ DB ':unsignedByte', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@
CONST	SEGMENT
??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@ DB ':unsignedShort', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EEHCOMNL@?3unsignedInt?$AA@
CONST	SEGMENT
??_C@_0N@EEHCOMNL@?3unsignedInt?$AA@ DB ':unsignedInt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FKBEEKGD@?3unsignedLong?$AA@
CONST	SEGMENT
??_C@_0O@FKBEEKGD@?3unsignedLong?$AA@ DB ':unsignedLong', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HMJFKOLE@?3decimal?$AA@
CONST	SEGMENT
??_C@_08HMJFKOLE@?3decimal?$AA@ DB ':decimal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PBNBEHML@?3double?$AA@
CONST	SEGMENT
??_C@_07PBNBEHML@?3double?$AA@ DB ':double', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06INOMFGCG@?3float?$AA@
CONST	SEGMENT
??_C@_06INOMFGCG@?3float?$AA@ DB ':float', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02BEIEFPIG@?$CFg?$AA@
CONST	SEGMENT
??_C@_02BEIEFPIG@?$CFg?$AA@ DB '%g', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LFPHEJAJ@?$CLINF?$AA@
CONST	SEGMENT
??_C@_04LFPHEJAJ@?$CLINF?$AA@ DB '+INF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DKLHLMKJ@?9INF?$AA@
CONST	SEGMENT
??_C@_04DKLHLMKJ@?9INF?$AA@ DB '-INF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OEIAHPBN@INF?$AA@
CONST	SEGMENT
??_C@_03OEIAHPBN@INF?$AA@ DB 'INF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICJPMMHB@NaN?$AA@
CONST	SEGMENT
??_C@_03ICJPMMHB@NaN?$AA@ DB 'NaN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LMKOBMME@?3long?$AA@
CONST	SEGMENT
??_C@_05LMKOBMME@?3long?$AA@ DB ':long', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PMBJAKPA@?3nonNegativeInteger?$AA@
CONST	SEGMENT
??_C@_0BE@PMBJAKPA@?3nonNegativeInteger?$AA@ DB ':nonNegativeInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HIKONPMJ@?3nonPositiveInteger?$AA@
CONST	SEGMENT
??_C@_0BE@HIKONPMJ@?3nonPositiveInteger?$AA@ DB ':nonPositiveInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FHGJHLHJ@?3negativeInteger?$AA@
CONST	SEGMENT
??_C@_0BB@FHGJHLHJ@?3negativeInteger?$AA@ DB ':negativeInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NDNOKOEA@?3positiveInteger?$AA@
CONST	SEGMENT
??_C@_0BB@NDNOKOEA@?3positiveInteger?$AA@ DB ':positiveInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08ICEBEHNK@?3integer?$AA@
CONST	SEGMENT
??_C@_08ICEBEHNK@?3integer?$AA@ DB ':integer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LLAMLEHD@?$CFI64d?$AA@
CONST	SEGMENT
??_C@_05LLAMLEHD@?$CFI64d?$AA@ DB '%I64d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JALODAI@?$CFld?$AA@
CONST	SEGMENT
??_C@_03JALODAI@?$CFld?$AA@ DB '%ld', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FFGLOOMC@?3byte?$AA@
CONST	SEGMENT
??_C@_05FFGLOOMC@?3byte?$AA@ DB ':byte', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DFBHHOOH@?3short?$AA@
CONST	SEGMENT
??_C@_06DFBHHOOH@?3short?$AA@ DB ':short', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JNHIEKJE@?3int?$AA@
CONST	SEGMENT
??_C@_04JNHIEKJE@?3int?$AA@ DB ':int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HNAHLMAI@apos?$DL?$AA@
CONST	SEGMENT
??_C@_05HNAHLMAI@apos?$DL?$AA@ DB 'apos;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LDHOCHGG@quot?$DL?$AA@
CONST	SEGMENT
??_C@_05LDHOCHGG@quot?$DL?$AA@ DB 'quot;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DMIAPOKJ@amp?$DL?$AA@
CONST	SEGMENT
??_C@_04DMIAPOKJ@amp?$DL?$AA@ DB 'amp;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BHAAMAON@gt?$DL?$AA@
CONST	SEGMENT
??_C@_03BHAAMAON@gt?$DL?$AA@ DB 'gt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MAABEHOM@lt?$DL?$AA@
CONST	SEGMENT
??_C@_03MAABEHOM@lt?$DL?$AA@ DB 'lt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DDLNFFBN@?$CGquot?$DL?$AA@
CONST	SEGMENT
??_C@_06DDLNFFBN@?$CGquot?$DL?$AA@ DB '&quot;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@
CONST	SEGMENT
??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@ DB '&gt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@
CONST	SEGMENT
??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@ DB '&lt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKJFEODM@?$CGamp?$DL?$AA@
CONST	SEGMENT
??_C@_05JKJFEODM@?$CGamp?$DL?$AA@ DB '&amp;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PMADKPPE@?$CG?$CDxD?$DL?$AA@
CONST	SEGMENT
??_C@_05PMADKPPE@?$CG?$CDxD?$DL?$AA@ DB '&#xD;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PKMIGNBP@?$CG?$CDxA?$DL?$AA@
CONST	SEGMENT
??_C@_05PKMIGNBP@?$CG?$CDxA?$DL?$AA@ DB '&#xA;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KACKFEPH@?$CG?$CDx9?$DL?$AA@
CONST	SEGMENT
??_C@_05KACKFEPH@?$CG?$CDx9?$DL?$AA@ DB '&#x9;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@KBJFLDJI@http?3?1?1www?4w3?4org?12003?105?1soap?9e@
CONST	SEGMENT
??_C@_0DC@KBJFLDJI@http?3?1?1www?4w3?4org?12003?105?1soap?9e@ DB 'http://'
	DB	'www.w3.org/2003/05/soap-envelope/role/next', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCDGINBO@ref?$AA@
CONST	SEGMENT
??_C@_03GCDGINBO@ref?$AA@ DB 'ref', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EFBJIKLI@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
CONST	SEGMENT
??_C@_0CL@EFBJIKLI@http?3?1?1schemas?4xmlsoap?4org?1soap?1@ DB 'http://sc'
	DB	'hemas.xmlsoap.org/soap/actor/next', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BGJHDLJG@SOAP?9ENC?3root?$AA@
CONST	SEGMENT
??_C@_0O@BGJHDLJG@SOAP?9ENC?3root?$AA@ DB 'SOAP-ENC:root', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DJPLLOHP@xsi?3null?$AA@
CONST	SEGMENT
??_C@_08DJPLLOHP@xsi?3null?$AA@ DB 'xsi:null', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BGJENONN@wsu?3Id?$AA@
CONST	SEGMENT
??_C@_06BGJENONN@wsu?3Id?$AA@ DB 'wsu:Id', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEFOGKI@xmlns?$AA@
CONST	SEGMENT
??_C@_05PPEFOGKI@xmlns?$AA@ DB 'xmlns', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PNFLLAEF@xmlns?3?$AA@
CONST	SEGMENT
??_C@_06PNFLLAEF@xmlns?3?$AA@ DB 'xmlns:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EFBDHEMP@?3result?$AA@
CONST	SEGMENT
??_C@_07EFBDHEMP@?3result?$AA@ DB ':result', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CNMICKND@xmlns?3SOAP?9RPC?$AA@
CONST	SEGMENT
??_C@_0P@CNMICKND@xmlns?3SOAP?9RPC?$AA@ DB 'xmlns:SOAP-RPC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JOBDACAK@SOAP?9RPC?3result?$AA@
CONST	SEGMENT
??_C@_0BA@JOBDACAK@SOAP?9RPC?3result?$AA@ DB 'SOAP-RPC:result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KJDFMKIE@xsi?3nil?$AA@
CONST	SEGMENT
??_C@_07KJDFMKIE@xsi?3nil?$AA@ DB 'xsi:nil', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BDMFGIGK@?$CD_?$CFd?$AA@
CONST	SEGMENT
??_C@_04BDMFGIGK@?$CD_?$CFd?$AA@ DB '#_%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HAMJFIGF@SOAP?9ENC?3ref?$AA@
CONST	SEGMENT
??_C@_0N@HAMJFIGF@SOAP?9ENC?3ref?$AA@ DB 'SOAP-ENC:ref', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNDACHE@?$DM?1?$AA@
CONST	SEGMENT
??_C@_02DPNDACHE@?$DM?1?$AA@ DB '</', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCGKDMEN@?1?$DO?$AA@
CONST	SEGMENT
??_C@_02HCGKDMEN@?1?$DO?$AA@ DB '/>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02ILLPBGAO@?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_02ILLPBGAO@?$DN?$CC?$AA@ DB '="', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GFBEJDEK@SOAP?9ENC?3arrayType?$AA@
CONST	SEGMENT
??_C@_0BD@GFBEJDEK@SOAP?9ENC?3arrayType?$AA@ DB 'SOAP-ENC:arrayType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CCJOJBBI@SOAP?9ENC?3offset?$AA@
CONST	SEGMENT
??_C@_0BA@CCJOJBBI@SOAP?9ENC?3offset?$AA@ DB 'SOAP-ENC:offset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IKLKJNBD@SOAP?9ENC?3arraySize?$AA@
CONST	SEGMENT
??_C@_0BD@IKLKJNBD@SOAP?9ENC?3arraySize?$AA@ DB 'SOAP-ENC:arraySize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GCPDJBOG@SOAP?9ENC?3itemType?$AA@
CONST	SEGMENT
??_C@_0BC@GCPDJBOG@SOAP?9ENC?3itemType?$AA@ DB 'SOAP-ENC:itemType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EFIHKLBM@SOAP?9ENC?3Array?$AA@
CONST	SEGMENT
??_C@_0P@EFIHKLBM@SOAP?9ENC?3Array?$AA@ DB 'SOAP-ENC:Array', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DOAGFCPF@SOAP?9ENV?3encodingStyle?$AA@
CONST	SEGMENT
??_C@_0BH@DOAGFCPF@SOAP?9ENV?3encodingStyle?$AA@ DB 'SOAP-ENV:encodingSty'
	DB	'le', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ENKFHJBH@SOAP?9ENV?3mustUnderstand?$AA@
CONST	SEGMENT
??_C@_0BI@ENKFHJBH@SOAP?9ENV?3mustUnderstand?$AA@ DB 'SOAP-ENV:mustUnders'
	DB	'tand', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OHPBIEEK@SOAP?9ENV?3actor?$AA@
CONST	SEGMENT
??_C@_0P@OHPBIEEK@SOAP?9ENV?3actor?$AA@ DB 'SOAP-ENV:actor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HCOOBFLG@SOAP?9ENV?3role?$AA@
CONST	SEGMENT
??_C@_0O@HCOOBFLG@SOAP?9ENV?3role?$AA@ DB 'SOAP-ENV:role', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LJIIOGEO@SOAP?9ENC?3position?$AA@
CONST	SEGMENT
??_C@_0BC@LJIIOGEO@SOAP?9ENC?3position?$AA@ DB 'SOAP-ENC:position', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JNIDGPLJ@xsi?3type?$AA@
CONST	SEGMENT
??_C@_08JNIDGPLJ@xsi?3type?$AA@ DB 'xsi:type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03HCMCBFLP@_?$CFd?$AA@
CONST	SEGMENT
??_C@_03HCMCBFLP@_?$CFd?$AA@ DB '_%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HMPLFLKJ@xmlns?3?$CFs?$AA@
CONST	SEGMENT
??_C@_08HMPLFLKJ@xmlns?3?$CFs?$AA@ DB 'xmlns:%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01MNNFJEPP@?$DM?$AA@
CONST	SEGMENT
??_C@_01MNNFJEPP@?$DM?$AA@ DB '<', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FMJEECLD@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCUT@
CONST	SEGMENT
??_C@_0CI@FMJEECLD@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCUT@ DB '<'
	DB	'?xml version="1.0" encoding="UTF-8"?>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCKCNDHP@1?41?$AA@
CONST	SEGMENT
??_C@_03GCKCNDHP@1?41?$AA@ DB '1.1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HGNFPOFN@cid?3id?$CFd?$AA@
CONST	SEGMENT
??_C@_08HGNFPOFN@cid?3id?$CFd?$AA@ DB 'cid:id%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MNPIOIFE@?$CF?417lG?$AA@
CONST	SEGMENT
??_C@_06MNPIOIFE@?$CF?417lG?$AA@ DB '%.17lG', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OEJDHHEG@?$CF?49G?$AA@
CONST	SEGMENT
??_C@_04OEJDHHEG@?$CF?49G?$AA@ DB '%.9G', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT
??_C@_01MCMALHOG@a?$AA@ DB 'a', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BOGAIONP@ab?$AA@
CONST	SEGMENT
??_C@_02BOGAIONP@ab?$AA@ DB 'ab', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MEMIDCKI@?$AN?60?$AN?6?$AN?6?$AA@
CONST	SEGMENT
??_C@_07MEMIDCKI@?$AN?60?$AN?6?$AN?6?$AA@ DB 0dH, 0aH, '0', 0dH, 0aH, 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO?$AA@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO?$AA@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLBGAAHD@cid?3?$AA@
CONST	SEGMENT
??_C@_04MLBGAAHD@cid?3?$AA@ DB 'cid:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CMBCJJJD@href?$AA@
CONST	SEGMENT
??_C@_04CMBCJJJD@href?$AA@ DB 'href', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JGPGJFPH@no?5master?5socket?5in?5soap_accept?$CI@
CONST	SEGMENT
??_C@_0CC@JGPGJFPH@no?5master?5socket?5in?5soap_accept?$CI@ DB 'no master'
	DB	' socket in soap_accept()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BOBCLGJD@setsockopt?5TCP_NODELAY?5failed?5in@
CONST	SEGMENT
??_C@_0CP@BOBCLGJD@setsockopt?5TCP_NODELAY?5failed?5in@ DB 'setsockopt TC'
	DB	'P_NODELAY failed in soap_accept()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IBIGNPMJ@setsockopt?5SO_RCVBUF?5failed?5in?5s@
CONST	SEGMENT
??_C@_0CN@IBIGNPMJ@setsockopt?5SO_RCVBUF?5failed?5in?5s@ DB 'setsockopt S'
	DB	'O_RCVBUF failed in soap_accept()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DKDDHJHM@setsockopt?5SO_SNDBUF?5failed?5in?5s@
CONST	SEGMENT
??_C@_0CN@DKDDHJHM@setsockopt?5SO_SNDBUF?5failed?5in?5s@ DB 'setsockopt S'
	DB	'O_SNDBUF failed in soap_accept()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HHADOPDB@setsockopt?5SO_KEEPALIVE?5failed?5i@
CONST	SEGMENT
??_C@_0DA@HHADOPDB@setsockopt?5SO_KEEPALIVE?5failed?5i@ DB 'setsockopt SO'
	DB	'_KEEPALIVE failed in soap_accept()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BMBLFJEF@setsockopt?5failed?5in?5soap_accept@
CONST	SEGMENT
??_C@_0CD@BMBLFJEF@setsockopt?5failed?5in?5soap_accept@ DB 'setsockopt fa'
	DB	'iled in soap_accept()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IPOEJJJL@setsockopt?5SO_LINGER?5failed?5in?5s@
CONST	SEGMENT
??_C@_0CN@IPOEJJJL@setsockopt?5SO_LINGER?5failed?5in?5s@ DB 'setsockopt S'
	DB	'O_LINGER failed in soap_accept()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HJFOKHGA@accept?5failed?5in?5soap_accept?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@HJFOKHGA@accept?5failed?5in?5soap_accept?$CI?$CJ?$AA@ DB 'accep'
	DB	't failed in soap_accept()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DONKIDPM@select?5failed?5in?5soap_poll?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BN@DONKIDPM@select?5failed?5in?5soap_poll?$CI?$CJ?$AA@ DB 'select '
	DB	'failed in soap_poll()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GKFGOOJD@listen?5failed?5in?5soap_bind?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BN@GKFGOOJD@listen?5failed?5in?5soap_bind?$CI?$CJ?$AA@ DB 'listen '
	DB	'failed in soap_bind()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GFJLCODA@bind?5failed?5in?5soap_bind?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BL@GFJLCODA@bind?5failed?5in?5soap_bind?$CI?$CJ?$AA@ DB 'bind fail'
	DB	'ed in soap_bind()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FGHBILAG@get?5host?5by?5name?5failed?5in?5soap_@
CONST	SEGMENT
??_C@_0CH@FGHBILAG@get?5host?5by?5name?5failed?5in?5soap_@ DB 'get host b'
	DB	'y name failed in soap_bind()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KADDKKPF@setsockopt?5TCP_NODELAY?5failed?5in@
CONST	SEGMENT
??_C@_0CN@KADDKKPF@setsockopt?5TCP_NODELAY?5failed?5in@ DB 'setsockopt TC'
	DB	'P_NODELAY failed in soap_bind()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JJJGHOEP@setsockopt?5SO_RCVBUF?5failed?5in?5s@
CONST	SEGMENT
??_C@_0CL@JJJGHOEP@setsockopt?5SO_RCVBUF?5failed?5in?5s@ DB 'setsockopt S'
	DB	'O_RCVBUF failed in soap_bind()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HDDANLDN@setsockopt?5SO_SNDBUF?5failed?5in?5s@
CONST	SEGMENT
??_C@_0CL@HDDANLDN@setsockopt?5SO_SNDBUF?5failed?5in?5s@ DB 'setsockopt S'
	DB	'O_SNDBUF failed in soap_bind()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IMNBHKGL@setsockopt?5SO_KEEPALIVE?5failed?5i@
CONST	SEGMENT
??_C@_0CO@IMNBHKGL@setsockopt?5SO_KEEPALIVE?5failed?5i@ DB 'setsockopt SO'
	DB	'_KEEPALIVE failed in soap_bind()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LHEHKJOM@setsockopt?5failed?5in?5soap_bind?$CI?$CJ@
CONST	SEGMENT
??_C@_0CB@LHEHKJOM@setsockopt?5failed?5in?5soap_bind?$CI?$CJ@ DB 'setsock'
	DB	'opt failed in soap_bind()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LIAJIIPM@socket?5failed?5in?5soap_bind?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BN@LIAJIIPM@socket?5failed?5in?5soap_bind?$CI?$CJ?$AA@ DB 'socket '
	DB	'failed in soap_bind()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EOFJAGHM@TCP?5init?5failed?5in?5soap_bind?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@EOFJAGHM@TCP?5init?5failed?5in?5soap_bind?$CI?$CJ?$AA@ DB 'TCP '
	DB	'init failed in soap_bind()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NHIIGDKE@https?3?$CK?$AA@
CONST	SEGMENT
??_C@_07NHIIGDKE@https?3?$CK?$AA@ DB 'https:*', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MKALMBDJ@Timeout?$AA@
CONST	SEGMENT
??_C@_07MKALMBDJ@Timeout?$AA@ DB 'Timeout', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@ DB 'conn'
	DB	'ect failed in tcp_connect()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HHNLALCP@get?5host?5by?5name?5failed?5in?5tcp_c@
CONST	SEGMENT
??_C@_0CJ@HHNLALCP@get?5host?5by?5name?5failed?5in?5tcp_c@ DB 'get host b'
	DB	'y name failed in tcp_connect()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BEACMDAL@get?5proxy?5host?5by?5name?5failed?5in@
CONST	SEGMENT
??_C@_0CP@BEACMDAL@get?5proxy?5host?5by?5name?5failed?5in@ DB 'get proxy '
	DB	'host by name failed in tcp_connect()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@ECDFPEN@setsockopt?5TCP_NODELAY?5failed?5in@
CONST	SEGMENT
??_C@_0CP@ECDFPEN@setsockopt?5TCP_NODELAY?5failed?5in@ DB 'setsockopt TCP'
	DB	'_NODELAY failed in tcp_connect()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JLLHDGBH@setsockopt?5SO_RCVBUF?5failed?5in?5t@
CONST	SEGMENT
??_C@_0CN@JLLHDGBH@setsockopt?5SO_RCVBUF?5failed?5in?5t@ DB 'setsockopt S'
	DB	'O_RCVBUF failed in tcp_connect()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CAACJAKC@setsockopt?5SO_SNDBUF?5failed?5in?5t@
CONST	SEGMENT
??_C@_0CN@CAACJAKC@setsockopt?5SO_SNDBUF?5failed?5in?5t@ DB 'setsockopt S'
	DB	'O_SNDBUF failed in tcp_connect()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@GNDCAGOP@setsockopt?5SO_KEEPALIVE?5failed?5i@
CONST	SEGMENT
??_C@_0DA@GNDCAGOP@setsockopt?5SO_KEEPALIVE?5failed?5i@ DB 'setsockopt SO'
	DB	'_KEEPALIVE failed in tcp_connect()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GCKLAJL@setsockopt?5failed?5in?5tcp_connect@
CONST	SEGMENT
??_C@_0CD@GCKLAJL@setsockopt?5failed?5in?5tcp_connect@ DB 'setsockopt fai'
	DB	'led in tcp_connect()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JFNFHAEF@setsockopt?5SO_LINGER?5failed?5in?5t@
CONST	SEGMENT
??_C@_0CN@JFNFHAEF@setsockopt?5SO_LINGER?5failed?5in?5t@ DB 'setsockopt S'
	DB	'O_LINGER failed in tcp_connect()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IBLNNK@socket?5failed?5in?5tcp_connect?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@IBLNNK@socket?5failed?5in?5tcp_connect?$CI?$CJ?$AA@ DB 'socket '
	DB	'failed in tcp_connect()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DBACHNOG@TCP?5init?5failed?5in?5tcp_connect?$CI?$CJ@
CONST	SEGMENT
??_C@_0CB@DBACHNOG@TCP?5init?5failed?5in?5tcp_connect?$CI?$CJ@ DB 'TCP in'
	DB	'it failed in tcp_connect()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GDJAADON@TCP?1UDP?5IP?5error?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BE@GDJAADON@TCP?1UDP?5IP?5error?5?$CFd?$AA@ DB 'TCP/UDP IP error %'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NFJDOJIM@WSAStartup?5failed?$AA@
CONST	SEGMENT
??_C@_0BC@NFJDOJIM@WSAStartup?5failed?$AA@ DB 'WSAStartup failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NANEACJL@xsd?3ur?9type?$AA@
CONST	SEGMENT
??_C@_0M@NANEACJL@xsd?3ur?9type?$AA@ DB 'xsd:ur-type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJHHNEEI@xml?$AA@
CONST	SEGMENT
??_C@_03PJHHNEEI@xml?$AA@ DB 'xml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PNKAICOI@?$FL?$CFd?$AA@
CONST	SEGMENT
??_C@_03PNKAICOI@?$FL?$CFd?$AA@ DB '[%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LEIBKMN@?0?$CFd?$AA@
CONST	SEGMENT
??_C@_03LEIBKMN@?0?$CFd?$AA@ DB ',%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EBJOKFHF@?5?$CFd?$AA@
CONST	SEGMENT
??_C@_03EBJOKFHF@?5?$CFd?$AA@ DB ' %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IEDFPCMN@?$CFs?$FL?$CFd?$AA@
CONST	SEGMENT
??_C@_05IEDFPCMN@?$CFs?$FL?$CFd?$AA@ DB '%s[%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BMFKMGMG@xop?3Include?$AA@
CONST	SEGMENT
??_C@_0M@BMFKMGMG@xop?3Include?$AA@ DB 'xop:Include', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06ENEJBNNE@utf?98?$CK?$AA@
CONST	SEGMENT
??_C@_06ENEJBNNE@utf?98?$CK?$AA@ DB 'utf-8*', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KFPCELGH@latin1?$CK?$AA@
CONST	SEGMENT
??_C@_07KFPCELGH@latin1?$CK?$AA@ DB 'latin1*', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CIPLLKIK@iso?98859?91?$CK?$AA@
CONST	SEGMENT
??_C@_0M@CIPLLKIK@iso?98859?91?$CK?$AA@ DB 'iso-8859-1*', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GJNPICMJ@?5encoding?$DN?$AA@
CONST	SEGMENT
??_C@_0L@GJNPICMJ@?5encoding?$DN?$AA@ DB ' encoding=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04ONHKJKNE@xml?5?$AA@
CONST	SEGMENT
??_C@_04ONHKJKNE@xml?5?$AA@ DB 'xml ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBCJFAKL@apos?$AA@
CONST	SEGMENT
??_C@_04LBCJFAKL@apos?$AA@ DB 'apos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KJFGKBNM@quot?$AA@
CONST	SEGMENT
??_C@_04KJFGKBNM@quot?$AA@ DB 'quot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DCBBJBAA@amp?$AA@
CONST	SEGMENT
??_C@_03DCBBJBAA@amp?$AA@ DB 'amp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GHFEHLK@gt?$AA@
CONST	SEGMENT
??_C@_02GHFEHLK@gt?$AA@ DB 'gt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KCAKIFL@lt?$AA@
CONST	SEGMENT
??_C@_02KCAKIFL@lt?$AA@ DB 'lt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FCIFDIFE@?$AN?6?$CFlX?$AN?6?$AA@
CONST	SEGMENT
??_C@_07FCIFDIFE@?$AN?6?$CFlX?$AN?6?$AA@ DB 0dH, 0aH, '%lX', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JJJGGCEE@x?9token?$AA@
CONST	SEGMENT
??_C@_07JJJGGCEE@x?9token?$AA@ DB 'x-token', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EPBKNKII@ietf?9token?$AA@
CONST	SEGMENT
??_C@_0L@EPBKNKII@ietf?9token?$AA@ DB 'ietf-token', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JEFEFGEJ@base64?$AA@
CONST	SEGMENT
??_C@_06JEFEFGEJ@base64?$AA@ DB 'base64', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CAHAECFA@quoted?9printable?$AA@
CONST	SEGMENT
??_C@_0BB@CAHAECFA@quoted?9printable?$AA@ DB 'quoted-printable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FNFBAEBE@binary?$AA@
CONST	SEGMENT
??_C@_06FNFBAEBE@binary?$AA@ DB 'binary', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DFPGIIHA@8bit?$AA@
CONST	SEGMENT
??_C@_04DFPGIIHA@8bit?$AA@ DB '8bit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LHKGBPKB@7bit?$AA@
CONST	SEGMENT
??_C@_04LHKGBPKB@7bit?$AA@ DB '7bit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GBBFKFHI@HTTP?5Version?5not?5supported?$AA@
CONST	SEGMENT
??_C@_0BL@GBBFKFHI@HTTP?5Version?5not?5supported?$AA@ DB 'HTTP Version no'
	DB	't supported', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PHMOGCPC@Gateway?5Time?9out?$AA@
CONST	SEGMENT
??_C@_0BB@PHMOGCPC@Gateway?5Time?9out?$AA@ DB 'Gateway Time-out', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NGHLFKBN@Service?5Unavailable?$AA@
CONST	SEGMENT
??_C@_0BE@NGHLFKBN@Service?5Unavailable?$AA@ DB 'Service Unavailable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BNCNLPGM@Bad?5Gateway?$AA@
CONST	SEGMENT
??_C@_0M@BNCNLPGM@Bad?5Gateway?$AA@ DB 'Bad Gateway', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JGKGKAME@Not?5Implemented?$AA@
CONST	SEGMENT
??_C@_0BA@JGKGKAME@Not?5Implemented?$AA@ DB 'Not Implemented', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NJGANGCC@Internal?5Server?5Error?$AA@
CONST	SEGMENT
??_C@_0BG@NJGANGCC@Internal?5Server?5Error?$AA@ DB 'Internal Server Error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NDMHPAED@Expectation?5Failed?$AA@
CONST	SEGMENT
??_C@_0BD@NDMHPAED@Expectation?5Failed?$AA@ DB 'Expectation Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KGJNFKJM@Requested?5range?5not?5satisfiable?$AA@
CONST	SEGMENT
??_C@_0CA@KGJNFKJM@Requested?5range?5not?5satisfiable?$AA@ DB 'Requested '
	DB	'range not satisfiable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HLJJIAEN@Unsupported?5Media?5Type?$AA@
CONST	SEGMENT
??_C@_0BH@HLJJIAEN@Unsupported?5Media?5Type?$AA@ DB 'Unsupported Media Ty'
	DB	'pe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PMALKKB@Request?9URI?5Too?5Large?$AA@
CONST	SEGMENT
??_C@_0BG@PMALKKB@Request?9URI?5Too?5Large?$AA@ DB 'Request-URI Too Large'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MMEIEOIG@Request?5Entity?5Too?5Large?$AA@
CONST	SEGMENT
??_C@_0BJ@MMEIEOIG@Request?5Entity?5Too?5Large?$AA@ DB 'Request Entity To'
	DB	'o Large', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BBDBJOM@Precondition?5Failed?$AA@
CONST	SEGMENT
??_C@_0BE@BBDBJOM@Precondition?5Failed?$AA@ DB 'Precondition Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCKHPIPI@Length?5Required?$AA@
CONST	SEGMENT
??_C@_0BA@JCKHPIPI@Length?5Required?$AA@ DB 'Length Required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04OKIIBCCG@Gone?$AA@
CONST	SEGMENT
??_C@_04OKIIBCCG@Gone?$AA@ DB 'Gone', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OJCIFGDF@Conflict?$AA@
CONST	SEGMENT
??_C@_08OJCIFGDF@Conflict?$AA@ DB 'Conflict', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GKNJPEJG@Request?5Time?9out?$AA@
CONST	SEGMENT
??_C@_0BB@GKNJPEJG@Request?5Time?9out?$AA@ DB 'Request Time-out', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ONPAAOGI@Proxy?5Authentication?5Required?$AA@
CONST	SEGMENT
??_C@_0BO@ONPAAOGI@Proxy?5Authentication?5Required?$AA@ DB 'Proxy Authent'
	DB	'ication Required', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HHIDFAOI@Not?5Acceptable?$AA@
CONST	SEGMENT
??_C@_0P@HHIDFAOI@Not?5Acceptable?$AA@ DB 'Not Acceptable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CCIPIALO@Method?5Not?5Allowed?$AA@
CONST	SEGMENT
??_C@_0BD@CCIPIALO@Method?5Not?5Allowed?$AA@ DB 'Method Not Allowed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CFCBFJND@Not?5Found?$AA@
CONST	SEGMENT
??_C@_09CFCBFJND@Not?5Found?$AA@ DB 'Not Found', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LMDIMFJD@Forbidden?$AA@
CONST	SEGMENT
??_C@_09LMDIMFJD@Forbidden?$AA@ DB 'Forbidden', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LMPIHCBH@Payment?5Required?$AA@
CONST	SEGMENT
??_C@_0BB@LMPIHCBH@Payment?5Required?$AA@ DB 'Payment Required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OOAPMOJA@Unauthorized?$AA@
CONST	SEGMENT
??_C@_0N@OOAPMOJA@Unauthorized?$AA@ DB 'Unauthorized', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LNAIDEEG@Bad?5Request?$AA@
CONST	SEGMENT
??_C@_0M@LNAIDEEG@Bad?5Request?$AA@ DB 'Bad Request', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJMNAMDM@Temporary?5Redirect?$AA@
CONST	SEGMENT
??_C@_0BD@PJMNAMDM@Temporary?5Redirect?$AA@ DB 'Temporary Redirect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JFBGBFIM@Use?5Proxy?$AA@
CONST	SEGMENT
??_C@_09JFBGBFIM@Use?5Proxy?$AA@ DB 'Use Proxy', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IFEFAIJB@Not?5Modified?$AA@
CONST	SEGMENT
??_C@_0N@IFEFAIJB@Not?5Modified?$AA@ DB 'Not Modified', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FAMPMKIP@See?5Other?$AA@
CONST	SEGMENT
??_C@_09FAMPMKIP@See?5Other?$AA@ DB 'See Other', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JDGHEPJG@Found?$AA@
CONST	SEGMENT
??_C@_05JDGHEPJG@Found?$AA@ DB 'Found', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BPBCNFPI@Moved?5Permanently?$AA@
CONST	SEGMENT
??_C@_0BC@BPBCNFPI@Moved?5Permanently?$AA@ DB 'Moved Permanently', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HLFEHKPE@Multiple?5Choices?$AA@
CONST	SEGMENT
??_C@_0BB@HLFEHKPE@Multiple?5Choices?$AA@ DB 'Multiple Choices', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NNLNHGMN@Partial?5Content?$AA@
CONST	SEGMENT
??_C@_0BA@NNLNHGMN@Partial?5Content?$AA@ DB 'Partial Content', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BFFLKCLE@Reset?5Content?$AA@
CONST	SEGMENT
??_C@_0O@BFFLKCLE@Reset?5Content?$AA@ DB 'Reset Content', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FDPJCNGK@No?5Content?$AA@
CONST	SEGMENT
??_C@_0L@FDPJCNGK@No?5Content?$AA@ DB 'No Content', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NKBPKPBI@Non?9Authoritative?5Information?$AA@
CONST	SEGMENT
??_C@_0BO@NKBPKPBI@Non?9Authoritative?5Information?$AA@ DB 'Non-Authorita'
	DB	'tive Information', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DOBOODLA@Accepted?$AA@
CONST	SEGMENT
??_C@_08DOBOODLA@Accepted?$AA@ DB 'Accepted', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BBIDHECN@Created?$AA@
CONST	SEGMENT
??_C@_07BBIDHECN@Created?$AA@ DB 'Created', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GIPFHKNO@OK?$AA@
CONST	SEGMENT
??_C@_02GIPFHKNO@OK?$AA@ DB 'OK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GGLPAOMP@No?5Address?$AA@
CONST	SEGMENT
??_C@_0L@GGLPAOMP@No?5Address?$AA@ DB 'No Address', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NNGPDNPG@No?5Data?$AA@
CONST	SEGMENT
??_C@_07NNGPDNPG@No?5Data?$AA@ DB 'No Data', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IFLIHMFH@No?5Recovery?$AA@
CONST	SEGMENT
??_C@_0M@IFLIHMFH@No?5Recovery?$AA@ DB 'No Recovery', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NOIJLNLL@Try?5Again?$AA@
CONST	SEGMENT
??_C@_09NOIJLNLL@Try?5Again?$AA@ DB 'Try Again', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CAFMJNJH@Host?5not?5found?$AA@
CONST	SEGMENT
??_C@_0P@CAFMJNJH@Host?5not?5found?$AA@ DB 'Host not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BILJKGCK@yuml?$AA@
CONST	SEGMENT
??_C@_04BILJKGCK@yuml?$AA@ DB 'yuml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LIICDAEF@thorn?$AA@
CONST	SEGMENT
??_C@_05LIICDAEF@thorn?$AA@ DB 'thorn', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BBMKGLNL@yacute?$AA@
CONST	SEGMENT
??_C@_06BBMKGLNL@yacute?$AA@ DB 'yacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NNEJELCL@uuml?$AA@
CONST	SEGMENT
??_C@_04NNEJELCL@uuml?$AA@ DB 'uuml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JEMLPDGA@ucirc?$AA@
CONST	SEGMENT
??_C@_05JEMLPDGA@ucirc?$AA@ DB 'ucirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NGGKABKP@uacute?$AA@
CONST	SEGMENT
??_C@_06NGGKABKP@uacute?$AA@ DB 'uacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IBEMEICG@ugrave?$AA@
CONST	SEGMENT
??_C@_06IBEMEICG@ugrave?$AA@ DB 'ugrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LGBAFOGO@oslash?$AA@
CONST	SEGMENT
??_C@_06LGBAFOGO@oslash?$AA@ DB 'oslash', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFHJEHBN@divide?$AA@
CONST	SEGMENT
??_C@_06FFHJEHBN@divide?$AA@ DB 'divide', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PHBJMEAI@ouml?$AA@
CONST	SEGMENT
??_C@_04PHBJMEAI@ouml?$AA@ DB 'ouml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNFIPCMD@otilde?$AA@
CONST	SEGMENT
??_C@_06DNFIPCMD@otilde?$AA@ DB 'otilde', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DGIGNCJN@ocirc?$AA@
CONST	SEGMENT
??_C@_05DGIGNCJN@ocirc?$AA@ DB 'ocirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BFMEMCCP@oacute?$AA@
CONST	SEGMENT
??_C@_06BFMEMCCP@oacute?$AA@ DB 'oacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ECOCILKG@ograve?$AA@
CONST	SEGMENT
??_C@_06ECOCILKG@ograve?$AA@ DB 'ograve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JLCPPJHH@ntilde?$AA@
CONST	SEGMENT
??_C@_06JLCPPJHH@ntilde?$AA@ DB 'ntilde', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CMJPAGPB@eth?$AA@
CONST	SEGMENT
??_C@_03CMJPAGPB@eth?$AA@ DB 'eth', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HIFJDBKI@iuml?$AA@
CONST	SEGMENT
??_C@_04HIFJDBKI@iuml?$AA@ DB 'iuml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OANPDBIA@icirc?$AA@
CONST	SEGMENT
??_C@_05OANPDBIA@icirc?$AA@ DB 'icirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HGBEPHBF@iacute?$AA@
CONST	SEGMENT
??_C@_06HGBEPHBF@iacute?$AA@ DB 'iacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CBDCLOJM@igrave?$AA@
CONST	SEGMENT
??_C@_06CBDCLOJM@igrave?$AA@ DB 'igrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LNKJNMKJ@euml?$AA@
CONST	SEGMENT
??_C@_04LNKJNMKJ@euml?$AA@ DB 'euml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JHBNPBPL@ecirc?$AA@
CONST	SEGMENT
??_C@_05JHBNPBPL@ecirc?$AA@ DB 'ecirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LBLEJNGB@eacute?$AA@
CONST	SEGMENT
??_C@_06LBLEJNGB@eacute?$AA@ DB 'eacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OGJCNEOI@egrave?$AA@
CONST	SEGMENT
??_C@_06OGJCNEOI@egrave?$AA@ DB 'egrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNHFEHGA@ccedil?$AA@
CONST	SEGMENT
??_C@_06DNHFEHGA@ccedil?$AA@ DB 'ccedil', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAANDPOK@aelig?$AA@
CONST	SEGMENT
??_C@_05MAANDPOK@aelig?$AA@ DB 'aelig', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CAFMJCMP@aring?$AA@
CONST	SEGMENT
??_C@_05CAFMJCMP@aring?$AA@ DB 'aring', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EICJHKGJ@auml?$AA@
CONST	SEGMENT
??_C@_04EICJHKGJ@auml?$AA@ DB 'auml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GNGHIJJO@atilde?$AA@
CONST	SEGMENT
??_C@_06GNGHIJJO@atilde?$AA@ DB 'atilde', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIMLDON@acirc?$AA@
CONST	SEGMENT
??_C@_05MIMLDON@acirc?$AA@ DB 'acirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EFPLLJHC@aacute?$AA@
CONST	SEGMENT
??_C@_06EFPLLJHC@aacute?$AA@ DB 'aacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BCNNPAPL@agrave?$AA@
CONST	SEGMENT
??_C@_06BCNNPAPL@agrave?$AA@ DB 'agrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GMKDJMCJ@szlig?$AA@
CONST	SEGMENT
??_C@_05GMKDJMCJ@szlig?$AA@ DB 'szlig', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDBENHAL@THORN?$AA@
CONST	SEGMENT
??_C@_05HDBENHAL@THORN?$AA@ DB 'THORN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NOHHFCEH@Yacute?$AA@
CONST	SEGMENT
??_C@_06NOHHFCEH@Yacute?$AA@ DB 'Yacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BMIIGECP@Uuml?$AA@
CONST	SEGMENT
??_C@_04BMIIGECP@Uuml?$AA@ DB 'Uuml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JDGHPGFG@Ucirc?$AA@
CONST	SEGMENT
??_C@_05JDGHPGFG@Ucirc?$AA@ DB 'Ucirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BJNHDIDD@Uacute?$AA@
CONST	SEGMENT
??_C@_06BJNHDIDD@Uacute?$AA@ DB 'Uacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOPBHBLK@Ugrave?$AA@
CONST	SEGMENT
??_C@_06EOPBHBLK@Ugrave?$AA@ DB 'Ugrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HJKNGHPC@Oslash?$AA@
CONST	SEGMENT
??_C@_06HJKNGHPC@Oslash?$AA@ DB 'Oslash', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MJOOAIJH@times?$AA@
CONST	SEGMENT
??_C@_05MJOOAIJH@times?$AA@ DB 'times', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DGNIOLAM@Ouml?$AA@
CONST	SEGMENT
??_C@_04DGNIOLAM@Ouml?$AA@ DB 'Ouml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCOFMLFP@Otilde?$AA@
CONST	SEGMENT
??_C@_06PCOFMLFP@Otilde?$AA@ DB 'Otilde', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DBCKNHKL@Ocirc?$AA@
CONST	SEGMENT
??_C@_05DBCKNHKL@Ocirc?$AA@ DB 'Ocirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NKHJPLLD@Oacute?$AA@
CONST	SEGMENT
??_C@_06NKHJPLLD@Oacute?$AA@ DB 'Oacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06INFPLCDK@Ograve?$AA@
CONST	SEGMENT
??_C@_06INFPLCDK@Ograve?$AA@ DB 'Ograve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FEJCMAOL@Ntilde?$AA@
CONST	SEGMENT
??_C@_06FEJCMAOL@Ntilde?$AA@ DB 'Ntilde', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CBGEMLIN@ETH?$AA@
CONST	SEGMENT
??_C@_03CBGEMLIN@ETH?$AA@ DB 'ETH', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LJJIBOKM@Iuml?$AA@
CONST	SEGMENT
??_C@_04LJJIBOKM@Iuml?$AA@ DB 'Iuml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OHHDDELG@Icirc?$AA@
CONST	SEGMENT
??_C@_05OHHDDELG@Icirc?$AA@ DB 'Icirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LJKJMOIJ@Iacute?$AA@
CONST	SEGMENT
??_C@_06LJKJMOIJ@Iacute?$AA@ DB 'Iacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OOIPIHAA@Igrave?$AA@
CONST	SEGMENT
??_C@_06OOIPIHAA@Igrave?$AA@ DB 'Igrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HMGIPDKN@Euml?$AA@
CONST	SEGMENT
??_C@_04HMGIPDKN@Euml?$AA@ DB 'Euml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JALBPEMN@Ecirc?$AA@
CONST	SEGMENT
??_C@_05JALBPEMN@Ecirc?$AA@ DB 'Ecirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HOAJKEPN@Eacute?$AA@
CONST	SEGMENT
??_C@_06HOAJKEPN@Eacute?$AA@ DB 'Eacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CJCPONHE@Egrave?$AA@
CONST	SEGMENT
??_C@_06CJCPONHE@Egrave?$AA@ DB 'Egrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCMIHOPM@Ccedil?$AA@
CONST	SEGMENT
??_C@_06PCMIHOPM@Ccedil?$AA@ DB 'Ccedil', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GGABFNI@AElig?$AA@
CONST	SEGMENT
??_C@_05GGABFNI@AElig?$AA@ DB 'AElig', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CHPAJHPJ@Aring?$AA@
CONST	SEGMENT
??_C@_05CHPAJHPJ@Aring?$AA@ DB 'Aring', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IJOIFFGN@Auml?$AA@
CONST	SEGMENT
??_C@_04IJOIFFGN@Auml?$AA@ DB 'Auml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KCNKLAAC@Atilde?$AA@
CONST	SEGMENT
??_C@_06KCNKLAAC@Atilde?$AA@ DB 'Atilde', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LCALGNL@Acirc?$AA@
CONST	SEGMENT
??_C@_05LCALGNL@Acirc?$AA@ DB 'Acirc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKEGIAOO@Aacute?$AA@
CONST	SEGMENT
??_C@_06IKEGIAOO@Aacute?$AA@ DB 'Aacute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NNGAMJGH@Agrave?$AA@
CONST	SEGMENT
??_C@_06NNGAMJGH@Agrave?$AA@ DB 'Agrave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JMONPFKG@iquest?$AA@
CONST	SEGMENT
??_C@_06JMONPFKG@iquest?$AA@ DB 'iquest', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NMNJFLLK@frac34?$AA@
CONST	SEGMENT
??_C@_06NMNJFLLK@frac34?$AA@ DB 'frac34', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJAHCIFC@frac12?$AA@
CONST	SEGMENT
??_C@_06IJAHCIFC@frac12?$AA@ DB 'frac12', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NPFNIPNE@frac14?$AA@
CONST	SEGMENT
??_C@_06NPFNIPNE@frac14?$AA@ DB 'frac14', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPFJLGEB@raquo?$AA@
CONST	SEGMENT
??_C@_05MPFJLGEB@raquo?$AA@ DB 'raquo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HMAEPGHP@ordm?$AA@
CONST	SEGMENT
??_C@_04HMAEPGHP@ordm?$AA@ DB 'ordm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EJOCKNLB@sup1?$AA@
CONST	SEGMENT
??_C@_04EJOCKNLB@sup1?$AA@ DB 'sup1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KLIFGPMF@cedil?$AA@
CONST	SEGMENT
??_C@_05KLIFGPMF@cedil?$AA@ DB 'cedil', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HHCHNCAA@middot?$AA@
CONST	SEGMENT
??_C@_06HHCHNCAA@middot?$AA@ DB 'middot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GIAGJOJD@para?$AA@
CONST	SEGMENT
??_C@_04GIAGJOJD@para?$AA@ DB 'para', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PCPGMEFP@micro?$AA@
CONST	SEGMENT
??_C@_05PCPGMEFP@micro?$AA@ DB 'micro', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EEJEIAPO@acute?$AA@
CONST	SEGMENT
??_C@_05EEJEIAPO@acute?$AA@ DB 'acute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HLNEMPDD@sup3?$AA@
CONST	SEGMENT
??_C@_04HLNEMPDD@sup3?$AA@ DB 'sup3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GCMPPOHC@sup2?$AA@
CONST	SEGMENT
??_C@_04GCMPPOHC@sup2?$AA@ DB 'sup2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CAEEBBM@plusmn?$AA@
CONST	SEGMENT
??_C@_06CAEEBBM@plusmn?$AA@ DB 'plusmn', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFPLEBM@deg?$AA@
CONST	SEGMENT
??_C@_03OFPLEBM@deg?$AA@ DB 'deg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IMHNEFHF@macr?$AA@
CONST	SEGMENT
??_C@_04IMHNEFHF@macr?$AA@ DB 'macr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HLCNLMFP@reg?$AA@
CONST	SEGMENT
??_C@_03HLCNLMFP@reg?$AA@ DB 'reg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BPAIHHLG@shy?$AA@
CONST	SEGMENT
??_C@_03BPAIHHLG@shy?$AA@ DB 'shy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJKJADM@not?$AA@
CONST	SEGMENT
??_C@_03NJKJADM@not?$AA@ DB 'not', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PGIFNFKK@laquo?$AA@
CONST	SEGMENT
??_C@_05PGIFNFKK@laquo?$AA@ DB 'laquo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JPPACPLE@ordf?$AA@
CONST	SEGMENT
??_C@_04JPPACPLE@ordf?$AA@ DB 'ordf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LBNAMJF@uml?$AA@
CONST	SEGMENT
??_C@_03LBNAMJF@uml?$AA@ DB 'uml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IKJFFMEH@sect?$AA@
CONST	SEGMENT
??_C@_04IKJFFMEH@sect?$AA@ DB 'sect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ILPBEBAD@brvbar?$AA@
CONST	SEGMENT
??_C@_06ILPBEBAD@brvbar?$AA@ DB 'brvbar', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HNOOIABH@yen?$AA@
CONST	SEGMENT
??_C@_03HNOOIABH@yen?$AA@ DB 'yen', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06HEGEHONB@curren?$AA@
CONST	SEGMENT
??_C@_06HEGEHONB@curren?$AA@ DB 'curren', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EBEEKLCG@pound?$AA@
CONST	SEGMENT
??_C@_05EBEEKLCG@pound?$AA@ DB 'pound', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OCKNFIJG@cent?$AA@
CONST	SEGMENT
??_C@_04OCKNFIJG@cent?$AA@ DB 'cent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BNEGCBFC@iexcl?$AA@
CONST	SEGMENT
??_C@_05BNEGCBFC@iexcl?$AA@ DB 'iexcl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PHHIFBLJ@nbsp?$AA@
CONST	SEGMENT
??_C@_04PHHIFBLJ@nbsp?$AA@ DB 'nbsp', 00H		; `string'
_soap_env1 DB	'http://schemas.xmlsoap.org/soap/envelope/', 00H
	ORG $+2
_soap_enc1 DB	'http://schemas.xmlsoap.org/soap/encoding/', 00H
	ORG $+2
_soap_env2 DB	'http://www.w3.org/2003/05/soap-envelope', 00H
_soap_enc2 DB	'http://www.w3.org/2003/05/soap-encoding', 00H
_soap_rpc DB	'http://www.w3.org/2003/05/soap-rpc', 00H
	ORG $+1
_soap_double_nan DD 0ffffffffH
	DD	0ffffffffH
_soap_indent DB	0aH, 09H, 09H, 09H, 09H, 09H, 09H, 09H, 09H, 09H, 00H
	ORG $+1
_soap_base64o DB 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012'
	DB	'3456789+/', 00H
	ORG $+7
_soap_base64i DB '>XXX?456789:;<=XXXXXXX', 00H, 01H, 02H, 03H, 04H, 05H, 06H
	DB	07H, 08H, 09H, 0aH, 0bH, 0cH, 0dH, 0eH, 0fH, 010H, 011H, 012H, 013H
	DB	014H, 015H, 016H, 017H, 018H, 019H, 'XXXXXX', 01aH, 01bH, 01cH
	DB	01dH, 01eH, 01fH, ' !"#$%&''()*+,-./0123', 00H
	ORG $+3
_soap_padding DB 00H, 00H, 00H, 00H
_html_entity_codes DD 0a0H
	DD	FLAT:??_C@_04PHHIFBLJ@nbsp?$AA@
	DD	0a1H
	DD	FLAT:??_C@_05BNEGCBFC@iexcl?$AA@
	DD	0a2H
	DD	FLAT:??_C@_04OCKNFIJG@cent?$AA@
	DD	0a3H
	DD	FLAT:??_C@_05EBEEKLCG@pound?$AA@
	DD	0a4H
	DD	FLAT:??_C@_06HEGEHONB@curren?$AA@
	DD	0a5H
	DD	FLAT:??_C@_03HNOOIABH@yen?$AA@
	DD	0a6H
	DD	FLAT:??_C@_06ILPBEBAD@brvbar?$AA@
	DD	0a7H
	DD	FLAT:??_C@_04IKJFFMEH@sect?$AA@
	DD	0a8H
	DD	FLAT:??_C@_03LBNAMJF@uml?$AA@
	DD	0a9H
	DD	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DD	0aaH
	DD	FLAT:??_C@_04JPPACPLE@ordf?$AA@
	DD	0abH
	DD	FLAT:??_C@_05PGIFNFKK@laquo?$AA@
	DD	0acH
	DD	FLAT:??_C@_03NJKJADM@not?$AA@
	DD	0adH
	DD	FLAT:??_C@_03BPAIHHLG@shy?$AA@
	DD	0aeH
	DD	FLAT:??_C@_03HLCNLMFP@reg?$AA@
	DD	0afH
	DD	FLAT:??_C@_04IMHNEFHF@macr?$AA@
	DD	0b0H
	DD	FLAT:??_C@_03OFPLEBM@deg?$AA@
	DD	0b1H
	DD	FLAT:??_C@_06CAEEBBM@plusmn?$AA@
	DD	0b2H
	DD	FLAT:??_C@_04GCMPPOHC@sup2?$AA@
	DD	0b3H
	DD	FLAT:??_C@_04HLNEMPDD@sup3?$AA@
	DD	0b4H
	DD	FLAT:??_C@_05EEJEIAPO@acute?$AA@
	DD	0b5H
	DD	FLAT:??_C@_05PCPGMEFP@micro?$AA@
	DD	0b6H
	DD	FLAT:??_C@_04GIAGJOJD@para?$AA@
	DD	0b7H
	DD	FLAT:??_C@_06HHCHNCAA@middot?$AA@
	DD	0b8H
	DD	FLAT:??_C@_05KLIFGPMF@cedil?$AA@
	DD	0b9H
	DD	FLAT:??_C@_04EJOCKNLB@sup1?$AA@
	DD	0baH
	DD	FLAT:??_C@_04HMAEPGHP@ordm?$AA@
	DD	0bbH
	DD	FLAT:??_C@_05MPFJLGEB@raquo?$AA@
	DD	0bcH
	DD	FLAT:??_C@_06NPFNIPNE@frac14?$AA@
	DD	0bdH
	DD	FLAT:??_C@_06IJAHCIFC@frac12?$AA@
	DD	0beH
	DD	FLAT:??_C@_06NMNJFLLK@frac34?$AA@
	DD	0bfH
	DD	FLAT:??_C@_06JMONPFKG@iquest?$AA@
	DD	0c0H
	DD	FLAT:??_C@_06NNGAMJGH@Agrave?$AA@
	DD	0c1H
	DD	FLAT:??_C@_06IKEGIAOO@Aacute?$AA@
	DD	0c2H
	DD	FLAT:??_C@_05LCALGNL@Acirc?$AA@
	DD	0c3H
	DD	FLAT:??_C@_06KCNKLAAC@Atilde?$AA@
	DD	0c4H
	DD	FLAT:??_C@_04IJOIFFGN@Auml?$AA@
	DD	0c5H
	DD	FLAT:??_C@_05CHPAJHPJ@Aring?$AA@
	DD	0c6H
	DD	FLAT:??_C@_05GGABFNI@AElig?$AA@
	DD	0c7H
	DD	FLAT:??_C@_06PCMIHOPM@Ccedil?$AA@
	DD	0c8H
	DD	FLAT:??_C@_06CJCPONHE@Egrave?$AA@
	DD	0c9H
	DD	FLAT:??_C@_06HOAJKEPN@Eacute?$AA@
	DD	0caH
	DD	FLAT:??_C@_05JALBPEMN@Ecirc?$AA@
	DD	0cbH
	DD	FLAT:??_C@_04HMGIPDKN@Euml?$AA@
	DD	0ccH
	DD	FLAT:??_C@_06OOIPIHAA@Igrave?$AA@
	DD	0cdH
	DD	FLAT:??_C@_06LJKJMOIJ@Iacute?$AA@
	DD	0ceH
	DD	FLAT:??_C@_05OHHDDELG@Icirc?$AA@
	DD	0cfH
	DD	FLAT:??_C@_04LJJIBOKM@Iuml?$AA@
	DD	0d0H
	DD	FLAT:??_C@_03CBGEMLIN@ETH?$AA@
	DD	0d1H
	DD	FLAT:??_C@_06FEJCMAOL@Ntilde?$AA@
	DD	0d2H
	DD	FLAT:??_C@_06INFPLCDK@Ograve?$AA@
	DD	0d3H
	DD	FLAT:??_C@_06NKHJPLLD@Oacute?$AA@
	DD	0d4H
	DD	FLAT:??_C@_05DBCKNHKL@Ocirc?$AA@
	DD	0d5H
	DD	FLAT:??_C@_06PCOFMLFP@Otilde?$AA@
	DD	0d6H
	DD	FLAT:??_C@_04DGNIOLAM@Ouml?$AA@
	DD	0d7H
	DD	FLAT:??_C@_05MJOOAIJH@times?$AA@
	DD	0d8H
	DD	FLAT:??_C@_06HJKNGHPC@Oslash?$AA@
	DD	0d9H
	DD	FLAT:??_C@_06EOPBHBLK@Ugrave?$AA@
	DD	0daH
	DD	FLAT:??_C@_06BJNHDIDD@Uacute?$AA@
	DD	0dbH
	DD	FLAT:??_C@_05JDGHPGFG@Ucirc?$AA@
	DD	0dcH
	DD	FLAT:??_C@_04BMIIGECP@Uuml?$AA@
	DD	0ddH
	DD	FLAT:??_C@_06NOHHFCEH@Yacute?$AA@
	DD	0deH
	DD	FLAT:??_C@_05HDBENHAL@THORN?$AA@
	DD	0dfH
	DD	FLAT:??_C@_05GMKDJMCJ@szlig?$AA@
	DD	0e0H
	DD	FLAT:??_C@_06BCNNPAPL@agrave?$AA@
	DD	0e1H
	DD	FLAT:??_C@_06EFPLLJHC@aacute?$AA@
	DD	0e2H
	DD	FLAT:??_C@_05MIMLDON@acirc?$AA@
	DD	0e3H
	DD	FLAT:??_C@_06GNGHIJJO@atilde?$AA@
	DD	0e4H
	DD	FLAT:??_C@_04EICJHKGJ@auml?$AA@
	DD	0e5H
	DD	FLAT:??_C@_05CAFMJCMP@aring?$AA@
	DD	0e6H
	DD	FLAT:??_C@_05MAANDPOK@aelig?$AA@
	DD	0e7H
	DD	FLAT:??_C@_06DNHFEHGA@ccedil?$AA@
	DD	0e8H
	DD	FLAT:??_C@_06OGJCNEOI@egrave?$AA@
	DD	0e9H
	DD	FLAT:??_C@_06LBLEJNGB@eacute?$AA@
	DD	0eaH
	DD	FLAT:??_C@_05JHBNPBPL@ecirc?$AA@
	DD	0ebH
	DD	FLAT:??_C@_04LNKJNMKJ@euml?$AA@
	DD	0ecH
	DD	FLAT:??_C@_06CBDCLOJM@igrave?$AA@
	DD	0edH
	DD	FLAT:??_C@_06HGBEPHBF@iacute?$AA@
	DD	0eeH
	DD	FLAT:??_C@_05OANPDBIA@icirc?$AA@
	DD	0efH
	DD	FLAT:??_C@_04HIFJDBKI@iuml?$AA@
	DD	0f0H
	DD	FLAT:??_C@_03CMJPAGPB@eth?$AA@
	DD	0f1H
	DD	FLAT:??_C@_06JLCPPJHH@ntilde?$AA@
	DD	0f2H
	DD	FLAT:??_C@_06ECOCILKG@ograve?$AA@
	DD	0f3H
	DD	FLAT:??_C@_06BFMEMCCP@oacute?$AA@
	DD	0f4H
	DD	FLAT:??_C@_05DGIGNCJN@ocirc?$AA@
	DD	0f5H
	DD	FLAT:??_C@_06DNFIPCMD@otilde?$AA@
	DD	0f6H
	DD	FLAT:??_C@_04PHBJMEAI@ouml?$AA@
	DD	0f7H
	DD	FLAT:??_C@_06FFHJEHBN@divide?$AA@
	DD	0f8H
	DD	FLAT:??_C@_06LGBAFOGO@oslash?$AA@
	DD	0f9H
	DD	FLAT:??_C@_06IBEMEICG@ugrave?$AA@
	DD	0faH
	DD	FLAT:??_C@_06NGGKABKP@uacute?$AA@
	DD	0fbH
	DD	FLAT:??_C@_05JEMLPDGA@ucirc?$AA@
	DD	0fcH
	DD	FLAT:??_C@_04NNEJELCL@uuml?$AA@
	DD	0fdH
	DD	FLAT:??_C@_06BBMKGLNL@yacute?$AA@
	DD	0feH
	DD	FLAT:??_C@_05LIICDAEF@thorn?$AA@
	DD	0ffH
	DD	FLAT:??_C@_04BILJKGCK@yuml?$AA@
	DD	00H
	DD	00H
_h_error_codes DD 02af9H
	DD	FLAT:??_C@_0P@CAFMJNJH@Host?5not?5found?$AA@
	DD	02afaH
	DD	FLAT:??_C@_09NOIJLNLL@Try?5Again?$AA@
	DD	02afbH
	DD	FLAT:??_C@_0M@IFLIHMFH@No?5Recovery?$AA@
	DD	02afcH
	DD	FLAT:??_C@_07NNGPDNPG@No?5Data?$AA@
	DD	02afcH
	DD	FLAT:??_C@_0L@GGLPAOMP@No?5Address?$AA@
	DD	00H
	DD	00H
_h_http_error_codes DD 0c8H
	DD	FLAT:??_C@_02GIPFHKNO@OK?$AA@
	DD	0c9H
	DD	FLAT:??_C@_07BBIDHECN@Created?$AA@
	DD	0caH
	DD	FLAT:??_C@_08DOBOODLA@Accepted?$AA@
	DD	0cbH
	DD	FLAT:??_C@_0BO@NKBPKPBI@Non?9Authoritative?5Information?$AA@
	DD	0ccH
	DD	FLAT:??_C@_0L@FDPJCNGK@No?5Content?$AA@
	DD	0cdH
	DD	FLAT:??_C@_0O@BFFLKCLE@Reset?5Content?$AA@
	DD	0ceH
	DD	FLAT:??_C@_0BA@NNLNHGMN@Partial?5Content?$AA@
	DD	012cH
	DD	FLAT:??_C@_0BB@HLFEHKPE@Multiple?5Choices?$AA@
	DD	012dH
	DD	FLAT:??_C@_0BC@BPBCNFPI@Moved?5Permanently?$AA@
	DD	012eH
	DD	FLAT:??_C@_05JDGHEPJG@Found?$AA@
	DD	012fH
	DD	FLAT:??_C@_09FAMPMKIP@See?5Other?$AA@
	DD	0130H
	DD	FLAT:??_C@_0N@IFEFAIJB@Not?5Modified?$AA@
	DD	0131H
	DD	FLAT:??_C@_09JFBGBFIM@Use?5Proxy?$AA@
	DD	0133H
	DD	FLAT:??_C@_0BD@PJMNAMDM@Temporary?5Redirect?$AA@
	DD	0190H
	DD	FLAT:??_C@_0M@LNAIDEEG@Bad?5Request?$AA@
	DD	0191H
	DD	FLAT:??_C@_0N@OOAPMOJA@Unauthorized?$AA@
	DD	0192H
	DD	FLAT:??_C@_0BB@LMPIHCBH@Payment?5Required?$AA@
	DD	0193H
	DD	FLAT:??_C@_09LMDIMFJD@Forbidden?$AA@
	DD	0194H
	DD	FLAT:??_C@_09CFCBFJND@Not?5Found?$AA@
	DD	0195H
	DD	FLAT:??_C@_0BD@CCIPIALO@Method?5Not?5Allowed?$AA@
	DD	0196H
	DD	FLAT:??_C@_0P@HHIDFAOI@Not?5Acceptable?$AA@
	DD	0197H
	DD	FLAT:??_C@_0BO@ONPAAOGI@Proxy?5Authentication?5Required?$AA@
	DD	0198H
	DD	FLAT:??_C@_0BB@GKNJPEJG@Request?5Time?9out?$AA@
	DD	0199H
	DD	FLAT:??_C@_08OJCIFGDF@Conflict?$AA@
	DD	019aH
	DD	FLAT:??_C@_04OKIIBCCG@Gone?$AA@
	DD	019bH
	DD	FLAT:??_C@_0BA@JCKHPIPI@Length?5Required?$AA@
	DD	019cH
	DD	FLAT:??_C@_0BE@BBDBJOM@Precondition?5Failed?$AA@
	DD	019dH
	DD	FLAT:??_C@_0BJ@MMEIEOIG@Request?5Entity?5Too?5Large?$AA@
	DD	019eH
	DD	FLAT:??_C@_0BG@PMALKKB@Request?9URI?5Too?5Large?$AA@
	DD	019fH
	DD	FLAT:??_C@_0BH@HLJJIAEN@Unsupported?5Media?5Type?$AA@
	DD	01a0H
	DD	FLAT:??_C@_0CA@KGJNFKJM@Requested?5range?5not?5satisfiable?$AA@
	DD	01a1H
	DD	FLAT:??_C@_0BD@NDMHPAED@Expectation?5Failed?$AA@
	DD	01f4H
	DD	FLAT:??_C@_0BG@NJGANGCC@Internal?5Server?5Error?$AA@
	DD	01f5H
	DD	FLAT:??_C@_0BA@JGKGKAME@Not?5Implemented?$AA@
	DD	01f6H
	DD	FLAT:??_C@_0M@BNCNLPGM@Bad?5Gateway?$AA@
	DD	01f7H
	DD	FLAT:??_C@_0BE@NGHLFKBN@Service?5Unavailable?$AA@
	DD	01f8H
	DD	FLAT:??_C@_0BB@PHMOGCPC@Gateway?5Time?9out?$AA@
	DD	01f9H
	DD	FLAT:??_C@_0BL@GBBFKFHI@HTTP?5Version?5not?5supported?$AA@
	DD	00H
	DD	00H
_mime_codes DD	01H
	DD	FLAT:??_C@_04LHKGBPKB@7bit?$AA@
	DD	02H
	DD	FLAT:??_C@_04DFPGIIHA@8bit?$AA@
	DD	03H
	DD	FLAT:??_C@_06FNFBAEBE@binary?$AA@
	DD	04H
	DD	FLAT:??_C@_0BB@CAHAECFA@quoted?9printable?$AA@
	DD	05H
	DD	FLAT:??_C@_06JEFEFGEJ@base64?$AA@
	DD	06H
	DD	FLAT:??_C@_0L@EPBKNKII@ietf?9token?$AA@
	DD	07H
	DD	FLAT:??_C@_07JJJGGCEE@x?9token?$AA@
	DD	00H
	DD	00H
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
;	COMDAT ?_Sgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPADIH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Sgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPADIH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Sgetn_s, COMDAT
; _this$ = ecx
; __Count$ = edx

; 117  : 		return _Xsgetn_s(_Ptr, _Ptr_size, _Count);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+28]
	push	edx
	mov	edx, DWORD PTR __Ptr$[esp]
	push	-1
	push	edx
	call	eax

; 118  : 		}

	ret	4
?_Sgetn_s@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPADIH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Sgetn_s
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\istream
_TEXT	ENDS
;	COMDAT ?gcount@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEHXZ
_TEXT	SEGMENT
?gcount@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEHXZ PROC ; std::basic_istream<char,std::char_traits<char> >::gcount, COMDAT
; _this$ = eax

; 791  : 		return (_Chcount);

	mov	eax, DWORD PTR [eax+4]

; 792  : 		}

	ret	0
?gcount@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEHXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::gcount
_TEXT	ENDS
PUBLIC	_soap_lookup_plugin
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\stdsoap2.cpp
_TEXT	SEGMENT
_soap_lookup_plugin PROC
; _soap$ = eax
; _id$ = ecx

; 14839: { return soap->fplugin(soap, id);

	mov	edx, DWORD PTR [eax+12332]
	push	ecx
	push	eax
	call	edx
	add	esp, 8

; 14840: }

	ret	0
_soap_lookup_plugin ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_fplugin PROC

; 14826:   for (p = soap->plugins; p; p = p->next)

	mov	eax, DWORD PTR _soap$[esp-4]
	push	esi
	mov	esi, DWORD PTR [eax+12220]
	push	edi
	test	esi, esi
	je	SHORT $LN3@fplugin
	mov	edi, DWORD PTR _id$[esp+4]
$LL5@fplugin:

; 14827:     if (p->id == id || !strcmp(p->id, id))

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@fplugin
	mov	ecx, edi
	npad	3
$LL11@fplugin:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN12@fplugin
	test	dl, dl
	je	SHORT $LN13@fplugin
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN12@fplugin
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL11@fplugin
$LN13@fplugin:
	xor	eax, eax
	jmp	SHORT $LN14@fplugin
$LN12@fplugin:
	sbb	eax, eax
	sbb	eax, -1
$LN14@fplugin:
	test	eax, eax
	je	SHORT $LN9@fplugin
	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL5@fplugin
$LN3@fplugin:
	pop	edi

; 14829:   return NULL;

	xor	eax, eax
	pop	esi

; 14830: }

	ret	0
$LN9@fplugin:

; 14828:       return p->data;

	mov	eax, DWORD PTR [esi+8]
	pop	edi
	pop	esi

; 14830: }

	ret	0
_fplugin ENDP
_TEXT	ENDS
PUBLIC	_soap_register_plugin_arg
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_fcreate$ = 12						; size = 4
_arg$ = 16						; size = 4
_soap_register_plugin_arg PROC

; 14800: { register struct soap_plugin *p;

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+4]
	push	esi

; 14801:   register int r;
; 14802:   if (!(p = (struct soap_plugin*)SOAP_MALLOC(soap, sizeof(struct soap_plugin))))

	push	20					; 00000014H
	call	_malloc
	mov	esi, eax
	xor	ebx, ebx
	add	esp, 4
	cmp	esi, ebx
	jne	SHORT $LN2@soap_regis
	pop	esi

; 14803:     return soap->error = SOAP_EOM;

	mov	DWORD PTR [ebp+90460], 20		; 00000014H
	pop	ebp
	lea	eax, DWORD PTR [ebx+20]
	pop	ebx

; 14818: }

	ret	0
$LN2@soap_regis:

; 14804:   p->id = NULL;
; 14805:   p->data = NULL;
; 14806:   p->fcopy = NULL;
; 14807:   p->fdelete = NULL;
; 14808:   r = fcreate(soap, p, arg);

	mov	eax, DWORD PTR _arg$[esp+8]
	push	edi
	push	eax
	push	esi
	push	ebp
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+16], ebx
	call	DWORD PTR _fcreate$[esp+24]
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 14809:   if (!r && p->fdelete)

	cmp	edi, ebx
	jne	SHORT $LN1@soap_regis
	cmp	DWORD PTR [esi+16], ebx
	je	SHORT $LN1@soap_regis

; 14810:   { p->next = soap->plugins;

	mov	ecx, DWORD PTR [ebp+12220]
	pop	edi
	mov	DWORD PTR [esi], ecx

; 14811:     soap->plugins = p;

	mov	DWORD PTR [ebp+12220], esi
	pop	esi
	pop	ebp

; 14812:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Registered '%s' plugin\n", p->id));
; 14813:     return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 14818: }

	ret	0
$LN1@soap_regis:

; 14814:   }
; 14815:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not register plugin '%s': plugin returned error %d (or fdelete callback not set)\n", p->id?p->id:"?", r));
; 14816:   SOAP_FREE(soap, p);

	push	esi
	call	_free
	add	esp, 4

; 14817:   return r;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 14818: }

	ret	0
_soap_register_plugin_arg ENDP
_TEXT	ENDS
PUBLIC	_soap_print_fault_location
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_c2$ = -4						; size = 4
_fd$ = 8						; size = 4
_soap_print_fault_location PROC
; _soap$ = esi

; 14768: {

	push	ecx

; 14769: #ifndef WITH_LEAN
; 14770:   int i, j, c1, c2;
; 14771:   if (soap->error && soap->bufidx <= soap->buflen && soap->buflen > 0 && soap->buflen <= SOAP_BUFLEN)

	xor	edx, edx
	cmp	DWORD PTR [esi+90460], edx
	je	$LN5@soap_print
	mov	ecx, DWORD PTR [esi+12428]
	mov	eax, DWORD PTR [esi+12432]
	cmp	ecx, eax
	ja	$LN5@soap_print
	cmp	eax, edx
	jbe	$LN5@soap_print
	cmp	eax, 65536				; 00010000H
	ja	$LN5@soap_print
	push	ebx
	push	ebp
	push	edi

; 14772:   { i = (int)soap->bufidx - 1;

	lea	edi, DWORD PTR [ecx-1]

; 14773:     if (i <= 0)

	cmp	edi, edx

; 14774:       i = 0;

	cmovle	edi, edx

; 14775:     c1 = soap->buf[i];

	movsx	ebx, BYTE PTR [edi+esi+12468]

; 14776:     soap->buf[i] = '\0';

	mov	BYTE PTR [edi+esi+12468], dl

; 14777:     if ((int)soap->buflen >= i + 1024)

	mov	eax, DWORD PTR [esi+12432]
	lea	ecx, DWORD PTR [edi+1024]
	cmp	eax, ecx

; 14778:       j = i + 1023;

	lea	ebp, DWORD PTR [edi+1023]
	jge	SHORT $LN2@soap_print

; 14779:     else
; 14780:       j = (int)soap->buflen - 1;

	lea	ebp, DWORD PTR [eax-1]
$LN2@soap_print:

; 14781:     c2 = soap->buf[j];

	movsx	eax, BYTE PTR [esi+ebp+12468]

; 14782:     soap->buf[j] = '\0';
; 14783:     fprintf(fd, "%s%c\n<!-- ** HERE ** -->\n", soap->buf, c1);

	push	ebx
	lea	ecx, DWORD PTR [esi+12468]
	push	ecx
	mov	BYTE PTR [esi+ebp+12468], dl
	mov	edx, DWORD PTR _fd$[esp+20]
	push	OFFSET ??_C@_0BK@GONPECDN@?$CFs?$CFc?6?$DM?$CB?9?9?5?$CK?$CK?5HERE?5?$CK?$CK?5?9?9?$DO?6?$AA@
	push	edx
	mov	DWORD PTR _c2$[esp+32], eax
	call	_fprintf

; 14784:     if (soap->bufidx < soap->buflen)

	mov	eax, DWORD PTR [esi+12428]
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR [esi+12432]
	jae	SHORT $LN1@soap_print

; 14785:       fprintf(fd, "%s\n", soap->buf + soap->bufidx);

	mov	ecx, DWORD PTR _fd$[esp+12]
	lea	eax, DWORD PTR [eax+esi+12468]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN1@soap_print:

; 14786:     soap->buf[i] = c1;
; 14787:     soap->buf[j] = c2;

	mov	dl, BYTE PTR _c2$[esp+16]
	mov	BYTE PTR [edi+esi+12468], bl
	pop	edi
	mov	BYTE PTR [esi+ebp+12468], dl
	pop	ebp
	pop	ebx
$LN5@soap_print:

; 14788:   }
; 14789: #endif
; 14790: }

	pop	ecx
	ret	0
_soap_print_fault_location ENDP
; Function compile flags: /Ogtpy
_soap_strerror PROC
; _soap$ = eax

; 14540: { register int err = soap->errnum;

	mov	ecx, DWORD PTR [eax+90468]
	push	esi

; 14541:   if (err)

	test	ecx, ecx
	je	SHORT $LN4@soap_strer

; 14542:   {
; 14543: #ifndef WIN32
; 14544:     return strerror(err);
; 14545: #else
; 14546: #ifndef UNDER_CE
; 14547:     DWORD len;
; 14548:     *soap->msgbuf = '\0';
; 14549:     len = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)soap->msgbuf, (DWORD)sizeof(soap->msgbuf), NULL);

	push	0
	push	1024					; 00000400H
	lea	esi, DWORD PTR [eax+78004]
	push	esi
	push	1024					; 00000400H
	push	ecx
	push	0
	push	4608					; 00001200H
	mov	BYTE PTR [esi], 0
	call	DWORD PTR __imp__FormatMessageA@28

; 14550: #else
; 14551:     DWORD i, len;
; 14552:     *soap->msgbuf = '\0';
; 14553:     len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, err, 0, (LPTSTR)soap->msgbuf, (DWORD)(sizeof(soap->msgbuf)/sizeof(TCHAR)), NULL);
; 14554:     for (i = 0; i <= len; i++)
; 14555:     { if (((TCHAR*)soap->msgbuf)[i] < 0x80)
; 14556:         soap->msgbuf[i] = (char)((TCHAR*)soap->msgbuf)[i];
; 14557:       else
; 14558:         soap->msgbuf[i] = '?';
; 14559:     }
; 14560: #endif
; 14561:     return soap->msgbuf;

	mov	eax, esi
	pop	esi

; 14574: }

	ret	0
$LN4@soap_strer:

; 14562: #endif
; 14563:   }
; 14564: #ifndef WITH_LEAN
; 14565:   if (soap->recv_timeout > 0)

	mov	ecx, DWORD PTR [eax+48]
	test	ecx, ecx
	jle	SHORT $LN3@soap_strer

; 14566:   { if (soap->send_timeout > 0)

	mov	edx, DWORD PTR [eax+52]

; 14567:       sprintf(soap->msgbuf, "Operation interrupted or timed out after %ds send or %ds receive delay", soap->send_timeout, soap->recv_timeout);

	lea	esi, DWORD PTR [eax+78004]
	push	ecx
	test	edx, edx
	jle	SHORT $LN2@soap_strer
	push	edx
	push	OFFSET ??_C@_0EH@OEKCJEEM@Operation?5interrupted?5or?5timed?5o@
	push	esi
	call	_sprintf
	add	esp, 16					; 00000010H

; 14570:     return soap->msgbuf;

	mov	eax, esi
	pop	esi

; 14574: }

	ret	0
$LN2@soap_strer:

; 14568:     else
; 14569:       sprintf(soap->msgbuf, "Operation interrupted or timed out after %ds receive delay", soap->recv_timeout);

	push	OFFSET ??_C@_0DL@HBKFNCEG@Operation?5interrupted?5or?5timed?5o@
	push	esi
	call	_sprintf
	add	esp, 12					; 0000000cH

; 14570:     return soap->msgbuf;

	mov	eax, esi
	pop	esi

; 14574: }

	ret	0
$LN3@soap_strer:

; 14571:   }
; 14572: #endif
; 14573:   return "Operation interrupted or timed out";

	mov	eax, OFFSET ??_C@_0CD@EBMJBALC@Operation?5interrupted?5or?5timed?5o@
	pop	esi

; 14574: }

	ret	0
_soap_strerror ENDP
; Function compile flags: /Ogtpy
_soap_set_validation_fault PROC
; _soap$ = ecx
; _s$ = edi
; _t$ = edx

; 14174: { if (*soap->tag)

	cmp	BYTE PTR [ecx+80052], 0
	lea	eax, DWORD PTR [ecx+80052]
	push	esi
	je	SHORT $LN2@soap_set_v

; 14175:     sprintf(soap->msgbuf, "Validation constraint violation: %s%s in element <%s>", s, t?t:SOAP_STR_EOS, soap->tag);

	test	edx, edx
	jne	SHORT $LN6@soap_set_v
	mov	edx, OFFSET _soap_padding
$LN6@soap_set_v:
	push	eax
	push	edx
	push	edi
	lea	esi, DWORD PTR [ecx+78004]
	push	OFFSET ??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 20					; 00000014H

; 14178:   return soap->msgbuf;

	mov	eax, esi
	pop	esi

; 14179: }

	ret	0
$LN2@soap_set_v:

; 14176:   else
; 14177:     sprintf(soap->msgbuf, "Validation constraint violation: %s%s", s, t?t:SOAP_STR_EOS);

	test	edx, edx
	jne	SHORT $LN8@soap_set_v
	mov	edx, OFFSET _soap_padding
$LN8@soap_set_v:
	push	edx
	push	edi
	lea	esi, DWORD PTR [ecx+78004]
	push	OFFSET ??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 16					; 00000010H

; 14178:   return soap->msgbuf;

	mov	eax, esi
	pop	esi

; 14179: }

	ret	0
_soap_set_validation_fault ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_http_head PROC

; 13932: { return SOAP_HEAD_METHOD;

	mov	eax, 18					; 00000012H

; 13933: }

	ret	0
_http_head ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_http_del PROC

; 13922: { return SOAP_DEL_METHOD;

	mov	eax, 17					; 00000011H

; 13923: }

	ret	0
_http_del ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_http_put PROC

; 13912: { return SOAP_PUT_METHOD;

	mov	eax, 16					; 00000010H

; 13913: }

	ret	0
_http_put ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_http_get PROC

; 13902: { return SOAP_GET_METHOD;

	mov	eax, 15					; 0000000fH

; 13903: }

	ret	0
_http_get ENDP
_TEXT	ENDS
PUBLIC	_soap_puthttphdr
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_r$84002 = -4						; size = 4
_err$84001 = 8						; size = 4
_soap$ = 8						; size = 4
_count$ = 12						; size = 4
_soap_puthttphdr PROC
; _status$ = eax

; 13823: { if (soap->status != SOAP_GET)

	push	ecx
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+4]
	cmp	DWORD PTR [ebp+90456], 2001		; 000007d1H
	push	esi
	push	edi
	je	$LN41@soap_putht

; 13824:   { register const char *s = "text/xml; charset=utf-8";
; 13825:     register int err = SOAP_OK;

	xor	esi, esi
	mov	edi, OFFSET ??_C@_0BI@JFLEALON@text?1xml?$DL?5charset?$DNutf?98?$AA@
	mov	DWORD PTR _err$84001[esp+12], esi

; 13826: #ifndef WITH_LEANER
; 13827:     register const char *r = NULL;

	mov	DWORD PTR _r$84002[esp+16], esi

; 13828: #endif
; 13829:     if (status == SOAP_FILE && soap->http_content)

	cmp	eax, 1003				; 000003ebH
	jne	SHORT $LN20@soap_putht
	mov	eax, DWORD PTR [ebp+36]
	cmp	eax, esi
	je	SHORT $LN18@soap_putht

; 13830:       s = soap->http_content;

	mov	edi, eax
	jmp	SHORT $LN14@soap_putht
$LN20@soap_putht:

; 13831:     else if (status == SOAP_HTML)

	cmp	eax, 1002				; 000003eaH
	jne	SHORT $LN18@soap_putht

; 13832:       s = "text/html; charset=utf-8";

	mov	edi, OFFSET ??_C@_0BJ@CDMHJEKP@text?1html?$DL?5charset?$DNutf?98?$AA@
	jmp	SHORT $LN14@soap_putht
$LN18@soap_putht:

; 13833:     else if (count || ((soap->omode & SOAP_IO) == SOAP_IO_CHUNK))

	cmp	DWORD PTR _count$[esp+12], esi
	jne	SHORT $LN40@soap_putht
	mov	eax, DWORD PTR [ebp+16]
	and	eax, 3
	cmp	al, 3
	jne	SHORT $LN14@soap_putht
$LN40@soap_putht:

; 13834:     { if (soap->version == 2)

	cmp	WORD PTR [ebp+6], 2
	jne	SHORT $LN14@soap_putht

; 13835:         s = "application/soap+xml; charset=utf-8";

	mov	edi, OFFSET ??_C@_0CE@HOOLIGFB@application?1soap?$CLxml?$DL?5charset?$DNut@
$LN14@soap_putht:

; 13836:     }
; 13837: #ifndef WITH_LEANER
; 13838:     if (soap->mode & (SOAP_ENC_DIME | SOAP_ENC_MTOM))

	mov	eax, DWORD PTR [ebp+8]
	test	eax, 640				; 00000280H
	je	SHORT $LN11@soap_putht

; 13839:     { if (soap->mode & SOAP_ENC_MTOM)

	test	eax, 512				; 00000200H
	je	SHORT $LN12@soap_putht

; 13840:       { r = s;

	mov	DWORD PTR _r$84002[esp+16], edi

; 13841:         s = "application/xop+xml; charset=utf-8";

	mov	edi, OFFSET ??_C@_0CD@GGDEJPLO@application?1xop?$CLxml?$DL?5charset?$DNutf@

; 13842:       }
; 13843:       else

	jmp	SHORT $LN11@soap_putht
$LN12@soap_putht:

; 13844:         s = "application/dime";

	mov	edi, OFFSET ??_C@_0BB@KDHCEMMM@application?1dime?$AA@
$LN11@soap_putht:

; 13845:     }
; 13846:     if ((soap->mode & SOAP_ENC_MIME) && soap->mime.boundary && strlen(soap->mime.boundary) + strlen(soap->mime.start ? soap->mime.start : SOAP_STR_EOS) < sizeof(soap->tmpbuf) - 80)

	test	eax, 256				; 00000100H
	je	$LN10@soap_putht
	mov	eax, DWORD PTR [ebp+90524]
	cmp	eax, esi
	je	$LN10@soap_putht
	lea	edx, DWORD PTR [eax+1]
$LL28@soap_putht:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL28@soap_putht
	mov	ecx, DWORD PTR [ebp+90528]
	sub	eax, edx
	cmp	ecx, esi
	jne	SHORT $LN25@soap_putht
	mov	ecx, OFFSET _soap_padding
$LN25@soap_putht:
	lea	esi, DWORD PTR [ecx+1]
	npad	5
$LL29@soap_putht:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL29@soap_putht
	sub	ecx, esi
	add	ecx, eax
	cmp	ecx, 944				; 000003b0H
	jae	$LN10@soap_putht
	push	ebx

; 13847:     { register const char *t = strchr(s, ';');

	push	59					; 0000003bH
	push	edi
	call	_strchr

; 13848:       sprintf(soap->tmpbuf, "multipart/related; boundary=\"%s\"; type=\"", soap->mime.boundary);

	mov	ecx, DWORD PTR [ebp+90524]
	push	ecx
	lea	ebx, DWORD PTR [ebp+79028]
	push	OFFSET ??_C@_0CJ@HGDIJJKJ@multipart?1related?$DL?5boundary?$DN?$CC?$CFs?$CC@
	push	ebx
	mov	esi, eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 13849:       if (t)

	test	esi, esi
	je	SHORT $LN9@soap_putht

; 13850:         strncat(soap->tmpbuf, s, t - s);

	sub	esi, edi
	push	esi
	push	edi
	push	ebx
	call	_strncat
	add	esp, 12					; 0000000cH

; 13851:       else

	jmp	SHORT $LN8@soap_putht
$LN9@soap_putht:

; 13852:         strcat(soap->tmpbuf, s);

	mov	eax, edi
	mov	ecx, edi
$LL30@soap_putht:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL30@soap_putht
	mov	edi, ebx
	sub	eax, ecx
	mov	esi, ecx
	dec	edi
$LL31@soap_putht:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL31@soap_putht
	mov	ecx, eax
	shr	ecx, 2
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb
$LN8@soap_putht:

; 13853:       if (soap->mime.start)

	cmp	DWORD PTR [ebp+90528], 0
	je	SHORT $LN7@soap_putht

; 13854:       { strcat(soap->tmpbuf, "\"; start=\"");

	mov	eax, ebx
	dec	eax
$LL32@soap_putht:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL32@soap_putht
	mov	edx, DWORD PTR ??_C@_0L@ENHEIJFK@?$CC?$DL?5start?$DN?$CC?$AA@
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR ??_C@_0L@ENHEIJFK@?$CC?$DL?5start?$DN?$CC?$AA@+4
	mov	DWORD PTR [eax+4], ecx
	mov	dx, WORD PTR ??_C@_0L@ENHEIJFK@?$CC?$DL?5start?$DN?$CC?$AA@+8
	mov	WORD PTR [eax+8], dx
	mov	cl, BYTE PTR ??_C@_0L@ENHEIJFK@?$CC?$DL?5start?$DN?$CC?$AA@+10
	mov	BYTE PTR [eax+10], cl

; 13855:         strcat(soap->tmpbuf, soap->mime.start);

	mov	eax, DWORD PTR [ebp+90528]
	mov	ecx, eax
	npad	7
$LL33@soap_putht:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL33@soap_putht
	mov	edi, ebx
	sub	eax, ecx
	mov	esi, ecx
	dec	edi
	npad	2
$LL34@soap_putht:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL34@soap_putht
	mov	ecx, eax
	shr	ecx, 2
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb
$LN7@soap_putht:

; 13856:       }
; 13857:       strcat(soap->tmpbuf, "\"");

	mov	edi, ebx
	dec	edi
	npad	7
$LL35@soap_putht:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL35@soap_putht

; 13858:       if (r)

	mov	esi, DWORD PTR _r$84002[esp+20]
	mov	dx, WORD PTR ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	WORD PTR [edi], dx
	test	esi, esi
	je	$LN6@soap_putht

; 13859:       { strcat(soap->tmpbuf, "; start-info=\"");

	mov	eax, ebx
	dec	eax
$LL36@soap_putht:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL36@soap_putht
	mov	ecx, DWORD PTR ??_C@_0P@KJFFOCGK@?$DL?5start?9info?$DN?$CC?$AA@
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ??_C@_0P@KJFFOCGK@?$DL?5start?9info?$DN?$CC?$AA@+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ??_C@_0P@KJFFOCGK@?$DL?5start?9info?$DN?$CC?$AA@+8
	mov	DWORD PTR [eax+8], ecx
	mov	dx, WORD PTR ??_C@_0P@KJFFOCGK@?$DL?5start?9info?$DN?$CC?$AA@+12
	mov	WORD PTR [eax+12], dx
	mov	cl, BYTE PTR ??_C@_0P@KJFFOCGK@?$DL?5start?9info?$DN?$CC?$AA@+14
	mov	BYTE PTR [eax+14], cl

; 13860:         strcat(soap->tmpbuf, r);

	mov	eax, esi
	mov	ecx, esi
	npad	5
$LL37@soap_putht:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL37@soap_putht
	mov	edi, ebx
	sub	eax, ecx
	mov	esi, ecx
	dec	edi
	npad	2
$LL38@soap_putht:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL38@soap_putht
	mov	ecx, eax
	shr	ecx, 2
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb

; 13861:         strcat(soap->tmpbuf, "\"");

	mov	edi, ebx
	dec	edi
	npad	7
$LL39@soap_putht:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL39@soap_putht
	mov	dx, WORD PTR ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	WORD PTR [edi], dx
$LN6@soap_putht:

; 13862:       }
; 13863:       s = soap->tmpbuf;

	mov	edi, ebx
	pop	ebx
$LN10@soap_putht:

; 13864:     }
; 13865: #endif
; 13866:     if (s && (err = soap->fposthdr(soap, "Content-Type", s)))

	test	edi, edi
	je	SHORT $LN42@soap_putht
	mov	eax, DWORD PTR [ebp+12256]
	push	edi
	push	OFFSET ??_C@_0N@LAFFMKKA@Content?9Type?$AA@
	push	ebp
	call	eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _err$84001[esp+12], eax
	test	eax, eax
	je	SHORT $LN42@soap_putht
	pop	edi
	pop	esi
	pop	ebp

; 13893: }

	pop	ecx
	ret	0
$LN42@soap_putht:

; 13867:       return err;
; 13868: #ifdef WITH_ZLIB
; 13869:     if (soap->omode & SOAP_ENC_ZLIB)
; 13870:     {
; 13871: #ifdef WITH_GZIP
; 13872:       err = soap->fposthdr(soap, "Content-Encoding", soap->zlib_out == SOAP_ZLIB_DEFLATE ? "deflate" : "gzip");
; 13873: #else
; 13874:       err = soap->fposthdr(soap, "Content-Encoding", "deflate");
; 13875: #endif
; 13876:       if (err)
; 13877:         return err;
; 13878:     }
; 13879: #endif
; 13880: #ifndef WITH_LEANER
; 13881:     if ((soap->omode & SOAP_IO) == SOAP_IO_CHUNK)

	mov	ecx, DWORD PTR [ebp+16]
	and	ecx, 3
	cmp	cl, 3
	jne	SHORT $LN4@soap_putht

; 13882:       err = soap->fposthdr(soap, "Transfer-Encoding", "chunked");

	mov	edx, DWORD PTR [ebp+12256]
	push	OFFSET ??_C@_07KCKHAHHI@chunked?$AA@
	push	OFFSET ??_C@_0BC@ELHLFCNH@Transfer?9Encoding?$AA@
	push	ebp
	call	edx
	add	esp, 12					; 0000000cH

; 13883:     else

	jmp	SHORT $LN43@soap_putht
$LN4@soap_putht:

; 13884: #endif
; 13885:     if (s)

	test	edi, edi
	je	SHORT $LN2@soap_putht

; 13886:     { sprintf(soap->tmpbuf, "%lu", (unsigned long)count);

	mov	eax, DWORD PTR _count$[esp+12]
	push	eax
	lea	esi, DWORD PTR [ebp+79028]
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu?$AA@
	push	esi
	call	_sprintf

; 13887:       err = soap->fposthdr(soap, "Content-Length", soap->tmpbuf);

	mov	ecx, DWORD PTR [ebp+12256]
	push	esi
	push	OFFSET ??_C@_0P@HOJGPHBA@Content?9Length?$AA@
	push	ebp
	call	ecx
	add	esp, 24					; 00000018H
$LN43@soap_putht:
	mov	DWORD PTR _err$84001[esp+12], eax
$LN2@soap_putht:

; 13888:     }
; 13889:     if (err)

	mov	eax, DWORD PTR _err$84001[esp+12]
	test	eax, eax

; 13890:       return err;

	jne	SHORT $LN22@soap_putht
$LN41@soap_putht:

; 13891:   }
; 13892:   return soap->fposthdr(soap, "Connection", soap->keep_alive ? "keep-alive" : "close");

	cmp	WORD PTR [ebp+90412], 0
	mov	eax, OFFSET ??_C@_0L@FFDPOIEG@keep?9alive?$AA@
	jne	SHORT $LN27@soap_putht
	mov	eax, OFFSET ??_C@_05LBOHBHFK@close?$AA@
$LN27@soap_putht:
	mov	edx, DWORD PTR [ebp+12256]
	push	eax
	push	OFFSET ??_C@_0L@PJJKMLL@Connection?$AA@
	push	ebp
	call	edx
	add	esp, 12					; 0000000cH
$LN22@soap_putht:
	pop	edi
	pop	esi
	pop	ebp

; 13893: }

	pop	ecx
	ret	0
_soap_puthttphdr ENDP
_TEXT	ENDS
PUBLIC	_soap_set_endpoint
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_set_endpoint PROC
; _endpoint$ = eax

; 13483: { register const char *s;

	push	ebp
	mov	ebp, DWORD PTR _soap$[esp]
	push	esi
	mov	esi, eax

; 13484:   register size_t i, n;
; 13485:   soap->endpoint[0] = '\0';

	lea	eax, DWORD PTR [ebp+87320]
	mov	BYTE PTR [eax], 0

; 13486:   soap->host[0] = '\0';

	mov	BYTE PTR [ebp+89368], 0

; 13487:   soap->path[0] = '/';

	mov	BYTE PTR [ebp+88344], 47		; 0000002fH

; 13488:   soap->path[1] = '\0';

	mov	BYTE PTR [ebp+88345], 0

; 13489:   soap->port = 80;

	mov	DWORD PTR [ebp+90408], 80		; 00000050H

; 13490:   if (!endpoint || !*endpoint)

	test	esi, esi
	je	$LN15@soap_set_e
	cmp	BYTE PTR [esi], 0
	je	$LN15@soap_set_e
	push	edi

; 13491:     return;
; 13492: #ifdef WITH_OPENSSL
; 13493:   if (!soap_tag_cmp(endpoint, "https:*"))
; 13494:     soap->port = 443;
; 13495: #endif
; 13496:   strncpy(soap->endpoint, endpoint, sizeof(soap->endpoint) - 1);

	push	1023					; 000003ffH
	push	esi
	push	eax
	call	_strncpy

; 13497:   soap->endpoint[sizeof(soap->endpoint) - 1] = '\0';
; 13498:   s = strchr(endpoint, ':');

	push	58					; 0000003aH
	push	esi
	mov	BYTE PTR [ebp+88343], 0
	call	_strchr
	mov	edi, eax
	add	esp, 20					; 00000014H

; 13499:   if (s && s[1] == '/' && s[2] == '/')

	test	edi, edi
	je	SHORT $LN14@soap_set_e
	cmp	BYTE PTR [edi+1], 47			; 0000002fH
	jne	SHORT $LN14@soap_set_e
	cmp	BYTE PTR [edi+2], 47			; 0000002fH
	jne	SHORT $LN14@soap_set_e

; 13500:     s += 3;

	add	edi, 3

; 13501:   else

	jmp	SHORT $LN13@soap_set_e
$LN14@soap_set_e:

; 13502:     s = endpoint;

	mov	edi, esi
$LN13@soap_set_e:

; 13503:   n = strlen(s);

	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL25@soap_set_e:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL25@soap_set_e
	sub	eax, edx
	push	ebx
	mov	ebx, eax

; 13504:   if (n >= sizeof(soap->host))

	cmp	ebx, 1024				; 00000400H
	jb	SHORT $LN12@soap_set_e

; 13505:     n = sizeof(soap->host) - 1;

	mov	ebx, 1023				; 000003ffH
$LN12@soap_set_e:

; 13506: #ifdef WITH_IPV6
; 13507:   if (s[0] == '[')
; 13508:   { s++;
; 13509:     for (i = 0; i < n; i++)
; 13510:     { if (s[i] == ']')
; 13511:       { s++;
; 13512:         --n;
; 13513:         break;
; 13514:       }
; 13515:       soap->host[i] = s[i];
; 13516:     }
; 13517:   }
; 13518:   else
; 13519:   { for (i = 0; i < n; i++)
; 13520:     { soap->host[i] = s[i];
; 13521:       if (s[i] == '/' || s[i] == ':')
; 13522:         break;
; 13523:     }
; 13524:   }
; 13525: #else
; 13526:   for (i = 0; i < n; i++)

	xor	esi, esi
	test	ebx, ebx
	jbe	SHORT $LN21@soap_set_e
	npad	1
$LL11@soap_set_e:

; 13527:   { soap->host[i] = s[i];

	mov	al, BYTE PTR [esi+edi]
	mov	BYTE PTR [esi+ebp+89368], al

; 13528:     if (s[i] == '/' || s[i] == ':')

	cmp	BYTE PTR [esi+edi], 47			; 0000002fH
	je	SHORT $LN21@soap_set_e
	cmp	BYTE PTR [esi+edi], 58			; 0000003aH
	je	SHORT $LN21@soap_set_e
	inc	esi
	cmp	esi, ebx
	jb	SHORT $LL11@soap_set_e
$LN21@soap_set_e:

; 13529:       break;
; 13530:   }
; 13531: #endif
; 13532:   soap->host[i] = '\0';

	mov	BYTE PTR [esi+ebp+89368], 0

; 13533:   if (s[i] == ':')

	cmp	BYTE PTR [esi+edi], 58			; 0000003aH
	jne	SHORT $LN26@soap_set_e

; 13534:   { soap->port = (int)atol(s + i + 1);

	lea	ecx, DWORD PTR [esi+edi+1]
	push	ecx
	call	_atol

; 13535:     for (i++; i < n; i++)

	inc	esi
	add	esp, 4
	mov	DWORD PTR [ebp+90408], eax
	cmp	esi, ebx
	jae	SHORT $LN28@soap_set_e
$LL5@soap_set_e:

; 13536:       if (s[i] == '/')

	cmp	BYTE PTR [esi+edi], 47			; 0000002fH
	je	SHORT $LN26@soap_set_e
	inc	esi
	cmp	esi, ebx
	jb	SHORT $LL5@soap_set_e
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 13542:   }
; 13543: }

	ret	0
$LN26@soap_set_e:

; 13537:         break;
; 13538:   }
; 13539:   if (i < n && s[i])

	cmp	esi, ebx
	jae	SHORT $LN28@soap_set_e
	add	esi, edi
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN28@soap_set_e

; 13540:   { strncpy(soap->path, s + i, sizeof(soap->path));

	push	1024					; 00000400H
	lea	eax, DWORD PTR [ebp+88344]
	push	esi
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 13541:     soap->path[sizeof(soap->path) - 1] = '\0';

	mov	BYTE PTR [ebp+89367], 0
$LN28@soap_set_e:
	pop	ebx
	pop	edi
$LN15@soap_set_e:
	pop	esi
	pop	ebp

; 13542:   }
; 13543: }

	ret	0
_soap_set_endpoint ENDP
; Function compile flags: /Ogtpy
_sep$ = 8						; size = 4
_soap_decode PROC
; _buf$ = ecx
; _val$ = eax

; 13238: { const char *s;

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _sep$[esp+4]
	push	esi
	mov	esi, eax

; 13239:   char *t = buf;
; 13240:   for (s = val; *s; s++)

	cmp	BYTE PTR [esi], 0
	push	edi
	mov	ebx, 1024				; 00000400H
	mov	edi, ecx
	je	SHORT $LN26@soap_decod
$LL15@soap_decod:

; 13241:     if (*s != ' ' && *s != '\t' && !strchr(sep, *s))

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN14@soap_decod
	cmp	al, 9
	je	SHORT $LN14@soap_decod
	movsx	eax, al
	push	eax
	push	ebp
	call	_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@soap_decod
$LN14@soap_decod:

; 13239:   char *t = buf;
; 13240:   for (s = val; *s; s++)

	inc	esi
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LL15@soap_decod
$LN26@soap_decod:

; 13242:       break;
; 13243:   if (*s == '"')

	mov	al, BYTE PTR [esi]
	cmp	al, 34					; 00000022H
	jne	SHORT $LN24@soap_decod

; 13244:   { s++;
; 13245:     while (*s && *s != '"' && --len)

	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	je	$LN6@soap_decod
	npad	7
$LL10@soap_decod:
	cmp	al, 34					; 00000022H
	je	$LN6@soap_decod
	sub	ebx, 1
	je	SHORT $LN6@soap_decod

; 13246:       *t++ = *s++;

	inc	esi
	mov	BYTE PTR [edi], al
	mov	al, BYTE PTR [esi]
	inc	edi
	test	al, al
	jne	SHORT $LL10@soap_decod

; 13247:   }
; 13248:   else

	jmp	SHORT $LN6@soap_decod
$LN24@soap_decod:

; 13249:   { while (*s && !soap_blank(*s) && !strchr(sep, *s) && --len)

	test	al, al
	je	SHORT $LN6@soap_decod
$LN32@soap_decod:
	jl	SHORT $LN5@soap_decod
	cmp	al, 32					; 00000020H
	jle	SHORT $LN6@soap_decod
$LN5@soap_decod:
	movsx	ecx, al
	push	ecx
	push	ebp
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@soap_decod
	sub	ebx, 1
	je	SHORT $LN6@soap_decod

; 13250:     { if (*s == '%')

	mov	al, BYTE PTR [esi]
	cmp	al, 37					; 00000025H
	jne	SHORT $LN4@soap_decod

; 13251:       { *t++ = ((s[1] >= 'A' ? (s[1] & 0x7) + 9 : s[1] - '0') << 4)
; 13252:               + (s[2] >= 'A' ? (s[2] & 0x7) + 9 : s[2] - '0');

	mov	al, BYTE PTR [esi+1]
	cmp	al, 65					; 00000041H
	movsx	eax, al
	jl	SHORT $LN18@soap_decod
	and	eax, 7
	add	eax, 9
	jmp	SHORT $LN19@soap_decod
$LN18@soap_decod:
	sub	eax, 48					; 00000030H
$LN19@soap_decod:
	mov	cl, BYTE PTR [esi+2]
	cmp	cl, 65					; 00000041H
	movsx	ecx, cl
	jl	SHORT $LN20@soap_decod
	and	ecx, 7
	add	ecx, 9
	shl	al, 4
	add	al, cl
	mov	BYTE PTR [edi], al
	inc	edi

; 13253:         s += 3;

	add	esi, 3

; 13254:       }
; 13255:       else

	jmp	SHORT $LN3@soap_decod
$LN20@soap_decod:

; 13251:       { *t++ = ((s[1] >= 'A' ? (s[1] & 0x7) + 9 : s[1] - '0') << 4)
; 13252:               + (s[2] >= 'A' ? (s[2] & 0x7) + 9 : s[2] - '0');

	sub	ecx, 48					; 00000030H
	shl	al, 4
	add	al, cl
	mov	BYTE PTR [edi], al
	inc	edi

; 13253:         s += 3;

	add	esi, 3

; 13254:       }
; 13255:       else

	jmp	SHORT $LN3@soap_decod
$LN4@soap_decod:

; 13256:         *t++ = *s++;

	mov	BYTE PTR [edi], al
	inc	edi
	inc	esi
$LN3@soap_decod:
	mov	al, BYTE PTR [esi]
	test	al, al
	jne	SHORT $LN32@soap_decod
$LN6@soap_decod:

; 13257:     }
; 13258:   }
; 13259:   *t = '\0';

	mov	BYTE PTR [edi], 0

; 13260:   while (*s && !strchr(sep, *s))

	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN31@soap_decod
$LL2@soap_decod:
	movsx	edx, al
	push	edx
	push	ebp
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN31@soap_decod
	mov	al, BYTE PTR [esi+1]

; 13261:     s++;

	inc	esi
	test	al, al
	jne	SHORT $LL2@soap_decod
$LN31@soap_decod:
	pop	edi

; 13262:   return s;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 13263: }

	ret	0
_soap_decode ENDP
_TEXT	ENDS
PUBLIC	_soap_decode_val
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_decode_val PROC
; _buf$ = ecx
; _val$ = eax

; 13224: { if (*val != '=')

	cmp	BYTE PTR [eax], 61			; 0000003dH
	je	SHORT $LN1@soap_decod@2

; 13225:   { *buf = '\0';

	mov	BYTE PTR [ecx], 0

; 13229: }

	ret	0
$LN1@soap_decod@2:

; 13226:     return val;
; 13227:   }
; 13228:   return soap_decode(buf, len, val + 1, ",;");

	push	OFFSET ??_C@_02NFLHGFB@?0?$DL?$AA@
	inc	eax
	call	_soap_decode
	add	esp, 4

; 13229: }

	ret	0
_soap_decode_val ENDP
_TEXT	ENDS
PUBLIC	_soap_decode_key
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_decode_key PROC
; _buf$ = ecx
; _val$ = eax

; 13212: { return soap_decode(buf, len, val, "=,;");

	push	OFFSET ??_C@_03NBBPFACD@?$DN?0?$DL?$AA@
	call	_soap_decode
	add	esp, 4

; 13213: }

	ret	0
_soap_decode_key ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_soap_valid_mime_boundary PROC

; 11949:   register size_t k;
; 11950:   if (soap->fmimeread)

	mov	edx, DWORD PTR _soap$[esp-4]
	cmp	DWORD PTR [edx+12396], 0
	je	SHORT $LN9@soap_valid

; 11951:     return SOAP_OK;

	xor	eax, eax

; 11964: }

	ret	0
$LN9@soap_valid:
	push	esi

; 11952:   k = strlen(soap->mime.boundary);

	mov	esi, DWORD PTR [edx+90524]
	lea	ecx, DWORD PTR [esi+1]
	npad	6
$LL17@soap_valid:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL17@soap_valid
	push	ebx
	push	ebp

; 11953:   for (content = soap->mime.first; content; content = content->next)

	mov	ebp, DWORD PTR [edx+90536]
	sub	esi, ecx
	push	edi
	test	ebp, ebp
	je	SHORT $LN6@soap_valid
$LL8@soap_valid:

; 11954:   { if (content->ptr && content->size >= k)

	mov	ebx, DWORD PTR [ebp+4]
	test	ebx, ebx
	je	SHORT $LN7@soap_valid
	mov	eax, DWORD PTR [ebp+8]
	cmp	eax, esi
	jb	SHORT $LN7@soap_valid

; 11955:     { register const char *p = (const char*)content->ptr;
; 11956:       register size_t i;
; 11957:       for (i = 0; i < content->size - k; i++, p++)

	xor	edi, edi
	sub	eax, esi
	je	SHORT $LN7@soap_valid
	npad	6
$LL18@soap_valid:

; 11958:       { if (!strncmp(p, soap->mime.boundary, k))

	mov	eax, DWORD PTR _soap$[esp+12]
	mov	ecx, DWORD PTR [eax+90524]
	push	esi
	push	ecx
	push	ebx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN14@soap_valid
	mov	edx, DWORD PTR [ebp+8]
	inc	edi
	sub	edx, esi
	inc	ebx
	cmp	edi, edx
	jb	SHORT $LL18@soap_valid
$LN7@soap_valid:

; 11953:   for (content = soap->mime.first; content; content = content->next)

	mov	ebp, DWORD PTR [ebp]
	test	ebp, ebp
	jne	SHORT $LL8@soap_valid
$LN6@soap_valid:
	pop	edi
	pop	ebp
	pop	ebx

; 11960:       }
; 11961:     }
; 11962:   }
; 11963:   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 11964: }

	ret	0
$LN14@soap_valid:
	pop	edi
	pop	ebp
	pop	ebx

; 11959:           return SOAP_ERR;

	or	eax, -1
	pop	esi

; 11964: }

	ret	0
_soap_valid_mime_boundary ENDP
_TEXT	ENDS
PUBLIC	_soap_next_multipart
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_next_multipart PROC
; _content$ = eax

; 11905: { if (content)

	test	eax, eax
	je	SHORT $LN1@soap_next_

; 11906:     return content->next;

	mov	eax, DWORD PTR [eax]

; 11908: }

	ret	0
$LN1@soap_next_:

; 11907:   return NULL;

	xor	eax, eax

; 11908: }

	ret	0
_soap_next_multipart ENDP
_TEXT	ENDS
PUBLIC	_soap_clr_mime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_clr_mime PROC
; _soap$ = eax

; 11823: { soap->omode &= ~SOAP_ENC_MIME;

	and	DWORD PTR [eax+16], -257		; fffffeffH

; 11824:   soap->mime.first = NULL;

	xor	ecx, ecx
	mov	DWORD PTR [eax+90536], ecx

; 11825:   soap->mime.last = NULL;

	mov	DWORD PTR [eax+90540], ecx

; 11826:   soap->mime.boundary = NULL;

	mov	DWORD PTR [eax+90524], ecx

; 11827:   soap->mime.start = NULL;

	mov	DWORD PTR [eax+90528], ecx

; 11828: }

	ret	0
_soap_clr_mime ENDP
_TEXT	ENDS
PUBLIC	_soap_clr_dime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_clr_dime PROC
; _soap$ = eax

; 11809: { soap->omode &= ~SOAP_ENC_DIME;

	and	DWORD PTR [eax+16], -129		; ffffff7fH

; 11810:   soap->dime.first = NULL;

	xor	ecx, ecx
	mov	DWORD PTR [eax+90516], ecx

; 11811:   soap->dime.last = NULL;

	mov	DWORD PTR [eax+90520], ecx

; 11812: }

	ret	0
_soap_clr_dime ENDP
_TEXT	ENDS
PUBLIC	_soap_set_dime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_set_dime PROC
; _soap$ = eax

; 11779: { soap->omode |= SOAP_ENC_DIME;

	or	DWORD PTR [eax+16], 128			; 00000080H

; 11780:   soap->dime.first = NULL;

	xor	ecx, ecx
	mov	DWORD PTR [eax+90516], ecx

; 11781:   soap->dime.last = NULL;

	mov	DWORD PTR [eax+90520], ecx

; 11782: }

	ret	0
_soap_set_dime ENDP
_TEXT	ENDS
PUBLIC	_soap_match_cid
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_t$ = 16						; size = 4
_soap_match_cid PROC

; 11627: { register size_t n;

	push	ebx
	mov	ebx, DWORD PTR _t$[esp]
	push	ebp
	mov	ebp, DWORD PTR _s$[esp+4]

; 11628:   if (!s)

	test	ebp, ebp
	jne	SHORT $LN6@soap_match

; 11629:     return 1;

	lea	eax, DWORD PTR [ebp+1]
	pop	ebp
	pop	ebx

; 11645: }

	ret	0
$LN6@soap_match:

; 11630:   if (!strcmp(s, t))

	mov	ecx, ebx
	mov	eax, ebp
$LL9@soap_match:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN10@soap_match
	test	dl, dl
	je	SHORT $LN11@soap_match
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN10@soap_match
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL9@soap_match
$LN11@soap_match:
	xor	eax, eax
	jmp	SHORT $LN12@soap_match
$LN10@soap_match:
	sbb	eax, eax
	sbb	eax, -1
$LN12@soap_match:
	test	eax, eax
	jne	SHORT $LN5@soap_match
	pop	ebp
	pop	ebx

; 11645: }

	ret	0
$LN5@soap_match:

; 11631:     return 0;
; 11632:   if (!strncmp(s, "cid:", 4))

	push	4
	push	OFFSET ??_C@_04MLBGAAHD@cid?3?$AA@
	push	ebp
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@soap_match

; 11633:     s += 4;

	add	ebp, 4
$LN4@soap_match:

; 11634:   n = strlen(t);

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL13@soap_match:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL13@soap_match
	sub	eax, edx

; 11635:   if (*t == '<')

	cmp	BYTE PTR [ebx], 60			; 0000003cH
	push	esi
	mov	esi, eax
	jne	SHORT $LN3@soap_match

; 11636:   { t++;

	inc	ebx

; 11637:     n -= 2;

	sub	esi, 2
$LN3@soap_match:

; 11638:   }
; 11639:   if (!strncmp(s, t, n) && !s[n])

	push	esi
	push	ebx
	push	ebp
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@soap_match
	cmp	BYTE PTR [esi+ebp], al

; 11640:     return 0;

	je	SHORT $LN15@soap_match
$LN2@soap_match:
	push	edi

; 11641:   soap_decode(soap->tmpbuf, sizeof(soap->tmpbuf), s, SOAP_STR_EOS);

	mov	edi, DWORD PTR _soap$[esp+12]
	add	edi, 79028				; 000134b4H
	push	OFFSET _soap_padding
	mov	eax, ebp
	mov	ecx, edi
	call	_soap_decode

; 11642:   if (!strncmp(soap->tmpbuf, t, n) && !soap->tmpbuf[n])

	push	esi
	push	ebx
	push	edi
	call	_strncmp
	add	esp, 16					; 00000010H
	pop	edi
	test	eax, eax
	jne	SHORT $LN1@soap_match
	mov	eax, DWORD PTR _soap$[esp+8]
	cmp	BYTE PTR [esi+eax+79028], 0
	jne	SHORT $LN1@soap_match
$LN15@soap_match:
	pop	esi
	pop	ebp

; 11643:     return 0;

	xor	eax, eax
	pop	ebx

; 11645: }

	ret	0
$LN1@soap_match:
	pop	esi
	pop	ebp

; 11644:   return 1;

	mov	eax, 1
	pop	ebx

; 11645: }

	ret	0
_soap_match_cid ENDP
_TEXT	ENDS
PUBLIC	_soap_post_check_mime_attachments
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_post_check_mime_attachments PROC
; _soap$ = eax

; 11487: { soap->imode |= SOAP_MIME_POSTCHECK;

	or	DWORD PTR [eax+12], 268435456		; 10000000H

; 11488: }

	ret	0
_soap_post_check_mime_attachments ENDP
_TEXT	ENDS
PUBLIC	_soap_get_mime_attachment
PUBLIC	_soap_getmime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_getmime PROC
; _soap$ = esi

; 11473: { while (soap_get_mime_attachment(soap, NULL))

$LL2@soap_getmi:
	push	0
	push	esi
	call	_soap_get_mime_attachment
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL2@soap_getmi

; 11474:     ;
; 11475:   return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 11476: }

	ret	0
_soap_getmime ENDP
_TEXT	ENDS
PUBLIC	_soap_s2ULONG64
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_s2ULONG64 PROC
; _soap$ = esi
; _s$ = eax
; _p$ = ecx

; 10089: { if (s)

	test	eax, eax
	je	SHORT $LN6@soap_s2ULO

; 10090:   {
; 10091: #ifdef HAVE_STRTOULL
; 10092:     char *r;
; 10093: #ifndef WITH_NOIO
; 10094: #ifndef WITH_LEAN
; 10095:     soap_reset_errno;
; 10096: #endif
; 10097: #endif
; 10098:     *p = strtoull(s, &r, 10);
; 10099:     if ((s == r && (soap->mode & SOAP_XML_STRICT)) || *r
; 10100: #ifndef WITH_NOIO
; 10101: #ifndef WITH_LEAN
; 10102:        || soap_errno == SOAP_ERANGE
; 10103: #endif
; 10104: #endif
; 10105:      )
; 10106: #else
; 10107: #ifdef HAVE_SSCANF
; 10108:     if (sscanf(s, SOAP_ULONG_FORMAT, p) != 1)

	push	ecx
	push	OFFSET ??_C@_05OINFJHGD@?$CFI64u?$AA@
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN6@soap_s2ULO

; 10109: #endif
; 10110: #endif
; 10111:       soap->error = SOAP_TYPE;

	mov	DWORD PTR [esi+90460], 4
$LN6@soap_s2ULO:

; 10112:   }
; 10113:   return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 10114: }

	ret	0
_soap_s2ULONG64 ENDP
_TEXT	ENDS
PUBLIC	_soap_ULONG642s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_n$ = 8							; size = 8
_soap_ULONG642s PROC
; _soap$ = eax

; 10065: { sprintf(soap->tmpbuf, SOAP_ULONG_FORMAT, n);

	mov	ecx, DWORD PTR _n$[esp-4]
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR _n$[esp+4]
	push	eax
	push	ecx
	add	esi, 79028				; 000134b4H
	push	OFFSET ??_C@_05OINFJHGD@?$CFI64u?$AA@
	push	esi
	call	_sprintf
	add	esp, 16					; 00000010H

; 10066:   return soap->tmpbuf;

	mov	eax, esi
	pop	esi

; 10067: }

	ret	0
_soap_ULONG642s ENDP
_TEXT	ENDS
PUBLIC	_soap_s2unsignedLong
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_r$82328 = -4						; size = 4
_p$ = 8							; size = 4
_soap_s2unsignedLong PROC
; _soap$ = edi
; _s$ = esi

; 10006: { if (s)

	push	ecx
	test	esi, esi
	je	SHORT $LN8@soap_s2uns

; 10007:   { char *r;
; 10008: #ifndef WITH_NOIO
; 10009: #ifndef WITH_LEAN
; 10010:     soap_reset_errno;

	push	0
	call	DWORD PTR __imp__SetLastError@4

; 10011: #endif
; 10012: #endif
; 10013:     *p = soap_strtoul(s, &r, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$82328[esp+8]
	push	eax
	push	esi
	call	_strtoul
	mov	ecx, DWORD PTR _p$[esp+12]
	mov	DWORD PTR [ecx], eax

; 10014:     if ((s == r && (soap->mode & SOAP_XML_STRICT)) || *r
; 10015: #ifndef WITH_NOIO
; 10016: #ifndef WITH_LEAN
; 10017:      || soap_errno == SOAP_ERANGE
; 10018: #endif
; 10019: #endif
; 10020:    )

	mov	eax, DWORD PTR _r$82328[esp+16]
	add	esp, 12					; 0000000cH
	cmp	esi, eax
	jne	SHORT $LN1@soap_s2uns
	test	DWORD PTR [edi+8], 4096			; 00001000H
	jne	SHORT $LN2@soap_s2uns
$LN1@soap_s2uns:
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@soap_s2uns
	call	DWORD PTR __imp__GetLastError@0
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN8@soap_s2uns
$LN2@soap_s2uns:

; 10021:       soap->error = SOAP_TYPE;

	mov	DWORD PTR [edi+90460], 4
$LN8@soap_s2uns:

; 10022:   }
; 10023:   return soap->error;

	mov	eax, DWORD PTR [edi+90460]

; 10024: }

	pop	ecx
	ret	0
_soap_s2unsignedLong ENDP
_TEXT	ENDS
PUBLIC	_soap_unsignedLong2s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_unsignedLong2s PROC
; _soap$ = ecx
; _n$ = eax

; 9982 : { sprintf(soap->tmpbuf, "%lu", n);

	push	esi
	push	eax
	mov	esi, ecx
	add	esi, 79028				; 000134b4H
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu?$AA@
	push	esi
	call	_sprintf
	add	esp, 12					; 0000000cH

; 9983 :   return soap->tmpbuf;

	mov	eax, esi
	pop	esi

; 9984 : }

	ret	0
_soap_unsignedLong2s ENDP
_TEXT	ENDS
PUBLIC	_soap_s2unsignedInt
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_r$82284 = -4						; size = 4
_p$ = 8							; size = 4
_soap_s2unsignedInt PROC
; _soap$ = edi
; _s$ = esi

; 9923 : { if (s)

	push	ecx
	test	esi, esi
	je	SHORT $LN8@soap_s2uns@2

; 9924 :   { char *r;
; 9925 : #ifndef WITH_NOIO
; 9926 : #ifndef WITH_LEAN
; 9927 :     soap_reset_errno;

	push	0
	call	DWORD PTR __imp__SetLastError@4

; 9928 : #endif
; 9929 : #endif
; 9930 :     *p = (unsigned int)soap_strtoul(s, &r, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$82284[esp+8]
	push	eax
	push	esi
	call	_strtoul
	mov	ecx, DWORD PTR _p$[esp+12]
	mov	DWORD PTR [ecx], eax

; 9931 :     if ((s == r && (soap->mode & SOAP_XML_STRICT)) || *r
; 9932 : #ifndef WITH_NOIO
; 9933 : #ifndef WITH_LEAN
; 9934 :      || soap_errno == SOAP_ERANGE
; 9935 : #endif
; 9936 : #endif
; 9937 :    )

	mov	eax, DWORD PTR _r$82284[esp+16]
	add	esp, 12					; 0000000cH
	cmp	esi, eax
	jne	SHORT $LN1@soap_s2uns@2
	test	DWORD PTR [edi+8], 4096			; 00001000H
	jne	SHORT $LN2@soap_s2uns@2
$LN1@soap_s2uns@2:
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@soap_s2uns@2
	call	DWORD PTR __imp__GetLastError@0
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN8@soap_s2uns@2
$LN2@soap_s2uns@2:

; 9938 :       soap->error = SOAP_TYPE;

	mov	DWORD PTR [edi+90460], 4
$LN8@soap_s2uns@2:

; 9939 :   }
; 9940 :   return soap->error;

	mov	eax, DWORD PTR [edi+90460]

; 9941 : }

	pop	ecx
	ret	0
_soap_s2unsignedInt ENDP
_TEXT	ENDS
PUBLIC	_soap_unsignedInt2s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_unsignedInt2s PROC
; _soap$ = ecx
; _n$ = eax

; 9900 : { return soap_unsignedLong2s(soap, (unsigned long)n);

	push	esi
	push	eax
	mov	esi, ecx
	add	esi, 79028				; 000134b4H
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu?$AA@
	push	esi
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi

; 9901 : }

	ret	0
_soap_unsignedInt2s ENDP
_TEXT	ENDS
PUBLIC	_soap_s2unsignedShort
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_r$82240 = -4						; size = 4
_p$ = 8							; size = 4
_soap_s2unsignedShort PROC
; _soap$ = edi
; _s$ = esi

; 9851 : { if (s)

	push	ecx
	test	esi, esi
	je	SHORT $LN6@soap_s2uns@3

; 9852 :   { unsigned long n;
; 9853 :     char *r;
; 9854 :     n = soap_strtoul(s, &r, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$82240[esp+8]
	push	eax
	push	esi
	call	_strtoul

; 9855 :     if (s == r || *r || n > 65535)

	mov	ecx, DWORD PTR _r$82240[esp+16]
	add	esp, 12					; 0000000cH
	cmp	esi, ecx
	je	SHORT $LN1@soap_s2uns@3
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN1@soap_s2uns@3
	cmp	eax, 65535				; 0000ffffH
	jbe	SHORT $LN2@soap_s2uns@3
$LN1@soap_s2uns@3:

; 9856 :       soap->error = SOAP_TYPE;

	mov	DWORD PTR [edi+90460], 4
$LN2@soap_s2uns@3:

; 9857 :     *p = (unsigned short)n;

	mov	ecx, DWORD PTR _p$[esp]
	mov	WORD PTR [ecx], ax
$LN6@soap_s2uns@3:

; 9858 :   }
; 9859 :   return soap->error;

	mov	eax, DWORD PTR [edi+90460]

; 9860 : }

	pop	ecx
	ret	0
_soap_s2unsignedShort ENDP
_TEXT	ENDS
PUBLIC	_soap_unsignedShort2s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_unsignedShort2s PROC
; _soap$ = ecx
; _n$ = eax

; 9828 : { return soap_unsignedLong2s(soap, (unsigned long)n);

	push	esi
	movzx	eax, ax
	push	eax
	mov	esi, ecx
	add	esi, 79028				; 000134b4H
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu?$AA@
	push	esi
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi

; 9829 : }

	ret	0
_soap_unsignedShort2s ENDP
_TEXT	ENDS
PUBLIC	_soap_s2unsignedByte
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_r$82195 = -4						; size = 4
_p$ = 8							; size = 4
_soap_s2unsignedByte PROC
; _soap$ = edi
; _s$ = esi

; 9780 : { if (s)

	push	ecx
	test	esi, esi
	je	SHORT $LN6@soap_s2uns@4

; 9781 :   { unsigned long n;
; 9782 :     char *r;
; 9783 :     n = soap_strtoul(s, &r, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$82195[esp+8]
	push	eax
	push	esi
	call	_strtoul

; 9784 :     if (s == r || *r || n > 255)

	mov	ecx, DWORD PTR _r$82195[esp+16]
	add	esp, 12					; 0000000cH
	cmp	esi, ecx
	je	SHORT $LN1@soap_s2uns@4
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN1@soap_s2uns@4
	cmp	eax, 255				; 000000ffH
	jbe	SHORT $LN2@soap_s2uns@4
$LN1@soap_s2uns@4:

; 9785 :       soap->error = SOAP_TYPE;

	mov	DWORD PTR [edi+90460], 4
$LN2@soap_s2uns@4:

; 9786 :     *p = (unsigned char)n;

	mov	ecx, DWORD PTR _p$[esp]
	mov	BYTE PTR [ecx], al
$LN6@soap_s2uns@4:

; 9787 :   }
; 9788 :   return soap->error;

	mov	eax, DWORD PTR [edi+90460]

; 9789 : }

	pop	ecx
	ret	0
_soap_s2unsignedByte ENDP
_TEXT	ENDS
PUBLIC	_soap_unsignedByte2s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_unsignedByte2s PROC
; _soap$ = ecx
; _n$ = eax

; 9757 : { return soap_unsignedLong2s(soap, (unsigned long)n);

	push	esi
	movzx	eax, al
	push	eax
	mov	esi, ecx
	add	esi, 79028				; 000134b4H
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu?$AA@
	push	esi
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi

; 9758 : }

	ret	0
_soap_unsignedByte2s ENDP
_TEXT	ENDS
PUBLIC	_soap_s2short
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_r$82016 = -4						; size = 4
_p$ = 8							; size = 4
_soap_s2short PROC
; _soap$ = edi
; _s$ = esi

; 9457 : { if (s)

	push	ecx
	test	esi, esi
	je	SHORT $LN6@soap_s2sho

; 9458 :   { long n;
; 9459 :     char *r;
; 9460 :     n = soap_strtol(s, &r, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$82016[esp+8]
	push	eax
	push	esi
	call	_strtol

; 9461 :     if (s == r || *r || n < -32768 || n > 32767)

	mov	ecx, DWORD PTR _r$82016[esp+16]
	add	esp, 12					; 0000000cH
	cmp	esi, ecx
	je	SHORT $LN1@soap_s2sho
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN1@soap_s2sho
	cmp	eax, -32768				; ffff8000H
	jl	SHORT $LN1@soap_s2sho
	cmp	eax, 32767				; 00007fffH
	jle	SHORT $LN2@soap_s2sho
$LN1@soap_s2sho:

; 9462 :       soap->error = SOAP_TYPE;

	mov	DWORD PTR [edi+90460], 4
$LN2@soap_s2sho:

; 9463 :     *p = (short)n;

	mov	ecx, DWORD PTR _p$[esp]
	mov	WORD PTR [ecx], ax
$LN6@soap_s2sho:

; 9464 :   }
; 9465 :   return soap->error;

	mov	eax, DWORD PTR [edi+90460]

; 9466 : }

	pop	ecx
	ret	0
_soap_s2short ENDP
_TEXT	ENDS
PUBLIC	_soap_s2byte
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_r$81971 = -4						; size = 4
_p$ = 8							; size = 4
_soap_s2byte PROC
; _soap$ = edi
; _s$ = esi

; 9386 : { if (s)

	push	ecx
	test	esi, esi
	je	SHORT $LN6@soap_s2byt

; 9387 :   { long n;
; 9388 :     char *r;
; 9389 :     n = soap_strtol(s, &r, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$81971[esp+8]
	push	eax
	push	esi
	call	_strtol

; 9390 :     if (s == r || *r || n < -128 || n > 127)

	mov	ecx, DWORD PTR _r$81971[esp+16]
	add	esp, 12					; 0000000cH
	cmp	esi, ecx
	je	SHORT $LN1@soap_s2byt
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN1@soap_s2byt
	cmp	eax, -128				; ffffff80H
	jl	SHORT $LN1@soap_s2byt
	cmp	eax, 127				; 0000007fH
	jle	SHORT $LN2@soap_s2byt
$LN1@soap_s2byt:

; 9391 :       soap->error = SOAP_TYPE;

	mov	DWORD PTR [edi+90460], 4
$LN2@soap_s2byt:

; 9392 :     *p = (char)n;

	mov	ecx, DWORD PTR _p$[esp]
	mov	BYTE PTR [ecx], al
$LN6@soap_s2byt:

; 9393 :   }
; 9394 :   return soap->error;

	mov	eax, DWORD PTR [edi+90460]

; 9395 : }

	pop	ecx
	ret	0
_soap_s2byte ENDP
_TEXT	ENDS
PUBLIC	_soap_s2LONG64
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_s2LONG64 PROC
; _soap$ = esi
; _s$ = eax
; _p$ = ecx

; 9291 : { if (s)

	test	eax, eax
	je	SHORT $LN6@soap_s2LON

; 9292 :   {
; 9293 : #ifdef HAVE_STRTOLL
; 9294 :     char *r;
; 9295 : #ifndef WITH_NOIO
; 9296 : #ifndef WITH_LEAN
; 9297 :     soap_reset_errno;
; 9298 : #endif
; 9299 : #endif
; 9300 :     *p = strtoll(s, &r, 10);
; 9301 :     if ((s == r && (soap->mode & SOAP_XML_STRICT)) || *r
; 9302 : #ifndef WITH_NOIO
; 9303 : #ifndef WITH_LEAN
; 9304 :        || soap_errno == SOAP_ERANGE
; 9305 : #endif
; 9306 : #endif
; 9307 :      )
; 9308 : #else
; 9309 : # ifdef HAVE_SSCANF
; 9310 :     if (sscanf(s, SOAP_LONG_FORMAT, p) != 1)

	push	ecx
	push	OFFSET ??_C@_05LLAMLEHD@?$CFI64d?$AA@
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN6@soap_s2LON

; 9311 : # endif
; 9312 : #endif
; 9313 :       soap->error = SOAP_TYPE;

	mov	DWORD PTR [esi+90460], 4
$LN6@soap_s2LON:

; 9314 :   }
; 9315 :   return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 9316 : }

	ret	0
_soap_s2LONG64 ENDP
_TEXT	ENDS
PUBLIC	_soap_LONG642s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_n$ = 8							; size = 8
_soap_LONG642s PROC
; _soap$ = eax

; 9267 : { sprintf(soap->tmpbuf, SOAP_LONG_FORMAT, n);

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	mov	ecx, DWORD PTR _n$[ebp]
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR _n$[ebp+4]
	push	eax
	push	ecx
	add	esi, 79028				; 000134b4H
	push	OFFSET ??_C@_05LLAMLEHD@?$CFI64d?$AA@
	push	esi
	call	_sprintf
	add	esp, 16					; 00000010H

; 9268 :   return soap->tmpbuf;

	mov	eax, esi

; 9269 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_LONG642s ENDP
_TEXT	ENDS
PUBLIC	_soap_s2long
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_r$81880 = -4						; size = 4
_p$ = 8							; size = 4
_soap_s2long PROC
; _soap$ = edi
; _s$ = esi

; 9208 : { if (s)

	push	ecx
	test	esi, esi
	je	SHORT $LN8@soap_s2lon

; 9209 :   { char *r;
; 9210 : #ifndef WITH_NOIO
; 9211 : #ifndef WITH_LEAN
; 9212 :     soap_reset_errno;

	push	0
	call	DWORD PTR __imp__SetLastError@4

; 9213 : #endif
; 9214 : #endif
; 9215 :     *p = soap_strtol(s, &r, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$81880[esp+8]
	push	eax
	push	esi
	call	_strtol
	mov	ecx, DWORD PTR _p$[esp+12]
	mov	DWORD PTR [ecx], eax

; 9216 :     if ((s == r && (soap->mode & SOAP_XML_STRICT)) || *r
; 9217 : #ifndef WITH_NOIO
; 9218 : #ifndef WITH_LEAN
; 9219 :      || soap_errno == SOAP_ERANGE
; 9220 : #endif
; 9221 : #endif
; 9222 :    )

	mov	eax, DWORD PTR _r$81880[esp+16]
	add	esp, 12					; 0000000cH
	cmp	esi, eax
	jne	SHORT $LN1@soap_s2lon
	test	DWORD PTR [edi+8], 4096			; 00001000H
	jne	SHORT $LN2@soap_s2lon
$LN1@soap_s2lon:
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@soap_s2lon
	call	DWORD PTR __imp__GetLastError@0
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN8@soap_s2lon
$LN2@soap_s2lon:

; 9223 :       soap->error = SOAP_TYPE;

	mov	DWORD PTR [edi+90460], 4
$LN8@soap_s2lon:

; 9224 :   }
; 9225 :   return soap->error;

	mov	eax, DWORD PTR [edi+90460]

; 9226 : }

	pop	ecx
	ret	0
_soap_s2long ENDP
_TEXT	ENDS
PUBLIC	_soap_long2s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_long2s PROC
; _soap$ = ecx
; _n$ = eax

; 9184 : { sprintf(soap->tmpbuf, "%ld", n);

	push	esi
	push	eax
	mov	esi, ecx
	add	esi, 79028				; 000134b4H
	push	OFFSET ??_C@_03JALODAI@?$CFld?$AA@
	push	esi
	call	_sprintf
	add	esp, 12					; 0000000cH

; 9185 :   return soap->tmpbuf;

	mov	eax, esi
	pop	esi

; 9186 : }

	ret	0
_soap_long2s ENDP
_TEXT	ENDS
PUBLIC	_soap_s2int
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_r$81833 = -4						; size = 4
_p$ = 8							; size = 4
_soap_s2int PROC
; _soap$ = edi
; _s$ = esi

; 9125 : { if (s)

	push	ecx
	test	esi, esi
	je	SHORT $LN8@soap_s2int

; 9126 :   { char *r;
; 9127 : #ifndef WITH_NOIO
; 9128 : #ifndef WITH_LEAN
; 9129 :     soap_reset_errno;

	push	0
	call	DWORD PTR __imp__SetLastError@4

; 9130 : #endif
; 9131 : #endif
; 9132 :     *p = (int)soap_strtol(s, &r, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _r$81833[esp+8]
	push	eax
	push	esi
	call	_strtol
	mov	ecx, DWORD PTR _p$[esp+12]
	mov	DWORD PTR [ecx], eax

; 9133 :     if ((s == r && (soap->mode & SOAP_XML_STRICT)) || *r
; 9134 : #ifndef WITH_NOIO
; 9135 : #ifndef WITH_LEAN
; 9136 :      || soap_errno == SOAP_ERANGE
; 9137 : #endif
; 9138 : #endif
; 9139 :    )

	mov	eax, DWORD PTR _r$81833[esp+16]
	add	esp, 12					; 0000000cH
	cmp	esi, eax
	jne	SHORT $LN1@soap_s2int
	test	DWORD PTR [edi+8], 4096			; 00001000H
	jne	SHORT $LN2@soap_s2int
$LN1@soap_s2int:
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN2@soap_s2int
	call	DWORD PTR __imp__GetLastError@0
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN8@soap_s2int
$LN2@soap_s2int:

; 9140 :       soap->error = SOAP_TYPE;

	mov	DWORD PTR [edi+90460], 4
$LN8@soap_s2int:

; 9141 :   }
; 9142 :   return soap->error;

	mov	eax, DWORD PTR [edi+90460]

; 9143 : }

	pop	ecx
	ret	0
_soap_s2int ENDP
_TEXT	ENDS
PUBLIC	_soap_int2s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_int2s PROC
; _soap$ = ecx
; _n$ = eax

; 9102 : { return soap_long2s(soap, (long)n);

	push	esi
	push	eax
	mov	esi, ecx
	add	esi, 79028				; 000134b4H
	push	OFFSET ??_C@_03JALODAI@?$CFld?$AA@
	push	esi
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi

; 9103 : }

	ret	0
_soap_int2s ENDP
_TEXT	ENDS
PUBLIC	_soap_revert
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_revert PROC
; _soap$ = eax

; 8302 : { if (!soap->peeked)

	cmp	WORD PTR [eax+87308], 0
	jne	SHORT $LN1@soap_rever

; 8303 :   { soap->peeked = 1;
; 8304 :     if (soap->body)

	cmp	WORD PTR [eax+12442], 0
	mov	ecx, 1
	mov	WORD PTR [eax+87308], cx
	je	SHORT $LN1@soap_rever

; 8305 :       soap->level--;

	dec	DWORD PTR [eax+12444]
$LN1@soap_rever:

; 8306 :   }
; 8307 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Reverting last element (level=%u)\n", soap->level));
; 8308 : }

	ret	0
_soap_revert ENDP
_TEXT	ENDS
PUBLIC	_soap_retry
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_retry PROC
; _soap$ = eax

; 8292 :   soap_revert(soap);

	cmp	WORD PTR [eax+87308], 0
	mov	DWORD PTR [eax+90460], 0
	jne	SHORT $LN3@soap_retry
	cmp	WORD PTR [eax+12442], 0
	mov	ecx, 1
	mov	WORD PTR [eax+87308], cx
	je	SHORT $LN3@soap_retry
	dec	DWORD PTR [eax+12444]
$LN3@soap_retry:

; 8293 : }

	ret	0
_soap_retry ENDP
_TEXT	ENDS
PUBLIC	_soap_append_lab
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_s$ = 8							; size = 4
_n$ = 12						; size = 4
_soap_append_lab PROC
; _soap$ = esi

; 7885 : { if (soap->labidx + n >= soap->lablen)

	mov	eax, DWORD PTR [esi+12464]
	push	ebx
	mov	ebx, DWORD PTR _n$[esp]
	lea	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [esi+12460]
	push	ebp
	mov	ebp, DWORD PTR _s$[esp+4]
	push	edi
	cmp	ecx, eax
	jb	$LN13@soap_appen

; 7886 :   { register char *t = soap->labbuf;

	mov	edi, DWORD PTR [esi+12456]

; 7887 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Enlarging look-aside buffer to append data, old size=%lu", (unsigned long)soap->lablen));
; 7888 :     if (soap->lablen == 0)

	test	eax, eax
	jne	SHORT $LN11@soap_appen

; 7889 :       soap->lablen = SOAP_LABLEN;

	mov	DWORD PTR [esi+12460], 256		; 00000100H
$LN11@soap_appen:

; 7890 :     while (soap->labidx + n >= soap->lablen)

	cmp	ecx, DWORD PTR [esi+12460]
	jb	SHORT $LN5@soap_appen
	npad	2
$LL6@soap_appen:

; 7891 :       soap->lablen <<= 1;

	shl	DWORD PTR [esi+12460], 1
	mov	ecx, DWORD PTR [esi+12464]
	add	ecx, ebx
	cmp	ecx, DWORD PTR [esi+12460]
	jae	SHORT $LL6@soap_appen
$LN5@soap_appen:

; 7892 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, ", new size=%lu\n", (unsigned long)soap->lablen));
; 7893 :     soap->labbuf = (char*)SOAP_MALLOC(soap, soap->lablen);

	mov	edx, DWORD PTR [esi+12460]
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR [esi+12456], eax

; 7894 :     if (!soap->labbuf)

	test	eax, eax
	jne	SHORT $LN4@soap_appen

; 7895 :     { if (t)

	test	edi, edi
	je	SHORT $LN3@soap_appen

; 7896 :         SOAP_FREE(soap, t);

	push	edi
	call	_free
	add	esp, 4
$LN3@soap_appen:
	pop	edi

; 7897 :       return soap->error = SOAP_EOM;

	mov	eax, 20					; 00000014H
	pop	ebp
	mov	DWORD PTR [esi+90460], eax
	pop	ebx

; 7909 : }

	ret	0
$LN4@soap_appen:

; 7898 :     }
; 7899 :     if (t)

	test	edi, edi
	je	SHORT $LN13@soap_appen

; 7900 :     { memcpy(soap->labbuf, t, soap->labidx);

	mov	ecx, DWORD PTR [esi+12464]
	push	ecx
	push	edi
	push	eax
	call	_memcpy

; 7901 :       SOAP_FREE(soap, t);

	push	edi
	call	_free
	add	esp, 16					; 00000010H
$LN13@soap_appen:

; 7902 :     }
; 7903 :   }
; 7904 :   if (s)

	test	ebp, ebp
	je	SHORT $LN1@soap_appen

; 7905 :   { memcpy(soap->labbuf + soap->labidx, s, n);

	mov	edx, DWORD PTR [esi+12456]
	add	edx, DWORD PTR [esi+12464]
	push	ebx
	push	ebp
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 7906 :     soap->labidx += n;

	add	DWORD PTR [esi+12464], ebx
$LN1@soap_appen:
	pop	edi
	pop	ebp

; 7907 :   }
; 7908 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 7909 : }

	ret	0
_soap_append_lab ENDP
_TEXT	ENDS
PUBLIC	_soap_store_lab
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_store_lab PROC
; _s$ = ecx
; _n$ = eax

; 7872 : { soap->labidx = 0;

	push	esi
	mov	esi, DWORD PTR _soap$[esp]

; 7873 :   return soap_append_lab(soap, s, n);

	push	eax
	push	ecx
	mov	DWORD PTR [esi+12464], 0
	call	_soap_append_lab
	add	esp, 8
	pop	esi

; 7874 : }

	ret	0
_soap_store_lab ENDP
_TEXT	ENDS
PUBLIC	_soap_clr_attr
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_clr_attr PROC
; _soap$ = eax

; 7788 : { register struct soap_attribute *tp;

	push	esi
	mov	esi, eax

; 7789 : #ifndef WITH_LEAN
; 7790 :   if ((soap->mode & SOAP_XML_CANONICAL))

	test	DWORD PTR [esi+8], 16384		; 00004000H
	je	SHORT $LN8@soap_clr_a

; 7791 :   { while (soap->attributes)

	cmp	DWORD PTR [esi+87292], 0
	je	SHORT $LN1@soap_clr_a
	push	edi
	npad	10
$LL7@soap_clr_a:

; 7792 :     { tp = soap->attributes->next;

	mov	eax, DWORD PTR [esi+87292]
	mov	edi, DWORD PTR [eax]

; 7793 :       if (soap->attributes->value)

	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN5@soap_clr_a

; 7794 :         SOAP_FREE(soap, soap->attributes->value);

	push	eax
	call	_free
	add	esp, 4
$LN5@soap_clr_a:

; 7795 :       SOAP_FREE(soap, soap->attributes);

	mov	eax, DWORD PTR [esi+87292]
	push	eax
	call	_free
	add	esp, 4

; 7796 :       soap->attributes = tp;

	mov	DWORD PTR [esi+87292], edi
	test	edi, edi
	jne	SHORT $LL7@soap_clr_a
	pop	edi
	pop	esi

; 7803 :   }
; 7804 : }

	ret	0
$LN8@soap_clr_a:

; 7797 :     }
; 7798 :   }
; 7799 :   else
; 7800 : #endif
; 7801 :   { for (tp = soap->attributes; tp; tp = tp->next)

	mov	esi, DWORD PTR [esi+87292]
	test	esi, esi
	je	SHORT $LN1@soap_clr_a
	npad	2
$LL3@soap_clr_a:

; 7802 :       tp->visible = 0;

	xor	ecx, ecx
	mov	WORD PTR [esi+16], cx
	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL3@soap_clr_a
$LN1@soap_clr_a:
	pop	esi

; 7803 :   }
; 7804 : }

	ret	0
_soap_clr_attr ENDP
_TEXT	ENDS
PUBLIC	_soap_set_attr
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_soap_set_attr PROC

; 7696 : { register struct soap_attribute *tp;

	push	edi
	mov	edi, DWORD PTR _name$[esp]

; 7697 :   if (*name == '-')

	cmp	BYTE PTR [edi], 45			; 0000002dH
	jne	SHORT $LN41@soap_set_a

; 7698 :     return SOAP_OK;

	xor	eax, eax
	pop	edi

; 7779 : }

	ret	0
$LN41@soap_set_a:
	push	ebx
	push	ebp
	push	esi

; 7699 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Set attribute %s='%s'\n", name, value?value:""));
; 7700 :   for (tp = soap->attributes; tp; tp = tp->next)

	mov	esi, DWORD PTR _soap$[esp+12]
	mov	ebx, DWORD PTR [esi+87292]
	add	esi, 87292				; 000154fcH
	xor	ebp, ebp
	cmp	ebx, ebp
	je	SHORT $LN58@soap_set_a
$LL40@soap_set_a:

; 7701 :   { if (!strcmp(tp->name, name))

	mov	ecx, edi
	lea	eax, DWORD PTR [ebx+18]
	npad	4
$LL59@soap_set_a:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN60@soap_set_a
	test	dl, dl
	je	SHORT $LN61@soap_set_a
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN60@soap_set_a
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL59@soap_set_a
$LN61@soap_set_a:
	xor	eax, eax
	jmp	SHORT $LN62@soap_set_a
$LN60@soap_set_a:
	sbb	eax, eax
	sbb	eax, -1
$LN62@soap_set_a:
	cmp	eax, ebp
	je	SHORT $LN52@soap_set_a
	mov	ebx, DWORD PTR [ebx]
	cmp	ebx, ebp
	jne	SHORT $LL40@soap_set_a

; 7702 :       break;
; 7703 :   }
; 7704 :   if (!tp)

	jmp	SHORT $LN58@soap_set_a
$LN52@soap_set_a:
	cmp	ebx, ebp
	jne	$LN36@soap_set_a
$LN58@soap_set_a:

; 7705 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Allocate attribute %s\n", name));
; 7706 :     if (!(tp = (struct soap_attribute*)SOAP_MALLOC(soap, sizeof(struct soap_attribute) + strlen(name))))

	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL63@soap_set_a:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL63@soap_set_a
	sub	eax, edx
	add	eax, 20					; 00000014H
	push	eax
	call	_malloc
	mov	ebx, eax
	add	esp, 4
	cmp	ebx, ebp

; 7707 :       return soap->error = SOAP_EOM;

	je	$LN91@soap_set_a

; 7708 :     tp->ns = NULL;
; 7709 : #ifndef WITH_LEAN
; 7710 :     if (soap->mode & SOAP_XML_CANONICAL)

	mov	edx, DWORD PTR _soap$[esp+12]
	mov	DWORD PTR [ebx+12], ebp
	test	DWORD PTR [edx+8], 16384		; 00004000H
	je	$LN34@soap_set_a

; 7711 :     { struct soap_attribute **tpp = &soap->attributes;
; 7712 :       const char *s = strchr(name, ':');

	mov	eax, DWORD PTR _name$[esp+12]
	push	58					; 0000003aH
	push	eax
	mov	edi, esi
	call	_strchr

; 7713 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inserting attribute %s for c14n\n", name))
; 7714 :       if (!strncmp(name, "xmlns", 5))

	mov	ecx, DWORD PTR _name$[esp+20]
	push	5
	push	OFFSET ??_C@_05PPEFOGKI@xmlns?$AA@
	push	ecx
	mov	ebp, eax
	call	_strncmp
	add	esp, 20					; 00000014H
	test	eax, eax

; 7715 :       { for (; *tpp; tpp = &(*tpp)->next)

	mov	eax, DWORD PTR [edi]
	jne	SHORT $LN33@soap_set_a
	test	eax, eax
	je	$LN12@soap_set_a
$LL32@soap_set_a:

; 7716 :           if (strncmp((*tpp)->name, "xmlns", 5) || strcmp((*tpp)->name + 5, name + 5) > 0)

	push	5
	add	eax, 18					; 00000012H
	push	OFFSET ??_C@_05PPEFOGKI@xmlns?$AA@
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN12@soap_set_a
	mov	esi, DWORD PTR [edi]
	mov	ecx, DWORD PTR _name$[esp+12]
	add	ecx, 5
	lea	eax, DWORD PTR [esi+23]
	npad	4
$LL64@soap_set_a:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN65@soap_set_a
	test	dl, dl
	je	SHORT $LN66@soap_set_a
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN65@soap_set_a
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL64@soap_set_a
$LN66@soap_set_a:
	xor	eax, eax
	jmp	SHORT $LN67@soap_set_a
$LN65@soap_set_a:
	sbb	eax, eax
	sbb	eax, -1
$LN67@soap_set_a:
	test	eax, eax
	jg	$LN12@soap_set_a
	mov	edi, esi
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LL32@soap_set_a

; 7734 :             break;
; 7735 :         }
; 7736 :       }
; 7737 :       tp->next = *tpp;

	mov	ecx, eax
	mov	DWORD PTR [ebx], ecx

; 7738 :       *tpp = tp;

	mov	DWORD PTR [edi], ebx

; 7739 :     }
; 7740 :     else

	mov	edi, DWORD PTR _name$[esp+12]
	xor	ebp, ebp
	jmp	$LN11@soap_set_a
$LN33@soap_set_a:

; 7717 :             break;
; 7718 :       }
; 7719 :       else if (!s)

	test	ebp, ebp
	jne	SHORT $LN26@soap_set_a

; 7720 :       { for (; *tpp; tpp = &(*tpp)->next)

	test	eax, eax
	je	$LN12@soap_set_a
$LL25@soap_set_a:

; 7721 :           if (strncmp((*tpp)->name, "xmlns", 5) && ((*tpp)->ns || strcmp((*tpp)->name, name) > 0))

	push	5
	add	eax, 18					; 00000012H
	push	OFFSET ??_C@_05PPEFOGKI@xmlns?$AA@
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN24@soap_set_a
	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax+12], 0
	jne	$LN12@soap_set_a
	mov	ecx, DWORD PTR _name$[esp+12]
	add	eax, 18					; 00000012H
	npad	4
$LL68@soap_set_a:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN69@soap_set_a
	test	dl, dl
	je	SHORT $LN70@soap_set_a
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN69@soap_set_a
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL68@soap_set_a
$LN70@soap_set_a:
	xor	eax, eax
	jmp	SHORT $LN71@soap_set_a
$LN69@soap_set_a:
	sbb	eax, eax
	sbb	eax, -1
$LN71@soap_set_a:
	test	eax, eax
	jg	$LN12@soap_set_a
$LN24@soap_set_a:

; 7720 :       { for (; *tpp; tpp = &(*tpp)->next)

	mov	edi, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LL25@soap_set_a

; 7734 :             break;
; 7735 :         }
; 7736 :       }
; 7737 :       tp->next = *tpp;

	mov	ecx, eax
	mov	DWORD PTR [ebx], ecx

; 7738 :       *tpp = tp;

	mov	DWORD PTR [edi], ebx

; 7739 :     }
; 7740 :     else

	mov	edi, DWORD PTR _name$[esp+12]
	xor	ebp, ebp
	jmp	$LN11@soap_set_a
$LN26@soap_set_a:

; 7722 :             break;
; 7723 :       }
; 7724 :       else
; 7725 :       { int k;
; 7726 :         for (; *tpp; tpp = &(*tpp)->next)

	test	eax, eax
	je	$LN12@soap_set_a
	npad	2
$LL19@soap_set_a:

; 7727 :         { if (!strncmp((*tpp)->name, "xmlns:", 6) && !strncmp((*tpp)->name + 6, name, s - name) && !(*tpp)->name[6 + s - name])

	push	6
	add	eax, 18					; 00000012H
	push	OFFSET ??_C@_06PNFLLAEF@xmlns?3?$AA@
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@soap_set_a
	mov	esi, DWORD PTR _name$[esp+12]
	mov	eax, DWORD PTR [edi]
	mov	edx, ebp
	sub	edx, esi
	push	edx
	add	eax, 24					; 00000018H
	push	esi
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@soap_set_a
	mov	eax, DWORD PTR [edi]
	mov	ecx, eax
	sub	ecx, esi
	cmp	BYTE PTR [ecx+ebp+24], 0
	jne	SHORT $LN16@soap_set_a

; 7728 :           { if (!tp->ns)

	cmp	DWORD PTR [ebx+12], 0
	jne	$LN18@soap_set_a

; 7729 :             { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Canonicalization: prefix %s=%p (%s)\n", name, (*tpp)->ns, (*tpp)->ns));
; 7730 :               tp->ns = (*tpp)->ns;

	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ebx+12], edx

; 7731 :             }
; 7732 :           }

	jmp	$LN18@soap_set_a
$LN16@soap_set_a:

; 7733 :           else if (strncmp((*tpp)->name, "xmlns", 5) && (*tpp)->ns && tp->ns && ((k = strcmp((*tpp)->ns, tp->ns)) > 0 || (!k && strcmp((*tpp)->name, name) > 0)))

	mov	eax, DWORD PTR [edi]
	push	5
	add	eax, 18					; 00000012H
	push	OFFSET ??_C@_05PPEFOGKI@xmlns?$AA@
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN18@soap_set_a
	mov	esi, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN18@soap_set_a
	mov	ecx, DWORD PTR [ebx+12]
	test	ecx, ecx
	je	SHORT $LN18@soap_set_a
$LL72@soap_set_a:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN73@soap_set_a
	test	dl, dl
	je	SHORT $LN74@soap_set_a
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN73@soap_set_a
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL72@soap_set_a
$LN74@soap_set_a:
	xor	eax, eax
	jmp	SHORT $LN75@soap_set_a
$LN73@soap_set_a:
	sbb	eax, eax
	sbb	eax, -1
$LN75@soap_set_a:
	test	eax, eax
	jg	SHORT $LN12@soap_set_a
	jne	SHORT $LN18@soap_set_a
	mov	ecx, DWORD PTR _name$[esp+12]
	lea	eax, DWORD PTR [esi+18]
$LL76@soap_set_a:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN77@soap_set_a
	test	dl, dl
	je	SHORT $LN78@soap_set_a
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN77@soap_set_a
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL76@soap_set_a
$LN78@soap_set_a:
	xor	eax, eax
	jmp	SHORT $LN79@soap_set_a
$LN77@soap_set_a:
	sbb	eax, eax
	sbb	eax, -1
$LN79@soap_set_a:
	test	eax, eax
	jg	SHORT $LN12@soap_set_a
$LN18@soap_set_a:

; 7722 :             break;
; 7723 :       }
; 7724 :       else
; 7725 :       { int k;
; 7726 :         for (; *tpp; tpp = &(*tpp)->next)

	mov	edi, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	$LL19@soap_set_a
$LN12@soap_set_a:

; 7734 :             break;
; 7735 :         }
; 7736 :       }
; 7737 :       tp->next = *tpp;

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ebx], ecx

; 7738 :       *tpp = tp;

	mov	DWORD PTR [edi], ebx

; 7739 :     }
; 7740 :     else

	mov	edi, DWORD PTR _name$[esp+12]
	xor	ebp, ebp
	jmp	SHORT $LN11@soap_set_a
$LN34@soap_set_a:

; 7741 : #endif
; 7742 :     { tp->next = soap->attributes;

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], edx

; 7743 :       soap->attributes = tp;

	mov	DWORD PTR [esi], ebx
$LN11@soap_set_a:

; 7744 :     }
; 7745 :     strcpy(tp->name, name);

	lea	edx, DWORD PTR [ebx+18]
	mov	eax, edi
	sub	edx, edi
$LL44@soap_set_a:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL44@soap_set_a

; 7746 :     tp->value = NULL;

	jmp	SHORT $LN90@soap_set_a
$LN36@soap_set_a:

; 7747 :   }
; 7748 :   else if (tp->visible)

	cmp	WORD PTR [ebx+16], bp

; 7749 :   { return SOAP_OK;

	jne	$LN1@soap_set_a

; 7750 :   }
; 7751 :   else if (value && tp->value && tp->size <= strlen(value))

	mov	eax, DWORD PTR _value$[esp+12]
	cmp	eax, ebp
	je	$LN6@soap_set_a
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ebp
	je	SHORT $LN86@soap_set_a
	lea	edx, DWORD PTR [eax+1]
$LL80@soap_set_a:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL80@soap_set_a
	sub	eax, edx
	cmp	DWORD PTR [ebx+8], eax
	ja	SHORT $LN86@soap_set_a

; 7752 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free attribute value of %s (free %p)\n", name, tp->value));
; 7753 :     SOAP_FREE(soap, tp->value);

	push	esi
	call	_free
	add	esp, 4

; 7755 :     tp->ns = NULL;

	mov	DWORD PTR [ebx+12], ebp
$LN90@soap_set_a:

; 7754 :     tp->value = NULL;

	mov	DWORD PTR [ebx+4], ebp
$LN86@soap_set_a:

; 7756 :   }
; 7757 :   if (value)

	cmp	DWORD PTR _value$[esp+12], ebp
	je	$LN6@soap_set_a

; 7758 :   { if (!tp->value)

	cmp	DWORD PTR [ebx+4], ebp
	jne	SHORT $LN4@soap_set_a

; 7759 :     { tp->size = strlen(value) + 1;

	mov	eax, DWORD PTR _value$[esp+12]
	lea	edx, DWORD PTR [eax+1]
$LL81@soap_set_a:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL81@soap_set_a
	sub	eax, edx
	inc	eax

; 7760 :       if (!(tp->value = (char*)SOAP_MALLOC(soap, tp->size)))

	push	eax
	mov	DWORD PTR [ebx+8], eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR [ebx+4], eax
	cmp	eax, ebp
	jne	SHORT $LN4@soap_set_a
$LN91@soap_set_a:

; 7761 :         return soap->error = SOAP_EOM;

	mov	ecx, DWORD PTR _soap$[esp+12]
	pop	esi
	pop	ebp
	mov	eax, 20					; 00000014H
	pop	ebx
	mov	DWORD PTR [ecx+90460], eax
	pop	edi

; 7779 : }

	ret	0
$LN4@soap_set_a:

; 7762 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Allocate attribute value for %s (%p)\n", tp->name, tp->value));
; 7763 :     }
; 7764 :     strcpy(tp->value, value);

	mov	esi, DWORD PTR _value$[esp+12]
	mov	edx, DWORD PTR [ebx+4]
	mov	ecx, esi
	npad	3
$LL45@soap_set_a:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL45@soap_set_a

; 7765 :     if (!strncmp(tp->name, "xmlns:", 6))

	push	6
	lea	edx, DWORD PTR [ebx+18]
	push	OFFSET ??_C@_06PNFLLAEF@xmlns?3?$AA@
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@soap_set_a

; 7766 :       tp->ns = tp->value;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx+12], eax
$LN3@soap_set_a:

; 7767 :     tp->visible = 2;

	mov	ecx, 2
	mov	WORD PTR [ebx+16], cx

; 7768 : #ifndef WITH_LEAN
; 7769 :     if (!strcmp(name, "wsu:Id"))

	mov	ecx, OFFSET ??_C@_06BGJENONN@wsu?3Id?$AA@
	mov	eax, edi
$LL82@soap_set_a:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN83@soap_set_a
	test	dl, dl
	je	SHORT $LN84@soap_set_a
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN83@soap_set_a
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL82@soap_set_a
$LN84@soap_set_a:
	xor	eax, eax
	jmp	SHORT $LN85@soap_set_a
$LN83@soap_set_a:
	sbb	eax, eax
	sbb	eax, -1
$LN85@soap_set_a:
	cmp	eax, ebp
	jne	SHORT $LN1@soap_set_a

; 7770 :     { soap->part = SOAP_BEGIN_SECURITY;

	mov	edi, DWORD PTR _soap$[esp+12]

; 7771 :       strncpy(soap->id, value, sizeof(soap->id));

	push	1024					; 00000400H
	lea	eax, DWORD PTR [edi+81076]
	mov	edx, 10					; 0000000aH
	push	esi
	push	eax
	mov	WORD PTR [edi+87304], dx
	call	_strncpy
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebp
	pop	ebx

; 7772 :       soap->id[sizeof(soap->id)-1] = '\0';

	mov	BYTE PTR [edi+82099], 0

; 7778 :   return SOAP_OK;

	xor	eax, eax
	pop	edi

; 7779 : }

	ret	0
$LN6@soap_set_a:

; 7773 :     }
; 7774 : #endif
; 7775 :   }
; 7776 :   else
; 7777 :     tp->visible = 1;

	mov	ecx, 1
	mov	WORD PTR [ebx+16], cx
$LN1@soap_set_a:
	pop	esi
	pop	ebp
	pop	ebx

; 7778 :   return SOAP_OK;

	xor	eax, eax
	pop	edi

; 7779 : }

	ret	0
_soap_set_attr ENDP
_TEXT	ENDS
PUBLIC	_soap_lookup_ns
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_soap_lookup_ns PROC
; _soap$ = eax
; _n$ = edi

; 6849 : { register struct soap_nlist *np;

	push	ebx
	mov	ebx, DWORD PTR _tag$[esp]
	push	esi

; 6850 :   for (np = soap->nlist; np; np = np->next)

	mov	esi, DWORD PTR [eax+88]
	test	esi, esi
	je	SHORT $LN2@soap_looku
	npad	3
$LL4@soap_looku:

; 6851 :   { if (!strncmp(np->id, tag, n) && !np->id[n])

	push	edi
	lea	ecx, DWORD PTR [esi+16]
	push	ebx
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@soap_looku
	cmp	BYTE PTR [esi+edi+16], al
	je	SHORT $LN8@soap_looku
$LN3@soap_looku:

; 6850 :   for (np = soap->nlist; np; np = np->next)

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL4@soap_looku
$LN2@soap_looku:
	pop	esi

; 6853 :   }
; 6854 :   return NULL;

	xor	eax, eax
	pop	ebx

; 6855 : }

	ret	0
$LN8@soap_looku:

; 6852 :       return np;

	mov	eax, esi
	pop	esi
	pop	ebx

; 6855 : }

	ret	0
_soap_lookup_ns ENDP
_TEXT	ENDS
PUBLIC	_soap_strsearch
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_little$ = 8						; size = 4
_soap_strsearch PROC
; _big$ = eax

; 6828 : { size_t n = strlen(little);

	push	ebx
	mov	ebx, DWORD PTR _little$[esp]
	push	esi
	mov	esi, eax
	mov	eax, ebx
	push	edi
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL10@soap_strse:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL10@soap_strse
	sub	eax, edx
	mov	edi, eax

; 6829 :   const char *s = big;
; 6830 :   while (s)

	test	esi, esi
	je	SHORT $LN4@soap_strse
	npad	1
$LL5@soap_strse:

; 6831 :   { if (!strncmp(s, little, n) && (s[n] == '\0' || s[n] == ' '))

	push	edi
	push	ebx
	push	esi
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@soap_strse
	mov	al, BYTE PTR [esi+edi]
	test	al, al
	je	SHORT $LN2@soap_strse
	cmp	al, 32					; 00000020H
	je	SHORT $LN2@soap_strse
$LN3@soap_strse:

; 6833 :     s = strchr(s, ' ');

	push	32					; 00000020H
	push	esi
	call	_strchr
	mov	esi, eax
	add	esp, 8

; 6834 :     if (s)

	test	esi, esi
	je	SHORT $LN4@soap_strse

; 6835 :       s++;

	add	esi, 1

; 6829 :   const char *s = big;
; 6830 :   while (s)

	jne	SHORT $LL5@soap_strse
$LN4@soap_strse:
	pop	edi
	pop	esi

; 6836 :   }
; 6837 :   return NULL;

	xor	eax, eax
	pop	ebx

; 6838 : }

	ret	0
$LN2@soap_strse:
	pop	edi

; 6832 :       return s;

	mov	eax, esi
	pop	esi
	pop	ebx

; 6838 : }

	ret	0
_soap_strsearch ENDP
_TEXT	ENDS
PUBLIC	_soap_set_local_namespaces
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_set_local_namespaces PROC

; 6799 : { if (soap->namespaces && !soap->local_namespaces)

	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	mov	eax, DWORD PTR [ebx+80]
	test	eax, eax
	je	$LN4@soap_set_l
	cmp	DWORD PTR [ebx+84], 0
	jne	$LN4@soap_set_l

; 6800 :   { register const struct Namespace *ns1;
; 6801 :     register struct Namespace *ns2;
; 6802 :     register size_t n = 1;
; 6803 :     for (ns1 = soap->namespaces; ns1->id; ns1++)

	cmp	DWORD PTR [eax], 0
	mov	ecx, 1
	je	SHORT $LN5@soap_set_l
$LL7@soap_set_l:
	add	eax, 16					; 00000010H

; 6804 :       n++;

	inc	ecx
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LL7@soap_set_l
$LN5@soap_set_l:
	push	esi

; 6805 :     n *= sizeof(struct Namespace);

	shl	ecx, 4
	mov	esi, ecx
	push	edi

; 6806 :     ns2 = (struct Namespace*)SOAP_MALLOC(soap, n);

	push	esi
	call	_malloc
	mov	edi, eax
	add	esp, 4

; 6807 :     if (ns2)

	test	edi, edi
	je	SHORT $LN17@soap_set_l

; 6808 :     { memcpy(ns2, soap->namespaces, n);

	mov	eax, DWORD PTR [ebx+80]
	push	esi
	push	eax
	push	edi
	call	_memcpy

; 6809 :       if (ns2[0].ns)

	mov	eax, DWORD PTR [edi+4]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_set_l

; 6810 :       { if (!strcmp(ns2[0].ns, soap_env1))

	mov	ecx, OFFSET _soap_env1
	npad	3
$LL13@soap_set_l:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN14@soap_set_l
	test	dl, dl
	je	SHORT $LN15@soap_set_l
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN14@soap_set_l
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL13@soap_set_l
$LN15@soap_set_l:
	xor	eax, eax
	jmp	SHORT $LN16@soap_set_l
$LN14@soap_set_l:
	sbb	eax, eax
	sbb	eax, -1
$LN16@soap_set_l:
	test	eax, eax
	jne	SHORT $LN2@soap_set_l

; 6814 :       }
; 6815 :       soap->local_namespaces = ns2;

	mov	DWORD PTR [ebx+84], edi
	pop	edi
	mov	ecx, 1
	pop	esi
	mov	WORD PTR [ebx+6], cx
	pop	ebx

; 6816 :     }
; 6817 :   }
; 6818 : }

	ret	0
$LN2@soap_set_l:

; 6811 :           soap->version = 1;
; 6812 :         else
; 6813 :           soap->version = 2;

	mov	edx, 2
	mov	WORD PTR [ebx+6], dx
$LN1@soap_set_l:

; 6814 :       }
; 6815 :       soap->local_namespaces = ns2;

	mov	DWORD PTR [ebx+84], edi
$LN17@soap_set_l:
	pop	edi
	pop	esi
$LN4@soap_set_l:
	pop	ebx

; 6816 :     }
; 6817 :   }
; 6818 : }

	ret	0
_soap_set_local_namespaces ENDP
_TEXT	ENDS
PUBLIC	_soap_copy_stream
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_copy_stream PROC
; _copy$ = ecx
; _soap$ = eax

; 6392 : { copy->mode = soap->mode;

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx

; 6393 :   copy->imode = soap->imode;

	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx

; 6394 :   copy->omode = soap->omode;

	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx

; 6395 :   copy->socket = soap->socket;

	mov	edx, DWORD PTR [eax+12408]
	mov	DWORD PTR [ecx+12408], edx

; 6396 :   copy->recv_timeout = soap->recv_timeout;

	mov	edx, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx+48], edx

; 6397 :   copy->send_timeout = soap->send_timeout;

	mov	edx, DWORD PTR [eax+52]
	mov	DWORD PTR [ecx+52], edx

; 6398 : #if defined(__cplusplus) && !defined(WITH_LEAN)
; 6399 :   copy->os = soap->os;

	mov	edx, DWORD PTR [eax+12412]
	mov	DWORD PTR [ecx+12412], edx

; 6400 :   copy->is = soap->is;

	mov	edx, DWORD PTR [eax+12416]
	mov	DWORD PTR [ecx+12416], edx

; 6401 : #endif
; 6402 :   copy->sendfd = soap->sendfd;

	mov	edx, DWORD PTR [eax+12420]
	mov	DWORD PTR [ecx+12420], edx

; 6403 :   copy->recvfd = soap->recvfd;

	mov	edx, DWORD PTR [eax+12424]
	mov	DWORD PTR [ecx+12424], edx

; 6404 :   copy->bufidx = soap->bufidx;

	mov	edx, DWORD PTR [eax+12428]
	mov	DWORD PTR [ecx+12428], edx

; 6405 :   copy->buflen = soap->buflen;

	mov	edx, DWORD PTR [eax+12432]
	mov	DWORD PTR [ecx+12432], edx

; 6406 :   copy->ahead = soap->ahead;

	mov	edx, DWORD PTR [eax+12436]
	mov	DWORD PTR [ecx+12436], edx

; 6407 :   copy->cdata = soap->cdata;

	movzx	edx, WORD PTR [eax+12440]
	mov	WORD PTR [ecx+12440], dx

; 6408 :   copy->chunksize = soap->chunksize;

	mov	edx, DWORD PTR [eax+87312]
	mov	DWORD PTR [ecx+87312], edx

; 6409 :   copy->chunkbuflen = soap->chunkbuflen;

	mov	edx, DWORD PTR [eax+87316]
	mov	DWORD PTR [ecx+87316], edx

; 6410 :   copy->keep_alive = soap->keep_alive;

	movzx	edx, WORD PTR [eax+90412]
	mov	WORD PTR [ecx+90412], dx

; 6411 :   copy->tcp_keep_alive = soap->tcp_keep_alive;

	movzx	edx, WORD PTR [eax+90414]
	mov	WORD PTR [ecx+90414], dx

; 6412 :   copy->tcp_keep_idle = soap->tcp_keep_idle;

	mov	edx, DWORD PTR [eax+90416]
	mov	DWORD PTR [ecx+90416], edx

; 6413 :   copy->tcp_keep_intvl = soap->tcp_keep_intvl;

	mov	edx, DWORD PTR [eax+90420]
	mov	DWORD PTR [ecx+90420], edx

; 6414 :   copy->tcp_keep_cnt = soap->tcp_keep_cnt;

	mov	edx, DWORD PTR [eax+90424]
	mov	DWORD PTR [ecx+90424], edx

; 6415 :   copy->max_keep_alive = soap->max_keep_alive;

	mov	edx, DWORD PTR [eax+90428]
	mov	DWORD PTR [ecx+90428], edx

; 6416 : #ifndef WITH_NOIO
; 6417 :   copy->peer = soap->peer;

	movq	xmm0, QWORD PTR [eax+94692]
	movq	QWORD PTR [ecx+94692], xmm0
	movq	xmm0, QWORD PTR [eax+94700]
	movq	QWORD PTR [ecx+94700], xmm0

; 6418 :   copy->peerlen = soap->peerlen;

	mov	edx, DWORD PTR [eax+94708]

; 6419 : #endif
; 6420 : #ifdef WITH_OPENSSL
; 6421 :   copy->bio = soap->bio;
; 6422 :   copy->ssl = soap->ssl;
; 6423 :   copy->ctx = soap->ctx;
; 6424 : #endif
; 6425 : #ifdef WITH_ZLIB
; 6426 :   copy->zlib_state = soap->zlib_state;
; 6427 :   copy->zlib_in = soap->zlib_in;
; 6428 :   copy->zlib_out = soap->zlib_out;
; 6429 :   copy->d_stream = (z_stream*)SOAP_MALLOC(copy, sizeof(z_stream));
; 6430 :   memcpy(copy->d_stream, soap->d_stream, sizeof(z_stream));
; 6431 :   copy->z_crc = soap->z_crc;
; 6432 :   copy->z_ratio_in = soap->z_ratio_in;
; 6433 :   copy->z_ratio_out = soap->z_ratio_out;
; 6434 :   copy->z_buf = NULL;
; 6435 :   copy->z_buflen = soap->z_buflen;
; 6436 :   copy->z_level = soap->z_level;
; 6437 :   if (soap->z_buf && soap->zlib_state != SOAP_ZLIB_NONE)
; 6438 :   { copy->z_buf = (char*)SOAP_MALLOC(copy, SOAP_BUFLEN);
; 6439 :     memcpy(copy->z_buf, soap->z_buf, sizeof(soap->z_buf));
; 6440 :   }
; 6441 : #endif
; 6442 :   memcpy(copy->buf, soap->buf, sizeof(soap->buf));

	push	65536					; 00010000H
	add	eax, 12468				; 000030b4H
	mov	DWORD PTR [ecx+94708], edx
	push	eax
	add	ecx, 12468				; 000030b4H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6443 : }

	ret	0
_soap_copy_stream ENDP
_TEXT	ENDS
PUBLIC	_soap_open_logfile
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_open_logfile PROC
; _soap$ = edi
; _i$ = esi

; 6226 : { if (soap->logfile[i])

	mov	eax, DWORD PTR [edi+esi*4+90548]
	test	eax, eax
	je	SHORT $LN1@soap_open_

; 6227 :     soap->fdebug[i] = fopen(soap->logfile[i], i < 2 ? "ab" : "a");

	cmp	esi, 2
	mov	ecx, OFFSET ??_C@_02BOGAIONP@ab?$AA@
	jl	SHORT $LN5@soap_open_
	mov	ecx, OFFSET ??_C@_01MCMALHOG@a?$AA@
$LN5@soap_open_:
	push	ecx
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR [edi+esi*4+90560], eax
$LN1@soap_open_:

; 6228 : }

	ret	0
_soap_open_logfile ENDP
_TEXT	ENDS
PUBLIC	_soap_fcopy
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_st$ = 12						; size = 4
_tt$ = 16						; size = 4
_p$ = 20						; size = 4
_len$ = 24						; size = 4
_q$ = 28						; size = 4
_n$ = 32						; size = 4
_soap_fcopy PROC

; 5917 :   memcpy(p, q, n);

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR _q$[esp-4]
	mov	edx, DWORD PTR _p$[esp-4]
	push	eax
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5918 : }

	ret	0
_soap_fcopy ENDP
_TEXT	ENDS
PUBLIC	_soap_unlink
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_unlink PROC
; _soap$ = esi
; _p$ = edx

; 5664 :   register struct soap_clist **cp;
; 5665 :   if (!soap || !p)

	test	esi, esi
	je	SHORT $LN9@soap_unlin
	test	edx, edx
	je	SHORT $LN9@soap_unlin

; 5666 :     return;
; 5667 :   for (q = (char**)&soap->alist; *q; q = *(char***)q)

	cmp	DWORD PTR [esi+100], 0
	lea	eax, DWORD PTR [esi+100]
	push	edi
	je	SHORT $LN6@soap_unlin
$LL8@soap_unlin:

; 5668 :   { if (p == (void*)(*q - *(size_t*)(*q + sizeof(void*))))

	mov	ecx, DWORD PTR [eax]
	mov	edi, ecx
	sub	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	je	SHORT $LN15@soap_unlin
	mov	eax, ecx
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LL8@soap_unlin
$LN6@soap_unlin:

; 5670 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unlinked data %p\n", p));
; 5671 : #ifdef SOAP_MEM_DEBUG
; 5672 :       soap_track_unlink(soap, p);
; 5673 : #endif
; 5674 :       return;
; 5675 :     }
; 5676 :   }
; 5677 :   for (cp = &soap->clist; *cp; cp = &(*cp)->next)

	cmp	DWORD PTR [esi+96], 0
	lea	eax, DWORD PTR [esi+96]
	je	SHORT $LN19@soap_unlin
	npad	3
$LL4@soap_unlin:

; 5678 :   { if (p == (*cp)->ptr)

	mov	ecx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN16@soap_unlin
	mov	eax, ecx
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LL4@soap_unlin
	pop	edi

; 5683 :       return;
; 5684 :     }
; 5685 :   }
; 5686 : }

	ret	0
$LN15@soap_unlin:

; 5669 :     { *q = **(char***)q;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	pop	edi

; 5683 :       return;
; 5684 :     }
; 5685 :   }
; 5686 : }

	ret	0
$LN16@soap_unlin:

; 5679 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unlinked class instance %p\n", p));
; 5680 :       q = (char**)*cp;
; 5681 :       *cp = (*cp)->next;

	mov	edx, DWORD PTR [ecx]

; 5682 :       SOAP_FREE(soap, q);

	push	ecx
	mov	DWORD PTR [eax], edx
	call	_free
	add	esp, 4
$LN19@soap_unlin:
	pop	edi
$LN9@soap_unlin:

; 5683 :       return;
; 5684 :     }
; 5685 :   }
; 5686 : }

	ret	0
_soap_unlink ENDP
_TEXT	ENDS
PUBLIC	_soap_link
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_t$ = 8							; size = 4
_n$ = 12						; size = 4
_soap_link PROC
; _soap$ = esi

; 5645 :   if ((cp = (struct soap_clist*)SOAP_MALLOC(soap, sizeof(struct soap_clist))))

	push	20					; 00000014H
	call	_malloc
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_link

; 5646 :   { cp->next = soap->clist;

	mov	ecx, DWORD PTR [esi+96]

; 5647 :     cp->type = t;

	mov	edx, DWORD PTR _t$[esp-4]
	mov	DWORD PTR [eax], ecx

; 5648 :     cp->size = n;

	mov	ecx, DWORD PTR _n$[esp-4]
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], ecx

; 5649 :     cp->ptr = p;

	mov	DWORD PTR [eax+4], 0

; 5650 :     cp->fdelete = fdelete;

	mov	DWORD PTR [eax+16], OFFSET ?soap_fdelete@@YAHPAUsoap_clist@@@Z ; soap_fdelete

; 5651 :     soap->clist = cp;

	mov	DWORD PTR [esi+96], eax
$LN1@soap_link:

; 5652 :   }
; 5653 :   return cp;
; 5654 : }

	ret	0
_soap_link ENDP
_TEXT	ENDS
PUBLIC	_soap_delete
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_delete PROC
; _p$ = ecx

; 5598 : { register struct soap_clist **cp;

	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]

; 5599 :   if (soap_check_state(soap))

	test	ebx, ebx
	je	SHORT $LN10@soap_delet
	movzx	eax, WORD PTR [ebx+4]
	cmp	ax, 1
	je	SHORT $LN11@soap_delet
	cmp	ax, 2
	jne	SHORT $LN10@soap_delet
$LN11@soap_delet:
	push	esi
	push	edi

; 5600 :     return;
; 5601 :   cp = &soap->clist;

	lea	esi, DWORD PTR [ebx+96]

; 5602 :   if (p)

	test	ecx, ecx
	je	SHORT $LN15@soap_delet

; 5603 :   { while (*cp)

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN2@soap_delet
$LL8@soap_delet:

; 5604 :     { if (p == (*cp)->ptr)

	mov	eax, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN16@soap_delet

; 5614 :         return;
; 5615 :       }
; 5616 :       cp = &(*cp)->next;

	mov	esi, eax
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL8@soap_delet

; 5604 :     { if (p == (*cp)->ptr)

	jmp	SHORT $LN2@soap_delet
$LN16@soap_delet:

; 5605 :       { register struct soap_clist *q = *cp;

	mov	edi, eax

; 5606 :         *cp = q->next;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 5607 :         if (q->fdelete(q))

	mov	ecx, DWORD PTR [edi+16]
	push	edi
	call	ecx

; 5608 :         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not dealloc data %p: deletion callback failed for object type %d\n", q->ptr, q->type));
; 5609 : #ifdef SOAP_MEM_DEBUG
; 5610 :           fprintf(stderr, "new(object type = %d) = %p not freed: deletion callback failed\n", q->type, q->ptr);
; 5611 : #endif
; 5612 :         }
; 5613 :         SOAP_FREE(soap, q);

	push	edi
	call	_free
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 5635 : }

	ret	0
$LN15@soap_delet:

; 5617 :     }
; 5618 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not dealloc data %p: address not in list\n", p));
; 5619 :   }
; 5620 :   else
; 5621 :   { while (*cp)

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN2@soap_delet
$LL3@soap_delet:

; 5622 :     { register struct soap_clist *q = *cp;

	mov	edi, DWORD PTR [esi]

; 5623 :       *cp = q->next;

	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [esi], edx

; 5624 :       if (q->fdelete(q))

	mov	eax, DWORD PTR [edi+16]
	push	edi
	call	eax

; 5625 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not dealloc data %p: deletion callback failed for object type %d\n", q->ptr, q->type));
; 5626 : #ifdef SOAP_MEM_DEBUG
; 5627 :         fprintf(stderr, "new(object type = %d) = %p not freed: deletion callback failed\n", q->type, q->ptr);
; 5628 : #endif
; 5629 :       }
; 5630 :       SOAP_FREE(soap, q);

	push	edi
	call	_free
	add	esp, 8
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL3@soap_delet
$LN2@soap_delet:
	pop	edi

; 5631 :     }
; 5632 :   }
; 5633 :   soap->fault = NULL; /* this was possibly deallocated */

	mov	DWORD PTR [ebx+12208], 0

; 5634 :   soap->header = NULL; /* this was possibly deallocated */

	mov	DWORD PTR [ebx+12204], 0
	pop	esi
$LN10@soap_delet:
	pop	ebx

; 5635 : }

	ret	0
_soap_delete ENDP
_TEXT	ENDS
PUBLIC	_soap_dealloc
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_dealloc PROC
; _soap$ = esi

; 5531 : { if (soap_check_state(soap))

	push	edi
	xor	edi, edi
	cmp	esi, edi
	je	$LN11@soap_deall
	movzx	eax, WORD PTR [esi+4]
	cmp	ax, 1
	je	SHORT $LL9@soap_deall
	cmp	ax, 2
	jne	$LN11@soap_deall
	npad	1
$LL9@soap_deall:

; 5532 :     return;
; 5533 :   if (p)
; 5534 :   { register char **q;
; 5535 :     for (q = (char**)&soap->alist; *q; q = *(char***)q)
; 5536 :     {
; 5537 :       if (*(short*)(char*)(*q - sizeof(short)) != (short)SOAP_CANARY)
; 5538 :       {
; 5539 : #ifdef SOAP_MEM_DEBUG
; 5540 :         fprintf(stderr, "Data corruption in dynamic allocation (see logs)\n");
; 5541 : #endif
; 5542 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Data corruption:\n"));
; 5543 :         DBGHEX(TEST, *q - 200, 200);
; 5544 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "\n"));
; 5545 :         soap->error = SOAP_MOE;
; 5546 :         return;
; 5547 :       }
; 5548 :       if (p == (void*)(*q - *(size_t*)(*q + sizeof(void*))))
; 5549 :       { *q = **(char***)q;
; 5550 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Freed data at %p\n", p));
; 5551 :         SOAP_FREE(soap, p);
; 5552 :         return;
; 5553 :       }
; 5554 :     }
; 5555 :     soap_delete(soap, p);
; 5556 :   }
; 5557 :   else
; 5558 :   { register char *q;
; 5559 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free all soap_malloc() data\n"));
; 5560 :     while (soap->alist)

	cmp	DWORD PTR [esi+100], edi
	je	SHORT $LN2@soap_deall
	npad	11
$LL3@soap_deall:

; 5561 :     { q = (char*)soap->alist;

	mov	eax, DWORD PTR [esi+100]

; 5562 :       if (*(short*)(char*)(q - sizeof(short)) != (short)SOAP_CANARY)

	mov	ecx, -16162				; ffffc0deH
	cmp	WORD PTR [eax-2], cx
	jne	SHORT $LN21@soap_deall

; 5571 :         return;
; 5572 :       }
; 5573 :       soap->alist = *(void**)q;

	mov	edx, DWORD PTR [eax]

; 5574 :       q -= *(size_t*)(q + sizeof(void*));

	mov	ecx, eax
	mov	DWORD PTR [esi+100], edx
	sub	ecx, DWORD PTR [eax+4]

; 5575 :       SOAP_FREE(soap, q);

	push	ecx
	call	_free
	add	esp, 4
	cmp	DWORD PTR [esi+100], edi
	jne	SHORT $LL3@soap_deall
$LN2@soap_deall:

; 5576 :     }
; 5577 :     /* we must assume these were deallocated: */
; 5578 :     soap->action = NULL;
; 5579 :     soap->fault = NULL;
; 5580 :     soap->header = NULL;
; 5581 :     soap->userid = NULL;
; 5582 :     soap->passwd = NULL;
; 5583 :     soap->authrealm = NULL;
; 5584 :     soap->http_content = NULL;
; 5585 : #ifndef WITH_LEANER
; 5586 :     soap_clr_mime(soap);

	and	DWORD PTR [esi+16], -257		; fffffeffH
	mov	DWORD PTR [esi+90392], edi
	mov	DWORD PTR [esi+12208], edi
	mov	DWORD PTR [esi+12204], edi
	mov	DWORD PTR [esi+12224], edi
	mov	DWORD PTR [esi+12228], edi
	mov	DWORD PTR [esi+90396], edi
	mov	DWORD PTR [esi+36], edi
	mov	DWORD PTR [esi+90536], edi
	mov	DWORD PTR [esi+90540], edi
	mov	DWORD PTR [esi+90524], edi
	mov	DWORD PTR [esi+90528], edi
$LN11@soap_deall:
	pop	edi

; 5587 : #endif
; 5588 :   }
; 5589 : }

	ret	0
$LN21@soap_deall:

; 5563 :       {
; 5564 : #ifdef SOAP_MEM_DEBUG
; 5565 :         fprintf(stderr, "Data corruption in dynamic allocation (see logs)\n");
; 5566 : #endif
; 5567 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Data corruption:\n"));
; 5568 :         DBGHEX(TEST, q - 200, 200);
; 5569 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "\n"));
; 5570 :         soap->error = SOAP_MOE;

	mov	DWORD PTR [esi+90460], 21		; 00000015H
	pop	edi

; 5587 : #endif
; 5588 :   }
; 5589 : }

	ret	0
_soap_dealloc ENDP
_TEXT	ENDS
PUBLIC	_soap_malloc
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_malloc PROC
; _soap$ = edi
; _n$ = eax

; 5406 : { register char *p;

	push	esi
	mov	esi, eax

; 5407 :   if (!n)

	test	esi, esi
	jne	SHORT $LN5@soap_mallo

; 5408 :     return (void*)SOAP_NON_NULL;

	mov	eax, OFFSET _soap_padding
	pop	esi

; 5428 :   return p;
; 5429 : }

	ret	0
$LN5@soap_mallo:

; 5409 :   if (!soap)

	test	edi, edi
	jne	SHORT $LN4@soap_mallo

; 5410 :     return SOAP_MALLOC(soap, n);

	push	esi
	call	_malloc
	add	esp, 4
	pop	esi

; 5428 :   return p;
; 5429 : }

	ret	0
$LN4@soap_mallo:

; 5411 :   if (soap->fmalloc)

	mov	eax, DWORD PTR [edi+12336]
	test	eax, eax
	je	SHORT $LN3@soap_mallo

; 5412 :     p = (char*)soap->fmalloc(soap, n);

	push	esi
	push	edi
	call	eax
	add	esp, 8

; 5426 :   }
; 5427 :   soap->alloced = 1;

	mov	ecx, 1
	mov	WORD PTR [edi+87306], cx
	pop	esi

; 5428 :   return p;
; 5429 : }

	ret	0
$LN3@soap_mallo:

; 5413 :   else
; 5414 :   { n += sizeof(short);

	add	esi, 2

; 5415 :     n += (-(long)n) & (sizeof(void*)-1); /* align at 4-, 8- or 16-byte boundary */

	mov	eax, esi
	neg	eax
	and	eax, 3
	add	esi, eax

; 5416 :     if (!(p = (char*)SOAP_MALLOC(soap, n + sizeof(void*) + sizeof(size_t))))

	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	call	_malloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_mallo

; 5417 :     { soap->error = SOAP_EOM;

	mov	DWORD PTR [edi+90460], 20		; 00000014H
	pop	esi

; 5428 :   return p;
; 5429 : }

	ret	0
$LN1@soap_mallo:

; 5418 :       return NULL;
; 5419 :     }
; 5420 :     /* set the canary to detect corruption */
; 5421 :     *(short*)(p + n - sizeof(short)) = (short)SOAP_CANARY;

	lea	ecx, DWORD PTR [eax+esi]
	mov	edx, -16162				; ffffc0deH
	mov	WORD PTR [ecx-2], dx

; 5422 :     /* keep chain of alloced cells for destruction */
; 5423 :     *(void**)(p + n) = soap->alist;

	mov	edx, DWORD PTR [edi+100]

; 5424 :     *(size_t*)(p + n + sizeof(void*)) = n;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx

; 5425 :     soap->alist = p + n;

	mov	DWORD PTR [edi+100], ecx

; 5426 :   }
; 5427 :   soap->alloced = 1;

	mov	ecx, 1
	mov	WORD PTR [edi+87306], cx
	pop	esi

; 5428 :   return p;
; 5429 : }

	ret	0
_soap_malloc ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_soap_free_iht PROC

; 5343 : { register int i;

	push	ebx

; 5344 :   register struct soap_ilist *ip = NULL, *p = NULL;
; 5345 :   register struct soap_flist *fp = NULL, *fq = NULL;
; 5346 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free ID hashtable\n"));
; 5347 :   for (i = 0; i < SOAP_IDHASH; i++)

	mov	ebx, DWORD PTR _soap$[esp]
	push	ebp
	push	esi
	push	edi
	add	ebx, 104				; 00000068H
	mov	ebp, 1999				; 000007cfH
$LL9@soap_free_:

; 5348 :   { for (ip = soap->iht[i]; ip; ip = p)

	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	SHORT $LN4@soap_free_
$LL18@soap_free_:

; 5349 :     { for (fp = ip->flist; fp; fp = fq)

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN1@soap_free_
	npad	3
$LL3@soap_free_:

; 5350 :       { fq = fp->next;

	mov	esi, DWORD PTR [eax]

; 5351 :         SOAP_FREE(soap, fp);

	push	eax
	call	_free
	add	esp, 4
	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL3@soap_free_
$LN1@soap_free_:

; 5352 :       }
; 5353 :       p = ip->next;

	mov	esi, DWORD PTR [edi]

; 5354 :       SOAP_FREE(soap, ip);

	push	edi
	call	_free
	add	esp, 4
	mov	edi, esi
	test	esi, esi
	jne	SHORT $LL18@soap_free_
$LN4@soap_free_:

; 5355 :     }
; 5356 :     soap->iht[i] = NULL;

	mov	DWORD PTR [ebx], 0
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL9@soap_free_
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 5357 :   }
; 5358 : }

	ret	0
_soap_free_iht ENDP
; Function compile flags: /Ogtpy
_soap_init_iht PROC
; _soap$ = eax

; 5330 : { register int i;

	push	edi

; 5331 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Initializing ID hashtable\n"));
; 5332 :   for (i = 0; i < SOAP_IDHASH; i++)

	mov	edi, eax
	add	edi, 104				; 00000068H

; 5333 :     soap->iht[i] = NULL;

	mov	ecx, 1999				; 000007cfH
	xor	eax, eax
	rep stosd
	pop	edi

; 5334 : }

	ret	0
_soap_init_iht ENDP
_TEXT	ENDS
PUBLIC	_soap_set_embedded
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_set_embedded PROC
; _soap$ = ecx
; _pp$ = eax

; 5237 : { if (!pp)

	test	eax, eax
	je	SHORT $LN1@soap_set_e@2

; 5238 :     return;
; 5239 :   if (soap->mode & SOAP_IO_LENGTH)

	test	BYTE PTR [ecx+8], 8
	je	SHORT $LN2@soap_set_e@2

; 5240 :     pp->mark1 = 1;

	mov	BYTE PTR [eax+20], 1

; 5243 : }

	ret	0
$LN2@soap_set_e@2:

; 5241 :   else
; 5242 :     pp->mark2 = 1;

	mov	BYTE PTR [eax+21], 1
$LN1@soap_set_e@2:

; 5243 : }

	ret	0
_soap_set_embedded ENDP
_TEXT	ENDS
PUBLIC	_soap_is_single
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_is_single PROC
; _soap$ = ecx
; _pp$ = eax

; 5219 : { if (soap->part == SOAP_IN_HEADER)

	cmp	WORD PTR [ecx+87304], 3
	jne	SHORT $LN3@soap_is_si

; 5220 :     return 1;

	mov	eax, 1

; 5226 : }

	ret	0
$LN3@soap_is_si:

; 5221 :   if (!pp)

	test	eax, eax
	jne	SHORT $LN2@soap_is_si

; 5226 : }

	ret	0
$LN2@soap_is_si:

; 5222 :     return 0;
; 5223 :   if (soap->mode & SOAP_IO_LENGTH)

	test	BYTE PTR [ecx+8], 8
	je	SHORT $LN1@soap_is_si

; 5224 :     return pp->mark1 == 0;

	xor	ecx, ecx
	cmp	BYTE PTR [eax+20], cl
	sete	cl
	mov	eax, ecx

; 5226 : }

	ret	0
$LN1@soap_is_si:

; 5225 :   return pp->mark2 == 0;

	xor	edx, edx
	cmp	BYTE PTR [eax+21], dl
	sete	dl
	mov	eax, edx

; 5226 : }

	ret	0
_soap_is_single ENDP
_TEXT	ENDS
PUBLIC	_soap_is_embedded
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_is_embedded PROC
; _soap$ = eax
; _pp$ = ecx

; 5197 : { if (!pp)

	test	ecx, ecx
	jne	SHORT $LN4@soap_is_em

; 5198 :     return 0;

	xor	eax, eax

; 5208 : }

	ret	0
$LN4@soap_is_em:

; 5199 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Is embedded? %d %d\n", (int)pp->mark1, (int)pp->mark2));
; 5200 :   if (soap->version == 1 && soap->encodingStyle && !(soap->mode & SOAP_XML_GRAPH) && soap->part != SOAP_IN_HEADER)

	cmp	WORD PTR [eax+6], 1
	jne	SHORT $LN3@soap_is_em
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN3@soap_is_em
	mov	edx, DWORD PTR [eax+8]
	test	edx, 65536				; 00010000H
	jne	SHORT $LN3@soap_is_em
	cmp	WORD PTR [eax+87304], 3
	je	SHORT $LN3@soap_is_em

; 5201 :   { if (soap->mode & SOAP_IO_LENGTH)
; 5202 :       return pp->mark1 != 0;

	xor	eax, eax
	test	dl, 8
	je	SHORT $LN2@soap_is_em
	cmp	BYTE PTR [ecx+20], al
	setne	al

; 5208 : }

	ret	0
$LN2@soap_is_em:

; 5203 :     return pp->mark2 != 0;

	cmp	BYTE PTR [ecx+21], al
	setne	al

; 5208 : }

	ret	0
$LN3@soap_is_em:

; 5204 :   }
; 5205 :   if (soap->mode & SOAP_IO_LENGTH)

	test	BYTE PTR [eax+8], 8
	je	SHORT $LN1@soap_is_em

; 5206 :     return pp->mark1 == 1;

	xor	eax, eax
	cmp	BYTE PTR [ecx+20], 1

; 5207 :   return pp->mark2 == 1;

	sete	al

; 5208 : }

	ret	0
$LN1@soap_is_em:

; 5207 :   return pp->mark2 == 1;

	xor	eax, eax
	cmp	BYTE PTR [ecx+21], 1
	sete	al

; 5208 : }

	ret	0
_soap_is_embedded ENDP
_TEXT	ENDS
PUBLIC	_soap_end_count
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_end_count PROC
; _soap$ = esi

; 4957 : #ifndef WITH_LEANER
; 4958 :   if (soap->fpreparefinal)

	mov	eax, DWORD PTR [esi+12352]
	test	eax, eax
	je	SHORT $LN1@soap_end_c

; 4959 :     return soap->error = soap->fpreparefinal(soap);

	push	esi
	call	eax
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax

; 4963 : }

	ret	0
$LN1@soap_end_c:

; 4960 : #endif
; 4961 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End of count phase\n"));
; 4962 :   return SOAP_OK;

	xor	eax, eax

; 4963 : }

	ret	0
_soap_end_count ENDP
_TEXT	ENDS
PUBLIC	_soap_array_pointer_lookup
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_a$ = 8							; size = 4
_type$ = 12						; size = 4
_ppp$ = 16						; size = 4
_soap_array_pointer_lookup PROC
; _soap$ = edx
; _n$ = esi

; 4863 :   *ppp = NULL;
; 4864 :   if (!p || !a->__ptr)

	mov	eax, DWORD PTR _a$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	test	ebx, ebx
	jne	SHORT $LN11@soap_array

; 4865 :     return 0;

	xor	eax, eax
	pop	ebx

; 4881 : }

	ret	0
$LN11@soap_array:

; 4866 :   for (pp = soap->pht[soap_hash_ptr(a->__ptr)]; pp; pp = pp->next)

	mov	ecx, ebx
	shr	ecx, 3
	push	ebp
	and	ecx, 1023				; 000003ffH
	push	edi
	mov	edi, DWORD PTR [edx+ecx*4+8100]
	test	edi, edi
	je	SHORT $LN7@soap_array
$LL24@soap_array:

; 4867 :   { if (pp->type == type && pp->array && pp->array->__ptr == a->__ptr)

	mov	eax, DWORD PTR [edi+12]
	cmp	eax, DWORD PTR _type$[esp+8]
	jne	SHORT $LN8@soap_array
	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN8@soap_array
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN8@soap_array

; 4868 :     { register int i;
; 4869 :       for (i = 0; i < n; i++)

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN23@soap_array
	mov	edx, DWORD PTR _a$[esp+8]
	add	edx, 4
	add	ecx, 4
	npad	5
$LL5@soap_array:

; 4870 :         if (((const int*)&pp->array->__size)[i] != ((const int*)&a->__size)[i])

	mov	ebp, DWORD PTR [ecx]
	cmp	ebp, DWORD PTR [edx]
	jne	SHORT $LN23@soap_array
	inc	eax
	add	ecx, 4
	add	edx, 4
	cmp	eax, esi
	jl	SHORT $LL5@soap_array
$LN23@soap_array:

; 4871 :           break;
; 4872 :       if (i == n)

	cmp	eax, esi
	je	SHORT $LN20@soap_array
$LN8@soap_array:

; 4866 :   for (pp = soap->pht[soap_hash_ptr(a->__ptr)]; pp; pp = pp->next)

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL24@soap_array
$LN7@soap_array:
	pop	edi
	pop	ebp

; 4876 :       }
; 4877 :     }
; 4878 :   }
; 4879 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Array lookup location=%p type=%d: not found\n", a->__ptr, type));
; 4880 :   return 0;

	xor	eax, eax
	pop	ebx

; 4881 : }

	ret	0
$LN20@soap_array:

; 4873 :       { *ppp = pp;

	mov	ecx, DWORD PTR _ppp$[esp+8]

; 4874 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Array lookup location=%p type=%d id=%d\n", a->__ptr, type, pp->id));
; 4875 :         return pp->id;

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [ecx], edi
	pop	edi
	pop	ebp
	pop	ebx

; 4881 : }

	ret	0
_soap_array_pointer_lookup ENDP
_TEXT	ENDS
PUBLIC	_soap_pointer_enter
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_p$ = 8							; size = 4
_type$ = 12						; size = 4
_ppp$ = 16						; size = 4
_soap_pointer_enter PROC
; _soap$ = esi
; _a$ = edi

; 4825 :   register struct soap_plist *pp;
; 4826 :   if (!soap->pblk || soap->pidx >= SOAP_PTRBLK)

	cmp	DWORD PTR [esi+12196], 0
	push	ebp
	mov	ebp, DWORD PTR _p$[esp]
	je	SHORT $LN4@soap_point
	cmp	WORD PTR [esi+12200], 32		; 00000020H
	jl	SHORT $LN5@soap_point
$LN4@soap_point:

; 4827 :   { register struct soap_pblk *pb = (struct soap_pblk*)SOAP_MALLOC(soap, sizeof(struct soap_pblk));

	push	772					; 00000304H
	call	_malloc
	add	esp, 4

; 4828 :     if (!pb)

	test	eax, eax
	jne	SHORT $LN3@soap_point

; 4829 :     { soap->error = SOAP_EOM;

	mov	DWORD PTR [esi+90460], 20		; 00000014H
	pop	ebp

; 4850 :   return pp->id;
; 4851 : }

	ret	0
$LN3@soap_point:

; 4830 :       return 0;
; 4831 :     }
; 4832 :     pb->next = soap->pblk;

	mov	ecx, DWORD PTR [esi+12196]
	mov	DWORD PTR [eax], ecx

; 4833 :     soap->pblk = pb;
; 4834 :     soap->pidx = 0;

	xor	edx, edx
	mov	DWORD PTR [esi+12196], eax
	mov	WORD PTR [esi+12200], dx
$LN5@soap_point:

; 4835 :   }
; 4836 :   *ppp = pp = &soap->pblk->plist[soap->pidx++];

	movzx	eax, WORD PTR [esi+12200]
	mov	edx, DWORD PTR [esi+12196]
	movsx	ecx, ax
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [edx+ecx*8+4]
	mov	edx, DWORD PTR _ppp$[esp]
	inc	eax
	mov	DWORD PTR [edx], ecx
	mov	WORD PTR [esi+12200], ax

; 4837 :   if (a)

	test	edi, edi
	je	SHORT $LN2@soap_point

; 4838 :     h = soap_hash_ptr(a->__ptr);

	mov	eax, DWORD PTR [edi]

; 4839 :   else

	jmp	SHORT $LN8@soap_point
$LN2@soap_point:

; 4840 :     h = soap_hash_ptr(p);

	mov	eax, ebp
$LN8@soap_point:
	shr	eax, 3
	and	eax, 1023				; 000003ffH

; 4841 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Pointer enter location=%p array=%p size=%d dim=%d type=%d id=%d\n", p, a?a->__ptr:NULL, a?a->__size:0, n, type, soap->idnum+1));
; 4842 :   pp->next = soap->pht[h];

	mov	edx, DWORD PTR [esi+eax*4+8100]
	mov	DWORD PTR [ecx], edx

; 4843 :   pp->type = type;

	mov	edx, DWORD PTR _type$[esp]

; 4844 :   pp->mark1 = 0;
; 4845 :   pp->mark2 = 0;
; 4846 :   pp->ptr = p;

	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [ecx+12], edx
	mov	BYTE PTR [ecx+20], 0
	mov	BYTE PTR [ecx+21], 0

; 4847 :   pp->array = a;

	mov	DWORD PTR [ecx+8], edi

; 4848 :   soap->pht[h] = pp;

	mov	DWORD PTR [esi+eax*4+8100], ecx

; 4849 :   pp->id = ++soap->idnum;

	inc	DWORD PTR [esi+12212]
	mov	eax, DWORD PTR [esi+12212]
	mov	DWORD PTR [ecx+16], eax
	pop	ebp

; 4850 :   return pp->id;
; 4851 : }

	ret	0
_soap_pointer_enter ENDP
_TEXT	ENDS
PUBLIC	_soap_pointer_lookup
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_pointer_lookup PROC
; _soap$ = edi
; _p$ = ecx
; _type$ = esi
; _ppp$ = edx

; 4801 :   *ppp = NULL;

	mov	DWORD PTR [edx], 0

; 4802 :   if (p)

	test	ecx, ecx
	je	SHORT $LN2@soap_point@2

; 4803 :   { for (pp = soap->pht[soap_hash_ptr(p)]; pp; pp = pp->next)

	mov	eax, ecx
	shr	eax, 3
	and	eax, 1023				; 000003ffH
	mov	eax, DWORD PTR [edi+eax*4+8100]
	test	eax, eax
	je	SHORT $LN2@soap_point@2
	npad	1
$LL4@soap_point@2:

; 4804 :     { if (pp->ptr == p && pp->type == type)

	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN3@soap_point@2
	cmp	DWORD PTR [eax+12], esi
	je	SHORT $LN9@soap_point@2
$LN3@soap_point@2:

; 4803 :   { for (pp = soap->pht[soap_hash_ptr(p)]; pp; pp = pp->next)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL4@soap_point@2
$LN2@soap_point@2:

; 4808 :       }
; 4809 :     }
; 4810 :   }
; 4811 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Lookup location=%p type=%d: not found\n", p, type));
; 4812 :   return 0;

	xor	eax, eax

; 4813 : }

	ret	0
$LN9@soap_point@2:

; 4805 :       { *ppp = pp;

	mov	DWORD PTR [edx], eax

; 4806 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Lookup location=%p type=%d id=%d\n", p, type, pp->id));
; 4807 :         return pp->id;

	mov	eax, DWORD PTR [eax+16]

; 4813 : }

	ret	0
_soap_pointer_lookup ENDP
_TEXT	ENDS
PUBLIC	_soap_embed
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_embed PROC
; _p$ = eax
; _type$ = edx

; 4774 : { register int i;

	push	esi
	mov	esi, DWORD PTR _soap$[esp]

; 4775 :   struct soap_plist *pp;
; 4776 :   if (soap->version != 1)

	cmp	WORD PTR [esi+6], 1
	push	edi
	je	SHORT $LN5@soap_embed

; 4777 :     soap->encoding = 1;

	mov	ecx, 1
	mov	WORD PTR [esi+87296], cx
$LN5@soap_embed:

; 4778 :   if (a)
; 4779 :     i = soap_array_pointer_lookup(soap, p, a, n, type, &pp);
; 4780 :   else
; 4781 :     i = soap_pointer_lookup(soap, p, type, &pp);

	test	eax, eax
	je	SHORT $LN25@soap_embed
	mov	ecx, eax
	shr	ecx, 3
	and	ecx, 1023				; 000003ffH
	mov	ecx, DWORD PTR [esi+ecx*4+8100]
	test	ecx, ecx
	je	SHORT $LN25@soap_embed
$LL27@soap_embed:
	cmp	DWORD PTR [ecx+4], eax
	jne	SHORT $LN26@soap_embed
	cmp	DWORD PTR [ecx+12], edx
	je	SHORT $LN42@soap_embed
$LN26@soap_embed:
	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LL27@soap_embed
$LN25@soap_embed:
	xor	edi, edi

; 4786 :     soap_set_embedded(soap, pp);

$LN36@soap_embed:

; 4787 :   }
; 4788 :   return i;

	mov	eax, edi
	pop	edi
	pop	esi

; 4789 : }

	ret	0
$LN42@soap_embed:

; 4778 :   if (a)
; 4779 :     i = soap_array_pointer_lookup(soap, p, a, n, type, &pp);
; 4780 :   else
; 4781 :     i = soap_pointer_lookup(soap, p, type, &pp);

	mov	edi, DWORD PTR [ecx+16]

; 4782 :   if (i)

	test	edi, edi
	je	SHORT $LN36@soap_embed

; 4783 :   { if (soap_is_embedded(soap, pp)
; 4784 :      || soap_is_single(soap, pp))

	mov	eax, esi
	call	_soap_is_embedded
	test	eax, eax
	jne	SHORT $LN1@soap_embed
	cmp	WORD PTR [esi+87304], 3
	je	SHORT $LN1@soap_embed
	mov	esi, DWORD PTR [esi+8]
	and	esi, 8
	je	SHORT $LN31@soap_embed
	cmp	BYTE PTR [ecx+20], al
	jmp	SHORT $LN44@soap_embed
$LN31@soap_embed:
	cmp	BYTE PTR [ecx+21], 0
$LN44@soap_embed:
	sete	al
	test	eax, eax
	jne	SHORT $LN1@soap_embed

; 4786 :     soap_set_embedded(soap, pp);

	test	esi, esi
	je	SHORT $LN37@soap_embed

; 4787 :   }
; 4788 :   return i;

	mov	eax, edi
	pop	edi
	mov	BYTE PTR [ecx+20], 1
	pop	esi

; 4789 : }

	ret	0

; 4786 :     soap_set_embedded(soap, pp);

$LN37@soap_embed:

; 4787 :   }
; 4788 :   return i;

	mov	eax, edi
	pop	edi
	mov	BYTE PTR [ecx+21], 1
	pop	esi

; 4789 : }

	ret	0
$LN1@soap_embed:
	pop	edi

; 4785 :       return 0;

	xor	eax, eax
	pop	esi

; 4789 : }

	ret	0
_soap_embed ENDP
; Function compile flags: /Ogtpy
_soap_free_pht PROC
; _soap$ = eax

; 4752 : { register struct soap_pblk *pb, *next;

	push	edi
	mov	edi, eax

; 4753 :   register int i;
; 4754 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free pointer hashtable\n"));
; 4755 :   for (pb = soap->pblk; pb; pb = next)

	mov	eax, DWORD PTR [edi+12196]
	test	eax, eax
	je	SHORT $LN4@soap_free_@2
	push	esi
	npad	2
$LL6@soap_free_@2:

; 4756 :   { next = pb->next;

	mov	esi, DWORD PTR [eax]

; 4757 :     SOAP_FREE(soap, pb);

	push	eax
	call	_free
	add	esp, 4
	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL6@soap_free_@2
	pop	esi
$LN4@soap_free_@2:

; 4758 :   }
; 4759 :   soap->pblk = NULL;
; 4760 :   soap->pidx = 0;

	xor	eax, eax
	mov	DWORD PTR [edi+12196], 0
	mov	WORD PTR [edi+12200], ax
	add	edi, 8100				; 00001fa4H

; 4761 :   for (i = 0; i < (int)SOAP_PTRHASH; i++)
; 4762 :     soap->pht[i] = NULL;

	mov	ecx, 1024				; 00000400H
	rep stosd
	pop	edi

; 4763 : }

	ret	0
_soap_free_pht ENDP
_TEXT	ENDS
PUBLIC	_soap_del
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_del PROC
; _soap$ = eax

; 4743 : { free(soap);

	push	eax
	call	_free
	pop	ecx

; 4744 : }

	ret	0
_soap_del ENDP
; Function compile flags: /Ogtpy
_soap_init_pht PROC
; _soap$ = eax

; 4684 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Initializing pointer hashtable\n"));
; 4685 :   soap->pblk = NULL;
; 4686 :   soap->pidx = 0;

	xor	ecx, ecx
	push	edi
	mov	WORD PTR [eax+12200], cx
	mov	DWORD PTR [eax+12196], 0
	lea	edi, DWORD PTR [eax+8100]

; 4687 :   for (i = 0; i < (int)SOAP_PTRHASH; i++)
; 4688 :     soap->pht[i] = NULL;

	mov	ecx, 1024				; 00000400H
	xor	eax, eax
	rep stosd
	pop	edi

; 4689 : }

	ret	0
_soap_init_pht ENDP
_TEXT	ENDS
PUBLIC	_soap_hash
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_hash PROC
; _s$ = edx

; 4671 :   while (*s)

	mov	al, BYTE PTR [edx]
	xor	ecx, ecx
	test	al, al
	je	SHORT $LN1@soap_hash
	npad	8
$LL2@soap_hash:

; 4672 :     h = 65599*h + *s++;

	imul	ecx, 65599				; 0001003fH
	movsx	eax, al
	inc	edx
	add	ecx, eax
	mov	al, BYTE PTR [edx]
	test	al, al
	jne	SHORT $LL2@soap_hash
$LN1@soap_hash:

; 4673 :   return h % SOAP_IDHASH;

	mov	eax, 105279339				; 06466f6bH
	mul	ecx
	mov	eax, ecx
	sub	eax, edx
	shr	eax, 1
	add	eax, edx
	shr	eax, 10					; 0000000aH
	mov	edx, eax
	imul	edx, 1999				; 000007cfH
	mov	eax, ecx
	sub	eax, edx

; 4674 : }

	ret	0
_soap_hash ENDP
_TEXT	ENDS
PUBLIC	_soap_closesock
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_closesock PROC
; _soap$ = esi

; 4646 : { register int status = soap->error;

	push	edi
	mov	edi, DWORD PTR [esi+90460]

; 4647 :   if (status == SOAP_EOF || status == SOAP_TCP_ERROR || status == SOAP_SSL_ERROR || !soap->keep_alive)

	cmp	edi, -1
	je	SHORT $LN2@soap_close
	cmp	edi, 28					; 0000001cH
	je	SHORT $LN2@soap_close
	cmp	edi, 30					; 0000001eH
	je	SHORT $LN2@soap_close
	cmp	WORD PTR [esi+90412], 0
	jne	SHORT $LN3@soap_close
$LN2@soap_close:

; 4648 :   { if (soap->fclose && (soap->error = soap->fclose(soap)))

	mov	eax, DWORD PTR [esi+12304]
	test	eax, eax
	je	SHORT $LN1@soap_close
	push	esi
	call	eax
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax

; 4649 :       return soap->error;

	jne	SHORT $LN4@soap_close
$LN1@soap_close:

; 4650 :     soap->keep_alive = 0;

	xor	eax, eax
	mov	WORD PTR [esi+90412], ax
$LN3@soap_close:

; 4651 :   }
; 4652 : #ifdef WITH_ZLIB
; 4653 :   if (soap->zlib_state == SOAP_ZLIB_DEFLATE)
; 4654 :     deflateEnd(soap->d_stream);
; 4655 :   else if (soap->zlib_state == SOAP_ZLIB_INFLATE)
; 4656 :     inflateEnd(soap->d_stream);
; 4657 :   soap->zlib_state = SOAP_ZLIB_NONE;
; 4658 : #endif
; 4659 :   return soap->error = status;

	mov	DWORD PTR [esi+90460], edi
	mov	eax, edi
$LN4@soap_close:
	pop	edi

; 4660 : }

	ret	0
_soap_closesock ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_fd$ = 12						; size = 4
_how$ = 16						; size = 4
_tcp_shutdownsocket PROC

; 4635 :   return shutdown(fd, how);

	mov	eax, DWORD PTR _how$[esp-4]
	mov	ecx, DWORD PTR _fd$[esp-4]
	push	eax
	push	ecx
	call	_shutdown@8

; 4636 : }

	ret	0
_tcp_shutdownsocket ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_fd$ = 12						; size = 4
_tcp_closesocket PROC

; 4624 :   return soap_closesocket(fd);

	mov	eax, DWORD PTR _fd$[esp-4]
	push	eax
	call	_closesocket@4

; 4625 : }

	ret	0
_tcp_closesocket ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_tcp_disconnect PROC

; 4537 : {

	push	esi

; 4538 : #ifdef WITH_OPENSSL
; 4539 :   if (soap->ssl)
; 4540 :   { int r, s = 0;
; 4541 :     if (soap->session)
; 4542 :     { SSL_SESSION_free(soap->session);
; 4543 :       soap->session = NULL;
; 4544 :     }
; 4545 :     if (*soap->host)
; 4546 :     { soap->session = SSL_get1_session(soap->ssl);
; 4547 :       if (soap->session)
; 4548 :       { strcpy(soap->session_host, soap->host);
; 4549 :         soap->session_port = soap->port;
; 4550 :       }
; 4551 :     }
; 4552 :     r = SSL_shutdown(soap->ssl);
; 4553 :     if (r == 0)
; 4554 :     { if (soap_valid_socket(soap->socket))
; 4555 :       { struct timeval timeout;
; 4556 :         fd_set fd;
; 4557 :         if (soap->fshutdownsocket(soap, soap->socket, 1))
; 4558 :         { /*
; 4559 :           wait up to 10 seconds for close_notify to be sent by peer (if peer not
; 4560 :           present, this avoids calling SSL_shutdown() which has a lengthy return
; 4561 :           timeout)
; 4562 :           */
; 4563 : #ifndef WIN32
; 4564 :           if ((int)soap->socket < (int)FD_SETSIZE)
; 4565 :           {
; 4566 : #endif
; 4567 :             timeout.tv_sec = 10;
; 4568 :             timeout.tv_usec = 0;
; 4569 :             FD_ZERO(&fd);
; 4570 :             FD_SET(soap->socket, &fd);
; 4571 :             r = select((int)soap->socket + 1, &fd, NULL, &fd, &timeout);
; 4572 :             if (r <= 0 && soap_socket_errno(soap->socket) != SOAP_EINTR)
; 4573 :             { soap->errnum = 0;
; 4574 :               DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Connection lost...\n"));
; 4575 :               soap->fclosesocket(soap, soap->socket);
; 4576 :               soap->socket = SOAP_INVALID_SOCKET;
; 4577 :               SSL_free(soap->ssl);
; 4578 :               soap->ssl = NULL;
; 4579 :               ERR_remove_state(0);
; 4580 :               return SOAP_OK;
; 4581 :             }
; 4582 : #ifndef WIN32
; 4583 :           }
; 4584 : #endif
; 4585 :         }
; 4586 :       }
; 4587 :       r = SSL_shutdown(soap->ssl);
; 4588 :     }
; 4589 :     if (r != 1)
; 4590 :     { s = ERR_get_error();
; 4591 :       if (s)
; 4592 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Shutdown failed: %d\n", SSL_get_error(soap->ssl, r)));
; 4593 :         if (soap_valid_socket(soap->socket) && !(soap->omode & SOAP_IO_UDP))
; 4594 :         { soap->fclosesocket(soap, soap->socket);
; 4595 :           soap->socket = SOAP_INVALID_SOCKET;
; 4596 :         }
; 4597 :         SSL_free(soap->ssl);
; 4598 :         soap->ssl = NULL;
; 4599 :         ERR_remove_state(0);
; 4600 :         return SOAP_SSL_ERROR;
; 4601 :       }
; 4602 :     }
; 4603 :     SSL_free(soap->ssl);
; 4604 :     soap->ssl = NULL;
; 4605 :     ERR_remove_state(0);
; 4606 :   }
; 4607 : #endif
; 4608 :   if (soap_valid_socket(soap->socket) && !(soap->omode & SOAP_IO_UDP))

	mov	esi, DWORD PTR _soap$[esp]
	mov	eax, DWORD PTR [esi+12408]
	cmp	eax, -1
	je	SHORT $LN5@tcp_discon
	test	BYTE PTR [esi+16], 4
	jne	SHORT $LN5@tcp_discon

; 4609 :   { soap->fshutdownsocket(soap, soap->socket, 2);

	push	2
	push	eax
	mov	eax, DWORD PTR [esi+12292]
	push	esi
	call	eax

; 4610 :     soap->fclosesocket(soap, soap->socket);

	mov	ecx, DWORD PTR [esi+12408]
	mov	edx, DWORD PTR [esi+12288]
	push	ecx
	push	esi
	call	edx
	add	esp, 20					; 00000014H

; 4611 :     soap->socket = SOAP_INVALID_SOCKET;

	mov	DWORD PTR [esi+12408], -1
$LN5@tcp_discon:

; 4612 :   }
; 4613 :   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 4614 : }

	ret	0
_tcp_disconnect ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_a$ = 16						; size = 4
_n$ = 20						; size = 4
_tcp_accept PROC

; 4358 :   fd = accept(s, a, (SOAP_SOCKLEN_T*)n);	/* portability note: see SOAP_SOCKLEN_T definition in stdsoap2.h */

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR _a$[esp-4]
	mov	edx, DWORD PTR _s$[esp-4]
	push	eax
	push	ecx
	push	edx
	call	_accept@12

; 4359 : #ifdef SOCKET_CLOSE_ON_EXEC
; 4360 : #ifdef WIN32
; 4361 : #ifndef UNDER_CE
; 4362 :   SetHandleInformation((HANDLE)fd, HANDLE_FLAG_INHERIT, 0);
; 4363 : #endif
; 4364 : #else
; 4365 :   fcntl(fd, F_SETFD, FD_CLOEXEC);
; 4366 : #endif
; 4367 : #endif
; 4368 :   return fd;
; 4369 : }

	ret	0
_tcp_accept ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_addr$ = 12						; size = 4
_inaddr$ = 16						; size = 4
_tcp_gethost PROC

; 3487 : { soap_int32 iadd = -1;

	push	esi

; 3488 :   struct hostent hostent, *host = &hostent;
; 3489 : #ifdef VXWORKS
; 3490 :   int hostint;
; 3491 :   /* inet_addr(), and hostGetByName() expect "char *"; addr is a "const char *". */
; 3492 :   iadd = inet_addr((char*)addr);
; 3493 : #else
; 3494 : #if defined(_AIX43) || defined(TRU64)
; 3495 :   struct hostent_data ht_data;
; 3496 : #endif
; 3497 : #ifdef AS400
; 3498 :   iadd = inet_addr((void*)addr);
; 3499 : #else
; 3500 :   iadd = inet_addr(addr);

	mov	esi, DWORD PTR _addr$[esp]
	push	esi
	call	_inet_addr@4

; 3501 : #endif
; 3502 : #endif
; 3503 :   if (iadd != -1)

	cmp	eax, -1
	je	SHORT $LN3@tcp_gethos

; 3504 :   { memcpy(inaddr, &iadd, sizeof(iadd));

	mov	ecx, DWORD PTR _inaddr$[esp]
	mov	DWORD PTR [ecx], eax

; 3544 : #endif
; 3545 :   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 3546 : }

	ret	0
$LN3@tcp_gethos:

; 3505 :     return SOAP_OK;
; 3506 :   }
; 3507 : #if defined(__GLIBC__) || (defined(HAVE_GETHOSTBYNAME_R) && (defined(FREEBSD) || defined(__FreeBSD__)))
; 3508 :   if (gethostbyname_r(addr, &hostent, soap->buf, SOAP_BUFLEN, &host, &soap->errnum) < 0)
; 3509 :     host = NULL;
; 3510 : #elif defined(_AIX43) || defined(TRU64)
; 3511 :   memset((void*)&ht_data, 0, sizeof(ht_data));
; 3512 :   if (gethostbyname_r(addr, &hostent, &ht_data) < 0)
; 3513 :   { host = NULL;
; 3514 :     soap->errnum = h_errno;
; 3515 :   }
; 3516 : #elif defined(HAVE_GETHOSTBYNAME_R)
; 3517 :   host = gethostbyname_r(addr, &hostent, soap->buf, SOAP_BUFLEN, &soap->errnum);
; 3518 : #elif defined(VXWORKS)
; 3519 :   /* If the DNS resolver library resolvLib has been configured in the vxWorks
; 3520 :    * image, a query for the host IP address is sent to the DNS server, if the
; 3521 :    * name was not found in the local host table. */
; 3522 :   hostint = hostGetByName((char*)addr);
; 3523 :   if (hostint == ERROR)
; 3524 :   { host = NULL;
; 3525 :     soap->errnum = soap_errno;
; 3526 :   }
; 3527 : #else
; 3528 : #ifdef AS400
; 3529 :   if (!(host = gethostbyname((void*)addr)))
; 3530 :     soap->errnum = h_errno;
; 3531 : #else
; 3532 :   if (!(host = gethostbyname(addr)))

	push	esi
	call	_gethostbyname@4
	test	eax, eax
	jne	SHORT $LN1@tcp_gethos

; 3533 :     soap->errnum = h_errno;

	call	_WSAGetLastError@0
	mov	edx, DWORD PTR _soap$[esp]
	mov	DWORD PTR [edx+90468], eax

; 3534 : #endif
; 3535 : #endif
; 3536 :   if (!host)
; 3537 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Host name not found\n"));
; 3538 :     return SOAP_ERR;

	or	eax, -1
	pop	esi

; 3546 : }

	ret	0
$LN1@tcp_gethos:

; 3539 :   }
; 3540 : #ifdef VXWORKS
; 3541 :   inaddr->s_addr = hostint;
; 3542 : #else
; 3543 :   memcpy(inaddr, host->h_addr, host->h_length);

	movsx	ecx, WORD PTR [eax+10]
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _inaddr$[esp+4]
	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3544 : #endif
; 3545 :   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 3546 : }

	ret	0
_tcp_gethost ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	___security_cookie:DWORD
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_w$79630 = -412						; size = 400
__$ArrayPad$ = -8					; size = 4
_tcp_init PROC

; 3282 : { soap->errmode = 1;

	sub	esp, 412				; 0000019cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+412], eax

; 3283 : #ifdef WIN32
; 3284 :   if (tcp_done)
; 3285 :     return 0;
; 3286 :   else
; 3287 :   { WSADATA w;
; 3288 :     if (WSAStartup(MAKEWORD(1, 1), &w))

	lea	eax, DWORD PTR _w$79630[esp+412]
	push	eax
	push	257					; 00000101H
	call	_WSAStartup@8
	test	eax, eax
	je	SHORT $LN1@tcp_init

; 3289 :       return -1;

	or	eax, -1

; 3290 :     tcp_done = 1;
; 3291 :   }
; 3292 : #endif
; 3293 :   return 0;
; 3294 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+412]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 412				; 0000019cH
	ret	0
$LN1@tcp_init:
	mov	ecx, DWORD PTR __$ArrayPad$[esp+412]
	xor	ecx, esp
	mov	DWORD PTR _tcp_done, 1
	xor	eax, eax
	call	@__security_check_cookie@4
	add	esp, 412				; 0000019cH
	ret	0
_tcp_init ENDP
_TEXT	ENDS
PUBLIC	_soap_tag_cmp
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_s$ = 8							; size = 4
_t$ = 12						; size = 4
_soap_tag_cmp PROC

; 2809 : { for (;;)

	push	ebx
	push	esi

; 2810 :   { register int c1 = *s;

	mov	esi, DWORD PTR _s$[esp+4]
	movsx	eax, BYTE PTR [esi]
	push	edi

; 2811 :     register int c2 = *t;

	mov	edi, DWORD PTR _t$[esp+8]
	movsx	ecx, BYTE PTR [edi]

; 2812 :     if (!c1 || c1 == '"')

	test	eax, eax
	je	$LN4@soap_tag_c
	npad	7
$LL19@soap_tag_c:
	cmp	eax, 34					; 00000022H
	je	$LN4@soap_tag_c

; 2813 :       break;
; 2814 :     if (c2 != '-')

	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN11@soap_tag_c

; 2815 :     { if (c1 != c2)

	cmp	eax, ecx
	je	SHORT $LN11@soap_tag_c

; 2816 :       { if (c1 >= 'A' && c1 <= 'Z')

	lea	edx, DWORD PTR [eax-65]
	cmp	edx, 25					; 00000019H
	ja	SHORT $LN13@soap_tag_c

; 2817 :           c1 += 'a' - 'A';

	add	eax, 32					; 00000020H
$LN13@soap_tag_c:

; 2818 :         if (c2 >= 'A' && c2 <= 'Z')

	lea	edx, DWORD PTR [ecx-65]
	cmp	edx, 25					; 00000019H
	ja	SHORT $LN12@soap_tag_c

; 2819 :           c2 += 'a' - 'A';

	add	ecx, 32					; 00000020H
$LN12@soap_tag_c:

; 2820 :       }
; 2821 :       if (c1 != c2)

	cmp	eax, ecx
	jne	SHORT $LN25@soap_tag_c
$LN11@soap_tag_c:

; 2810 :   { register int c1 = *s;

	movsx	eax, BYTE PTR [esi+1]

; 2811 :     register int c2 = *t;

	movsx	ecx, BYTE PTR [edi+1]

; 2838 :         }
; 2839 :         break;
; 2840 :       }
; 2841 :     }
; 2842 :     s++;

	inc	esi

; 2843 :     t++;

	inc	edi
	test	eax, eax
	jne	SHORT $LL19@soap_tag_c

; 2835 :           if (c1 == c2 && !soap_tag_cmp(s + 1, t + 1))

	jmp	SHORT $LN4@soap_tag_c
$LN25@soap_tag_c:

; 2822 :       { if (c2 != '*')

	cmp	ecx, 42					; 0000002aH
	je	SHORT $LN10@soap_tag_c
	pop	edi
	pop	esi

; 2823 :           return 1;

	mov	eax, 1
	pop	ebx

; 2848 : }

	ret	0
$LN10@soap_tag_c:

; 2824 :         c2 = *++t;

	movsx	ebx, BYTE PTR [edi+1]
	inc	edi

; 2825 :         if (!c2)

	test	ebx, ebx
	jne	SHORT $LN9@soap_tag_c
$LN27@soap_tag_c:
	pop	edi
	pop	esi

; 2826 :           return 0;

	xor	eax, eax
	pop	ebx

; 2848 : }

	ret	0
$LN9@soap_tag_c:

; 2827 :         if (c2 >= 'A' && c2 <= 'Z')

	lea	eax, DWORD PTR [ebx-65]
	cmp	eax, 25					; 00000019H
	ja	SHORT $LN23@soap_tag_c

; 2828 :           c2 += 'a' - 'A';

	add	ebx, 32					; 00000020H
$LN23@soap_tag_c:

; 2829 :         for (;;)
; 2830 :         { c1 = *s;

	movsx	eax, BYTE PTR [esi]

; 2831 :           if (!c1 || c1 == '"')

	test	eax, eax
	je	SHORT $LN4@soap_tag_c
	npad	5
$LL7@soap_tag_c:
	cmp	eax, 34					; 00000022H
	je	SHORT $LN4@soap_tag_c

; 2832 :             break;
; 2833 :           if (c1 >= 'A' && c1 <= 'Z')

	lea	ecx, DWORD PTR [eax-65]
	cmp	ecx, 25					; 00000019H
	ja	SHORT $LN3@soap_tag_c

; 2834 :             c1 += 'a' - 'A';

	add	eax, 32					; 00000020H
$LN3@soap_tag_c:

; 2835 :           if (c1 == c2 && !soap_tag_cmp(s + 1, t + 1))

	cmp	eax, ebx
	jne	SHORT $LN2@soap_tag_c
	lea	edx, DWORD PTR [edi+1]
	push	edx
	lea	eax, DWORD PTR [esi+1]
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@soap_tag_c
$LN2@soap_tag_c:

; 2829 :         for (;;)
; 2830 :         { c1 = *s;

	movsx	eax, BYTE PTR [esi+1]

; 2836 :             return 0;
; 2837 :           s++;

	inc	esi
	test	eax, eax
	jne	SHORT $LL7@soap_tag_c
$LN4@soap_tag_c:

; 2844 :   }
; 2845 :   if (*t == '*' && !t[1])

	mov	al, BYTE PTR [edi]
	cmp	al, 42					; 0000002aH
	jne	SHORT $LN1@soap_tag_c
	cmp	BYTE PTR [edi+1], 0

; 2846 :     return 0;

	je	SHORT $LN27@soap_tag_c
$LN1@soap_tag_c:
	pop	edi
	pop	esi

; 2847 :   return *t;

	movsx	eax, al
	pop	ebx

; 2848 : }

	ret	0
_soap_tag_cmp ENDP
_TEXT	ENDS
PUBLIC	_soap_match_namespace
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_id1$ = 12						; size = 4
_id2$ = 16						; size = 4
_n2$ = 20						; size = 4
_soap_match_namespace PROC
; _n1$ = eax

; 2755 : { register struct soap_nlist *np = soap->nlist;

	push	ebx
	mov	ebx, DWORD PTR _id1$[esp]
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+4]
	push	esi
	mov	esi, DWORD PTR [ebp+88]
	push	edi
	mov	edi, eax

; 2756 :   while (np && (strncmp(np->id, id1, n1) || np->id[n1]))

	test	esi, esi
	je	SHORT $LN5@soap_match@2
$LL8@soap_match@2:
	push	edi
	lea	eax, DWORD PTR [esi+16]
	push	ebx
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@soap_match@2
	cmp	BYTE PTR [esi+edi+16], al
	je	SHORT $LN7@soap_match@2
$LN6@soap_match@2:

; 2757 :     np = np->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL8@soap_match@2
$LN5@soap_match@2:

; 2765 :   }
; 2766 :   if (n1 == 3 && n1 == n2 && !strncmp(id1, "xml", 3) && !strncmp(id1, id2, 3))

	cmp	edi, 3
	jne	SHORT $LN1@soap_match@2
	cmp	DWORD PTR _n2$[esp+12], edi
	jne	SHORT $LN1@soap_match@2
	push	edi
	push	OFFSET ??_C@_03PJHHNEEI@xml?$AA@
	push	ebx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@soap_match@2
	mov	edx, DWORD PTR _id2$[esp+12]
	push	edi
	push	edx
	push	ebx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax

; 2767 :     return SOAP_OK;

	je	SHORT $LN4@soap_match@2
$LN1@soap_match@2:
	pop	edi

; 2768 :   return soap->error = SOAP_SYNTAX_ERROR;

	mov	eax, 5
	pop	esi
	mov	DWORD PTR [ebp+90460], eax
	pop	ebp
	pop	ebx

; 2769 : }

	ret	0
$LN7@soap_match@2:

; 2758 :   if (np)

	test	esi, esi
	je	SHORT $LN5@soap_match@2

; 2759 :   { if (np->index < 0
; 2760 :      || (soap->local_namespaces[np->index].id
; 2761 :       && (strncmp(soap->local_namespaces[np->index].id, id2, n2)
; 2762 :        || soap->local_namespaces[np->index].id[n2])))

	movzx	eax, WORD PTR [esi+8]
	test	ax, ax
	jl	SHORT $LN2@soap_match@2
	mov	edx, DWORD PTR [ebp+84]
	movsx	ecx, ax
	shl	ecx, 4
	mov	eax, DWORD PTR [ecx+edx]
	test	eax, eax
	je	SHORT $LN4@soap_match@2
	mov	edi, DWORD PTR _n2$[esp+12]
	mov	ecx, DWORD PTR _id2$[esp+12]
	push	edi
	push	ecx
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@soap_match@2
	movsx	edx, WORD PTR [esi+8]
	mov	eax, DWORD PTR [ebp+84]
	shl	edx, 4
	mov	ecx, DWORD PTR [edx+eax]
	cmp	BYTE PTR [edi+ecx], 0
	jne	SHORT $LN2@soap_match@2
$LN4@soap_match@2:
	pop	edi
	pop	esi
	pop	ebp

; 2764 :     return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 2769 : }

	ret	0
$LN2@soap_match@2:
	pop	edi
	pop	esi
	pop	ebp

; 2763 :       return SOAP_NAMESPACE;

	mov	eax, 9
	pop	ebx

; 2769 : }

	ret	0
_soap_match_namespace ENDP
_TEXT	ENDS
PUBLIC	_soap_pop_namespace
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_pop_namespace PROC
; _soap$ = edi

; 2740 :   for (np = soap->nlist; np && np->level >= soap->level; np = nq)

	mov	eax, DWORD PTR [edi+88]
	test	eax, eax
	je	SHORT $LN8@soap_pop_n
	push	esi
	npad	8
$LL3@soap_pop_n:
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [edi+12444]
	jb	SHORT $LN9@soap_pop_n

; 2741 :   { nq = np->next;

	mov	esi, DWORD PTR [eax]

; 2742 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Pop namespace binding (level=%u) '%s'\n", soap->level, np->id));
; 2743 :     SOAP_FREE(soap, np);

	push	eax
	call	_free
	add	esp, 4
	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL3@soap_pop_n
$LN9@soap_pop_n:
	pop	esi
$LN8@soap_pop_n:

; 2744 :   }
; 2745 :   soap->nlist = np;

	mov	DWORD PTR [edi+88], eax

; 2746 : }

	ret	0
_soap_pop_namespace ENDP
_TEXT	ENDS
PUBLIC	_soap_push_namespace
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_i$ = -8						; size = 2
_n$ = -4						; size = 4
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_soap_push_namespace PROC
; _ns$ = edi

; 2678 : { register struct soap_nlist *np;

	sub	esp, 8

; 2679 :   register struct Namespace *p;
; 2680 :   register short i = -1;
; 2681 :   register size_t n, k;
; 2682 :   n = strlen(id);

	mov	eax, DWORD PTR _id$[esp+4]
	mov	DWORD PTR _i$[esp+8], -1
	lea	edx, DWORD PTR [eax+1]
$LL33@soap_push_:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL33@soap_push_
	sub	eax, edx
	mov	DWORD PTR _n$[esp+8], eax

; 2683 :   k = strlen(ns) + 1;

	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
$LL34@soap_push_:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL34@soap_push_
	sub	eax, edx
	push	ebp
	lea	ebp, DWORD PTR [eax+1]

; 2684 :   p = soap->local_namespaces;

	mov	eax, DWORD PTR _soap$[esp+8]
	push	esi
	mov	esi, DWORD PTR [eax+84]

; 2685 :   if (p)

	test	esi, esi
	je	$LN4@soap_push_

; 2686 :   { for (i = 0; p->id; p++, i++)

	cmp	DWORD PTR [esi], 0
	mov	DWORD PTR _i$[esp+16], 0
	je	$LN46@soap_push_
$LL17@soap_push_:

; 2687 :     { if (p->ns && !strcmp(ns, p->ns))

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN14@soap_push_
	mov	eax, edi
	npad	6
$LL35@soap_push_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN36@soap_push_
	test	dl, dl
	je	SHORT $LN37@soap_push_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN36@soap_push_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL35@soap_push_
$LN37@soap_push_:
	xor	eax, eax
	jmp	SHORT $LN38@soap_push_
$LN36@soap_push_:
	sbb	eax, eax
	sbb	eax, -1
$LN38@soap_push_:
	test	eax, eax
	je	SHORT $LN28@soap_push_
$LN14@soap_push_:

; 2693 :       }
; 2694 :       if (p->out)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN12@soap_push_

; 2695 :       { if (!strcmp(ns, p->out))

	mov	eax, edi
$LL39@soap_push_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN40@soap_push_
	test	dl, dl
	je	SHORT $LN41@soap_push_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN40@soap_push_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL39@soap_push_
$LN41@soap_push_:
	xor	eax, eax
	jmp	SHORT $LN42@soap_push_
$LN40@soap_push_:
	sbb	eax, eax
	sbb	eax, -1
$LN42@soap_push_:
	test	eax, eax
	je	SHORT $LN43@soap_push_

; 2696 :           break;
; 2697 :       }

	jmp	SHORT $LN16@soap_push_
$LN12@soap_push_:

; 2698 :       else if (p->in)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN16@soap_push_

; 2699 :       { if (!soap_tag_cmp(ns, p->in))

	push	eax
	push	edi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN30@soap_push_
$LN16@soap_push_:

; 2686 :   { for (i = 0; p->id; p++, i++)

	inc	DWORD PTR _i$[esp+16]
	add	esi, 16					; 00000010H
	cmp	DWORD PTR [esi], 0
	jne	$LL17@soap_push_

; 2699 :       { if (!soap_tag_cmp(ns, p->in))

	jmp	SHORT $LN43@soap_push_
$LN28@soap_push_:

; 2688 :       { if (p->out)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN43@soap_push_

; 2689 :         { SOAP_FREE(soap, p->out);

	push	eax
	call	_free
	add	esp, 4

; 2690 :           p->out = NULL;

	mov	DWORD PTR [esi+12], 0

; 2691 :         }
; 2692 :         break;

	jmp	SHORT $LN43@soap_push_
$LN30@soap_push_:

; 2700 :         { if ((p->out = (char*)SOAP_MALLOC(soap, k)))

	push	ebp
	call	_malloc
	add	esp, 4
	mov	DWORD PTR [esi+12], eax
	test	eax, eax
	je	SHORT $LN43@soap_push_

; 2701 :             strcpy(p->out, ns);

	mov	ecx, edi
	mov	edx, eax
$LL21@soap_push_:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL21@soap_push_
$LN43@soap_push_:

; 2702 :           break;
; 2703 :         }
; 2704 :       }
; 2705 :     }
; 2706 :     if (!p || !p->id)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN6@soap_push_
$LN46@soap_push_:

; 2707 :       i = -1;

	mov	DWORD PTR _i$[esp+16], -1

; 2708 :   }
; 2709 :   if (i >= 0)

	jmp	SHORT $LN4@soap_push_
$LN6@soap_push_:
	cmp	WORD PTR _i$[esp+16], 0
	jl	SHORT $LN4@soap_push_

; 2710 :     k = 0;

	xor	ebp, ebp
$LN4@soap_push_:

; 2711 :   np = (struct soap_nlist*)SOAP_MALLOC(soap, sizeof(struct soap_nlist) + n + k);

	mov	ecx, DWORD PTR _n$[esp+16]
	lea	edx, DWORD PTR [ecx+ebp+20]
	push	edx
	call	_malloc

; 2712 :   if (!np)
; 2713 :     return soap->error = SOAP_EOM;

	mov	ecx, DWORD PTR _soap$[esp+16]
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@soap_push_
	mov	eax, 20					; 00000014H
	pop	esi
	mov	DWORD PTR [ecx+90460], eax
	pop	ebp

; 2730 : }

	add	esp, 8
	ret	0
$LN3@soap_push_:

; 2714 :   np->next = soap->nlist;

	mov	edx, DWORD PTR [ecx+88]

; 2715 :   soap->nlist = np;
; 2716 :   np->level = soap->level;
; 2717 :   np->index = i;

	mov	ebp, DWORD PTR _i$[esp+16]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [ecx+88], eax
	mov	ecx, DWORD PTR [ecx+12444]
	mov	DWORD PTR [eax+4], ecx

; 2718 :   strcpy(np->id, id);

	mov	ecx, DWORD PTR _id$[esp+12]
	mov	edx, eax
	sub	edx, ecx
	mov	WORD PTR [eax+8], bp
	lea	esi, DWORD PTR [edx+16]
$LL22@soap_push_:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [esi+ecx], dl
	inc	ecx
	test	dl, dl
	jne	SHORT $LL22@soap_push_

; 2719 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Push namespace binding (level=%u) '%s' '%s'\n", soap->level, id, ns));
; 2720 :   if (i < 0)

	test	bp, bp
	jge	SHORT $LN2@soap_push_

; 2721 :   { np->ns = np->id + n + 1;

	mov	ecx, DWORD PTR _n$[esp+16]
	lea	edx, DWORD PTR [eax+ecx+17]
	mov	DWORD PTR [eax+12], edx

; 2722 :     strcpy(np->ns, ns);

	mov	eax, edi
	sub	edx, edi
$LL23@soap_push_:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL23@soap_push_
	pop	esi

; 2727 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Push OK ('%s' matches '%s' in namespace table)\n", id, p->id));
; 2728 :   }
; 2729 :   return SOAP_OK;

	xor	eax, eax
	pop	ebp

; 2730 : }

	add	esp, 8
	ret	0
$LN2@soap_push_:
	pop	esi

; 2723 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Push NOT OK: no match found for '%s' in namespace mapping table (added to stack anyway)\n", ns));
; 2724 :   }
; 2725 :   else
; 2726 :   { np->ns = NULL;

	mov	DWORD PTR [eax+12], 0

; 2727 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Push OK ('%s' matches '%s' in namespace table)\n", id, p->id));
; 2728 :   }
; 2729 :   return SOAP_OK;

	xor	eax, eax
	pop	ebp

; 2730 : }

	add	esp, 8
	ret	0
_soap_push_namespace ENDP
_TEXT	ENDS
PUBLIC	_soap_getposition
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_attr$ = 8						; size = 4
_pos$ = 12						; size = 4
_soap_getposition PROC

; 2656 : { register int i, n;

	push	ebx
	mov	ebx, DWORD PTR _attr$[esp]

; 2657 :   if (!*attr)

	cmp	BYTE PTR [ebx], 0
	jne	SHORT $LN8@soap_getpo

; 2658 :     return -1;

	or	eax, -1
	pop	ebx

; 2669 : }

	ret	0
$LN8@soap_getpo:
	push	ebp
	push	esi
	push	edi

; 2659 :   n = 0;

	xor	ebp, ebp

; 2660 :   i = 1;

	mov	esi, 1
	npad	7
$LL7@soap_getpo:

; 2661 :   do
; 2662 :   { pos[n++] = (int)atol(attr + i);

	lea	edi, DWORD PTR [esi+ebx]
	push	edi
	call	_atol
	mov	ecx, DWORD PTR _pos$[esp+16]
	mov	DWORD PTR [ecx+ebp*4], eax

; 2663 :     while (attr[i] && attr[i] != ',' && attr[i] != ']')

	mov	al, BYTE PTR [edi]
	add	esp, 4
	inc	ebp
	test	al, al
	je	SHORT $LN3@soap_getpo
	npad	6
$LL4@soap_getpo:
	cmp	al, 44					; 0000002cH
	je	SHORT $LN3@soap_getpo
	cmp	al, 93					; 0000005dH
	je	SHORT $LN3@soap_getpo
	mov	al, BYTE PTR [esi+ebx+1]

; 2664 :       i++;

	inc	esi
	test	al, al
	jne	SHORT $LL4@soap_getpo
$LN3@soap_getpo:

; 2665 :     if (attr[i] == ',')

	cmp	BYTE PTR [esi+ebx], 44			; 0000002cH
	jne	SHORT $LN6@soap_getpo

; 2666 :       i++;

	inc	esi
$LN6@soap_getpo:

; 2667 :   } while (n < SOAP_MAXDIMS && attr[i] && attr[i] != ']');

	cmp	ebp, 16					; 00000010H
	jge	SHORT $LN1@soap_getpo
	mov	al, BYTE PTR [esi+ebx]
	test	al, al
	je	SHORT $LN1@soap_getpo
	cmp	al, 93					; 0000005dH
	jne	SHORT $LL7@soap_getpo
$LN1@soap_getpo:
	pop	edi
	pop	esi

; 2668 :   return n;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2669 : }

	ret	0
_soap_getposition ENDP
_TEXT	ENDS
PUBLIC	_soap_getsizes
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_size$ = 8						; size = 4
_dim$ = 12						; size = 4
_soap_getsizes PROC
; _attr$ = edi

; 2633 :   if (!*attr)

	cmp	BYTE PTR [edi], 0
	jne	SHORT $LN12@soap_getsi

; 2634 :     return -1;

	or	eax, -1

; 2647 : }

	ret	0
$LN12@soap_getsi:
	push	esi

; 2635 :   i = (int)strlen(attr);

	mov	esi, edi
	lea	ecx, DWORD PTR [esi+1]
	npad	1
$LL20@soap_getsi:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL20@soap_getsi
	mov	eax, DWORD PTR _dim$[esp]
	push	ebx
	sub	esi, ecx
	mov	ecx, DWORD PTR _size$[esp+4]
	push	ebp

; 2636 :   n = 1;

	mov	ebx, 1
	lea	ebp, DWORD PTR [ecx+eax*4]
	npad	5
$LL11@soap_getsi:

; 2637 :   do
; 2638 :   { for (i = i-1; i >= 0; i--)

	sub	esi, 1
	js	SHORT $LN17@soap_getsi
$LL8@soap_getsi:

; 2639 :       if (attr[i] == '[' || attr[i] == ',' || attr[i] == ' ')

	mov	al, BYTE PTR [esi+edi]
	cmp	al, 91					; 0000005bH
	je	SHORT $LN17@soap_getsi
	cmp	al, 44					; 0000002cH
	je	SHORT $LN17@soap_getsi
	cmp	al, 32					; 00000020H
	je	SHORT $LN17@soap_getsi

; 2637 :   do
; 2638 :   { for (i = i-1; i >= 0; i--)

	sub	esi, 1
	jns	SHORT $LL8@soap_getsi
$LN17@soap_getsi:

; 2640 :         break;
; 2641 :     k = (int)atol(attr + i + 1);

	lea	edx, DWORD PTR [edi+esi+1]
	push	edx
	call	_atol

; 2642 :     n *= size[--dim] = k;

	mov	ecx, eax
	sub	ebp, 4
	imul	ebx, ecx
	add	esp, 4
	mov	DWORD PTR [ebp], eax

; 2643 :     if (k < 0 || n > SOAP_MAXARRAYSIZE)

	test	eax, eax
	jl	SHORT $LN2@soap_getsi
	cmp	ebx, 100000				; 000186a0H
	jg	SHORT $LN2@soap_getsi

; 2645 :   } while (i >= 0 && attr[i] != '[');

	test	esi, esi
	jl	SHORT $LN1@soap_getsi
	cmp	BYTE PTR [esi+edi], 91			; 0000005bH
	jne	SHORT $LL11@soap_getsi
$LN1@soap_getsi:
	pop	ebp

; 2646 :   return n;

	mov	eax, ebx
	pop	ebx
	pop	esi

; 2647 : }

	ret	0
$LN2@soap_getsi:
	pop	ebp
	pop	ebx

; 2644 :       return -1;

	or	eax, -1
	pop	esi

; 2647 : }

	ret	0
_soap_getsizes ENDP
_TEXT	ENDS
PUBLIC	_soap_getoffsets
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_size$ = 8						; size = 4
tv227 = 12						; size = 4
_offset$ = 12						; size = 4
_dim$ = 16						; size = 4
_soap_getoffsets PROC
; _attr$ = eax

; 2568 : { register int i, j = 0;

	push	ebx
	mov	ebx, DWORD PTR _offset$[esp]
	push	ebp
	push	esi
	push	edi
	xor	edi, edi
	mov	esi, eax

; 2569 :   if (offset)

	test	ebx, ebx
	je	SHORT $LN8@soap_getof

; 2570 :     for (i = 0; i < dim && attr && *attr; i++)

	xor	ebp, ebp
	cmp	DWORD PTR _dim$[esp+12], edi
	jle	$LN20@soap_getof
	mov	eax, DWORD PTR _size$[esp+12]
	sub	eax, ebx
	mov	DWORD PTR tv227[esp+12], eax
	jmp	SHORT $LN7@soap_getof
$LL21@soap_getof:
	mov	eax, DWORD PTR tv227[esp+12]
$LN7@soap_getof:
	test	esi, esi
	je	SHORT $LN20@soap_getof
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN20@soap_getof

; 2571 :     { attr++;
; 2572 :       j *= size[i];

	mov	eax, DWORD PTR [eax+ebx]
	inc	esi
	imul	edi, eax

; 2573 :       j += offset[i] = (int)atol(attr);

	push	esi
	call	_atol

; 2574 :       attr = strchr(attr, ',');

	push	44					; 0000002cH
	push	esi
	mov	DWORD PTR [ebx], eax
	add	edi, eax
	call	_strchr
	inc	ebp
	add	esp, 12					; 0000000cH
	add	ebx, 4
	cmp	ebp, DWORD PTR _dim$[esp+12]
	mov	esi, eax
	jl	SHORT $LL21@soap_getof

; 2582 :     }
; 2583 :   return j;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2584 : }

	ret	0
$LN8@soap_getof:

; 2575 :     }
; 2576 :   else
; 2577 :     for (i = 0; i < dim && attr && *attr; i++)

	mov	ebp, DWORD PTR _dim$[esp+12]
	xor	ebx, ebx
	test	ebp, ebp
	jle	SHORT $LN20@soap_getof
	npad	2
$LL22@soap_getof:
	test	esi, esi
	je	SHORT $LN20@soap_getof
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN20@soap_getof

; 2578 :     { attr++;
; 2579 :       j *= size[i];

	mov	ecx, DWORD PTR _size$[esp+12]
	mov	edx, DWORD PTR [ecx+ebx*4]
	inc	esi
	imul	edi, edx

; 2580 :       j += (int)atol(attr);

	push	esi
	call	_atol

; 2581 :       attr = strchr(attr, ',');

	push	44					; 0000002cH
	push	esi
	add	edi, eax
	call	_strchr
	inc	ebx
	add	esp, 12					; 0000000cH
	cmp	ebx, ebp
	mov	esi, eax
	jl	SHORT $LL22@soap_getof
$LN20@soap_getof:

; 2582 :     }
; 2583 :   return j;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2584 : }

	ret	0
_soap_getoffsets ENDP
_TEXT	ENDS
PUBLIC	_soap_size
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_size PROC
; _size$ = esi
; _dim$ = edx

; 2555 : { register int i, n = size[0];

	mov	eax, DWORD PTR [esi]

; 2556 :   for (i = 1; i < dim; i++)

	mov	ecx, 1
	cmp	edx, ecx
	jle	SHORT $LN1@soap_size
	push	edi
	npad	4
$LL3@soap_size:

; 2557 :     n *= size[i];

	mov	edi, DWORD PTR [esi+ecx*4]
	inc	ecx
	imul	eax, edi
	cmp	ecx, edx
	jl	SHORT $LL3@soap_size
	pop	edi
$LN1@soap_size:

; 2558 :   return n;
; 2559 : }

	ret	0
_soap_size ENDP
_TEXT	ENDS
PUBLIC	_soap_putoffsets
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_putoffsets PROC
; _soap$ = ecx
; _offset$ = eax

; 2540 : { register int i;

	push	esi

; 2541 :   sprintf(soap->arrayOffset, "[%d", offset[0]);

	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	push	edi
	push	ecx
	add	esi, 86196				; 000150b4H
	push	OFFSET ??_C@_03PNKAICOI@?$FL?$CFd?$AA@
	push	esi
	call	_sprintf

; 2542 :   for (i = 1; i < dim; i++)
; 2543 :     sprintf(soap->arrayOffset + strlen(soap->arrayOffset), ",%d", offset[i]);
; 2544 :   strcat(soap->arrayOffset, "]");

	mov	edi, esi
	add	esp, 12					; 0000000cH
	dec	edi
	npad	2
$LL8@soap_putof:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL8@soap_putof
	mov	dx, WORD PTR ??_C@_01LBDDMOBJ@?$FN?$AA@
	mov	WORD PTR [edi], dx
	pop	edi

; 2545 :   return soap->arrayOffset;

	mov	eax, esi
	pop	esi

; 2546 : }

	ret	0
_soap_putoffsets ENDP
_TEXT	ENDS
PUBLIC	_soap_putoffset
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_offset$ = 8						; size = 4
_soap_putoffset PROC
; _soap$ = eax

; 2530 : { return soap_putoffsets(soap, &offset, 1);

	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR _offset$[esp]
	push	edi
	push	eax
	add	esi, 86196				; 000150b4H
	push	OFFSET ??_C@_03PNKAICOI@?$FL?$CFd?$AA@
	push	esi
	call	_sprintf
	mov	edi, esi
	add	esp, 12					; 0000000cH
	dec	edi
$LL10@soap_putof@2:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL10@soap_putof@2
	mov	cx, WORD PTR ??_C@_01LBDDMOBJ@?$FN?$AA@
	mov	WORD PTR [edi], cx
	pop	edi
	mov	eax, esi
	pop	esi

; 2531 : }

	ret	0
_soap_putoffset ENDP
_TEXT	ENDS
PUBLIC	_soap_putsizesoffsets
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_putsizesoffsets PROC
; _type$ = eax
; _size$ = edx

; 2499 : { int i;

	mov	ecx, DWORD PTR _soap$[esp-4]

; 2500 :   if (!type)

	test	eax, eax
	jne	SHORT $LN14@soap_putsi

; 2521 : }

	ret	0
$LN14@soap_putsi:

; 2501 :     return NULL;
; 2502 :   if (soap->version == 2)

	cmp	WORD PTR [ecx+6], 2
	push	esi

; 2503 :   { sprintf(soap->type, "%s[%d", type, size[0]);

	lea	esi, DWORD PTR [ecx+83124]
	jne	SHORT $LL7@soap_putsi
	mov	ecx, DWORD PTR [edx]
	push	ecx
	push	eax
	push	OFFSET ??_C@_05IEDFPCMN@?$CFs?$FL?$CFd?$AA@
	push	esi
	call	_sprintf
	add	esp, 16					; 00000010H

; 2519 :   }
; 2520 :   return soap->type;

	mov	eax, esi
	pop	esi

; 2521 : }

	ret	0
	npad	3
$LL7@soap_putsi:

; 2504 :     for (i = 1; i < dim; i++)
; 2505 :       sprintf(soap->type + strlen(soap->type), " %d", size[i]);
; 2506 :   }
; 2507 :   else
; 2508 :   { if (offset)
; 2509 :     { sprintf(soap->type, "%s[%d", type, size[0] + offset[0]);
; 2510 :       for (i = 1; i < dim; i++)
; 2511 :         sprintf(soap->type + strlen(soap->type), ",%d", size[i] + offset[i]);
; 2512 :     }
; 2513 :     else
; 2514 :     { sprintf(soap->type, "%s[%d", type, size[0]);

	mov	edx, DWORD PTR [edx]
	push	edi
	push	edx
	push	eax
	push	OFFSET ??_C@_05IEDFPCMN@?$CFs?$FL?$CFd?$AA@
	push	esi
	call	_sprintf

; 2515 :       for (i = 1; i < dim; i++)
; 2516 :         sprintf(soap->type + strlen(soap->type), ",%d", size[i]);
; 2517 :     }
; 2518 :     strcat(soap->type, "]");

	mov	edi, esi
	add	esp, 16					; 00000010H
	dec	edi
$LL23@soap_putsi:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL23@soap_putsi
	mov	ax, WORD PTR ??_C@_01LBDDMOBJ@?$FN?$AA@
	mov	WORD PTR [edi], ax
	pop	edi

; 2519 :   }
; 2520 :   return soap->type;

	mov	eax, esi
	pop	esi

; 2521 : }

	ret	0
_soap_putsizesoffsets ENDP
_TEXT	ENDS
PUBLIC	_soap_putsizes
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_type$ = 8						; size = 4
_soap_putsizes PROC
; _soap$ = eax
; _size$ = edx

; 2489 : { return soap_putsizesoffsets(soap, type, size, NULL, dim);

	push	eax
	mov	eax, DWORD PTR _type$[esp]
	call	_soap_putsizesoffsets
	add	esp, 4

; 2490 : }

	ret	0
_soap_putsizes ENDP
_TEXT	ENDS
PUBLIC	_soap_putsize
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_type$ = 8						; size = 4
_size$ = 12						; size = 4
_soap_putsize PROC
; _soap$ = eax

; 2479 : { return soap_putsizes(soap, type, &size, 1);

	push	eax
	mov	eax, DWORD PTR _type$[esp]
	lea	edx, DWORD PTR _size$[esp]
	call	_soap_putsizesoffsets
	add	esp, 4

; 2480 : }

	ret	0
_soap_putsize ENDP
_TEXT	ENDS
PUBLIC	_soap_end_block
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_end_block PROC

; 2425 : { struct soap_blist *bp;

	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	edi

; 2426 :   char *p, *q;
; 2427 :   bp = soap->blist;

	mov	edi, DWORD PTR [ebx+92]

; 2428 :   if (bp)

	test	edi, edi
	je	SHORT $LN4@soap_end_b

; 2429 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End of block sequence, free all remaining blocks\n"));
; 2430 :     for (p = bp->ptr; p; p = q)

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN1@soap_end_b
	push	esi
$LL3@soap_end_b:

; 2431 :     { q = *(char**)p;

	mov	esi, DWORD PTR [eax]

; 2432 :       SOAP_FREE(soap, p);

	push	eax
	call	_free
	add	esp, 4
	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL3@soap_end_b
	pop	esi
$LN1@soap_end_b:

; 2433 :     }
; 2434 :     soap->blist = bp->next;

	mov	eax, DWORD PTR [edi]

; 2435 :     SOAP_FREE(soap, bp);

	push	edi
	mov	DWORD PTR [ebx+92], eax
	call	_free
	add	esp, 4
$LN4@soap_end_b:
	pop	edi
	pop	ebx

; 2436 :   }
; 2437 :   DBGLOG(TEST, if (soap->blist) SOAP_MESSAGE(fdebug, "Restore previous block sequence\n"));
; 2438 : }

	ret	0
_soap_end_block ENDP
_TEXT	ENDS
PUBLIC	_soap_block_size
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_block_size PROC
; _soap$ = eax

; 2415 : { return *(size_t*)(soap->blist->ptr + sizeof(char*));

	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]

; 2416 : }

	ret	0
_soap_block_size ENDP
_TEXT	ENDS
PUBLIC	_soap_next_block
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_next_block PROC
; _soap$ = esi

; 2397 :   p = soap->blist->ptr;

	mov	ecx, DWORD PTR [esi+92]
	mov	eax, DWORD PTR [ecx+4]

; 2398 :   if (p)

	test	eax, eax
	je	SHORT $LN1@soap_next_@2

; 2399 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Next block\n"));
; 2400 :     soap->blist->ptr = *(char**)p;

	mov	edx, DWORD PTR [eax]

; 2401 :     SOAP_FREE(soap, p);

	push	eax
	mov	DWORD PTR [ecx+4], edx
	call	_free

; 2402 :     if (soap->blist->ptr)

	mov	eax, DWORD PTR [esi+92]
	mov	eax, DWORD PTR [eax+4]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_next_@2

; 2403 :       return soap->blist->ptr + sizeof(char*) + sizeof(size_t);

	add	eax, 8

; 2406 : }

	ret	0
$LN1@soap_next_@2:

; 2404 :   }
; 2405 :   return NULL;

	xor	eax, eax

; 2406 : }

	ret	0
_soap_next_block ENDP
_TEXT	ENDS
PUBLIC	_soap_first_block
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_first_block PROC
; _soap$ = esi

; 2374 :   p = soap->blist->ptr;

	mov	eax, DWORD PTR [esi+92]
	mov	eax, DWORD PTR [eax+4]

; 2375 :   if (!p)

	test	eax, eax
	jne	SHORT $LN4@soap_first

; 2387 : }

	ret	0
$LN4@soap_first:

; 2376 :     return NULL;
; 2377 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "First block\n"));
; 2378 :   r = NULL;

	xor	edx, edx
	npad	3
$LL3@soap_first:

; 2379 :   do
; 2380 :   { q = *(char**)p;

	mov	ecx, DWORD PTR [eax]

; 2381 :     *(char**)p = r;

	mov	DWORD PTR [eax], edx

; 2382 :     r = p;

	mov	edx, eax

; 2383 :     p = q;

	mov	eax, ecx

; 2384 :   } while (p);

	test	ecx, ecx
	jne	SHORT $LL3@soap_first

; 2385 :   soap->blist->ptr = r;

	mov	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [ecx+4], edx

; 2386 :   return r + sizeof(char*) + sizeof(size_t);

	lea	eax, DWORD PTR [edx+8]

; 2387 : }

	ret	0
_soap_first_block ENDP
_TEXT	ENDS
PUBLIC	_soap_size_block
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_size_block PROC
; _soap$ = ecx
; _n$ = edx

; 2359 : { if (soap->blist->ptr)

	mov	eax, DWORD PTR [ecx+92]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@soap_size_
	push	esi

; 2360 :   { soap->blist->size -= *(size_t*)(soap->blist->ptr + sizeof(char*)) - n;

	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, edx
	sub	edi, DWORD PTR [esi+4]
	add	DWORD PTR [eax+8], edi

; 2361 :     *(size_t*)(soap->blist->ptr + sizeof(char*)) = n;

	mov	eax, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+4], edx

; 2362 :   }
; 2363 :   return soap->blist->size;

	mov	ecx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR [ecx+8]
	pop	edi
	pop	esi

; 2364 : }

	ret	0
$LN4@soap_size_:

; 2362 :   }
; 2363 :   return soap->blist->size;

	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]

; 2364 : }

	ret	0
_soap_size_block ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_soap_has_copies PROC
; _start$ = esi
; _end$ = edi

; 2242 : { register int i;

	push	ebx
	push	ebp

; 2243 :   register struct soap_ilist *ip = NULL;
; 2244 :   register struct soap_flist *fp = NULL;
; 2245 :   register const char *p;
; 2246 :   for (i = 0; i < SOAP_IDHASH; i++)

	mov	ebp, DWORD PTR _soap$[esp+4]
	xor	ebx, ebx
	add	ebp, 104				; 00000068H
	npad	5
$LL14@soap_has_c:

; 2247 :   { for (ip = soap->iht[i]; ip; ip = ip->next)

	mov	edx, DWORD PTR [ebp]
	test	edx, edx
	je	SHORT $LN13@soap_has_c
$LL11@soap_has_c:

; 2248 :     { for (p = (const char*)ip->copy; p; p = *(const char**)p)

	mov	eax, DWORD PTR [edx+16]
	test	eax, eax
	je	SHORT $LN6@soap_has_c
	npad	2
$LL8@soap_has_c:

; 2249 :         if (p >= start && p < end)

	cmp	eax, esi
	jb	SHORT $LN7@soap_has_c
	cmp	eax, edi
	jb	SHORT $LN21@soap_has_c
$LN7@soap_has_c:

; 2248 :     { for (p = (const char*)ip->copy; p; p = *(const char**)p)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL8@soap_has_c
$LN6@soap_has_c:

; 2251 :       for (fp = ip->flist; fp; fp = fp->next)

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN10@soap_has_c
$LL4@soap_has_c:

; 2252 :         if ((const char*)fp->ptr >= start && (const char*)fp->ptr < end)

	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, esi
	jb	SHORT $LN3@soap_has_c
	cmp	ecx, edi
	jb	SHORT $LN21@soap_has_c
$LN3@soap_has_c:

; 2251 :       for (fp = ip->flist; fp; fp = fp->next)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL4@soap_has_c
$LN10@soap_has_c:

; 2247 :   { for (ip = soap->iht[i]; ip; ip = ip->next)

	mov	edx, DWORD PTR [edx]
	test	edx, edx
	jne	SHORT $LL11@soap_has_c
$LN13@soap_has_c:

; 2243 :   register struct soap_ilist *ip = NULL;
; 2244 :   register struct soap_flist *fp = NULL;
; 2245 :   register const char *p;
; 2246 :   for (i = 0; i < SOAP_IDHASH; i++)

	inc	ebx
	add	ebp, 4
	cmp	ebx, 1999				; 000007cfH
	jl	SHORT $LL14@soap_has_c
	pop	ebp

; 2253 :           return SOAP_ERR;
; 2254 :     }
; 2255 :   }
; 2256 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 2257 : }

	ret	0
$LN21@soap_has_c:
	pop	ebp

; 2250 :           return SOAP_ERR;

	or	eax, -1
	pop	ebx

; 2257 : }

	ret	0
_soap_has_copies ENDP
; Function compile flags: /Ogtpy
tv370 = -8						; size = 4
tv93 = -4						; size = 4
_soap$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_soap_update_ptrs PROC
; _p1$ = esi
; _p2$ = edx

; 2187 : { int i;

	sub	esp, 8

; 2188 :   register struct soap_ilist *ip = NULL;
; 2189 :   register struct soap_flist *fp = NULL;
; 2190 : #ifndef WITH_LEANER
; 2191 :   register struct soap_xlist *xp = NULL;
; 2192 : #endif
; 2193 :   register void *p, **q;
; 2194 :   for (i = 0; i < SOAP_IDHASH; i++)

	mov	eax, DWORD PTR _soap$[esp+4]
	push	ebx
	mov	ebx, DWORD PTR _start$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _end$[esp+12]
	add	eax, 104				; 00000068H
	mov	DWORD PTR tv370[esp+16], eax
	mov	DWORD PTR tv93[esp+16], 1999		; 000007cfH
	push	edi
$LL23@soap_updat:

; 2195 :   { for (ip = soap->iht[i]; ip; ip = ip->next)

	mov	ecx, DWORD PTR tv370[esp+20]
	mov	edi, DWORD PTR [ecx]
	test	edi, edi
	je	$LN22@soap_updat
	npad	1
$LL41@soap_updat:

; 2196 :     { if (ip->ptr && (char*)ip->ptr >= start && (char*)ip->ptr < end)

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN17@soap_updat
	cmp	eax, ebx
	jb	SHORT $LN17@soap_updat
	cmp	eax, ebp
	jae	SHORT $LN17@soap_updat

; 2197 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Update id='%s' %p -> %p\n", ip->id, ip->ptr, (char*)ip->ptr + (p1-p2)));
; 2198 :         ip->ptr = (char*)ip->ptr + (p1-p2);

	sub	eax, edx
	add	eax, esi
	mov	DWORD PTR [edi+24], eax
$LN17@soap_updat:

; 2199 :       }
; 2200 :       for (q = &ip->link; q; q = (void**)p)

	lea	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	je	SHORT $LN14@soap_updat
	npad	3
$LL16@soap_updat:

; 2201 :       { p = *q;

	mov	eax, DWORD PTR [ecx]

; 2202 :         if (p && (char*)p >= start && (char*)p < end)

	test	eax, eax
	je	SHORT $LN15@soap_updat
	cmp	eax, ebx
	jb	SHORT $LN15@soap_updat
	cmp	eax, ebp
	jae	SHORT $LN15@soap_updat

; 2203 :         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Link update id='%s' %p\n", ip->id, p));
; 2204 :           *q = (char*)p + (p1-p2);

	mov	ebp, eax
	sub	ebp, edx
	add	ebp, esi
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR _end$[esp+16]
$LN15@soap_updat:
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL16@soap_updat
$LN14@soap_updat:

; 2205 :         }
; 2206 :       }
; 2207 :       for (q = &ip->copy; q; q = (void**)p)

	lea	ecx, DWORD PTR [edi+16]
	test	ecx, ecx
	je	SHORT $LN10@soap_updat
$LL12@soap_updat:

; 2208 :       { p = *q;

	mov	eax, DWORD PTR [ecx]

; 2209 :         if (p && (char*)p >= start && (char*)p < end)

	test	eax, eax
	je	SHORT $LN11@soap_updat
	cmp	eax, ebx
	jb	SHORT $LN11@soap_updat
	cmp	eax, ebp
	jae	SHORT $LN11@soap_updat

; 2210 :         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy chain update id='%s' %p\n", ip->id, p));
; 2211 :           *q = (char*)p + (p1-p2);

	mov	ebp, eax
	sub	ebp, edx
	add	ebp, esi
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR _end$[esp+16]
$LN11@soap_updat:
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL12@soap_updat
$LN10@soap_updat:

; 2212 :         }
; 2213 :       }
; 2214 :       for (fp = ip->flist; fp; fp = fp->next)

	mov	ecx, DWORD PTR [edi+20]
	test	ecx, ecx
	je	SHORT $LN19@soap_updat
	npad	2
$LL8@soap_updat:

; 2215 :       { if ((char*)fp->ptr >= start && (char*)fp->ptr < end)

	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, ebx
	jb	SHORT $LN7@soap_updat
	cmp	eax, ebp
	jae	SHORT $LN7@soap_updat

; 2216 :         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy list update id='%s' %p\n", ip->id, fp));
; 2217 :           fp->ptr = (char*)fp->ptr + (p1-p2);

	sub	eax, edx
	add	eax, esi
	mov	DWORD PTR [ecx+8], eax
$LN7@soap_updat:
	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LL8@soap_updat
$LN19@soap_updat:

; 2195 :   { for (ip = soap->iht[i]; ip; ip = ip->next)

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	$LL41@soap_updat
$LN22@soap_updat:

; 2188 :   register struct soap_ilist *ip = NULL;
; 2189 :   register struct soap_flist *fp = NULL;
; 2190 : #ifndef WITH_LEANER
; 2191 :   register struct soap_xlist *xp = NULL;
; 2192 : #endif
; 2193 :   register void *p, **q;
; 2194 :   for (i = 0; i < SOAP_IDHASH; i++)

	add	DWORD PTR tv370[esp+20], 4
	sub	DWORD PTR tv93[esp+20], 1
	jne	$LL23@soap_updat

; 2218 :         }
; 2219 :       }
; 2220 :     }
; 2221 :   }
; 2222 : #ifndef WITH_LEANER
; 2223 :   for (xp = soap->xlist; xp; xp = xp->next)

	mov	eax, DWORD PTR _soap$[esp+16]
	mov	eax, DWORD PTR [eax+90544]
	pop	edi
	test	eax, eax
	je	SHORT $LN2@soap_updat
$LL4@soap_updat:

; 2224 :   { if (xp->ptr && (char*)xp->ptr >= start && (char*)xp->ptr < end)

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN3@soap_updat
	cmp	ecx, ebx
	jb	SHORT $LN3@soap_updat
	cmp	ecx, ebp
	jae	SHORT $LN3@soap_updat

; 2225 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Update id='%s' %p -> %p\n", xp->id?xp->id:"", xp->ptr, (char*)xp->ptr + (p1-p2)));
; 2226 :       xp->ptr = (unsigned char**)((char*)xp->ptr + (p1-p2));

	sub	ecx, edx
	add	ecx, esi
	mov	DWORD PTR [eax+4], ecx

; 2227 :       xp->size = (int*)((char*)xp->size + (p1-p2));

	mov	ecx, esi
	sub	ecx, edx
	add	DWORD PTR [eax+8], ecx

; 2228 :       xp->type = (char**)((char*)xp->type + (p1-p2));

	mov	ecx, esi
	sub	ecx, edx
	add	DWORD PTR [eax+16], ecx

; 2229 :       xp->options = (char**)((char*)xp->options + (p1-p2));

	mov	ecx, esi
	sub	ecx, edx
	add	DWORD PTR [eax+20], ecx
$LN3@soap_updat:
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL4@soap_updat
$LN2@soap_updat:
	pop	ebp
	pop	ebx

; 2230 :     }
; 2231 :   }
; 2232 : #endif
; 2233 : }

	add	esp, 8
	ret	0
_soap_update_ptrs ENDP
_TEXT	ENDS
PUBLIC	_soap_pop_block
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_pop_block PROC
; _soap$ = edx

; 2172 :   if (!soap->blist->ptr)

	mov	eax, DWORD PTR [edx+92]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@soap_pop_b

; 2173 :     return;
; 2174 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Pop block\n"));
; 2175 :   p = soap->blist->ptr;

	mov	ecx, DWORD PTR [eax+4]
	push	esi

; 2176 :   soap->blist->size -= *(size_t*)(p + sizeof(char*));

	mov	esi, DWORD PTR [ecx+4]
	sub	DWORD PTR [eax+8], esi

; 2177 :   soap->blist->ptr = *(char**)p;

	mov	edx, DWORD PTR [edx+92]
	mov	eax, DWORD PTR [ecx]

; 2178 :   SOAP_FREE(soap, p);

	push	ecx
	mov	DWORD PTR [edx+4], eax
	call	_free
	add	esp, 4
	pop	esi
$LN2@soap_pop_b:

; 2179 : }

	ret	0
_soap_pop_block ENDP
_TEXT	ENDS
PUBLIC	_soap_push_block
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_push_block PROC
; _soap$ = eax
; _n$ = edi

; 2151 : { char *p;

	push	esi
	mov	esi, eax

; 2152 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Push block of %u bytes (%u bytes total)\n", (unsigned int)n, (unsigned int)soap->blist->size + (unsigned int)n));
; 2153 :   if (!(p = (char*)SOAP_MALLOC(soap, n + sizeof(char*) + sizeof(size_t))))

	lea	eax, DWORD PTR [edi+8]
	push	eax
	call	_malloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_push_@2

; 2154 :   { soap->error = SOAP_EOM;

	mov	DWORD PTR [esi+90460], 20		; 00000014H
	pop	esi

; 2162 : }

	ret	0
$LN1@soap_push_@2:

; 2155 :     return NULL;
; 2156 :   }
; 2157 :   *(char**)p = soap->blist->ptr;

	mov	ecx, DWORD PTR [esi+92]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 2158 :   *(size_t*)(p + sizeof(char*)) = n;

	mov	DWORD PTR [eax+4], edi

; 2159 :   soap->blist->ptr = p;

	mov	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [ecx+4], eax

; 2160 :   soap->blist->size += n;

	mov	esi, DWORD PTR [esi+92]
	add	DWORD PTR [esi+8], edi

; 2161 :   return p + sizeof(char*) + sizeof(size_t);

	add	eax, 8
	pop	esi

; 2162 : }

	ret	0
_soap_push_block ENDP
_TEXT	ENDS
PUBLIC	_soap_new_block
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_new_block PROC
; _soap$ = esi

; 2134 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "New block sequence (prev=%p)\n", soap->blist));
; 2135 :   if (!(p = (struct soap_blist*)SOAP_MALLOC(soap, sizeof(struct soap_blist))))

	push	12					; 0000000cH
	call	_malloc
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	jne	SHORT $LN1@soap_new_b

; 2136 :     return SOAP_EOM;

	mov	eax, 20					; 00000014H

; 2142 : }

	ret	0
$LN1@soap_new_b:

; 2137 :   p->next = soap->blist;

	mov	edx, DWORD PTR [esi+92]
	mov	DWORD PTR [eax], edx

; 2138 :   p->ptr = NULL;

	mov	DWORD PTR [eax+4], ecx

; 2139 :   p->size = 0;

	mov	DWORD PTR [eax+8], ecx

; 2140 :   soap->blist = p;

	mov	DWORD PTR [esi+92], eax

; 2141 :   return SOAP_OK;

	xor	eax, eax

; 2142 : }

	ret	0
_soap_new_block ENDP
_TEXT	ENDS
PUBLIC	_soap_wstrdup
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_wstrdup PROC
; _soap$ = edi

; 2116 :   if (s)
; 2117 :   { size_t n = 0;
; 2118 :     while (s[n])
; 2119 :       n++;
; 2120 :     if ((t = (wchar_t*)soap_malloc(soap, sizeof(wchar_t)*(n+1))))

	mov	eax, 2
	call	_soap_malloc
	test	eax, eax
	je	SHORT $LN1@soap_wstrd

; 2121 :       memcpy(t, s, sizeof(wchar_t)*(n+1));

	mov	cx, WORD PTR _soap_padding
	mov	WORD PTR [eax], cx
$LN1@soap_wstrd:

; 2122 :   }
; 2123 :   return t;
; 2124 : }

	ret	0
_soap_wstrdup ENDP
_TEXT	ENDS
PUBLIC	_soap_strdup
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_soap_strdup PROC

; 2102 : { char *t = NULL;

	push	ebx
	mov	ebx, DWORD PTR _s$[esp]
	xor	eax, eax

; 2103 :   if (s && (t = (char*)soap_malloc(soap, strlen(s) + 1)))

	test	ebx, ebx
	je	SHORT $LN1@soap_strdu
	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL6@soap_strdu:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL6@soap_strdu
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR _soap$[esp+4]
	inc	eax
	call	_soap_malloc
	pop	edi
	test	eax, eax
	je	SHORT $LN1@soap_strdu
	push	esi

; 2104 :     strcpy(t, s);

	mov	esi, eax
	mov	ecx, ebx
	sub	esi, ebx
$LL4@soap_strdu:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [esi+ecx], dl
	inc	ecx
	test	dl, dl
	jne	SHORT $LL4@soap_strdu
	pop	esi
$LN1@soap_strdu:
	pop	ebx

; 2105 :   return t;
; 2106 : }

	ret	0
_soap_strdup ENDP
_TEXT	ENDS
PUBLIC	_soap_dime_forward
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_size$ = 12						; size = 4
_type$ = 16						; size = 4
_options$ = 20						; size = 4
_soap_dime_forward PROC
; _soap$ = esi
; _id$ = edi

; 2073 :   *ptr = NULL;

	mov	eax, DWORD PTR _ptr$[esp-4]

; 2074 :   *size = 0;

	mov	ecx, DWORD PTR _size$[esp-4]
	mov	DWORD PTR [eax], 0
	push	ebx
	mov	ebx, DWORD PTR _options$[esp]
	mov	DWORD PTR [ecx], 0
	push	ebp
	mov	ebp, DWORD PTR _type$[esp+4]

; 2075 :   *id = NULL;

	mov	DWORD PTR [edi], 0

; 2076 :   *type = NULL;

	mov	DWORD PTR [ebp], 0

; 2077 :   *options = NULL;
; 2078 :   if (!*soap->href)

	lea	eax, DWORD PTR [esi+82100]
	mov	DWORD PTR [ebx], 0
	cmp	BYTE PTR [eax], 0

; 2079 :     return SOAP_OK;

	je	SHORT $LN5@soap_dime_

; 2080 :   *id = soap_strdup(soap, soap->href);

	push	eax
	push	esi
	call	_soap_strdup

; 2081 :   xp = (struct soap_xlist*)SOAP_MALLOC(soap, sizeof(struct soap_xlist));

	push	24					; 00000018H
	mov	DWORD PTR [edi], eax
	call	_malloc
	add	esp, 12					; 0000000cH

; 2082 :   if (!xp)

	test	eax, eax
	jne	SHORT $LN1@soap_dime_

; 2083 :     return soap->error = SOAP_EOM;

	mov	eax, 20					; 00000014H
	pop	ebp
	mov	DWORD PTR [esi+90460], eax
	pop	ebx

; 2092 : }

	ret	0
$LN1@soap_dime_:

; 2084 :   xp->next = soap->xlist;

	mov	edx, DWORD PTR [esi+90544]

; 2085 :   xp->ptr = ptr;

	mov	ecx, DWORD PTR _ptr$[esp+4]
	mov	DWORD PTR [eax], edx

; 2086 :   xp->size = size;

	mov	edx, DWORD PTR _size$[esp+4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx

; 2087 :   xp->id = *id;

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax+12], ecx

; 2088 :   xp->type = type;

	mov	DWORD PTR [eax+16], ebp

; 2089 :   xp->options = options;

	mov	DWORD PTR [eax+20], ebx

; 2090 :   soap->xlist = xp;

	mov	DWORD PTR [esi+90544], eax
$LN5@soap_dime_:
	pop	ebp

; 2091 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 2092 : }

	ret	0
_soap_dime_forward ENDP
_TEXT	ENDS
PUBLIC	_soap_tell
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_tell PROC
; _soap$ = ecx

; 1654 : { return soap->count - soap->buflen + soap->bufidx - (soap->ahead != 0);

	mov	eax, DWORD PTR [ecx+12448]
	xor	edx, edx
	cmp	DWORD PTR [ecx+12436], edx
	setne	dl
	sub	eax, edx
	sub	eax, DWORD PTR [ecx+12432]
	add	eax, DWORD PTR [ecx+12428]

; 1655 : }

	ret	0
_soap_tell ENDP
_TEXT	ENDS
PUBLIC	_soap_code_list
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_code_map$ = 12						; size = 4
_code$ = 16						; size = 4
_soap_code_list PROC

; 1411 : { register char *t = soap->tmpbuf;

	push	ebx
	mov	ebx, DWORD PTR _code_map$[esp]
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+4]
	lea	eax, DWORD PTR [ebp+79028]
	mov	ecx, eax

; 1412 :   if (code_map)

	test	ebx, ebx
	je	SHORT $LN18@soap_code_
	push	esi

; 1413 :   { while (code_map->string)

	mov	esi, DWORD PTR [ebx+4]
	test	esi, esi
	je	SHORT $LN17@soap_code_
	push	edi
	npad	1
$LL7@soap_code_:

; 1414 :     { if (code_map->code & code)

	mov	edx, DWORD PTR _code$[esp+12]
	test	DWORD PTR [ebx], edx
	je	SHORT $LN1@soap_code_

; 1415 :       { register const char *s = code_map->string;
; 1416 :         if (t != soap->tmpbuf)

	cmp	ecx, eax
	je	SHORT $LN12@soap_code_

; 1417 :           *t++ = ' ';

	mov	BYTE PTR [ecx], 32			; 00000020H
	inc	ecx
$LN12@soap_code_:

; 1418 :         while (*s && t < soap->tmpbuf + sizeof(soap->tmpbuf) - 1)

	mov	dl, BYTE PTR [esi]
	test	dl, dl
	je	SHORT $LN19@soap_code_
	lea	edi, DWORD PTR [ebp+80051]
	npad	4
$LL3@soap_code_:
	cmp	ecx, edi
	jae	SHORT $LN19@soap_code_

; 1419 :           *t++ = *s++;

	inc	esi
	mov	BYTE PTR [ecx], dl
	mov	dl, BYTE PTR [esi]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL3@soap_code_
$LN19@soap_code_:

; 1420 :         if (t == soap->tmpbuf + sizeof(soap->tmpbuf) - 1)

	lea	edx, DWORD PTR [ebp+80051]
	cmp	ecx, edx
	je	SHORT $LN16@soap_code_
$LN1@soap_code_:

; 1413 :   { while (code_map->string)

	mov	esi, DWORD PTR [ebx+12]

; 1421 :           break;
; 1422 :       }
; 1423 :       code_map++;

	add	ebx, 8
	test	esi, esi
	jne	SHORT $LL7@soap_code_
$LN16@soap_code_:
	pop	edi
	pop	esi
	pop	ebp

; 1424 :     }
; 1425 :   }
; 1426 :   *t = '\0';

	mov	BYTE PTR [ecx], 0
	pop	ebx

; 1427 :   return soap->tmpbuf;
; 1428 : }

	ret	0
$LN17@soap_code_:
	pop	esi
	pop	ebp

; 1424 :     }
; 1425 :   }
; 1426 :   *t = '\0';

	mov	BYTE PTR [ecx], 0
	pop	ebx

; 1427 :   return soap->tmpbuf;
; 1428 : }

	ret	0
$LN18@soap_code_:
	pop	ebp

; 1424 :     }
; 1425 :   }
; 1426 :   *t = '\0';

	mov	BYTE PTR [ecx], 0
	pop	ebx

; 1427 :   return soap->tmpbuf;
; 1428 : }

	ret	0
_soap_code_list ENDP
_TEXT	ENDS
PUBLIC	_soap_code_bits
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_code_map$ = 8						; size = 4
_soap_code_bits PROC
; _str$ = eax

; 1383 : { register long bits = 0;

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, eax

; 1384 :   if (code_map)

	mov	eax, DWORD PTR _code_map$[esp+12]
	xor	ebp, ebp
	test	eax, eax
	je	SHORT $LN8@soap_code_@2

; 1385 :   { while (str && *str)

	test	edi, edi
	jne	SHORT $LN9@soap_code_@2
$LN8@soap_code_@2:
	pop	edi
	pop	esi

; 1399 :     }
; 1400 :   }
; 1401 :   return bits;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 1402 : }

	ret	0
	npad	5
$LL22@soap_code_@2:

; 1385 :   { while (str && *str)

	mov	eax, DWORD PTR _code_map$[esp+12]
$LN9@soap_code_@2:
	cmp	BYTE PTR [edi], 0
	je	SHORT $LN8@soap_code_@2

; 1386 :     { const struct soap_code_map *p;
; 1387 :       for (p = code_map; p->string; p++)

	mov	ebx, eax
	add	eax, 4
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN21@soap_code_@2
$LL7@soap_code_@2:

; 1388 :       { register size_t n = strlen(p->string);

	mov	edx, DWORD PTR [eax]
	mov	eax, edx
	lea	esi, DWORD PTR [eax+1]
	npad	6
$LL20@soap_code_@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL20@soap_code_@2
	sub	eax, esi
	mov	esi, eax

; 1389 :         if (!strncmp(p->string, str, n) && soap_blank(str[n]))

	push	esi
	push	edi
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@soap_code_@2
	mov	al, BYTE PTR [esi+edi]
	test	al, al
	jl	SHORT $LN6@soap_code_@2
	cmp	al, 32					; 00000020H
	jle	SHORT $LN16@soap_code_@2
$LN6@soap_code_@2:

; 1386 :     { const struct soap_code_map *p;
; 1387 :       for (p = code_map; p->string; p++)

	add	ebx, 8
	cmp	DWORD PTR [ebx+4], 0
	lea	eax, DWORD PTR [ebx+4]
	jne	SHORT $LL7@soap_code_@2

; 1394 :           break;
; 1395 :         }
; 1396 :       }
; 1397 :       if (!p->string)

	jmp	SHORT $LN21@soap_code_@2
$LN16@soap_code_@2:

; 1390 :         { bits |= p->code;
; 1391 :           str += n;
; 1392 :           while (*str > 0 && *str <= 32)

	mov	al, BYTE PTR [edi+esi]
	or	ebp, DWORD PTR [ebx]
	add	edi, esi
	test	al, al
	jle	SHORT $LN21@soap_code_@2
	npad	2
$LL3@soap_code_@2:
	cmp	al, 32					; 00000020H
	jg	SHORT $LN21@soap_code_@2
	mov	al, BYTE PTR [edi+1]

; 1393 :             str++;

	inc	edi
	test	al, al
	jg	SHORT $LL3@soap_code_@2
$LN21@soap_code_@2:

; 1394 :           break;
; 1395 :         }
; 1396 :       }
; 1397 :       if (!p->string)

	cmp	DWORD PTR [ebx+4], 0
	jne	SHORT $LL22@soap_code_@2
	pop	edi
	pop	esi
	pop	ebp

; 1398 :         return 0;

	xor	eax, eax
	pop	ebx

; 1402 : }

	ret	0
_soap_code_bits ENDP
_TEXT	ENDS
PUBLIC	_soap_code_str
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_code_str PROC
; _code_map$ = eax
; _code$ = ecx

; 1369 : { if (!code_map)

	test	eax, eax
	jne	SHORT $LN6@soap_code_@3

; 1374 : }

	ret	0
$LN6@soap_code_@3:

; 1370 :     return NULL;
; 1371 :   while (code_map->code != code && code_map->string)

	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN1@soap_code_@3
	npad	7
$LL2@soap_code_@3:
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@soap_code_@3

; 1372 :     code_map++;

	add	eax, 8
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LL2@soap_code_@3
$LN1@soap_code_@3:

; 1373 :   return code_map->string;

	mov	eax, DWORD PTR [eax+4]

; 1374 : }

	ret	0
_soap_code_str ENDP
_TEXT	ENDS
PUBLIC	_soap_code_int
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_other$ = 8						; size = 4
_soap_code_int PROC
; _code_map$ = eax
; _str$ = edi

; 1352 : { if (code_map)

	push	esi
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN2@soap_code_@4

; 1353 :   { while (code_map->string)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN2@soap_code_@4
	npad	2
$LL3@soap_code_@4:

; 1354 :     { if (!soap_tag_cmp(str, code_map->string)) /* case insensitive */

	push	eax
	push	edi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@soap_code_@4
	mov	eax, DWORD PTR [esi+12]

; 1356 :       code_map++;

	add	esi, 8
	test	eax, eax
	jne	SHORT $LL3@soap_code_@4
$LN2@soap_code_@4:

; 1357 :     }
; 1358 :   }
; 1359 :   return other;

	mov	eax, DWORD PTR _other$[esp]
	pop	esi

; 1360 : }

	ret	0
$LN8@soap_code_@4:

; 1355 :         return code_map->code;

	mov	eax, DWORD PTR [esi]
	pop	esi

; 1360 : }

	ret	0
_soap_code_int ENDP
_TEXT	ENDS
PUBLIC	_soap_code
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_code PROC
; _str$ = esi

; 1335 : { if (code_map && str)

	push	ebx
	mov	eax, OFFSET _soap_codes_bool
	test	esi, esi
	je	SHORT $LN2@soap_code

; 1336 :   { while (code_map->string)

	mov	edx, DWORD PTR _soap_codes_bool+4
	test	edx, edx
	je	SHORT $LN2@soap_code
$LL3@soap_code:

; 1337 :     { if (!strcmp(str, code_map->string)) /* case sensitive */

	mov	ecx, esi
$LL10@soap_code:
	mov	bl, BYTE PTR [ecx]
	cmp	bl, BYTE PTR [edx]
	jne	SHORT $LN11@soap_code
	test	bl, bl
	je	SHORT $LN12@soap_code
	mov	bl, BYTE PTR [ecx+1]
	cmp	bl, BYTE PTR [edx+1]
	jne	SHORT $LN11@soap_code
	add	ecx, 2
	add	edx, 2
	test	bl, bl
	jne	SHORT $LL10@soap_code
$LN12@soap_code:
	xor	ecx, ecx
	jmp	SHORT $LN13@soap_code
$LN11@soap_code:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN13@soap_code:
	test	ecx, ecx
	je	SHORT $LN5@soap_code
	mov	edx, DWORD PTR [eax+12]

; 1338 :         return code_map;
; 1339 :       code_map++;

	add	eax, 8
	test	edx, edx
	jne	SHORT $LL3@soap_code
$LN2@soap_code:

; 1340 :     }
; 1341 :   }
; 1342 :   return NULL;

	xor	eax, eax
$LN5@soap_code:
	pop	ebx

; 1343 : }

	ret	0
_soap_code ENDP
; Function compile flags: /Ogtpy
_soap_isxdigit PROC
; _c$ = eax

; 1070 : { return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');

	cmp	eax, 48					; 00000030H
	jl	SHORT $LN3@soap_isxdi
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN5@soap_isxdi
$LN3@soap_isxdi:
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN4@soap_isxdi
	cmp	eax, 70					; 00000046H
	jle	SHORT $LN5@soap_isxdi
$LN4@soap_isxdi:
	add	eax, -97				; ffffff9fH
	cmp	eax, 5
	ja	SHORT $LN6@soap_isxdi
$LN5@soap_isxdi:
	mov	eax, 1

; 1071 : }

	ret	0
$LN6@soap_isxdi:

; 1070 : { return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');

	xor	eax, eax

; 1071 : }

	ret	0
_soap_isxdigit ENDP
; Function compile flags: /Ogtpy
_soap_getchunkchar PROC
; _soap$ = esi

; 1053 : { if (soap->bufidx < soap->buflen)

	mov	ecx, DWORD PTR [esi+12428]
	cmp	ecx, DWORD PTR [esi+12432]

; 1054 :     return soap->buf[soap->bufidx++];

	jb	SHORT $LN5@soap_getch

; 1055 :   soap->bufidx = 0;
; 1056 :   soap->buflen = soap->chunkbuflen = soap->frecv(soap, soap->buf, SOAP_BUFLEN);

	mov	ecx, DWORD PTR [esi+12312]
	push	65536					; 00010000H
	lea	eax, DWORD PTR [esi+12468]
	push	eax
	push	esi
	mov	DWORD PTR [esi+12428], 0
	call	ecx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+87316], eax
	mov	DWORD PTR [esi+12432], eax

; 1057 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Read %u bytes from socket %d\n", (unsigned int)soap->buflen, soap->socket));
; 1058 :   DBGMSG(RECV, soap->buf, soap->buflen);
; 1059 :   if (soap->buflen)

	test	eax, eax
	je	SHORT $LN1@soap_getch

; 1060 :     return soap->buf[soap->bufidx++];

	mov	ecx, DWORD PTR [esi+12428]
$LN5@soap_getch:
	movsx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx

; 1062 : }

	ret	0
$LN1@soap_getch:

; 1061 :   return EOF;

	or	eax, -1

; 1062 : }

	ret	0
_soap_getchunkchar ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_frecv_stop PROC

; 1042 : { return 0;

	xor	eax, eax

; 1043 : }

	ret	0
_frecv_stop ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_soap_flush_raw
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_t$78476 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_soap_flush_raw PROC
; _soap$ = esi
; _n$ = edi

; 784  : { if ((soap->mode & SOAP_IO) == SOAP_IO_STORE)

	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+20], eax
	mov	eax, DWORD PTR [esi+8]
	and	eax, 3
	push	ebx
	mov	ebx, DWORD PTR _s$[esp+20]
	cmp	eax, 2
	jne	$LN5@soap_flush

; 785  :   { register char *t;
; 786  :     if (!(t = (char*)soap_push_block(soap, n)))

	lea	eax, DWORD PTR [edi+8]
	push	eax
	call	_malloc
	add	esp, 4
	mov	edx, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN8@soap_flush
	mov	DWORD PTR [esi+90460], edx

; 787  :       return soap->error = SOAP_EOM;

	mov	DWORD PTR [esi+90460], edx
	mov	eax, edx
	pop	ebx

; 807  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+20]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 20					; 00000014H
	ret	0

; 785  :   { register char *t;
; 786  :     if (!(t = (char*)soap_push_block(soap, n)))

$LN8@soap_flush:
	mov	ecx, DWORD PTR [esi+92]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edi
	mov	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR [esi+92]
	add	DWORD PTR [ecx+8], edi
	add	eax, 8
	jne	SHORT $LN4@soap_flush

; 787  :       return soap->error = SOAP_EOM;

	mov	DWORD PTR [esi+90460], edx
	mov	eax, edx
	pop	ebx

; 807  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+20]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 20					; 00000014H
	ret	0
$LN4@soap_flush:

; 788  :     memcpy(t, s, n);

	push	edi
	push	ebx
	push	eax
	call	_memcpy

; 789  : #ifndef WITH_LEANER
; 790  :     if (soap->fpreparesend)

	mov	eax, DWORD PTR [esi+12344]
	add	esp, 12					; 0000000cH
	test	eax, eax

; 791  :       return soap->error = soap->fpreparesend(soap, s, n);

	jne	SHORT $LN13@soap_flush
	pop	ebx

; 807  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+20]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 20					; 00000014H
	ret	0
$LN5@soap_flush:

; 792  : #endif
; 793  :     return SOAP_OK;
; 794  :   }
; 795  : #ifndef WITH_LEANER
; 796  :   if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK)

	cmp	eax, 3
	jne	SHORT $LN2@soap_flush

; 797  :   { char t[16];
; 798  :     sprintf(t, "\r\n%lX\r\n" + (soap->chunksize ? 0 : 2), (unsigned long)n);

	mov	edx, DWORD PTR [esi+87312]
	neg	edx
	sbb	edx, edx
	and	edx, -2					; fffffffeH
	add	edx, 2
	push	edi
	add	edx, OFFSET ??_C@_07FCIFDIFE@?$AN?6?$CFlX?$AN?6?$AA@
	push	edx
	lea	eax, DWORD PTR _t$78476[esp+32]
	push	eax
	call	_sprintf

; 799  :     DBGMSG(SENT, t, strlen(t));
; 800  :     if ((soap->error = soap->fsend(soap, t, strlen(t))))

	lea	eax, DWORD PTR _t$78476[esp+36]
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL12@soap_flush:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL12@soap_flush
	sub	eax, edx
	mov	edx, DWORD PTR [esi+12308]
	push	eax
	lea	ecx, DWORD PTR _t$78476[esp+28]
	push	ecx
	push	esi
	call	edx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax

; 801  :       return soap->error;

	jne	SHORT $LN6@soap_flush

; 802  :     soap->chunksize += n;

	add	DWORD PTR [esi+87312], edi
$LN2@soap_flush:

; 803  :   }
; 804  :   DBGMSG(SENT, s, n);
; 805  : #endif
; 806  :   return soap->error = soap->fsend(soap, s, n);

	mov	eax, DWORD PTR [esi+12308]
$LN13@soap_flush:
	push	edi
	push	ebx
	push	esi
	call	eax
	mov	DWORD PTR [esi+90460], eax
	add	esp, 12					; 0000000cH
$LN6@soap_flush:

; 807  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+24]
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 20					; 00000014H
	ret	0
_soap_flush_raw ENDP
_TEXT	ENDS
PUBLIC	_soap_flush
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_flush PROC
; _soap$ = eax

; 746  : { register size_t n = soap->bufidx;

	push	esi
	mov	esi, eax
	push	edi
	mov	edi, DWORD PTR [esi+12428]

; 747  :   if (n)

	test	edi, edi
	je	SHORT $LN1@soap_flush@2

; 748  :   { soap->bufidx = 0;
; 749  : #ifdef WITH_ZLIB
; 750  :     if (soap->mode & SOAP_ENC_ZLIB)
; 751  :     { soap->d_stream->next_in = (Byte*)soap->buf;
; 752  :       soap->d_stream->avail_in = (unsigned int)n;
; 753  : #ifdef WITH_GZIP
; 754  :       soap->z_crc = crc32(soap->z_crc, (Byte*)soap->buf, (unsigned int)n);
; 755  : #endif
; 756  :       do
; 757  :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Deflating %u bytes\n", soap->d_stream->avail_in));
; 758  :         if (deflate(soap->d_stream, Z_NO_FLUSH) != Z_OK)
; 759  :         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unable to deflate: %s\n", soap->d_stream->msg?soap->d_stream->msg:""));
; 760  :           return soap->error = SOAP_ZLIB_ERROR;
; 761  :         }
; 762  :         if (!soap->d_stream->avail_out)
; 763  :         { if (soap_flush_raw(soap, soap->z_buf, SOAP_BUFLEN))
; 764  :             return soap->error;
; 765  :           soap->d_stream->next_out = (Byte*)soap->z_buf;
; 766  :           soap->d_stream->avail_out = SOAP_BUFLEN;
; 767  :         }
; 768  :       } while (soap->d_stream->avail_in);
; 769  :     }
; 770  :     else
; 771  : #endif
; 772  :       return soap_flush_raw(soap, soap->buf, n);

	lea	eax, DWORD PTR [esi+12468]
	push	eax
	mov	DWORD PTR [esi+12428], 0
	call	_soap_flush_raw
	add	esp, 4
	pop	edi
	pop	esi

; 775  : }

	ret	0
$LN1@soap_flush@2:
	pop	edi

; 773  :   }
; 774  :   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 775  : }

	ret	0
_soap_flush ENDP
_TEXT	ENDS
PUBLIC	_soap_send_raw
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_s$ = 8							; size = 4
_n$ = 12						; size = 4
_soap_send_raw PROC
; _soap$ = eax

; 711  : { if (!n)

	push	ebp
	mov	ebp, DWORD PTR _n$[esp]
	push	esi
	mov	esi, eax
	test	ebp, ebp
	jne	SHORT $LN7@soap_send_
$LN5@soap_send_:
	pop	esi

; 712  :     return SOAP_OK;

	xor	eax, eax
	pop	ebp

; 737  : }

	ret	0
$LN7@soap_send_:

; 713  :   if (soap->mode & SOAP_IO_LENGTH)

	mov	ecx, DWORD PTR [esi+8]
	test	cl, 8
	je	SHORT $LN6@soap_send_

; 714  :   { soap->count += n;
; 715  : #ifndef WITH_LEANER
; 716  :     if (soap->fpreparesend && (soap->mode & SOAP_IO) != SOAP_IO_STORE)

	mov	eax, DWORD PTR [esi+12344]
	add	DWORD PTR [esi+12448], ebp
	test	eax, eax
	je	SHORT $LN5@soap_send_
	and	cl, 3
	cmp	cl, 2
	je	SHORT $LN5@soap_send_

; 717  :       return soap->error = soap->fpreparesend(soap, s, n);

	mov	ecx, DWORD PTR _s$[esp+4]
	push	ebp
	push	ecx
	push	esi
	call	eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+90460], eax
	pop	esi
	pop	ebp

; 737  : }

	ret	0
$LN6@soap_send_:
	push	edi

; 718  : #endif
; 719  :     return SOAP_OK;
; 720  :   }
; 721  :   if (soap->mode & SOAP_IO)

	test	cl, 3
	je	$LN4@soap_send_
	push	ebx

; 722  :   { register size_t i = SOAP_BUFLEN - soap->bufidx;

	mov	ebx, 65536				; 00010000H
	sub	ebx, DWORD PTR [esi+12428]

; 723  :     while (n >= i)

	cmp	ebp, ebx
	jb	SHORT $LN2@soap_send_
$LL3@soap_send_:

; 724  :     { memcpy(soap->buf + soap->bufidx, s, i);

	mov	edx, DWORD PTR _s$[esp+12]
	mov	eax, DWORD PTR [esi+12428]
	push	ebx
	push	edx
	lea	ecx, DWORD PTR [esi+eax+12468]
	push	ecx
	call	_memcpy

; 725  :       soap->bufidx = SOAP_BUFLEN;
; 726  :       if (soap_flush(soap))

	lea	eax, DWORD PTR [esi+12468]
	push	eax
	mov	edi, 65536				; 00010000H
	mov	DWORD PTR [esi+12428], 0
	call	_soap_flush_raw
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN14@soap_send_

; 728  :       s += i;

	add	DWORD PTR _s$[esp+12], ebx

; 729  :       n -= i;

	sub	ebp, ebx

; 730  :       i = SOAP_BUFLEN;

	mov	ebx, edi
	cmp	ebp, ebx
	jae	SHORT $LL3@soap_send_
$LN2@soap_send_:

; 731  :     }
; 732  :     memcpy(soap->buf + soap->bufidx, s, n);

	mov	edx, DWORD PTR _s$[esp+12]
	mov	eax, DWORD PTR [esi+12428]
	push	ebp
	push	edx
	lea	ecx, DWORD PTR [esi+eax+12468]
	push	ecx
	call	_memcpy

; 733  :     soap->bufidx += n;

	add	DWORD PTR [esi+12428], ebp
	add	esp, 12					; 0000000cH
	pop	ebx
	pop	edi
	pop	esi

; 734  :     return SOAP_OK;

	xor	eax, eax
	pop	ebp

; 737  : }

	ret	0
$LN14@soap_send_:

; 727  :         return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 737  : }

	ret	0
$LN4@soap_send_:

; 735  :   }
; 736  :   return soap_flush_raw(soap, s, n);

	mov	edx, DWORD PTR _s$[esp+8]
	push	edx
	mov	edi, ebp
	call	_soap_flush_raw
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp

; 737  : }

	ret	0
_soap_send_raw ENDP
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\time.inl
_mktime	PROC
; __Tm$ = eax

; 127  :     return _mktime64(_Tm);

	push	eax
	call	__mktime64
	add	esp, 4

; 128  : }

	ret	0
_mktime	ENDP
; Function compile flags: /Ogtpy
_localtime PROC
; __Time$ = eax

; 116  : #pragma warning( push )
; 117  : #pragma warning( disable : 4996 )
; 118  :     return _localtime64(_Time);

	push	eax
	call	__localtime64
	add	esp, 4

; 119  : #pragma warning( pop )
; 120  : }

	ret	0
_localtime ENDP
; Function compile flags: /Ogtpy
_gmtime PROC
; __Time$ = eax

; 103  : #pragma warning( push )
; 104  : #pragma warning( disable : 4996 )
; 105  :     return _gmtime64(_Time);

	push	eax
	call	__gmtime64
	add	esp, 4

; 106  : #pragma warning( pop )
; 107  : }

	ret	0
_gmtime	ENDP
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\sys\timeb.inl
_ftime	PROC
; __Tmb$ = eax

; 52   :     _STATIC_ASSERT( sizeof(struct timeb) == sizeof(struct __timeb64) );
; 53   :     _ftime64((struct __timeb64 *)_Tmb);

	push	eax
	call	__ftime64
	pop	ecx

; 54   : }

	ret	0
_ftime	ENDP
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\string.h
_TEXT	ENDS
;	COMDAT ?strstr@@YAPADPADPBD@Z
_TEXT	SEGMENT
?strstr@@YAPADPADPBD@Z PROC				; strstr, COMDAT
; __Str$ = ecx
; __SubStr$ = eax

; 190  : 	{ return (char*)strstr((const char*)_Str, _SubStr); }

	push	eax
	push	ecx
	call	_strstr
	add	esp, 8
	ret	0
?strstr@@YAPADPADPBD@Z ENDP				; strstr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?strrchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strrchr@@YAPADPADH@Z PROC				; strrchr, COMDAT

; 188  : 	{ return (char*)strrchr((const char*)_Str, _Ch); }

	jmp	_strrchr
?strrchr@@YAPADPADH@Z ENDP				; strrchr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?strchr@@YAPADPADH@Z
_TEXT	SEGMENT
?strchr@@YAPADPADH@Z PROC				; strchr, COMDAT
; __Str$ = ecx
; __Ch$ = eax

; 184  : 	{ return (char*)strchr((const char*)_Str, _Ch); }

	push	eax
	push	ecx
	call	_strchr
	add	esp, 8
	ret	0
?strchr@@YAPADPADH@Z ENDP				; strchr
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\stdsoap2.cpp
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_http_send_header PROC
; _s$ = eax

; 14025: { register const char *t;

	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	esi
	push	edi
	mov	edi, eax
	npad	7
$LL5@http_send_:

; 14026:   do
; 14027:   { t = strchr(s, '\n'); /* disallow \n in HTTP headers */

	push	10					; 0000000aH
	push	edi
	call	_strchr
	mov	esi, eax
	add	esp, 8

; 14028:     if (!t)

	test	esi, esi
	jne	SHORT $LN2@http_send_

; 14029:       t = s + strlen(s);

	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
$LL11@http_send_:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL11@http_send_
	sub	eax, edx
	lea	esi, DWORD PTR [eax+edi]
$LN2@http_send_:

; 14030:     if (soap_send_raw(soap, s, t - s))

	mov	eax, esi
	sub	eax, edi
	push	eax
	push	edi
	mov	eax, ebx
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@http_send_

; 14032:     s = t + 1;

	lea	edi, DWORD PTR [esi+1]

; 14033:   } while (*t);

	cmp	BYTE PTR [esi], al
	jne	SHORT $LL5@http_send_
	pop	edi
	pop	esi
	pop	ebx

; 14034:   return SOAP_OK;
; 14035: }

	ret	0
$LN9@http_send_:

; 14031:       return soap->error;

	mov	eax, DWORD PTR [ebx+90460]
	pop	edi
	pop	esi
	pop	ebx

; 14034:   return SOAP_OK;
; 14035: }

	ret	0
_http_send_header ENDP
_TEXT	ENDS
PUBLIC	_soap_hex2s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_l$ = 12						; size = 4
_n$ = 16						; size = 4
_soap_hex2s PROC
; _s$ = ecx
; _t$ = eax

; 13782: { register const char *p;

	push	ebx
	mov	ebx, DWORD PTR _l$[esp]
	push	ebp
	mov	ebp, DWORD PTR _n$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _soap$[esp+12]

; 13783:   if (!s || !*s)

	test	esi, esi
	je	$LN10@soap_hex2s
	cmp	BYTE PTR [esi], 0
	je	$LN10@soap_hex2s

; 13787:       return NULL;
; 13788:     return SOAP_NON_NULL;
; 13789:   }
; 13790:   if (!t)

	test	eax, eax
	jne	SHORT $LN23@soap_hex2s

; 13791:   { l = strlen(s) / 2;

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL22@soap_hex2s:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL22@soap_hex2s
	sub	eax, edx
	shr	eax, 1
	mov	ebx, eax

; 13792:     t = (char*)soap_malloc(soap, l);

	call	_soap_malloc

; 13793:   }
; 13794:   if (!t)

	test	eax, eax
	jne	SHORT $LN23@soap_hex2s

; 13795:   { soap->error = SOAP_EOM;

	mov	DWORD PTR [edi+90460], 20		; 00000014H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 13813: }

	ret	0
$LN23@soap_hex2s:

; 13796:     return NULL;
; 13797:   }
; 13798:   p = t;

	mov	edi, eax

; 13799:   while (l)

	test	ebx, ebx
	je	SHORT $LN24@soap_hex2s
	npad	5
$LL5@soap_hex2s:

; 13800:   { register int d1, d2;
; 13801:     d1 = *s++;

	movsx	ecx, BYTE PTR [esi]
	inc	esi

; 13802:     if (!d1)

	test	ecx, ecx
	je	SHORT $LN24@soap_hex2s

; 13803:       break;
; 13804:     d2 = *s++;

	movsx	edx, BYTE PTR [esi]
	inc	esi

; 13805:     if (!d2)

	test	edx, edx
	je	SHORT $LN24@soap_hex2s

; 13806:       break;
; 13807:     *t++ = ((d1 >= 'A' ? (d1 & 0x7) + 9 : d1 - '0') << 4) + (d2 >= 'A' ? (d2 & 0x7) + 9 : d2 - '0');

	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN14@soap_hex2s
	and	ecx, 7
	add	ecx, 9
	jmp	SHORT $LN15@soap_hex2s
$LN14@soap_hex2s:
	add	ecx, -48				; ffffffd0H
$LN15@soap_hex2s:
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN16@soap_hex2s
	and	edx, 7
	add	edx, 9
	jmp	SHORT $LN17@soap_hex2s
$LN16@soap_hex2s:
	add	edx, -48				; ffffffd0H
$LN17@soap_hex2s:
	shl	cl, 4
	add	cl, dl
	mov	BYTE PTR [eax], cl
	inc	eax

; 13808:     l--;

	sub	ebx, 1
	jne	SHORT $LL5@soap_hex2s
$LN24@soap_hex2s:

; 13809:   }
; 13810:   if (n)

	test	ebp, ebp
	je	SHORT $LN1@soap_hex2s

; 13811:     *n = (int)(t - p);

	sub	eax, edi
	mov	DWORD PTR [ebp], eax
$LN1@soap_hex2s:

; 13812:   return p;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 13813: }

	ret	0
$LN10@soap_hex2s:

; 13784:   { if (n)

	test	ebp, ebp
	je	SHORT $LN9@soap_hex2s

; 13785:       *n = 0;

	mov	DWORD PTR [ebp], 0
$LN9@soap_hex2s:

; 13786:     if (soap->error)

	mov	eax, DWORD PTR [edi+90460]
	neg	eax
	pop	edi
	sbb	eax, eax
	pop	esi
	not	eax
	pop	ebp
	and	eax, OFFSET _soap_padding
	pop	ebx

; 13813: }

	ret	0
_soap_hex2s ENDP
_TEXT	ENDS
PUBLIC	_soap_s2hex
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_s$ = 8							; size = 4
_n$ = 12						; size = 4
_soap_s2hex PROC
; _soap$ = ecx
; _t$ = eax

; 13754: { register char *p;

	push	ebx
	mov	ebx, DWORD PTR _s$[esp]
	push	ebp
	mov	ebp, DWORD PTR _n$[esp+4]
	push	esi
	mov	esi, eax
	push	edi
	mov	edi, ecx

; 13755:   if (!t)

	test	esi, esi
	jne	SHORT $LN11@soap_s2hex

; 13756:     t = (char*)soap_malloc(soap, 2 * n + 1);

	lea	eax, DWORD PTR [ebp+ebp+1]
	call	_soap_malloc
	mov	esi, eax

; 13757:   if (!t)

	test	esi, esi
	jne	SHORT $LN11@soap_s2hex

; 13758:   { soap->error = SOAP_EOM;

	mov	DWORD PTR [edi+90460], 20		; 00000014H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 13773: }

	ret	0
$LN11@soap_s2hex:

; 13759:     return NULL;
; 13760:   }
; 13761:   p = t;

	mov	edi, esi

; 13762:   t[0] = '\0';

	mov	BYTE PTR [esi], 0

; 13763:   if (s)

	test	ebx, ebx
	je	SHORT $LN1@soap_s2hex

; 13764:   { for (; n > 0; n--)

	test	ebp, ebp
	jle	SHORT $LN1@soap_s2hex
	npad	1
$LL3@soap_s2hex:

; 13765:     { register int m = *s++;

	movzx	ecx, BYTE PTR [ebx]
	inc	ebx

; 13766:       *t++ = (char)((m >> 4) + (m > 159 ? 'a' - 10 : '0'));

	cmp	ecx, 159				; 0000009fH
	setle	al
	dec	al
	and	al, 39					; 00000027H
	add	al, 48					; 00000030H
	mov	edx, ecx
	sar	edx, 4
	add	al, dl
	mov	BYTE PTR [esi], al
	inc	esi

; 13767:       m &= 0x0F;

	and	ecx, 15					; 0000000fH

; 13768:       *t++ = (char)(m + (m > 9 ? 'a' - 10 : '0'));

	cmp	ecx, 9
	setle	al
	dec	al
	and	al, 39					; 00000027H
	add	al, 48					; 00000030H
	add	al, cl
	mov	BYTE PTR [esi], al
	dec	ebp
	inc	esi
	test	ebp, ebp
	jg	SHORT $LL3@soap_s2hex
$LN1@soap_s2hex:

; 13769:     }
; 13770:   }
; 13771:   *t++ = '\0';
; 13772:   return p;

	mov	eax, edi
	pop	edi
	mov	BYTE PTR [esi], 0
	pop	esi
	pop	ebp
	pop	ebx

; 13773: }

	ret	0
_soap_s2hex ENDP
_TEXT	ENDS
PUBLIC	_soap_base642s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_l$ = -4						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_soap_base642s PROC
; _t$ = eax

; 13674: { register int i, j, c;

	push	ecx
	push	ebp
	mov	ebp, DWORD PTR _s$[esp+4]
	push	esi
	push	edi
	mov	esi, eax
	mov	edi, 1023				; 000003ffH

; 13675:   register unsigned long m;
; 13676:   register const char *p;
; 13677:   if (!s || !*s)

	test	ebp, ebp
	je	$LN28@soap_base6
	cmp	BYTE PTR [ebp], 0
	je	$LN28@soap_base6

; 13681:       return NULL;
; 13682:     return SOAP_NON_NULL;
; 13683:   }
; 13684:   if (!t)

	test	esi, esi
	jne	SHORT $LN24@soap_base6

; 13685:   { l = (strlen(s) + 3) / 4 * 3;

	mov	eax, ebp
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL46@soap_base6:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL46@soap_base6

; 13686:     t = (char*)soap_malloc(soap, l);

	mov	edi, DWORD PTR _soap$[esp+12]
	sub	eax, edx
	add	eax, 3
	shr	eax, 2
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _l$[esp+16], eax
	call	_soap_malloc
	mov	esi, eax

; 13687:   }
; 13688:   if (!t)

	test	esi, esi
	jne	SHORT $LN50@soap_base6

; 13689:   { soap->error = SOAP_EOM;

	mov	DWORD PTR [edi+90460], 20		; 00000014H
	pop	edi
	pop	esi
	pop	ebp

; 13745: }

	pop	ecx
	ret	0
$LN50@soap_base6:

; 13687:   }
; 13688:   if (!t)

	mov	edi, DWORD PTR _l$[esp+16]
$LN24@soap_base6:

; 13690:     return NULL;
; 13691:   }
; 13692:   p = t;
; 13693:   if (n)

	mov	eax, DWORD PTR _n$[esp+12]
	mov	DWORD PTR _p$[esp+12], esi
	test	eax, eax
	je	SHORT $LN54@soap_base6

; 13694:     *n = 0;

	mov	DWORD PTR [eax], 0
$LN54@soap_base6:
	push	ebx
	npad	5
$LL22@soap_base6:

; 13695:   for (;;)
; 13696:   { for (i = 0; i < SOAP_BLKLEN; i++)

	xor	eax, eax
$LL52@soap_base6:

; 13697:     { m = 0;

	xor	edx, edx

; 13698:       j = 0;

	xor	ebx, ebx
$LL17@soap_base6:

; 13700:       { c = *s++;

	movsx	ecx, BYTE PTR [ebp]
	inc	ebp

; 13701:         if (c == '=' || !c)

	cmp	ecx, 61					; 0000003dH
	je	$LN53@soap_base6
	test	ecx, ecx
	je	$LN53@soap_base6

; 13716:         }
; 13717:         c -= '+';

	sub	ecx, 43					; 0000002bH

; 13718:         if (c >= 0 && c <= 79)

	cmp	ecx, 79					; 0000004fH
	ja	SHORT $LN8@soap_base6

; 13719:         { int b = soap_base64i[c];

	movsx	ecx, BYTE PTR _soap_base64i[ecx]

; 13720:           if (b >= 64)

	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN36@soap_base6

; 13723:           }
; 13724:           m = (m << 6) + b;

	shl	edx, 6
	add	edx, ecx

; 13725:           j++;

	inc	ebx
	jmp	SHORT $LN5@soap_base6
$LN8@soap_base6:

; 13726:         }
; 13727:         else if (!soap_blank(c + '+'))

	add	ecx, 43					; 0000002bH
	js	SHORT $LN37@soap_base6
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN37@soap_base6
$LN5@soap_base6:

; 13699:       while (j < 4)

	cmp	ebx, 4
	jl	SHORT $LL17@soap_base6

; 13730:         }
; 13731:       }
; 13732:       *t++ = (char)((m >> 16) & 0xFF);

	mov	ecx, edx
	shr	ecx, 16					; 00000010H
	mov	BYTE PTR [esi], cl
	inc	esi

; 13733:       *t++ = (char)((m >> 8) & 0xFF);

	mov	ecx, edx
	shr	ecx, 8
	mov	BYTE PTR [esi], cl
	inc	esi

; 13734:       *t++ = (char)(m & 0xFF);

	mov	BYTE PTR [esi], dl
	inc	esi

; 13735:       if (l < 3)

	cmp	edi, 3
	jb	$LN38@soap_base6
	inc	eax

; 13738:         return p;
; 13739:       }
; 13740:       l -= 3;

	sub	edi, 3
	cmp	eax, 256				; 00000100H
	jl	SHORT $LL52@soap_base6

; 13741:     }
; 13742:     if (n)

	cmp	DWORD PTR _n$[esp+16], 0
	je	SHORT $LL22@soap_base6

; 13743:       *n += 3 * SOAP_BLKLEN;

	mov	eax, DWORD PTR _n$[esp+16]
	add	DWORD PTR [eax], 768			; 00000300H

; 13744:   }

	jmp	$LL22@soap_base6
$LN36@soap_base6:

; 13721:           { soap->error = SOAP_TYPE;

	mov	edx, DWORD PTR _soap$[esp+16]
	pop	ebx
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+90460], 4

; 13722:             return NULL;

	xor	eax, eax
	pop	ebp

; 13745: }

	pop	ecx
	ret	0
$LN37@soap_base6:

; 13728:         { soap->error = SOAP_TYPE;

	mov	eax, DWORD PTR _soap$[esp+16]
	pop	ebx
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+90460], 4

; 13729:           return NULL;

	xor	eax, eax
	pop	ebp

; 13745: }

	pop	ecx
	ret	0
$LN53@soap_base6:

; 13702:         { i *= 3;
; 13703:           switch (j)

	mov	ecx, ebx
	sub	ecx, 2
	lea	edi, DWORD PTR [eax+eax*2]
	je	SHORT $LN11@soap_base6
	sub	ecx, 1
	jne	SHORT $LN12@soap_base6

; 13707:               break;
; 13708:             case 3:
; 13709:               *t++ = (char)((m >> 10) & 0xFF);

	mov	ecx, edx
	shr	ecx, 10					; 0000000aH

; 13710:               *t++ = (char)((m >> 2) & 0xFF);

	shr	edx, 2
	mov	BYTE PTR [esi], cl
	mov	BYTE PTR [esi+1], dl

; 13711:               i += 2;

	add	edi, 2
	jmp	SHORT $LN12@soap_base6
$LN11@soap_base6:

; 13704:           { case 2:
; 13705:               *t++ = (char)((m >> 4) & 0xFF);

	shr	edx, 4
	mov	BYTE PTR [esi], dl

; 13706:               i++;

	inc	edi
$LN12@soap_base6:

; 13712:           }
; 13713:           if (n)

	mov	eax, DWORD PTR _n$[esp+16]
	test	eax, eax
	je	SHORT $LN9@soap_base6

; 13714:             *n += i;

	add	DWORD PTR [eax], edi
$LN9@soap_base6:

; 13715:           return p;

	mov	eax, DWORD PTR _p$[esp+16]
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 13745: }

	pop	ecx
	ret	0
$LN38@soap_base6:

; 13736:       { if (n)

	mov	ecx, DWORD PTR _n$[esp+16]
	test	ecx, ecx
	je	SHORT $LN9@soap_base6

; 13737:           *n += i;

	add	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _p$[esp+16]
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 13745: }

	pop	ecx
	ret	0
$LN28@soap_base6:

; 13678:   { if (n)

	mov	eax, DWORD PTR _n$[esp+12]
	test	eax, eax
	je	SHORT $LN27@soap_base6

; 13679:       *n = 0;

	mov	DWORD PTR [eax], 0
$LN27@soap_base6:

; 13680:     if (soap->error)

	mov	edx, DWORD PTR _soap$[esp+12]
	mov	eax, DWORD PTR [edx+90460]
	neg	eax
	sbb	eax, eax
	pop	edi
	not	eax
	pop	esi
	and	eax, OFFSET _soap_padding
	pop	ebp

; 13745: }

	pop	ecx
	ret	0
_soap_base642s ENDP
_TEXT	ENDS
PUBLIC	_soap_s2base64
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_p$ = -4						; size = 4
_s$ = 8							; size = 4
_n$ = 12						; size = 4
_soap_s2base64 PROC
; _soap$ = ecx
; _t$ = eax

; 13630: { register int i;

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _n$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR _s$[esp+8]
	push	esi
	mov	esi, eax
	push	edi
	mov	edi, ecx

; 13631:   register unsigned long m;
; 13632:   register char *p;
; 13633:   if (!t)

	test	esi, esi
	jne	SHORT $LN41@soap_s2bas

; 13634:     t = (char*)soap_malloc(soap, (n + 2) / 3 * 4 + 1);

	lea	ecx, DWORD PTR [ebx+2]
	mov	eax, 1431655766				; 55555556H
	imul	ecx
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	eax, DWORD PTR [eax*4+1]
	call	_soap_malloc
	mov	esi, eax

; 13635:   if (!t)

	test	esi, esi
	jne	SHORT $LN41@soap_s2bas

; 13636:   { soap->error = SOAP_EOM;

	mov	DWORD PTR [edi+90460], 20		; 00000014H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 13665: }

	pop	ecx
	ret	0
$LN41@soap_s2bas:

; 13637:     return NULL;
; 13638:   }
; 13639:   p = t;

	mov	DWORD PTR _p$[esp+20], esi

; 13640:   t[0] = '\0';

	mov	BYTE PTR [esi], 0

; 13641:   if (!s)

	test	ebp, ebp
	jne	SHORT $LN20@soap_s2bas
	pop	edi

; 13642:     return p;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 13665: }

	pop	ecx
	ret	0
$LN20@soap_s2bas:

; 13643:   for (; n > 2; n -= 3, s += 3)

	cmp	ebx, 2
	jle	SHORT $LN17@soap_s2bas
	lea	ecx, DWORD PTR [ebx-3]
	mov	eax, -1431655765			; aaaaaaabH
	mul	ecx
	mov	edi, edx
	shr	edi, 1
	inc	edi
	lea	edx, DWORD PTR [edi*4]
	sub	edx, edi
	neg	edx
	add	ebx, edx
	npad	4
$LL42@soap_s2bas:

; 13644:   { m = s[0];
; 13645:     m = (m << 8) | s[1];
; 13646:     m = (m << 8) | s[2];

	movzx	eax, BYTE PTR [ebp]
	movzx	ecx, BYTE PTR [ebp+1]
	movzx	edx, BYTE PTR [ebp+2]
	shl	eax, 8
	or	eax, ecx
	shl	eax, 8
	or	eax, edx

; 13647:     for (i = 4; i > 0; m >>= 6)

	mov	ecx, 4
	npad	5
$LL43@soap_s2bas:

; 13648:       t[--i] = soap_base64o[m & 0x3F];

	mov	edx, eax
	and	edx, 63					; 0000003fH
	mov	dl, BYTE PTR _soap_base64o[edx]
	dec	ecx
	shr	eax, 6
	mov	BYTE PTR [ecx+esi], dl
	test	ecx, ecx
	jg	SHORT $LL43@soap_s2bas

; 13649:     t += 4;

	add	esi, 4
	add	ebp, 3
	sub	edi, 1
	jne	SHORT $LL42@soap_s2bas
$LN17@soap_s2bas:

; 13650:   }
; 13651:   t[0] = '\0';

	mov	BYTE PTR [esi], 0

; 13652:   if (n > 0)

	test	ebx, ebx
	jle	SHORT $LN13@soap_s2bas

; 13653:   { m = 0;

	xor	ecx, ecx

; 13654:     for (i = 0; i < n; i++)

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN44@soap_s2bas
	mov	edx, ebx
	mov	eax, ebx
$LL12@soap_s2bas:

; 13655:       m = (m << 8) | *s++;

	movzx	edi, BYTE PTR [ebp]
	shl	ecx, 8
	or	ecx, edi
	inc	ebp
	sub	edx, 1
	jne	SHORT $LL12@soap_s2bas

; 13656:     for (; i < 3; i++)

	cmp	ebx, 3
	jge	SHORT $LN46@soap_s2bas
$LN44@soap_s2bas:

; 13657:       m <<= 8;

	mov	edx, 3
	sub	edx, eax
	add	eax, edx
$LL37@soap_s2bas:
	shl	ecx, 8
	sub	edx, 1
	jne	SHORT $LL37@soap_s2bas
$LN46@soap_s2bas:

; 13658:     for (i++; i > 0; m >>= 6)

	inc	eax
	test	eax, eax
	jle	SHORT $LN4@soap_s2bas
	npad	2
$LL47@soap_s2bas:

; 13659:       t[--i] = soap_base64o[m & 0x3F];

	mov	edx, ecx
	and	edx, 63					; 0000003fH
	mov	dl, BYTE PTR _soap_base64o[edx]
	dec	eax
	shr	ecx, 6
	mov	BYTE PTR [eax+esi], dl
	test	eax, eax
	jg	SHORT $LL47@soap_s2bas
$LN4@soap_s2bas:

; 13660:     for (i = 3; i > n; i--)

	mov	eax, 3
	cmp	ebx, eax
	jge	SHORT $LN1@soap_s2bas
	npad	1
$LL3@soap_s2bas:

; 13661:       t[i] = '=';

	mov	BYTE PTR [eax+esi], 61			; 0000003dH
	dec	eax
	cmp	eax, ebx
	jg	SHORT $LL3@soap_s2bas
$LN1@soap_s2bas:

; 13662:     t[4] = '\0';

	mov	BYTE PTR [esi+4], 0
$LN13@soap_s2bas:

; 13663:   }
; 13664:   return p;

	mov	eax, DWORD PTR _p$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 13665: }

	pop	ecx
	ret	0
_soap_s2base64 ENDP
_TEXT	ENDS
PUBLIC	_soap_get_header_attribute
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_key$ = 8						; size = 4
_soap_get_header_attribute PROC
; _soap$ = ecx
; _line$ = eax

; 13189: { register const char *s = line;

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _key$[esp+4]
	push	esi
	mov	esi, eax
	push	edi

; 13190:   if (s)

	test	esi, esi
	je	SHORT $LN2@soap_get_h@3

; 13191:   { while (*s)

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN2@soap_get_h@3
	mov	edi, ecx
	add	edi, 79028				; 000134b4H
	npad	5
$LL3@soap_get_h@3:

; 13192:     { register short flag;
; 13193:       s = soap_decode_key(soap->tmpbuf, sizeof(soap->tmpbuf), s);

	push	OFFSET ??_C@_03NBBPFACD@?$DN?0?$DL?$AA@
	mov	eax, esi
	mov	ecx, edi
	call	_soap_decode

; 13194:       flag = soap_tag_cmp(soap->tmpbuf, key);

	push	ebp
	push	edi
	mov	esi, eax
	call	_soap_tag_cmp
	add	esp, 12					; 0000000cH

; 13195:       s = soap_decode_val(soap->tmpbuf, sizeof(soap->tmpbuf), s);

	cmp	BYTE PTR [esi], 61			; 0000003dH
	movzx	ebx, ax
	je	SHORT $LN9@soap_get_h@3
	mov	BYTE PTR [edi], 0
	jmp	SHORT $LN10@soap_get_h@3
$LN9@soap_get_h@3:
	push	OFFSET ??_C@_02NFLHGFB@?0?$DL?$AA@
	lea	eax, DWORD PTR [esi+1]
	mov	ecx, edi
	call	_soap_decode
	add	esp, 4
	mov	esi, eax
$LN10@soap_get_h@3:

; 13196:       if (!flag)

	test	bx, bx
	je	SHORT $LN13@soap_get_h@3

; 13191:   { while (*s)

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LL3@soap_get_h@3
$LN2@soap_get_h@3:
	pop	edi
	pop	esi
	pop	ebp

; 13198:     }
; 13199:   }
; 13200:   return NULL;

	xor	eax, eax
	pop	ebx

; 13201: }

	ret	0
$LN13@soap_get_h@3:

; 13197:         return soap->tmpbuf;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 13201: }

	ret	0
_soap_get_header_attribute ENDP
; Function compile flags: /Ogtpy
_n$83645 = -4						; size = 4
_soap$ = 8						; size = 4
_key$ = 12						; size = 4
_val$ = 16						; size = 4
_http_parse_header PROC

; 13053: { if (!soap_tag_cmp(key, "Host"))

	push	ecx
	push	ebx
	push	esi
	mov	esi, DWORD PTR _key$[esp+8]
	push	edi
	push	OFFSET ??_C@_04CPPPJGME@Host?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN44@http_parse

; 13054:   {
; 13055: #ifdef WITH_OPENSSL
; 13056:     if (soap->imode & SOAP_ENC_SSL)
; 13057:       strcpy(soap->endpoint, "https://");
; 13058:     else
; 13059: #endif
; 13060:       strcpy(soap->endpoint, "http://");

	mov	ecx, DWORD PTR ??_C@_07FGAOOBMN@http?3?1?1?$AA@
	mov	esi, DWORD PTR _soap$[esp+12]
	lea	eax, DWORD PTR [esi+87320]
	mov	DWORD PTR [eax], ecx

; 13061:     strncat(soap->endpoint, val, sizeof(soap->endpoint) - 8);

	mov	ecx, DWORD PTR _val$[esp+12]
	mov	edx, DWORD PTR ??_C@_07FGAOOBMN@http?3?1?1?$AA@+4
	push	1016					; 000003f8H
	push	ecx
	push	eax
	mov	DWORD PTR [eax+4], edx
	call	_strncat
	add	esp, 12					; 0000000cH
	pop	edi

; 13062:     soap->endpoint[sizeof(soap->endpoint) - 1] = '\0';

	mov	BYTE PTR [esi+88343], 0
	pop	esi

; 13168:   }
; 13169: #ifdef WITH_COOKIES
; 13170:   else if (!soap_tag_cmp(key, "Cookie")
; 13171:    || !soap_tag_cmp(key, "Cookie2")
; 13172:    || !soap_tag_cmp(key, "Set-Cookie")
; 13173:    || !soap_tag_cmp(key, "Set-Cookie2"))
; 13174:   { soap_getcookies(soap, val);
; 13175:   }
; 13176: #endif
; 13177:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 13178: }

	pop	ecx
	ret	0
$LN44@http_parse:

; 13063:   }
; 13064: #ifndef WITH_LEANER
; 13065:   else if (!soap_tag_cmp(key, "Content-Type"))

	push	OFFSET ??_C@_0N@LAFFMKKA@Content?9Type?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	$LN42@http_parse

; 13066:   { const char *action;
; 13067:     soap->http_content = soap_strdup(soap, val);

	mov	edi, DWORD PTR _val$[esp+12]
	mov	esi, DWORD PTR _soap$[esp+12]
	push	edi
	push	esi
	call	_soap_strdup
	mov	DWORD PTR [esi+36], eax

; 13068:     if (soap_get_header_attribute(soap, val, "application/dime"))

	push	OFFSET ??_C@_0BB@KDHCEMMM@application?1dime?$AA@
	mov	eax, edi
	mov	ecx, esi
	call	_soap_get_header_attribute
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN41@http_parse

; 13069:       soap->mode |= SOAP_ENC_DIME;

	or	DWORD PTR [esi+8], 128			; 00000080H

; 13070:     else if (soap_get_header_attribute(soap, val, "multipart/related")

	jmp	SHORT $LN39@http_parse
$LN41@http_parse:

; 13071:           || soap_get_header_attribute(soap, val, "multipart/form-data"))

	push	OFFSET ??_C@_0BC@GGLOKPIO@multipart?1related?$AA@
	mov	eax, edi
	mov	ecx, esi
	call	_soap_get_header_attribute
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN38@http_parse
	push	OFFSET ??_C@_0BE@PILCJFLE@multipart?1form?9data?$AA@
	mov	eax, edi
	mov	ecx, esi
	call	_soap_get_header_attribute
	add	esp, 4
	test	eax, eax
	je	SHORT $LN39@http_parse
$LN38@http_parse:

; 13072:     { soap->mime.boundary = soap_strdup(soap, soap_get_header_attribute(soap, val, "boundary"));

	push	OFFSET ??_C@_08KIKGFOKI@boundary?$AA@
	mov	eax, edi
	mov	ecx, esi
	call	_soap_get_header_attribute
	push	eax
	push	esi
	call	_soap_strdup
	mov	DWORD PTR [esi+90524], eax

; 13073:       soap->mime.start = soap_strdup(soap, soap_get_header_attribute(soap, val, "start"));

	push	OFFSET ??_C@_05FAGFPHJG@start?$AA@
	mov	eax, edi
	mov	ecx, esi
	call	_soap_get_header_attribute
	push	eax
	push	esi
	call	_soap_strdup
	add	esp, 24					; 00000018H

; 13074:       soap->mode |= SOAP_ENC_MIME;

	or	DWORD PTR [esi+8], 256			; 00000100H
	mov	DWORD PTR [esi+90528], eax
$LN39@http_parse:

; 13075:     }
; 13076:     action = soap_get_header_attribute(soap, val, "action");

	push	OFFSET ??_C@_06DDLLCOJG@action?$AA@
	mov	eax, edi
	mov	ecx, esi
	call	_soap_get_header_attribute
	add	esp, 4

; 13077:     if (action)

	test	eax, eax
	je	$LN1@http_parse

; 13078:     { if (*action == '"')

	cmp	BYTE PTR [eax], 34			; 00000022H
	jne	SHORT $LN36@http_parse

; 13079:       { soap->action = soap_strdup(soap, action + 1);

	inc	eax
	push	eax
	push	esi
	call	_soap_strdup

; 13080:         soap->action[strlen(soap->action) - 1] = '\0';

	mov	ecx, eax
	mov	DWORD PTR [esi+90392], eax
	add	esp, 8
	lea	esi, DWORD PTR [ecx+1]
	npad	6
$LL49@http_parse:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL49@http_parse
	sub	ecx, esi
	pop	edi
	pop	esi
	mov	BYTE PTR [ecx+eax-1], dl

; 13168:   }
; 13169: #ifdef WITH_COOKIES
; 13170:   else if (!soap_tag_cmp(key, "Cookie")
; 13171:    || !soap_tag_cmp(key, "Cookie2")
; 13172:    || !soap_tag_cmp(key, "Set-Cookie")
; 13173:    || !soap_tag_cmp(key, "Set-Cookie2"))
; 13174:   { soap_getcookies(soap, val);
; 13175:   }
; 13176: #endif
; 13177:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 13178: }

	pop	ecx
	ret	0
$LN36@http_parse:

; 13081:       }
; 13082:       else
; 13083:         soap->action = soap_strdup(soap, action);

	push	eax
	push	esi
	call	_soap_strdup

; 13167:   { soap->proxy_from = soap_strdup(soap, val);

	add	esp, 8
	pop	edi
	mov	DWORD PTR [esi+90392], eax
	pop	esi

; 13168:   }
; 13169: #ifdef WITH_COOKIES
; 13170:   else if (!soap_tag_cmp(key, "Cookie")
; 13171:    || !soap_tag_cmp(key, "Cookie2")
; 13172:    || !soap_tag_cmp(key, "Set-Cookie")
; 13173:    || !soap_tag_cmp(key, "Set-Cookie2"))
; 13174:   { soap_getcookies(soap, val);
; 13175:   }
; 13176: #endif
; 13177:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 13178: }

	pop	ecx
	ret	0
$LN42@http_parse:

; 13084:     }
; 13085:   }
; 13086: #endif
; 13087:   else if (!soap_tag_cmp(key, "Content-Length"))

	push	OFFSET ??_C@_0P@HOJGPHBA@Content?9Length?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN33@http_parse

; 13088:   { soap->length = soap_strtoul(val, NULL, 10);

	mov	edx, DWORD PTR _val$[esp+12]
	push	10					; 0000000aH
	push	eax
	push	edx
	call	_strtoul
	mov	ecx, DWORD PTR _soap$[esp+24]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+12452], eax

; 13168:   }
; 13169: #ifdef WITH_COOKIES
; 13170:   else if (!soap_tag_cmp(key, "Cookie")
; 13171:    || !soap_tag_cmp(key, "Cookie2")
; 13172:    || !soap_tag_cmp(key, "Set-Cookie")
; 13173:    || !soap_tag_cmp(key, "Set-Cookie2"))
; 13174:   { soap_getcookies(soap, val);
; 13175:   }
; 13176: #endif
; 13177:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 13178: }

	pop	ecx
	ret	0
$LN33@http_parse:

; 13089:   }
; 13090:   else if (!soap_tag_cmp(key, "Content-Encoding"))

	push	OFFSET ??_C@_0BB@KFPPKJHF@Content?9Encoding?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN31@http_parse

; 13091:   { if (!soap_tag_cmp(val, "deflate"))

	mov	esi, DWORD PTR _val$[esp+12]
	push	OFFSET ??_C@_07FNHFFEJG@deflate?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax

; 13092: #ifdef WITH_ZLIB
; 13093:       soap->zlib_in = SOAP_ZLIB_DEFLATE;
; 13094: #else
; 13095:       return SOAP_ZLIB_ERROR;

	je	SHORT $LN52@http_parse

; 13096: #endif
; 13097:     else if (!soap_tag_cmp(val, "gzip"))

	push	OFFSET ??_C@_04HOHEGKBO@gzip?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	$LN1@http_parse
$LN52@http_parse:
	pop	edi
	pop	esi

; 13098: #ifdef WITH_GZIP
; 13099:       soap->zlib_in = SOAP_ZLIB_GZIP;
; 13100: #else
; 13101:       return SOAP_ZLIB_ERROR;

	mov	eax, 31					; 0000001fH
	pop	ebx

; 13178: }

	pop	ecx
	ret	0
$LN31@http_parse:

; 13102: #endif
; 13103:   }
; 13104: #ifdef WITH_ZLIB
; 13105:   else if (!soap_tag_cmp(key, "Accept-Encoding"))
; 13106:   {
; 13107: #ifdef WITH_GZIP
; 13108:     if (strchr(val, '*') || soap_get_header_attribute(soap, val, "gzip"))
; 13109:       soap->zlib_out = SOAP_ZLIB_GZIP;
; 13110:     else
; 13111: #endif
; 13112:     if (strchr(val, '*') || soap_get_header_attribute(soap, val, "deflate"))
; 13113:       soap->zlib_out = SOAP_ZLIB_DEFLATE;
; 13114:     else
; 13115:       soap->zlib_out = SOAP_ZLIB_NONE;
; 13116:   }
; 13117: #endif
; 13118:   else if (!soap_tag_cmp(key, "Transfer-Encoding"))

	push	OFFSET ??_C@_0BC@ELHLFCNH@Transfer?9Encoding?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@http_parse

; 13119:   { soap->mode &= ~SOAP_IO;

	mov	esi, DWORD PTR _soap$[esp+12]

; 13120:     if (!soap_tag_cmp(val, "chunked"))

	mov	edx, DWORD PTR _val$[esp+12]
	and	DWORD PTR [esi+8], -4			; fffffffcH
	mov	edi, DWORD PTR [esi+8]
	push	OFFSET ??_C@_07KCKHAHHI@chunked?$AA@
	push	edx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	$LN1@http_parse

; 13121:       soap->mode |= SOAP_IO_CHUNK;

	or	edi, 3
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 13178: }

	pop	ecx
	ret	0
$LN26@http_parse:

; 13122:   }
; 13123:   else if (!soap_tag_cmp(key, "Connection"))

	push	OFFSET ??_C@_0L@PJJKMLL@Connection?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@http_parse

; 13124:   { if (!soap_tag_cmp(val, "keep-alive"))

	mov	esi, DWORD PTR _val$[esp+12]
	push	OFFSET ??_C@_0L@FFDPOIEG@keep?9alive?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@http_parse

; 13125:       soap->keep_alive = -soap->keep_alive;

	mov	eax, DWORD PTR _soap$[esp+12]
	mov	cx, WORD PTR [eax+90412]
	pop	edi
	neg	cx
	pop	esi
	mov	WORD PTR [eax+90412], cx

; 13168:   }
; 13169: #ifdef WITH_COOKIES
; 13170:   else if (!soap_tag_cmp(key, "Cookie")
; 13171:    || !soap_tag_cmp(key, "Cookie2")
; 13172:    || !soap_tag_cmp(key, "Set-Cookie")
; 13173:    || !soap_tag_cmp(key, "Set-Cookie2"))
; 13174:   { soap_getcookies(soap, val);
; 13175:   }
; 13176: #endif
; 13177:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 13178: }

	pop	ecx
	ret	0
$LN22@http_parse:

; 13126:     else if (!soap_tag_cmp(val, "close"))

	push	OFFSET ??_C@_05LBOHBHFK@close?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	$LN1@http_parse

; 13127:       soap->keep_alive = 0;

	mov	eax, DWORD PTR _soap$[esp+12]
	pop	edi
	xor	edx, edx
	pop	esi
	mov	WORD PTR [eax+90412], dx

; 13168:   }
; 13169: #ifdef WITH_COOKIES
; 13170:   else if (!soap_tag_cmp(key, "Cookie")
; 13171:    || !soap_tag_cmp(key, "Cookie2")
; 13172:    || !soap_tag_cmp(key, "Set-Cookie")
; 13173:    || !soap_tag_cmp(key, "Set-Cookie2"))
; 13174:   { soap_getcookies(soap, val);
; 13175:   }
; 13176: #endif
; 13177:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 13178: }

	pop	ecx
	ret	0
$LN23@http_parse:

; 13128:   }
; 13129: #ifndef WITH_LEAN
; 13130:   else if (!soap_tag_cmp(key, "Authorization"))

	push	OFFSET ??_C@_0O@NAFGPKMI@Authorization?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@http_parse

; 13131:   { if (!soap_tag_cmp(val, "Basic *"))

	mov	ebx, DWORD PTR _val$[esp+12]
	push	OFFSET ??_C@_07LLIFBKCB@Basic?5?$CK?$AA@
	push	ebx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	$LN1@http_parse

; 13132:     { int n;
; 13133:       char *s;
; 13134:       soap_base642s(soap, val + 6, soap->tmpbuf, sizeof(soap->tmpbuf) - 1, &n);

	mov	esi, DWORD PTR _soap$[esp+12]
	lea	ecx, DWORD PTR _n$83645[esp+16]
	push	ecx
	add	ebx, 6
	lea	edi, DWORD PTR [esi+79028]
	push	ebx
	push	esi
	mov	eax, edi
	call	_soap_base642s

; 13135:       soap->tmpbuf[n] = '\0';

	mov	edx, DWORD PTR _n$83645[esp+28]

; 13136:       if ((s = strchr(soap->tmpbuf, ':')))

	push	58					; 0000003aH
	push	edi
	mov	BYTE PTR [edx+esi+79028], 0
	call	_strchr
	mov	ebx, eax
	add	esp, 20					; 00000014H
	test	ebx, ebx
	je	$LN1@http_parse

; 13137:       { *s = '\0';
; 13138:         soap->userid = soap_strdup(soap, soap->tmpbuf);

	push	edi
	push	esi
	mov	BYTE PTR [ebx], 0
	call	_soap_strdup

; 13139:         soap->passwd = soap_strdup(soap, s + 1);

	inc	ebx
	push	ebx
	push	esi
	mov	DWORD PTR [esi+12224], eax
	call	_soap_strdup
	add	esp, 16					; 00000010H
	pop	edi
	mov	DWORD PTR [esi+12228], eax
	pop	esi

; 13168:   }
; 13169: #ifdef WITH_COOKIES
; 13170:   else if (!soap_tag_cmp(key, "Cookie")
; 13171:    || !soap_tag_cmp(key, "Cookie2")
; 13172:    || !soap_tag_cmp(key, "Set-Cookie")
; 13173:    || !soap_tag_cmp(key, "Set-Cookie2"))
; 13174:   { soap_getcookies(soap, val);
; 13175:   }
; 13176: #endif
; 13177:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 13178: }

	pop	ecx
	ret	0
$LN18@http_parse:

; 13140:       }
; 13141:     }
; 13142:   }
; 13143:   else if (!soap_tag_cmp(key, "WWW-Authenticate"))

	push	OFFSET ??_C@_0BB@KEDJJIFI@WWW?9Authenticate?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@http_parse

; 13144:   { soap->authrealm = soap_strdup(soap, soap_get_header_attribute(soap, val + 6, "realm"));

	mov	eax, DWORD PTR _val$[esp+12]
	mov	esi, DWORD PTR _soap$[esp+12]
	push	OFFSET ??_C@_05ELABLNGD@realm?$AA@
	add	eax, 6
	mov	ecx, esi
	call	_soap_get_header_attribute
	push	eax
	push	esi
	call	_soap_strdup
	add	esp, 12					; 0000000cH
	pop	edi
	mov	DWORD PTR [esi+90396], eax
	pop	esi

; 13168:   }
; 13169: #ifdef WITH_COOKIES
; 13170:   else if (!soap_tag_cmp(key, "Cookie")
; 13171:    || !soap_tag_cmp(key, "Cookie2")
; 13172:    || !soap_tag_cmp(key, "Set-Cookie")
; 13173:    || !soap_tag_cmp(key, "Set-Cookie2"))
; 13174:   { soap_getcookies(soap, val);
; 13175:   }
; 13176: #endif
; 13177:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 13178: }

	pop	ecx
	ret	0
$LN14@http_parse:

; 13145:   }
; 13146:   else if (!soap_tag_cmp(key, "Expect"))

	push	OFFSET ??_C@_06GHDJNLIG@Expect?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@http_parse

; 13147:   { if (!soap_tag_cmp(val, "100-continue"))

	mov	eax, DWORD PTR _val$[esp+12]
	push	OFFSET ??_C@_0N@IOPAKPOD@100?9continue?$AA@
	push	eax
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	$LN1@http_parse

; 13148:     { if ((soap->error = soap->fposthdr(soap, "HTTP/1.1 100 Continue", NULL))
; 13149:        || (soap->error = soap->fposthdr(soap, NULL, NULL)))

	mov	esi, DWORD PTR _soap$[esp+12]
	mov	ecx, DWORD PTR [esi+12256]
	push	eax
	push	OFFSET ??_C@_0BG@NPCCMLBA@HTTP?11?41?5100?5Continue?$AA@
	push	esi
	call	ecx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	jne	SHORT $LN9@http_parse
	mov	edx, DWORD PTR [esi+12256]
	push	eax
	push	eax
	push	esi
	call	edx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	je	$LN1@http_parse
$LN9@http_parse:

; 13150:         return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 13178: }

	pop	ecx
	ret	0
$LN12@http_parse:

; 13151:     }
; 13152:   }
; 13153: #endif
; 13154:   else if (!soap_tag_cmp(key, "SOAPAction"))

	push	OFFSET ??_C@_0L@BIMPHKBC@SOAPAction?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@http_parse

; 13155:   { if (*val == '"')

	mov	eax, DWORD PTR _val$[esp+12]
	cmp	BYTE PTR [eax], 34			; 00000022H

; 13156:     { soap->action = soap_strdup(soap, val + 1);

	mov	esi, DWORD PTR _soap$[esp+12]
	jne	$LN36@http_parse
	inc	eax
	push	eax
	push	esi
	call	_soap_strdup

; 13157:       soap->action[strlen(soap->action) - 1] = '\0';

	mov	ecx, eax
	mov	DWORD PTR [esi+90392], eax
	add	esp, 8
	lea	esi, DWORD PTR [ecx+1]
$LL50@http_parse:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL50@http_parse
	sub	ecx, esi
	pop	edi
	pop	esi
	mov	BYTE PTR [ecx+eax-1], dl

; 13168:   }
; 13169: #ifdef WITH_COOKIES
; 13170:   else if (!soap_tag_cmp(key, "Cookie")
; 13171:    || !soap_tag_cmp(key, "Cookie2")
; 13172:    || !soap_tag_cmp(key, "Set-Cookie")
; 13173:    || !soap_tag_cmp(key, "Set-Cookie2"))
; 13174:   { soap_getcookies(soap, val);
; 13175:   }
; 13176: #endif
; 13177:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 13178: }

	pop	ecx
	ret	0
$LN7@http_parse:

; 13158:     }
; 13159:     else
; 13160:       soap->action = soap_strdup(soap, val);
; 13161:   }
; 13162:   else if (!soap_tag_cmp(key, "Location"))

	push	OFFSET ??_C@_08KDOEBHGA@Location?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@http_parse

; 13163:   { strncpy(soap->endpoint, val, sizeof(soap->endpoint));

	mov	eax, DWORD PTR _val$[esp+12]
	mov	esi, DWORD PTR _soap$[esp+12]
	push	1024					; 00000400H
	push	eax
	lea	ecx, DWORD PTR [esi+87320]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH
	pop	edi

; 13164:     soap->endpoint[sizeof(soap->endpoint) - 1] = '\0';

	mov	BYTE PTR [esi+88343], 0
	pop	esi

; 13168:   }
; 13169: #ifdef WITH_COOKIES
; 13170:   else if (!soap_tag_cmp(key, "Cookie")
; 13171:    || !soap_tag_cmp(key, "Cookie2")
; 13172:    || !soap_tag_cmp(key, "Set-Cookie")
; 13173:    || !soap_tag_cmp(key, "Set-Cookie2"))
; 13174:   { soap_getcookies(soap, val);
; 13175:   }
; 13176: #endif
; 13177:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 13178: }

	pop	ecx
	ret	0
$LN3@http_parse:

; 13165:   }
; 13166:   else if (!soap_tag_cmp(key, "X-Forwarded-For"))

	push	OFFSET ??_C@_0BA@HEMDDLEL@X?9Forwarded?9For?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@http_parse

; 13167:   { soap->proxy_from = soap_strdup(soap, val);

	mov	edx, DWORD PTR _val$[esp+12]
	mov	esi, DWORD PTR _soap$[esp+12]
	push	edx
	push	esi
	call	_soap_strdup
	mov	DWORD PTR [esi+90452], eax
	add	esp, 8
$LN1@http_parse:
	pop	edi
	pop	esi

; 13168:   }
; 13169: #ifdef WITH_COOKIES
; 13170:   else if (!soap_tag_cmp(key, "Cookie")
; 13171:    || !soap_tag_cmp(key, "Cookie2")
; 13172:    || !soap_tag_cmp(key, "Set-Cookie")
; 13173:    || !soap_tag_cmp(key, "Set-Cookie2"))
; 13174:   { soap_getcookies(soap, val);
; 13175:   }
; 13176: #endif
; 13177:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 13178: }

	pop	ecx
	ret	0
_http_parse_header ENDP
; Function compile flags: /Ogtpy
_soap_select_mime_boundary PROC
; _soap$ = eax

; 11917: { while (!soap->mime.boundary || soap_valid_mime_boundary(soap))

	push	ebx
	push	esi
	push	edi
	mov	edi, eax
$LL9@soap_selec:
	cmp	DWORD PTR [edi+90524], 0
	je	SHORT $LN7@soap_selec
	push	edi
	call	_soap_valid_mime_boundary
	add	esp, 4
	test	eax, eax
	je	$LN8@soap_selec
$LN7@soap_selec:

; 11918:   { register char *s = soap->mime.boundary;

	mov	esi, DWORD PTR [edi+90524]

; 11919:     register size_t n = 0;
; 11920:     if (s)

	test	esi, esi
	je	SHORT $LN17@soap_selec

; 11921:       n = strlen(s);

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL18@soap_selec:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL18@soap_selec
	sub	eax, edx
	mov	ebx, eax

; 11922:     if (n < 16)

	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN4@soap_selec
$LN17@soap_selec:

; 11923:     { n = 64;

	mov	ebx, 64					; 00000040H

; 11924:       s = soap->mime.boundary = (char*)soap_malloc(soap, n + 1);

	lea	eax, DWORD PTR [ebx+1]
	call	_soap_malloc
	mov	esi, eax
	mov	DWORD PTR [edi+90524], eax

; 11925:       if (!s)

	test	esi, esi
	je	SHORT $LN15@soap_selec
$LN4@soap_selec:

; 11926:         return;
; 11927:     }
; 11928:     strcpy(s, "==");

	mov	ax, WORD PTR ??_C@_02EGOFBIJA@?$DN?$DN?$AA@
	mov	WORD PTR [esi], ax
	mov	cl, BYTE PTR ??_C@_02EGOFBIJA@?$DN?$DN?$AA@+2
	mov	BYTE PTR [esi+2], cl

; 11929:     s += 2;

	add	esi, 2

; 11930:     n -= 4;

	sub	ebx, 4

; 11931:     while (n)

	je	SHORT $LN2@soap_selec
$LL3@soap_selec:

; 11932:     { *s++ = soap_base64o[soap_random & 0x3F];

	call	_rand
	and	eax, 63					; 0000003fH
	mov	dl, BYTE PTR _soap_base64o[eax]
	mov	BYTE PTR [esi], dl
	inc	esi

; 11933:       n--;

	sub	ebx, 1
	jne	SHORT $LL3@soap_selec
$LN2@soap_selec:

; 11934:     }
; 11935:     strcpy(s, "==");

	mov	ax, WORD PTR ??_C@_02EGOFBIJA@?$DN?$DN?$AA@
	mov	WORD PTR [esi], ax
	mov	cl, BYTE PTR ??_C@_02EGOFBIJA@?$DN?$DN?$AA@+2
	mov	BYTE PTR [esi+2], cl

; 11936:   }

	jmp	$LL9@soap_selec
$LN8@soap_selec:

; 11937:   if (!soap->mime.start)

	cmp	DWORD PTR [edi+90528], 0
	jne	SHORT $LN15@soap_selec

; 11938:     soap->mime.start = "<SOAP-ENV:Envelope>";

	mov	DWORD PTR [edi+90528], OFFSET ??_C@_0BE@MKHJBFJG@?$DMSOAP?9ENV?3Envelope?$DO?$AA@
$LN15@soap_selec:
	pop	edi
	pop	esi
	pop	ebx

; 11939: }

	ret	0
_soap_select_mime_boundary ENDP
; Function compile flags: /Ogtpy
_last$ = 8						; size = 4
_ptr$ = 12						; size = 4
_size$ = 16						; size = 4
_soap_new_multipart PROC
; _soap$ = edi
; _first$ = esi

; 11837: { struct soap_multipart *content;

	push	ebx
	mov	ebx, DWORD PTR _last$[esp]

; 11838:   content = (struct soap_multipart*)soap_malloc(soap, sizeof(struct soap_multipart));

	mov	eax, 36					; 00000024H
	call	_soap_malloc

; 11839:   if (content)

	xor	ecx, ecx
	cmp	eax, ecx
	je	SHORT $LN3@soap_new_m

; 11840:   { content->next = NULL;
; 11841:     content->ptr = ptr;

	mov	edx, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [eax+4], edx

; 11842:     content->size = size;

	mov	edx, DWORD PTR _size$[esp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+8], edx

; 11843:     content->id = NULL;

	mov	DWORD PTR [eax+12], ecx

; 11844:     content->type = NULL;

	mov	DWORD PTR [eax+16], ecx

; 11845:     content->options = NULL;

	mov	DWORD PTR [eax+20], ecx

; 11846:     content->encoding = SOAP_MIME_NONE;

	mov	DWORD PTR [eax+24], ecx

; 11847:     content->location = NULL;

	mov	DWORD PTR [eax+28], ecx

; 11848:     content->description = NULL;

	mov	DWORD PTR [eax+32], ecx

; 11849:     if (!*first)

	cmp	DWORD PTR [esi], ecx
	jne	SHORT $LN2@soap_new_m

; 11850:       *first = content;

	mov	DWORD PTR [esi], eax
$LN2@soap_new_m:

; 11851:     if (*last)

	mov	edx, DWORD PTR [ebx]
	cmp	edx, ecx
	je	SHORT $LN1@soap_new_m

; 11852:       (*last)->next = content;

	mov	DWORD PTR [edx], eax
$LN1@soap_new_m:

; 11853:     *last = content;

	mov	DWORD PTR [ebx], eax
$LN3@soap_new_m:
	pop	ebx

; 11854:   }
; 11855:   return content;
; 11856: }

	ret	0
_soap_new_multipart ENDP
_TEXT	ENDS
PUBLIC	_soap_set_mime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_boundary$ = 8						; size = 4
_start$ = 12						; size = 4
_soap_set_mime PROC
; _soap$ = eax

; 11793: { soap->omode |= SOAP_ENC_MIME;

	push	ebp
	mov	ebp, DWORD PTR _boundary$[esp]
	push	esi
	push	edi
	mov	edi, eax
	or	DWORD PTR [edi+16], 256			; 00000100H

; 11794:   soap->mime.first = NULL;
; 11795:   soap->mime.last = NULL;
; 11796:   soap->mime.boundary = soap_strdup(soap, boundary);

	xor	eax, eax
	mov	DWORD PTR [edi+90536], 0
	mov	DWORD PTR [edi+90540], 0
	test	ebp, ebp
	je	SHORT $LN3@soap_set_m
	mov	eax, ebp
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL13@soap_set_m:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL13@soap_set_m
	sub	eax, edx
	inc	eax
	call	_soap_malloc
	test	eax, eax
	je	SHORT $LN3@soap_set_m
	mov	esi, eax
	mov	ecx, ebp
	sub	esi, ebp
	npad	7
$LL6@soap_set_m:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [esi+ecx], dl
	inc	ecx
	test	dl, dl
	jne	SHORT $LL6@soap_set_m
$LN3@soap_set_m:

; 11797:   soap->mime.start = soap_strdup(soap, start);

	mov	ebp, DWORD PTR _start$[esp+8]
	mov	DWORD PTR [edi+90524], eax
	xor	eax, eax
	test	ebp, ebp
	je	SHORT $LN16@soap_set_m
	mov	eax, ebp
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL14@soap_set_m:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL14@soap_set_m
	sub	eax, edx
	inc	eax
	call	_soap_malloc
	test	eax, eax
	je	SHORT $LN16@soap_set_m
	mov	esi, eax
	mov	ecx, ebp
	sub	esi, ebp
	npad	7
$LL10@soap_set_m:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [esi+ecx], dl
	inc	ecx
	test	dl, dl
	jne	SHORT $LL10@soap_set_m
$LN16@soap_set_m:
	mov	DWORD PTR [edi+90528], eax
	pop	edi
	pop	esi
	pop	ebp

; 11798: }

	ret	0
_soap_set_mime ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_soap_resolve_attachment PROC
; _content$ = edi

; 11654: { if (content->id)

	cmp	DWORD PTR [edi+12], 0
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp]
	je	SHORT $LN5@soap_resol

; 11655:   { register struct soap_xlist **xp = &soap->xlist;
; 11656:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolving attachment data for id=%s\n", content->id));
; 11657:     while (*xp)

	cmp	DWORD PTR [ebp+90544], 0
	push	ebx
	lea	ebx, DWORD PTR [ebp+90544]
	je	SHORT $LN11@soap_resol
	push	esi
	npad	4
$LL6@soap_resol:

; 11658:     { register struct soap_xlist *xq = *xp;

	mov	esi, DWORD PTR [ebx]

; 11659:       if (!soap_match_cid(soap, xq->id, content->id))

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	push	eax
	push	ecx
	push	ebp
	call	_soap_match_cid
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@soap_resol

; 11660:       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Found matching attachment %s for content id=%s\n", xq->id, content->id));
; 11661:         *xp = xq->next;

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], edx

; 11662:         *xq->ptr = (unsigned char*)content->ptr;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ecx

; 11663:         *xq->size = (int)content->size;

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edx], eax

; 11664:         *xq->type = (char*)content->type;

	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [edi+16]
	mov	DWORD PTR [ecx], edx

; 11665:         if (content->options)

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN3@soap_resol

; 11666:           *xq->options = (char*)content->options;

	mov	ecx, DWORD PTR [esi+20]

; 11669:         SOAP_FREE(soap, xq);

	push	esi
	mov	DWORD PTR [ecx], eax
	call	_free
	add	esp, 4

; 11670:       }
; 11671:       else

	jmp	SHORT $LN1@soap_resol
$LN3@soap_resol:

; 11667:         else
; 11668:           *xq->options = (char*)content->description;

	mov	edx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [edi+32]

; 11669:         SOAP_FREE(soap, xq);

	push	esi
	mov	DWORD PTR [edx], eax
	call	_free
	add	esp, 4

; 11670:       }
; 11671:       else

	jmp	SHORT $LN1@soap_resol
$LN4@soap_resol:

; 11672:         xp = &(*xp)->next;

	mov	ebx, DWORD PTR [ebx]
$LN1@soap_resol:

; 11655:   { register struct soap_xlist **xp = &soap->xlist;
; 11656:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolving attachment data for id=%s\n", content->id));
; 11657:     while (*xp)

	cmp	DWORD PTR [ebx], 0
	jne	SHORT $LL6@soap_resol
	pop	esi
$LN11@soap_resol:
	pop	ebx
$LN5@soap_resol:
	pop	ebp

; 11673:     }
; 11674:   }
; 11675: }

	ret	0
_soap_resolve_attachment ENDP
_TEXT	ENDS
PUBLIC	_soap_dime_option
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_optype$ = 12						; size = 2
_option$ = 16						; size = 4
_soap_dime_option PROC

; 11056: { size_t n;

	push	ebp
	mov	ebp, DWORD PTR _option$[esp]

; 11057:   char *s = NULL;

	xor	eax, eax

; 11058:   if (option)

	test	ebp, ebp
	je	SHORT $LN1@soap_dime_@2

; 11059:   { n = strlen(option);

	mov	eax, ebp
	lea	edx, DWORD PTR [eax+1]
$LL7@soap_dime_@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL7@soap_dime_@2
	sub	eax, edx
	push	ebx
	mov	ebx, eax
	push	edi

; 11060:     s = (char*)soap_malloc(soap, n + 5);

	mov	edi, DWORD PTR _soap$[esp+8]
	lea	eax, DWORD PTR [ebx+5]
	call	_soap_malloc

; 11061:     if (s)

	test	eax, eax
	je	SHORT $LN10@soap_dime_@2

; 11062:     { s[0] = (char)(optype >> 8);

	mov	ecx, DWORD PTR _optype$[esp+8]
	mov	edx, ecx

; 11063:       s[1] = (char)(optype & 0xFF);

	mov	BYTE PTR [eax+1], cl

; 11064:       s[2] = (char)(n >> 8);

	mov	ecx, ebx
	shr	ecx, 8
	push	esi
	shr	edx, 8

; 11065:       s[3] = (char)(n & 0xFF);
; 11066:       strcpy(s + 4, option);

	lea	esi, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+2], cl
	mov	BYTE PTR [eax], dl
	mov	BYTE PTR [eax+3], bl
	mov	ecx, ebp
	sub	esi, ebp
	npad	2
$LL5@soap_dime_@2:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [esi+ecx], dl
	inc	ecx
	test	dl, dl
	jne	SHORT $LL5@soap_dime_@2
	pop	esi
$LN10@soap_dime_@2:
	pop	edi
	pop	ebx
$LN1@soap_dime_@2:
	pop	ebp

; 11067:     }
; 11068:   }
; 11069:   return s;
; 11070: }

	ret	0
_soap_dime_option ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_soap_putdimefield PROC
; _n$ = eax

; 11043:     return soap->error;
; 11044:   return soap_send_raw(soap, SOAP_STR_PADDING, -(long)n&3);

	neg	eax
	and	eax, 3
	push	eax
	mov	eax, DWORD PTR _soap$[esp]
	push	OFFSET _soap_padding
	call	_soap_send_raw
	add	esp, 8

; 11045: }

	ret	0
_soap_putdimefield ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_soap_count_attachments PROC

; 10981: {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+4]

; 10982: #ifndef WITH_LEANER
; 10983:   register struct soap_multipart *content;
; 10984:   register size_t count = soap->count;
; 10985:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Calculating the message size with attachments, current count=%lu\n", (unsigned long)count));
; 10986:   if ((soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))

	mov	ebx, DWORD PTR [ebp+8]
	mov	eax, DWORD PTR [ebp+12448]
	push	esi
	push	edi
	test	bl, bl
	jns	$LN40@soap_count
	test	ebx, 512				; 00000200H
	jne	SHORT $LN40@soap_count

; 10987:   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Calculating the size of DIME attachments\n"));
; 10988:     for (content = soap->dime.first; content; content = content->next)

	mov	esi, DWORD PTR [ebp+90516]
	test	esi, esi
	je	SHORT $LN40@soap_count
	npad	5
$LL15@soap_count:

; 10989:     { count += 12 + ((content->size+3)&(~3));

	mov	ecx, DWORD PTR [esi+8]
	add	ecx, 3
	and	ecx, -4					; fffffffcH
	lea	eax, DWORD PTR [eax+ecx+12]

; 10990:       if (content->id)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN12@soap_count

; 10991:         count += ((strlen(content->id)+3)&(~3));

	lea	edi, DWORD PTR [ecx+1]
$LL30@soap_count:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL30@soap_count
	sub	ecx, edi
	add	ecx, 3
	and	ecx, -4					; fffffffcH
	add	eax, ecx
$LN12@soap_count:

; 10992:       if (content->type)

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $LN11@soap_count

; 10993:         count += ((strlen(content->type)+3)&(~3));

	lea	edi, DWORD PTR [ecx+1]
$LL31@soap_count:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL31@soap_count
	sub	ecx, edi
	add	ecx, 3
	and	ecx, -4					; fffffffcH
	add	eax, ecx
$LN11@soap_count:

; 10994:       if (content->options)

	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN14@soap_count

; 10995:         count += ((((unsigned char)content->options[2] << 8) | ((unsigned char)content->options[3]))+7)&(~3);

	mov	ecx, DWORD PTR [esi+20]
	movzx	edx, BYTE PTR [ecx+2]
	movzx	ecx, BYTE PTR [ecx+3]
	shl	edx, 8
	or	edx, ecx
	add	edx, 7
	and	edx, -4					; fffffffcH
	add	eax, edx
$LN14@soap_count:
	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL15@soap_count
$LN40@soap_count:

; 10996:       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Size of DIME attachment content is %lu bytes\n", (unsigned long)content->size));
; 10997:     }
; 10998:   }
; 10999:   if ((soap->mode & SOAP_ENC_MIME) && soap->mime.boundary)

	test	ebx, 256				; 00000100H
	je	$LN9@soap_count
	mov	ecx, DWORD PTR [ebp+90524]
	test	ecx, ecx
	je	$LN9@soap_count

; 11000:   { register size_t n = strlen(soap->mime.boundary);

	lea	esi, DWORD PTR [ecx+1]
$LL32@soap_count:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL32@soap_count

; 11001:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Calculating the size of MIME attachments\n"));
; 11002:     for (content = soap->mime.first; content; content = content->next)

	mov	edi, DWORD PTR [ebp+90536]
	sub	ecx, esi
	mov	ebx, ecx
	test	edi, edi
	je	$LN6@soap_count
	lea	ebp, DWORD PTR [ebx+6]
$LL41@soap_count:

; 11003:     { register const char *s;
; 11004:       /* count \r\n--boundary\r\n */
; 11005:       count += 6 + n;
; 11006:       /* count Content-Type: ...\r\n */
; 11007:       if (content->type)

	mov	ecx, DWORD PTR [edi+16]
	add	eax, ebp
	test	ecx, ecx
	je	SHORT $LN5@soap_count

; 11008:         count += 16 + strlen(content->type);

	lea	esi, DWORD PTR [ecx+1]
	npad	4
$LL33@soap_count:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL33@soap_count
	sub	ecx, esi
	lea	eax, DWORD PTR [eax+ecx+16]
$LN5@soap_count:
	mov	edx, DWORD PTR [edi+24]

; 11009:       /* count Content-Transfer-Encoding: ...\r\n */
; 11010:       s = soap_code_str(mime_codes, content->encoding);

	mov	ecx, OFFSET _mime_codes
	cmp	edx, 1
	je	SHORT $LN42@soap_count
	npad	6
$LL20@soap_count:
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN42@soap_count
	add	ecx, 8
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LL20@soap_count
$LN42@soap_count:
	mov	ecx, DWORD PTR [ecx+4]

; 11011:       if (s)

	test	ecx, ecx
	je	SHORT $LN4@soap_count

; 11012:         count += 29 + strlen(s);

	lea	esi, DWORD PTR [ecx+1]
$LL34@soap_count:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL34@soap_count
	sub	ecx, esi
	lea	eax, DWORD PTR [eax+ecx+29]
$LN4@soap_count:

; 11013:       /* count Content-ID: ...\r\n */
; 11014:       if (content->id)

	mov	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	je	SHORT $LN3@soap_count

; 11015:         count += 14 + strlen(content->id);

	lea	esi, DWORD PTR [ecx+1]
	npad	2
$LL35@soap_count:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL35@soap_count
	sub	ecx, esi
	lea	eax, DWORD PTR [eax+ecx+14]
$LN3@soap_count:

; 11016:       /* count Content-Location: ...\r\n */
; 11017:       if (content->location)

	mov	ecx, DWORD PTR [edi+28]
	test	ecx, ecx
	je	SHORT $LN2@soap_count

; 11018:         count += 20 + strlen(content->location);

	lea	esi, DWORD PTR [ecx+1]
$LL36@soap_count:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL36@soap_count
	sub	ecx, esi
	lea	eax, DWORD PTR [eax+ecx+20]
$LN2@soap_count:

; 11019:       /* count Content-Description: ...\r\n */
; 11020:       if (content->description)

	mov	ecx, DWORD PTR [edi+32]
	test	ecx, ecx
	je	SHORT $LN1@soap_count

; 11021:         count += 23 + strlen(content->description);

	lea	esi, DWORD PTR [ecx+1]
	npad	2
$LL37@soap_count:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL37@soap_count
	sub	ecx, esi
	lea	eax, DWORD PTR [eax+ecx+23]
$LN1@soap_count:

; 11022:       /* count \r\n...content */
; 11023:       count += 2 + content->size;

	mov	edx, DWORD PTR [edi+8]
	mov	edi, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+edx+2]
	test	edi, edi
	jne	$LL41@soap_count
$LN6@soap_count:

; 11024:       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Size of MIME attachment content is %lu bytes\n", (unsigned long)content->size));
; 11025:     }
; 11026:     /* count \r\n--boundary-- */
; 11027:     count += 6 + n;

	lea	eax, DWORD PTR [eax+ebx+6]
$LN9@soap_count:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 11028:   }
; 11029:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "New count is %lu bytes\n", (unsigned long)count));
; 11030:   return count;
; 11031: #else
; 11032:   return soap->count;
; 11033: #endif
; 11034: }

	ret	0
_soap_count_attachments ENDP
_TEXT	ENDS
PUBLIC	_soap_dateTime2s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_t$ = -16						; size = 16
_soap$ = 8						; size = 4
_n$ = 12						; size = 8
_soap_dateTime2s PROC

; 10580: { struct tm T, *pT = &T;

	sub	esp, 16					; 00000010H

; 10581: #if defined(HAVE_GMTIME_R)
; 10582:   if (gmtime_r(&n, pT))
; 10583:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%SZ", pT);
; 10584: #elif defined(HAVE_GMTIME)
; 10585:   if ((pT = gmtime(&n)))
; 10586:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%SZ", pT);
; 10587: #elif defined(HAVE_GETTIMEOFDAY)
; 10588:   struct timezone tz;
; 10589:   memset((void*)&tz, 0, sizeof(tz));
; 10590: #if defined(HAVE_LOCALTIME_R)
; 10591:   if (localtime_r(&n, pT))
; 10592:   { struct timeval tv;
; 10593:     gettimeofday(&tv, &tz);
; 10594:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
; 10595:     sprintf(soap->tmpbuf + strlen(soap->tmpbuf), "%+03d:%02d", -tz.tz_minuteswest/60+(pT->tm_isdst!=0), abs(tz.tz_minuteswest)%60);
; 10596:   }
; 10597: #else
; 10598:   if ((pT = localtime(&n)))
; 10599:   { struct timeval tv;
; 10600:     gettimeofday(&tv, &tz);
; 10601:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
; 10602:     sprintf(soap->tmpbuf + strlen(soap->tmpbuf), "%+03d:%02d", -tz.tz_minuteswest/60+(pT->tm_isdst!=0), abs(tz.tz_minuteswest)%60);
; 10603:   }
; 10604: #endif
; 10605: #elif defined(HAVE_FTIME)
; 10606:   struct timeb t;
; 10607:   memset((void*)&t, 0, sizeof(t));
; 10608: #if defined(HAVE_LOCALTIME_R)
; 10609:   if (localtime_r(&n, pT))
; 10610:   {
; 10611: #ifdef __BORLANDC__
; 10612:     ::ftime(&t);
; 10613: #else
; 10614:     ftime(&t);
; 10615: #endif
; 10616:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
; 10617:     sprintf(soap->tmpbuf + strlen(soap->tmpbuf), "%+03d:%02d", -t.timezone/60+(pT->tm_isdst!=0), abs(t.timezone)%60);
; 10618:   }
; 10619: #else
; 10620:   if ((pT = localtime(&n)))

	lea	eax, DWORD PTR _n$[esp+12]
	push	ebx
	pxor	xmm0, xmm0
	push	eax
	movq	QWORD PTR _t$[esp+24], xmm0
	movq	QWORD PTR _t$[esp+32], xmm0
	call	__localtime64
	mov	ebx, eax
	add	esp, 4
	test	ebx, ebx
	je	$LN2@soap_dateT
	push	ebp
	push	esi

; 10621:   {
; 10622: #ifdef __BORLANDC__
; 10623:     ::ftime(&t);
; 10624: #else
; 10625:     ftime(&t);

	lea	ecx, DWORD PTR _t$[esp+28]
	push	edi
	push	ecx
	call	__ftime64

; 10626: #endif
; 10627:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);

	mov	edi, DWORD PTR _soap$[esp+32]
	push	ebx
	push	OFFSET ??_C@_0BC@EJFCONBF@?$CFY?9?$CFm?9?$CFdT?$CFH?3?$CFM?3?$CFS?$AA@
	add	edi, 79028				; 000134b4H
	push	1024					; 00000400H
	push	edi
	call	_strftime

; 10628:     sprintf(soap->tmpbuf + strlen(soap->tmpbuf), "%+03d:%02d", -t.timezone/60+(pT->tm_isdst!=0), abs(t.timezone)%60);

	mov	eax, edi
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL9@soap_dateT:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL9@soap_dateT
	movsx	esi, WORD PTR _t$[esp+42]
	sub	eax, edx
	mov	ebp, eax
	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	xor	ecx, ecx
	cmp	DWORD PTR [ebx+32], ecx
	mov	eax, -2004318071			; 88888889H
	setne	cl
	push	edx
	imul	esi
	add	edx, esi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	ecx, eax
	push	ecx
	mov	ecx, DWORD PTR _soap$[esp+36]
	lea	edx, DWORD PTR [ecx+ebp+79028]
	push	OFFSET ??_C@_0L@PEBBIKFI@?$CF?$CL03d?3?$CF02d?$AA@
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 10640:   return soap->tmpbuf;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10641: }

	add	esp, 16					; 00000010H
	ret	0
$LN2@soap_dateT:

; 10629:   }
; 10630: #endif
; 10631: #elif defined(HAVE_LOCALTIME_R)
; 10632:   if (localtime_r(&n, pT))
; 10633:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
; 10634: #else
; 10635:   if ((pT = localtime(&n)))
; 10636:     strftime(soap->tmpbuf, sizeof(soap->tmpbuf), "%Y-%m-%dT%H:%M:%S", pT);
; 10637: #endif
; 10638:   else
; 10639:     strcpy(soap->tmpbuf, "1969-12-31T23:59:59Z");

	movq	xmm0, QWORD PTR ??_C@_0BF@KNOONEPL@1969?912?931T23?359?359Z?$AA@
	mov	eax, DWORD PTR _soap$[esp+16]
	add	eax, 79028				; 000134b4H
	movq	QWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR ??_C@_0BF@KNOONEPL@1969?912?931T23?359?359Z?$AA@+8
	movq	QWORD PTR [eax+8], xmm0
	mov	ecx, DWORD PTR ??_C@_0BF@KNOONEPL@1969?912?931T23?359?359Z?$AA@+16
	mov	DWORD PTR [eax+16], ecx
	mov	dl, BYTE PTR ??_C@_0BF@KNOONEPL@1969?912?931T23?359?359Z?$AA@+20
	mov	BYTE PTR [eax+20], dl
	pop	ebx

; 10641: }

	add	esp, 16					; 00000010H
	ret	0
_soap_dateTime2s ENDP
_TEXT	ENDS
PUBLIC	_soap_timegm
EXTRN	__allmul:PROC
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_t$ = -44						; size = 8
_tm$ = -36						; size = 36
_soap_timegm PROC
; _T$ = eax

; 10550: {

	sub	esp, 44					; 0000002cH

; 10551: #if defined(HAVE_TIMEGM)
; 10552:   return timegm(T);
; 10553: #else
; 10554:   time_t t, g, z;
; 10555:   struct tm tm;
; 10556:   t = mktime(T);

	push	eax
	call	__mktime64
	mov	DWORD PTR _t$[esp+48], eax

; 10557:   if (t == (time_t)-1)

	and	eax, edx
	add	esp, 4
	mov	DWORD PTR _t$[esp+48], edx
	cmp	eax, -1
	jne	SHORT $LN2@soap_timeg

; 10558:     return (time_t)-1;

	or	eax, eax
	or	edx, -1

; 10570: #endif
; 10571: }

	add	esp, 44					; 0000002cH
	ret	0
$LN2@soap_timeg:
	push	esi

; 10559: #ifdef HAVE_GMTIME_R
; 10560:   gmtime_r(&t, &tm);
; 10561: #else
; 10562:   tm = *gmtime(&t);

	lea	ecx, DWORD PTR _t$[esp+48]
	push	edi
	push	ecx
	call	__gmtime64
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR _tm$[esp+56], xmm0
	movq	xmm0, QWORD PTR [eax+8]
	movq	QWORD PTR _tm$[esp+64], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR _tm$[esp+72], xmm0
	movq	xmm0, QWORD PTR [eax+24]
	movq	QWORD PTR _tm$[esp+80], xmm0
	mov	edx, DWORD PTR [eax+32]

; 10563: #endif
; 10564:   tm.tm_isdst = 0;
; 10565:   g = mktime(&tm);

	lea	eax, DWORD PTR _tm$[esp+56]
	mov	DWORD PTR _tm$[esp+88], edx
	push	eax
	mov	DWORD PTR _tm$[esp+92], 0
	call	__mktime64
	mov	esi, eax
	mov	edi, edx

; 10566:   if (g == (time_t)-1)

	mov	ecx, esi
	and	ecx, edi
	add	esp, 8
	cmp	ecx, -1
	jne	SHORT $LN1@soap_timeg
	pop	edi

; 10567:     return (time_t)-1;

	or	eax, ecx
	or	edx, ecx
	pop	esi

; 10570: #endif
; 10571: }

	add	esp, 44					; 0000002cH
	ret	0
$LN1@soap_timeg:

; 10567:     return (time_t)-1;

	mov	edx, DWORD PTR _t$[esp+56]
	mov	eax, DWORD PTR _t$[esp+52]
	push	0
	push	2
	push	edx
	push	eax
	call	__allmul

; 10568:   z = g - t;
; 10569:   return t - z;

	sub	eax, esi
	sbb	edx, edi
	pop	edi
	pop	esi

; 10570: #endif
; 10571: }

	add	esp, 44					; 0000002cH
	ret	0
_soap_timegm ENDP
_TEXT	ENDS
PUBLIC	_soap_wchar2s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_wchar2s PROC
; _s$ = eax

; 10375: { register soap_wchar c;

	push	esi
	mov	esi, eax

; 10376:   register char *r, *t;
; 10377:   const wchar_t *q = s;
; 10378:   size_t n = 0;
; 10379:   while ((c = *q++))

	movzx	eax, WORD PTR [esi]
	xor	edx, edx
	push	edi
	mov	ecx, esi
	test	eax, eax
	je	SHORT $LN22@soap_wchar
	npad	1
$LL17@soap_wchar:

; 10380:   { if (c > 0 && c < 0x80)

	dec	eax
	add	ecx, 2
	cmp	eax, 126				; 0000007eH
	ja	SHORT $LN15@soap_wchar

; 10381:       n++;

	inc	edx

; 10382:     else

	jmp	SHORT $LN14@soap_wchar
$LN15@soap_wchar:

; 10383:       n += 6;

	add	edx, 6
$LN14@soap_wchar:

; 10376:   register char *r, *t;
; 10377:   const wchar_t *q = s;
; 10378:   size_t n = 0;
; 10379:   while ((c = *q++))

	movzx	eax, WORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LL17@soap_wchar
$LN22@soap_wchar:

; 10384:   }
; 10385:   r = t = (char*)soap_malloc(soap, n + 1);

	mov	edi, DWORD PTR _soap$[esp+4]
	lea	eax, DWORD PTR [edx+1]
	call	_soap_malloc
	mov	ecx, eax
	mov	edi, ecx

; 10386:   if (r)

	test	ecx, ecx
	je	$LN24@soap_wchar

; 10387:   { /* Convert wchar to UTF8 */
; 10388:     while ((c = *s++))

	movzx	edx, WORD PTR [esi]
	test	edx, edx
	je	$LN23@soap_wchar
	npad	7
$LL12@soap_wchar:

; 10389:     { if (c > 0 && c < 0x80)

	lea	eax, DWORD PTR [edx-1]
	add	esi, 2
	cmp	eax, 126				; 0000007eH

; 10390:         *t++ = (char)c;
; 10391:       else

	jbe	$LN25@soap_wchar

; 10392:       { if (c < 0x0800)

	cmp	edx, 2048				; 00000800H

; 10393:           *t++ = (char)(0xC0 | ((c >> 6) & 0x1F));

	mov	eax, edx
	jge	SHORT $LN8@soap_wchar
	sar	eax, 6
	and	al, 31					; 0000001fH
	or	al, -64					; ffffffc0H

; 10394:         else

	jmp	SHORT $LN26@soap_wchar
$LN8@soap_wchar:

; 10395:         { if (c < 0x010000)

	cmp	edx, 65536				; 00010000H
	jge	SHORT $LN6@soap_wchar

; 10396:             *t++ = (char)(0xE0 | ((c >> 12) & 0x0F));

	sar	eax, 12					; 0000000cH
	and	al, 15					; 0000000fH
	or	al, -32					; ffffffe0H

; 10397:           else

	jmp	SHORT $LN27@soap_wchar
$LN6@soap_wchar:

; 10398:           { if (c < 0x200000)

	cmp	edx, 2097152				; 00200000H
	jge	SHORT $LN4@soap_wchar

; 10399:               *t++ = (char)(0xF0 | ((c >> 18) & 0x07));

	sar	eax, 18					; 00000012H
	and	al, 7
	or	al, -16					; fffffff0H

; 10400:             else

	jmp	SHORT $LN28@soap_wchar
$LN4@soap_wchar:

; 10401:             { if (c < 0x04000000)

	cmp	edx, 67108864				; 04000000H
	jge	SHORT $LN2@soap_wchar

; 10402:                 *t++ = (char)(0xF8 | ((c >> 24) & 0x03));

	sar	eax, 24					; 00000018H
	and	al, 3
	or	al, -8					; fffffff8H

; 10403:               else

	jmp	SHORT $LN29@soap_wchar
$LN2@soap_wchar:

; 10404:               { *t++ = (char)(0xFC | ((c >> 30) & 0x01));

	sar	eax, 30					; 0000001eH
	and	al, 1
	or	al, -4					; fffffffcH
	mov	BYTE PTR [ecx], al

; 10405:                 *t++ = (char)(0x80 | ((c >> 24) & 0x3F));

	mov	eax, edx
	sar	eax, 24					; 00000018H
	and	al, 63					; 0000003fH
	inc	ecx
	or	al, -128				; ffffff80H
$LN29@soap_wchar:
	mov	BYTE PTR [ecx], al

; 10406:               }
; 10407:               *t++ = (char)(0x80 | ((c >> 18) & 0x3F));

	mov	eax, edx
	sar	eax, 18					; 00000012H
	and	al, 63					; 0000003fH
	inc	ecx
	or	al, -128				; ffffff80H
$LN28@soap_wchar:
	mov	BYTE PTR [ecx], al

; 10408:             }
; 10409:             *t++ = (char)(0x80 | ((c >> 12) & 0x3F));

	mov	eax, edx
	sar	eax, 12					; 0000000cH
	and	al, 63					; 0000003fH
	inc	ecx
	or	al, -128				; ffffff80H
$LN27@soap_wchar:
	mov	BYTE PTR [ecx], al

; 10410:           }
; 10411:           *t++ = (char)(0x80 | ((c >> 6) & 0x3F));

	mov	eax, edx
	sar	eax, 6
	and	al, 63					; 0000003fH
	inc	ecx
	or	al, -128				; ffffff80H
$LN26@soap_wchar:
	mov	BYTE PTR [ecx], al

; 10412:         }
; 10413:         *t++ = (char)(0x80 | (c & 0x3F));

	and	dl, 63					; 0000003fH
	inc	ecx
	or	dl, -128				; ffffff80H
$LN25@soap_wchar:
	mov	BYTE PTR [ecx], dl
	movzx	edx, WORD PTR [esi]
	inc	ecx
	test	edx, edx
	jne	$LL12@soap_wchar
$LN23@soap_wchar:

; 10414:       }
; 10415:     }
; 10416:     *t = '\0';

	mov	BYTE PTR [ecx], 0
$LN24@soap_wchar:

; 10417:   }
; 10418:   return r;

	mov	eax, edi
	pop	edi
	pop	esi

; 10419: }

	ret	0
_soap_wchar2s ENDP
_TEXT	ENDS
PUBLIC	_soap_s2wchar
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_t$ = 8							; size = 4
_soap_s2wchar PROC
; _soap$ = ecx
; _s$ = eax

; 10323: { if (s)

	push	esi
	mov	esi, eax
	push	edi
	mov	edi, ecx
	test	esi, esi
	je	$LN18@soap_s2wch

; 10324:   { wchar_t *r;
; 10325:     *t = r = (wchar_t*)soap_malloc(soap, sizeof(wchar_t) * (strlen(s) + 1));

	lea	edx, DWORD PTR [eax+1]
$LL24@soap_s2wch:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL24@soap_s2wch
	sub	eax, edx
	lea	eax, DWORD PTR [eax+eax+2]
	call	_soap_malloc
	mov	ecx, DWORD PTR _t$[esp+4]
	mov	DWORD PTR [ecx], eax

; 10326:     if (!r)

	test	eax, eax
	jne	SHORT $LN17@soap_s2wch

; 10327:       return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 10366: }

	ret	0
$LN17@soap_s2wch:

; 10328:     if (soap->mode & SOAP_ENC_LATIN)

	test	BYTE PTR [edi+8], 32			; 00000020H

; 10329:     { while (*s)

	mov	cl, BYTE PTR [esi]
	je	SHORT $LN22@soap_s2wch
	test	cl, cl
	je	$LN11@soap_s2wch
$LL15@soap_s2wch:

; 10330:         *r++ = (wchar_t)*s++;

	movsx	dx, cl
	inc	esi
	mov	WORD PTR [eax], dx
	mov	cl, BYTE PTR [esi]
	add	eax, 2
	test	cl, cl
	jne	SHORT $LL15@soap_s2wch

; 10357:               }
; 10358:             }
; 10359:           }
; 10360:         }
; 10361:       }
; 10362:     }
; 10363:     *r = L'\0';

	xor	edx, edx
	pop	edi
	mov	WORD PTR [eax], dx

; 10364:   }
; 10365:   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 10366: }

	ret	0
$LN22@soap_s2wch:

; 10331:     }
; 10332:     else
; 10333:     { /* Convert UTF8 to wchar */
; 10334:       while (*s)

	test	cl, cl
	je	$LN11@soap_s2wch
	push	ebx
	npad	6
$LL12@soap_s2wch:

; 10335:       { register soap_wchar c, c1, c2, c3, c4;
; 10336:         c = *s++;

	movsx	ecx, cl
	inc	esi

; 10337:         if (c < 0x80)

	cmp	ecx, 128				; 00000080H
	jge	SHORT $LN10@soap_s2wch

; 10338:           *r++ = (wchar_t)c;

	mov	WORD PTR [eax], cx
	add	eax, 2

; 10339:         else

	jmp	$LN1@soap_s2wch
$LN10@soap_s2wch:

; 10340:         { c1 = (soap_wchar)*s++ & 0x3F;

	movsx	ebx, BYTE PTR [esi]
	and	ebx, 63					; 0000003fH
	inc	esi

; 10341:           if (c < 0xE0)

	cmp	ecx, 224				; 000000e0H
	jge	SHORT $LN8@soap_s2wch

; 10342:             *r++ = (wchar_t)(((soap_wchar)(c & 0x1F) << 6) | c1);

	and	ecx, 31					; 0000001fH
	shl	ecx, 6
	or	ecx, ebx
	mov	WORD PTR [eax], cx
	add	eax, 2

; 10343:           else

	jmp	SHORT $LN1@soap_s2wch
$LN8@soap_s2wch:

; 10344:           { c2 = (soap_wchar)*s++ & 0x3F;

	movsx	edi, BYTE PTR [esi]
	and	edi, 63					; 0000003fH
	inc	esi

; 10345:             if (c < 0xF0)

	cmp	ecx, 240				; 000000f0H
	jge	SHORT $LN6@soap_s2wch

; 10346:               *r++ = (wchar_t)(((soap_wchar)(c & 0x0F) << 12) | (c1 << 6) | c2);

	shl	ecx, 6
	or	ecx, ebx
	shl	ecx, 6
	or	ecx, edi
	mov	WORD PTR [eax], cx
	add	eax, 2

; 10347:             else

	jmp	SHORT $LN1@soap_s2wch
$LN6@soap_s2wch:

; 10348:             { c3 = (soap_wchar)*s++ & 0x3F;

	movsx	edx, BYTE PTR [esi]
	and	edx, 63					; 0000003fH
	inc	esi

; 10349:               if (c < 0xF8)

	cmp	ecx, 248				; 000000f8H
	jge	SHORT $LN4@soap_s2wch

; 10350:                 *r++ = (wchar_t)(((soap_wchar)(c & 0x07) << 18) | (c1 << 12) | (c2 << 6) | c3);

	shl	ebx, 6
	or	ebx, edi
	shl	ebx, 6
	or	ebx, edx
	mov	WORD PTR [eax], bx
	add	eax, 2

; 10351:               else

	jmp	SHORT $LN1@soap_s2wch
$LN4@soap_s2wch:

; 10352:               { c4 = (soap_wchar)*s++ & 0x3F;

	movsx	ebx, BYTE PTR [esi]
	and	ebx, 63					; 0000003fH
	inc	esi

; 10353:                 if (c < 0xFC)

	cmp	ecx, 252				; 000000fcH
	jge	SHORT $LN2@soap_s2wch

; 10354:                   *r++ = (wchar_t)(((soap_wchar)(c & 0x03) << 24) | (c1 << 18) | (c2 << 12) | (c3 << 6) | c4);

	shl	edi, 6
	or	edi, edx
	shl	edi, 6
	or	edi, ebx
	mov	WORD PTR [eax], di
	add	eax, 2

; 10355:                 else

	jmp	SHORT $LN1@soap_s2wch
$LN2@soap_s2wch:

; 10356:                   *r++ = (wchar_t)(((soap_wchar)(c & 0x01) << 30) | (c1 << 24) | (c2 << 18) | (c3 << 12) | (c4 << 6) | (soap_wchar)(*s++ & 0x3F));

	mov	cl, BYTE PTR [esi]
	shl	edx, 6
	and	cl, 63					; 0000003fH
	or	edx, ebx
	movsx	cx, cl
	shl	edx, 6
	or	dx, cx
	mov	WORD PTR [eax], dx
	add	eax, 2
	inc	esi
$LN1@soap_s2wch:
	mov	cl, BYTE PTR [esi]
	test	cl, cl
	jne	$LL12@soap_s2wch
	pop	ebx
$LN11@soap_s2wch:

; 10357:               }
; 10358:             }
; 10359:           }
; 10360:         }
; 10361:       }
; 10362:     }
; 10363:     *r = L'\0';

	xor	edx, edx
	mov	WORD PTR [eax], dx
$LN18@soap_s2wch:
	pop	edi

; 10364:   }
; 10365:   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 10366: }

	ret	0
_soap_s2wchar ENDP
_TEXT	ENDS
PUBLIC	_soap_s2QName
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_n$82407 = -4						; size = 4
_soap$ = 8						; size = 4
_p$82409 = 12						; size = 4
_s$ = 12						; size = 4
_t$ = 16						; size = 4
_soap_s2QName PROC

; 10173: { if (s)

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _s$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+8]
	push	esi
	push	edi
	test	ebx, ebx
	je	SHORT $LN27@soap_s2QNa

; 10174:   { soap->labidx = 0;

	mov	DWORD PTR [ebp+12464], 0
	npad	5
$LL26@soap_s2QNa:

; 10175:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Normalized namespace(s) of QNames '%s'", s));
; 10176:     /* convert (by prefix normalize prefix) all QNames in s */
; 10177:     for (;;)
; 10178:     { size_t n;
; 10179:       struct soap_nlist *np;
; 10180:       register const char *p;
; 10181:       /* skip blanks */
; 10182:       while (*s && soap_blank(*s))

	mov	al, BYTE PTR [ebx]
	test	al, al
	je	SHORT $LN49@soap_s2QNa
$LN54@soap_s2QNa:
	jl	SHORT $LN23@soap_s2QNa
	cmp	al, 32					; 00000020H
	jg	SHORT $LN23@soap_s2QNa
	mov	al, BYTE PTR [ebx+1]

; 10183:         s++;

	inc	ebx
	test	al, al
	jne	SHORT $LN54@soap_s2QNa
$LN49@soap_s2QNa:

; 10236:     soap_append_lab(soap, SOAP_STR_EOS, 1);

	push	1
	push	OFFSET _soap_padding
	mov	esi, ebp
	call	_soap_append_lab

; 10237:     *t = soap_strdup(soap, soap->labbuf);

	mov	eax, DWORD PTR [ebp+12456]
	push	eax
	push	ebp
	call	_soap_strdup
	mov	ecx, DWORD PTR _t$[esp+32]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx], eax
$LN27@soap_s2QNa:

; 10238:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, " into '%s'\n", *t));
; 10239:   }
; 10240:   return soap->error;

	mov	eax, DWORD PTR [ebp+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10241: }

	pop	ecx
	ret	0
$LN23@soap_s2QNa:

; 10184:       if (!*s)

	cmp	BYTE PTR [ebx], 0
	je	SHORT $LN49@soap_s2QNa

; 10185:         break;
; 10186:       /* find next QName */
; 10187:       n = 1;
; 10188:       while (s[n] && !soap_blank(s[n]))

	mov	al, BYTE PTR [ebx+1]
	mov	esi, 1
	mov	DWORD PTR _n$82407[esp+20], esi
	test	al, al
	je	SHORT $LN20@soap_s2QNa
$LN55@soap_s2QNa:
	jl	SHORT $LN19@soap_s2QNa
	cmp	al, 32					; 00000020H
	jle	SHORT $LN50@soap_s2QNa
$LN19@soap_s2QNa:
	mov	al, BYTE PTR [esi+ebx+1]

; 10189:         n++;

	inc	esi
	test	al, al
	jne	SHORT $LN55@soap_s2QNa
$LN50@soap_s2QNa:
	mov	DWORD PTR _n$82407[esp+20], esi
$LN20@soap_s2QNa:

; 10190:       np = soap->nlist;

	mov	edi, DWORD PTR [ebp+88]

; 10191:       /* if there is no namespace stack, or prefix is "xml" then copy string */
; 10192:       if (!np || !strncmp(s, "xml:", 4))

	test	edi, edi
	je	$LN17@soap_s2QNa
	push	4
	push	OFFSET ??_C@_04FNFHGAAP@xml?3?$AA@
	push	ebx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN17@soap_s2QNa

; 10194:       }
; 10195:       else /* we normalize the QName by replacing its prefix */
; 10196:       { p = strchr(s, ':');

	push	58					; 0000003aH
	push	ebx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _p$82409[esp+16], eax

; 10197:         if (p)

	test	eax, eax
	je	SHORT $LL10@soap_s2QNa

; 10198:         { size_t k = p - s;

	mov	esi, eax
	sub	esi, ebx
$LL14@soap_s2QNa:

; 10199:           while (np && (strncmp(np->id, s, k) || np->id[k]))

	push	esi
	lea	eax, DWORD PTR [edi+16]
	push	ebx
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@soap_s2QNa
	cmp	BYTE PTR [esi+edi+16], al
	je	SHORT $LN13@soap_s2QNa
$LN12@soap_s2QNa:

; 10200:             np = np->next;

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL14@soap_s2QNa
$LN13@soap_s2QNa:

; 10201:           p++;

	inc	DWORD PTR _p$82409[esp+16]

; 10202:         }
; 10203:         else

	jmp	SHORT $LN11@soap_s2QNa
	npad	6
$LL10@soap_s2QNa:

; 10204:         { while (np && *np->id)

	cmp	BYTE PTR [edi+16], 0
	je	SHORT $LN9@soap_s2QNa

; 10205:             np = np->next;

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL10@soap_s2QNa
$LN9@soap_s2QNa:

; 10206:           p = s;

	mov	DWORD PTR _p$82409[esp+16], ebx
$LN11@soap_s2QNa:

; 10207:         }
; 10208:         /* replace prefix */
; 10209:         if (np)

	test	edi, edi
	je	SHORT $LN8@soap_s2QNa

; 10210:         { if (np->index >= 0 && soap->local_namespaces)

	movzx	ecx, WORD PTR [edi+8]
	test	cx, cx
	jl	SHORT $LN7@soap_s2QNa
	mov	eax, DWORD PTR [ebp+84]
	test	eax, eax
	je	SHORT $LN7@soap_s2QNa

; 10211:           { const char *q = soap->local_namespaces[np->index].id;

	movsx	ecx, cx
	shl	ecx, 4
	mov	esi, DWORD PTR [ecx+eax]

; 10212:             if (q)

	test	esi, esi
	je	SHORT $LN48@soap_s2QNa

; 10213:               soap_append_lab(soap, q, strlen(q));

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$LL42@soap_s2QNa:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL42@soap_s2QNa
	sub	eax, edx
	push	eax
	push	esi

; 10214:           }

	jmp	SHORT $LN56@soap_s2QNa
$LN7@soap_s2QNa:

; 10215:           else if (np->ns)

	cmp	DWORD PTR [edi+12], 0
	je	$LN4@soap_s2QNa

; 10216:           { soap_append_lab(soap, "\"", 1);

	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	esi, ebp
	call	_soap_append_lab

; 10217:             soap_append_lab(soap, np->ns, strlen(np->ns));

	mov	edi, DWORD PTR [edi+12]
	mov	eax, edi
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL43@soap_s2QNa:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL43@soap_s2QNa
	sub	eax, edx
	push	eax
	push	edi
	call	_soap_append_lab

; 10218:             soap_append_lab(soap, "\"", 1);

	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	call	_soap_append_lab
	add	esp, 16					; 00000010H

; 10223:           }
; 10224:         }
; 10225:         else /* no namespace: assume default "" namespace */

	jmp	SHORT $LN48@soap_s2QNa
$LN8@soap_s2QNa:

; 10226:         { soap_append_lab(soap, "\"\"", 2);

	push	2
	push	OFFSET ??_C@_02JMMFPCED@?$CC?$CC?$AA@
$LN56@soap_s2QNa:
	mov	esi, ebp
	call	_soap_append_lab
	add	esp, 8
$LN48@soap_s2QNa:

; 10227:         }
; 10228:         soap_append_lab(soap, ":", 1);

	push	1
	push	OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
	mov	esi, ebp
	call	_soap_append_lab

; 10229:         soap_append_lab(soap, p, n - (p-s));

	mov	eax, DWORD PTR _p$82409[esp+24]
	mov	edx, DWORD PTR _n$82407[esp+28]
	sub	edx, eax
	add	edx, ebx
	push	edx
	push	eax
	call	_soap_append_lab
	add	esp, 16					; 00000010H
	jmp	SHORT $LN16@soap_s2QNa
$LN17@soap_s2QNa:

; 10193:       { soap_append_lab(soap, s, n);

	push	esi
	push	ebx
	mov	esi, ebp
	call	_soap_append_lab
	add	esp, 8
$LN16@soap_s2QNa:

; 10230:       }
; 10231:       /* advance to next and add spacing */
; 10232:       s += n;

	add	ebx, DWORD PTR _n$82407[esp+20]

; 10233:       if (*s)

	cmp	BYTE PTR [ebx], 0
	je	$LL26@soap_s2QNa

; 10234:         soap_append_lab(soap, " ", 1);

	push	1
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	esi, ebp
	call	_soap_append_lab
	add	esp, 8

; 10235:     }

	jmp	$LL26@soap_s2QNa
$LN4@soap_s2QNa:
	pop	edi

; 10219:           }
; 10220:           else
; 10221:           { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "\nNamespace prefix of '%s' not defined (index=%d, URI=%s)\n", s, np->index, np->ns?np->ns:""));
; 10222:             return soap->error = SOAP_NAMESPACE;

	mov	eax, 9
	pop	esi
	mov	DWORD PTR [ebp+90460], eax
	pop	ebp
	pop	ebx

; 10241: }

	pop	ecx
	ret	0
_soap_s2QName ENDP
_TEXT	ENDS
PUBLIC	_soap_s2string
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_t$ = 8							; size = 4
_soap_s2string PROC
; _soap$ = esi
; _s$ = eax

; 10156: { if (s)

	test	eax, eax
	je	SHORT $LN2@soap_s2str

; 10157:   { if (!(*t = soap_strdup(soap, s)))

	push	eax
	push	esi
	call	_soap_strdup
	mov	ecx, DWORD PTR _t$[esp+4]
	add	esp, 8
	mov	DWORD PTR [ecx], eax
	test	eax, eax
	jne	SHORT $LN2@soap_s2str

; 10158:       return soap->error = SOAP_EOM;

	mov	eax, 20					; 00000014H
	mov	DWORD PTR [esi+90460], eax

; 10164: }

	ret	0
$LN2@soap_s2str:

; 10159:     if (!(soap->mode & (SOAP_ENC_LATIN | SOAP_C_UTFSTRING)))
; 10160:     { /* TODO: consider truncating UTF8 to ASCII for regular XML attribute strings? */
; 10161:     }
; 10162:   }
; 10163:   return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 10164: }

	ret	0
_soap_s2string ENDP
_TEXT	ENDS
PUBLIC	__real@ffefffffffffffff
PUBLIC	__real@7fefffffffffffff
PUBLIC	_soap_s2double
;	COMDAT __real@ffefffffffffffff
CONST	SEGMENT
__real@ffefffffffffffff DQ 0ffefffffffffffffr	; -1.79769e+308
CONST	ENDS
;	COMDAT __real@7fefffffffffffff
CONST	SEGMENT
__real@7fefffffffffffff DQ 07fefffffffffffffr	; 1.79769e+308
; Function compile flags: /Ogtpy
CONST	ENDS
_TEXT	SEGMENT
_r$82150 = -4						; size = 4
_soap$ = 8						; size = 4
_soap_s2double PROC
; _s$ = esi
; _p$ = edi

; 9689 : { if (s)

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp+4]
	test	esi, esi
	je	$LN1@soap_s2dou

; 9690 :   { if (!*s)

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN11@soap_s2dou

; 9691 :       return soap->error = SOAP_TYPE;

	mov	eax, 4
	mov	DWORD PTR [ebx+90460], eax
	pop	ebx

; 9723 : }

	pop	ecx
	ret	0
$LN11@soap_s2dou:

; 9692 :     if (!soap_tag_cmp(s, "INF"))

	push	OFFSET ??_C@_03OEIAHPBN@INF?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax

; 9693 :       *p = DBL_PINFTY;

	je	SHORT $LN15@soap_s2dou

; 9694 :     else if (!soap_tag_cmp(s, "+INF"))

	push	OFFSET ??_C@_04LFPHEJAJ@?$CLINF?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@soap_s2dou
$LN15@soap_s2dou:

; 9695 :       *p = DBL_PINFTY;

	movsd	xmm0, QWORD PTR __real@7fefffffffffffff
	movsd	QWORD PTR [edi], xmm0

; 9717 : #else
; 9718 :         soap->error = SOAP_TYPE;
; 9719 : #endif
; 9720 :     }
; 9721 :   }
; 9722 :   return soap->error;

	mov	eax, DWORD PTR [ebx+90460]
	pop	ebx

; 9723 : }

	pop	ecx
	ret	0
$LN8@soap_s2dou:

; 9696 :     else if (!soap_tag_cmp(s, "-INF"))

	push	OFFSET ??_C@_04DKLHLMKJ@?9INF?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@soap_s2dou

; 9697 :       *p = DBL_NINFTY;

	movsd	xmm0, QWORD PTR __real@ffefffffffffffff
	movsd	QWORD PTR [edi], xmm0

; 9717 : #else
; 9718 :         soap->error = SOAP_TYPE;
; 9719 : #endif
; 9720 :     }
; 9721 :   }
; 9722 :   return soap->error;

	mov	eax, DWORD PTR [ebx+90460]
	pop	ebx

; 9723 : }

	pop	ecx
	ret	0
$LN6@soap_s2dou:

; 9698 :     else if (!soap_tag_cmp(s, "NaN"))

	push	OFFSET ??_C@_03ICJPMMHB@NaN?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@soap_s2dou

; 9699 :       *p = DBL_NAN;

	movsd	xmm0, QWORD PTR _soap_double_nan
	movsd	QWORD PTR [edi], xmm0

; 9717 : #else
; 9718 :         soap->error = SOAP_TYPE;
; 9719 : #endif
; 9720 :     }
; 9721 :   }
; 9722 :   return soap->error;

	mov	eax, DWORD PTR [ebx+90460]
	pop	ebx

; 9723 : }

	pop	ecx
	ret	0
$LN4@soap_s2dou:

; 9700 :     else
; 9701 :     {
; 9702 : #if defined(HAVE_STRTOD_L)
; 9703 :       char *r;
; 9704 :       *p = strtod_l(s, &r, NULL);
; 9705 :       if (*r)
; 9706 : #elif defined(HAVE_STRTOD)
; 9707 :       char *r;
; 9708 :       *p = strtod(s, &r);

	lea	eax, DWORD PTR _r$82150[esp+8]
	push	eax
	push	esi
	call	_strtod
	fstp	QWORD PTR [edi]

; 9709 :       if (*r)

	mov	ecx, DWORD PTR _r$82150[esp+16]
	add	esp, 8
	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN1@soap_s2dou

; 9710 : #endif
; 9711 : #if defined(HAVE_SSCANF_L)
; 9712 :         if (sscanf_l(s, NULL, "%lg", p) != 1)
; 9713 :           soap->error = SOAP_TYPE;
; 9714 : #elif defined(HAVE_SSCANF)
; 9715 :         if (sscanf(s, "%lg", p) != 1)

	push	edi
	push	OFFSET ??_C@_03CCCGLAML@?$CFlg?$AA@
	push	esi
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN1@soap_s2dou

; 9716 :           soap->error = SOAP_TYPE;

	mov	DWORD PTR [ebx+90460], 4
$LN1@soap_s2dou:

; 9717 : #else
; 9718 :         soap->error = SOAP_TYPE;
; 9719 : #endif
; 9720 :     }
; 9721 :   }
; 9722 :   return soap->error;

	mov	eax, DWORD PTR [ebx+90460]
	pop	ebx

; 9723 : }

	pop	ecx
	ret	0
_soap_s2double ENDP
_TEXT	ENDS
PUBLIC	_soap_double2s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_n$ = 8							; size = 8
_soap_double2s PROC
; _soap$ = edi

; 9651 :   if (soap_isnan(n))

	fld	QWORD PTR _n$[esp-4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	__isnan
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@soap_doubl

; 9652 :     return "NaN";

	mov	eax, OFFSET ??_C@_03ICJPMMHB@NaN?$AA@

; 9667 : }

	ret	0
$LN4@soap_doubl:

; 9653 :   if (soap_ispinfd(n))

	movsd	xmm0, QWORD PTR _n$[esp-4]
	comisd	xmm0, QWORD PTR __real@7fefffffffffffff
	jb	SHORT $LN3@soap_doubl

; 9654 :     return "INF";

	mov	eax, OFFSET ??_C@_03OEIAHPBN@INF?$AA@

; 9667 : }

	ret	0
$LN3@soap_doubl:

; 9655 :   if (soap_isninfd(n))

	movsd	xmm1, QWORD PTR __real@ffefffffffffffff
	comisd	xmm1, xmm0
	jb	SHORT $LN2@soap_doubl

; 9656 :     return "-INF";

	mov	eax, OFFSET ??_C@_04DKLHLMKJ@?9INF?$AA@

; 9667 : }

	ret	0
$LN2@soap_doubl:

; 9657 :   s = soap->tmpbuf;
; 9658 : #if defined(HAVE_SPRINTF_L)
; 9659 :   sprintf_l(s, NULL, soap->double_format, n);
; 9660 : #else
; 9661 :   sprintf(s, soap->double_format, n);

	fld	QWORD PTR _n$[esp-4]
	mov	eax, DWORD PTR [edi+24]
	push	esi
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	lea	esi, DWORD PTR [edi+79028]
	push	esi
	call	_sprintf

; 9662 :   s = strchr(s, ',');	/* convert decimal comma to DP */

	push	44					; 0000002cH
	push	esi
	call	_strchr
	add	esp, 24					; 00000018H

; 9663 :   if (s)

	test	eax, eax
	je	SHORT $LN1@soap_doubl

; 9664 :     *s = '.';

	mov	BYTE PTR [eax], 46			; 0000002eH
$LN1@soap_doubl:

; 9665 : #endif
; 9666 :   return soap->tmpbuf;

	mov	eax, esi
	pop	esi

; 9667 : }

	ret	0
_soap_double2s ENDP
_TEXT	ENDS
PUBLIC	__real@ff7fffff
PUBLIC	__real@7f7fffff
PUBLIC	_soap_s2float
;	COMDAT __real@ff7fffff
CONST	SEGMENT
__real@ff7fffff DD 0ff7fffffr			; -3.40282e+038
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+038
; Function compile flags: /Ogtpy
CONST	ENDS
_TEXT	SEGMENT
_r$82079 = -4						; size = 4
_soap$ = 8						; size = 4
_soap_s2float PROC
; _s$ = esi
; _p$ = edi

; 9545 : { if (s)

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp+4]
	test	esi, esi
	je	$LN1@soap_s2flo

; 9546 :   { if (!*s)

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN11@soap_s2flo

; 9547 :       return soap->error = SOAP_TYPE;

	mov	eax, 4
	mov	DWORD PTR [ebx+90460], eax
	pop	ebx

; 9588 : }

	pop	ecx
	ret	0
$LN11@soap_s2flo:

; 9548 :     if (!soap_tag_cmp(s, "INF"))

	push	OFFSET ??_C@_03OEIAHPBN@INF?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax

; 9549 :       *p = FLT_PINFTY;

	je	SHORT $LN15@soap_s2flo

; 9550 :     else if (!soap_tag_cmp(s, "+INF"))

	push	OFFSET ??_C@_04LFPHEJAJ@?$CLINF?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@soap_s2flo
$LN15@soap_s2flo:

; 9551 :       *p = FLT_PINFTY;

	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR [edi], xmm0

; 9582 : #else
; 9583 :         soap->error = SOAP_TYPE;
; 9584 : #endif
; 9585 :     }
; 9586 :   }
; 9587 :   return soap->error;

	mov	eax, DWORD PTR [ebx+90460]
	pop	ebx

; 9588 : }

	pop	ecx
	ret	0
$LN8@soap_s2flo:

; 9552 :     else if (!soap_tag_cmp(s, "-INF"))

	push	OFFSET ??_C@_04DKLHLMKJ@?9INF?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@soap_s2flo

; 9553 :       *p = FLT_NINFTY;

	movss	xmm0, DWORD PTR __real@ff7fffff
	movss	DWORD PTR [edi], xmm0

; 9582 : #else
; 9583 :         soap->error = SOAP_TYPE;
; 9584 : #endif
; 9585 :     }
; 9586 :   }
; 9587 :   return soap->error;

	mov	eax, DWORD PTR [ebx+90460]
	pop	ebx

; 9588 : }

	pop	ecx
	ret	0
$LN6@soap_s2flo:

; 9554 :     else if (!soap_tag_cmp(s, "NaN"))

	push	OFFSET ??_C@_03ICJPMMHB@NaN?$AA@
	push	esi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@soap_s2flo

; 9555 :       *p = FLT_NAN;

	movss	xmm0, DWORD PTR _soap_double_nan
	movss	DWORD PTR [edi], xmm0

; 9582 : #else
; 9583 :         soap->error = SOAP_TYPE;
; 9584 : #endif
; 9585 :     }
; 9586 :   }
; 9587 :   return soap->error;

	mov	eax, DWORD PTR [ebx+90460]
	pop	ebx

; 9588 : }

	pop	ecx
	ret	0
$LN4@soap_s2flo:

; 9556 :     else
; 9557 :     {
; 9558 : /* On some systems, strtof appears to be broken or doesn't link: use with caution */
; 9559 : #if defined(HAVE_STRTOF_L)
; 9560 :       char *r;
; 9561 :       *p = strtof_l((char*)s, &r, NULL);
; 9562 :       if (*r)
; 9563 : #elif defined(HAVE_STRTOD_L)
; 9564 :       char *r;
; 9565 :       *p = (float)strtod_l(s, &r, NULL);
; 9566 :       if (*r)
; 9567 : #elif defined(HAVE_STRTOF)
; 9568 :       char *r;
; 9569 :       *p = strtof((char*)s, &r);
; 9570 :       if (*r)
; 9571 : #elif defined(HAVE_STRTOD)
; 9572 :       char *r;
; 9573 :       *p = (float)strtod(s, &r);

	lea	eax, DWORD PTR _r$82079[esp+8]
	push	eax
	push	esi
	call	_strtod
	fstp	DWORD PTR [edi]

; 9574 :       if (*r)

	mov	ecx, DWORD PTR _r$82079[esp+16]
	add	esp, 8
	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN1@soap_s2flo

; 9575 : #endif
; 9576 : #if defined(HAVE_SSCANF_L)
; 9577 :         if (sscanf_l(s, NULL, "%g", p) != 1)
; 9578 :           soap->error = SOAP_TYPE;
; 9579 : #elif defined(HAVE_SSCANF)
; 9580 :         if (sscanf(s, "%g", p) != 1)

	push	edi
	push	OFFSET ??_C@_02BEIEFPIG@?$CFg?$AA@
	push	esi
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN1@soap_s2flo

; 9581 :           soap->error = SOAP_TYPE;

	mov	DWORD PTR [ebx+90460], 4
$LN1@soap_s2flo:

; 9582 : #else
; 9583 :         soap->error = SOAP_TYPE;
; 9584 : #endif
; 9585 :     }
; 9586 :   }
; 9587 :   return soap->error;

	mov	eax, DWORD PTR [ebx+90460]
	pop	ebx

; 9588 : }

	pop	ecx
	ret	0
_soap_s2float ENDP
_TEXT	ENDS
PUBLIC	__real@c7efffffe0000000
PUBLIC	__real@47efffffe0000000
PUBLIC	_soap_float2s
;	COMDAT __real@c7efffffe0000000
; File c:\program files\microsoft visual studio 9.0\vc\include\string.h
CONST	SEGMENT
__real@c7efffffe0000000 DQ 0c7efffffe0000000r	; -3.40282e+038
CONST	ENDS
;	COMDAT __real@47efffffe0000000
CONST	SEGMENT
__real@47efffffe0000000 DQ 047efffffe0000000r	; 3.40282e+038
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\stdsoap2.cpp
CONST	ENDS
_TEXT	SEGMENT
_n$ = 8							; size = 4
_soap_float2s PROC
; _soap$ = edi

; 9506 : { char *s;

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H

; 9507 :   if (soap_isnan((double)n))

	cvtss2sd xmm0, DWORD PTR _n$[ebp]
	sub	esp, 60					; 0000003cH
	push	esi
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	__isnan
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@soap_float

; 9508 :     return "NaN";

	mov	eax, OFFSET ??_C@_03ICJPMMHB@NaN?$AA@

; 9523 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@soap_float:

; 9509 :   if (soap_ispinff(n))

	movss	xmm0, DWORD PTR _n$[ebp]
	cvtps2pd xmm1, xmm0
	comisd	xmm1, QWORD PTR __real@47efffffe0000000
	jb	SHORT $LN3@soap_float

; 9510 :     return "INF";

	mov	eax, OFFSET ??_C@_03OEIAHPBN@INF?$AA@

; 9523 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@soap_float:

; 9511 :   if (soap_isninff(n))

	movsd	xmm2, QWORD PTR __real@c7efffffe0000000
	cvtps2pd xmm1, xmm0
	comisd	xmm2, xmm1
	jb	SHORT $LN2@soap_float

; 9512 :     return "-INF";

	mov	eax, OFFSET ??_C@_04DKLHLMKJ@?9INF?$AA@

; 9523 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@soap_float:

; 9513 :   s = soap->tmpbuf;
; 9514 : #if defined(HAVE_SPRINTF_L)
; 9515 :   sprintf_l(s, NULL, soap->float_format, n);
; 9516 : #else
; 9517 :   sprintf(s, soap->float_format, n);

	mov	eax, DWORD PTR [edi+20]
	sub	esp, 8
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	eax
	lea	esi, DWORD PTR [edi+79028]
	push	esi
	call	_sprintf

; 9518 :   s = strchr(s, ',');	/* convert decimal comma to DP */

	push	44					; 0000002cH
	push	esi
	call	_strchr
	add	esp, 24					; 00000018H

; 9519 :   if (s)

	test	eax, eax
	je	SHORT $LN1@soap_float

; 9520 :     *s = '.';

	mov	BYTE PTR [eax], 46			; 0000002eH
$LN1@soap_float:

; 9521 : #endif
; 9522 :   return soap->tmpbuf;

	mov	eax, esi

; 9523 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_float2s ENDP
_TEXT	ENDS
PUBLIC	_soap_short2s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_short2s PROC
; _soap$ = ecx
; _n$ = eax

; 9434 : { return soap_long2s(soap, (long)n);

	push	esi
	cwde
	push	eax
	mov	esi, ecx
	add	esi, 79028				; 000134b4H
	push	OFFSET ??_C@_03JALODAI@?$CFld?$AA@
	push	esi
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi

; 9435 : }

	ret	0
_soap_short2s ENDP
_TEXT	ENDS
PUBLIC	_soap_byte2s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_byte2s PROC
; _soap$ = ecx
; _n$ = eax

; 9363 : { return soap_long2s(soap, (long)n);

	push	esi
	movsx	eax, al
	push	eax
	mov	esi, ecx
	add	esi, 79028				; 000134b4H
	push	OFFSET ??_C@_03JALODAI@?$CFld?$AA@
	push	esi
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi

; 9364 : }

	ret	0
_soap_byte2s ENDP
; Function compile flags: /Ogtpy
_soap_pop_ns PROC
; _soap$ = edi

; 6927 : { soap_pop_namespace(soap);

	mov	eax, DWORD PTR [edi+88]
	test	eax, eax
	je	SHORT $LN10@soap_pop_n@2
	push	esi
	npad	8
$LL5@soap_pop_n@2:
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [edi+12444]
	jb	SHORT $LN11@soap_pop_n@2
	mov	esi, DWORD PTR [eax]
	push	eax
	call	_free
	add	esp, 4
	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL5@soap_pop_n@2
$LN11@soap_pop_n@2:
	pop	esi
$LN10@soap_pop_n@2:
	mov	DWORD PTR [edi+88], eax

; 6928 : }

	ret	0
_soap_pop_ns ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_ns$ = 16						; size = 4
_utilized$ = 20						; size = 2
_soap_push_ns PROC

; 6863 : { register struct soap_nlist *np;

	push	ebx
	mov	ebx, DWORD PTR _ns$[esp]
	push	ebp
	mov	ebp, DWORD PTR _id$[esp+4]
	push	edi

; 6864 :   size_t n, k;
; 6865 :   if (soap_strsearch(soap->c14nexclude, id))

	mov	edi, DWORD PTR _soap$[esp+8]
	mov	eax, DWORD PTR [edi+94672]
	push	ebp
	call	_soap_strsearch
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@soap_push_@3
	pop	edi
	pop	ebp

; 6866 :     return NULL;

	xor	eax, eax
	pop	ebx

; 6901 :   return np;
; 6902 : }

	ret	0
$LN16@soap_push_@3:

; 6867 :   if (!utilized)

	cmp	WORD PTR _utilized$[esp+8], 0
	push	esi
	jne	$LN6@soap_push_@3

; 6868 :   { for (np = soap->nlist; np; np = np->next)

	mov	esi, DWORD PTR [edi+88]
	test	esi, esi
	je	$LN6@soap_push_@3
$LL14@soap_push_@3:

; 6869 :     { if (!strcmp(np->id, id) && (!np->ns || !strcmp(np->ns, ns)))

	mov	ecx, ebp
	lea	eax, DWORD PTR [esi+16]
$LL25@soap_push_@3:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN26@soap_push_@3
	test	dl, dl
	je	SHORT $LN27@soap_push_@3
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN26@soap_push_@3
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL25@soap_push_@3
$LN27@soap_push_@3:
	xor	eax, eax
	jmp	SHORT $LN28@soap_push_@3
$LN26@soap_push_@3:
	sbb	eax, eax
	sbb	eax, -1
$LN28@soap_push_@3:
	test	eax, eax
	jne	SHORT $LN13@soap_push_@3
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN35@soap_push_@3
	mov	ecx, ebx
$LL29@soap_push_@3:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN30@soap_push_@3
	test	dl, dl
	je	SHORT $LN31@soap_push_@3
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN30@soap_push_@3
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL29@soap_push_@3
$LN31@soap_push_@3:
	xor	eax, eax
	jmp	SHORT $LN32@soap_push_@3
$LN30@soap_push_@3:
	sbb	eax, eax
	sbb	eax, -1
$LN32@soap_push_@3:
	test	eax, eax
	je	SHORT $LN35@soap_push_@3
$LN13@soap_push_@3:

; 6868 :   { for (np = soap->nlist; np; np = np->next)

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL14@soap_push_@3

; 6870 :         break;
; 6871 :     }
; 6872 :     if (np)

	jmp	SHORT $LN6@soap_push_@3
$LN35@soap_push_@3:

; 6873 :     { if ((np->level < soap->level || !np->ns) && np->index == 1)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [edi+12444]
	jb	SHORT $LN7@soap_push_@3
	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN8@soap_push_@3
$LN7@soap_push_@3:
	mov	eax, 1
	cmp	WORD PTR [esi+8], ax
	jne	SHORT $LN8@soap_push_@3

; 6874 :         utilized = 1;

	mov	DWORD PTR _utilized$[esp+12], eax
$LN6@soap_push_@3:

; 6875 :       else
; 6876 :         return NULL;
; 6877 :     }
; 6878 :   }
; 6879 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Adding namespace binding (level=%u) '%s' '%s' utilized=%d\n", soap->level, id, ns?ns:"(null)", utilized));
; 6880 :   n = strlen(id);

	mov	eax, ebp
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL33@soap_push_@3:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL33@soap_push_@3
	sub	eax, edx
	mov	edi, eax

; 6881 :   if (ns)

	test	ebx, ebx
	je	SHORT $LN5@soap_push_@3

; 6882 :     k = strlen(ns);

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL34@soap_push_@3:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL34@soap_push_@3
	sub	eax, edx

; 6883 :   else

	jmp	SHORT $LN4@soap_push_@3
$LN5@soap_push_@3:

; 6884 :     k = 0;

	xor	eax, eax
$LN4@soap_push_@3:

; 6885 :   np = (struct soap_nlist*)SOAP_MALLOC(soap, sizeof(struct soap_nlist) + n + k + 1);

	lea	ecx, DWORD PTR [eax+edi+21]
	push	ecx
	call	_malloc
	add	esp, 4

; 6886 :   if (!np)

	test	eax, eax
	jne	SHORT $LN3@soap_push_@3

; 6887 :   { soap->error = SOAP_EOM;

	mov	edx, DWORD PTR _soap$[esp+12]
	mov	DWORD PTR [edx+90460], 20		; 00000014H
$LN8@soap_push_@3:
	pop	esi
	pop	edi
	pop	ebp

; 6888 :     return NULL;

	xor	eax, eax
	pop	ebx

; 6901 :   return np;
; 6902 : }

	ret	0
$LN3@soap_push_@3:

; 6889 :   }
; 6890 :   np->next = soap->nlist;

	mov	ecx, DWORD PTR _soap$[esp+12]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax], edx

; 6891 :   soap->nlist = np;
; 6892 :   strcpy(np->id, id);

	lea	esi, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+88], eax
	mov	ecx, ebp
	sub	esi, ebp
	npad	6
$LL19@soap_push_@3:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [esi+ecx], dl
	inc	ecx
	test	dl, dl
	jne	SHORT $LL19@soap_push_@3

; 6893 :   if (ns)

	test	ebx, ebx
	je	SHORT $LN2@soap_push_@3

; 6894 :   { np->ns = np->id + n + 1;

	lea	esi, DWORD PTR [edi+eax+17]
	mov	DWORD PTR [eax+12], esi

; 6895 :     strcpy(np->ns, ns);

	mov	ecx, ebx
	sub	esi, ebx
	npad	7
$LL20@soap_push_@3:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [esi+ecx], dl
	inc	ecx
	test	dl, dl
	jne	SHORT $LL20@soap_push_@3

; 6896 :   }
; 6897 :   else

	jmp	SHORT $LN1@soap_push_@3
$LN2@soap_push_@3:

; 6898 :     np->ns = NULL;

	mov	DWORD PTR [eax+12], 0
$LN1@soap_push_@3:

; 6899 :   np->level = soap->level;

	mov	ecx, DWORD PTR _soap$[esp+12]
	mov	edx, DWORD PTR [ecx+12444]

; 6900 :   np->index = utilized;

	mov	cx, WORD PTR _utilized$[esp+12]
	pop	esi
	pop	edi
	pop	ebp
	mov	DWORD PTR [eax+4], edx
	mov	WORD PTR [eax+8], cx
	pop	ebx

; 6901 :   return np;
; 6902 : }

	ret	0
_soap_push_ns ENDP
_TEXT	ENDS
PUBLIC	_soap_set_namespaces
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_level$ = 8						; size = 4
_soap$ = 8						; size = 4
_soap_set_namespaces PROC
; _p$ = ecx

; 6743 : { register struct Namespace *ns = soap->local_namespaces;

	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]

; 6744 :   register struct soap_nlist *np, *nq, *nr;
; 6745 :   register unsigned int level = soap->level;

	mov	eax, DWORD PTR [ebx+12444]
	push	ebp
	mov	ebp, DWORD PTR [ebx+84]
	push	esi
	push	edi

; 6746 :   soap->namespaces = p;
; 6747 :   soap->local_namespaces = NULL;

	xor	edi, edi

; 6748 :   soap_set_local_namespaces(soap);

	push	ebx
	mov	DWORD PTR _level$[esp+16], eax
	mov	DWORD PTR [ebx+80], ecx
	mov	DWORD PTR [ebx+84], edi
	call	_soap_set_local_namespaces

; 6749 :   /* reverse the namespace list */
; 6750 :   np = soap->nlist;

	mov	esi, DWORD PTR [ebx+88]
	add	esp, 4

; 6751 :   soap->nlist = NULL;

	mov	DWORD PTR [ebx+88], edi

; 6752 :   if (np)

	cmp	esi, edi
	je	SHORT $LN9@soap_set_n

; 6753 :   { nq = np->next;

	mov	eax, DWORD PTR [esi]

; 6754 :     np->next = NULL;

	mov	DWORD PTR [esi], edi

; 6755 :     while (nq)

	cmp	eax, edi
	je	SHORT $LN17@soap_set_n
$LL12@soap_set_n:

; 6756 :     { nr = nq->next;

	mov	ecx, DWORD PTR [eax]

; 6757 :       nq->next = np;

	mov	DWORD PTR [eax], esi

; 6758 :       np = nq;

	mov	esi, eax

; 6759 :       nq = nr;

	mov	eax, ecx
	cmp	ecx, edi
	jne	SHORT $LL12@soap_set_n
$LN17@soap_set_n:

; 6760 :     }
; 6761 :   }
; 6762 :   /* then push on new stack */
; 6763 :   while (np)

	cmp	esi, edi
	je	SHORT $LN9@soap_set_n
	npad	8
$LL10@soap_set_n:

; 6764 :   { register const char *s;
; 6765 :     soap->level = np->level; /* preserve element nesting level */

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ebx+12444], edx

; 6766 :     s = np->ns;

	mov	edi, DWORD PTR [esi+12]

; 6767 :     if (!s && np->index >= 0 && ns)

	test	edi, edi
	jne	SHORT $LN23@soap_set_n
	movzx	eax, WORD PTR [esi+8]
	test	ax, ax
	jl	SHORT $LN6@soap_set_n
	test	ebp, ebp
	je	SHORT $LN6@soap_set_n

; 6768 :     { s = ns[np->index].out;

	cwde
	shl	eax, 4
	mov	edi, DWORD PTR [eax+ebp+12]
	add	eax, ebp

; 6769 :       if (!s)

	test	edi, edi
	jne	SHORT $LN23@soap_set_n

; 6770 :         s = ns[np->index].ns;

	mov	edi, DWORD PTR [eax+4]

; 6771 :     }
; 6772 :     if (s && soap_push_namespace(soap, np->id, s))

	test	edi, edi
	je	SHORT $LN6@soap_set_n
$LN23@soap_set_n:
	lea	ecx, DWORD PTR [esi+16]
	push	ecx
	push	ebx
	call	_soap_push_namespace
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@soap_set_n
$LN6@soap_set_n:

; 6774 :     nq = np;

	mov	eax, esi

; 6775 :     np = np->next;

	mov	esi, DWORD PTR [esi]

; 6776 :     SOAP_FREE(soap, nq);

	push	eax
	call	_free
	add	esp, 4
	test	esi, esi
	jne	SHORT $LL10@soap_set_n
$LN9@soap_set_n:

; 6777 :   }
; 6778 :   if (ns)

	test	ebp, ebp
	je	SHORT $LN5@soap_set_n

; 6779 :   { register int i;
; 6780 :     for (i = 0; ns[i].id; i++)

	xor	edi, edi
	cmp	DWORD PTR [ebp], edi
	je	SHORT $LN2@soap_set_n
	mov	esi, ebp
$LL4@soap_set_n:

; 6781 :     { if (ns[i].out)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN3@soap_set_n

; 6782 :       { SOAP_FREE(soap, ns[i].out);

	push	eax
	call	_free
	add	esp, 4

; 6783 :         ns[i].out = NULL;

	mov	DWORD PTR [esi+12], 0
$LN3@soap_set_n:
	inc	edi
	mov	edx, edi
	shl	edx, 4
	cmp	DWORD PTR [edx+ebp], 0
	lea	esi, DWORD PTR [edx+ebp]
	jne	SHORT $LL4@soap_set_n
$LN2@soap_set_n:

; 6784 :       }
; 6785 :     }
; 6786 :     SOAP_FREE(soap, ns);

	push	ebp
	call	_free
	add	esp, 4
$LN5@soap_set_n:

; 6787 :   }
; 6788 :   soap->level = level; /* restore level */

	mov	eax, DWORD PTR _level$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+12444], eax
	pop	ebp

; 6789 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 6790 : }

	ret	0
$LN19@soap_set_n:

; 6773 :       return soap->error;

	mov	eax, DWORD PTR [ebx+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 6790 : }

	ret	0
_soap_set_namespaces ENDP
_TEXT	ENDS
PUBLIC	_soap_copy_context
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_copy_context PROC
; _copy$ = esi

; 6318 : { if (soap_check_state(soap))

	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	ebp
	xor	ebp, ebp
	cmp	ebx, ebp
	je	$LN7@soap_copy_
	movzx	eax, WORD PTR [ebx+4]
	cmp	ax, 1
	je	SHORT $LN8@soap_copy_
	cmp	ax, 2
	jne	$LN7@soap_copy_
$LN8@soap_copy_:
	push	edi

; 6320 :   if (copy)

	cmp	esi, ebp
	je	$LN3@soap_copy_

; 6321 :   { register struct soap_plugin *p = NULL;
; 6322 :     memcpy(copy, soap, sizeof(struct soap));

	push	95832					; 00017658H
	push	ebx
	push	esi
	call	_memcpy

; 6323 :     copy->state = SOAP_COPY;

	mov	eax, 2
	mov	WORD PTR [esi+4], ax

; 6324 :     copy->error = SOAP_OK;
; 6325 :     copy->userid = NULL;
; 6326 :     copy->passwd = NULL;
; 6327 :     copy->nlist = NULL;
; 6328 :     copy->blist = NULL;
; 6329 :     copy->clist = NULL;
; 6330 :     copy->alist = NULL;
; 6331 :     copy->attributes = NULL;
; 6332 :     copy->labbuf = NULL;
; 6333 :     copy->lablen = 0;
; 6334 :     copy->labidx = 0;
; 6335 : #ifdef SOAP_MEM_DEBUG
; 6336 :     soap_init_mht(copy);
; 6337 : #endif
; 6338 : #ifdef SOAP_DEBUG
; 6339 :     soap_init_logs(copy);
; 6340 :     soap_set_recv_logfile(copy, soap->logfile[SOAP_INDEX_RECV]);
; 6341 :     soap_set_sent_logfile(copy, soap->logfile[SOAP_INDEX_SENT]);
; 6342 :     soap_set_test_logfile(copy, soap->logfile[SOAP_INDEX_TEST]);
; 6343 : #endif
; 6344 : #ifdef WITH_ZLIB
; 6345 :     copy->d_stream = (z_stream*)SOAP_MALLOC(copy, sizeof(z_stream));
; 6346 :     copy->d_stream->zalloc = Z_NULL;
; 6347 :     copy->d_stream->zfree = Z_NULL;
; 6348 :     copy->d_stream->opaque = Z_NULL;
; 6349 :     copy->z_buf = NULL;
; 6350 : #endif
; 6351 :     copy->local_namespaces = NULL;
; 6352 : #ifndef WITH_NOIDREF
; 6353 :     soap_init_iht(copy);

	xor	eax, eax
	mov	DWORD PTR [esi+90460], ebp
	mov	DWORD PTR [esi+12224], ebp
	mov	DWORD PTR [esi+12228], ebp
	mov	DWORD PTR [esi+88], ebp
	mov	DWORD PTR [esi+92], ebp
	mov	DWORD PTR [esi+96], ebp
	mov	DWORD PTR [esi+100], ebp
	mov	DWORD PTR [esi+87292], ebp
	mov	DWORD PTR [esi+12456], ebp
	mov	DWORD PTR [esi+12460], ebp
	mov	DWORD PTR [esi+12464], ebp
	mov	DWORD PTR [esi+84], ebp
	lea	edi, DWORD PTR [esi+104]
	mov	ecx, 1999				; 000007cfH
	rep stosd

; 6354 :     soap_init_pht(copy);

	xor	ecx, ecx
	mov	WORD PTR [esi+12200], cx
	mov	DWORD PTR [esi+12196], ebp
	lea	edi, DWORD PTR [esi+8100]
	mov	ecx, 1024				; 00000400H
	rep stosd

; 6355 : #endif
; 6356 :     copy->header = NULL;

	mov	DWORD PTR [esi+12204], ebp

; 6357 :     copy->fault = NULL;

	mov	DWORD PTR [esi+12208], ebp

; 6358 :     copy->action = NULL;

	mov	DWORD PTR [esi+90392], ebp

; 6359 : #ifndef WITH_LEAN
; 6360 : #ifdef WITH_COOKIES
; 6361 :     copy->cookies = soap_copy_cookies(copy, soap);
; 6362 : #else
; 6363 :     copy->cookies = NULL;

	mov	DWORD PTR [esi+94676], ebp

; 6364 : #endif
; 6365 : #endif
; 6366 :     copy->plugins = NULL;

	mov	DWORD PTR [esi+12220], ebp

; 6367 :     for (p = soap->plugins; p; p = p->next)

	mov	edi, DWORD PTR [ebx+12220]
	add	esp, 12					; 0000000cH
	cmp	edi, ebp
	je	SHORT $LN3@soap_copy_
	npad	2
$LL5@soap_copy_:

; 6368 :     { register struct soap_plugin *q = (struct soap_plugin*)SOAP_MALLOC(copy, sizeof(struct soap_plugin));

	push	20					; 00000014H
	call	_malloc
	mov	ebx, eax
	add	esp, 4

; 6369 :       if (!q)

	cmp	ebx, ebp
	je	SHORT $LN24@soap_copy_

; 6370 :         return NULL;
; 6371 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying plugin '%s'\n", p->id));
; 6372 :       *q = *p;

	movq	xmm0, QWORD PTR [edi]
	movq	QWORD PTR [ebx], xmm0
	movq	xmm0, QWORD PTR [edi+8]
	movq	QWORD PTR [ebx+8], xmm0
	mov	edx, DWORD PTR [edi+16]
	mov	DWORD PTR [ebx+16], edx

; 6373 :       if (p->fcopy && p->fcopy(copy, q, p))

	mov	eax, DWORD PTR [edi+12]
	cmp	eax, ebp
	je	SHORT $LN1@soap_copy_
	push	edi
	push	ebx
	push	esi
	call	eax
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@soap_copy_
$LN1@soap_copy_:

; 6377 :       }
; 6378 :       q->next = copy->plugins;

	mov	eax, DWORD PTR [esi+12220]
	mov	DWORD PTR [ebx], eax

; 6379 :       copy->plugins = q;

	mov	DWORD PTR [esi+12220], ebx
	mov	edi, DWORD PTR [edi]
	cmp	edi, ebp
	jne	SHORT $LL5@soap_copy_
$LN3@soap_copy_:
	pop	edi
	pop	ebp

; 6380 :     }
; 6381 :   }
; 6382 :   return copy;

	mov	eax, esi
	pop	ebx

; 6383 : }

	ret	0
$LN25@soap_copy_:

; 6374 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not copy plugin '%s'\n", p->id));
; 6375 :         SOAP_FREE(copy, q);

	push	ebx
	call	_free
	add	esp, 4
$LN24@soap_copy_:
	pop	edi
	pop	ebp

; 6376 :         return NULL;

	xor	eax, eax
	pop	ebx

; 6383 : }

	ret	0
$LN7@soap_copy_:
	pop	ebp

; 6319 :     return NULL;

	xor	eax, eax
	pop	ebx

; 6383 : }

	ret	0
_soap_copy_context ENDP
_TEXT	ENDS
PUBLIC	_soap_copy
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_copy PROC
; _soap$ = eax

; 6308 : { return soap_copy_context((struct soap*)malloc(sizeof(struct soap)), soap);

	push	esi
	push	eax
	push	95832					; 00017658H
	call	_malloc
	add	esp, 4
	mov	esi, eax
	call	_soap_copy_context
	add	esp, 4
	pop	esi

; 6309 : }

	ret	0
_soap_copy ENDP
_TEXT	ENDS
PUBLIC	_soap_free_temp
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_free_temp PROC
; _soap$ = esi

; 6153 :   register struct soap_attribute *tp, *tq;
; 6154 :   register struct Namespace *ns;
; 6155 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free namespace stack\n"));
; 6156 :   for (np = soap->nlist; np; np = nq)

	mov	eax, DWORD PTR [esi+88]
	push	ebp
	xor	ebp, ebp
	push	edi
	cmp	eax, ebp
	je	SHORT $LN17@soap_free_@3
	npad	5
$LL19@soap_free_@3:

; 6157 :   { nq = np->next;

	mov	edi, DWORD PTR [eax]

; 6158 :     SOAP_FREE(soap, np);

	push	eax
	call	_free
	add	esp, 4
	mov	eax, edi
	cmp	edi, ebp
	jne	SHORT $LL19@soap_free_@3
$LN17@soap_free_@3:
	push	ebx

; 6159 :   }
; 6160 :   soap->nlist = NULL;

	mov	DWORD PTR [esi+88], ebp

; 6161 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free any remaining temp blocks\n"));
; 6162 :   while (soap->blist)

	cmp	DWORD PTR [esi+92], ebp
	je	SHORT $LN15@soap_free_@3
	npad	6
$LL16@soap_free_@3:

; 6163 :     soap_end_block(soap);

	mov	ebx, DWORD PTR [esi+92]
	cmp	ebx, ebp
	je	SHORT $LN25@soap_free_@3
	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, ebp
	je	SHORT $LN22@soap_free_@3
	npad	2
$LL24@soap_free_@3:
	mov	edi, DWORD PTR [eax]
	push	eax
	call	_free
	add	esp, 4
	mov	eax, edi
	cmp	edi, ebp
	jne	SHORT $LL24@soap_free_@3
$LN22@soap_free_@3:
	mov	eax, DWORD PTR [ebx]
	push	ebx
	mov	DWORD PTR [esi+92], eax
	call	_free
	add	esp, 4
$LN25@soap_free_@3:

; 6161 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free any remaining temp blocks\n"));
; 6162 :   while (soap->blist)

	cmp	DWORD PTR [esi+92], ebp
	jne	SHORT $LL16@soap_free_@3
$LN15@soap_free_@3:

; 6164 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free attribute storage\n"));
; 6165 :   for (tp = soap->attributes; tp; tp = tq)

	mov	edi, DWORD PTR [esi+87292]
	cmp	edi, ebp
	je	SHORT $LN12@soap_free_@3
	npad	2
$LL14@soap_free_@3:

; 6166 :   { tq = tp->next;
; 6167 :     if (tp->value)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edi]
	cmp	eax, ebp
	je	SHORT $LN11@soap_free_@3

; 6168 :       SOAP_FREE(soap, tp->value);

	push	eax
	call	_free
	add	esp, 4
$LN11@soap_free_@3:

; 6169 :     SOAP_FREE(soap, tp);

	push	edi
	call	_free
	add	esp, 4
	mov	edi, ebx
	cmp	ebx, ebp
	jne	SHORT $LL14@soap_free_@3
$LN12@soap_free_@3:

; 6170 :   }
; 6171 :   soap->attributes = NULL;
; 6172 : #ifdef WITH_FAST
; 6173 :   if (soap->labbuf)

	mov	eax, DWORD PTR [esi+12456]
	mov	DWORD PTR [esi+87292], ebp
	cmp	eax, ebp
	je	SHORT $LN10@soap_free_@3

; 6174 :     SOAP_FREE(soap, soap->labbuf);

	push	eax
	call	_free
	add	esp, 4
$LN10@soap_free_@3:

; 6175 :   soap->labbuf = NULL;
; 6176 :   soap->lablen = 0;
; 6177 :   soap->labidx = 0;
; 6178 : #endif
; 6179 :   ns = soap->local_namespaces;

	mov	edi, DWORD PTR [esi+84]
	mov	DWORD PTR [esi+12456], ebp
	mov	DWORD PTR [esi+12460], ebp
	mov	DWORD PTR [esi+12464], ebp

; 6180 :   if (ns)

	cmp	edi, ebp
	je	SHORT $LN41@soap_free_@3

; 6181 :   { for (; ns->id; ns++)

	cmp	DWORD PTR [edi], ebp
	je	SHORT $LN6@soap_free_@3
	mov	ebx, OFFSET _soap_padding
	npad	4
$LL8@soap_free_@3:

; 6182 :     { if (ns->out)

	mov	eax, DWORD PTR [edi+12]
	cmp	eax, ebp
	je	SHORT $LN5@soap_free_@3

; 6183 :       { if (soap->encodingStyle == ns->out)

	cmp	DWORD PTR [esi+40], eax
	jne	SHORT $LN4@soap_free_@3

; 6184 :           soap->encodingStyle = SOAP_STR_EOS;

	mov	DWORD PTR [esi+40], ebx
$LN4@soap_free_@3:

; 6185 :         SOAP_FREE(soap, ns->out);

	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	call	_free
	add	esp, 4

; 6186 :         ns->out = NULL;

	mov	DWORD PTR [edi+12], ebp
$LN5@soap_free_@3:

; 6187 :       }
; 6188 :       if (soap->encodingStyle == ns->ns)

	mov	edx, DWORD PTR [esi+40]
	cmp	edx, DWORD PTR [edi+4]
	jne	SHORT $LN7@soap_free_@3

; 6189 :         soap->encodingStyle = SOAP_STR_EOS;

	mov	DWORD PTR [esi+40], ebx
$LN7@soap_free_@3:

; 6181 :   { for (; ns->id; ns++)

	add	edi, 16					; 00000010H
	cmp	DWORD PTR [edi], ebp
	jne	SHORT $LL8@soap_free_@3
$LN6@soap_free_@3:

; 6190 :     }
; 6191 :     SOAP_FREE(soap, soap->local_namespaces);

	mov	eax, DWORD PTR [esi+84]
	push	eax
	call	_free
	add	esp, 4

; 6192 :     soap->local_namespaces = NULL;

	mov	DWORD PTR [esi+84], ebp
$LN41@soap_free_@3:
	pop	ebx

; 6193 :   }
; 6194 : #ifndef WITH_LEANER
; 6195 :   while (soap->xlist)

	cmp	DWORD PTR [esi+90544], ebp
	je	SHORT $LN1@soap_free_@3
	npad	8
$LL2@soap_free_@3:

; 6196 :   { struct soap_xlist *xp = soap->xlist->next;

	mov	eax, DWORD PTR [esi+90544]
	mov	edi, DWORD PTR [eax]

; 6197 :     SOAP_FREE(soap, soap->xlist);

	push	eax
	call	_free
	add	esp, 4

; 6198 :     soap->xlist = xp;

	mov	DWORD PTR [esi+90544], edi
	cmp	edi, ebp
	jne	SHORT $LL2@soap_free_@3
$LN1@soap_free_@3:

; 6199 :   }
; 6200 : #endif
; 6201 : #ifndef WITH_NOIDREF
; 6202 :   soap_free_pht(soap);

	mov	eax, DWORD PTR [esi+12196]
	cmp	eax, ebp
	je	SHORT $LN31@soap_free_@3
$LL33@soap_free_@3:
	mov	edi, DWORD PTR [eax]
	push	eax
	call	_free
	add	esp, 4
	mov	eax, edi
	cmp	edi, ebp
	jne	SHORT $LL33@soap_free_@3
$LN31@soap_free_@3:
	xor	ecx, ecx
	mov	WORD PTR [esi+12200], cx
	xor	eax, eax
	mov	DWORD PTR [esi+12196], ebp
	lea	edi, DWORD PTR [esi+8100]
	mov	ecx, 1024				; 00000400H

; 6203 :   soap_free_iht(soap);

	push	esi
	rep stosd
	call	_soap_free_iht
	add	esp, 4
	pop	edi
	pop	ebp

; 6204 : #endif
; 6205 : }

	ret	0
_soap_free_temp ENDP
_TEXT	ENDS
PUBLIC	_soap_enter
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_soap_enter PROC

; 5385 : { register size_t h;

	push	ebx
	mov	ebx, DWORD PTR _id$[esp]
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+4]

; 5386 :   register struct soap_ilist *ip;
; 5387 :   ip = (struct soap_ilist*)SOAP_MALLOC(soap, sizeof(struct soap_ilist) + strlen(id));

	mov	eax, ebx
	push	edi
	lea	edx, DWORD PTR [eax+1]
$LL6@soap_enter:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL6@soap_enter
	sub	eax, edx
	add	eax, 36					; 00000024H
	push	eax
	call	_malloc
	mov	edi, eax
	add	esp, 4

; 5388 :   if (ip)

	test	edi, edi
	je	SHORT $LN1@soap_enter
	push	esi

; 5389 :   { h = soap_hash(id);

	mov	edx, ebx
	call	_soap_hash

; 5390 :     strcpy(ip->id, id);

	lea	esi, DWORD PTR [edi+32]
	mov	ecx, ebx
	sub	esi, ebx
	npad	6
$LL4@soap_enter:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [esi+ecx], dl
	inc	ecx
	test	dl, dl
	jne	SHORT $LL4@soap_enter

; 5391 :     ip->next = soap->iht[h];

	mov	ecx, DWORD PTR [ebp+eax*4+104]
	mov	DWORD PTR [edi], ecx

; 5392 :     soap->iht[h] = ip;

	mov	DWORD PTR [ebp+eax*4+104], edi
	pop	esi

; 5393 :     return ip;

	mov	eax, edi
	pop	edi
	pop	ebp
	pop	ebx

; 5396 : }

	ret	0
$LN1@soap_enter:
	pop	edi
	pop	ebp

; 5394 :   }
; 5395 :   return NULL;

	xor	eax, eax
	pop	ebx

; 5396 : }

	ret	0
_soap_enter ENDP
_TEXT	ENDS
PUBLIC	_soap_lookup
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_lookup PROC
; _id$ = esi

; 5369 : { register struct soap_ilist *ip = NULL;

	push	ebx

; 5370 :   for (ip = soap->iht[soap_hash(id)]; ip; ip = ip->next)

	mov	edx, esi
	call	_soap_hash
	mov	ecx, DWORD PTR _soap$[esp]
	mov	eax, DWORD PTR [ecx+eax*4+104]
	test	eax, eax
	je	SHORT $LN2@soap_looku@2
$LL4@soap_looku@2:

; 5371 :     if (!strcmp(ip->id, id))

	mov	edx, esi
	lea	ecx, DWORD PTR [eax+32]
	npad	7
$LL10@soap_looku@2:
	mov	bl, BYTE PTR [ecx]
	cmp	bl, BYTE PTR [edx]
	jne	SHORT $LN11@soap_looku@2
	test	bl, bl
	je	SHORT $LN12@soap_looku@2
	mov	bl, BYTE PTR [ecx+1]
	cmp	bl, BYTE PTR [edx+1]
	jne	SHORT $LN11@soap_looku@2
	add	ecx, 2
	add	edx, 2
	test	bl, bl
	jne	SHORT $LL10@soap_looku@2
$LN12@soap_looku@2:
	xor	ecx, ecx
	jmp	SHORT $LN13@soap_looku@2
$LN11@soap_looku@2:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN13@soap_looku@2:
	test	ecx, ecx
	je	SHORT $LN5@soap_looku@2
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL4@soap_looku@2
$LN2@soap_looku@2:

; 5372 :       return ip;
; 5373 :   return NULL;

	xor	eax, eax
$LN5@soap_looku@2:
	pop	ebx

; 5374 : }

	ret	0
_soap_lookup ENDP
_TEXT	ENDS
PUBLIC	_soap_embedded_id
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_soap_embedded_id PROC
; _p$ = ecx
; _t$ = eax

; 5156 : { struct soap_plist *pp = NULL;

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _id$[esp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+12]

; 5157 :   if (soap->mode & SOAP_XML_TREE)

	mov	ebx, DWORD PTR [edi+8]
	mov	esi, eax
	mov	DWORD PTR _pp$[esp+12], 0
	test	ebx, 32768				; 00008000H

; 5158 :     return id;

	jne	$LN1@soap_embed@2

; 5159 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Embedded_id %p type=%d id=%d\n", p, t, id));
; 5160 :   if (soap->version == 1 && soap->encodingStyle && !(soap->mode & SOAP_XML_GRAPH) && soap->part != SOAP_IN_HEADER)

	cmp	WORD PTR [edi+6], 1
	jne	SHORT $LN11@soap_embed@2
	cmp	DWORD PTR [edi+40], 0
	je	SHORT $LN11@soap_embed@2
	test	ebx, 65536				; 00010000H
	jne	SHORT $LN11@soap_embed@2
	cmp	WORD PTR [edi+87304], 3
	je	SHORT $LN11@soap_embed@2

; 5161 :   { if (id < 0)

	test	ebp, ebp
	jge	SHORT $LN1@soap_embed@2

; 5162 :     { id = soap_pointer_lookup(soap, p, t, &pp);

	lea	edx, DWORD PTR _pp$[esp+12]
	call	_soap_pointer_lookup

; 5163 :       if (id)

	test	eax, eax
	je	SHORT $LN7@soap_embed@2

; 5164 :       { if (soap->mode & SOAP_IO_LENGTH)

	test	bl, 8
	je	SHORT $LN8@soap_embed@2

; 5165 :           pp->mark1 = 2;

	mov	eax, DWORD PTR _pp$[esp+12]
	pop	edi
	pop	esi
	pop	ebp
	mov	BYTE PTR [eax+20], 2

; 5168 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Embedded_id multiref id=%d %p type=%d = (%d %d)\n", id, p, t, (int)pp->mark1, (int)pp->mark2));
; 5169 :       }
; 5170 :       return -1;

	or	eax, -1
	pop	ebx

; 5186 : }

	ret	0
$LN8@soap_embed@2:

; 5166 :         else
; 5167 :           pp->mark2 = 2;

	mov	ecx, DWORD PTR _pp$[esp+12]
	mov	BYTE PTR [ecx+21], 2
$LN7@soap_embed@2:
	pop	edi
	pop	esi
	pop	ebp

; 5168 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Embedded_id multiref id=%d %p type=%d = (%d %d)\n", id, p, t, (int)pp->mark1, (int)pp->mark2));
; 5169 :       }
; 5170 :       return -1;

	or	eax, -1
	pop	ebx

; 5186 : }

	ret	0
$LN11@soap_embed@2:

; 5171 :     }
; 5172 :     return id;
; 5173 :   }
; 5174 :   if (id < 0)

	test	ebp, ebp
	jge	SHORT $LN15@soap_embed@2

; 5175 :     id = soap_pointer_lookup(soap, p, t, &pp);

	lea	edx, DWORD PTR _pp$[esp+12]
	call	_soap_pointer_lookup
	mov	ebp, eax
$LN4@soap_embed@2:

; 5177 :     return 0;
; 5178 :   if (id && pp)

	test	ebp, ebp
	je	SHORT $LN1@soap_embed@2
	mov	eax, DWORD PTR _pp$[esp+12]
	test	eax, eax
	je	SHORT $LN1@soap_embed@2

; 5179 :   { if (soap->mode & SOAP_IO_LENGTH)

	test	bl, 8
	je	SHORT $LN2@soap_embed@2
	pop	edi
	pop	esi

; 5180 :       pp->mark1 = 1;

	mov	BYTE PTR [eax+20], 1

; 5183 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Embedded_id embedded ref id=%d %p type=%d = (%d %d)\n", id, p, t, (int)pp->mark1, (int)pp->mark2));
; 5184 :   }
; 5185 :   return id;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 5186 : }

	ret	0
$LN15@soap_embed@2:

; 5176 :   else if (id && !soap_pointer_lookup(soap, p, t, &pp))

	je	SHORT $LN1@soap_embed@2
	lea	edx, DWORD PTR _pp$[esp+12]
	call	_soap_pointer_lookup
	test	eax, eax
	jne	SHORT $LN4@soap_embed@2
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 5186 : }

	ret	0
$LN2@soap_embed@2:

; 5181 :     else
; 5182 :       pp->mark2 = 1;

	mov	BYTE PTR [eax+21], 1
$LN1@soap_embed@2:
	pop	edi
	pop	esi

; 5183 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Embedded_id embedded ref id=%d %p type=%d = (%d %d)\n", id, p, t, (int)pp->mark1, (int)pp->mark2));
; 5184 :   }
; 5185 :   return id;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 5186 : }

	ret	0
_soap_embedded_id ENDP
_TEXT	ENDS
PUBLIC	_soap_array_reference
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_pp$ = -4						; size = 4
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_t$ = 16						; size = 4
_soap_array_reference PROC
; _a$ = eax
; _n$ = ecx

; 5126 : { register int i;

	push	ecx

; 5127 :   struct soap_plist *pp;
; 5128 :   if (!p || !a->__ptr)

	cmp	DWORD PTR _p$[esp], 0
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR _t$[esp+8]
	push	edi
	mov	edi, eax
	je	SHORT $LN6@soap_array@2
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN6@soap_array@2
	push	esi

; 5130 :   i = soap_array_pointer_lookup(soap, p, a, n, t, &pp);

	lea	eax, DWORD PTR _pp$[esp+20]
	push	eax
	push	ebp
	push	edi
	mov	esi, ecx
	mov	edx, ebx
	mov	DWORD PTR _pp$[esp+32], 0
	call	_soap_array_pointer_lookup
	add	esp, 12					; 0000000cH

; 5131 :   if (i)

	test	eax, eax
	je	SHORT $LN5@soap_array@2

; 5132 :   { if (pp->mark1 == 0)

	mov	ecx, DWORD PTR _pp$[esp+20]
	cmp	BYTE PTR [ecx+20], 0
	lea	eax, DWORD PTR [ecx+20]
	jne	SHORT $LN1@soap_array@2
	pop	esi
	pop	edi

; 5133 :     { pp->mark1 = 2;

	mov	BYTE PTR [eax], 2
	pop	ebp

; 5134 :       pp->mark2 = 2;

	mov	BYTE PTR [ecx+21], 2

; 5142 :   }
; 5143 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Array reference %p ptr=%p dim=%d type=%d (%d %d)\n", p, a->__ptr, n, t, (int)pp->mark1, (int)pp->mark2));
; 5144 :   return pp->mark1;

	movsx	eax, BYTE PTR [eax]
	pop	ebx

; 5145 : }

	pop	ecx
	ret	0
$LN5@soap_array@2:

; 5135 :     }
; 5136 :   }
; 5137 :   else if (!soap_pointer_enter(soap, p, a, n, t, &pp))

	mov	edx, DWORD PTR _p$[esp+16]
	lea	ecx, DWORD PTR _pp$[esp+20]
	push	ecx
	push	ebp
	push	edx
	mov	esi, ebx
	call	_soap_pointer_enter
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@soap_array@2
	pop	esi
	pop	edi
	pop	ebp

; 5138 :     return 1;

	mov	eax, 1
	pop	ebx

; 5145 : }

	pop	ecx
	ret	0
$LN2@soap_array@2:

; 5139 :   else
; 5140 :   { pp->mark1 = 0;

	mov	ecx, DWORD PTR _pp$[esp+20]
	lea	eax, DWORD PTR [ecx+20]
	mov	BYTE PTR [eax], 0

; 5141 :     pp->mark2 = 0;

	mov	BYTE PTR [ecx+21], 0
$LN1@soap_array@2:

; 5142 :   }
; 5143 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Array reference %p ptr=%p dim=%d type=%d (%d %d)\n", p, a->__ptr, n, t, (int)pp->mark1, (int)pp->mark2));
; 5144 :   return pp->mark1;

	movsx	eax, BYTE PTR [eax]
	pop	esi
	pop	edi
	pop	ebp
	pop	ebx

; 5145 : }

	pop	ecx
	ret	0
$LN6@soap_array@2:
	pop	edi
	pop	ebp

; 5129 :     return 1;

	mov	eax, 1
	pop	ebx

; 5145 : }

	pop	ecx
	ret	0
_soap_array_reference ENDP
_TEXT	ENDS
PUBLIC	_soap_reference
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_pp$ = -4						; size = 4
_soap$ = 8						; size = 4
_soap_reference PROC
; _p$ = ecx
; _t$ = eax

; 5098 : { struct soap_plist *pp;

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp+4]
	push	esi
	mov	esi, eax

; 5099 :   if (!p || (soap->mode & SOAP_XML_TREE))

	test	ecx, ecx
	je	SHORT $LN6@soap_refer
	test	DWORD PTR [ebx+8], 32768		; 00008000H
	jne	SHORT $LN6@soap_refer
	push	edi

; 5101 :   if (soap_pointer_lookup(soap, p, t, &pp))

	lea	edx, DWORD PTR _pp$[esp+16]
	mov	edi, ebx
	call	_soap_pointer_lookup
	test	eax, eax
	je	SHORT $LN5@soap_refer

; 5102 :   { if (pp->mark1 == 0)

	mov	ecx, DWORD PTR _pp$[esp+16]
	cmp	BYTE PTR [ecx+20], 0
	lea	eax, DWORD PTR [ecx+20]
	jne	SHORT $LN1@soap_refer
	pop	edi

; 5103 :     { pp->mark1 = 2;

	mov	BYTE PTR [eax], 2
	pop	esi

; 5104 :       pp->mark2 = 2;

	mov	BYTE PTR [ecx+21], 2

; 5113 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Reference %p type=%d (%d %d)\n", p, t, (int)pp->mark1, (int)pp->mark2));
; 5114 :   return pp->mark1;

	movsx	eax, BYTE PTR [eax]
	pop	ebx

; 5115 : }

	pop	ecx
	ret	0
$LN5@soap_refer:

; 5105 :     }
; 5106 :   }
; 5107 :   else if (soap_pointer_enter(soap, p, NULL, 0, t, &pp))

	lea	eax, DWORD PTR _pp$[esp+16]
	push	eax
	push	esi
	push	ecx
	xor	edi, edi
	mov	esi, ebx
	call	_soap_pointer_enter
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_refer

; 5108 :   { pp->mark1 = 0;

	mov	ecx, DWORD PTR _pp$[esp+16]
	lea	eax, DWORD PTR [ecx+20]
	mov	BYTE PTR [eax], 0

; 5109 :     pp->mark2 = 0;

	mov	BYTE PTR [ecx+21], 0
$LN1@soap_refer:

; 5113 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Reference %p type=%d (%d %d)\n", p, t, (int)pp->mark1, (int)pp->mark2));
; 5114 :   return pp->mark1;

	movsx	eax, BYTE PTR [eax]
	pop	edi
	pop	esi
	pop	ebx

; 5115 : }

	pop	ecx
	ret	0
$LN2@soap_refer:
	pop	edi
	pop	esi

; 5110 :   }
; 5111 :   else
; 5112 :     return 1;

	mov	eax, 1
	pop	ebx

; 5115 : }

	pop	ecx
	ret	0
$LN6@soap_refer:
	pop	esi

; 5100 :     return 1;

	mov	eax, 1
	pop	ebx

; 5115 : }

	pop	ecx
	ret	0
_soap_reference ENDP
_TEXT	ENDS
PUBLIC	_soap_embedded
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_embedded PROC
; _soap$ = edx
; _p$ = ecx

; 5082 :   if (soap_pointer_lookup(soap, p, t, &pp))

	test	ecx, ecx
	je	SHORT $LN1@soap_embed@3
	mov	eax, ecx
	shr	eax, 3
	and	eax, 1023				; 000003ffH
	mov	eax, DWORD PTR [edx+eax*4+8100]
	test	eax, eax
	je	SHORT $LN1@soap_embed@3
	mov	edx, 18					; 00000012H
	npad	2
$LL7@soap_embed@3:
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN6@soap_embed@3
	cmp	DWORD PTR [eax+12], edx
	je	SHORT $LN12@soap_embed@3
$LN6@soap_embed@3:
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL7@soap_embed@3

; 5085 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Embedded %p type=%d mark set to 1\n", p, t));
; 5086 :   }
; 5087 : }

	ret	0
$LN12@soap_embed@3:

; 5082 :   if (soap_pointer_lookup(soap, p, t, &pp))

	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN1@soap_embed@3

; 5083 :   { pp->mark1 = 1;

	mov	cl, 1
	mov	BYTE PTR [eax+20], cl

; 5084 :     pp->mark2 = 1;

	mov	BYTE PTR [eax+21], cl
$LN1@soap_embed@3:

; 5085 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Embedded %p type=%d mark set to 1\n", p, t));
; 5086 :   }
; 5087 : }

	ret	0
_soap_embedded ENDP
_TEXT	ENDS
PUBLIC	_soap_begin_send
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_begin_send PROC
; _soap$ = esi

; 4973 :   soap->error = SOAP_OK;
; 4974 :   soap->mode = soap->omode | (soap->mode & (SOAP_IO_LENGTH | SOAP_ENC_DIME));

	mov	eax, DWORD PTR [esi+8]
	and	eax, 136				; 00000088H
	or	eax, DWORD PTR [esi+16]
	push	edi
	xor	edi, edi
	mov	DWORD PTR [esi+90460], edi
	mov	DWORD PTR [esi+8], eax

; 4975 : #ifdef WITH_ZLIB
; 4976 :   if ((soap->mode & SOAP_ENC_ZLIB) && (soap->mode & SOAP_IO) == SOAP_IO_FLUSH)
; 4977 :   { if (soap->mode & SOAP_ENC_XML)
; 4978 :       soap->mode |= SOAP_IO_BUFFER;
; 4979 :     else
; 4980 :       soap->mode |= SOAP_IO_STORE;
; 4981 :   }
; 4982 : #endif
; 4983 : #ifndef WITH_LEAN
; 4984 :   if ((soap->mode & SOAP_IO_UDP))

	test	al, 4
	je	SHORT $LN14@soap_begin

; 4985 :   { soap->mode |= SOAP_ENC_XML;

	or	eax, 64					; 00000040H

; 4986 :     if (soap->count > SOAP_BUFLEN)

	cmp	DWORD PTR [esi+12448], 65536		; 00010000H
	mov	DWORD PTR [esi+8], eax
	jbe	SHORT $LN14@soap_begin

; 4987 :       return soap->error = SOAP_UDP_ERROR;

	mov	eax, 27					; 0000001bH
	mov	DWORD PTR [esi+90460], eax
	pop	edi

; 5071 : }

	ret	0
$LN14@soap_begin:

; 4988 :   }
; 4989 : #endif
; 4990 :   if ((soap->mode & SOAP_IO) == SOAP_IO_FLUSH && soap_valid_socket(soap->socket))

	mov	eax, DWORD PTR [esi+8]
	test	al, 3
	jne	SHORT $LN10@soap_begin
	cmp	DWORD PTR [esi+12408], -1
	je	SHORT $LN10@soap_begin

; 4991 :   { if (soap->count || (soap->mode & SOAP_IO_LENGTH) || (soap->mode & SOAP_ENC_XML))

	cmp	DWORD PTR [esi+12448], edi
	jne	SHORT $LN11@soap_begin
	test	al, 72					; 00000048H
	jne	SHORT $LN11@soap_begin

; 4993 :     else
; 4994 :       soap->mode |= SOAP_IO_STORE;

	or	eax, 2
	jmp	SHORT $LN21@soap_begin
$LN11@soap_begin:

; 4992 :       soap->mode |= SOAP_IO_BUFFER;

	or	eax, 1
$LN21@soap_begin:
	mov	DWORD PTR [esi+8], eax
$LN10@soap_begin:

; 4995 :   }
; 4996 :   soap->mode &= ~SOAP_IO_LENGTH;

	and	DWORD PTR [esi+8], -9			; fffffff7H

; 4997 :   if ((soap->mode & SOAP_IO) == SOAP_IO_STORE)

	mov	eax, DWORD PTR [esi+8]
	and	al, 3
	cmp	al, 2
	jne	SHORT $LN19@soap_begin

; 4998 :     soap_new_block(soap);

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN19@soap_begin
	mov	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [esi+92], eax
$LN19@soap_begin:

; 4999 :   if (!(soap->mode & SOAP_IO_KEEPALIVE))

	mov	eax, DWORD PTR [esi+8]
	test	al, 16					; 00000010H
	jne	SHORT $LN8@soap_begin

; 5000 :     soap->keep_alive = 0;

	xor	edx, edx
	mov	WORD PTR [esi+90412], dx
$LN8@soap_begin:

; 5001 :   if (!soap->encodingStyle && !(soap->mode & SOAP_XML_GRAPH))

	cmp	DWORD PTR [esi+40], edi
	jne	SHORT $LN7@soap_begin
	test	eax, 65536				; 00010000H
	jne	SHORT $LN7@soap_begin

; 5002 :     soap->mode |= SOAP_XML_TREE;

	or	eax, 32768				; 00008000H
	mov	DWORD PTR [esi+8], eax
$LN7@soap_begin:

; 5003 : #ifndef WITH_LEANER
; 5004 :   if ((soap->mode & SOAP_ENC_MTOM) && (soap->mode & SOAP_ENC_DIME))

	mov	eax, DWORD PTR [esi+8]
	test	eax, 512				; 00000200H
	je	SHORT $LN6@soap_begin
	test	al, al
	jns	SHORT $LN6@soap_begin

; 5005 :   { soap->mode |= SOAP_ENC_MIME;
; 5006 :     soap->mode &= ~SOAP_ENC_DIME;

	and	eax, -129				; ffffff7fH
	or	eax, 256				; 00000100H

; 5007 :   }
; 5008 :   else

	jmp	SHORT $LN22@soap_begin
$LN6@soap_begin:

; 5009 :     soap->mode &= ~SOAP_ENC_MTOM;

	and	eax, -513				; fffffdffH
$LN22@soap_begin:
	mov	DWORD PTR [esi+8], eax

; 5010 :   if (soap->mode & SOAP_ENC_MIME)

	test	eax, 256				; 00000100H
	je	SHORT $LN4@soap_begin

; 5011 :     soap_select_mime_boundary(soap);

	mov	eax, esi
	call	_soap_select_mime_boundary
$LN4@soap_begin:

; 5012 : #ifdef WIN32
; 5013 : #ifndef UNDER_CE
; 5014 : #ifndef WITH_FASTCGI
; 5015 :   if (!soap_valid_socket(soap->socket)) /* Set win32 stdout or soap->sendfd to BINARY, e.g. to support DIME */

	cmp	DWORD PTR [esi+12408], -1
	jne	SHORT $LN3@soap_begin

; 5016 : #ifdef __BORLANDC__
; 5017 :     setmode(soap->sendfd, O_BINARY);
; 5018 : #else
; 5019 :     _setmode(soap->sendfd, _O_BINARY);

	mov	eax, DWORD PTR [esi+12420]
	push	32768					; 00008000H
	push	eax
	call	__setmode
	add	esp, 8
$LN3@soap_begin:

; 5020 : #endif
; 5021 : #endif
; 5022 : #endif
; 5023 : #endif
; 5024 : #endif
; 5025 :   if (soap->mode & SOAP_IO)

	test	BYTE PTR [esi+8], 3
	je	SHORT $LN2@soap_begin

; 5026 :   { soap->bufidx = 0;

	mov	DWORD PTR [esi+12428], edi

; 5027 :     soap->buflen = 0;

	mov	DWORD PTR [esi+12432], edi
$LN2@soap_begin:

; 5028 :   }
; 5029 :   soap->chunksize = 0;
; 5030 :   soap->ns = 0;
; 5031 :   soap->null = 0;
; 5032 :   soap->position = 0;

	xor	eax, eax
	xor	ecx, ecx
	xor	edx, edx
	mov	WORD PTR [esi+87222], ax

; 5033 :   soap->mustUnderstand = 0;
; 5034 :   soap->encoding = 0;
; 5035 :   soap->idnum = 0;
; 5036 :   soap->level = 0;
; 5037 :   soap_clr_attr(soap);

	mov	eax, esi
	mov	DWORD PTR [esi+87312], edi
	mov	WORD PTR [esi+87302], cx
	mov	WORD PTR [esi+87300], dx
	mov	WORD PTR [esi+87298], cx
	mov	WORD PTR [esi+87296], dx
	mov	DWORD PTR [esi+12212], edi
	mov	DWORD PTR [esi+12444], edi
	call	_soap_clr_attr

; 5038 :   soap_set_local_namespaces(soap);

	push	esi
	call	_soap_set_local_namespaces

; 5039 : #ifdef WITH_ZLIB
; 5040 :   soap->z_ratio_out = 1.0;
; 5041 :   if ((soap->mode & SOAP_ENC_ZLIB) && soap->zlib_state != SOAP_ZLIB_DEFLATE)
; 5042 :   { if (!soap->z_buf)
; 5043 :       soap->z_buf = (char*)SOAP_MALLOC(soap, SOAP_BUFLEN);
; 5044 :     soap->d_stream->next_out = (Byte*)soap->z_buf;
; 5045 :     soap->d_stream->avail_out = SOAP_BUFLEN;
; 5046 : #ifdef WITH_GZIP
; 5047 :     if (soap->zlib_out != SOAP_ZLIB_DEFLATE)
; 5048 :     { memcpy(soap->z_buf, "\37\213\10\0\0\0\0\0\0\377", 10);
; 5049 :       soap->d_stream->next_out = (Byte*)soap->z_buf + 10;
; 5050 :       soap->d_stream->avail_out = SOAP_BUFLEN - 10;
; 5051 :       soap->z_crc = crc32(0L, NULL, 0);
; 5052 :       soap->zlib_out = SOAP_ZLIB_GZIP;
; 5053 :       if (deflateInit2(soap->d_stream, soap->z_level, Z_DEFLATED, -MAX_WBITS, 8, Z_DEFAULT_STRATEGY) != Z_OK)
; 5054 :         return soap->error = SOAP_ZLIB_ERROR;
; 5055 :     }
; 5056 :     else
; 5057 : #endif
; 5058 :     if (deflateInit(soap->d_stream, soap->z_level) != Z_OK)
; 5059 :       return soap->error = SOAP_ZLIB_ERROR;
; 5060 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Deflate initialized\n"));
; 5061 :     soap->zlib_state = SOAP_ZLIB_DEFLATE;
; 5062 :   }
; 5063 : #endif
; 5064 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Begin send phase (socket=%d mode=0x%x count=%lu)\n", soap->socket, soap->mode, (unsigned long)soap->count));
; 5065 :   soap->part = SOAP_BEGIN;

	xor	eax, eax
	mov	WORD PTR [esi+87304], ax

; 5066 : #ifndef WITH_LEANER
; 5067 :   if (soap->fprepareinit && (soap->mode & SOAP_IO) == SOAP_IO_STORE)

	mov	eax, DWORD PTR [esi+12340]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN1@soap_begin
	mov	ecx, DWORD PTR [esi+8]
	and	cl, 3
	cmp	cl, 2
	jne	SHORT $LN1@soap_begin

; 5068 :     soap->fprepareinit(soap);

	push	esi
	call	eax
	add	esp, 4
$LN1@soap_begin:

; 5069 : #endif
; 5070 :   return SOAP_OK;

	xor	eax, eax
	pop	edi

; 5071 : }

	ret	0
_soap_begin_send ENDP
_TEXT	ENDS
PUBLIC	_soap_begin_count
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_begin_count PROC
; _soap$ = esi

; 4891 : {

	push	edi

; 4892 : #ifndef WITH_LEANER
; 4893 :   if ((soap->mode & SOAP_ENC_DIME) || (soap->omode & SOAP_ENC_DIME))

	xor	edi, edi
	test	BYTE PTR [esi+8], -128			; ffffff80H
	jne	SHORT $LN11@soap_begin@2
	mov	eax, DWORD PTR [esi+16]
	test	al, al
	js	SHORT $LN11@soap_begin@2

; 4895 :   else
; 4896 : #endif
; 4897 :   { soap->mode = soap->omode;
; 4898 :     if ((soap->mode & SOAP_IO) == SOAP_IO_STORE
; 4899 :      || (((soap->mode & SOAP_IO) == SOAP_IO_CHUNK || (soap->mode & SOAP_ENC_XML))
; 4900 : #ifndef WITH_LEANER
; 4901 :       && !soap->fpreparesend
; 4902 : #endif
; 4903 :      ))

	mov	ecx, eax
	and	ecx, 3
	mov	DWORD PTR [esi+8], eax
	cmp	ecx, 2
	je	SHORT $LN8@soap_begin@2
	cmp	ecx, 3
	je	SHORT $LN7@soap_begin@2
	test	al, 64					; 00000040H
	je	SHORT $LN9@soap_begin@2
$LN7@soap_begin@2:
	cmp	DWORD PTR [esi+12344], edi
	je	SHORT $LN8@soap_begin@2
$LN9@soap_begin@2:

; 4906 :       soap->mode |= SOAP_IO_LENGTH;

	or	eax, 8
	jmp	SHORT $LN15@soap_begin@2
$LN8@soap_begin@2:

; 4904 :       soap->mode &= ~SOAP_IO_LENGTH;

	and	eax, -9					; fffffff7H

; 4905 :     else

	jmp	SHORT $LN15@soap_begin@2
$LN11@soap_begin@2:

; 4894 :     soap->mode = soap->omode | SOAP_IO_LENGTH | SOAP_ENC_DIME;

	mov	eax, DWORD PTR [esi+16]
	or	eax, 136				; 00000088H
$LN15@soap_begin@2:
	mov	DWORD PTR [esi+8], eax

; 4907 :   }
; 4908 : #ifdef WITH_ZLIB
; 4909 :   if ((soap->mode & SOAP_ENC_ZLIB) && (soap->mode & SOAP_IO) == SOAP_IO_FLUSH)
; 4910 :   { if (!(soap->mode & SOAP_ENC_DIME))
; 4911 :       soap->mode &= ~SOAP_IO_LENGTH;
; 4912 :     if (soap->mode & SOAP_ENC_XML)
; 4913 :       soap->mode |= SOAP_IO_BUFFER;
; 4914 :     else
; 4915 :       soap->mode |= SOAP_IO_STORE;
; 4916 :   }
; 4917 : #endif
; 4918 :   if (!soap->encodingStyle && !(soap->mode & SOAP_XML_GRAPH))

	cmp	DWORD PTR [esi+40], edi
	jne	SHORT $LN5@soap_begin@2
	test	eax, 65536				; 00010000H
	jne	SHORT $LN5@soap_begin@2

; 4919 :     soap->mode |= SOAP_XML_TREE;

	or	eax, 32768				; 00008000H
	mov	DWORD PTR [esi+8], eax
$LN5@soap_begin@2:

; 4920 : #ifndef WITH_LEANER
; 4921 :   if ((soap->mode & SOAP_ENC_MTOM) && (soap->mode & SOAP_ENC_DIME))

	mov	eax, DWORD PTR [esi+8]
	test	eax, 512				; 00000200H
	je	SHORT $LN4@soap_begin@2
	test	al, al
	jns	SHORT $LN4@soap_begin@2

; 4922 :     soap->mode |= SOAP_ENC_MIME;

	or	eax, 256				; 00000100H

; 4923 :   else

	jmp	SHORT $LN16@soap_begin@2
$LN4@soap_begin@2:

; 4924 :     soap->mode &= ~SOAP_ENC_MTOM;

	and	eax, -513				; fffffdffH
$LN16@soap_begin@2:
	mov	DWORD PTR [esi+8], eax

; 4925 :   if (soap->mode & SOAP_ENC_MIME)

	test	eax, 256				; 00000100H
	je	SHORT $LN2@soap_begin@2

; 4926 :     soap_select_mime_boundary(soap);

	mov	eax, esi
	call	_soap_select_mime_boundary
$LN2@soap_begin@2:

; 4927 :   soap->dime.list = soap->dime.last;	/* keep track of last DIME attachment */

	mov	ecx, DWORD PTR [esi+90520]

; 4928 : #endif
; 4929 :   soap->count = 0;
; 4930 :   soap->ns = 0;
; 4931 :   soap->null = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+90512], ecx
	xor	edx, edx

; 4932 :   soap->position = 0;

	xor	ecx, ecx
	mov	WORD PTR [esi+87300], ax

; 4933 :   soap->mustUnderstand = 0;
; 4934 :   soap->encoding = 0;

	mov	WORD PTR [esi+87296], ax

; 4935 :   soap->part = SOAP_BEGIN;
; 4936 :   soap->idnum = 0;
; 4937 :   soap_clr_attr(soap);

	mov	eax, esi
	mov	DWORD PTR [esi+12448], edi
	mov	WORD PTR [esi+87302], dx
	mov	WORD PTR [esi+87222], cx
	mov	WORD PTR [esi+87298], dx
	mov	WORD PTR [esi+87304], cx
	mov	DWORD PTR [esi+12212], edi
	call	_soap_clr_attr

; 4938 :   soap_set_local_namespaces(soap);

	push	esi
	call	_soap_set_local_namespaces

; 4939 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Begin count phase (socket=%d mode=0x%x count=%lu)\n", soap->socket, soap->mode, (unsigned long)soap->count));
; 4940 : #ifndef WITH_LEANER
; 4941 :   soap->dime.count = 0; /* count # of attachments */
; 4942 :   soap->dime.size = 0; /* accumulate total size of attachments */
; 4943 :   if (soap->fprepareinit && (soap->mode & SOAP_IO) != SOAP_IO_STORE)

	mov	eax, DWORD PTR [esi+12340]
	add	esp, 4
	mov	DWORD PTR [esi+90476], edi
	mov	DWORD PTR [esi+90480], edi
	cmp	eax, edi
	pop	edi
	je	SHORT $LN1@soap_begin@2
	mov	edx, DWORD PTR [esi+8]
	and	dl, 3
	cmp	dl, 2
	je	SHORT $LN1@soap_begin@2

; 4944 :     return soap->error = soap->fprepareinit(soap);

	push	esi
	call	eax
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax

; 4947 : }

	ret	0
$LN1@soap_begin@2:

; 4945 : #endif
; 4946 :   return SOAP_OK;

	xor	eax, eax

; 4947 : }

	ret	0
_soap_begin_count ENDP
; Function compile flags: /Ogtpy
_http_error PROC
; _status$ = ecx

; 3471 : #ifndef WITH_LEAN
; 3472 :   msg = soap_code_str(h_http_error_codes, status);

	mov	eax, OFFSET _h_http_error_codes
	cmp	ecx, 200				; 000000c8H
	je	SHORT $LN4@http_error
	npad	3
$LL5@http_error:
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@http_error
	add	eax, 8
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LL5@http_error
$LN4@http_error:
	mov	eax, DWORD PTR [eax+4]

; 3473 :   if (!msg)

	test	eax, eax
	jne	SHORT $LN1@http_error

; 3474 :     msg = SOAP_STR_EOS;

	mov	eax, OFFSET _soap_padding
$LN1@http_error:

; 3475 : #endif
; 3476 :   return msg;
; 3477 : }

	ret	0
_http_error ENDP
; Function compile flags: /Ogtpy
_tcp_error PROC
; _soap$ = eax

; 3442 :   switch (soap->errmode)

	mov	ecx, DWORD PTR [eax+90464]
	xor	edx, edx
	sub	ecx, edx
	je	SHORT $LN4@tcp_error
	sub	ecx, 1
	je	SHORT $LN3@tcp_error
	sub	ecx, 1
	jne	SHORT $LN16@tcp_error

; 3448 :       break;
; 3449 :     case 2:
; 3450 :     {
; 3451 : #ifndef WITH_LEAN
; 3452 :       msg = soap_code_str(h_error_codes, soap->errnum);

	mov	edx, DWORD PTR [eax+90468]
	mov	ecx, OFFSET _h_error_codes
	cmp	edx, 11001				; 00002af9H
	je	SHORT $LN9@tcp_error
	npad	7
$LL10@tcp_error:
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN9@tcp_error
	add	ecx, 8
	cmp	DWORD PTR [ecx], edx
	jne	SHORT $LL10@tcp_error
$LN9@tcp_error:
	mov	ecx, DWORD PTR [ecx+4]

; 3453 :       if (!msg)

	test	ecx, ecx
	jne	SHORT $LN17@tcp_error
	push	esi

; 3454 : #endif
; 3455 :       { sprintf(soap->msgbuf, "TCP/UDP IP error %d", soap->errnum);

	push	edx
	lea	esi, DWORD PTR [eax+78004]
	push	OFFSET ??_C@_0BE@GDJAADON@TCP?1UDP?5IP?5error?5?$CFd?$AA@
	push	esi
	call	_sprintf
	add	esp, 12					; 0000000cH

; 3456 :         msg = soap->msgbuf;
; 3457 :       }
; 3458 :     }
; 3459 :   }
; 3460 :   return msg;

	mov	eax, esi
	pop	esi

; 3461 : }

	ret	0
$LN3@tcp_error:

; 3445 :       break;
; 3446 :     case 1:
; 3447 :       msg = "WSAStartup failed";

	mov	eax, OFFSET ??_C@_0BC@NFJDOJIM@WSAStartup?5failed?$AA@

; 3461 : }

	ret	0
$LN4@tcp_error:

; 3443 :   { case 0:
; 3444 :       msg = soap_strerror(soap);

	jmp	_soap_strerror
$LN16@tcp_error:

; 3456 :         msg = soap->msgbuf;
; 3457 :       }
; 3458 :     }
; 3459 :   }
; 3460 :   return msg;

	mov	eax, edx

; 3461 : }

	ret	0
$LN17@tcp_error:

; 3456 :         msg = soap->msgbuf;
; 3457 :       }
; 3458 :     }
; 3459 :   }
; 3460 :   return msg;

	mov	eax, ecx

; 3461 : }

	ret	0
_tcp_error ENDP
_TEXT	ENDS
PUBLIC	_soap_match_tag
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag1$ = 12						; size = 4
_soap_match_tag PROC
; _tag2$ = edi

; 2857 : { register const char *s, *t;

	push	ebp
	mov	ebp, DWORD PTR _tag1$[esp]

; 2858 :   register int err;
; 2859 :   if (!tag1 || !tag2 || !*tag2)

	test	ebp, ebp
	je	$LN15@soap_match@3
	test	edi, edi
	je	$LN15@soap_match@3
	cmp	BYTE PTR [edi], 0
	je	$LN15@soap_match@3
	push	ebx

; 2861 :   s = strchr(tag1, ':');

	push	58					; 0000003aH
	push	ebp
	call	_strchr

; 2862 :   t = strchr(tag2, ':');

	push	58					; 0000003aH
	push	edi
	mov	ebx, eax
	call	_strchr
	add	esp, 16					; 00000010H

; 2863 :   if (t)

	test	eax, eax
	je	$LN14@soap_match@3
	push	esi

; 2864 :   { if (s)
; 2865 :     { if (t[1] && SOAP_STRCMP(s + 1, t + 1))

	lea	esi, DWORD PTR [eax+1]
	test	ebx, ebx
	je	SHORT $LN13@soap_match@3
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN35@soap_match@3
	lea	ecx, DWORD PTR [ebx+1]
	npad	4
$LL19@soap_match@3:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [esi]
	jne	SHORT $LN20@soap_match@3
	test	dl, dl
	je	SHORT $LN21@soap_match@3
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [esi+1]
	jne	SHORT $LN20@soap_match@3
	add	ecx, 2
	add	esi, 2
	test	dl, dl
	jne	SHORT $LL19@soap_match@3
$LN21@soap_match@3:
	xor	ecx, ecx
	jmp	SHORT $LN22@soap_match@3
$LN20@soap_match@3:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN22@soap_match@3:
	test	ecx, ecx

; 2866 :         return SOAP_TAG_MISMATCH;

	jne	SHORT $LN38@soap_match@3
$LN35@soap_match@3:

; 2867 :       if (t != tag2 && (err = soap_match_namespace(soap, tag1, tag2, s - tag1, t - tag2)))

	cmp	eax, edi
	je	SHORT $LN6@soap_match@3
	mov	ecx, DWORD PTR _soap$[esp+8]
	sub	eax, edi
	push	eax
	push	edi
	mov	eax, ebx
	push	ebp
	sub	eax, ebp
	push	ecx

; 2868 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Tags '%s' and '%s' match but namespaces differ\n", tag1, tag2));
; 2869 :         if (err == SOAP_NAMESPACE)
; 2870 :           return SOAP_TAG_MISMATCH;

	jmp	SHORT $LN39@soap_match@3
$LN13@soap_match@3:

; 2871 :         return err;
; 2872 :       }
; 2873 :     }
; 2874 :     else if (SOAP_STRCMP(tag1, t + 1))

	mov	ecx, ebp
	npad	1
$LL23@soap_match@3:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [esi]
	jne	SHORT $LN24@soap_match@3
	test	dl, dl
	je	SHORT $LN25@soap_match@3
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [esi+1]
	jne	SHORT $LN24@soap_match@3
	add	ecx, 2
	add	esi, 2
	test	dl, dl
	jne	SHORT $LL23@soap_match@3
$LN25@soap_match@3:
	xor	ecx, ecx
	jmp	SHORT $LN26@soap_match@3
$LN24@soap_match@3:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN26@soap_match@3:
	test	ecx, ecx

; 2875 :     { return SOAP_TAG_MISMATCH;

	jne	SHORT $LN38@soap_match@3

; 2876 :     }
; 2877 :     else if (t != tag2 && (err = soap_match_namespace(soap, tag1, tag2, 0, t - tag2)))

	cmp	eax, edi
	je	SHORT $LN6@soap_match@3
	mov	edx, DWORD PTR _soap$[esp+8]
	sub	eax, edi
	push	eax
	push	edi
	push	ebp
	push	edx
	xor	eax, eax
$LN39@soap_match@3:
	call	_soap_match_namespace
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN6@soap_match@3

; 2878 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Tags '%s' and '%s' match but namespaces differ\n", tag1, tag2));
; 2879 :       if (err == SOAP_NAMESPACE)

	cmp	eax, 9
	jne	SHORT $LN37@soap_match@3
$LN38@soap_match@3:

; 2880 :         return SOAP_TAG_MISMATCH;

	mov	eax, 3
$LN37@soap_match@3:
	pop	esi
	pop	ebx
	pop	ebp

; 2894 : }

	ret	0
$LN6@soap_match@3:
	pop	esi
	pop	ebx

; 2881 :       return err;
; 2882 :     }
; 2883 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Tags and (default) namespaces match: '%s' '%s'\n", tag1, tag2));
; 2884 :     return SOAP_OK;

	xor	eax, eax
	pop	ebp

; 2894 : }

	ret	0
$LN14@soap_match@3:

; 2885 :   }
; 2886 :   if (s)
; 2887 :   { if (SOAP_STRCMP(s + 1, tag2))

	mov	ecx, edi
	test	ebx, ebx
	je	SHORT $LN4@soap_match@3
	lea	eax, DWORD PTR [ebx+1]
$LL27@soap_match@3:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN32@soap_match@3
	test	dl, dl
	je	SHORT $LN29@soap_match@3
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN32@soap_match@3
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL27@soap_match@3
$LN29@soap_match@3:
	xor	eax, eax
	jmp	SHORT $LN34@soap_match@3
$LN4@soap_match@3:

; 2888 :       return SOAP_TAG_MISMATCH;
; 2889 :   }
; 2890 :   else if (SOAP_STRCMP(tag1, tag2))

	mov	eax, ebp
$LL31@soap_match@3:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN32@soap_match@3
	test	dl, dl
	je	SHORT $LN33@soap_match@3
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN32@soap_match@3
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL31@soap_match@3
$LN33@soap_match@3:
	xor	eax, eax
	jmp	SHORT $LN34@soap_match@3
$LN32@soap_match@3:
	sbb	eax, eax
	sbb	eax, -1
$LN34@soap_match@3:
	test	eax, eax
	je	SHORT $LN1@soap_match@3
	pop	ebx

; 2891 :     return SOAP_TAG_MISMATCH;

	mov	eax, 3
	pop	ebp

; 2894 : }

	ret	0
$LN1@soap_match@3:
	pop	ebx

; 2892 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Tags match: '%s' '%s'\n", tag1, tag2));
; 2893 :   return SOAP_OK;

	xor	eax, eax
	pop	ebp

; 2894 : }

	ret	0
$LN15@soap_match@3:

; 2860 :     return SOAP_OK;

	xor	eax, eax
	pop	ebp

; 2894 : }

	ret	0
_soap_match_tag ENDP
_TEXT	ENDS
PUBLIC	_soap_current_namespace
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_soap_current_namespace PROC

; 2778 : { register struct soap_nlist *np;

	push	ebx
	mov	ebx, DWORD PTR _tag$[esp]
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+4]

; 2779 :   register const char *s;
; 2780 :   if (!tag || !strncmp(tag, "xml", 3))

	test	ebx, ebx
	je	$LN12@soap_curre
	push	3
	push	OFFSET ??_C@_03PJHHNEEI@xml?$AA@
	push	ebx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN12@soap_curre
	push	esi

; 2782 :   np = soap->nlist;

	mov	esi, DWORD PTR [ebp+88]
	push	edi

; 2783 :   if (!(s = strchr(tag, ':')))

	push	58					; 0000003aH
	push	ebx
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@soap_curre

; 2784 :   { while (np && *np->id) /* find default namespace, if present */

	test	esi, esi
	je	SHORT $LN1@soap_curre
$LL10@soap_curre:
	cmp	BYTE PTR [esi+16], 0
	je	SHORT $LN4@soap_curre

; 2785 :       np = np->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL10@soap_curre
$LN1@soap_curre:
	pop	edi
	pop	esi
	pop	ebp

; 2798 :   }
; 2799 :   return NULL;

	xor	eax, eax
	pop	ebx

; 2800 : }

	ret	0
$LN17@soap_curre:

; 2786 :   }
; 2787 :   else
; 2788 :   { while (np && (strncmp(np->id, tag, s - tag) || np->id[s - tag]))

	test	esi, esi
	je	SHORT $LN21@soap_curre
	mov	edi, eax
	sub	edi, ebx
	npad	3
$LL7@soap_curre:
	push	edi
	lea	eax, DWORD PTR [esi+16]
	push	ebx
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@soap_curre
	cmp	BYTE PTR [edi+esi+16], al
	je	SHORT $LN6@soap_curre
$LN5@soap_curre:

; 2789 :       np = np->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL7@soap_curre

; 2790 :     if (!np)

	jmp	SHORT $LN21@soap_curre
$LN6@soap_curre:
	test	esi, esi
	jne	SHORT $LN22@soap_curre
$LN21@soap_curre:

; 2791 :       soap->error = SOAP_NAMESPACE;

	mov	DWORD PTR [ebp+90460], 9
$LN4@soap_curre:

; 2792 :   }
; 2793 :   if (np)

	test	esi, esi
	je	SHORT $LN1@soap_curre
$LN22@soap_curre:

; 2794 :   { if (np->index >= 0)

	movzx	eax, WORD PTR [esi+8]
	test	ax, ax
	jl	SHORT $LN2@soap_curre

; 2795 :       return soap->namespaces[np->index].ns;

	mov	edx, DWORD PTR [ebp+80]
	pop	edi
	movsx	ecx, ax
	pop	esi
	shl	ecx, 4
	mov	eax, DWORD PTR [ecx+edx+4]
	pop	ebp
	pop	ebx

; 2800 : }

	ret	0
$LN2@soap_curre:

; 2796 :     if (np->ns)

	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	je	SHORT $LN1@soap_curre

; 2797 :       return soap_strdup(soap, np->ns);

	push	esi
	push	ebp
	call	_soap_strdup
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2800 : }

	ret	0
$LN12@soap_curre:
	pop	ebp

; 2781 :     return NULL;

	xor	eax, eax
	pop	ebx

; 2800 : }

	ret	0
_soap_current_namespace ENDP
_TEXT	ENDS
PUBLIC	_soap_getsize
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_attr2$ = 8						; size = 4
_s$ = 12						; size = 4
_j$ = 12						; size = 4
_soap_getsize PROC
; _attr1$ = eax

; 2593 : { register int n, k;

	push	ebx
	mov	ebx, DWORD PTR _j$[esp]
	push	esi
	mov	esi, eax

; 2594 :   char *s;
; 2595 :   *j = 0;

	mov	DWORD PTR [ebx], 0

; 2596 :   if (!*attr1)

	mov	al, BYTE PTR [esi]
	test	al, al
	jne	SHORT $LN10@soap_getsi@2
	pop	esi

; 2597 :     return -1;

	mov	eax, -1
	pop	ebx

; 2623 : }

	ret	0
$LN10@soap_getsi@2:

; 2598 :   if (*attr1 == '[')

	cmp	al, 91					; 0000005bH
	jne	SHORT $LN9@soap_getsi@2

; 2599 :     attr1++;

	inc	esi
$LN9@soap_getsi@2:
	push	ebp
	push	edi

; 2600 :   n = 1;
; 2601 :   for (;;)
; 2602 :   { k = (int)soap_strtol(attr1, &s, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _s$[esp+16]
	push	eax
	push	esi
	call	_strtol
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 2603 :     n *= k;

	mov	ebp, edi

; 2604 :     if (k < 0 || n > SOAP_MAXARRAYSIZE || s == attr1)

	test	edi, edi
	jl	$LN5@soap_getsi@2
	npad	1
$LL8@soap_getsi@2:
	cmp	ebp, 100000				; 000186a0H
	jg	$LN5@soap_getsi@2
	mov	eax, DWORD PTR _s$[esp+12]
	cmp	eax, esi
	je	SHORT $LN5@soap_getsi@2

; 2606 :     attr1 = strchr(s, ',');

	push	44					; 0000002cH
	push	eax
	call	_strchr
	mov	esi, eax
	add	esp, 8

; 2607 :     if (!attr1)

	test	esi, esi
	jne	SHORT $LN4@soap_getsi@2

; 2608 :       attr1 = strchr(s, ' ');

	mov	ecx, DWORD PTR _s$[esp+12]
	push	32					; 00000020H
	push	ecx
	call	_strchr
	add	esp, 8
	mov	esi, eax
$LN4@soap_getsi@2:

; 2609 :     if (attr2 && *attr2)

	mov	eax, DWORD PTR _attr2$[esp+12]
	test	eax, eax
	je	SHORT $LN22@soap_getsi@2
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN22@soap_getsi@2

; 2610 :     { attr2++;
; 2611 :       *j *= k;

	mov	edx, DWORD PTR [ebx]
	imul	edx, edi

; 2612 :       k = (int)soap_strtol(attr2, &s, 10);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _s$[esp+16]
	push	ecx
	inc	eax
	push	eax
	mov	DWORD PTR [ebx], edx
	call	_strtol

; 2613 :       *j += k;

	add	DWORD PTR [ebx], eax
	add	esp, 12					; 0000000cH

; 2614 :       if (k < 0)

	test	eax, eax
	jl	SHORT $LN5@soap_getsi@2

; 2615 :         return -1;
; 2616 :       attr2 = s;

	mov	edx, DWORD PTR _s$[esp+12]
	mov	DWORD PTR _attr2$[esp+12], edx
$LN22@soap_getsi@2:

; 2617 :     }
; 2618 :     if (!attr1)

	test	esi, esi
	je	SHORT $LN20@soap_getsi@2
	push	10					; 0000000aH
	lea	eax, DWORD PTR _s$[esp+16]
	push	eax

; 2619 :       break;
; 2620 :     attr1++;

	inc	esi
	push	esi
	call	_strtol
	mov	edi, eax
	mov	ecx, edi
	add	esp, 12					; 0000000cH
	imul	ebp, ecx
	test	edi, edi
	jge	$LL8@soap_getsi@2
$LN5@soap_getsi@2:
	pop	edi
	pop	ebp
	pop	esi

; 2605 :       return -1;

	or	eax, -1
	pop	ebx

; 2623 : }

	ret	0
$LN20@soap_getsi@2:
	pop	edi

; 2621 :   }
; 2622 :   return n - *j;

	mov	eax, ebp
	sub	eax, DWORD PTR [ebx]
	pop	ebp
	pop	esi
	pop	ebx

; 2623 : }

	ret	0
_soap_getsize ENDP
_TEXT	ENDS
PUBLIC	_soap_save_block
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_save_block PROC
; _soap$ = eax

; 2447 : { register size_t n;

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, eax

; 2448 :   register char *q, *s;
; 2449 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Save all blocks in contiguous memory space of %u bytes (%p->%p)\n", (unsigned int)soap->blist->size, soap->blist->ptr, p));
; 2450 :   if (soap->blist->size)

	mov	eax, DWORD PTR [edi+92]
	mov	eax, DWORD PTR [eax+8]
	xor	ebp, ebp
	test	eax, eax
	je	$LN38@soap_save_

; 2451 :   { if (!p)
; 2452 :       p = (char*)soap_malloc(soap, soap->blist->size);

	call	_soap_malloc
	mov	ebp, eax

; 2453 :     if (p)

	test	ebp, ebp
	je	SHORT $LN6@soap_save_

; 2454 :     { for (s = p, q = soap_first_block(soap); q; q = soap_next_block(soap))

	mov	ecx, DWORD PTR [edi+92]
	mov	eax, DWORD PTR [ecx+4]
	mov	ebx, ebp
	test	eax, eax
	je	SHORT $LN38@soap_save_
	xor	ecx, ecx
	npad	1
$LL13@soap_save_:
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax], ecx
	mov	ecx, eax
	mov	eax, edx
	test	edx, edx
	jne	SHORT $LL13@soap_save_
	mov	edx, DWORD PTR [edi+92]
	mov	DWORD PTR [edx+4], ecx
	add	ecx, 8
	je	SHORT $LN38@soap_save_

; 2455 :       { n = soap_block_size(soap);

	mov	eax, DWORD PTR [edi+92]
	mov	eax, DWORD PTR [eax+4]
	npad	3
$LL19@soap_save_:
	mov	esi, DWORD PTR [eax+4]

; 2456 : #ifndef WITH_NOIDREF
; 2457 :         if (flag)
; 2458 :           soap_update_ptrs(soap, q, q + n, s, q);
; 2459 : #endif
; 2460 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy %u bytes from %p to %p\n", (unsigned int)n, q, s));
; 2461 :         memcpy(s, q, n);

	push	esi
	push	ecx
	push	ebx
	call	_memcpy
	mov	ecx, DWORD PTR [edi+92]
	mov	eax, DWORD PTR [ecx+4]
	add	esp, 12					; 0000000cH

; 2462 :         s += n;

	add	ebx, esi
	test	eax, eax
	je	SHORT $LN38@soap_save_
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	DWORD PTR [ecx+4], edx
	call	_free
	mov	eax, DWORD PTR [edi+92]
	mov	eax, DWORD PTR [eax+4]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN38@soap_save_
	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	jne	SHORT $LL19@soap_save_

; 2463 :       }
; 2464 :     }
; 2465 :     else

	jmp	SHORT $LN38@soap_save_
$LN6@soap_save_:

; 2466 :       soap->error = SOAP_EOM;

	mov	DWORD PTR [edi+90460], 20		; 00000014H
$LN38@soap_save_:

; 2467 :   }
; 2468 :   soap_end_block(soap);

	mov	ebx, DWORD PTR [edi+92]
	test	ebx, ebx
	je	SHORT $LN37@soap_save_
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN23@soap_save_
$LL25@soap_save_:
	mov	esi, DWORD PTR [eax]
	push	eax
	call	_free
	add	esp, 4
	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL25@soap_save_
$LN23@soap_save_:
	mov	ecx, DWORD PTR [ebx]
	push	ebx
	mov	DWORD PTR [edi+92], ecx
	call	_free
	add	esp, 4
$LN37@soap_save_:
	pop	edi
	pop	esi

; 2469 :   return p;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2470 : }

	ret	0
_soap_save_block ENDP
_TEXT	ENDS
PUBLIC	_soap_resolve
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_flag$ = -12						; size = 2
_k$79274 = -12						; size = 4
_i$ = -8						; size = 4
tv578 = -4						; size = 4
_soap$ = 8						; size = 4
_soap_resolve PROC

; 2268 : { register int i;

	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp+12]
	push	ebp
	push	esi

; 2269 :   register struct soap_ilist *ip = NULL;
; 2270 :   register struct soap_flist *fp = NULL;
; 2271 :   short flag;
; 2272 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolving forwarded data\n"));
; 2273 :   for (i = 0; i < SOAP_IDHASH; i++)

	lea	eax, DWORD PTR [ebx+104]
	push	edi
	xor	ebp, ebp
	mov	edx, eax
$LL33@soap_resol@2:

; 2274 :   { for (ip = soap->iht[i]; ip; ip = ip->next)

	mov	esi, DWORD PTR [edx]
	test	esi, esi
	je	SHORT $LN32@soap_resol@2
$LL30@soap_resol@2:

; 2275 :     { if (ip->ptr)

	mov	edi, DWORD PTR [esi+24]
	test	edi, edi
	je	SHORT $LN27@soap_resol@2

; 2276 :       { register void *p, **q, *r;
; 2277 :         q = (void**)ip->link;

	mov	eax, DWORD PTR [esi+12]

; 2278 :         ip->link = NULL;

	mov	DWORD PTR [esi+12], 0

; 2279 :         r = ip->ptr;
; 2280 :         DBGLOG(TEST, if (q) SOAP_MESSAGE(fdebug, "Traversing link chain to resolve id='%s'\n", ip->id));
; 2281 :         while (q)

	test	eax, eax
	je	SHORT $LN29@soap_resol@2
	npad	3
$LL26@soap_resol@2:

; 2282 :         { p = *q;

	mov	ecx, DWORD PTR [eax]

; 2283 :           *q = r;

	mov	DWORD PTR [eax], edi

; 2284 :           DBGLOG(TEST,SOAP_MESSAGE(fdebug, "... link %p -> %p\n", q, r));
; 2285 :           q = (void**)p;

	mov	eax, ecx
	test	ecx, ecx
	jne	SHORT $LL26@soap_resol@2

; 2286 :         }
; 2287 :       }
; 2288 :       else if (*ip->id == '#')

	jmp	SHORT $LN29@soap_resol@2
$LN27@soap_resol@2:
	cmp	BYTE PTR [esi+32], 35			; 00000023H
	je	$LN56@soap_resol@2
$LN29@soap_resol@2:

; 2274 :   { for (ip = soap->iht[i]; ip; ip = ip->next)

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL30@soap_resol@2
$LN32@soap_resol@2:

; 2269 :   register struct soap_ilist *ip = NULL;
; 2270 :   register struct soap_flist *fp = NULL;
; 2271 :   short flag;
; 2272 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolving forwarded data\n"));
; 2273 :   for (i = 0; i < SOAP_IDHASH; i++)

	inc	ebp
	add	edx, 4
	cmp	ebp, 1999				; 000007cfH
	jl	SHORT $LL33@soap_resol@2
	npad	8
$LL22@soap_resol@2:

; 2292 :       }
; 2293 :     }
; 2294 :   }
; 2295 :   do
; 2296 :   { flag = 0;

	xor	eax, eax
	mov	DWORD PTR _flag$[esp+28], eax

; 2297 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolution phase\n"));
; 2298 :     for (i = 0; i < SOAP_IDHASH; i++)

	mov	DWORD PTR _i$[esp+28], eax
	lea	eax, DWORD PTR [ebx+104]
	mov	DWORD PTR tv578[esp+28], eax
$LL89@soap_resol@2:

; 2299 :     { for (ip = soap->iht[i]; ip; ip = ip->next)

	mov	ebp, DWORD PTR [eax]
	test	ebp, ebp
	je	$LN18@soap_resol@2
	npad	5
$LL16@soap_resol@2:

; 2300 :       { if (ip->ptr && !soap_has_copies(soap, (const char*)ip->ptr, (const char*)ip->ptr + ip->size))

	mov	esi, DWORD PTR [ebp+24]
	test	esi, esi
	je	$LN15@soap_resol@2
	mov	edi, DWORD PTR [ebp+8]
	add	edi, esi
	push	ebx
	call	_soap_has_copies
	add	esp, 4
	test	eax, eax
	jne	$LN15@soap_resol@2

; 2301 :         { if (ip->copy)

	mov	eax, DWORD PTR [ebp+16]
	test	eax, eax
	je	SHORT $LN86@soap_resol@2

; 2302 :           { register void *p, **q = (void**)ip->copy;
; 2303 :             DBGLOG(TEST, if (q) SOAP_MESSAGE(fdebug, "Traversing copy chain to resolve id='%s'\n", ip->id));
; 2304 :             ip->copy = NULL;

	mov	DWORD PTR [ebp+16], 0
	npad	1
$LL11@soap_resol@2:

; 2305 :             do
; 2306 :             { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "... copy %p -> %p (%u bytes)\n", ip->ptr, q, (unsigned int)ip->size));
; 2307 :               p = *q;
; 2308 :               memcpy(q, ip->ptr, ip->size);

	mov	edx, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebp+24]
	mov	esi, DWORD PTR [eax]
	push	edx
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2309 :               q = (void**)p;

	mov	eax, esi

; 2310 :             } while (q);

	test	esi, esi
	jne	SHORT $LL11@soap_resol@2

; 2311 :             flag = 1;

	mov	DWORD PTR _flag$[esp+28], 1
$LN86@soap_resol@2:

; 2312 :           }
; 2313 :           for (fp = ip->flist; fp; fp = ip->flist)

	mov	esi, DWORD PTR [ebp+20]
	test	esi, esi
	je	$LN15@soap_resol@2
	npad	4
$LL8@soap_resol@2:

; 2314 :           { register unsigned int k = fp->level;

	mov	eax, DWORD PTR [esi+12]

; 2315 :             register void *p = ip->ptr;

	mov	edi, DWORD PTR [ebp+24]
	mov	DWORD PTR _k$79274[esp+28], eax

; 2316 :             DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolving forwarded data type=%d location=%p level=%u,%u id='%s'\n", ip->type, p, ip->level, fp->level, ip->id));
; 2317 :             while (ip->level < k)

	cmp	DWORD PTR [ebp+28], eax
	jae	$LN87@soap_resol@2
$LL5@soap_resol@2:

; 2318 :             { register void **q = (void**)soap_malloc(soap, sizeof(void*));

	test	ebx, ebx
	jne	SHORT $LN40@soap_resol@2
	push	4
	call	_malloc
	add	esp, 4
	jmp	SHORT $LN42@soap_resol@2
$LN56@soap_resol@2:

; 2289 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Missing data for id='%s'\n", ip->id));
; 2290 :         strcpy(soap->id, ip->id + 1);

	lea	eax, DWORD PTR [esi+33]
	mov	ecx, ebx
	sub	ecx, eax
	lea	edx, DWORD PTR [ecx+81076]
$LL36@soap_resol@2:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL36@soap_resol@2
	pop	edi
	pop	esi

; 2291 :         return soap->error = SOAP_MISSING_ID;

	mov	eax, 25					; 00000019H
	pop	ebp
	mov	DWORD PTR [ebx+90460], eax
	pop	ebx

; 2349 : }

	add	esp, 12					; 0000000cH
	ret	0

; 2318 :             { register void **q = (void**)soap_malloc(soap, sizeof(void*));

$LN40@soap_resol@2:
	mov	eax, DWORD PTR [ebx+12336]
	test	eax, eax
	je	SHORT $LN39@soap_resol@2
	push	4
	push	ebx
	call	eax
	add	esp, 8
	jmp	SHORT $LN38@soap_resol@2
$LN39@soap_resol@2:
	push	16					; 00000010H
	call	_malloc
	add	esp, 4
	test	eax, eax
	je	$LN72@soap_resol@2
	mov	edx, -16162				; ffffc0deH
	mov	WORD PTR [eax+6], dx
	mov	edx, DWORD PTR [ebx+100]
	lea	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [eax+12], 8
	mov	DWORD PTR [ebx+100], ecx
$LN38@soap_resol@2:
	mov	ecx, 1
	mov	WORD PTR [ebx+87306], cx
$LN42@soap_resol@2:

; 2319 :               if (!q)

	test	eax, eax
	je	$LN57@soap_resol@2

; 2321 :               *q = p;

	mov	DWORD PTR [eax], edi

; 2322 :               DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Descending one level, new location=%p holds=%p...\n", q, *q));
; 2323 :               p = (void*)q;

	mov	edi, eax

; 2324 :               k--;

	mov	eax, DWORD PTR _k$79274[esp+28]
	dec	eax
	mov	DWORD PTR _k$79274[esp+28], eax
	cmp	DWORD PTR [ebp+28], eax
	jb	$LL5@soap_resol@2
$LN87@soap_resol@2:

; 2325 :             }
; 2326 :             if (fp->fcopy)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN2@soap_resol@2

; 2327 :               fp->fcopy(soap, ip->type, fp->type, fp->ptr, fp->len, p, ip->size);

	mov	edx, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [esi+16]
	push	edx
	mov	edx, DWORD PTR [esi+8]
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	mov	edx, DWORD PTR [ebp+4]
	push	ecx
	push	edx
	push	ebx
	call	eax
	add	esp, 28					; 0000001cH

; 2328 :             else

	jmp	SHORT $LN44@soap_resol@2
$LN2@soap_resol@2:

; 2329 :               soap_fcopy(soap, ip->type, fp->type, fp->ptr, fp->len, p, ip->size);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [esi+8]
	push	eax
	push	edi
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN44@soap_resol@2:

; 2330 :             ip->flist = fp->next;

	mov	edx, DWORD PTR [esi]

; 2331 :             SOAP_FREE(soap, fp);

	push	esi
	mov	DWORD PTR [ebp+20], edx
	call	_free
	mov	esi, DWORD PTR [ebp+20]
	add	esp, 4

; 2332 :             flag = 1;

	mov	DWORD PTR _flag$[esp+28], 1
	test	esi, esi
	jne	$LL8@soap_resol@2
$LN15@soap_resol@2:

; 2299 :     { for (ip = soap->iht[i]; ip; ip = ip->next)

	mov	ebp, DWORD PTR [ebp]
	test	ebp, ebp
	jne	$LL16@soap_resol@2
$LN18@soap_resol@2:

; 2297 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolution phase\n"));
; 2298 :     for (i = 0; i < SOAP_IDHASH; i++)

	mov	ecx, DWORD PTR _i$[esp+28]
	mov	eax, DWORD PTR tv578[esp+28]
	inc	ecx
	add	eax, 4
	cmp	ecx, 1999				; 000007cfH
	mov	DWORD PTR _i$[esp+28], ecx
	mov	DWORD PTR tv578[esp+28], eax
	jl	$LL89@soap_resol@2

; 2333 :           }
; 2334 :         }
; 2335 :       }
; 2336 :     }
; 2337 :   } while (flag);

	cmp	WORD PTR _flag$[esp+28], 0
	jne	$LL22@soap_resol@2
	pop	edi
	pop	esi
	pop	ebp

; 2338 : #ifdef SOAP_DEBUG
; 2339 :   for (i = 0; i < SOAP_IDHASH; i++)
; 2340 :   { for (ip = soap->iht[i]; ip; ip = ip->next)
; 2341 :     { if (ip->copy || ip->flist)
; 2342 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolution error: forwarded data for id='%s' could not be propagated, please report this problem to the developers\n", ip->id));
; 2343 :       }
; 2344 :     }
; 2345 :   }
; 2346 : #endif
; 2347 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolution done\n"));
; 2348 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 2349 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN72@soap_resol@2:

; 2318 :             { register void **q = (void**)soap_malloc(soap, sizeof(void*));

	mov	DWORD PTR [ebx+90460], 20		; 00000014H
$LN57@soap_resol@2:

; 2320 :                 return soap->error;

	mov	eax, DWORD PTR [ebx+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2349 : }

	add	esp, 12					; 0000000cH
	ret	0
_soap_resolve ENDP
_TEXT	ENDS
PUBLIC	_soap_putbase64
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_d$ = -4						; size = 4
_soap$ = 8						; size = 4
_soap_putbase64 PROC
; _s$ = ecx
; _n$ = eax

; 1865 : { register int i;

	push	ecx
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, eax

; 1866 :   register unsigned long m;
; 1867 :   char d[4];
; 1868 :   if (!s)

	test	esi, esi

; 1869 :     return SOAP_OK;

	je	$LN1@soap_putba

; 1870 : #ifdef WITH_DOM
; 1871 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 1872 :   { if (!(soap->dom->data = soap_s2base64(soap, s, NULL, n)))
; 1873 :       return soap->error;
; 1874 :     return SOAP_OK;
; 1875 :   }
; 1876 : #endif
; 1877 :   for (; n > 2; n -= 3, s += 3)

	cmp	edi, 2
	jle	SHORT $LN19@soap_putba
	npad	7
$LL21@soap_putba:

; 1878 :   { m = s[0];
; 1879 :     m = (m << 8) | s[1];
; 1880 :     m = (m << 8) | s[2];

	movzx	eax, BYTE PTR [esi]
	movzx	ecx, BYTE PTR [esi+1]
	movzx	edx, BYTE PTR [esi+2]
	shl	eax, 8
	or	eax, ecx
	shl	eax, 8
	or	eax, edx

; 1881 :     for (i = 4; i > 0; m >>= 6)

	mov	ecx, 4
	npad	6
$LL18@soap_putba:

; 1882 :       d[--i] = soap_base64o[m & 0x3F];

	mov	edx, eax
	and	edx, 63					; 0000003fH
	mov	dl, BYTE PTR _soap_base64o[edx]
	dec	ecx
	shr	eax, 6
	mov	BYTE PTR _d$[esp+ecx+16], dl
	test	ecx, ecx
	jg	SHORT $LL18@soap_putba

; 1883 :     if (soap_send_raw(soap, d, 4))

	lea	eax, DWORD PTR _d$[esp+16]
	push	4
	push	eax
	mov	eax, ebp
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	$LN31@soap_putba
	sub	edi, 3
	add	esi, 3
	cmp	edi, 2
	jg	SHORT $LL21@soap_putba
$LN19@soap_putba:

; 1885 :   }
; 1886 :   if (n > 0)

	test	edi, edi
	jle	$LN1@soap_putba

; 1887 :   { m = 0;

	xor	ecx, ecx

; 1888 :     for (i = 0; i < n; i++)

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN39@soap_putba
	mov	edx, edi
	mov	eax, edi
	push	ebx
$LL13@soap_putba:

; 1889 :       m = (m << 8) | *s++;

	movzx	ebx, BYTE PTR [esi]
	shl	ecx, 8
	or	ecx, ebx
	inc	esi
	sub	edx, 1
	jne	SHORT $LL13@soap_putba

; 1890 :     for (; i < 3; i++)

	cmp	edi, 3
	pop	ebx
	jge	SHORT $LN42@soap_putba
$LN39@soap_putba:

; 1891 :       m <<= 8;

	mov	edx, 3
	sub	edx, eax
	add	eax, edx
	npad	3
$LL38@soap_putba:
	shl	ecx, 8
	sub	edx, 1
	jne	SHORT $LL38@soap_putba
$LN42@soap_putba:

; 1892 :     for (i++; i > 0; m >>= 6)

	inc	eax
	test	eax, eax
	jle	SHORT $LN5@soap_putba
	npad	3
$LL7@soap_putba:

; 1893 :       d[--i] = soap_base64o[m & 0x3F];

	mov	edx, ecx
	and	edx, 63					; 0000003fH
	mov	dl, BYTE PTR _soap_base64o[edx]
	dec	eax
	shr	ecx, 6
	mov	BYTE PTR _d$[esp+eax+16], dl
	test	eax, eax
	jg	SHORT $LL7@soap_putba
$LN5@soap_putba:

; 1894 :     for (i = 3; i > n; i--)

	mov	eax, 3
	cmp	edi, eax
	jge	SHORT $LN2@soap_putba
	mov	cl, 61					; 0000003dH
$LL4@soap_putba:

; 1895 :       d[i] = '=';

	mov	BYTE PTR _d$[esp+eax+16], cl
	dec	eax
	cmp	eax, edi
	jg	SHORT $LL4@soap_putba
$LN2@soap_putba:

; 1896 :     if (soap_send_raw(soap, d, 4))

	lea	eax, DWORD PTR _d$[esp+16]
	push	4
	push	eax
	mov	eax, ebp
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax

; 1897 :       return soap->error;

	jne	SHORT $LN31@soap_putba
$LN1@soap_putba:
	pop	edi
	pop	esi

; 1898 :   }
; 1899 :   return SOAP_OK;

	xor	eax, eax
	pop	ebp

; 1900 : }

	pop	ecx
	ret	0
$LN31@soap_putba:

; 1884 :       return soap->error;

	mov	eax, DWORD PTR [ebp+90460]
	pop	edi
	pop	esi
	pop	ebp

; 1900 : }

	pop	ecx
	ret	0
_soap_putbase64 ENDP
_TEXT	ENDS
PUBLIC	_soap_puthex
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_d$ = 8							; size = 2
_n$ = 8							; size = 4
_soap_puthex PROC
; _soap$ = edi
; _s$ = eax

; 1749 : { char d[2];

	push	ebx
	mov	ebx, DWORD PTR _n$[esp]
	push	ebp

; 1750 :   register int i;
; 1751 : #ifdef WITH_DOM
; 1752 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 1753 :   { if (!(soap->dom->data = soap_s2hex(soap, s, NULL, n)))
; 1754 :       return soap->error;
; 1755 :     return SOAP_OK;
; 1756 :   }
; 1757 : #endif
; 1758 :   for (i = 0; i < n; i++)

	xor	ebp, ebp
	push	esi
	mov	esi, eax
	test	ebx, ebx
	jle	SHORT $LN2@soap_puthe
	npad	1
$LL4@soap_puthe:

; 1759 :   { register int m = *s++;

	movzx	eax, BYTE PTR [esi]
	inc	esi

; 1760 :     d[0] = (char)((m >> 4) + (m > 159 ? '7' : '0'));

	cmp	eax, 159				; 0000009fH
	setle	cl
	dec	cl
	and	cl, 7
	add	cl, 48					; 00000030H
	mov	edx, eax
	sar	edx, 4
	add	cl, dl

; 1761 :     m &= 0x0F;

	and	eax, 15					; 0000000fH
	mov	BYTE PTR _d$[esp+8], cl

; 1762 :     d[1] = (char)(m + (m > 9 ? '7' : '0'));

	cmp	eax, 9
	setle	cl
	dec	cl
	and	cl, 7
	add	cl, 48					; 00000030H
	add	cl, al

; 1763 :     if (soap_send_raw(soap, d, 2))

	lea	edx, DWORD PTR _d$[esp+8]
	push	2
	push	edx
	mov	eax, edi
	mov	BYTE PTR _d$[esp+17], cl
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@soap_puthe
	inc	ebp
	cmp	ebp, ebx
	jl	SHORT $LL4@soap_puthe
$LN2@soap_puthe:
	pop	esi
	pop	ebp

; 1765 :   }
; 1766 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 1767 : }

	ret	0
$LN8@soap_puthe:

; 1764 :       return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	esi
	pop	ebp
	pop	ebx

; 1767 : }

	ret	0
_soap_puthex ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_soap_recv_raw
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_t$78590 = -16						; size = 4
_tmp$78591 = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_soap_recv_raw PROC
; _soap$ = ecx

; 1080 : { register size_t ret;

	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+16], eax
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1081 : #ifdef WITH_ZLIB
; 1082 :   if (soap->mode & SOAP_ENC_ZLIB)
; 1083 :   { if (soap->d_stream->next_out == Z_NULL)
; 1084 :       return EOF;
; 1085 :     if (soap->d_stream->avail_in || !soap->d_stream->avail_out)
; 1086 :     { register int r;
; 1087 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflating\n"));
; 1088 :       soap->d_stream->next_out = (Byte*)soap->buf;
; 1089 :       soap->d_stream->avail_out = SOAP_BUFLEN;
; 1090 :       r = inflate(soap->d_stream, Z_NO_FLUSH);
; 1091 :       if (r == Z_OK || r == Z_STREAM_END)
; 1092 :       { soap->bufidx = 0;
; 1093 :         ret = soap->buflen = SOAP_BUFLEN - soap->d_stream->avail_out;
; 1094 :         if (soap->zlib_in == SOAP_ZLIB_GZIP)
; 1095 :           soap->z_crc = crc32(soap->z_crc, (Byte*)soap->buf, (unsigned int)ret);
; 1096 :         if (r == Z_STREAM_END)
; 1097 :         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflated %lu->%lu bytes\n", soap->d_stream->total_in, soap->d_stream->total_out));
; 1098 :           soap->z_ratio_in = (float)soap->d_stream->total_in / (float)soap->d_stream->total_out;
; 1099 :           soap->d_stream->next_out = Z_NULL;
; 1100 :         }
; 1101 :         if (ret)
; 1102 :         { soap->count += ret;
; 1103 :           DBGLOG(RECV, SOAP_MESSAGE(fdebug, "\n---- decompressed ----\n"));
; 1104 :           DBGMSG(RECV, soap->buf, ret);
; 1105 :           DBGLOG(RECV, SOAP_MESSAGE(fdebug, "\n----\n"));
; 1106 :           return SOAP_OK;
; 1107 :         }
; 1108 :       }
; 1109 :       else if (r != Z_BUF_ERROR)
; 1110 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflate error: %s\n", soap->d_stream->msg?soap->d_stream->msg:""));
; 1111 :         soap->d_stream->next_out = Z_NULL;
; 1112 :         soap->error = SOAP_ZLIB_ERROR;
; 1113 :         return EOF;
; 1114 :       }
; 1115 :     }
; 1116 : zlib_again:
; 1117 :     if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK && !soap->chunksize)
; 1118 :     { memcpy(soap->buf, soap->z_buf, SOAP_BUFLEN);
; 1119 :       soap->buflen = soap->z_buflen;
; 1120 :     }
; 1121 :     DBGLOG(RECV, SOAP_MESSAGE(fdebug, "\n---- compressed ----\n"));
; 1122 :   }
; 1123 : #endif
; 1124 : #ifndef WITH_NOHTTP
; 1125 :   if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK) /* read HTTP chunked transfer */

	mov	eax, DWORD PTR [esi+8]
	and	eax, 3
	push	edi
	cmp	al, 3
	jne	$LN26@soap_recv_

; 1126 :   { for (;;)
; 1127 :     { register soap_wchar c;
; 1128 :       char *t, tmp[8];
; 1129 :       if (soap->chunksize)

	xor	ebp, ebp
	cmp	DWORD PTR [esi+87312], ebp
	jne	$LN63@soap_recv_
$LL25@soap_recv_:

; 1136 :       }
; 1137 :       t = tmp;

	lea	ecx, DWORD PTR _tmp$78591[esp+32]
	mov	DWORD PTR _t$78590[esp+32], ecx

; 1138 :       if (!soap->chunkbuflen)

	cmp	DWORD PTR [esi+87316], ebp
	jne	SHORT $LN22@soap_recv_

; 1139 :       { soap->chunkbuflen = ret = soap->frecv(soap, soap->buf, SOAP_BUFLEN);

	mov	eax, DWORD PTR [esi+12312]
	push	65536					; 00010000H
	lea	edx, DWORD PTR [esi+12468]
	push	edx
	push	esi
	call	eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+87316], eax

; 1140 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Read %u bytes (chunked) from socket %d\n", (unsigned int)ret, soap->socket));
; 1141 :         DBGMSG(RECV, soap->buf, ret);
; 1142 :         soap->bufidx = 0;

	mov	DWORD PTR [esi+12428], ebp

; 1143 :         if (!ret)

	cmp	eax, ebp
	jne	SHORT $LN20@soap_recv_
$LN64@soap_recv_:
	pop	edi

; 1144 :           return soap->ahead = EOF;

	or	eax, -1
	mov	DWORD PTR [esi+12436], eax
	pop	esi
	pop	ebp
	pop	ebx

; 1236 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+16]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 16					; 00000010H
	ret	0
$LN22@soap_recv_:

; 1145 :       }
; 1146 :       else
; 1147 :         soap->bufidx = soap->buflen;

	mov	ecx, DWORD PTR [esi+12432]
	mov	DWORD PTR [esi+12428], ecx
$LN20@soap_recv_:

; 1148 :       soap->buflen = soap->chunkbuflen;

	mov	edx, DWORD PTR [esi+87316]
	mov	DWORD PTR [esi+12432], edx
	npad	4
$LL19@soap_recv_:

; 1149 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Getting chunk size (idx=%u len=%u)\n", (unsigned int)soap->bufidx, (unsigned int)soap->buflen));
; 1150 :       while (!soap_isxdigit((int)(c = soap_getchunkchar(soap))))

	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN94@soap_recv_
	mov	ecx, DWORD PTR [esi+12312]
	push	65536					; 00010000H
	lea	eax, DWORD PTR [esi+12468]
	push	eax
	push	esi
	mov	DWORD PTR [esi+12428], ebp
	call	ecx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+87316], eax
	mov	DWORD PTR [esi+12432], eax
	cmp	eax, ebp
	je	SHORT $LN64@soap_recv_
	mov	eax, DWORD PTR [esi+12428]
$LN94@soap_recv_:
	movsx	ebx, BYTE PTR [eax+esi+12468]
	inc	eax
	cmp	ebx, 48					; 00000030H
	mov	DWORD PTR [esi+12428], eax
	jl	SHORT $LN84@soap_recv_
	cmp	ebx, 57					; 00000039H
	jle	SHORT $LL16@soap_recv_
$LN84@soap_recv_:
	cmp	ebx, 65					; 00000041H
	jl	SHORT $LN85@soap_recv_
	cmp	ebx, 70					; 00000046H
	jle	SHORT $LL16@soap_recv_
$LN85@soap_recv_:
	lea	edx, DWORD PTR [ebx-97]
	cmp	edx, 5
	jbe	SHORT $LL16@soap_recv_

; 1151 :       { if ((int)c == EOF)

	cmp	ebx, -1
	jne	SHORT $LL19@soap_recv_

; 1152 :           return soap->ahead = EOF;
; 1153 :       }

	jmp	$LN64@soap_recv_
	npad	9
$LL16@soap_recv_:

; 1154 :       do
; 1155 :         *t++ = (char)c;

	mov	eax, DWORD PTR _t$78590[esp+32]
	mov	BYTE PTR [eax], bl

; 1156 :       while (soap_isxdigit((int)(c = soap_getchunkchar(soap))) && t - tmp < 7);

	mov	eax, DWORD PTR [esi+12428]
	inc	DWORD PTR _t$78590[esp+32]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN95@soap_recv_
	mov	edx, DWORD PTR [esi+12312]
	push	65536					; 00010000H
	lea	ecx, DWORD PTR [esi+12468]
	push	ecx
	push	esi
	mov	DWORD PTR [esi+12428], ebp
	call	edx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+87316], eax
	mov	DWORD PTR [esi+12432], eax
	cmp	eax, ebp
	je	$LN64@soap_recv_
	mov	eax, DWORD PTR [esi+12428]
$LN95@soap_recv_:
	movsx	ebx, BYTE PTR [eax+esi+12468]
	inc	eax
	cmp	ebx, 48					; 00000030H
	mov	DWORD PTR [esi+12428], eax
	jl	SHORT $LN48@soap_recv_
	cmp	ebx, 57					; 00000039H
	jle	SHORT $LN50@soap_recv_
$LN48@soap_recv_:
	cmp	ebx, 65					; 00000041H
	jl	SHORT $LN49@soap_recv_
	cmp	ebx, 70					; 00000046H
	jle	SHORT $LN50@soap_recv_
$LN49@soap_recv_:
	lea	ecx, DWORD PTR [ebx-97]
	cmp	ecx, 5
	ja	SHORT $LN13@soap_recv_
$LN50@soap_recv_:
	mov	edx, DWORD PTR _t$78590[esp+32]
	lea	ecx, DWORD PTR _tmp$78591[esp+32]
	sub	edx, ecx
	cmp	edx, 7
	jl	$LL16@soap_recv_
$LN13@soap_recv_:

; 1157 :       while ((int)c != EOF && c != '\n')

	cmp	ebx, -1
	je	$LN64@soap_recv_
$LL12@soap_recv_:
	cmp	ebx, 10					; 0000000aH
	je	SHORT $LN11@soap_recv_

; 1158 :         c = soap_getchunkchar(soap);

	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN96@soap_recv_
	mov	eax, DWORD PTR [esi+12312]
	push	65536					; 00010000H
	lea	edx, DWORD PTR [esi+12468]
	push	edx
	push	esi
	mov	DWORD PTR [esi+12428], ebp
	call	eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+87316], eax
	mov	DWORD PTR [esi+12432], eax
	cmp	eax, ebp
	je	$LN64@soap_recv_
	mov	eax, DWORD PTR [esi+12428]
$LN96@soap_recv_:
	movsx	ebx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
	cmp	ebx, -1
	jne	SHORT $LL12@soap_recv_

; 1157 :       while ((int)c != EOF && c != '\n')

	jmp	$LN64@soap_recv_
$LN11@soap_recv_:

; 1159 :       if ((int)c == EOF)
; 1160 :         return soap->ahead = EOF;
; 1161 :       *t = '\0';

	mov	ecx, DWORD PTR _t$78590[esp+32]

; 1162 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Chunk size = %s (hex)\n", tmp));
; 1163 :       soap->chunksize = soap_strtoul(tmp, &t, 16);

	push	16					; 00000010H
	lea	edx, DWORD PTR _t$78590[esp+36]
	push	edx
	lea	eax, DWORD PTR _tmp$78591[esp+40]
	push	eax
	mov	BYTE PTR [ecx], 0
	call	_strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+87312], eax

; 1164 :       if (!soap->chunksize)

	cmp	eax, ebp
	je	$LN66@soap_recv_

; 1171 : 	break;
; 1172 :       }
; 1173 :       soap->buflen = soap->bufidx + soap->chunksize;

	mov	edx, DWORD PTR [esi+12428]

; 1174 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Moving buf len to idx=%u len=%u (%s)\n", (unsigned int)soap->bufidx, (unsigned int)soap->buflen, tmp));
; 1175 :       if (soap->buflen > soap->chunkbuflen)

	mov	ecx, DWORD PTR [esi+87316]
	lea	edi, DWORD PTR [edx+eax]
	mov	DWORD PTR [esi+12432], edi
	cmp	edi, ecx
	jbe	SHORT $LN6@soap_recv_

; 1176 :       { soap->buflen = soap->chunkbuflen;
; 1177 :         soap->chunksize -= soap->buflen - soap->bufidx;

	mov	edi, edx
	sub	edi, ecx
	add	edi, eax
	mov	DWORD PTR [esi+12432], ecx
	mov	DWORD PTR [esi+87312], edi

; 1178 :         soap->chunkbuflen = 0;

	mov	DWORD PTR [esi+87316], ebp
	jmp	SHORT $LN4@soap_recv_
$LN6@soap_recv_:

; 1179 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Passed end of buffer for chunked HTTP (%u bytes left)\n", (unsigned int)(soap->buflen - soap->bufidx)));
; 1180 :       }
; 1181 :       else if (soap->chunkbuflen)

	cmp	ecx, ebp
	je	SHORT $LN4@soap_recv_

; 1182 :         soap->chunksize = 0;

	mov	DWORD PTR [esi+87312], ebp
$LN4@soap_recv_:

; 1183 :       ret = soap->buflen - soap->bufidx;

	mov	edi, DWORD PTR [esi+12432]
	sub	edi, edx

; 1184 :       if (ret)

	jne	$LN2@soap_recv_

; 1126 :   { for (;;)
; 1127 :     { register soap_wchar c;
; 1128 :       char *t, tmp[8];
; 1129 :       if (soap->chunksize)

	cmp	DWORD PTR [esi+87312], ebp
	je	$LL25@soap_recv_
$LN63@soap_recv_:

; 1130 :       { soap->buflen = ret = soap->frecv(soap, soap->buf, soap->chunksize > SOAP_BUFLEN ? SOAP_BUFLEN : soap->chunksize);

	mov	eax, DWORD PTR [esi+87312]
	cmp	eax, 65536				; 00010000H
	jbe	SHORT $LN29@soap_recv_
	mov	eax, 65536				; 00010000H
$LN29@soap_recv_:
	mov	edx, DWORD PTR [esi+12312]
	push	eax
	lea	ecx, DWORD PTR [esi+12468]
	push	ecx
	push	esi
	call	edx
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1131 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Getting chunk: read %u bytes\n", (unsigned int)ret));
; 1132 :         DBGMSG(RECV, soap->buf, ret);
; 1133 :         soap->bufidx = 0;
; 1134 :         soap->chunksize -= ret;

	sub	DWORD PTR [esi+87312], edi
	mov	DWORD PTR [esi+12428], ebp

; 1135 :         break;

	jmp	SHORT $LN97@soap_recv_
$LN66@soap_recv_:

; 1165 :       { soap->chunkbuflen = 0;

	mov	DWORD PTR [esi+87316], ebp
$LL8@soap_recv_:

; 1166 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End of chunked message\n"));
; 1167 :         while ((int)c != EOF && c != '\n')

	cmp	ebx, 10					; 0000000aH
	je	SHORT $LN7@soap_recv_

; 1168 :           c = soap_getchunkchar(soap);

	call	_soap_getchunkchar
	mov	ebx, eax
	cmp	ebx, -1
	jne	SHORT $LL8@soap_recv_
$LN7@soap_recv_:

; 1169 :         ret = 0;

	xor	edi, edi

; 1170 :         soap->ahead = EOF;

	mov	DWORD PTR [esi+12436], -1

; 1185 :         break;
; 1186 :     }
; 1187 :   }
; 1188 :   else

	jmp	SHORT $LN2@soap_recv_
$LN26@soap_recv_:

; 1189 : #endif
; 1190 :   { soap->bufidx = 0;
; 1191 :     soap->buflen = ret = soap->frecv(soap, soap->buf, SOAP_BUFLEN);

	mov	ecx, DWORD PTR [esi+12312]
	push	65536					; 00010000H
	lea	eax, DWORD PTR [esi+12468]
	push	eax
	push	esi
	mov	DWORD PTR [esi+12428], 0
	call	ecx
	add	esp, 12					; 0000000cH
	mov	edi, eax
	xor	ebp, ebp
$LN97@soap_recv_:
	mov	DWORD PTR [esi+12432], edi
$LN2@soap_recv_:

; 1192 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Read %u bytes from socket %d\n", (unsigned int)ret, soap->socket));
; 1193 :     DBGMSG(RECV, soap->buf, ret);
; 1194 :   }
; 1195 : #ifndef WITH_LEANER
; 1196 :   if (soap->fpreparerecv && (soap->error = soap->fpreparerecv(soap, soap->buf, ret)))

	mov	eax, DWORD PTR [esi+12348]
	cmp	eax, ebp
	je	SHORT $LN1@soap_recv_
	push	edi
	lea	edx, DWORD PTR [esi+12468]
	push	edx
	push	esi
	call	eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+90460], eax
	cmp	eax, ebp

; 1197 :     return soap->error;

	jne	SHORT $LN27@soap_recv_
$LN1@soap_recv_:

; 1198 : #endif
; 1199 : #ifdef WITH_ZLIB
; 1200 :   if (soap->mode & SOAP_ENC_ZLIB)
; 1201 :   { register int r;
; 1202 :     memcpy(soap->z_buf, soap->buf, SOAP_BUFLEN);
; 1203 :     soap->d_stream->next_in = (Byte*)(soap->z_buf + soap->bufidx);
; 1204 :     soap->d_stream->avail_in = (unsigned int)ret;
; 1205 :     soap->d_stream->next_out = (Byte*)soap->buf;
; 1206 :     soap->d_stream->avail_out = SOAP_BUFLEN;
; 1207 :     r = inflate(soap->d_stream, Z_NO_FLUSH);
; 1208 :     if (r == Z_OK || r == Z_STREAM_END)
; 1209 :     { soap->bufidx = 0;
; 1210 :       soap->z_buflen = soap->buflen;
; 1211 :       soap->buflen = SOAP_BUFLEN - soap->d_stream->avail_out;
; 1212 :       if (soap->zlib_in == SOAP_ZLIB_GZIP)
; 1213 :         soap->z_crc = crc32(soap->z_crc, (Byte*)soap->buf, (unsigned int)soap->buflen);
; 1214 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflated %u bytes\n", (unsigned int)soap->buflen));
; 1215 :       if (ret && !soap->buflen)
; 1216 :         goto zlib_again;
; 1217 :       ret = soap->buflen;
; 1218 :       if (r == Z_STREAM_END)
; 1219 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflated total %lu->%lu bytes\n", soap->d_stream->total_in, soap->d_stream->total_out));
; 1220 :         soap->z_ratio_in = (float)soap->d_stream->total_in / (float)soap->d_stream->total_out;
; 1221 :         soap->d_stream->next_out = Z_NULL;
; 1222 :       }
; 1223 :       DBGLOG(RECV, SOAP_MESSAGE(fdebug, "\n---- decompressed ----\n"));
; 1224 :       DBGMSG(RECV, soap->buf, ret);
; 1225 :     }
; 1226 :     else
; 1227 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unable to inflate: (%d) %s\n", r, soap->d_stream->msg?soap->d_stream->msg:""));
; 1228 :       soap->d_stream->next_out = Z_NULL;
; 1229 :       soap->error = SOAP_ZLIB_ERROR;
; 1230 :       return EOF;
; 1231 :     }
; 1232 :   }
; 1233 : #endif
; 1234 :   soap->count += ret;

	add	DWORD PTR [esi+12448], edi

; 1235 :   return !ret;

	xor	eax, eax
	cmp	edi, ebp
	sete	al
$LN27@soap_recv_:

; 1236 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 16					; 00000010H
	ret	0
_soap_recv_raw ENDP
_TEXT	ENDS
PUBLIC	_soap_send
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_send PROC
; _s$ = edx

; 816  : { if (s)

	test	edx, edx
	je	SHORT $LN1@soap_send

; 817  :     return soap_send_raw(soap, s, strlen(s));

	mov	eax, edx
	push	esi
	lea	esi, DWORD PTR [eax+1]
	npad	6
$LL4@soap_send:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL4@soap_send
	sub	eax, esi
	push	eax
	mov	eax, DWORD PTR _soap$[esp+4]
	push	edx
	call	_soap_send_raw
	add	esp, 8
	pop	esi

; 819  : }

	ret	0
$LN1@soap_send:

; 818  :   return SOAP_OK;

	xor	eax, eax

; 819  : }

	ret	0
_soap_send ENDP
PUBLIC	??0soap@@QAE@AAU0@@Z				; soap::soap
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
??0soap@@QAE@AAU0@@Z PROC				; soap::soap
; _this$ = ecx
; _soap$ = eax

; 14877: { soap_copy_context(this, &soap);

	push	esi
	mov	esi, ecx
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7soap@@6B@
	call	_soap_copy_context
	add	esp, 4

; 14878: }

	mov	eax, esi
	pop	esi
	ret	0
??0soap@@QAE@AAU0@@Z ENDP				; soap::soap
_TEXT	ENDS
PUBLIC	_soap_response
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_count$ = 8						; size = 4
_status$ = 8						; size = 4
_soap_response PROC
; _soap$ = eax

; 14139: { register size_t count;

	push	ebp
	mov	ebp, DWORD PTR _status$[esp]
	push	esi
	mov	esi, eax

; 14140:   if (!(soap->omode & (SOAP_ENC_XML | SOAP_IO_STORE /* this tests for chunking too */))
; 14141:    && (status == SOAP_HTML || status == SOAP_FILE))

	mov	eax, DWORD PTR [esi+16]
	test	al, 66					; 00000042H
	jne	SHORT $LN8@soap_respo
	cmp	ebp, 1002				; 000003eaH
	je	SHORT $LN7@soap_respo
	cmp	ebp, 1003				; 000003ebH
	jne	SHORT $LN8@soap_respo
$LN7@soap_respo:

; 14142:   { soap->omode &= ~SOAP_IO;

	and	eax, -2					; fffffffeH

; 14143:     soap->omode |= SOAP_IO_STORE;

	or	eax, 2
	mov	DWORD PTR [esi+16], eax
$LN8@soap_respo:

; 14144:   }
; 14145:   soap->status = status;
; 14146:   count = soap_count_attachments(soap);

	push	esi
	mov	DWORD PTR [esi+90456], ebp
	call	_soap_count_attachments
	add	esp, 4
	mov	DWORD PTR _count$[esp+4], eax

; 14147:   if (soap_begin_send(soap))

	call	_soap_begin_send
	test	eax, eax
	je	SHORT $LN6@soap_respo

; 14148:     return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	esi
	pop	ebp

; 14167: }

	ret	0
$LN6@soap_respo:
	push	ebx

; 14149: #ifndef WITH_NOHTTP
; 14150:   if ((soap->mode & SOAP_IO) != SOAP_IO_STORE && !(soap->mode & SOAP_ENC_XML))

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	and	al, 3
	push	edi
	cmp	al, 2
	je	SHORT $LN5@soap_respo
	test	bl, 64					; 00000040H
	jne	SHORT $LN5@soap_respo

; 14151:   { register int n = soap->mode;
; 14152:     soap->mode &= ~(SOAP_IO | SOAP_ENC_ZLIB);

	mov	eax, ebx
	and	eax, -1028				; fffffbfcH

; 14153:     if ((n & SOAP_IO) != SOAP_IO_FLUSH)

	mov	edi, ebx
	and	edi, 3
	mov	DWORD PTR [esi+8], eax
	je	SHORT $LN4@soap_respo

; 14154:       soap->mode |= SOAP_IO_BUFFER;

	or	eax, 1
	mov	DWORD PTR [esi+8], eax
$LN4@soap_respo:

; 14155:     if ((soap->error = soap->fresponse(soap, status, count)))

	mov	ecx, DWORD PTR _count$[esp+12]
	mov	edx, DWORD PTR [esi+12260]
	push	ecx
	push	ebp
	push	esi
	call	edx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax

; 14156:       return soap->error;

	jne	SHORT $LN11@soap_respo

; 14157: #ifndef WITH_LEANER
; 14158:     if ((n & SOAP_IO) == SOAP_IO_CHUNK)

	cmp	edi, 3
	jne	SHORT $LN1@soap_respo

; 14159:     { if (soap_flush(soap))

	mov	eax, esi
	call	_soap_flush
	test	eax, eax
	je	SHORT $LN1@soap_respo

; 14160:         return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 14167: }

	ret	0
$LN1@soap_respo:

; 14161:     }
; 14162: #endif
; 14163:     soap->mode = n;

	mov	DWORD PTR [esi+8], ebx
$LN5@soap_respo:

; 14164:   }
; 14165: #endif
; 14166:   return SOAP_OK;

	xor	eax, eax
$LN11@soap_respo:
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 14167: }

	ret	0
_soap_response ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_key$ = 12						; size = 4
_val$ = 16						; size = 4
_http_post_header PROC

; 14044: { if (key)

	mov	eax, DWORD PTR _key$[esp-4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp]
	push	edi
	test	eax, eax
	je	SHORT $LN2@http_post_

; 14045:   { if (http_send_header(soap, key))

	push	esi
	call	_http_send_header
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@http_post_
$LN1@http_post_:

; 14046:       return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	esi

; 14051: }

	ret	0
$LN3@http_post_:

; 14047:     if (val && (soap_send_raw(soap, ": ", 2) || http_send_header(soap, val)))

	mov	edi, DWORD PTR _val$[esp+4]
	test	edi, edi
	je	SHORT $LN2@http_post_
	push	2
	push	OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@http_post_
	push	esi
	mov	eax, edi
	call	_http_send_header
	add	esp, 4
	test	eax, eax

; 14048:       return soap->error;

	jne	SHORT $LN1@http_post_
$LN2@http_post_:

; 14049:   }
; 14050:   return soap_send_raw(soap, "\r\n", 2);

	push	2
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	pop	edi
	pop	esi

; 14051: }

	ret	0
_http_post_header ENDP
; Function compile flags: /Ogtpy
_s$ = 8						; size = 4
_soap$ = 8						; size = 4
_endpoint$ = 12						; size = 4
_host$ = 16						; size = 4
_port$ = 20						; size = 4
_path$ = 24						; size = 4
_action$ = 28						; size = 4
_count$ = 32						; size = 4
_http_post PROC

; 13942: { register const char *s;

	push	ebp
	push	esi

; 13943:   register int err;
; 13944:   if (soap->status == SOAP_GET)

	mov	esi, DWORD PTR _soap$[esp+4]
	cmp	DWORD PTR [esi+90456], 2001		; 000007d1H

; 13945:     s = "GET";

	mov	DWORD PTR _s$[esp+4], OFFSET ??_C@_03HAPOJHBM@GET?$AA@
	je	SHORT $LN18@http_post

; 13946:   else
; 13947:     s = "POST";

	mov	DWORD PTR _s$[esp+4], OFFSET ??_C@_04HCJEIHPL@POST?$AA@
$LN18@http_post:

; 13948: #ifdef PALM
; 13949:   if (!endpoint || (soap_tag_cmp(endpoint, "http:*") && soap_tag_cmp(endpoint, "https:*") && strncmp(endpoint, "httpg:", 6)) && strncmp(endpoint, "_beam:", 6) && strncmp(endpoint, "_local:", 7) && strncmp(endpoint, "_btobex:", 8))
; 13950: #else
; 13951:   if (!endpoint || (soap_tag_cmp(endpoint, "http:*") && soap_tag_cmp(endpoint, "https:*") && strncmp(endpoint, "httpg:", 6)))

	mov	ebp, DWORD PTR _endpoint$[esp+4]
	test	ebp, ebp
	je	$LN16@http_post
	push	OFFSET ??_C@_06GLIDCHCJ@http?3?$CK?$AA@
	push	ebp
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@http_post
	push	OFFSET ??_C@_07NHIIGDKE@https?3?$CK?$AA@
	push	ebp
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@http_post
	push	6
	push	OFFSET ??_C@_06EFCFIIJL@httpg?3?$AA@
	push	ebp
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN16@http_post
$LN17@http_post:

; 13954:   if (strlen(endpoint) + strlen(soap->http_version) > sizeof(soap->tmpbuf) - 80)

	mov	eax, ebp
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL28@http_post:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL28@http_post
	push	ebx
	mov	ebx, DWORD PTR [esi+32]
	mov	ecx, ebx
	push	edi
	sub	eax, edx
	lea	edi, DWORD PTR [ecx+1]
$LL29@http_post:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL29@http_post
	sub	ecx, edi
	add	ecx, eax
	cmp	ecx, 944				; 000003b0H
	jbe	SHORT $LN15@http_post

; 13955:     return soap->error = SOAP_EOM;

	mov	eax, 20					; 00000014H
	mov	DWORD PTR [esi+90460], eax
$LN44@http_post:
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 14016: }

	ret	0
$LN15@http_post:

; 13956:   if (soap->proxy_host && soap_tag_cmp(endpoint, "https:*"))

	cmp	DWORD PTR [esi+90436], 0
	je	SHORT $LN14@http_post
	push	OFFSET ??_C@_07NHIIGDKE@https?3?$CK?$AA@
	push	ebp
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@http_post

; 13957:     sprintf(soap->tmpbuf, "%s %s HTTP/%s", s, endpoint, soap->http_version);

	mov	eax, DWORD PTR _s$[esp+12]
	push	ebx
	push	ebp
	push	eax
	push	OFFSET ??_C@_0O@FAODEEBC@?$CFs?5?$CFs?5HTTP?1?$CFs?$AA@

; 13958:   else

	jmp	SHORT $LN46@http_post
$LN14@http_post:

; 13959:     sprintf(soap->tmpbuf, "%s /%s HTTP/%s", s, (*path == '/' ? path + 1 : path), soap->http_version);

	mov	eax, DWORD PTR _path$[esp+12]
	cmp	BYTE PTR [eax], 47			; 0000002fH
	jne	SHORT $LN22@http_post
	inc	eax
$LN22@http_post:
	mov	ecx, DWORD PTR _s$[esp+12]
	push	ebx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0P@PENEPKMC@?$CFs?5?1?$CFs?5HTTP?1?$CFs?$AA@
$LN46@http_post:
	lea	edi, DWORD PTR [esi+79028]
	push	edi
	call	_sprintf

; 13960:   if ((err = soap->fposthdr(soap, soap->tmpbuf, NULL)))

	mov	edx, DWORD PTR [esi+12256]
	add	esp, 20					; 00000014H
	push	0
	push	edi
	push	esi
	call	edx
	add	esp, 12					; 0000000cH
	test	eax, eax

; 13961:     return err;

	jne	SHORT $LN44@http_post

; 13962: #ifdef WITH_OPENSSL
; 13963:   if ((soap->ssl && soap->port != 443) || (!soap->ssl && soap->port != 80))
; 13964:     sprintf(soap->tmpbuf, "%s:%d", host, port);
; 13965:   else
; 13966:     strcpy(soap->tmpbuf, host);
; 13967: #else
; 13968:   if (port != 80)

	mov	eax, DWORD PTR _port$[esp+12]
	cmp	eax, 80					; 00000050H
	je	SHORT $LN11@http_post

; 13969:     sprintf(soap->tmpbuf, "%s:%d", host, port);

	push	eax
	mov	eax, DWORD PTR _host$[esp+16]
	push	eax
	push	OFFSET ??_C@_05HKPGCKL@?$CFs?3?$CFd?$AA@
	push	edi
	call	_sprintf
	add	esp, 16					; 00000010H

; 13970:   else

	jmp	SHORT $LN10@http_post
$LN11@http_post:

; 13971:     strcpy(soap->tmpbuf, host);

	mov	eax, DWORD PTR _host$[esp+12]
	mov	edx, edi
	sub	edx, eax
	npad	2
$LL24@http_post:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL24@http_post
$LN10@http_post:

; 13972: #endif
; 13973:   if ((err = soap->fposthdr(soap, "Host", soap->tmpbuf))
; 13974:    || (err = soap->fposthdr(soap, "User-Agent", "gSOAP/2.7"))
; 13975:    || (err = soap_puthttphdr(soap, SOAP_OK, count)))

	mov	ecx, DWORD PTR [esi+12256]
	push	edi
	push	OFFSET ??_C@_04CPPPJGME@Host?$AA@
	push	esi
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN44@http_post
	mov	edx, DWORD PTR [esi+12256]
	push	OFFSET ??_C@_09MBLJBAGJ@gSOAP?12?47?$AA@
	push	OFFSET ??_C@_0L@DMPACEMJ@User?9Agent?$AA@
	push	esi
	call	edx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN44@http_post
	mov	eax, DWORD PTR _count$[esp+12]
	push	eax
	push	esi
	xor	eax, eax
	call	_soap_puthttphdr
	add	esp, 8
	test	eax, eax
	jne	$LN44@http_post

; 13976:     return err;
; 13977: #ifdef WITH_ZLIB
; 13978: #ifdef WITH_GZIP
; 13979:   if ((err = soap->fposthdr(soap, "Accept-Encoding", "gzip, deflate")))
; 13980: #else
; 13981:   if ((err = soap->fposthdr(soap, "Accept-Encoding", "deflate")))
; 13982: #endif
; 13983:     return err;
; 13984: #endif
; 13985: #ifndef WITH_LEAN
; 13986:   if (soap->userid && soap->passwd && strlen(soap->userid) + strlen(soap->passwd) < 761)

	mov	eax, DWORD PTR [esi+12224]
	test	eax, eax
	je	$LN38@http_post
	mov	edx, DWORD PTR [esi+12228]
	test	edx, edx
	je	$LN38@http_post
	lea	ebx, DWORD PTR [eax+1]
	npad	7
$LL30@http_post:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL30@http_post
	sub	eax, ebx
	mov	ebx, eax
	mov	eax, edx
	lea	ebp, DWORD PTR [eax+1]
$LL31@http_post:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL31@http_post
	sub	eax, ebp
	add	eax, ebx
	cmp	eax, 761				; 000002f9H
	jae	SHORT $LN38@http_post

; 13987:   { sprintf(soap->tmpbuf + 262, "%s:%s", soap->userid, soap->passwd);

	mov	eax, DWORD PTR [esi+12224]
	push	edx
	push	eax
	lea	ebx, DWORD PTR [esi+79290]
	push	OFFSET ??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@
	push	ebx
	call	_sprintf

; 13988:     strcpy(soap->tmpbuf, "Basic ");

	mov	ecx, DWORD PTR ??_C@_06FFOGOLGD@Basic?5?$AA@
	mov	DWORD PTR [edi], ecx
	mov	dx, WORD PTR ??_C@_06FFOGOLGD@Basic?5?$AA@+4
	mov	WORD PTR [edi+4], dx
	mov	al, BYTE PTR ??_C@_06FFOGOLGD@Basic?5?$AA@+6
	mov	BYTE PTR [edi+6], al

; 13989:     soap_s2base64(soap, (const unsigned char*)(soap->tmpbuf + 262), soap->tmpbuf + 6, (int)strlen(soap->tmpbuf + 262));

	mov	eax, ebx
	add	esp, 16					; 00000010H
	lea	ebp, DWORD PTR [eax+1]
	npad	2
$LL32@http_post:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL32@http_post
	sub	eax, ebp
	push	eax
	lea	eax, DWORD PTR [esi+79034]
	push	ebx
	mov	ecx, esi
	call	_soap_s2base64

; 13990:     if ((err = soap->fposthdr(soap, "Authorization", soap->tmpbuf)))

	mov	ecx, DWORD PTR [esi+12256]
	push	edi
	push	OFFSET ??_C@_0O@NAFGPKMI@Authorization?$AA@
	push	esi
	call	ecx
	add	esp, 20					; 00000014H
	test	eax, eax

; 13991:       return err;

	jne	$LN44@http_post
$LN38@http_post:

; 13992:   }
; 13993:   if (soap->proxy_userid && soap->proxy_passwd && strlen(soap->proxy_userid) + strlen(soap->proxy_passwd) < 761)

	mov	eax, DWORD PTR [esi+90444]
	test	eax, eax
	je	$LN37@http_post
	mov	edx, DWORD PTR [esi+90448]
	test	edx, edx
	je	$LN37@http_post
	lea	ebx, DWORD PTR [eax+1]
$LL33@http_post:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL33@http_post
	sub	eax, ebx
	mov	ebx, eax
	mov	eax, edx
	lea	ebp, DWORD PTR [eax+1]
$LL34@http_post:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL34@http_post
	sub	eax, ebp
	add	eax, ebx
	cmp	eax, 761				; 000002f9H
	jae	SHORT $LN37@http_post

; 13994:   { sprintf(soap->tmpbuf + 262, "%s:%s", soap->proxy_userid, soap->proxy_passwd);

	mov	eax, DWORD PTR [esi+90444]
	push	edx
	push	eax
	lea	ebx, DWORD PTR [esi+79290]
	push	OFFSET ??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@
	push	ebx
	call	_sprintf

; 13995:     strcpy(soap->tmpbuf, "Basic ");

	mov	edx, DWORD PTR ??_C@_06FFOGOLGD@Basic?5?$AA@
	mov	DWORD PTR [edi], edx
	mov	ax, WORD PTR ??_C@_06FFOGOLGD@Basic?5?$AA@+4
	mov	WORD PTR [edi+4], ax
	mov	cl, BYTE PTR ??_C@_06FFOGOLGD@Basic?5?$AA@+6

; 13996:     soap_s2base64(soap, (const unsigned char*)(soap->tmpbuf + 262), soap->tmpbuf + 6, (int)strlen(soap->tmpbuf + 262));

	mov	eax, ebx
	add	esp, 16					; 00000010H
	mov	BYTE PTR [edi+6], cl
	lea	ebp, DWORD PTR [eax+1]
	npad	1
$LL35@http_post:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL35@http_post
	sub	eax, ebp
	push	eax
	lea	eax, DWORD PTR [esi+79034]
	push	ebx
	mov	ecx, esi
	call	_soap_s2base64

; 13997:     if ((err = soap->fposthdr(soap, "Proxy-Authorization", soap->tmpbuf)))

	mov	edx, DWORD PTR [esi+12256]
	push	edi
	push	OFFSET ??_C@_0BE@DCLKKIPG@Proxy?9Authorization?$AA@
	push	esi
	call	edx
	add	esp, 20					; 00000014H
	test	eax, eax

; 13998:       return err;

	jne	$LN44@http_post
$LN37@http_post:

; 13999:   }
; 14000: #endif
; 14001: #ifdef WITH_COOKIES
; 14002: #ifdef WITH_OPENSSL
; 14003:   if (soap_putcookies(soap, host, path, soap->ssl != NULL))
; 14004:     return soap->error;
; 14005: #else
; 14006:   if (soap_putcookies(soap, host, path, 0))
; 14007:     return soap->error;
; 14008: #endif
; 14009: #endif
; 14010:   if (soap->status != SOAP_GET && (soap->version == 1 || (action && *action && strlen(action) < sizeof(soap->tmpbuf) - 2)))

	cmp	DWORD PTR [esi+90456], 2001		; 000007d1H
	je	SHORT $LN43@http_post
	cmp	WORD PTR [esi+6], 1
	mov	edx, DWORD PTR _action$[esp+12]
	je	SHORT $LN42@http_post
	test	edx, edx
	je	SHORT $LN43@http_post
	cmp	BYTE PTR [edx], 0
	je	SHORT $LN43@http_post
	mov	eax, edx
	lea	ebx, DWORD PTR [eax+1]
$LL36@http_post:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL36@http_post
	sub	eax, ebx
	cmp	eax, 1022				; 000003feH
	jae	SHORT $LN43@http_post
$LN42@http_post:

; 14011:   { sprintf(soap->tmpbuf, "\"%s\"", action?action:"");

	mov	eax, edx
	test	edx, edx
	jne	SHORT $LN26@http_post
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN26@http_post:
	push	eax
	push	OFFSET ??_C@_04OEDFLLKD@?$CC?$CFs?$CC?$AA@
	push	edi
	call	_sprintf

; 14012:     if ((err = soap->fposthdr(soap, "SOAPAction", soap->tmpbuf)))

	mov	eax, DWORD PTR [esi+12256]
	push	edi
	push	OFFSET ??_C@_0L@BIMPHKBC@SOAPAction?$AA@
	push	esi
	call	eax
	add	esp, 24					; 00000018H
	test	eax, eax

; 14013:       return err;

	jne	$LN44@http_post
$LN43@http_post:

; 14014:   }
; 14015:   return soap->fposthdr(soap, NULL, NULL);

	mov	ecx, DWORD PTR [esi+12256]
	push	0
	push	0
	push	esi
	call	ecx
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 14016: }

	ret	0
$LN16@http_post:
	pop	esi

; 13952: #endif
; 13953:     return SOAP_OK;

	xor	eax, eax
	pop	ebp

; 14016: }

	ret	0
_http_post ENDP
_TEXT	ENDS
PUBLIC	_soap_set_mime_attachment
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_set_mime_attachment PROC
; _soap$ = eax

; 11885: { struct soap_multipart *content = soap_new_multipart(soap, &soap->mime.first, &soap->mime.last, ptr, size);

	push	ebx
	push	esi
	push	edi
	mov	edi, eax
	mov	eax, 36					; 00000024H
	call	_soap_malloc
	mov	esi, eax
	xor	ebx, ebx
	cmp	esi, ebx
	je	SHORT $LN9@soap_set_m@2
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+28], ebx
	mov	DWORD PTR [esi+32], ebx
	cmp	DWORD PTR [edi+90536], ebx
	jne	SHORT $LN5@soap_set_m@2
	mov	DWORD PTR [edi+90536], esi
$LN5@soap_set_m@2:
	mov	eax, DWORD PTR [edi+90540]
	cmp	eax, ebx
	je	SHORT $LN4@soap_set_m@2
	mov	DWORD PTR [eax], esi
$LN4@soap_set_m@2:

; 11888:   content->id = soap_strdup(soap, id);

	push	ebx
	push	edi
	mov	DWORD PTR [edi+90540], esi
	call	_soap_strdup

; 11889:   content->type = soap_strdup(soap, type);

	push	ebx
	push	edi
	mov	DWORD PTR [esi+12], eax
	call	_soap_strdup

; 11890:   content->encoding = encoding;
; 11891:   content->location = soap_strdup(soap, location);

	push	ebx
	push	edi
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+24], ebx
	call	_soap_strdup

; 11892:   content->description = soap_strdup(soap, description);

	push	ebx
	push	edi
	mov	DWORD PTR [esi+28], eax
	call	_soap_strdup
	add	esp, 32					; 00000020H
	pop	edi
	mov	DWORD PTR [esi+32], eax
	pop	esi

; 11893:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 11894: }

	ret	0
$LN9@soap_set_m@2:
	pop	edi
	pop	esi

; 11886:   if (!content)
; 11887:     return SOAP_EOM;

	mov	eax, 20					; 00000014H
	pop	ebx

; 11894: }

	ret	0
_soap_set_mime_attachment ENDP
_TEXT	ENDS
PUBLIC	_soap_set_dime_attachment
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_size$ = 12						; size = 4
_type$ = 16						; size = 4
_id$ = 20						; size = 4
_optype$ = 24						; size = 2
_option$ = 28						; size = 4
_soap_set_dime_attachment PROC
; _soap$ = eax

; 11867: { struct soap_multipart *content = soap_new_multipart(soap, &soap->dime.first, &soap->dime.last, ptr, size);

	push	esi
	push	edi
	mov	edi, eax
	mov	eax, 36					; 00000024H
	call	_soap_malloc
	mov	esi, eax
	xor	eax, eax
	cmp	esi, eax
	je	SHORT $LN9@soap_set_d
	mov	ecx, DWORD PTR _ptr$[esp+4]
	mov	edx, DWORD PTR _size$[esp+4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	cmp	DWORD PTR [edi+90516], eax
	jne	SHORT $LN5@soap_set_d
	mov	DWORD PTR [edi+90516], esi
$LN5@soap_set_d:
	mov	ecx, DWORD PTR [edi+90520]
	cmp	ecx, eax
	je	SHORT $LN4@soap_set_d
	mov	DWORD PTR [ecx], esi
$LN4@soap_set_d:

; 11870:   content->id = soap_strdup(soap, id);

	mov	eax, DWORD PTR _id$[esp+4]
	push	eax
	push	edi
	mov	DWORD PTR [edi+90520], esi
	call	_soap_strdup

; 11871:   content->type = soap_strdup(soap, type);

	mov	ecx, DWORD PTR _type$[esp+12]
	push	ecx
	push	edi
	mov	DWORD PTR [esi+12], eax
	call	_soap_strdup

; 11872:   content->options = soap_dime_option(soap, optype, option);

	mov	edx, DWORD PTR _option$[esp+20]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR _optype$[esp+20]
	push	edx
	push	eax
	push	edi
	call	_soap_dime_option
	add	esp, 28					; 0000001cH
	mov	DWORD PTR [esi+20], eax
	pop	edi

; 11873:   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 11874: }

	ret	0
$LN9@soap_set_d:
	pop	edi

; 11868:   if (!content)
; 11869:     return SOAP_EOM;

	mov	eax, 20					; 00000014H
	pop	esi

; 11874: }

	ret	0
_soap_set_dime_attachment ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_soap_putdimehdr
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_typelen$ = -24						; size = 4
_idlen$ = -20						; size = 4
_tmp$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_soap_putdimehdr PROC
; _soap$ = esi

; 11081: { unsigned char tmp[12];

	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+24], eax
	push	ebx

; 11082:   size_t optlen = 0, idlen = 0, typelen = 0;

	xor	ebx, ebx
	push	edi
	mov	DWORD PTR _idlen$[esp+32], ebx
	mov	DWORD PTR _typelen$[esp+32], ebx

; 11083:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Put DIME header id='%s'\n", soap->dime.id?soap->dime.id:""));
; 11084:   if (soap->dime.options)

	cmp	DWORD PTR [esi+90508], ebx
	je	SHORT $LN7@soap_putdi

; 11085:     optlen = (((unsigned char)soap->dime.options[2] << 8) | ((unsigned char)soap->dime.options[3])) + 4;

	mov	eax, DWORD PTR [esi+90508]
	movzx	ebx, BYTE PTR [eax+2]
	movzx	eax, BYTE PTR [eax+3]
	shl	ebx, 8
	or	ebx, eax
	add	ebx, 4
$LN7@soap_putdi:

; 11086:   if (soap->dime.id)

	mov	eax, DWORD PTR [esi+90500]
	mov	edi, 65535				; 0000ffffH
	test	eax, eax
	je	SHORT $LN21@soap_putdi

; 11087:   { idlen = strlen(soap->dime.id);

	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL19@soap_putdi:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL19@soap_putdi
	sub	eax, edx
	mov	DWORD PTR _idlen$[esp+32], eax

; 11088:     if (idlen > 0x0000FFFF)

	cmp	eax, edi
	jbe	SHORT $LN21@soap_putdi

; 11089:       idlen = 0x0000FFFF;

	mov	DWORD PTR _idlen$[esp+32], edi
$LN21@soap_putdi:

; 11090:   }
; 11091:   if (soap->dime.type)

	mov	eax, DWORD PTR [esi+90504]
	test	eax, eax
	je	SHORT $LN22@soap_putdi

; 11092:   { typelen = strlen(soap->dime.type);

	lea	edx, DWORD PTR [eax+1]
$LL20@soap_putdi:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL20@soap_putdi
	sub	eax, edx
	mov	DWORD PTR _typelen$[esp+32], eax

; 11093:     if (typelen > 0x0000FFFF)

	cmp	eax, edi
	jbe	SHORT $LN22@soap_putdi

; 11094:       typelen = 0x0000FFFF;

	mov	DWORD PTR _typelen$[esp+32], edi
$LN22@soap_putdi:

; 11095:   }
; 11096:   tmp[0] = SOAP_DIME_VERSION | (soap->dime.flags & 0x7);

	mov	al, BYTE PTR [esi+90492]
	mov	cl, al

; 11097:   tmp[1] = soap->dime.flags & 0xF0;

	and	al, 240					; 000000f0H
	and	cl, 7
	or	cl, 8
	mov	BYTE PTR _tmp$[esp+33], al

; 11098:   tmp[2] = (char)(optlen >> 8);
; 11099:   tmp[3] = (char)(optlen & 0xFF);
; 11100:   tmp[4] = (char)(idlen >> 8);

	mov	eax, DWORD PTR _idlen$[esp+32]
	mov	BYTE PTR _tmp$[esp+32], cl
	mov	ecx, eax

; 11101:   tmp[5] = (char)(idlen & 0xFF);

	mov	BYTE PTR _tmp$[esp+37], al

; 11102:   tmp[6] = (char)(typelen >> 8);

	mov	eax, DWORD PTR _typelen$[esp+32]
	mov	edx, ebx
	shr	edx, 8
	mov	BYTE PTR _tmp$[esp+34], dl
	mov	edx, eax

; 11103:   tmp[7] = (char)(typelen & 0xFF);

	mov	BYTE PTR _tmp$[esp+39], al

; 11104:   tmp[8] = (char)(soap->dime.size >> 24);

	movzx	eax, BYTE PTR [esi+90483]
	shr	ecx, 8
	mov	BYTE PTR _tmp$[esp+36], cl

; 11105:   tmp[9] = (char)((soap->dime.size >> 16) & 0xFF);

	mov	cl, BYTE PTR [esi+90482]
	mov	BYTE PTR _tmp$[esp+40], al

; 11106:   tmp[10] = (char)((soap->dime.size >> 8) & 0xFF);
; 11107:   tmp[11] = (char)(soap->dime.size & 0xFF);

	movzx	eax, BYTE PTR [esi+90480]
	shr	edx, 8
	mov	BYTE PTR _tmp$[esp+41], cl
	mov	BYTE PTR _tmp$[esp+38], dl
	mov	dl, BYTE PTR [esi+90481]

; 11108:   if (soap_send_raw(soap, (char*)tmp, 12)
; 11109:    || soap_putdimefield(soap, soap->dime.options, optlen)
; 11110:    || soap_putdimefield(soap, soap->dime.id, idlen)
; 11111:    || soap_putdimefield(soap, soap->dime.type, typelen))

	lea	ecx, DWORD PTR _tmp$[esp+32]
	mov	BYTE PTR _tmp$[esp+43], al
	push	12					; 0000000cH
	push	ecx
	mov	eax, esi
	mov	BYTE PTR _tmp$[esp+43], bl
	mov	BYTE PTR _tmp$[esp+50], dl
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	$LN1@soap_putdi
	mov	eax, DWORD PTR [esi+90508]
	push	ebx
	push	eax
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@soap_putdi
	mov	eax, DWORD PTR [esi+90460]
	jmp	SHORT $LN11@soap_putdi
$LN10@soap_putdi:
	neg	ebx
	and	ebx, 3
	push	ebx
	push	OFFSET _soap_padding
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
$LN11@soap_putdi:
	test	eax, eax
	jne	$LN1@soap_putdi
	mov	eax, DWORD PTR [esi+90500]
	mov	edi, DWORD PTR _idlen$[esp+32]
	push	edi
	push	eax
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@soap_putdi
	mov	eax, DWORD PTR [esi+90460]
	jmp	SHORT $LN14@soap_putdi
$LN13@soap_putdi:
	neg	edi
	and	edi, 3
	push	edi
	push	OFFSET _soap_padding
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
$LN14@soap_putdi:
	test	eax, eax
	jne	SHORT $LN1@soap_putdi
	mov	eax, DWORD PTR [esi+90504]
	mov	edi, DWORD PTR _typelen$[esp+32]
	push	edi
	push	eax
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@soap_putdi
	mov	eax, DWORD PTR [esi+90460]
	jmp	SHORT $LN17@soap_putdi
$LN16@soap_putdi:
	neg	edi
	and	edi, 3
	push	edi
	push	OFFSET _soap_padding
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
$LN17@soap_putdi:
	test	eax, eax
	jne	SHORT $LN1@soap_putdi
	pop	edi
	pop	ebx

; 11112:     return soap->error;
; 11113:   return SOAP_OK;
; 11114: }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+24]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 24					; 00000018H
	ret	0
$LN1@soap_putdi:
	mov	ecx, DWORD PTR __$ArrayPad$[esp+32]
	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 24					; 00000018H
	ret	0
_soap_putdimehdr ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_soap_s2dateTime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_m$82728 = -80						; size = 4
_h$82727 = -76						; size = 4
_T$82704 = -72						; size = 36
_zone$82705 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_soap_s2dateTime PROC
; _s$ = esi
; _p$ = edi

; 10663: { if (s)

	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+80], eax
	push	ebx
	xor	ebx, ebx
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+84]
	cmp	esi, ebx
	je	$LN29@soap_s2dat

; 10664:   { struct tm T;
; 10665:     char zone[32];
; 10666:     const char *t;
; 10667:     memset((void*)&T, 0, sizeof(T));

	pxor	xmm0, xmm0

; 10668:     zone[sizeof(zone)-1] = '\0';
; 10669:     if (strchr(s, '-'))

	push	45					; 0000002dH
	push	esi
	movq	QWORD PTR _T$82704[esp+96], xmm0
	movq	QWORD PTR _T$82704[esp+104], xmm0
	movq	QWORD PTR _T$82704[esp+112], xmm0
	movq	QWORD PTR _T$82704[esp+120], xmm0
	mov	DWORD PTR _T$82704[esp+128], ebx
	mov	BYTE PTR _zone$82705[esp+127], bl
	call	_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@soap_s2dat

; 10670:       t = "%d-%d-%dT%d:%d:%d%31s";

	mov	eax, OFFSET ??_C@_0BG@CNJMEEAL@?$CFd?9?$CFd?9?$CFdT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@
	jmp	SHORT $LN17@soap_s2dat
$LN20@soap_s2dat:

; 10671:     else if (strchr(s, ':'))

	push	58					; 0000003aH
	push	esi
	call	_strchr
	add	esp, 8
	test	eax, eax

; 10672:       t = "%4d%2d%2dT%d:%d:%d%31s";

	mov	eax, OFFSET ??_C@_0BH@OJGJFHHH@?$CF4d?$CF2d?$CF2dT?$CFd?3?$CFd?3?$CFd?$CF31s?$AA@
	jne	SHORT $LN17@soap_s2dat

; 10673:     else /* parse non-XSD-standard alternative ISO 8601 format */
; 10674:       t = "%4d%2d%2dT%2d%2d%2d%31s";

	mov	eax, OFFSET ??_C@_0BI@KJDFMOL@?$CF4d?$CF2d?$CF2dT?$CF2d?$CF2d?$CF2d?$CF31s?$AA@
$LN17@soap_s2dat:

; 10675:     sscanf(s, t, &T.tm_year, &T.tm_mon, &T.tm_mday, &T.tm_hour, &T.tm_min, &T.tm_sec, zone);

	lea	ecx, DWORD PTR _zone$82705[esp+88]
	push	ecx
	lea	edx, DWORD PTR _T$82704[esp+92]
	push	edx
	lea	ecx, DWORD PTR _T$82704[esp+100]
	push	ecx
	lea	edx, DWORD PTR _T$82704[esp+108]
	push	edx
	lea	ecx, DWORD PTR _T$82704[esp+116]
	push	ecx
	lea	edx, DWORD PTR _T$82704[esp+124]
	push	edx
	lea	ecx, DWORD PTR _T$82704[esp+132]
	push	ecx
	push	eax
	push	esi
	call	_sscanf

; 10676:     if (T.tm_year == 1)

	mov	edx, 1
	add	esp, 36					; 00000024H
	cmp	DWORD PTR _T$82704[esp+108], edx
	jne	SHORT $LN16@soap_s2dat

; 10677:       T.tm_year = 70;

	mov	DWORD PTR _T$82704[esp+108], 70		; 00000046H

; 10678:     else

	jmp	SHORT $LN15@soap_s2dat
$LN16@soap_s2dat:

; 10679:       T.tm_year -= 1900;

	sub	DWORD PTR _T$82704[esp+108], 1900	; 0000076cH
$LN15@soap_s2dat:

; 10680:     T.tm_mon--;
; 10681:     if (*zone)

	mov	al, BYTE PTR _zone$82705[esp+88]
	sub	DWORD PTR _T$82704[esp+104], edx
	cmp	al, bl
	je	$LN14@soap_s2dat

; 10682:     { if (*zone == '.')

	cmp	al, 46					; 0000002eH
	jne	SHORT $LN13@soap_s2dat

; 10683:       { for (s = zone + 1; *s; s++)

	mov	cl, BYTE PTR _zone$82705[esp+89]
	lea	eax, DWORD PTR _zone$82705[esp+89]
	cmp	cl, bl
	je	SHORT $LN7@soap_s2dat
	npad	5
$LL12@soap_s2dat:

; 10684:           if (*s < '0' || *s > '9')

	cmp	cl, 48					; 00000030H
	jl	SHORT $LN7@soap_s2dat
	cmp	cl, 57					; 00000039H
	jg	SHORT $LN7@soap_s2dat
	mov	cl, BYTE PTR [eax+edx]
	add	eax, edx
	cmp	cl, bl
	jne	SHORT $LL12@soap_s2dat

; 10685:             break;
; 10686:       }
; 10687:       else

	jmp	SHORT $LN7@soap_s2dat
$LN13@soap_s2dat:

; 10688:         s = zone;

	lea	eax, DWORD PTR _zone$82705[esp+88]
$LN7@soap_s2dat:

; 10689:       if (*s == '+' || *s == '-')

	mov	cl, BYTE PTR [eax]
	cmp	cl, 43					; 0000002bH
	je	SHORT $LN5@soap_s2dat
	cmp	cl, 45					; 0000002dH
	jne	SHORT $LN6@soap_s2dat
$LN5@soap_s2dat:

; 10690:       { int h = 0, m = 0;
; 10691:         if (s[3] == ':')

	cmp	BYTE PTR [eax+3], 58			; 0000003aH
	mov	DWORD PTR _h$82727[esp+88], ebx
	mov	DWORD PTR _m$82728[esp+88], ebx
	jne	SHORT $LN4@soap_s2dat

; 10692:         { sscanf(s, "%d:%d", &h, &m);

	lea	edx, DWORD PTR _m$82728[esp+88]
	push	edx
	lea	ecx, DWORD PTR _h$82727[esp+92]
	push	ecx
	push	OFFSET ??_C@_05NFGPCJDJ@?$CFd?3?$CFd?$AA@
	push	eax
	call	_sscanf

; 10693:           if (h < 0)

	mov	eax, DWORD PTR _h$82727[esp+104]

; 10694:             m = -m;

	mov	ecx, DWORD PTR _m$82728[esp+104]
	add	esp, 16					; 00000010H
	cmp	eax, ebx
	jge	SHORT $LN2@soap_s2dat
	neg	ecx

; 10695:         }
; 10696:         else

	jmp	SHORT $LN2@soap_s2dat
$LN4@soap_s2dat:

; 10697:         { m = (int)atol(s);

	push	eax
	call	_atol
	mov	ecx, eax

; 10698:           h = m / 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 10699:           m = m % 100;

	mov	edx, eax
	imul	edx, -100				; ffffff9cH
	add	esp, 4
	add	ecx, edx
$LN2@soap_s2dat:

; 10700:         }
; 10701:         T.tm_hour -= h;

	sub	DWORD PTR _T$82704[esp+96], eax

; 10702:         T.tm_min -= m;

	sub	DWORD PTR _T$82704[esp+92], ecx
$LN6@soap_s2dat:

; 10703:       }
; 10704:       T.tm_isdst = 0;
; 10705:       *p = soap_timegm(&T);

	lea	eax, DWORD PTR _T$82704[esp+88]
	mov	DWORD PTR _T$82704[esp+120], ebx
	call	_soap_timegm

; 10706:     }
; 10707:     else

	jmp	SHORT $LN31@soap_s2dat
$LN14@soap_s2dat:

; 10708:     { T.tm_isdst = -1;
; 10709:       *p = mktime(&T); /* no time zone: suppose it is localtime? */

	lea	eax, DWORD PTR _T$82704[esp+88]
	push	eax
	mov	DWORD PTR _T$82704[esp+124], -1
	call	__mktime64
	add	esp, 4
$LN31@soap_s2dat:
	mov	DWORD PTR [edi+4], edx
	mov	DWORD PTR [edi], eax
$LN29@soap_s2dat:

; 10710:     }
; 10711:   }
; 10712:   return soap->error;

	mov	eax, DWORD PTR [ebp+90460]

; 10713: }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+88]
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 80					; 00000050H
	ret	0
_soap_s2dateTime ENDP
; Function compile flags: /Ogtpy
_soap_isnumeric PROC
; _soap$ = esi
; _type$ = eax

; 9594 : { if (soap_match_tag(soap, soap->type, type)

	push	ebx
	push	edi

; 9595 :    && soap_match_tag(soap, soap->type, ":float")
; 9596 :    && soap_match_tag(soap, soap->type, ":double")
; 9597 :    && soap_match_tag(soap, soap->type, ":decimal")
; 9598 :    && soap_match_tag(soap, soap->type, ":integer")
; 9599 :    && soap_match_tag(soap, soap->type, ":positiveInteger")
; 9600 :    && soap_match_tag(soap, soap->type, ":negativeInteger")
; 9601 :    && soap_match_tag(soap, soap->type, ":nonPositiveInteger")
; 9602 :    && soap_match_tag(soap, soap->type, ":nonNegativeInteger")
; 9603 :    && soap_match_tag(soap, soap->type, ":long")
; 9604 :    && soap_match_tag(soap, soap->type, ":int")
; 9605 :    && soap_match_tag(soap, soap->type, ":short")
; 9606 :    && soap_match_tag(soap, soap->type, ":byte")
; 9607 :    && soap_match_tag(soap, soap->type, ":unsignedLong")
; 9608 :    && soap_match_tag(soap, soap->type, ":unsignedInt")
; 9609 :    && soap_match_tag(soap, soap->type, ":unsignedShort")
; 9610 :    && soap_match_tag(soap, soap->type, ":unsignedByte"))

	lea	ebx, DWORD PTR [esi+83124]
	push	ebx
	push	esi
	mov	edi, eax
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_06INOMFGCG@?3float?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_07PBNBEHML@?3double?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_08HMJFKOLE@?3decimal?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_08ICEBEHNK@?3integer?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BB@NDNOKOEA@?3positiveInteger?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BB@FHGJHLHJ@?3negativeInteger?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BE@HIKONPMJ@?3nonPositiveInteger?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BE@PMBJAKPA@?3nonNegativeInteger?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_05LMKOBMME@?3long?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_04JNHIEKJE@?3int?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_06DFBHHOOH@?3short?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_05FFGLOOMC@?3byte?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0O@FKBEEKGD@?3unsignedLong?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0N@EEHCOMNL@?3unsignedInt?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_isnum
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_isnum

; 9611 :   { soap->error = SOAP_TYPE;
; 9612 :     soap_revert(soap);

	mov	eax, esi
	mov	DWORD PTR [esi+90460], 4
	call	_soap_revert
	pop	edi

; 9613 :     return SOAP_ERR;

	or	eax, -1
	pop	ebx

; 9616 : }

	ret	0
$LN1@soap_isnum:
	pop	edi

; 9614 :   }
; 9615 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 9616 : }

	ret	0
_soap_isnumeric ENDP
_TEXT	ENDS
PUBLIC	_soap_attr_value
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_flag$ = 12						; size = 4
_soap_attr_value PROC
; _name$ = eax

; 7671 : { register struct soap_attribute *tp;

	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	ebp
	mov	ebp, DWORD PTR _flag$[esp+4]
	push	edi
	mov	edi, eax

; 7672 :   if (*name == '-')

	cmp	BYTE PTR [edi], 45			; 0000002dH
	jne	SHORT $LN10@soap_attr_
	pop	edi
	pop	ebp

; 7673 :     return SOAP_STR_EOS;

	mov	eax, OFFSET _soap_padding
	pop	ebx

; 7687 : }

	ret	0
$LN10@soap_attr_:
	push	esi

; 7674 :   for (tp = soap->attributes; tp; tp = tp->next)

	mov	esi, DWORD PTR [ebx+87292]
	test	esi, esi
	je	SHORT $LN5@soap_attr_
$LL9@soap_attr_:

; 7675 :   { if (tp->visible && !soap_match_tag(soap, tp->name, name))

	cmp	WORD PTR [esi+16], 0
	je	SHORT $LN8@soap_attr_
	lea	eax, DWORD PTR [esi+18]
	push	eax
	push	ebx
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@soap_attr_
$LN8@soap_attr_:

; 7674 :   for (tp = soap->attributes; tp; tp = tp->next)

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL9@soap_attr_
$LN5@soap_attr_:

; 7683 :   }
; 7684 :   else if (flag == 1 && (soap->mode & SOAP_XML_STRICT))

	cmp	ebp, 1
	jne	SHORT $LN1@soap_attr_
	test	DWORD PTR [ebx+8], 4096			; 00001000H
	je	SHORT $LN1@soap_attr_

; 7685 :     soap->error = SOAP_REQUIRED;

	mov	DWORD PTR [ebx+90460], 42		; 0000002aH
$LN1@soap_attr_:
	pop	esi
	pop	edi
	pop	ebp

; 7686 :   return NULL;

	xor	eax, eax
	pop	ebx

; 7687 : }

	ret	0
$LN14@soap_attr_:

; 7676 :       break;
; 7677 :   }
; 7678 :   if (tp)
; 7679 :   { if (flag == 2 && (soap->mode & SOAP_XML_STRICT))

	cmp	ebp, 2
	jne	SHORT $LN4@soap_attr_
	test	DWORD PTR [ebx+8], 4096			; 00001000H
	je	SHORT $LN4@soap_attr_
	pop	esi
	pop	edi
	pop	ebp

; 7680 :       soap->error = SOAP_PROHIBITED;

	mov	DWORD PTR [ebx+90460], 43		; 0000002bH

; 7686 :   return NULL;

	xor	eax, eax
	pop	ebx

; 7687 : }

	ret	0
$LN4@soap_attr_:

; 7681 :     else
; 7682 :       return tp->value;

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	pop	edi
	pop	ebp
	pop	ebx

; 7687 : }

	ret	0
_soap_attr_value ENDP
_TEXT	ENDS
PUBLIC	_soap_element_end_out
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_element_end_out PROC
; _soap$ = eax
; _tag$ = esi

; 7358 : { if (*tag == '-')

	cmp	BYTE PTR [esi], 45			; 0000002dH
	push	edi
	mov	edi, eax
	jne	SHORT $LN7@soap_eleme

; 7359 :     return SOAP_OK;

	xor	eax, eax
	pop	edi

; 7392 : }

	ret	0
$LN7@soap_eleme:

; 7360 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Element ending tag='%s'\n", tag));
; 7361 : #ifdef WITH_DOM
; 7362 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 7363 :   { if (soap->dom->prnt)
; 7364 :       soap->dom = soap->dom->prnt;
; 7365 :     return SOAP_OK;
; 7366 :   }
; 7367 : #endif
; 7368 : #ifndef WITH_LEAN
; 7369 :   if (soap->mode & SOAP_XML_CANONICAL)

	test	DWORD PTR [edi+8], 16384		; 00004000H
	je	SHORT $LN6@soap_eleme

; 7370 :     soap_pop_ns(soap);

	call	_soap_pop_ns
$LN6@soap_eleme:

; 7371 :   if (soap->mode & SOAP_XML_INDENT)

	test	DWORD PTR [edi+8], 8192			; 00002000H
	je	SHORT $LN5@soap_eleme

; 7372 :   { if (!soap->body)

	cmp	WORD PTR [edi+12442], 0
	jne	SHORT $LN3@soap_eleme

; 7373 :     { if (soap_send_raw(soap, soap_indent, soap->level < sizeof(soap_indent) ? soap->level : sizeof(soap_indent) - 1))

	mov	eax, DWORD PTR [edi+12444]
	cmp	eax, 11					; 0000000bH
	jb	SHORT $LN11@soap_eleme
	mov	eax, 10					; 0000000aH
$LN11@soap_eleme:
	push	eax
	push	OFFSET _soap_indent
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax

; 7374 :         return soap->error;

	jne	SHORT $LN1@soap_eleme
$LN3@soap_eleme:

; 7375 :     }
; 7376 :     soap->body = 0;

	xor	eax, eax
	mov	WORD PTR [edi+12442], ax
$LN5@soap_eleme:

; 7377 :   }
; 7378 : #endif
; 7379 : #ifdef WITH_XMLNS
; 7380 :   { const char *s = strchr(tag, ':');
; 7381 :     if (s && strncmp(tag, "SOAP-ENV", s - tag))
; 7382 :     { soap_pop_ns(soap);
; 7383 :       tag = s + 1;
; 7384 :     }
; 7385 :   }
; 7386 : #endif
; 7387 :   if (soap_send_raw(soap, "</", 2)
; 7388 :    || soap_send(soap, tag))

	push	2
	push	OFFSET ??_C@_02DPNDACHE@?$DM?1?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@soap_eleme
	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$LL15@soap_eleme:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL15@soap_eleme
	sub	eax, edx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@soap_eleme

; 7390 :   soap->level--;	/* decrement level just before > */

	dec	DWORD PTR [edi+12444]

; 7391 :   return soap_send_raw(soap, ">", 1);

	push	1
	push	OFFSET ??_C@_01PPODPGHN@?$DO?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	pop	edi

; 7392 : }

	ret	0
$LN1@soap_eleme:

; 7389 :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi

; 7392 : }

	ret	0
_soap_element_end_out ENDP
; Function compile flags: /Ogtpy
_tag$ = 8						; size = 4
_soap_utilize_ns PROC
; _soap$ = esi
; _n$ = eax

; 6909 : { register struct soap_nlist *np = soap_lookup_ns(soap, tag, n);

	push	ebp
	mov	ebp, DWORD PTR _tag$[esp]
	push	edi
	mov	edi, eax
	push	ebp
	mov	eax, esi
	call	_soap_lookup_ns
	add	esp, 4

; 6910 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Utilizing namespace of '%s'\n", tag));
; 6911 :   if (np)

	test	eax, eax
	je	SHORT $LN4@soap_utili

; 6912 :   { if (np->index == 0)

	cmp	WORD PTR [eax+8], 0
	jne	SHORT $LN1@soap_utili

; 6913 :       soap_push_ns(soap, np->id, np->ns, 1);

	mov	ecx, DWORD PTR [eax+12]
	push	1
	push	ecx
	add	eax, 16					; 00000010H
	push	eax
	push	esi
	call	_soap_push_ns
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebp

; 6919 :   }
; 6920 : }

	ret	0
$LN4@soap_utili:

; 6914 :   }
; 6915 :   else if (strncmp(tag, "xml", 3))

	push	3
	push	OFFSET ??_C@_03PJHHNEEI@xml?$AA@
	push	ebp
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_utili
	push	ebx

; 6916 :   { strncpy(soap->tmpbuf, tag, n);

	push	edi
	lea	ebx, DWORD PTR [esi+79028]
	push	ebp
	push	ebx
	call	_strncpy

; 6917 :     soap->tmpbuf[n] = '\0';
; 6918 :     soap_push_ns(soap, soap->tmpbuf, NULL, 1);

	push	1
	push	0
	push	ebx
	push	esi
	mov	BYTE PTR [esi+edi+79028], 0
	call	_soap_push_ns
	add	esp, 28					; 0000001cH
	pop	ebx
$LN1@soap_utili:
	pop	edi
	pop	ebp

; 6919 :   }
; 6920 : }

	ret	0
_soap_utilize_ns ENDP
_TEXT	ENDS
PUBLIC	_soap_end
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_end PROC
; _soap$ = eax

; 6718 : { if (soap_check_state(soap))

	push	esi
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN3@soap_end
	movzx	eax, WORD PTR [esi+4]
	cmp	ax, 1
	je	SHORT $LN4@soap_end
	cmp	ax, 2
	jne	SHORT $LN3@soap_end
$LN4@soap_end:

; 6719 :     return;
; 6720 :   soap_free_temp(soap);

	call	_soap_free_temp

; 6721 :   soap_dealloc(soap, NULL);

	call	_soap_dealloc

; 6722 :   while (soap->clist)

	cmp	DWORD PTR [esi+96], 0
	je	SHORT $LN1@soap_end
	push	edi
$LL2@soap_end:

; 6723 :   { register struct soap_clist *cp = soap->clist->next;

	mov	eax, DWORD PTR [esi+96]
	mov	edi, DWORD PTR [eax]

; 6724 :     SOAP_FREE(soap, soap->clist);

	push	eax
	call	_free
	add	esp, 4

; 6725 :     soap->clist = cp;

	mov	DWORD PTR [esi+96], edi
	test	edi, edi
	jne	SHORT $LL2@soap_end
	pop	edi
$LN1@soap_end:

; 6726 :   }
; 6727 :   soap_closesock(soap);

	call	_soap_closesock
$LN3@soap_end:
	pop	esi

; 6728 : #ifdef SOAP_DEBUG
; 6729 :   soap_close_logfiles(soap);
; 6730 : #endif
; 6731 : #ifdef PALM
; 6732 :   palmNetLibClose();
; 6733 : #endif
; 6734 : }

	ret	0
_soap_end ENDP
_TEXT	ENDS
PUBLIC	_soap_begin
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_begin PROC
; _soap$ = eax

; 6681 : { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Reinitializing context\n"));

	push	esi
	mov	esi, eax

; 6682 :   if (!soap->keep_alive)

	xor	eax, eax
	cmp	WORD PTR [esi+90412], ax
	jne	SHORT $LN1@soap_begin@3

; 6683 :   { soap->buflen = 0;

	mov	DWORD PTR [esi+12432], eax

; 6684 :     soap->bufidx = 0;

	mov	DWORD PTR [esi+12428], eax
$LN1@soap_begin@3:

; 6685 :   }
; 6686 :   soap->keep_alive = (((soap->imode | soap->omode) & SOAP_IO_KEEPALIVE) != 0);

	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+12]
	shr	edx, 4
	shr	ecx, 4
	or	ecx, edx

; 6687 :   soap->null = 0;
; 6688 :   soap->position = 0;

	xor	edx, edx
	mov	WORD PTR [esi+87222], dx

; 6689 :   soap->encoding = 0;
; 6690 :   soap->mustUnderstand = 0;

	mov	WORD PTR [esi+87298], dx
	and	ecx, 1

; 6691 :   soap->mode = 0;
; 6692 :   soap->ns = 0;
; 6693 :   soap->part = SOAP_END;

	mov	edx, 9
	mov	WORD PTR [esi+90412], cx
	xor	ecx, ecx
	mov	WORD PTR [esi+87304], dx

; 6694 :   soap->alloced = 0;
; 6695 :   soap->count = 0;
; 6696 :   soap->length = 0;
; 6697 :   soap->cdata = 0;

	xor	edx, edx
	mov	WORD PTR [esi+87300], cx
	mov	WORD PTR [esi+87296], cx
	mov	DWORD PTR [esi+8], eax
	mov	WORD PTR [esi+87302], cx
	mov	WORD PTR [esi+87306], cx
	mov	DWORD PTR [esi+12448], eax
	mov	DWORD PTR [esi+12452], eax
	mov	WORD PTR [esi+12440], dx

; 6698 :   soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], eax

; 6699 :   soap->peeked = 0;

	mov	WORD PTR [esi+87308], cx

; 6700 :   soap->ahead = 0;

	mov	DWORD PTR [esi+12436], eax

; 6701 :   soap->idnum = 0;

	mov	DWORD PTR [esi+12212], eax

; 6702 :   soap->level = 0;

	mov	DWORD PTR [esi+12444], eax

; 6703 :   soap->endpoint[0] = '\0';

	mov	BYTE PTR [esi+87320], al

; 6704 : #ifndef WITH_LEANER
; 6705 :   soap->dime.chunksize = 0;

	mov	DWORD PTR [esi+90484], eax

; 6706 :   soap->dime.buflen = 0;

	mov	DWORD PTR [esi+90488], eax

; 6707 : #endif
; 6708 :   soap_free_temp(soap);

	call	_soap_free_temp
	pop	esi

; 6709 : }

	ret	0
_soap_begin ENDP
_TEXT	ENDS
PUBLIC	_soap_id_enter
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_t$ = 16						; size = 4
_n$ = 20						; size = 4
_type$ = 24						; size = 4
_arrayType$ = 28					; size = 4
_soap_id_enter PROC
; _id$ = ecx
; _finstantiate$ = eax

; 5855 : {

	push	ebx
	mov	ebx, DWORD PTR _t$[esp]
	push	ebp
	mov	ebp, DWORD PTR _p$[esp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+12]
	mov	esi, ecx

; 5856 : #ifndef WITH_NOIDREF
; 5857 :   struct soap_ilist *ip;
; 5858 : #endif
; 5859 :   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Enter id='%s' type=%d loc=%p size=%lu level=%u\n", id, t, p, (unsigned long)n, k));
; 5860 :   soap->alloced = 0;

	xor	ecx, ecx
	mov	WORD PTR [edi+87306], cx

; 5861 :   if (!p)

	test	ebp, ebp
	jne	SHORT $LN21@soap_id_en

; 5862 :   { if (finstantiate)

	test	eax, eax
	je	SHORT $LN13@soap_id_en

; 5863 :       p = finstantiate(soap, t, type, arrayType, &n);

	mov	ecx, DWORD PTR _arrayType$[esp+12]
	lea	edx, DWORD PTR _n$[esp+12]
	push	edx
	mov	edx, DWORD PTR _type$[esp+16]
	push	ecx
	push	edx
	push	ebx
	push	edi
	call	eax
	add	esp, 20					; 00000014H

; 5864 :     else

	jmp	SHORT $LN24@soap_id_en
$LN13@soap_id_en:

; 5865 :       p = soap_malloc(soap, n);

	mov	eax, DWORD PTR _n$[esp+12]
	call	_soap_malloc
$LN24@soap_id_en:
	mov	ebp, eax

; 5866 :     if (p)

	test	ebp, ebp
	je	SHORT $LN21@soap_id_en

; 5867 :       soap->alloced = 1;

	mov	eax, 1
	mov	WORD PTR [edi+87306], ax
$LN21@soap_id_en:

; 5868 :   }
; 5869 : #ifndef WITH_NOIDREF
; 5870 :   if (!id || !*id)

	test	esi, esi
	je	$LN9@soap_id_en
	cmp	BYTE PTR [esi], 0
	je	$LN9@soap_id_en

; 5873 : #ifndef WITH_NOIDREF
; 5874 :   ip = soap_lookup(soap, id); /* lookup pointer to hash table entry for string id */

	push	edi
	call	_soap_lookup
	add	esp, 4

; 5875 :   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Lookup entry id='%s for location=%p'\n", id, p));
; 5876 :   if (!ip)

	test	eax, eax
	jne	SHORT $LN8@soap_id_en

; 5877 :   { ip = soap_enter(soap, id); /* new hash table entry for string id */

	push	esi
	push	edi
	call	_soap_enter
	add	esp, 8

; 5878 :     ip->type = t;
; 5879 :     ip->link = NULL;

	xor	edx, edx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+12], edx

; 5880 :     ip->copy = NULL;

	mov	DWORD PTR [eax+16], edx

; 5881 :     ip->flist = NULL;

	mov	DWORD PTR [eax+20], edx

; 5882 :     ip->size = n;

	mov	ecx, DWORD PTR _n$[esp+12]
	mov	DWORD PTR [eax+8], ecx
	pop	edi

; 5883 :     ip->ptr = p;

	lea	ecx, DWORD PTR [eax+24]

; 5884 :     ip->level = k;

	mov	DWORD PTR [eax+28], edx
	pop	esi

; 5901 :     ip->ptr = p;

	mov	DWORD PTR [ecx], ebp

; 5903 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Update entry id='%s' type=%d location=%p size=%lu level=%u\n", id, t, p, (unsigned long)n, k));
; 5904 :   }
; 5905 :   return ip->ptr;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 5906 : #endif
; 5907 : }

	ret	0
$LN8@soap_id_en:

; 5885 :     DBGLOG(TEST,SOAP_MESSAGE(fdebug, "New entry id='%s' type=%d size=%lu level=%u location=%p\n", id, t, (unsigned long)n, k, p));
; 5886 :   }
; 5887 :   else if ((ip->type != t || (ip->level == k && ip->size != n)) && (ip->copy || ip->flist))

	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN22@soap_id_en
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN23@soap_id_en
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR _n$[esp+12]
	je	SHORT $LN23@soap_id_en
$LN22@soap_id_en:
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN4@soap_id_en
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN4@soap_id_en
$LN23@soap_id_en:

; 5892 :   }
; 5893 :   else if (ip->ptr)

	cmp	DWORD PTR [eax+24], 0
	lea	ecx, DWORD PTR [eax+24]
	je	SHORT $LN2@soap_id_en

; 5894 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Multiply defined id='%s'\n", id));
; 5895 :     strcpy(soap->id, id);

	lea	edx, DWORD PTR [edi+81076]
	mov	eax, esi
	sub	edx, esi
$LL18@soap_id_en:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL18@soap_id_en

; 5896 :     soap->error = SOAP_DUPLICATE_ID;

	mov	DWORD PTR [edi+90460], 24		; 00000018H
	pop	edi
	pop	esi
	pop	ebp

; 5897 :     return NULL;

	xor	eax, eax
	pop	ebx

; 5906 : #endif
; 5907 : }

	ret	0
$LN2@soap_id_en:

; 5898 :   }
; 5899 :   else
; 5900 :   { ip->size = n;

	mov	edx, DWORD PTR _n$[esp+12]
	pop	edi
	mov	DWORD PTR [eax+8], edx

; 5902 :     ip->level = k;

	mov	DWORD PTR [eax+28], 0
	pop	esi
	mov	DWORD PTR [ecx], ebp

; 5903 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Update entry id='%s' type=%d location=%p size=%lu level=%u\n", id, t, p, (unsigned long)n, k));
; 5904 :   }
; 5905 :   return ip->ptr;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 5906 : #endif
; 5907 : }

	ret	0
$LN4@soap_id_en:

; 5888 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Type incompatibility id='%s' expect type=%d size=%lu level=%u got type=%d size=%lu\n", id, ip->type, (unsigned long)ip->size, k, t, (unsigned long)n));
; 5889 :     strcpy(soap->id, id);

	lea	edx, DWORD PTR [edi+81076]
	mov	eax, esi
	sub	edx, esi
$LL17@soap_id_en:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL17@soap_id_en

; 5890 :     soap->error = SOAP_HREF;

	mov	DWORD PTR [edi+90460], 26		; 0000001aH
	pop	edi
	pop	esi
	pop	ebp

; 5891 :     return NULL;

	xor	eax, eax
	pop	ebx

; 5906 : #endif
; 5907 : }

	ret	0
$LN9@soap_id_en:
	pop	edi
	pop	esi

; 5871 : #endif
; 5872 :     return p;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 5906 : #endif
; 5907 : }

	ret	0
_soap_id_enter ENDP
_TEXT	ENDS
PUBLIC	_soap_id_forward
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_len$ = 16						; size = 4
_st$ = 20						; size = 4
_tt$ = 24						; size = 4
_n$ = 28						; size = 4
_fcopy$ = 32						; size = 4
_soap_id_forward PROC
; _href$ = eax

; 5800 : { struct soap_ilist *ip;

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _p$[esp+4]

; 5801 :   if (!p || !href || !*href)

	xor	ebx, ebx
	push	esi
	mov	esi, eax
	cmp	ebp, ebx
	je	$LN11@soap_id_fo
	cmp	esi, ebx
	je	$LN11@soap_id_fo
	cmp	BYTE PTR [esi], bl
	je	$LN11@soap_id_fo

; 5803 :   ip = soap_lookup(soap, href); /* lookup pointer to hash table entry for string id */

	mov	eax, DWORD PTR _soap$[esp+8]
	push	edi
	push	eax
	call	_soap_lookup
	mov	edi, eax
	add	esp, 4

; 5804 :   if (!ip)

	cmp	edi, ebx
	jne	SHORT $LN10@soap_id_fo

; 5805 :   { ip = soap_enter(soap, href); /* new hash table entry for string id */

	mov	ecx, DWORD PTR _soap$[esp+12]
	push	esi
	push	ecx
	call	_soap_enter

; 5806 :     ip->type = st;

	mov	edx, DWORD PTR _st$[esp+20]
	mov	edi, eax

; 5807 :     ip->size = n;

	mov	eax, DWORD PTR _n$[esp+20]
	add	esp, 8
	mov	DWORD PTR [edi+4], edx
	mov	DWORD PTR [edi+8], eax

; 5808 :     ip->link = NULL;

	mov	DWORD PTR [edi+12], ebx

; 5809 :     ip->copy = NULL;

	mov	DWORD PTR [edi+16], ebx

; 5810 :     ip->ptr = NULL;

	mov	DWORD PTR [edi+24], ebx

; 5811 :     ip->level = 0;

	mov	DWORD PTR [edi+28], ebx

; 5812 :     ip->flist = NULL;

	mov	DWORD PTR [edi+20], ebx
	jmp	SHORT $LN17@soap_id_fo
$LN10@soap_id_fo:

; 5813 :     DBGLOG(TEST,SOAP_MESSAGE(fdebug, "New entry href='%s' type=%d size=%lu level=%d location=%p\n", href, st, (unsigned long)n, k, p));
; 5814 :   }
; 5815 :   else if (ip->type != st || (ip->level == k && ip->size != n))

	mov	ecx, DWORD PTR _st$[esp+12]
	cmp	DWORD PTR [edi+4], ecx
	jne	$LN7@soap_id_fo
	cmp	DWORD PTR [edi+28], ebx
	jne	SHORT $LN17@soap_id_fo
	mov	edx, DWORD PTR _n$[esp+12]
	cmp	DWORD PTR [edi+8], edx
	jne	$LN7@soap_id_fo
$LN17@soap_id_fo:

; 5819 :     return NULL;
; 5820 :   }
; 5821 :   if (fcopy || n < sizeof(void*) || *href != '#')

	cmp	DWORD PTR _fcopy$[esp+12], ebx
	jne	SHORT $LN5@soap_id_fo
	cmp	DWORD PTR _n$[esp+12], 4
	jb	SHORT $LN5@soap_id_fo
	cmp	BYTE PTR [esi], 35			; 00000023H
	jne	SHORT $LN5@soap_id_fo

; 5837 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Forwarding type=%d (target type=%d) size=%lu location=%p level=%u len=%lu href='%s'\n", st, tt, (unsigned long)n, p, k, (unsigned long)len, href));
; 5838 :   }
; 5839 :   else
; 5840 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Forwarding copying address %p for type=%d href='%s'\n", p, st, href));
; 5841 :     *(void**)p = ip->copy;

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [ebp], eax

; 5842 :     ip->copy = p;

	mov	DWORD PTR [edi+16], ebp
	pop	edi
	pop	esi

; 5843 :   }
; 5844 :   return p;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 5845 : }

	ret	0
$LN5@soap_id_fo:

; 5822 :   { register struct soap_flist *fp = (struct soap_flist*)SOAP_MALLOC(soap, sizeof(struct soap_flist));

	push	24					; 00000018H
	call	_malloc
	add	esp, 4

; 5823 :     if (!fp)

	cmp	eax, ebx
	jne	SHORT $LN4@soap_id_fo

; 5824 :     { soap->error = SOAP_EOM;

	mov	ecx, DWORD PTR _soap$[esp+12]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+90460], 20		; 00000014H

; 5825 :       return NULL;

	xor	eax, eax
	pop	ebx

; 5845 : }

	ret	0
$LN4@soap_id_fo:

; 5826 :     }
; 5827 :     fp->next = ip->flist;

	mov	edx, DWORD PTR [edi+20]

; 5828 :     fp->type = tt;

	mov	ecx, DWORD PTR _tt$[esp+12]
	mov	DWORD PTR [eax+4], ecx

; 5829 :     fp->ptr = p;
; 5830 :     fp->level = k;
; 5831 :     fp->len = len;
; 5832 :     if (fcopy)

	mov	ecx, DWORD PTR _fcopy$[esp+12]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR _len$[esp+12]
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], edx
	cmp	ecx, ebx
	je	SHORT $LN3@soap_id_fo

; 5833 :       fp->fcopy = fcopy;

	mov	DWORD PTR [eax+20], ecx

; 5836 :     ip->flist = fp;

	mov	DWORD PTR [edi+20], eax
	pop	edi
	pop	esi

; 5843 :   }
; 5844 :   return p;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 5845 : }

	ret	0
$LN3@soap_id_fo:

; 5834 :     else
; 5835 :       fp->fcopy = soap_fcopy;

	mov	DWORD PTR [eax+20], OFFSET _soap_fcopy

; 5836 :     ip->flist = fp;

	mov	DWORD PTR [edi+20], eax
	pop	edi
	pop	esi

; 5843 :   }
; 5844 :   return p;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 5845 : }

	ret	0
$LN7@soap_id_fo:

; 5816 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Type incompatibility id='%s' expect type=%d size=%lu level=%u got type=%d size=%lu\n", href, ip->type, (unsigned long)ip->size, k, st, (unsigned long)n));
; 5817 :     strcpy(soap->id, href);

	mov	edi, DWORD PTR _soap$[esp+12]
	lea	edx, DWORD PTR [edi+81076]
	mov	eax, esi
	sub	edx, esi
$LL15@soap_id_fo:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	cmp	cl, bl
	jne	SHORT $LL15@soap_id_fo

; 5818 :     soap->error = SOAP_HREF;

	mov	DWORD PTR [edi+90460], 26		; 0000001aH
	pop	edi
	pop	esi
	pop	ebp

; 5825 :       return NULL;

	xor	eax, eax
	pop	ebx

; 5845 : }

	ret	0
$LN11@soap_id_fo:
	pop	esi

; 5802 :     return p;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 5845 : }

	ret	0
_soap_id_forward ENDP
_TEXT	ENDS
PUBLIC	_soap_id_lookup
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
tv202 = -4						; size = 4
_p$ = 8							; size = 4
_t$ = 12						; size = 4
_n$ = 16						; size = 4
_soap_id_lookup PROC
; _soap$ = ecx
; _id$ = eax

; 5717 : { struct soap_ilist *ip;

	push	ecx
	push	ebp

; 5718 :   void **q;
; 5719 :   if (!p || !id || !*id)

	mov	ebp, DWORD PTR _p$[esp+4]
	push	esi
	push	edi
	mov	esi, eax
	mov	edi, ecx
	test	ebp, ebp
	je	$LN17@soap_id_lo
	test	esi, esi
	je	$LN17@soap_id_lo
	cmp	BYTE PTR [esi], 0
	je	$LN17@soap_id_lo
	push	ebx

; 5721 :   ip = soap_lookup(soap, id); /* lookup pointer to hash table entry for string id */

	push	edi
	call	_soap_lookup
	mov	ebx, eax
	add	esp, 4

; 5722 :   if (!ip)

	test	ebx, ebx
	jne	SHORT $LN16@soap_id_lo

; 5723 :   { ip = soap_enter(soap, id); /* new hash table entry for string id */

	push	esi
	push	edi
	call	_soap_enter

; 5724 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Forwarding first href='%s' type=%d %p (%u bytes)\n", id, t, p, (unsigned int)n));
; 5725 :     ip->type = t;

	mov	ecx, DWORD PTR _t$[esp+24]

; 5726 :     ip->size = n;

	mov	edx, DWORD PTR _n$[esp+24]
	add	esp, 8
	pop	ebx
	mov	DWORD PTR [eax+4], ecx

; 5727 :     ip->link = p;
; 5728 :     ip->copy = NULL;

	xor	ecx, ecx
	pop	edi
	mov	DWORD PTR [eax+12], ebp
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+16], ecx

; 5729 :     ip->flist = NULL;

	mov	DWORD PTR [eax+20], ecx

; 5730 :     ip->ptr = NULL;

	mov	DWORD PTR [eax+24], ecx

; 5731 :     ip->level = k;

	mov	DWORD PTR [eax+28], ecx
	pop	esi

; 5732 :     *p = NULL;

	mov	DWORD PTR [ebp], ecx

; 5787 :   }
; 5788 :   return p;

	mov	eax, ebp
	pop	ebp

; 5789 : }

	pop	ecx
	ret	0
$LN16@soap_id_lo:

; 5733 :   }
; 5734 :   else if (ip->ptr)

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN14@soap_id_lo

; 5735 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolved href='%s' type=%d location=%p (%u bytes)\n", id, t, ip->ptr, (unsigned int)n));
; 5736 :     if (ip->type != t)

	mov	ecx, DWORD PTR _t$[esp+16]
	cmp	DWORD PTR [ebx+4], ecx
	je	$LN23@soap_id_lo

; 5737 :     { strcpy(soap->id, id);

	mov	edx, edi
	sub	edx, esi
	mov	eax, esi
	add	edx, 81076				; 00013cb4H
	npad	7
$LL21@soap_id_lo:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL21@soap_id_lo
	pop	ebx

; 5738 :       soap->error = SOAP_HREF;

	mov	DWORD PTR [edi+90460], 26		; 0000001aH
	pop	edi
	pop	esi

; 5739 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Type incompatibility: href='%s' id-type=%d href-type=%d\n", id, ip->type, t));
; 5740 :       return NULL;

	xor	eax, eax
	pop	ebp

; 5789 : }

	pop	ecx
	ret	0
$LN14@soap_id_lo:

; 5741 :     }
; 5742 :     while (ip->level < k)
; 5743 :     { q = (void**)soap_malloc(soap, sizeof(void*));
; 5744 :       if (!q)
; 5745 :         return NULL;
; 5746 :       *p = (void*)q;
; 5747 :       p = q;
; 5748 :       k--;
; 5749 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Descending one level...\n"));
; 5750 :     }
; 5751 :     *p = ip->ptr;
; 5752 :   }
; 5753 :   else if (ip->level > k)

	cmp	DWORD PTR [ebx+28], 0
	jbe	SHORT $LN26@soap_id_lo
	lea	eax, DWORD PTR [ebx+12]

; 5776 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Forwarded href='%s' type=%d location=%p (%u bytes)\n", id, t, p, (unsigned int)n));
; 5777 :     while (ip->level < k)
; 5778 :     { q = (void**)soap_malloc(soap, sizeof(void*));
; 5779 :       *p = q;
; 5780 :       p = q;
; 5781 :       k--;
; 5782 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Descending one level...\n"));
; 5783 :     }
; 5784 :     q = (void**)ip->link;

	mov	DWORD PTR tv202[esp+20], eax
	npad	7
$LL7@soap_id_lo:
	mov	ebp, DWORD PTR [eax]
	mov	esi, eax
	test	ebp, ebp
	je	SHORT $LN4@soap_id_lo
	npad	8
$LL5@soap_id_lo:

; 5759 :       { *r = (void*)soap_malloc(soap, sizeof(void*));

	mov	eax, 4
	call	_soap_malloc
	mov	DWORD PTR [esi], eax

; 5760 :         s = *q;

	mov	ecx, DWORD PTR [ebp]

; 5761 :         *q = *r;

	mov	DWORD PTR [ebp], eax

; 5762 :         r = (void**)*r;

	mov	esi, DWORD PTR [esi]

; 5763 :         q = (void**)s;

	mov	ebp, ecx
	test	ecx, ecx
	jne	SHORT $LL5@soap_id_lo

; 5754 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolving level %u pointers to href='%s'\n", ip->level, id));
; 5755 :     while (ip->level > k)
; 5756 :     { void *s, **r = &ip->link;
; 5757 :       q = (void**)ip->link;
; 5758 :       while (q)

	mov	eax, DWORD PTR tv202[esp+20]
$LN4@soap_id_lo:

; 5764 :       }
; 5765 :       *r = NULL;
; 5766 :       ip->size = n;

	mov	ecx, DWORD PTR _n$[esp+16]
	mov	DWORD PTR [esi], 0

; 5767 :       ip->copy = NULL;
; 5768 :       ip->level = ip->level - 1;

	dec	DWORD PTR [ebx+28]
	mov	DWORD PTR [ebx+8], ecx
	mov	DWORD PTR [ebx+16], 0
	cmp	DWORD PTR [ebx+28], 0
	ja	SHORT $LL7@soap_id_lo

; 5769 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Descending one level...\n"));
; 5770 :     }
; 5771 :     q = (void**)ip->link;
; 5772 :     ip->link = p;

	mov	ecx, DWORD PTR _p$[esp+16]
	mov	edx, DWORD PTR [eax]
	pop	ebx
	pop	edi

; 5773 :     *p = (void*)q;
; 5774 :   }
; 5775 :   else

	mov	ebp, ecx
	mov	DWORD PTR [eax], ecx
	pop	esi

; 5787 :   }
; 5788 :   return p;

	mov	eax, ebp
	mov	DWORD PTR [ecx], edx
	pop	ebp

; 5789 : }

	pop	ecx
	ret	0
$LN26@soap_id_lo:

; 5776 :   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Forwarded href='%s' type=%d location=%p (%u bytes)\n", id, t, p, (unsigned int)n));
; 5777 :     while (ip->level < k)
; 5778 :     { q = (void**)soap_malloc(soap, sizeof(void*));
; 5779 :       *p = q;
; 5780 :       p = q;
; 5781 :       k--;
; 5782 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Descending one level...\n"));
; 5783 :     }
; 5784 :     q = (void**)ip->link;

	mov	eax, DWORD PTR [ebx+12]

; 5785 :     ip->link = p;

	mov	DWORD PTR [ebx+12], ebp
$LN23@soap_id_lo:
	pop	ebx
	pop	edi

; 5786 :     *p = (void*)q;

	mov	DWORD PTR [ebp], eax
	pop	esi

; 5787 :   }
; 5788 :   return p;

	mov	eax, ebp
	pop	ebp

; 5789 : }

	pop	ecx
	ret	0
$LN17@soap_id_lo:
	pop	edi
	pop	esi

; 5720 :     return p;

	mov	eax, ebp
	pop	ebp

; 5789 : }

	pop	ecx
	ret	0
_soap_id_lookup ENDP
_TEXT	ENDS
PUBLIC	_soap_lookup_type
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_lookup_type PROC
; _soap$ = eax
; _id$ = ecx

; 5696 : { register struct soap_ilist *ip;

	push	esi
	mov	esi, ecx

; 5697 :   if (id && *id)

	test	esi, esi
	je	SHORT $LN1@soap_looku@3
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN1@soap_looku@3

; 5698 :   { ip = soap_lookup(soap, id);

	push	eax
	call	_soap_lookup
	add	esp, 4

; 5699 :     if (ip)

	test	eax, eax
	je	SHORT $LN1@soap_looku@3

; 5700 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Lookup id='%s' type=%d\n", id, ip->type));
; 5701 :       return ip->type;

	mov	eax, DWORD PTR [eax+4]
	pop	esi

; 5706 : }

	ret	0
$LN1@soap_looku@3:

; 5702 :     }
; 5703 :   }
; 5704 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "lookup type id='%s' NOT FOUND! Need to get it from xsi:type\n", id));
; 5705 :   return 0;

	xor	eax, eax
	pop	esi

; 5706 : }

	ret	0
_soap_lookup_type ENDP
_TEXT	ENDS
PUBLIC	_soap_match_array
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_match_array PROC
; _type$ = eax

; 2903 : { if (*soap->arrayType)

	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	cmp	BYTE PTR [ebx+84148], 0
	push	esi
	lea	esi, DWORD PTR [ebx+84148]
	push	edi
	je	SHORT $LN1@soap_match@4

; 2904 :     if (soap_match_tag(soap, soap->arrayType, type)
; 2905 :      && soap_match_tag(soap, soap->arrayType, "xsd:anyType")
; 2906 :      && soap_match_tag(soap, soap->arrayType, "xsd:ur-type")
; 2907 :    )

	push	esi
	push	ebx
	mov	edi, eax
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_match@4
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0M@NOIFKOBF@xsd?3anyType?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_match@4
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0M@NANEACJL@xsd?3ur?9type?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_match@4
	pop	edi
	pop	esi

; 2908 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Array type mismatch: '%s' '%s'\n", soap->arrayType, type));
; 2909 :       return SOAP_TAG_MISMATCH;

	mov	eax, 3
	pop	ebx

; 2912 : }

	ret	0
$LN1@soap_match@4:
	pop	edi
	pop	esi

; 2910 :     }
; 2911 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 2912 : }

	ret	0
_soap_match_array ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_soap_pututf8
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tmp$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_soap_pututf8 PROC
; _soap$ = edi
; _c$ = ecx

; 1665 : { char tmp[16];

	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+20], eax

; 1666 :   if (c < 0x80 && c > 0)

	cmp	ecx, 128				; 00000080H
	jae	SHORT $LN16@soap_putut
	test	ecx, ecx
	jbe	$LN9@soap_putut

; 1667 :   { *tmp = (char)c;
; 1668 :     return soap_send_raw(soap, tmp, 1);

	lea	eax, DWORD PTR _tmp$[esp+20]
	push	1
	push	eax
	mov	eax, edi
	mov	BYTE PTR _tmp$[esp+28], cl
	call	_soap_send_raw
	add	esp, 8

; 1701 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+20]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 20					; 00000014H
	ret	0
$LN16@soap_putut:

; 1669 :   }
; 1670 : #ifndef WITH_LEAN
; 1671 :   if (c >= 0x80)
; 1672 :   { register char *t = tmp;
; 1673 :     if (c < 0x0800)

	cmp	ecx, 2048				; 00000800H
	jae	SHORT $LN8@soap_putut

; 1674 :       *t++ = (char)(0xC0 | ((c >> 6) & 0x1F));

	mov	edx, ecx
	shr	edx, 6
	and	dl, 31					; 0000001fH
	or	dl, -64					; ffffffc0H
	mov	BYTE PTR _tmp$[esp+20], dl
	lea	edx, DWORD PTR _tmp$[esp+21]

; 1675 :     else

	jmp	$LN7@soap_putut
$LN8@soap_putut:

; 1676 :     { if (c < 0x010000)

	cmp	ecx, 65536				; 00010000H
	jae	SHORT $LN6@soap_putut

; 1677 :         *t++ = (char)(0xE0 | ((c >> 12) & 0x0F));

	mov	eax, ecx
	shr	eax, 12					; 0000000cH
	and	al, 15					; 0000000fH
	or	al, -32					; ffffffe0H
	mov	BYTE PTR _tmp$[esp+20], al
	lea	edx, DWORD PTR _tmp$[esp+21]

; 1678 :       else

	jmp	SHORT $LN5@soap_putut
$LN6@soap_putut:

; 1679 :       { if (c < 0x200000)

	cmp	ecx, 2097152				; 00200000H
	jae	SHORT $LN4@soap_putut

; 1680 :           *t++ = (char)(0xF0 | ((c >> 18) & 0x07));

	mov	edx, ecx
	shr	edx, 18					; 00000012H
	and	dl, 7
	or	dl, -16					; fffffff0H
	mov	BYTE PTR _tmp$[esp+20], dl
	lea	edx, DWORD PTR _tmp$[esp+21]

; 1681 :         else

	jmp	SHORT $LN3@soap_putut
$LN4@soap_putut:

; 1682 :         { if (c < 0x04000000)
; 1683 :             *t++ = (char)(0xF8 | ((c >> 24) & 0x03));

	mov	eax, ecx
	shr	eax, 24					; 00000018H
	cmp	ecx, 67108864				; 04000000H
	jae	SHORT $LN2@soap_putut
	and	al, 3
	or	al, -8					; fffffff8H
	mov	BYTE PTR _tmp$[esp+20], al
	lea	edx, DWORD PTR _tmp$[esp+21]

; 1684 :           else

	jmp	SHORT $LN1@soap_putut
$LN2@soap_putut:

; 1685 :           { *t++ = (char)(0xFC | ((c >> 30) & 0x01));

	mov	edx, ecx
	shr	edx, 30					; 0000001eH
	and	dl, 1
	or	dl, -4					; fffffffcH

; 1686 :             *t++ = (char)(0x80 | ((c >> 24) & 0x3F));

	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR _tmp$[esp+20], dl
	mov	BYTE PTR _tmp$[esp+21], al
	lea	edx, DWORD PTR _tmp$[esp+22]
$LN1@soap_putut:

; 1687 :           }
; 1688 :           *t++ = (char)(0x80 | ((c >> 18) & 0x3F));

	mov	eax, ecx
	shr	eax, 18					; 00000012H
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [edx], al
	inc	edx
$LN3@soap_putut:

; 1689 :         }
; 1690 :         *t++ = (char)(0x80 | ((c >> 12) & 0x3F));

	mov	eax, ecx
	shr	eax, 12					; 0000000cH
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [edx], al
	inc	edx
$LN5@soap_putut:

; 1691 :       }
; 1692 :       *t++ = (char)(0x80 | ((c >> 6) & 0x3F));

	mov	eax, ecx
	shr	eax, 6
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [edx], al
	inc	edx
$LN7@soap_putut:

; 1693 :     }
; 1694 :     *t++ = (char)(0x80 | (c & 0x3F));

	and	cl, 63					; 0000003fH
	or	cl, -128				; ffffff80H
	mov	BYTE PTR [edx], cl

; 1695 :     *t = '\0';

	mov	BYTE PTR [edx+1], 0
$LN9@soap_putut:

; 1696 :   }
; 1697 : #else
; 1698 :   sprintf(tmp, "&#%lu;", c);
; 1699 : #endif
; 1700 :   return soap_send(soap, tmp);

	lea	ecx, DWORD PTR _tmp$[esp+20]
	push	esi
	lea	esi, DWORD PTR [ecx+1]
$LL17@soap_putut:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL17@soap_putut
	sub	ecx, esi
	push	ecx
	lea	ecx, DWORD PTR _tmp$[esp+28]
	push	ecx
	mov	eax, edi
	call	_soap_send_raw

; 1701 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+32]
	add	esp, 8
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 20					; 00000014H
	ret	0
_soap_pututf8 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_soap_recv
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tmp$78632 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_soap_recv PROC
; _soap$ = esi

; 1245 : {

	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+16], eax

; 1246 : #ifndef WITH_LEANER
; 1247 :   if (soap->mode & SOAP_ENC_DIME)

	test	BYTE PTR [esi+8], -128			; ffffff80H
	push	edi
	je	$LN4@soap_recv

; 1248 :   { if (soap->dime.buflen)

	mov	eax, DWORD PTR [esi+90488]
	test	eax, eax
	je	$LN19@soap_recv

; 1249 :     { char *s;
; 1250 :       int i;
; 1251 :       unsigned char tmp[12];
; 1252 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "DIME hdr for chunked DIME is in buffer\n"));
; 1253 :       soap->count += soap->dime.buflen - soap->buflen;
; 1254 :       soap->buflen = soap->dime.buflen;
; 1255 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Skip padding (%ld bytes)\n", -(long)soap->dime.size&3));
; 1256 :       for (i = -(long)soap->dime.size&3; i > 0; i--)

	mov	edi, DWORD PTR [esi+90480]
	mov	ecx, eax
	sub	ecx, DWORD PTR [esi+12432]
	neg	edi
	add	DWORD PTR [esi+12448], ecx
	and	edi, 3
	mov	DWORD PTR [esi+12432], eax
	jle	SHORT $LN16@soap_recv
	npad	8
$LL18@soap_recv:

; 1257 :       { soap->bufidx++;

	inc	DWORD PTR [esi+12428]
	mov	eax, DWORD PTR [esi+12428]

; 1258 :         if (soap->bufidx >= soap->buflen)

	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN17@soap_recv

; 1259 :           if (soap_recv_raw(soap))

	mov	ecx, esi
	call	_soap_recv_raw
	test	eax, eax
	jne	$LN25@soap_recv
$LN17@soap_recv:

; 1249 :     { char *s;
; 1250 :       int i;
; 1251 :       unsigned char tmp[12];
; 1252 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "DIME hdr for chunked DIME is in buffer\n"));
; 1253 :       soap->count += soap->dime.buflen - soap->buflen;
; 1254 :       soap->buflen = soap->dime.buflen;
; 1255 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Skip padding (%ld bytes)\n", -(long)soap->dime.size&3));
; 1256 :       for (i = -(long)soap->dime.size&3; i > 0; i--)

	dec	edi
	test	edi, edi
	jg	SHORT $LL18@soap_recv
$LN16@soap_recv:
	push	ebp

; 1261 :       }
; 1262 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Get DIME hdr for next chunk\n"));
; 1263 :       s = (char*)tmp;

	lea	edi, DWORD PTR _tmp$78632[esp+24]

; 1264 :       for (i = 12; i > 0; i--)

	mov	ebp, 12					; 0000000cH
$LL13@soap_recv:

; 1265 :       { *s++ = soap->buf[soap->bufidx++];

	mov	eax, DWORD PTR [esi+12428]
	mov	dl, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	BYTE PTR [edi], dl
	inc	edi
	mov	DWORD PTR [esi+12428], eax

; 1266 :         if (soap->bufidx >= soap->buflen)

	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN12@soap_recv

; 1267 :           if (soap_recv_raw(soap))

	mov	ecx, esi
	call	_soap_recv_raw
	test	eax, eax
	jne	SHORT $LN26@soap_recv
$LN12@soap_recv:

; 1264 :       for (i = 12; i > 0; i--)

	dec	ebp
	test	ebp, ebp
	jg	SHORT $LL13@soap_recv

; 1269 :       }
; 1270 :       soap->dime.flags = tmp[0] & 0x7;
; 1271 :       soap->dime.size = ((size_t)tmp[8] << 24) | ((size_t)tmp[9] << 16) | ((size_t)tmp[10] << 8) | ((size_t)tmp[11]);

	movzx	eax, BYTE PTR _tmp$78632[esp+32]
	movzx	edx, BYTE PTR _tmp$78632[esp+33]
	mov	cl, BYTE PTR _tmp$78632[esp+24]
	shl	eax, 8
	or	eax, edx
	movzx	edx, BYTE PTR _tmp$78632[esp+34]
	shl	eax, 8
	or	eax, edx
	movzx	edx, BYTE PTR _tmp$78632[esp+35]
	shl	eax, 8
	and	cl, 7
	or	eax, edx
	mov	BYTE PTR [esi+90492], cl
	mov	DWORD PTR [esi+90480], eax

; 1272 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Get DIME chunk (%u bytes)\n", (unsigned int)soap->dime.size));
; 1273 :       if (soap->dime.flags & SOAP_DIME_CF)

	test	cl, 1
	je	SHORT $LN8@soap_recv

; 1274 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "More chunking\n"));
; 1275 :         soap->dime.chunksize = soap->dime.size;
; 1276 :         if (soap->buflen - soap->bufidx >= soap->dime.size)

	mov	ecx, DWORD PTR [esi+12432]
	mov	edx, DWORD PTR [esi+12428]
	mov	edi, ecx
	sub	edi, edx
	mov	DWORD PTR [esi+90484], eax
	cmp	edi, eax
	jb	SHORT $LN7@soap_recv

; 1277 :         { soap->dime.buflen = soap->buflen;
; 1278 :           soap->buflen = soap->bufidx + soap->dime.chunksize;

	add	eax, edx
	mov	DWORD PTR [esi+90488], ecx
	mov	DWORD PTR [esi+12432], eax

; 1279 :         }
; 1280 :         else

	jmp	SHORT $LN5@soap_recv
$LN25@soap_recv:

; 1260 :             return EOF;

	or	eax, -1
	pop	edi

; 1309 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+16]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 16					; 00000010H
	ret	0
$LN26@soap_recv:
	pop	ebp

; 1268 :             return EOF;

	or	eax, -1
	pop	edi

; 1309 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+16]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 16					; 00000010H
	ret	0
$LN7@soap_recv:

; 1281 :           soap->dime.chunksize -= soap->buflen - soap->bufidx;

	sub	eax, ecx
	add	eax, edx
	mov	DWORD PTR [esi+90484], eax

; 1282 :       }
; 1283 :       else

	jmp	SHORT $LN5@soap_recv
$LN8@soap_recv:

; 1284 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Last chunk\n"));
; 1285 :         soap->dime.buflen = 0;

	mov	DWORD PTR [esi+90488], 0

; 1286 :         soap->dime.chunksize = 0;

	mov	DWORD PTR [esi+90484], 0
$LN5@soap_recv:

; 1287 :       }
; 1288 :       soap->count = soap->buflen - soap->bufidx;

	mov	eax, DWORD PTR [esi+12432]
	sub	eax, DWORD PTR [esi+12428]
	pop	ebp
	mov	DWORD PTR [esi+12448], eax

; 1289 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "%u bytes remaining\n", (unsigned int)soap->count));
; 1290 :       return SOAP_OK;

	xor	eax, eax
	pop	edi

; 1309 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+16]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 16					; 00000010H
	ret	0
$LN19@soap_recv:

; 1291 :     }
; 1292 :     if (soap->dime.chunksize)

	cmp	DWORD PTR [esi+90484], 0
	je	SHORT $LN4@soap_recv

; 1293 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Get next DIME hdr for chunked DIME (%u bytes chunk)\n", (unsigned int)soap->dime.chunksize));
; 1294 :       if (soap_recv_raw(soap))

	mov	ecx, esi
	call	_soap_recv_raw
	test	eax, eax

; 1295 :         return EOF;

	jne	SHORT $LN25@soap_recv

; 1296 :       if (soap->buflen - soap->bufidx >= soap->dime.chunksize)

	mov	ecx, DWORD PTR [esi+12432]
	mov	edx, DWORD PTR [esi+12428]
	mov	eax, DWORD PTR [esi+90484]
	mov	edi, ecx
	sub	edi, edx
	cmp	edi, eax
	jb	SHORT $LN2@soap_recv

; 1297 :       { soap->dime.buflen = soap->buflen;
; 1298 :         soap->count -= soap->buflen - soap->bufidx - soap->dime.chunksize;

	mov	edi, eax
	sub	edi, ecx
	add	edi, edx
	add	DWORD PTR [esi+12448], edi

; 1299 :         soap->buflen = soap->bufidx + soap->dime.chunksize;

	add	eax, edx
	mov	DWORD PTR [esi+12432], eax
	mov	DWORD PTR [esi+90488], ecx

; 1303 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "%lu bytes remaining, count=%u\n", (unsigned long)(soap->buflen-soap->bufidx), (unsigned int)soap->count));
; 1304 :       return SOAP_OK;

	xor	eax, eax
	pop	edi

; 1309 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+16]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 16					; 00000010H
	ret	0
$LN2@soap_recv:

; 1300 :       }
; 1301 :       else
; 1302 :         soap->dime.chunksize -= soap->buflen - soap->bufidx;

	sub	eax, ecx
	add	eax, edx
	mov	DWORD PTR [esi+90484], eax

; 1303 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "%lu bytes remaining, count=%u\n", (unsigned long)(soap->buflen-soap->bufidx), (unsigned int)soap->count));
; 1304 :       return SOAP_OK;

	xor	eax, eax
	pop	edi

; 1309 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+16]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 16					; 00000010H
	ret	0
$LN4@soap_recv:

; 1305 :     }
; 1306 :   }
; 1307 : #endif
; 1308 :   return soap_recv_raw(soap);

	mov	ecx, esi
	call	_soap_recv_raw

; 1309 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+20]
	pop	edi
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 16					; 00000010H
	ret	0
_soap_recv ENDP
_TEXT	ENDS
PUBLIC	_soap_send3
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_s3$ = 8						; size = 4
_soap_send3 PROC
; _soap$ = edi
; _s2$ = edx

; 843  : { if (soap_send(soap, s1)

	push	ebx
	mov	ebx, DWORD PTR _s3$[esp]

; 844  :    || soap_send(soap, s2))

	test	edx, edx
	je	SHORT $LN2@soap_send3
	mov	eax, edx
	push	esi
	lea	esi, DWORD PTR [eax+1]
	npad	1
$LL14@soap_send3:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL14@soap_send3
	sub	eax, esi
	push	eax
	push	edx
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	pop	esi
	test	eax, eax
	je	SHORT $LN2@soap_send3

; 845  :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	ebx

; 847  : }

	ret	0
$LN2@soap_send3:

; 846  :   return soap_send(soap, s3);

	test	ebx, ebx
	je	SHORT $LN11@soap_send3
	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL15@soap_send3:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL15@soap_send3
	sub	eax, edx
	push	eax
	push	ebx
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	pop	ebx

; 847  : }

	ret	0

; 846  :   return soap_send(soap, s3);

$LN11@soap_send3:
	xor	eax, eax
	pop	ebx

; 847  : }

	ret	0
_soap_send3 ENDP
_TEXT	ENDS
PUBLIC	_soap_send2
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_s2$ = 8						; size = 4
_soap_send2 PROC
; _soap$ = edi
; _s1$ = edx

; 829  : { if (soap_send(soap, s1))

	push	ebx
	mov	ebx, DWORD PTR _s2$[esp]
	test	edx, edx
	je	SHORT $LN1@soap_send2
	mov	eax, edx
	push	esi
	lea	esi, DWORD PTR [eax+1]
	npad	1
$LL10@soap_send2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL10@soap_send2
	sub	eax, esi
	push	eax
	push	edx
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	pop	esi
	test	eax, eax
	je	SHORT $LN1@soap_send2

; 830  :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	ebx

; 832  : }

	ret	0
$LN1@soap_send2:

; 831  :   return soap_send(soap, s2);

	test	ebx, ebx
	je	SHORT $LN7@soap_send2
	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL11@soap_send2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL11@soap_send2
	sub	eax, edx
	push	eax
	push	ebx
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	pop	ebx

; 832  : }

	ret	0

; 831  :   return soap_send(soap, s2);

$LN7@soap_send2:
	xor	eax, eax
	pop	ebx

; 832  : }

	ret	0
_soap_send2 ENDP
PUBLIC	_soap_body_end_out
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_body_end_out PROC
; _soap$ = edi

; 13428: { if (soap_element_end_out(soap, "SOAP-ENV:Body"))

	push	esi
	mov	esi, OFFSET ??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@
	mov	eax, edi
	call	_soap_element_end_out
	pop	esi
	test	eax, eax
	je	SHORT $LN1@soap_body_

; 13429:     return soap->error;

	mov	eax, DWORD PTR [edi+90460]

; 13432: }

	ret	0
$LN1@soap_body_:

; 13430:   soap->part = SOAP_END_BODY;

	mov	eax, 7
	mov	WORD PTR [edi+87304], ax

; 13431:   return SOAP_OK;

	xor	eax, eax

; 13432: }

	ret	0
_soap_body_end_out ENDP
_TEXT	ENDS
PUBLIC	_soap_envelope_end_out
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_envelope_end_out PROC
; _soap$ = edi

; 13311: { if (soap_element_end_out(soap, "SOAP-ENV:Envelope"))

	push	esi
	mov	esi, OFFSET ??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@
	mov	eax, edi
	call	_soap_element_end_out
	test	eax, eax
	je	SHORT $LN7@soap_envel

; 13312:     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	esi

; 13335: }

	ret	0
$LN7@soap_envel:

; 13313: #ifndef WITH_LEANER
; 13314:   if ((soap->mode & SOAP_IO_LENGTH) && (soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))

	mov	eax, DWORD PTR [edi+8]
	test	al, 8
	je	$LN6@soap_envel
	test	al, al
	jns	$LN6@soap_envel
	test	eax, 512				; 00000200H
	jne	$LN6@soap_envel

; 13315:   { soap->dime.size = soap->count - soap->dime.size;	/* DIME in MIME correction */

	mov	eax, DWORD PTR [edi+12448]

; 13316:     sprintf(soap->id, soap->dime_id_format, 0);

	mov	ecx, DWORD PTR [edi+28]
	sub	eax, DWORD PTR [edi+90480]
	push	0
	push	ecx
	lea	esi, DWORD PTR [edi+81076]
	push	esi
	mov	DWORD PTR [edi+90480], eax
	call	_sprintf

; 13317:     soap->dime.id = soap->id;
; 13318:     if (soap->local_namespaces)

	mov	eax, DWORD PTR [edi+84]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+90500], esi
	test	eax, eax
	je	SHORT $LN3@soap_envel

; 13319:     { if (soap->local_namespaces[0].out)

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN4@soap_envel

; 13320:         soap->dime.type = (char*)soap->local_namespaces[0].out;

	mov	DWORD PTR [edi+90504], ecx

; 13321:       else

	jmp	SHORT $LN3@soap_envel
$LN4@soap_envel:

; 13322:         soap->dime.type = (char*)soap->local_namespaces[0].ns;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+90504], edx
$LN3@soap_envel:

; 13323:     }
; 13324:     soap->dime.options = NULL;
; 13325:     soap->dime.flags = SOAP_DIME_MB | SOAP_DIME_ABSURI;
; 13326:     if (!soap->dime.first)

	cmp	DWORD PTR [edi+90516], 0
	mov	DWORD PTR [edi+90508], 0
	mov	BYTE PTR [edi+90492], 36		; 00000024H
	jne	SHORT $LN2@soap_envel

; 13327:       soap->dime.flags |= SOAP_DIME_ME;

	mov	BYTE PTR [edi+90492], 38		; 00000026H
$LN2@soap_envel:

; 13328:     soap->count += 12 + ((strlen(soap->dime.id)+3)&(~3)) + (soap->dime.type ? ((strlen(soap->dime.type)+3)&(~3)) : 0);

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL12@soap_envel:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL12@soap_envel
	mov	ecx, DWORD PTR [edi+90504]
	sub	eax, edx
	test	ecx, ecx
	je	SHORT $LN10@soap_envel
	lea	esi, DWORD PTR [ecx+1]
$LL13@soap_envel:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL13@soap_envel
	sub	ecx, esi
	add	ecx, 3
	and	ecx, -4					; fffffffcH
	jmp	SHORT $LN11@soap_envel
$LN10@soap_envel:
	xor	ecx, ecx
$LN11@soap_envel:
	add	eax, 3
	and	eax, -4					; fffffffcH
	lea	eax, DWORD PTR [eax+ecx+12]
	add	DWORD PTR [edi+12448], eax
$LN6@soap_envel:

; 13329:   }
; 13330:   if ((soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))

	mov	eax, DWORD PTR [edi+8]
	test	al, al
	jns	SHORT $LN1@soap_envel
	test	eax, 512				; 00000200H
	jne	SHORT $LN1@soap_envel

; 13331:     return soap_send_raw(soap, SOAP_STR_PADDING, -(long)soap->dime.size&3);

	mov	ecx, DWORD PTR [edi+90480]
	neg	ecx
	and	ecx, 3
	push	ecx
	push	OFFSET _soap_padding
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	pop	esi

; 13335: }

	ret	0
$LN1@soap_envel:

; 13332: #endif
; 13333:   soap->part = SOAP_END_ENVELOPE;

	mov	edx, 8
	mov	WORD PTR [edi+87304], dx

; 13334:   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 13335: }

	ret	0
_soap_envelope_end_out ENDP
_TEXT	ENDS
PUBLIC	_soap_putmimehdr
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_content$ = 8						; size = 4
_soap_putmimehdr PROC
; _soap$ = eax

; 11686: { const char *s;

	push	ebx
	mov	ebx, DWORD PTR _content$[esp]
	push	esi
	push	edi
	mov	edi, eax

; 11687:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "MIME attachment type=%s\n", content->type?content->type:""));
; 11688:   if (soap_send3(soap, "\r\n--", soap->mime.boundary, "\r\n"))

	mov	esi, DWORD PTR [edi+90524]
	push	4
	push	OFFSET ??_C@_04LOEPKDGL@?$AN?6?9?9?$AA@
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN76@soap_putmi
	test	esi, esi
	je	SHORT $LN74@soap_putmi
	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL75@soap_putmi:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL75@soap_putmi
	sub	eax, edx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN76@soap_putmi
$LN74@soap_putmi:
	push	2
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	jmp	SHORT $LN11@soap_putmi
$LN76@soap_putmi:
	mov	eax, DWORD PTR [edi+90460]
$LN11@soap_putmi:
	test	eax, eax
	je	SHORT $LN6@soap_putmi
$LN77@soap_putmi:

; 11689:     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 11702: }

	ret	0
$LN6@soap_putmi:

; 11690:   if (content->type && soap_send3(soap, "Content-Type: ", content->type, "\r\n"))

	mov	esi, DWORD PTR [ebx+16]
	test	esi, esi
	je	SHORT $LN5@soap_putmi
	push	14					; 0000000eH
	push	OFFSET ??_C@_0P@GJMOGDPG@Content?9Type?3?5?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@soap_putmi
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	edx, esi
	call	_soap_send3
	add	esp, 4
	jmp	SHORT $LN24@soap_putmi
$LN22@soap_putmi:
	mov	eax, DWORD PTR [edi+90460]
$LN24@soap_putmi:
	test	eax, eax

; 11691:     return soap->error;

	jne	SHORT $LN77@soap_putmi
$LN5@soap_putmi:

; 11692:   s = soap_code_str(mime_codes, content->encoding);

	mov	ecx, DWORD PTR [ebx+24]
	mov	eax, OFFSET _mime_codes
	cmp	ecx, 1
	je	SHORT $LN31@soap_putmi
$LL32@soap_putmi:
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN31@soap_putmi
	add	eax, 8
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LL32@soap_putmi
$LN31@soap_putmi:
	mov	esi, DWORD PTR [eax+4]

; 11693:   if (s && soap_send3(soap, "Content-Transfer-Encoding: ", s, "\r\n"))

	test	esi, esi
	je	SHORT $LN4@soap_putmi
	push	27					; 0000001bH
	push	OFFSET ??_C@_0BM@MCMHCKIN@Content?9Transfer?9Encoding?3?5?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN36@soap_putmi
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	edx, esi
	call	_soap_send3
	add	esp, 4
	jmp	SHORT $LN38@soap_putmi
$LN36@soap_putmi:
	mov	eax, DWORD PTR [edi+90460]
$LN38@soap_putmi:
	test	eax, eax

; 11694:     return soap->error;

	jne	$LN77@soap_putmi
$LN4@soap_putmi:

; 11695:   if (content->id && soap_send3(soap, "Content-ID: ", content->id, "\r\n"))

	mov	esi, DWORD PTR [ebx+12]
	test	esi, esi
	je	SHORT $LN3@soap_putmi
	push	12					; 0000000cH
	push	OFFSET ??_C@_0N@NKGHAKLJ@Content?9ID?3?5?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN45@soap_putmi
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	edx, esi
	call	_soap_send3
	add	esp, 4
	jmp	SHORT $LN47@soap_putmi
$LN45@soap_putmi:
	mov	eax, DWORD PTR [edi+90460]
$LN47@soap_putmi:
	test	eax, eax

; 11696:     return soap->error;

	jne	$LN77@soap_putmi
$LN3@soap_putmi:

; 11697:   if (content->location && soap_send3(soap, "Content-Location: ", content->location, "\r\n"))

	mov	esi, DWORD PTR [ebx+28]
	test	esi, esi
	je	SHORT $LN2@soap_putmi
	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OHIJMKJJ@Content?9Location?3?5?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN54@soap_putmi
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	edx, esi
	call	_soap_send3
	add	esp, 4
	jmp	SHORT $LN56@soap_putmi
$LN54@soap_putmi:
	mov	eax, DWORD PTR [edi+90460]
$LN56@soap_putmi:
	test	eax, eax

; 11698:     return soap->error;

	jne	$LN77@soap_putmi
$LN2@soap_putmi:

; 11699:   if (content->description && soap_send3(soap, "Content-Description: ", content->description, "\r\n"))

	mov	esi, DWORD PTR [ebx+32]
	test	esi, esi
	je	SHORT $LN1@soap_putmi
	push	21					; 00000015H
	push	OFFSET ??_C@_0BG@FGNCEKKA@Content?9Description?3?5?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN63@soap_putmi
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	edx, esi
	call	_soap_send3
	add	esp, 4
	jmp	SHORT $LN65@soap_putmi
$LN63@soap_putmi:
	mov	eax, DWORD PTR [edi+90460]
$LN65@soap_putmi:
	test	eax, eax

; 11700:     return soap->error;

	jne	$LN77@soap_putmi
$LN1@soap_putmi:

; 11701:   return soap_send_raw(soap, "\r\n", 2);

	push	2
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 11702: }

	ret	0
_soap_putmimehdr ENDP
_TEXT	ENDS
PUBLIC	_soap_putdime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_size$82988 = -8					; size = 4
_handle$82984 = -4					; size = 4
_soap_putdime PROC
; _soap$ = eax

; 11125: { struct soap_multipart *content;

	sub	esp, 8
	push	esi
	mov	esi, eax

; 11126:   if (!(soap->mode & SOAP_ENC_DIME))

	test	BYTE PTR [esi+8], -128			; ffffff80H
	jne	SHORT $LN33@soap_putdi@2

; 11127:     return SOAP_OK;

	xor	eax, eax
	pop	esi

; 11202: }

	add	esp, 8
	ret	0
$LN33@soap_putdi@2:
	push	ebx

; 11128:   for (content = soap->dime.first; content; content = content->next)

	mov	ebx, DWORD PTR [esi+90516]
	push	ebp
	push	edi
	test	ebx, ebx
	je	$LN30@soap_putdi@2
$LL32@soap_putdi@2:

; 11129:   { void *handle;
; 11130:     soap->dime.size = content->size;

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+90480], eax

; 11131:     soap->dime.id = content->id;

	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+90500], ecx

; 11132:     soap->dime.type = content->type;

	mov	edx, DWORD PTR [ebx+16]
	mov	DWORD PTR [esi+90504], edx

; 11133:     soap->dime.options = content->options;

	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [esi+90508], eax

; 11134:     soap->dime.flags = SOAP_DIME_VERSION | SOAP_DIME_MEDIA;
; 11135:     if (soap->fdimereadopen && ((handle = soap->fdimereadopen(soap, (void*)content->ptr, content->id, content->type, content->options)) || soap->error))

	mov	eax, DWORD PTR [esi+12356]
	mov	BYTE PTR [esi+90492], 24		; 00000018H
	test	eax, eax
	je	$LN29@soap_putdi@2
	mov	ecx, DWORD PTR [ebx+20]
	mov	edx, DWORD PTR [ebx+16]
	push	ecx
	mov	ecx, DWORD PTR [ebx+12]
	push	edx
	mov	edx, DWORD PTR [ebx+4]
	push	ecx
	push	edx
	push	esi
	call	eax
	mov	edi, eax
	add	esp, 20					; 00000014H
	mov	DWORD PTR _handle$82984[esp+24], edi
	test	edi, edi
	jne	SHORT $LN28@soap_putdi@2
	cmp	DWORD PTR [esi+90460], eax
	je	$LN29@soap_putdi@2
$LN28@soap_putdi@2:

; 11136:     { size_t size = content->size;

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _size$82988[esp+24], eax

; 11137:       if (!handle)

	test	edi, edi
	je	$LN51@soap_putdi@2

; 11138:       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fdimereadopen failed\n"));
; 11139:         return soap->error;
; 11140:       }
; 11141:       if (!size && ((soap->mode & SOAP_ENC_XML) || (soap->mode & SOAP_IO) == SOAP_IO_CHUNK || (soap->mode & SOAP_IO) == SOAP_IO_STORE))

	test	eax, eax
	jne	$LN26@soap_putdi@2
	mov	eax, DWORD PTR [esi+8]
	test	al, 64					; 00000040H
	jne	SHORT $LN53@soap_putdi@2
	and	eax, 3
	cmp	eax, 3
	je	SHORT $LN53@soap_putdi@2
	cmp	eax, 2
	jne	$LN26@soap_putdi@2
$LN53@soap_putdi@2:
	lea	ebp, DWORD PTR [esi+79028]
	jmp	SHORT $LN24@soap_putdi@2
$LL54@soap_putdi@2:
	mov	edi, DWORD PTR _handle$82984[esp+24]
$LN24@soap_putdi@2:

; 11142:       { size_t chunksize = sizeof(soap->tmpbuf);
; 11143:         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Chunked streaming DIME\n"));
; 11144:         do
; 11145:         { size = soap->fdimeread(soap, handle, soap->tmpbuf, chunksize);

	mov	eax, DWORD PTR [esi+12372]
	push	1024					; 00000400H
	push	ebp
	push	edi
	push	esi
	call	eax
	mov	edi, eax
	add	esp, 16					; 00000010H

; 11146:           DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fdimeread returned %lu bytes\n", (unsigned long)size));
; 11147:           if (size < chunksize)

	cmp	edi, 1024				; 00000400H
	jae	SHORT $LN21@soap_putdi@2

; 11148:           { soap->dime.flags &= ~SOAP_DIME_CF;

	and	BYTE PTR [esi+90492], -2		; fffffffeH

; 11149:             if (!content->next)

	cmp	DWORD PTR [ebx], 0
	mov	al, BYTE PTR [esi+90492]
	jne	SHORT $LN19@soap_putdi@2

; 11150:               soap->dime.flags |= SOAP_DIME_ME;

	or	al, 2
	mov	BYTE PTR [esi+90492], al

; 11151:           }
; 11152:           else

	jmp	SHORT $LN19@soap_putdi@2
$LN21@soap_putdi@2:

; 11153:             soap->dime.flags |= SOAP_DIME_CF;

	or	BYTE PTR [esi+90492], 1
$LN19@soap_putdi@2:

; 11154:           soap->dime.size = size;

	mov	DWORD PTR [esi+90480], edi

; 11155:           if (soap_putdimehdr(soap)
; 11156:            || soap_putdimefield(soap, soap->tmpbuf, size))

	call	_soap_putdimehdr
	test	eax, eax
	jne	$LN55@soap_putdi@2
	push	edi
	push	ebp
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	je	SHORT $LN36@soap_putdi@2
	mov	eax, DWORD PTR [esi+90460]
	jmp	SHORT $LN37@soap_putdi@2
$LN36@soap_putdi@2:
	mov	ecx, edi
	neg	ecx
	and	ecx, 3
	push	ecx
	push	OFFSET _soap_padding
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
$LN37@soap_putdi@2:
	xor	ecx, ecx
	cmp	eax, ecx
	jne	$LN15@soap_putdi@2

; 11157:             break;
; 11158:           if (soap->dime.id)

	cmp	DWORD PTR [esi+90500], ecx
	je	SHORT $LN23@soap_putdi@2

; 11159:           { soap->dime.flags &= ~(SOAP_DIME_MB | SOAP_DIME_MEDIA);

	and	BYTE PTR [esi+90492], -21		; ffffffebH

; 11160:             soap->dime.id = NULL;

	mov	DWORD PTR [esi+90500], ecx

; 11161:             soap->dime.type = NULL;

	mov	DWORD PTR [esi+90504], ecx

; 11162:             soap->dime.options = NULL;

	mov	DWORD PTR [esi+90508], ecx
$LN23@soap_putdi@2:

; 11163:           }
; 11164:         } while (size >= chunksize);

	cmp	edi, 1024				; 00000400H
	jae	$LL54@soap_putdi@2

; 11165:       }
; 11166:       else

	jmp	$LN55@soap_putdi@2
$LN26@soap_putdi@2:

; 11167:       { if (!content->next)

	cmp	DWORD PTR [ebx], 0
	jne	SHORT $LN14@soap_putdi@2

; 11168:           soap->dime.flags |= SOAP_DIME_ME;

	or	BYTE PTR [esi+90492], 2
$LN14@soap_putdi@2:

; 11169:         if (soap_putdimehdr(soap))

	call	_soap_putdimehdr
	test	eax, eax
	jne	$LN51@soap_putdi@2
	lea	ebp, DWORD PTR [esi+79028]
$LL12@soap_putdi@2:

; 11170:           return soap->error;
; 11171:         do
; 11172:         { size_t bufsize;
; 11173:           if (size < sizeof(soap->tmpbuf))

	mov	eax, DWORD PTR _size$82988[esp+24]
	cmp	eax, 1024				; 00000400H

; 11174:             bufsize = size;
; 11175:           else

	jb	SHORT $LN8@soap_putdi@2

; 11176:             bufsize = sizeof(soap->tmpbuf);

	mov	eax, 1024				; 00000400H
$LN8@soap_putdi@2:

; 11177:           if (!(bufsize = soap->fdimeread(soap, handle, soap->tmpbuf, bufsize)))

	mov	edx, DWORD PTR [esi+12372]
	push	eax
	push	ebp
	push	edi
	push	esi
	call	edx
	mov	edi, eax
	add	esp, 16					; 00000010H
	test	edi, edi
	je	SHORT $LN47@soap_putdi@2

; 11180:             break;
; 11181:           }
; 11182:           if (soap_send_raw(soap, soap->tmpbuf, bufsize))

	push	edi
	push	ebp
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@soap_putdi@2

; 11183:             break;
; 11184:           size -= bufsize;

	sub	DWORD PTR _size$82988[esp+24], edi

; 11185:         } while (size);

	je	SHORT $LN10@soap_putdi@2
	mov	edi, DWORD PTR _handle$82984[esp+24]
	jmp	SHORT $LL12@soap_putdi@2
$LN47@soap_putdi@2:

; 11178:           { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fdimeread failed: insufficient data (%lu bytes remaining from %lu bytes)\n", (unsigned long)size, (unsigned long)content->size));
; 11179:             soap->error = SOAP_EOF;

	mov	DWORD PTR [esi+90460], -1
$LN10@soap_putdi@2:

; 11186:         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fdimereadclose\n"));
; 11187:         soap_send_raw(soap, SOAP_STR_PADDING, -(long)soap->dime.size&3);

	mov	eax, DWORD PTR [esi+90480]
	neg	eax
	and	eax, 3
	push	eax
	push	OFFSET _soap_padding
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
$LN55@soap_putdi@2:

; 11165:       }
; 11166:       else

	xor	ecx, ecx
$LN15@soap_putdi@2:

; 11188:       }
; 11189:       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fdimereadclose\n"));
; 11190:       if (soap->fdimereadclose)

	mov	eax, DWORD PTR [esi+12364]
	cmp	eax, ecx
	je	SHORT $LN31@soap_putdi@2

; 11191:         soap->fdimereadclose(soap, handle);

	mov	ecx, DWORD PTR _handle$82984[esp+24]
	push	ecx
	push	esi
	call	eax
	add	esp, 8

; 11192:     }
; 11193:     else

	jmp	SHORT $LN31@soap_putdi@2
$LN29@soap_putdi@2:

; 11194:     { if (!content->next)

	cmp	DWORD PTR [ebx], 0
	jne	SHORT $LN3@soap_putdi@2

; 11195:         soap->dime.flags |= SOAP_DIME_ME;

	or	BYTE PTR [esi+90492], 2
$LN3@soap_putdi@2:

; 11196:       if (soap_putdimehdr(soap)
; 11197:        || soap_putdimefield(soap, (char*)content->ptr, content->size))

	call	_soap_putdimehdr
	test	eax, eax
	jne	SHORT $LN51@soap_putdi@2
	mov	edi, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+4]
	push	edi
	push	eax
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	je	SHORT $LN39@soap_putdi@2
	mov	eax, DWORD PTR [esi+90460]
	jmp	SHORT $LN40@soap_putdi@2
$LN39@soap_putdi@2:
	neg	edi
	and	edi, 3
	push	edi
	push	OFFSET _soap_padding
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
$LN40@soap_putdi@2:
	test	eax, eax
	jne	SHORT $LN51@soap_putdi@2
$LN31@soap_putdi@2:

; 11128:   for (content = soap->dime.first; content; content = content->next)

	mov	ebx, DWORD PTR [ebx]
	test	ebx, ebx
	jne	$LL32@soap_putdi@2
$LN30@soap_putdi@2:
	pop	edi
	pop	ebp
	pop	ebx

; 11199:     }
; 11200:   }
; 11201:   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 11202: }

	add	esp, 8
	ret	0
$LN51@soap_putdi@2:

; 11198:         return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 11202: }

	add	esp, 8
	ret	0
_soap_putdime ENDP
_TEXT	ENDS
PUBLIC	_soap_QName2s
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_q$82466 = -4						; size = 4
_soap$ = 8						; size = 4
_n$82452 = 12						; size = 4
_s$ = 12						; size = 4
_soap_QName2s PROC

; 10250: { const char *t = NULL;

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _s$[esp+4]
	xor	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+8]

; 10251:   if (s)

	cmp	ebx, eax
	je	SHORT $LN25@soap_QName
	push	esi

; 10252:   { soap->labidx = 0;

	mov	DWORD PTR [ebp+12464], eax
	push	edi
	npad	7
$LL24@soap_QName:

; 10253:     for (;;)
; 10254:     { size_t n;
; 10255:       /* skip blanks */
; 10256:       while (*s && soap_blank(*s))

	mov	al, BYTE PTR [ebx]
	test	al, al
	je	SHORT $LN56@soap_QName
$LN59@soap_QName:
	jl	SHORT $LN21@soap_QName
	cmp	al, 32					; 00000020H
	jg	SHORT $LN21@soap_QName
	mov	al, BYTE PTR [ebx+1]

; 10257:         s++;

	inc	ebx
	test	al, al
	jne	SHORT $LN59@soap_QName
$LN56@soap_QName:

; 10310:     soap_append_lab(soap, SOAP_STR_EOS, 1);

	push	1
	push	OFFSET _soap_padding
	mov	esi, ebp
	call	_soap_append_lab

; 10311:     t = soap_strdup(soap, soap->labbuf);

	mov	ebx, DWORD PTR [ebp+12456]
	add	esp, 8
	xor	eax, eax
	test	ebx, ebx
	je	SHORT $LN32@soap_QName
	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL52@soap_QName:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL52@soap_QName
	sub	eax, edx
	inc	eax
	mov	edi, ebp
	call	_soap_malloc
	test	eax, eax
	je	SHORT $LN32@soap_QName
	mov	esi, eax
	mov	ecx, ebx
	sub	esi, ebx
$LL35@soap_QName:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [esi+ecx], dl
	inc	ecx
	test	dl, dl
	jne	SHORT $LL35@soap_QName
$LN32@soap_QName:
	pop	edi
	pop	esi
$LN25@soap_QName:
	pop	ebp
	pop	ebx

; 10312:   }
; 10313:   return t;
; 10314: }

	pop	ecx
	ret	0
$LN21@soap_QName:

; 10258:       if (!*s)

	mov	cl, BYTE PTR [ebx]
	test	cl, cl
	je	SHORT $LN56@soap_QName

; 10259:         break;
; 10260:       /* find next QName */
; 10261:       n = 1;
; 10262:       while (s[n] && !soap_blank(s[n]))

	mov	al, BYTE PTR [ebx+1]
	mov	edi, 1
	mov	DWORD PTR _n$82452[esp+16], edi
	test	al, al
	je	SHORT $LN18@soap_QName
$LN60@soap_QName:
	jl	SHORT $LN17@soap_QName
	cmp	al, 32					; 00000020H
	jle	SHORT $LN58@soap_QName
$LN17@soap_QName:
	mov	al, BYTE PTR [edi+ebx+1]

; 10263:         n++;

	inc	edi
	test	al, al
	jne	SHORT $LN60@soap_QName
$LN58@soap_QName:
	mov	DWORD PTR _n$82452[esp+16], edi
$LN18@soap_QName:

; 10264:       /* normal prefix: pass string as is */
; 10265:       if (*s != '"')

	cmp	cl, 34					; 00000022H
	je	SHORT $LN16@soap_QName

; 10266:       { soap_append_lab(soap, s, n);

	push	edi
	push	ebx
	mov	esi, ebp
	call	_soap_append_lab
	add	esp, 8

; 10267: #ifndef WITH_LEAN
; 10268:         if ((soap->mode & SOAP_XML_CANONICAL))

	test	DWORD PTR [ebp+8], 16384		; 00004000H
	je	$LN12@soap_QName

; 10269:         { const char *r = strchr(s, ':');

	push	58					; 0000003aH
	push	ebx
	call	_strchr
	add	esp, 8

; 10270:           if (r)

	test	eax, eax
	je	$LN12@soap_QName

; 10271:             soap_utilize_ns(soap, s, r - s);

	sub	eax, ebx
	push	ebx
	call	_soap_utilize_ns
	add	esp, 4

; 10272:         }
; 10273: #endif
; 10274:       }
; 10275:       else /* URL-based string prefix */

	jmp	$LN12@soap_QName
$LN16@soap_QName:

; 10259:         break;
; 10260:       /* find next QName */
; 10261:       n = 1;
; 10262:       while (s[n] && !soap_blank(s[n]))

	inc	ebx

; 10276:       { const char *q;
; 10277:         s++;
; 10278:         q = strchr(s, '"');

	push	34					; 00000022H
	push	ebx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _q$82466[esp+20], eax

; 10279:         if (q)

	test	eax, eax
	je	$LN12@soap_QName

; 10280:         { struct Namespace *p = soap->local_namespaces;

	mov	esi, DWORD PTR [ebp+84]

; 10281:           if (p)

	test	esi, esi
	je	SHORT $LN54@soap_QName

; 10282:           { for (; p->id; p++)

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN54@soap_QName
	npad	1
$LL10@soap_QName:

; 10283:             { if (p->ns)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@soap_QName

; 10284:                 if (!soap_tag_cmp(s, p->ns))

	push	eax
	push	ebx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	je	$LN42@soap_QName
$LN6@soap_QName:

; 10285:                   break;
; 10286:               if (p->in)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN9@soap_QName

; 10287:                 if (!soap_tag_cmp(s, p->in))

	push	eax
	push	ebx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	je	$LN42@soap_QName
$LN9@soap_QName:

; 10282:           { for (; p->id; p++)

	add	esi, 16					; 00000010H
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL10@soap_QName
$LN54@soap_QName:

; 10296:           { char *r = soap_strdup(soap, s);

	xor	edi, edi
	test	ebx, ebx
	je	SHORT $LN55@soap_QName
	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL50@soap_QName:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL50@soap_QName
	sub	eax, edx
	inc	eax
	mov	edi, ebp
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN55@soap_QName
	mov	edx, edi
	mov	eax, ebx
	sub	edx, ebx
$LL31@soap_QName:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL31@soap_QName
$LN55@soap_QName:

; 10297:             r[q-s] = '\0';

	mov	ecx, DWORD PTR _q$82466[esp+20]
	mov	eax, edi
	sub	eax, ebx
	mov	BYTE PTR [eax+ecx], 0

; 10298:             sprintf(soap->tmpbuf, "xmlns:_%d", soap->idnum++);

	mov	eax, DWORD PTR [ebp+12212]
	push	eax
	lea	edx, DWORD PTR [eax+1]
	lea	esi, DWORD PTR [ebp+79028]
	push	OFFSET ??_C@_09MCFEFMEO@xmlns?3_?$CFd?$AA@
	push	esi
	mov	DWORD PTR [ebp+12212], edx
	call	_sprintf

; 10299:             soap_set_attr(soap, soap->tmpbuf, r);

	push	edi
	push	esi
	push	ebp
	call	_soap_set_attr

; 10300:             soap_append_lab(soap, soap->tmpbuf + 6, strlen(soap->tmpbuf + 6));

	lea	esi, DWORD PTR [ebp+79034]
	mov	eax, esi
	add	esp, 24					; 00000018H
	lea	edi, DWORD PTR [eax+1]
	npad	1
$LL51@soap_QName:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL51@soap_QName
	sub	eax, edi
	push	eax
	push	esi
	mov	esi, ebp
	call	_soap_append_lab
	mov	edi, DWORD PTR _n$82452[esp+24]
$LN61@soap_QName:

; 10301:           }
; 10302:           soap_append_lab(soap, q + 1, n - (q-s) - 1);

	mov	eax, DWORD PTR _q$82466[esp+28]
	mov	ecx, edi
	sub	ecx, eax
	add	esp, 8
	lea	edx, DWORD PTR [ecx+ebx-1]
	push	edx
	inc	eax
	push	eax
	mov	esi, ebp
	call	_soap_append_lab
	add	esp, 8
$LN12@soap_QName:

; 10303:         }
; 10304:       }
; 10305:       /* advance to next and add spacing */
; 10306:       s += n;

	add	ebx, edi

; 10307:       if (*s)

	cmp	BYTE PTR [ebx], 0
	je	$LL24@soap_QName

; 10308:         soap_append_lab(soap, " ", 1);

	push	1
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	esi, ebp
	call	_soap_append_lab
	add	esp, 8

; 10309:     }

	jmp	$LL24@soap_QName
$LN42@soap_QName:

; 10288:                   break;
; 10289:             }
; 10290:           }
; 10291:           /* URL is in the namespace table? */
; 10292:           if (p && p->id)

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	$LN54@soap_QName

; 10293:           { soap_append_lab(soap, p->id, strlen(p->id));

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$LL49@soap_QName:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL49@soap_QName
	sub	eax, edx
	push	eax
	push	esi
	mov	esi, ebp
	call	_soap_append_lab

; 10294:           }
; 10295:           else /* not in namespace table: create xmlns binding */

	jmp	SHORT $LN61@soap_QName
_soap_QName2s ENDP
_TEXT	ENDS
PUBLIC	_soap_wstring_out
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tmp$ = 8						; size = 1
_s$ = 8							; size = 4
_soap_wstring_out PROC
; _soap$ = eax

; 8876 : { const char *t;

	push	ebx
	mov	ebx, DWORD PTR _s$[esp]

; 8877 :   char tmp;
; 8878 :   register soap_wchar c;
; 8879 : #ifdef WITH_DOM
; 8880 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 8881 :   { wchar_t *r = (wchar_t*)s;
; 8882 :     int n = 1;
; 8883 :     while (*r++)
; 8884 :       n++;
; 8885 :     soap->dom->wide = r = (wchar_t*)soap_malloc(soap, n * sizeof(wchar_t));
; 8886 :     while (n--)
; 8887 :       *r++ = *s++;
; 8888 :     return SOAP_OK;
; 8889 :   }
; 8890 : #endif
; 8891 :   while ((c = *s++))

	movzx	ecx, WORD PTR [ebx]
	push	esi
	push	edi
	mov	edi, eax
	test	ecx, ecx
	je	$LN37@soap_wstri
$LL26@soap_wstri:

; 8892 :   { switch (c)

	lea	eax, DWORD PTR [ecx-9]
	add	ebx, 2
	cmp	eax, 53					; 00000035H
	ja	SHORT $LN6@soap_wstri
	movzx	eax, BYTE PTR $LN39@soap_wstri[eax]
	jmp	DWORD PTR $LN43@soap_wstri[eax*4]
$LN22@soap_wstri:

; 8893 :     {
; 8894 :     case 0x09:
; 8895 :       if (flag)
; 8896 :         t = "&#x9;";
; 8897 :       else
; 8898 :         t = "\t";

	mov	ecx, OFFSET ??_C@_01GPOEFGEJ@?7?$AA@

; 8899 :       break;

	jmp	SHORT $LN38@soap_wstri
$LN19@soap_wstri:

; 8900 :     case 0x0A:
; 8901 :       if (flag || !(soap->mode & SOAP_XML_CANONICAL))

	test	DWORD PTR [edi+8], 16384		; 00004000H
	je	SHORT $LN17@soap_wstri

; 8903 :       else
; 8904 :         t = "\n";

	mov	ecx, OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	jmp	SHORT $LN38@soap_wstri
$LN17@soap_wstri:

; 8902 :         t = "&#xA;";

	mov	ecx, OFFSET ??_C@_05PKMIGNBP@?$CG?$CDxA?$DL?$AA@

; 8905 :       break;

	jmp	SHORT $LN38@soap_wstri
$LN15@soap_wstri:

; 8906 :     case 0x0D:
; 8907 :       t = "&#xD;";

	mov	ecx, OFFSET ??_C@_05PMADKPPE@?$CG?$CDxD?$DL?$AA@

; 8908 :       break;

	jmp	SHORT $LN38@soap_wstri
$LN14@soap_wstri:

; 8909 :     case '&':
; 8910 :       t = "&amp;";

	mov	ecx, OFFSET ??_C@_05JKJFEODM@?$CGamp?$DL?$AA@

; 8911 :       break;

	jmp	SHORT $LN38@soap_wstri
$LN13@soap_wstri:

; 8912 :     case '<':
; 8913 :       t = "&lt;";

	mov	ecx, OFFSET ??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@

; 8914 :       break;

	jmp	SHORT $LN38@soap_wstri
$LN12@soap_wstri:

; 8915 :     case '>':
; 8916 :       if (flag)
; 8917 :         t = ">";
; 8918 :       else
; 8919 :         t = "&gt;";

	mov	ecx, OFFSET ??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@

; 8920 :       break;

	jmp	SHORT $LN38@soap_wstri
$LN8@soap_wstri:

; 8921 :     case '"':
; 8922 :       if (flag)
; 8923 :         t = "&quot;";
; 8924 :       else
; 8925 :         t = "\"";

	mov	ecx, OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
$LN38@soap_wstri:

; 8934 :         return soap->error;
; 8935 :       continue;
; 8936 :     }
; 8937 :     if (soap_send(soap, t))

	mov	eax, ecx
	lea	esi, DWORD PTR [eax+1]
$LL40@soap_wstri:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL40@soap_wstri
	sub	eax, esi
	push	eax
	push	ecx
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8

; 8938 :       return soap->error;
; 8939 :   }

	jmp	SHORT $LN42@soap_wstri
$LN6@soap_wstri:

; 8926 :       break;
; 8927 :     default:
; 8928 :       if (c >= 0x20 && c < 0x80)

	lea	edx, DWORD PTR [ecx-32]
	cmp	edx, 95					; 0000005fH
	ja	SHORT $LN5@soap_wstri

; 8929 :       { tmp = (char)c;
; 8930 :         if (soap_send_raw(soap, &tmp, 1))

	lea	eax, DWORD PTR _tmp$[esp+8]
	push	1
	push	eax
	mov	eax, edi
	mov	BYTE PTR _tmp$[esp+16], cl
	call	_soap_send_raw
	add	esp, 8

; 8932 :       }

	jmp	SHORT $LN42@soap_wstri
$LN5@soap_wstri:

; 8933 :       else if (soap_pututf8(soap, (unsigned long)c))

	call	_soap_pututf8
$LN42@soap_wstri:
	test	eax, eax
	jne	SHORT $LN35@soap_wstri
	movzx	ecx, WORD PTR [ebx]
	test	ecx, ecx
	jne	$LL26@soap_wstri
$LN37@soap_wstri:
	pop	edi
	pop	esi

; 8940 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 8941 : }

	ret	0
$LN35@soap_wstri:

; 8931 :           return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 8941 : }

	ret	0
	npad	1
$LN43@soap_wstri:
	DD	$LN22@soap_wstri
	DD	$LN19@soap_wstri
	DD	$LN15@soap_wstri
	DD	$LN8@soap_wstri
	DD	$LN14@soap_wstri
	DD	$LN13@soap_wstri
	DD	$LN12@soap_wstri
	DD	$LN6@soap_wstri
$LN39@soap_wstri:
	DB	0
	DB	1
	DB	7
	DB	7
	DB	2
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	3
	DB	7
	DB	7
	DB	7
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	6
_soap_wstring_out ENDP
_TEXT	ENDS
PUBLIC	_soap_string_out
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_wc$81551 = -12						; size = 2
_mask$ = -8						; size = 4
_m$81552 = -4						; size = 4
_flag$ = 8						; size = 4
_soap_string_out PROC
; _soap$ = ecx
; _s$ = eax

; 8317 : { register const char *t;

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 8318 :   register soap_wchar c;
; 8319 :   register soap_wchar mask = 0xFFFFFF80UL;
; 8320 : #ifdef WITH_DOM
; 8321 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 8322 :   { soap->dom->data = soap_strdup(soap, s);
; 8323 :     return SOAP_OK;
; 8324 :   }
; 8325 : #endif
; 8326 :   if (soap->mode & SOAP_C_UTFSTRING)

	test	DWORD PTR [edi+8], 2097152		; 00200000H
	mov	esi, eax
	mov	DWORD PTR _mask$[esp+28], -128		; ffffff80H
	je	SHORT $LN56@soap_strin

; 8327 :     mask = 0;

	mov	DWORD PTR _mask$[esp+28], 0
$LN56@soap_strin:

; 8328 :   t = s;
; 8329 :   while ((c = *t++))

	movsx	ebx, BYTE PTR [esi]
	mov	ebp, esi
	test	ebx, ebx
	je	$LN54@soap_strin
$LL39@soap_strin:

; 8330 :   { switch (c)

	lea	eax, DWORD PTR [ebx-9]
	inc	ebp
	cmp	eax, 53					; 00000035H
	ja	$LN9@soap_strin
	movzx	eax, BYTE PTR $LN55@soap_strin[eax]
	jmp	DWORD PTR $LN61@soap_strin[eax*4]
$LN35@soap_strin:

; 8331 :     {
; 8332 :     case 0x09:
; 8333 :       if (flag)

	cmp	DWORD PTR _flag$[esp+24], 0
	je	$LN4@soap_strin

; 8334 :       { if (soap_send_raw(soap, s, t - s - 1) || soap_send_raw(soap, "&#x9;", 5))

	mov	ecx, ebp
	sub	ecx, esi
	dec	ecx
	push	ecx
	push	esi
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	$LN45@soap_strin
	push	5
	push	OFFSET ??_C@_05KACKFEPH@?$CG?$CDx9?$DL?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8

; 8336 :         s = t;
; 8337 :       }
; 8338 :       break;

	jmp	$LN60@soap_strin
$LN31@soap_strin:

; 8339 :     case 0x0A:
; 8340 :       if (flag || !(soap->mode & SOAP_XML_CANONICAL))

	cmp	DWORD PTR _flag$[esp+24], 0
	jne	SHORT $LN29@soap_strin
	test	DWORD PTR [edi+8], 16384		; 00004000H
	jne	$LN4@soap_strin
$LN29@soap_strin:

; 8341 :       { if (soap_send_raw(soap, s, t - s - 1) || soap_send_raw(soap, "&#xA;", 5))

	mov	edx, ebp
	sub	edx, esi
	dec	edx
	push	edx
	push	esi
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	$LN45@soap_strin
	push	5
	push	OFFSET ??_C@_05PKMIGNBP@?$CG?$CDxA?$DL?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8

; 8342 :           return soap->error;
; 8343 :         s = t;
; 8344 :       }
; 8345 :       break;

	jmp	$LN60@soap_strin
$LN26@soap_strin:

; 8346 :     case 0x0D:
; 8347 :       if (soap_send_raw(soap, s, t - s - 1) || soap_send_raw(soap, "&#xD;", 5))

	mov	eax, ebp
	sub	eax, esi
	dec	eax
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	$LN45@soap_strin
	push	5
	push	OFFSET ??_C@_05PMADKPPE@?$CG?$CDxD?$DL?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8

; 8348 :         return soap->error;
; 8349 :       s = t;
; 8350 :       break;

	jmp	$LN60@soap_strin
$LN23@soap_strin:

; 8351 :     case '&':
; 8352 :       if (soap_send_raw(soap, s, t - s - 1) || soap_send_raw(soap, "&amp;", 5))

	mov	ecx, ebp
	sub	ecx, esi
	dec	ecx
	push	ecx
	push	esi
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	$LN45@soap_strin
	push	5
	push	OFFSET ??_C@_05JKJFEODM@?$CGamp?$DL?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8

; 8353 :         return soap->error;
; 8354 :       s = t;
; 8355 :       break;

	jmp	$LN60@soap_strin
$LN20@soap_strin:

; 8356 :     case '<':
; 8357 :       if (soap_send_raw(soap, s, t - s - 1) || soap_send_raw(soap, "&lt;", 4))

	mov	edx, ebp
	sub	edx, esi
	dec	edx
	push	edx
	push	esi
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	$LN45@soap_strin
	push	4
	push	OFFSET ??_C@_04GJOGLFEJ@?$CGlt?$DL?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8

; 8358 :         return soap->error;
; 8359 :       s = t;
; 8360 :       break;

	jmp	$LN60@soap_strin
$LN17@soap_strin:

; 8361 :     case '>':
; 8362 :       if (!flag)

	cmp	DWORD PTR _flag$[esp+24], 0
	jne	$LN4@soap_strin

; 8363 :       { if (soap_send_raw(soap, s, t - s - 1) || soap_send_raw(soap, "&gt;", 4))

	mov	eax, ebp
	sub	eax, esi
	dec	eax
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	$LN45@soap_strin
	push	4
	push	OFFSET ??_C@_04LOOHDCEI@?$CGgt?$DL?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8

; 8364 :           return soap->error;
; 8365 :         s = t;
; 8366 :       }
; 8367 :       break;

	jmp	$LN60@soap_strin
$LN13@soap_strin:

; 8368 :     case '"':
; 8369 :       if (flag)

	cmp	DWORD PTR _flag$[esp+24], 0
	je	$LN4@soap_strin

; 8370 :       { if (soap_send_raw(soap, s, t - s - 1) || soap_send_raw(soap, "&quot;", 6))

	mov	ecx, ebp
	sub	ecx, esi
	dec	ecx
	push	ecx
	push	esi
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	$LN45@soap_strin
	push	6
	push	OFFSET ??_C@_06DDLNFFBN@?$CGquot?$DL?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8

; 8371 :           return soap->error;
; 8372 :         s = t;
; 8373 :       }
; 8374 :       break;

	jmp	$LN60@soap_strin
$LN9@soap_strin:

; 8375 :     default:
; 8376 : #ifndef WITH_LEANER
; 8377 : #ifdef HAVE_MBTOWC
; 8378 :       if (soap->mode & SOAP_C_MBSTRING)

	test	DWORD PTR [edi+8], 4194304		; 00400000H
	je	SHORT $LN57@soap_strin

; 8379 :       { wchar_t wc;
; 8380 :         register int m = mbtowc(&wc, t - 1, MB_CUR_MAX);

	call	____mb_cur_max_func
	push	eax
	lea	edx, DWORD PTR [ebp-1]
	push	edx
	lea	eax, DWORD PTR _wc$81551[esp+36]
	push	eax
	call	_mbtowc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _m$81552[esp+28], eax

; 8381 :         if (m > 0 && wc != c)

	test	eax, eax
	jle	SHORT $LN57@soap_strin
	movzx	ecx, WORD PTR _wc$81551[esp+28]
	cmp	ecx, ebx
	je	SHORT $LN57@soap_strin

; 8382 :         { if (soap_send_raw(soap, s, t - s - 1) || soap_pututf8(soap, wc))

	mov	edx, ebp
	sub	edx, esi
	dec	edx
	push	edx
	push	esi
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN45@soap_strin
	movzx	ecx, WORD PTR _wc$81551[esp+28]
	call	_soap_pututf8
	test	eax, eax
	jne	SHORT $LN45@soap_strin

; 8383 :             return soap->error;
; 8384 :           s = t += m - 1;

	mov	eax, DWORD PTR _m$81552[esp+28]
	lea	ebp, DWORD PTR [eax+ebp-1]

; 8385 :           continue;

	jmp	SHORT $LN58@soap_strin
$LN57@soap_strin:

; 8386 :         }
; 8387 :       }
; 8388 : #endif
; 8389 : #endif
; 8390 : #ifndef WITH_NOSTRINGTOUTF8
; 8391 :       if ((c & mask) || !(c & 0xFFFFFFE0UL))

	mov	ecx, DWORD PTR _mask$[esp+28]
	test	ebx, ecx
	jne	SHORT $LN3@soap_strin
	test	ebx, -32				; ffffffe0H
	jne	SHORT $LN4@soap_strin
$LN3@soap_strin:

; 8392 :       { if (soap_send_raw(soap, s, t - s - 1) || soap_pututf8(soap, (unsigned char)c))

	mov	edx, ebp
	sub	edx, esi
	dec	edx
	push	edx
	push	esi
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN45@soap_strin
	movzx	ecx, bl
	call	_soap_pututf8
$LN60@soap_strin:
	test	eax, eax
	jne	SHORT $LN45@soap_strin
$LN58@soap_strin:

; 8393 :           return soap->error;
; 8394 :         s = t;

	mov	esi, ebp
$LN4@soap_strin:

; 8328 :   t = s;
; 8329 :   while ((c = *t++))

	movsx	ebx, BYTE PTR [ebp]
	test	ebx, ebx
	jne	$LL39@soap_strin
$LN54@soap_strin:

; 8395 :       }
; 8396 : #endif
; 8397 :     }
; 8398 :   }
; 8399 :   return soap_send_raw(soap, s, t - s - 1);

	sub	ebp, esi
	push	ebp
	push	esi
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 8400 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN45@soap_strin:

; 8335 :           return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 8400 : }

	add	esp, 12					; 0000000cH
	ret	0
	npad	1
$LN61@soap_strin:
	DD	$LN35@soap_strin
	DD	$LN31@soap_strin
	DD	$LN26@soap_strin
	DD	$LN13@soap_strin
	DD	$LN23@soap_strin
	DD	$LN20@soap_strin
	DD	$LN17@soap_strin
	DD	$LN9@soap_strin
$LN55@soap_strin:
	DB	0
	DB	1
	DB	7
	DB	7
	DB	2
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	3
	DB	7
	DB	7
	DB	7
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	6
_soap_string_out ENDP
_TEXT	ENDS
PUBLIC	_soap_attribute
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_value$ = 8						; size = 4
_soap_attribute PROC
; _soap$ = esi
; _name$ = eax

; 7525 : #ifdef WITH_DOM
; 7526 :   if ((soap->mode & SOAP_XML_DOM) && !(soap->mode & SOAP_XML_CANONICAL) && soap->dom)
; 7527 :   { register struct soap_dom_attribute *a = (struct soap_dom_attribute*)soap_malloc(soap, sizeof(struct soap_dom_attribute));
; 7528 :     a->next = soap->dom->atts;
; 7529 :     a->nstr = NULL;
; 7530 :     a->name = soap_strdup(soap, name);
; 7531 :     a->data = soap_strdup(soap, value);
; 7532 :     a->wide = NULL;
; 7533 :     a->soap = soap;
; 7534 :     soap->dom->atts = a;
; 7535 :     return SOAP_OK;
; 7536 :   }
; 7537 : #endif
; 7538 : #ifndef WITH_LEAN
; 7539 :   if (soap->mode & SOAP_XML_CANONICAL)

	test	DWORD PTR [esi+8], 16384		; 00004000H
	push	ebx
	mov	ebx, DWORD PTR _value$[esp]
	push	edi
	mov	edi, eax
	je	SHORT $LN10@soap_attri

; 7540 :   { /* TODO: consider using this code to handle default namespace bindings
; 7541 :     if (!strncmp(name, "xmlns", 5) && (name[5] == ':' || name[5] == '\0'))
; 7542 :     { if (name[5] == ':')
; 7543 :         soap_push_ns(soap, name + 6, value, 0);
; 7544 :       else
; 7545 :         soap_push_ns(soap, "", value, 0);
; 7546 :     }
; 7547 :     */
; 7548 :     if (!strncmp(name, "xmlns:", 6))

	push	6
	push	OFFSET ??_C@_06PNFLLAEF@xmlns?3?$AA@
	push	edi
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@soap_attri

; 7549 :       soap_push_ns(soap, name + 6, value, 0);

	push	eax
	push	ebx
	add	edi, 6
	push	edi
	push	esi
	call	_soap_push_ns
	add	esp, 16					; 00000010H
	pop	edi

; 7562 :   }
; 7563 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 7564 : }

	ret	0
$LN9@soap_attri:

; 7550 :     else if (soap_set_attr(soap, name, value))

	push	ebx
	push	edi
	push	esi
	call	_soap_set_attr
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN2@soap_attri
$LN4@soap_attri:

; 7556 :       return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	ebx

; 7564 : }

	ret	0
$LN10@soap_attri:

; 7551 :       return soap->error;
; 7552 :   }
; 7553 :   else
; 7554 : #endif
; 7555 :   { if (soap_send(soap, " ") || soap_send(soap, name))

	push	1
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@soap_attri
	test	edi, edi
	je	SHORT $LN19@soap_attri
	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
$LL20@soap_attri:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL20@soap_attri
	sub	eax, edx
	push	eax
	push	edi
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@soap_attri
$LN19@soap_attri:

; 7557 :     if (value)

	test	ebx, ebx
	je	SHORT $LN2@soap_attri

; 7558 :       if (soap_send_raw(soap, "=\"", 2)
; 7559 :        || soap_string_out(soap, value, 1)
; 7560 :        || soap_send_raw(soap, "\"", 1))

	push	2
	push	OFFSET ??_C@_02ILLPBGAO@?$DN?$CC?$AA@
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@soap_attri
	push	1
	mov	eax, ebx
	mov	ecx, esi
	call	_soap_string_out
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@soap_attri
	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax

; 7561 :         return soap->error;

	jne	SHORT $LN4@soap_attri
$LN2@soap_attri:
	pop	edi

; 7562 :   }
; 7563 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 7564 : }

	ret	0
_soap_attribute ENDP
_TEXT	ENDS
PUBLIC	_soap_element_start_end_out
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_soap_element_start_end_out PROC
; _soap$ = edi

; 7265 : #ifndef WITH_LEAN
; 7266 :   if (soap->mode & SOAP_XML_CANONICAL)

	test	DWORD PTR [edi+8], 16384		; 00004000H
	push	ebx
	push	esi
	je	$LN44@soap_eleme@2

; 7267 :   { struct soap_nlist *np;
; 7268 :     for (tp = soap->attributes; tp; tp = tp->next)

	mov	ebx, DWORD PTR [edi+87292]
	test	ebx, ebx
	je	SHORT $LN21@soap_eleme@2
	npad	7
$LL23@soap_eleme@2:

; 7269 :     { if (tp->visible && tp->name)

	cmp	WORD PTR [ebx+16], 0
	je	SHORT $LN22@soap_eleme@2
	lea	esi, DWORD PTR [ebx+18]
	test	esi, esi
	je	SHORT $LN22@soap_eleme@2

; 7270 :       { const char *s = strchr(tp->name, ':');

	push	58					; 0000003aH
	push	esi
	call	_strchr
	add	esp, 8

; 7271 :         if (s)

	test	eax, eax
	je	SHORT $LN22@soap_eleme@2

; 7272 :           soap_utilize_ns(soap, tp->name, s - tp->name);

	sub	eax, ebx
	push	esi
	sub	eax, 18					; 00000012H
	mov	esi, edi
	call	_soap_utilize_ns
	add	esp, 4
$LN22@soap_eleme@2:
	mov	ebx, DWORD PTR [ebx]
	test	ebx, ebx
	jne	SHORT $LL23@soap_eleme@2
$LN21@soap_eleme@2:

; 7273 :       }
; 7274 :     }
; 7275 :     for (np = soap->nlist; np; np = np->next)

	mov	esi, DWORD PTR [edi+88]
	test	esi, esi
	je	SHORT $LN44@soap_eleme@2
	npad	6
$LL18@soap_eleme@2:

; 7276 :     { if (np->index == 1 && np->ns)

	cmp	WORD PTR [esi+8], 1
	jne	SHORT $LN17@soap_eleme@2
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN17@soap_eleme@2

; 7277 :       { sprintf(soap->tmpbuf, "xmlns:%s", np->id);

	lea	eax, DWORD PTR [esi+16]
	push	eax
	lea	ebx, DWORD PTR [edi+79028]
	push	OFFSET ??_C@_08HMPLFLKJ@xmlns?3?$CFs?$AA@
	push	ebx
	call	_sprintf

; 7278 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Enabling utilized binding (level=%u) %s='%s'\n", np->level, soap->tmpbuf, np->ns));
; 7279 :         soap_set_attr(soap, soap->tmpbuf, np->ns);

	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	push	ebx
	push	edi
	call	_soap_set_attr

; 7280 :         np->index = 2;

	mov	edx, 2
	add	esp, 24					; 00000018H
	mov	WORD PTR [esi+8], dx
$LN17@soap_eleme@2:
	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL18@soap_eleme@2
$LN44@soap_eleme@2:

; 7281 :       }
; 7282 :     }
; 7283 :   }
; 7284 : #endif
; 7285 : #ifdef WITH_DOM
; 7286 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 7287 :   { register struct soap_dom_attribute **att;
; 7288 :     att = &soap->dom->atts;
; 7289 :     for (tp = soap->attributes; tp; tp = tp->next)
; 7290 :     { if (tp->visible)
; 7291 :       { *att = (struct soap_dom_attribute*)soap_malloc(soap, sizeof(struct soap_dom_attribute));
; 7292 :         if (!*att)
; 7293 :           return soap->error = SOAP_EOM;
; 7294 :         (*att)->next = NULL;
; 7295 :         (*att)->nstr = NULL;
; 7296 :         (*att)->name = soap_strdup(soap, tp->name);
; 7297 :         (*att)->data = soap_strdup(soap, tp->value);
; 7298 :         (*att)->wide = NULL;
; 7299 :         (*att)->soap = soap;
; 7300 :         att = &(*att)->next;
; 7301 :         tp->visible = 0;
; 7302 :       }
; 7303 :     }
; 7304 :     return SOAP_OK;
; 7305 :   }
; 7306 : #endif
; 7307 :   for (tp = soap->attributes; tp; tp = tp->next)

	mov	esi, DWORD PTR [edi+87292]
	test	esi, esi
	je	$LN12@soap_eleme@2
	npad	3
$LL14@soap_eleme@2:

; 7308 :   { if (tp->visible)

	cmp	WORD PTR [esi+16], 0
	je	$LN13@soap_eleme@2

; 7309 :     {
; 7310 : #ifdef WITH_XMLNS
; 7311 :       const char *s = strchr(tp->name, ':');
; 7312 :       if (s)
; 7313 :       { size_t n = s - tp->name;
; 7314 :         if (soap->nlist && !strncmp(soap->nlist->id, tp->name, n) && !soap->nlist->id[n])
; 7315 :           s++;
; 7316 :         else
; 7317 :           s = tp->name;
; 7318 :         if (soap_send(soap, " ") || soap_send(soap, s))
; 7319 :           return soap->error;
; 7320 :       }
; 7321 :       else
; 7322 : #endif
; 7323 :       if (soap_send(soap, " ") || soap_send(soap, tp->name))

	push	1
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	$LN9@soap_eleme@2
	lea	ecx, DWORD PTR [esi+18]
	test	ecx, ecx
	je	SHORT $LN42@soap_eleme@2
	mov	eax, ecx
	lea	ebx, DWORD PTR [eax+1]
$LL43@soap_eleme@2:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL43@soap_eleme@2
	sub	eax, ebx
	push	eax
	push	ecx
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	$LN9@soap_eleme@2
$LN42@soap_eleme@2:

; 7325 :       if (tp->visible == 2 && tp->value)

	cmp	WORD PTR [esi+16], 2
	jne	SHORT $LN7@soap_eleme@2
	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN7@soap_eleme@2

; 7326 :         if (soap_send_raw(soap, "=\"", 2)
; 7327 :          || soap_string_out(soap, tp->value, 1)
; 7328 :          || soap_send_raw(soap, "\"", 1))

	push	2
	push	OFFSET ??_C@_02ILLPBGAO@?$DN?$CC?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@soap_eleme@2
	mov	eax, DWORD PTR [esi+4]
	push	1
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@soap_eleme@2
	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@soap_eleme@2
$LN7@soap_eleme@2:

; 7329 :           return soap->error;
; 7330 :       tp->visible = 0;

	xor	eax, eax
	mov	WORD PTR [esi+16], ax
$LN13@soap_eleme@2:
	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	$LL14@soap_eleme@2
$LN12@soap_eleme@2:

; 7331 :     }
; 7332 :   }
; 7333 :   if (tag)

	mov	esi, DWORD PTR _tag$[esp+4]

; 7337 :     { if (soap_send_raw(soap, ">", 1)
; 7338 :        || soap_element_end_out(soap, tag))

	mov	eax, edi
	test	esi, esi
	je	SHORT $LN5@soap_eleme@2

; 7334 :   {
; 7335 : #ifndef WITH_LEAN
; 7336 :     if (soap->mode & SOAP_XML_CANONICAL)

	test	DWORD PTR [edi+8], 16384		; 00004000H
	je	SHORT $LN4@soap_eleme@2

; 7337 :     { if (soap_send_raw(soap, ">", 1)
; 7338 :        || soap_element_end_out(soap, tag))

	push	1
	push	OFFSET ??_C@_01PPODPGHN@?$DO?$AA@
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@soap_eleme@2
	mov	eax, edi
	call	_soap_element_end_out
	test	eax, eax
	jne	SHORT $LN9@soap_eleme@2
$LN1@soap_eleme@2:
	pop	esi

; 7339 :         return soap->error;
; 7340 :       return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 7349 : }

	ret	0
$LN9@soap_eleme@2:

; 7324 :         return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	esi
	pop	ebx

; 7349 : }

	ret	0
$LN4@soap_eleme@2:

; 7341 :     }
; 7342 : #endif
; 7343 :     soap->level--;	/* decrement level just before /> */

	dec	DWORD PTR [edi+12444]

; 7344 :     if (soap_send_raw(soap, "/>", 2))

	push	2
	push	OFFSET ??_C@_02HCGKDMEN@?1?$DO?$AA@
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@soap_eleme@2
	mov	eax, DWORD PTR [edi+90460]
	pop	esi
	pop	ebx

; 7349 : }

	ret	0
$LN5@soap_eleme@2:

; 7345 :       return soap->error;
; 7346 :     return SOAP_OK;
; 7347 :   }
; 7348 :   return soap_send_raw(soap, ">", 1);

	push	1
	push	OFFSET ??_C@_01PPODPGHN@?$DO?$AA@
	call	_soap_send_raw
	add	esp, 8
	pop	esi
	pop	ebx

; 7349 : }

	ret	0
_soap_element_start_end_out ENDP
_TEXT	ENDS
PUBLIC	_soap_element
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_id$ = 12						; size = 4
_type$ = 16						; size = 4
_soap_element PROC
; _soap$ = eax

; 6937 : {

	push	ebx
	mov	ebx, DWORD PTR _type$[esp]
	push	ebp
	mov	ebp, DWORD PTR _tag$[esp+4]
	push	esi
	mov	esi, eax

; 6938 : #ifdef WITH_XMLNS
; 6939 :   register const char *s;
; 6940 : #endif
; 6941 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Element begin tag='%s' id='%d' type='%s'\n", tag, id, type?type:""));
; 6942 : #ifdef WITH_DOM
; 6943 :   if (soap->part == SOAP_BEGIN_SECURITY && (soap->mode & SOAP_XML_CANONICAL) && !(soap->mode & SOAP_DOM_ASIS))
; 6944 :   { register struct soap_nlist *np;
; 6945 :     /* wsu:Id found: clear xmlns renderings, so re-emit them for exc-c14n */
; 6946 :     for (np = soap->nlist; np; np = np->next)
; 6947 :     { if (np->index == 2)
; 6948 :         np->index = 0;
; 6949 :     }
; 6950 :   }
; 6951 :   if (soap->mode & SOAP_XML_DOM)
; 6952 :   { register struct soap_dom_element *elt = (struct soap_dom_element*)soap_malloc(soap, sizeof(struct soap_dom_element));
; 6953 :     if (!elt)
; 6954 :       return soap->error = SOAP_EOM;
; 6955 :     elt->soap = soap;
; 6956 :     elt->next = NULL;
; 6957 :     elt->prnt = soap->dom;
; 6958 :     elt->name = soap_strdup(soap, tag);
; 6959 :     elt->elts = NULL;
; 6960 :     elt->atts = NULL;
; 6961 :     elt->nstr = NULL;
; 6962 :     elt->data = NULL;
; 6963 :     elt->wide = NULL;
; 6964 :     elt->node = NULL;
; 6965 :     elt->type = 0;
; 6966 :     elt->head = NULL;
; 6967 :     elt->tail = NULL;
; 6968 :     if (soap->dom)
; 6969 :     { struct soap_dom_element *p = soap->dom->elts;
; 6970 :       if (p)
; 6971 :       { while (p->next)
; 6972 :           p = p->next;
; 6973 :         p->next = elt;
; 6974 :       }
; 6975 :       else
; 6976 :         soap->dom->elts = elt;
; 6977 :     }
; 6978 :     soap->dom = elt;
; 6979 :   }
; 6980 :   else
; 6981 :   {
; 6982 : #endif
; 6983 :     soap->level++;
; 6984 : #ifndef WITH_LEAN
; 6985 :     if (!soap->ns)

	movzx	eax, WORD PTR [esi+87302]
	inc	DWORD PTR [esi+12444]
	mov	ecx, DWORD PTR [esi+12444]
	push	edi
	test	ax, ax
	jne	SHORT $LN39@soap_eleme@3

; 6986 :     { if (!(soap->mode & SOAP_XML_CANONICAL)
; 6987 :        && soap_send(soap, soap->prolog ? soap->prolog : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"))

	test	DWORD PTR [esi+8], 16384		; 00004000H
	jne	SHORT $LN69@soap_eleme@3
	mov	edx, DWORD PTR [esi+90400]
	test	edx, edx
	jne	SHORT $LN43@soap_eleme@3
	mov	edx, OFFSET ??_C@_0CI@FMJEECLD@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCUT@
$LN43@soap_eleme@3:
	mov	eax, edx
	lea	edi, DWORD PTR [eax+1]
$LL65@soap_eleme@3:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL65@soap_eleme@3
	sub	eax, edi
	push	eax
	push	edx
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	je	SHORT $LN69@soap_eleme@3
$LN33@soap_eleme@3:

; 7019 :       return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7093 : }

	ret	0
$LN39@soap_eleme@3:

; 6988 :         return soap->error;
; 6989 :     }
; 6990 :     else if (soap->mode & SOAP_XML_INDENT)

	test	DWORD PTR [esi+8], 8192			; 00002000H
	je	SHORT $LN69@soap_eleme@3

; 6991 :     { if (soap->ns == 1 && soap_send_raw(soap, soap_indent, soap->level < sizeof(soap_indent) ? soap->level : sizeof(soap_indent) - 1))

	cmp	ax, 1
	jne	SHORT $LN35@soap_eleme@3
	cmp	ecx, 11					; 0000000bH
	jb	SHORT $LN45@soap_eleme@3
	mov	ecx, 10					; 0000000aH
$LN45@soap_eleme@3:
	push	ecx
	push	OFFSET _soap_indent
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax

; 6992 :         return soap->error;

	jne	SHORT $LN33@soap_eleme@3
$LN35@soap_eleme@3:

; 6993 :       soap->body = 1;

	mov	eax, 1
	mov	WORD PTR [esi+12442], ax
$LN69@soap_eleme@3:

; 6994 :     }
; 6995 : #endif
; 6996 : #ifdef WITH_XMLNS
; 6997 :     s = strchr(tag, ':');
; 6998 :     if (s && strncmp(tag, "SOAP-ENV", s - tag))
; 6999 :     { struct Namespace *ns = soap->local_namespaces;
; 7000 :       size_t n = s - tag;
; 7001 :       if (soap_send_raw(soap, "<", 1)
; 7002 :        || soap_send(soap, s + 1))
; 7003 :         return soap->error;
; 7004 :       if (soap->nlist && !strncmp(soap->nlist->id, tag, n) && !soap->nlist->id[n])
; 7005 :         ns = NULL;
; 7006 :       for (; ns && ns->id; ns++)
; 7007 :       { if (*ns->id && (ns->out || ns->ns) && !strncmp(ns->id, tag, n) && !ns->id[n])
; 7008 :         { soap_push_ns(soap, ns->id, ns->out ? ns->out : ns->ns, 0);
; 7009 :           if (soap_attribute(soap, "xmlns", ns->out ? ns->out : ns->ns))
; 7010 :             return soap->error;
; 7011 :           break;
; 7012 :         }
; 7013 :       }
; 7014 :     }
; 7015 :     else
; 7016 : #endif
; 7017 :     if (soap_send_raw(soap, "<", 1)
; 7018 :      || soap_send(soap, tag))

	push	1
	push	OFFSET ??_C@_01MNNFJEPP@?$DM?$AA@
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN33@soap_eleme@3
	test	ebp, ebp
	je	SHORT $LN64@soap_eleme@3
	mov	eax, ebp
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL66@soap_eleme@3:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL66@soap_eleme@3
	sub	eax, edx
	push	eax
	push	ebp
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN33@soap_eleme@3
$LN64@soap_eleme@3:

; 7020 : #ifdef WITH_DOM
; 7021 :   }
; 7022 : #endif
; 7023 :   if (!soap->ns)

	cmp	WORD PTR [esi+87302], 0
	jne	SHORT $LN29@soap_eleme@3

; 7024 :   { struct Namespace *ns;
; 7025 :     for (ns = soap->local_namespaces; ns && ns->id; ns++)

	mov	edi, DWORD PTR [esi+84]
	test	edi, edi
	je	SHORT $LN29@soap_eleme@3
	npad	6
$LL31@soap_eleme@3:
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN29@soap_eleme@3

; 7026 :     { if (*ns->id && (ns->out || ns->ns))

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN30@soap_eleme@3
	cmp	DWORD PTR [edi+12], 0
	jne	SHORT $LN27@soap_eleme@3
	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN30@soap_eleme@3
$LN27@soap_eleme@3:

; 7027 :       { sprintf(soap->tmpbuf, "xmlns:%s", ns->id);

	push	eax
	lea	ebx, DWORD PTR [esi+79028]
	push	OFFSET ??_C@_08HMPLFLKJ@xmlns?3?$CFs?$AA@
	push	ebx
	call	_sprintf

; 7028 :         if (soap_attribute(soap, soap->tmpbuf, ns->out ? ns->out : ns->ns))

	mov	eax, DWORD PTR [edi+12]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN47@soap_eleme@3
	mov	eax, DWORD PTR [edi+4]
$LN47@soap_eleme@3:
	push	eax
	mov	eax, ebx
	call	_soap_attribute
	add	esp, 4
	test	eax, eax
	jne	$LN33@soap_eleme@3
	mov	ebx, DWORD PTR _type$[esp+12]
$LN30@soap_eleme@3:

; 7024 :   { struct Namespace *ns;
; 7025 :     for (ns = soap->local_namespaces; ns && ns->id; ns++)

	add	edi, 16					; 00000010H
	jne	SHORT $LL31@soap_eleme@3
$LN29@soap_eleme@3:

; 7029 :           return soap->error;
; 7030 :       }
; 7031 :     }
; 7032 :   }
; 7033 :   soap->ns = 1; /* start with 0 or 2, but should be one to continue */
; 7034 : #ifndef WITH_LEAN
; 7035 :   if (soap->mode & SOAP_XML_CANONICAL)

	test	DWORD PTR [esi+8], 16384		; 00004000H
	mov	ecx, 1
	mov	WORD PTR [esi+87302], cx
	je	SHORT $LN70@soap_eleme@3

; 7036 :   { const char *t = strchr(tag, ':');

	push	58					; 0000003aH
	push	ebp
	call	_strchr
	add	esp, 8

; 7037 :     if (t)

	test	eax, eax
	je	SHORT $LN70@soap_eleme@3

; 7038 :       soap_utilize_ns(soap, tag, t - tag);

	sub	eax, ebp
	push	ebp
	call	_soap_utilize_ns
	add	esp, 4
$LN70@soap_eleme@3:

; 7039 :   }
; 7040 : #endif
; 7041 :   if (id > 0)

	cmp	DWORD PTR _id$[esp+12], 0
	jle	SHORT $LN22@soap_eleme@3

; 7042 :   { sprintf(soap->tmpbuf, "_%d", id);

	mov	edx, DWORD PTR _id$[esp+12]
	push	edx
	lea	edi, DWORD PTR [esi+79028]
	push	OFFSET ??_C@_03HCMCBFLP@_?$CFd?$AA@
	push	edi
	call	_sprintf

; 7043 :     if (soap_attribute(soap, "id", soap->tmpbuf))

	push	edi
	mov	eax, OFFSET ??_C@_02EGCJHIOB@id?$AA@
	call	_soap_attribute
	add	esp, 16					; 00000010H
	test	eax, eax

; 7044 :       return soap->error;

	jne	$LN33@soap_eleme@3
$LN22@soap_eleme@3:

; 7045 :   }
; 7046 :   if (type && *type && (!(soap->mode & SOAP_XML_SEC) || soap->part == SOAP_IN_BODY))

	test	ebx, ebx
	je	SHORT $LN17@soap_eleme@3
	cmp	BYTE PTR [ebx], 0
	je	SHORT $LN17@soap_eleme@3
	test	DWORD PTR [esi+8], 524288		; 00080000H
	je	SHORT $LN20@soap_eleme@3
	cmp	WORD PTR [esi+87304], 6
	jne	SHORT $LN17@soap_eleme@3
$LN20@soap_eleme@3:

; 7047 :   { if (soap_attribute(soap, "xsi:type", type))

	push	ebx
	mov	eax, OFFSET ??_C@_08JNIDGPLJ@xsi?3type?$AA@
	call	_soap_attribute
	add	esp, 4
	test	eax, eax

; 7048 :       return soap->error;

	jne	$LN33@soap_eleme@3

; 7049 : #ifndef WITH_LEAN
; 7050 :     if (soap->mode & SOAP_XML_CANONICAL)

	test	DWORD PTR [esi+8], 16384		; 00004000H
	je	SHORT $LN17@soap_eleme@3

; 7051 :     { const char *t = strchr(type, ':');

	push	58					; 0000003aH
	push	ebx
	call	_strchr
	add	esp, 8

; 7052 :       if (t)

	test	eax, eax
	je	SHORT $LN17@soap_eleme@3

; 7053 :         soap_utilize_ns(soap, type, t - type);

	sub	eax, ebx
	push	ebx
	call	_soap_utilize_ns
	add	esp, 4
$LN17@soap_eleme@3:

; 7054 :     }
; 7055 : #endif
; 7056 :   }
; 7057 :   if (soap->null && soap->position > 0)

	cmp	WORD PTR [esi+87300], 0
	je	$LN12@soap_eleme@3
	cmp	WORD PTR [esi+87222], 0
	jle	$LN12@soap_eleme@3

; 7058 :   { register int i;
; 7059 :     sprintf(soap->tmpbuf, "[%d", soap->positions[0]);

	mov	eax, DWORD PTR [esi+87224]
	push	eax
	lea	ebp, DWORD PTR [esi+79028]
	push	OFFSET ??_C@_03PNKAICOI@?$FL?$CFd?$AA@
	push	ebp
	call	_sprintf

; 7060 :     for (i = 1; i < soap->position; i++)

	mov	edi, 1
	mov	ecx, edi
	add	esp, 12					; 0000000cH
	cmp	cx, WORD PTR [esi+87222]
	jge	SHORT $LN13@soap_eleme@3

; 7058 :   { register int i;
; 7059 :     sprintf(soap->tmpbuf, "[%d", soap->positions[0]);

	lea	ebx, DWORD PTR [esi+87228]
$LL15@soap_eleme@3:

; 7061 :       sprintf(soap->tmpbuf + strlen(soap->tmpbuf), ",%d", soap->positions[i]);

	mov	eax, ebp
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL67@soap_eleme@3:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL67@soap_eleme@3
	sub	eax, edx
	mov	edx, DWORD PTR [ebx]
	push	edx
	add	eax, ebp
	push	OFFSET ??_C@_03LEIBKMN@?0?$CFd?$AA@
	push	eax
	call	_sprintf
	movsx	ecx, WORD PTR [esi+87222]
	inc	edi
	add	esp, 12					; 0000000cH
	add	ebx, 4
	cmp	edi, ecx
	jl	SHORT $LL15@soap_eleme@3
$LN13@soap_eleme@3:

; 7062 :     strcat(soap->tmpbuf, "]");

	mov	edi, ebp
	dec	edi
	npad	2
$LL68@soap_eleme@3:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL68@soap_eleme@3
	mov	dx, WORD PTR ??_C@_01LBDDMOBJ@?$FN?$AA@

; 7063 :     if (soap_attribute(soap, "SOAP-ENC:position", soap->tmpbuf))

	push	ebp
	mov	eax, OFFSET ??_C@_0BC@LJIIOGEO@SOAP?9ENC?3position?$AA@
	mov	WORD PTR [edi], dx
	call	_soap_attribute
	add	esp, 4
	test	eax, eax

; 7064 :       return soap->error;

	jne	$LN33@soap_eleme@3
$LN12@soap_eleme@3:

; 7065 :   }
; 7066 :   if (soap->mustUnderstand)

	cmp	WORD PTR [esi+87298], 0
	je	SHORT $LN11@soap_eleme@3

; 7067 :   { if (soap->actor && *soap->actor)

	mov	ecx, DWORD PTR [esi+44]
	mov	edi, 2
	test	ecx, ecx
	je	SHORT $LN9@soap_eleme@3
	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN9@soap_eleme@3

; 7068 :     { if (soap_attribute(soap, soap->version == 2 ? "SOAP-ENV:role" : "SOAP-ENV:actor", soap->actor))

	mov	eax, OFFSET ??_C@_0O@HCOOBFLG@SOAP?9ENV?3role?$AA@
	cmp	WORD PTR [esi+6], di
	je	SHORT $LN49@soap_eleme@3
	mov	eax, OFFSET ??_C@_0P@OHPBIEEK@SOAP?9ENV?3actor?$AA@
$LN49@soap_eleme@3:
	push	ecx
	call	_soap_attribute
	add	esp, 4
	test	eax, eax

; 7069 :         return soap->error;

	jne	$LN33@soap_eleme@3
$LN9@soap_eleme@3:

; 7070 :     }
; 7071 :     if (soap_attribute(soap, "SOAP-ENV:mustUnderstand", soap->version == 2 ? "true" : "1"))

	mov	eax, OFFSET ??_C@_04LOAJBDKD@true?$AA@
	cmp	WORD PTR [esi+6], di
	je	SHORT $LN51@soap_eleme@3
	mov	eax, OFFSET ??_C@_01HIHLOKLC@1?$AA@
$LN51@soap_eleme@3:
	push	eax
	mov	eax, OFFSET ??_C@_0BI@ENKFHJBH@SOAP?9ENV?3mustUnderstand?$AA@
	call	_soap_attribute
	add	esp, 4
	test	eax, eax

; 7072 :       return soap->error;

	jne	$LN33@soap_eleme@3

; 7073 :     soap->mustUnderstand = 0;

	mov	WORD PTR [esi+87298], ax
$LN11@soap_eleme@3:

; 7074 :   }
; 7075 :   if (soap->encoding)

	cmp	WORD PTR [esi+87296], 0
	je	SHORT $LN7@soap_eleme@3

; 7076 :   { if (soap->encodingStyle && soap->local_namespaces)

	mov	ecx, DWORD PTR [esi+40]
	test	ecx, ecx
	je	SHORT $LN2@soap_eleme@3
	mov	eax, DWORD PTR [esi+84]
	test	eax, eax
	je	SHORT $LN2@soap_eleme@3

; 7077 :     { if (!*soap->encodingStyle)

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN3@soap_eleme@3

; 7078 :       { if (soap->local_namespaces[1].out)

	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx

; 7079 :           soap->encodingStyle = soap->local_namespaces[1].out;
; 7080 :         else

	jne	SHORT $LN71@soap_eleme@3

; 7081 :           soap->encodingStyle = soap->local_namespaces[1].ns;

	mov	ecx, DWORD PTR [eax+20]
$LN71@soap_eleme@3:
	mov	DWORD PTR [esi+40], ecx
$LN3@soap_eleme@3:

; 7082 :       }
; 7083 :       if (soap_attribute(soap, "SOAP-ENV:encodingStyle", soap->encodingStyle))

	mov	edx, DWORD PTR [esi+40]
	push	edx
	mov	eax, OFFSET ??_C@_0BH@DOAGFCPF@SOAP?9ENV?3encodingStyle?$AA@
	call	_soap_attribute
	add	esp, 4
	test	eax, eax

; 7084 :         return soap->error;

	jne	$LN33@soap_eleme@3
$LN2@soap_eleme@3:

; 7085 :     }
; 7086 :     soap->encoding = 0;

	xor	eax, eax
	mov	WORD PTR [esi+87296], ax
$LN7@soap_eleme@3:

; 7087 :   }
; 7088 :   soap->null = 0;

	xor	ecx, ecx

; 7089 :   soap->position = 0;

	xor	edx, edx

; 7090 :   if (soap->part == SOAP_BEGIN_SECURITY && (soap->mode & SOAP_XML_CANONICAL))

	cmp	WORD PTR [esi+87304], 10		; 0000000aH
	mov	WORD PTR [esi+87300], cx
	mov	WORD PTR [esi+87222], dx
	jne	SHORT $LN1@soap_eleme@3
	test	DWORD PTR [esi+8], 16384		; 00004000H
	je	SHORT $LN1@soap_eleme@3

; 7091 :     soap->part = SOAP_IN_SECURITY;

	mov	eax, 11					; 0000000bH
	mov	WORD PTR [esi+87304], ax
$LN1@soap_eleme@3:
	pop	edi
	pop	esi
	pop	ebp

; 7092 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 7093 : }

	ret	0
_soap_element ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tmp$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_soap_char PROC
; _soap$ = ecx

; 1435 : { char tmp[8];

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+12], eax
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 1436 :   register int i;
; 1437 :   register soap_wchar c;
; 1438 :   register char *s = tmp;

	lea	edi, DWORD PTR _tmp$[esp+24]

; 1439 :   for (i = 0; i < 7; i++)

	xor	ebx, ebx
	npad	7
$LL13@soap_char:

; 1440 :   { c = soap_get1(soap);

	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN16@soap_char
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN22@soap_char
$LN16@soap_char:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx

; 1441 :     if (c == ';' || (int)c == EOF)

	cmp	eax, 59					; 0000003bH
	je	SHORT $LN22@soap_char
	cmp	eax, -1
	je	SHORT $LN22@soap_char

; 1442 :       break;
; 1443 :     *s++ = (char)c;

	mov	BYTE PTR [edi], al
	inc	ebx
	inc	edi
	cmp	ebx, 7
	jl	SHORT $LL13@soap_char
$LN22@soap_char:

; 1444 :   }
; 1445 :   *s = '\0';

	mov	BYTE PTR [edi], 0

; 1446 :   if (*tmp == '#')

	cmp	BYTE PTR _tmp$[esp+24], 35		; 00000023H
	jne	SHORT $LN8@soap_char

; 1447 :   { if (tmp[1] == 'x' || tmp[1] == 'X')

	mov	al, BYTE PTR _tmp$[esp+25]
	cmp	al, 120					; 00000078H
	je	SHORT $LN6@soap_char
	cmp	al, 88					; 00000058H
	je	SHORT $LN6@soap_char

; 1449 :     return atol(tmp + 1);

	lea	ecx, DWORD PTR _tmp$[esp+25]
	push	ecx
	call	_atol

; 1461 : #ifndef WITH_LEAN
; 1462 :   return (soap_wchar)soap_code_int(html_entity_codes, tmp, SOAP_UNKNOWN_CHAR);

	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1463 : #else
; 1464 :   return SOAP_UNKNOWN_CHAR; /* use this to represent unknown code */
; 1465 : #endif
; 1466 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+12]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 12					; 0000000cH
	ret	0
$LN6@soap_char:

; 1448 :       return soap_strtol(tmp + 2, NULL, 16);

	push	16					; 00000010H
	lea	edx, DWORD PTR _tmp$[esp+30]
	push	0
	push	edx
	call	_strtol
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 1463 : #else
; 1464 :   return SOAP_UNKNOWN_CHAR; /* use this to represent unknown code */
; 1465 : #endif
; 1466 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+12]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 12					; 0000000cH
	ret	0
$LN8@soap_char:

; 1450 :   }
; 1451 :   if (!strcmp(tmp, "lt"))

	mov	edx, OFFSET ??_C@_02KCAKIFL@lt?$AA@
	lea	ecx, DWORD PTR _tmp$[esp+24]
$LL23@soap_char:
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edx]
	jne	SHORT $LN24@soap_char
	test	al, al
	je	SHORT $LN25@soap_char
	mov	al, BYTE PTR [ecx+1]
	cmp	al, BYTE PTR [edx+1]
	jne	SHORT $LN24@soap_char
	add	ecx, 2
	add	edx, 2
	test	al, al
	jne	SHORT $LL23@soap_char
$LN25@soap_char:
	xor	eax, eax
	jmp	SHORT $LN26@soap_char
$LN24@soap_char:
	sbb	eax, eax
	sbb	eax, -1
$LN26@soap_char:
	test	eax, eax
	jne	SHORT $LN5@soap_char
	pop	edi
	pop	esi

; 1452 :     return '<';

	mov	eax, 60					; 0000003cH
	pop	ebx

; 1463 : #else
; 1464 :   return SOAP_UNKNOWN_CHAR; /* use this to represent unknown code */
; 1465 : #endif
; 1466 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+12]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 12					; 0000000cH
	ret	0
$LN5@soap_char:

; 1453 :   if (!strcmp(tmp, "gt"))

	mov	ecx, OFFSET ??_C@_02GHFEHLK@gt?$AA@
	lea	eax, DWORD PTR _tmp$[esp+24]
	npad	7
$LL27@soap_char:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN28@soap_char
	test	dl, dl
	je	SHORT $LN29@soap_char
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN28@soap_char
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL27@soap_char
$LN29@soap_char:
	xor	eax, eax
	jmp	SHORT $LN30@soap_char
$LN28@soap_char:
	sbb	eax, eax
	sbb	eax, -1
$LN30@soap_char:
	test	eax, eax
	jne	SHORT $LN4@soap_char
	pop	edi
	pop	esi

; 1454 :     return '>';

	mov	eax, 62					; 0000003eH
	pop	ebx

; 1463 : #else
; 1464 :   return SOAP_UNKNOWN_CHAR; /* use this to represent unknown code */
; 1465 : #endif
; 1466 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+12]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 12					; 0000000cH
	ret	0
$LN4@soap_char:

; 1455 :   if (!strcmp(tmp, "amp"))

	mov	ecx, OFFSET ??_C@_03DCBBJBAA@amp?$AA@
	lea	eax, DWORD PTR _tmp$[esp+24]
	npad	7
$LL31@soap_char:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN32@soap_char
	test	dl, dl
	je	SHORT $LN33@soap_char
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN32@soap_char
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL31@soap_char
$LN33@soap_char:
	xor	eax, eax
	jmp	SHORT $LN34@soap_char
$LN32@soap_char:
	sbb	eax, eax
	sbb	eax, -1
$LN34@soap_char:
	test	eax, eax
	jne	SHORT $LN3@soap_char
	pop	edi
	pop	esi

; 1456 :     return '&';

	mov	eax, 38					; 00000026H
	pop	ebx

; 1463 : #else
; 1464 :   return SOAP_UNKNOWN_CHAR; /* use this to represent unknown code */
; 1465 : #endif
; 1466 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+12]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 12					; 0000000cH
	ret	0
$LN3@soap_char:

; 1457 :   if (!strcmp(tmp, "quot"))

	mov	ecx, OFFSET ??_C@_04KJFGKBNM@quot?$AA@
	lea	eax, DWORD PTR _tmp$[esp+24]
	npad	7
$LL35@soap_char:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN36@soap_char
	test	dl, dl
	je	SHORT $LN37@soap_char
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN36@soap_char
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL35@soap_char
$LN37@soap_char:
	xor	eax, eax
	jmp	SHORT $LN38@soap_char
$LN36@soap_char:
	sbb	eax, eax
	sbb	eax, -1
$LN38@soap_char:
	test	eax, eax
	jne	SHORT $LN2@soap_char
	pop	edi
	pop	esi

; 1458 :     return '"';

	mov	eax, 34					; 00000022H
	pop	ebx

; 1463 : #else
; 1464 :   return SOAP_UNKNOWN_CHAR; /* use this to represent unknown code */
; 1465 : #endif
; 1466 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+12]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 12					; 0000000cH
	ret	0
$LN2@soap_char:

; 1459 :   if (!strcmp(tmp, "apos"))

	mov	ecx, OFFSET ??_C@_04LBCJFAKL@apos?$AA@
	lea	eax, DWORD PTR _tmp$[esp+24]
	npad	7
$LL39@soap_char:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN40@soap_char
	test	dl, dl
	je	SHORT $LN41@soap_char
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN40@soap_char
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL39@soap_char
$LN41@soap_char:
	xor	eax, eax
	jmp	SHORT $LN42@soap_char
$LN40@soap_char:
	sbb	eax, eax
	sbb	eax, -1
$LN42@soap_char:
	test	eax, eax
	jne	SHORT $LN1@soap_char
	pop	edi
	pop	esi

; 1460 :     return '\'';

	mov	eax, 39					; 00000027H
	pop	ebx

; 1463 : #else
; 1464 :   return SOAP_UNKNOWN_CHAR; /* use this to represent unknown code */
; 1465 : #endif
; 1466 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+12]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 12					; 0000000cH
	ret	0
$LN1@soap_char:

; 1461 : #ifndef WITH_LEAN
; 1462 :   return (soap_wchar)soap_code_int(html_entity_codes, tmp, SOAP_UNKNOWN_CHAR);

	push	127					; 0000007fH
	lea	edi, DWORD PTR _tmp$[esp+28]
	mov	eax, OFFSET _html_entity_codes
	call	_soap_code_int

; 1463 : #else
; 1464 :   return SOAP_UNKNOWN_CHAR; /* use this to represent unknown code */
; 1465 : #endif
; 1466 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+28]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 12					; 0000000cH
	ret	0
_soap_char ENDP
_TEXT	ENDS
PUBLIC	_soap_getchar
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_getchar PROC
; _soap$ = eax

; 1318 : { register soap_wchar c;

	push	esi
	mov	esi, eax

; 1319 :   c = soap->ahead;

	mov	eax, DWORD PTR [esi+12436]

; 1320 :   if (c)

	test	eax, eax
	je	SHORT $LN2@soap_getch@2

; 1321 :   { if (c != EOF)

	cmp	eax, -1
	je	SHORT $LN3@soap_getch@2

; 1322 :       soap->ahead = 0;

	mov	DWORD PTR [esi+12436], 0
	pop	esi

; 1326 : }

	ret	0
$LN2@soap_getch@2:

; 1323 :     return c;
; 1324 :   }
; 1325 :   return soap_get1(soap);

	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN5@soap_getch@2
	call	_soap_recv
	test	eax, eax
	je	SHORT $LN5@soap_getch@2
	or	eax, -1
	pop	esi

; 1326 : }

	ret	0
$LN5@soap_getch@2:

; 1323 :     return c;
; 1324 :   }
; 1325 :   return soap_get1(soap);

	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx
$LN3@soap_getch@2:
	pop	esi

; 1326 : }

	ret	0
_soap_getchar ENDP
PUBLIC	_soap_body_begin_out
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_body_begin_out PROC
; _soap$ = eax

; 13409: { soap->part = SOAP_IN_BODY;

	push	edi
	mov	edi, eax

; 13410:   if (soap->version == 1)

	cmp	WORD PTR [edi+6], 1
	mov	eax, 6
	mov	WORD PTR [edi+87304], ax
	jne	SHORT $LN3@soap_body_@2

; 13411:     soap->encoding = 1;

	mov	ecx, 1
	mov	WORD PTR [edi+87296], cx
$LN3@soap_body_@2:

; 13412: #ifndef WITH_LEAN
; 13413:   if ((soap->mode & SOAP_XML_SEC) && soap_set_attr(soap, "wsu:Id", "Body"))

	test	DWORD PTR [edi+8], 524288		; 00080000H
	je	SHORT $LN2@soap_body_@2
	push	OFFSET ??_C@_04MJIIEFNN@Body?$AA@
	push	OFFSET ??_C@_06BGJENONN@wsu?3Id?$AA@
	push	edi
	call	_soap_set_attr
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_body_@2
$LN6@soap_body_@2:

; 13414:     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi

; 13419: }

	ret	0
$LN2@soap_body_@2:

; 13415: #endif
; 13416:   if (soap_element(soap, "SOAP-ENV:Body", 0, NULL))

	push	0
	push	0
	push	OFFSET ??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax

; 13417:     return soap->error;

	jne	SHORT $LN6@soap_body_@2

; 13418:   return soap_element_start_end_out(soap, NULL);

	push	eax
	call	_soap_element_start_end_out
	add	esp, 4
	pop	edi

; 13419: }

	ret	0
_soap_body_begin_out ENDP
_TEXT	ENDS
PUBLIC	_soap_putmime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_content$ = -8						; size = 4
_size$83339 = -4					; size = 4
_soap_putmime PROC
; _soap$ = esi

; 11713: { struct soap_multipart *content;

	sub	esp, 8

; 11714:   if (!(soap->mode & SOAP_ENC_MIME) || !soap->mime.boundary)

	test	DWORD PTR [esi+8], 256			; 00000100H
	je	$LN28@soap_putmi@2
	cmp	DWORD PTR [esi+90524], 0
	je	$LN28@soap_putmi@2
	push	ebx
	push	ebp
	push	edi

; 11716:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Sending MIME attachments\n"));
; 11717:   for (content = soap->mime.first; content; content = content->next)

	mov	edi, DWORD PTR [esi+90536]
	mov	DWORD PTR _content$[esp+20], edi
	test	edi, edi
	je	$LN25@soap_putmi@2
	jmp	SHORT $LN27@soap_putmi@2
$LL61@soap_putmi@2:
	mov	edi, DWORD PTR _content$[esp+20]
$LN27@soap_putmi@2:

; 11718:   { void *handle;
; 11719:     if (soap->fmimereadopen && ((handle = soap->fmimereadopen(soap, (void*)content->ptr, content->id, content->type, content->description)) || soap->error))

	mov	eax, DWORD PTR [esi+12380]
	test	eax, eax
	je	$LN24@soap_putmi@2
	mov	ecx, DWORD PTR [edi+32]
	mov	edx, DWORD PTR [edi+16]
	push	ecx
	mov	ecx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR [edi+4]
	push	ecx
	push	edx
	push	esi
	call	eax
	mov	ebp, eax
	add	esp, 20					; 00000014H
	test	ebp, ebp
	jne	SHORT $LN23@soap_putmi@2
	cmp	DWORD PTR [esi+90460], eax
	je	$LN24@soap_putmi@2
$LN23@soap_putmi@2:

; 11720:     { size_t size = content->size;

	mov	ebx, DWORD PTR [edi+8]
	mov	DWORD PTR _size$83339[esp+20], ebx

; 11721:       if (!handle)

	test	ebp, ebp
	je	$LN32@soap_putmi@2

; 11722:       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fmimereadopen failed\n"));
; 11723:         return soap->error;
; 11724:       }
; 11725:       if (soap_putmimehdr(soap, content))

	push	edi
	mov	eax, esi
	call	_soap_putmimehdr
	add	esp, 4
	test	eax, eax
	jne	$LN32@soap_putmi@2

; 11726:         return soap->error;
; 11727:       if (!size)

	test	ebx, ebx
	jne	SHORT $LN59@soap_putmi@2

; 11728:       { if ((soap->mode & SOAP_ENC_XML) || (soap->mode & SOAP_IO) == SOAP_IO_CHUNK || (soap->mode & SOAP_IO) == SOAP_IO_STORE)

	mov	eax, DWORD PTR [esi+8]
	test	al, 64					; 00000040H
	jne	SHORT $LN58@soap_putmi@2
	and	eax, 3
	cmp	eax, 3
	je	SHORT $LN58@soap_putmi@2
	cmp	eax, 2
	jne	$LN9@soap_putmi@2
$LN58@soap_putmi@2:
	lea	ebx, DWORD PTR [esi+79028]
$LL17@soap_putmi@2:

; 11729:         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Chunked streaming MIME\n"));
; 11730:           do
; 11731:           { size = soap->fmimeread(soap, handle, soap->tmpbuf, sizeof(soap->tmpbuf));

	mov	eax, DWORD PTR [esi+12396]
	push	1024					; 00000400H
	push	ebx
	push	ebp
	push	esi
	call	eax
	mov	edi, eax

; 11732:             DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fmimeread returned %lu bytes\n", (unsigned long)size));
; 11733:             if (soap_send_raw(soap, soap->tmpbuf, size))

	push	edi
	push	ebx
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN62@soap_putmi@2

; 11734:               break;
; 11735:           } while (size);

	test	edi, edi
	jne	SHORT $LL17@soap_putmi@2

; 11736:         }
; 11737:         else
; 11738:         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Error: cannot chunk streaming MIME (no HTTP chunking)\n"));
; 11739:         }
; 11740:       }
; 11741:       else

	jmp	SHORT $LN62@soap_putmi@2
$LN59@soap_putmi@2:
	lea	ebx, DWORD PTR [esi+79028]
$LL11@soap_putmi@2:

; 11742:       { do
; 11743:         { size_t bufsize;
; 11744:           if (size < sizeof(soap->tmpbuf))

	mov	eax, DWORD PTR _size$83339[esp+20]
	cmp	eax, 1024				; 00000400H

; 11745:             bufsize = size;
; 11746:           else

	jb	SHORT $LN7@soap_putmi@2

; 11747:             bufsize = sizeof(soap->tmpbuf);

	mov	eax, 1024				; 00000400H
$LN7@soap_putmi@2:

; 11748:           if (!(bufsize = soap->fmimeread(soap, handle, soap->tmpbuf, bufsize)))

	mov	ecx, DWORD PTR [esi+12396]
	push	eax
	push	ebx
	push	ebp
	push	esi
	call	ecx
	mov	edi, eax
	add	esp, 16					; 00000010H
	test	edi, edi
	je	SHORT $LN49@soap_putmi@2

; 11751:             break;
; 11752:           }
; 11753:           if (soap_send_raw(soap, soap->tmpbuf, bufsize))

	push	edi
	push	ebx
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN62@soap_putmi@2

; 11754:             break;
; 11755:           size -= bufsize;

	sub	DWORD PTR _size$83339[esp+20], edi

; 11756:         } while (size);

	jne	SHORT $LL11@soap_putmi@2
	jmp	SHORT $LN62@soap_putmi@2
$LN49@soap_putmi@2:

; 11749:           { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "fmimeread failed: insufficient data (%lu bytes remaining from %lu bytes)\n", (unsigned long)size, (unsigned long)content->size));
; 11750:             soap->error = SOAP_EOF;

	mov	DWORD PTR [esi+90460], -1
$LN62@soap_putmi@2:

; 11736:         }
; 11737:         else
; 11738:         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Error: cannot chunk streaming MIME (no HTTP chunking)\n"));
; 11739:         }
; 11740:       }
; 11741:       else

	mov	edi, DWORD PTR _content$[esp+20]
$LN9@soap_putmi@2:

; 11757:       }
; 11758:       if (soap->fmimereadclose)

	mov	eax, DWORD PTR [esi+12388]
	test	eax, eax
	je	SHORT $LN26@soap_putmi@2

; 11759:         soap->fmimereadclose(soap, handle);

	push	ebp
	push	esi
	call	eax
	add	esp, 8

; 11760:     }
; 11761:     else

	jmp	SHORT $LN26@soap_putmi@2
$LN24@soap_putmi@2:

; 11762:     { if (soap_putmimehdr(soap, content)
; 11763:        || soap_send_raw(soap, content->ptr, content->size))

	push	edi
	mov	eax, esi
	call	_soap_putmimehdr
	add	esp, 4
	test	eax, eax
	jne	$LN32@soap_putmi@2
	mov	edx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi+4]
	push	edx
	push	eax
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@soap_putmi@2
$LN26@soap_putmi@2:

; 11716:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Sending MIME attachments\n"));
; 11717:   for (content = soap->mime.first; content; content = content->next)

	mov	edi, DWORD PTR [edi]
	mov	DWORD PTR _content$[esp+20], edi
	test	edi, edi
	jne	$LL61@soap_putmi@2
$LN25@soap_putmi@2:

; 11764:         return soap->error;
; 11765:     }
; 11766:   }
; 11767:   return soap_send3(soap, "\r\n--", soap->mime.boundary, "--");

	mov	edi, DWORD PTR [esi+90524]
	push	4
	push	OFFSET ??_C@_04LOEPKDGL@?$AN?6?9?9?$AA@
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@soap_putmi@2
	test	edi, edi
	je	SHORT $LN57@soap_putmi@2
	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL60@soap_putmi@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL60@soap_putmi@2
	sub	eax, edx
	push	eax
	push	edi
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@soap_putmi@2
$LN57@soap_putmi@2:
	push	2
	push	OFFSET ??_C@_02BAABKJLB@?9?9?$AA@
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	pop	edi
	pop	ebp
	pop	ebx

; 11768: }

	add	esp, 8
	ret	0

; 11764:         return soap->error;
; 11765:     }
; 11766:   }
; 11767:   return soap_send3(soap, "\r\n--", soap->mime.boundary, "--");

$LN32@soap_putmi@2:
	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	ebp
	pop	ebx

; 11768: }

	add	esp, 8
	ret	0
$LN28@soap_putmi@2:

; 11715:     return SOAP_OK;

	xor	eax, eax

; 11768: }

	add	esp, 8
	ret	0
_soap_putmime ENDP
_TEXT	ENDS
PUBLIC	_soap_getline
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_s$ = 8							; size = 4
_len$ = 12						; size = 4
_soap_getline PROC
; _soap$ = eax

; 10946: { int i = len;

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _s$[esp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _len$[esp+12]
	mov	esi, eax

; 10947:   soap_wchar c = 0;

	xor	ebx, ebx
	xor	eax, eax
$LL14@soap_getli:

; 10948:   for (;;)
; 10949:   { while (--i > 0)

	dec	edi
	cmp	edi, ebx
	jle	SHORT $LN47@soap_getli
	npad	9
$LL12@soap_getli:

; 10950:     { c = soap_getchar(soap);

	mov	eax, DWORD PTR [esi+12436]
	cmp	eax, ebx
	je	SHORT $LN20@soap_getli
	cmp	eax, -1
	je	SHORT $LN24@soap_getli
	mov	DWORD PTR [esi+12436], ebx
	jmp	SHORT $LN24@soap_getli
$LN20@soap_getli:
	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN23@soap_getli
	call	_soap_recv
	test	eax, eax
	jne	$LN49@soap_getli
$LN23@soap_getli:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx
$LN24@soap_getli:

; 10951:       if (c == '\r' || c == '\n')

	cmp	eax, 13					; 0000000dH
	je	SHORT $LN47@soap_getli
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN40@soap_getli

; 10952:         break;
; 10953:       if ((int)c == EOF)

	cmp	eax, -1
	je	$LN49@soap_getli

; 10954:         return soap->error = SOAP_EOF;
; 10955:       *s++ = (char)c;

	mov	BYTE PTR [ebp], al
	dec	edi
	inc	ebp
	cmp	edi, ebx
	jg	SHORT $LL12@soap_getli
$LN47@soap_getli:

; 10956:     }
; 10957:     if (c != '\n')

	cmp	eax, 10					; 0000000aH
	je	SHORT $LN40@soap_getli

; 10958:       c = soap_getchar(soap); /* got \r or something else, now get \n */

	mov	eax, DWORD PTR [esi+12436]
	cmp	eax, ebx
	je	SHORT $LN26@soap_getli
	cmp	eax, -1
	je	SHORT $LN30@soap_getli
	mov	DWORD PTR [esi+12436], ebx
	jmp	SHORT $LN30@soap_getli
$LN26@soap_getli:
	mov	ecx, DWORD PTR [esi+12428]
	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN29@soap_getli
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN49@soap_getli
$LN29@soap_getli:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx
$LN30@soap_getli:

; 10959:     if (c == '\n')

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN6@soap_getli
$LN40@soap_getli:

; 10960:     { *s = '\0';
; 10961:       if (i+1 == len) /* empty line: end of HTTP/MIME header */

	lea	edx, DWORD PTR [edi+1]
	mov	BYTE PTR [ebp], bl
	cmp	edx, DWORD PTR _len$[esp+12]
	je	SHORT $LN36@soap_getli

; 10962:         break;
; 10963:       c = soap_get0(soap);

	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN17@soap_getli
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN36@soap_getli
$LN17@soap_getli:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [esi+ecx+12468]

; 10964:       if (c != ' ' && c != '\t') /* HTTP line continuation? */

	cmp	eax, 32					; 00000020H
	je	$LL14@soap_getli
	cmp	eax, 9
	je	$LL14@soap_getli
$LN36@soap_getli:

; 10969:   }
; 10970:   if (i < 0)

	cmp	edi, ebx
	jge	SHORT $LN1@soap_getli
	pop	edi

; 10971:     return soap->error = SOAP_HDR;

	mov	eax, 22					; 00000016H
	mov	DWORD PTR [esi+90460], eax
	pop	esi
	pop	ebp
	pop	ebx

; 10973: }

	ret	0
$LN6@soap_getli:

; 10965:         break;
; 10966:     }
; 10967:     else if ((int)c == EOF)

	cmp	eax, -1
	jne	$LL14@soap_getli
$LN49@soap_getli:
	pop	edi

; 10968:       return soap->error = SOAP_EOF;

	or	eax, -1
	mov	DWORD PTR [esi+90460], eax
	pop	esi
	pop	ebp
	pop	ebx

; 10973: }

	ret	0
$LN1@soap_getli:
	pop	edi
	pop	esi
	pop	ebp

; 10972:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 10973: }

	ret	0
_soap_getline ENDP
_TEXT	ENDS
PUBLIC	_soap_element_result
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_element_result PROC
; _soap$ = eax

; 7493 : { if (soap->version == 2 && soap->encodingStyle)

	push	esi
	push	edi
	mov	edi, eax
	cmp	WORD PTR [edi+6], 2
	jne	SHORT $LN2@soap_eleme@4
	cmp	DWORD PTR [edi+40], 0
	je	SHORT $LN2@soap_eleme@4

; 7494 :   { if (soap_element(soap, "SOAP-RPC:result", 0, NULL)
; 7495 :      || soap_attribute(soap, "xmlns:SOAP-RPC", soap_rpc)
; 7496 :      || soap_element_start_end_out(soap, NULL)
; 7497 :      || soap_string_out(soap, tag, 0)
; 7498 :      || soap_element_end_out(soap, "SOAP-RPC:result"))

	push	0
	push	0
	push	OFFSET ??_C@_0BA@JOBDACAK@SOAP?9RPC?3result?$AA@
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@soap_eleme@4
	push	OFFSET _soap_rpc
	mov	eax, OFFSET ??_C@_0P@CNMICKND@xmlns?3SOAP?9RPC?$AA@
	mov	esi, edi
	call	_soap_attribute
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_eleme@4
	push	eax
	call	_soap_element_start_end_out
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_eleme@4
	push	eax
	mov	eax, OFFSET ??_C@_0L@FEKNHBLL@ns2?3result?$AA@
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_eleme@4
	mov	esi, OFFSET ??_C@_0BA@JOBDACAK@SOAP?9RPC?3result?$AA@
	mov	eax, edi
	call	_soap_element_end_out
	test	eax, eax
	je	SHORT $LN2@soap_eleme@4
$LN1@soap_eleme@4:

; 7499 :       return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi

; 7502 : }

	ret	0
$LN2@soap_eleme@4:
	pop	edi

; 7500 :   }
; 7501 :   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 7502 : }

	ret	0
_soap_element_result ENDP
_TEXT	ENDS
PUBLIC	_soap_element_null
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_type$ = 12						; size = 4
_soap_element_null PROC
; _tag$ = ecx
; _id$ = eax

; 7433 : { struct soap_attribute *tp;

	push	ebx
	push	esi
	mov	esi, DWORD PTR _soap$[esp+4]

; 7434 :   for (tp = soap->attributes; tp; tp = tp->next)

	mov	ebx, DWORD PTR [esi+87292]
	push	edi
	mov	edi, ecx
	test	ebx, ebx
	je	SHORT $LN15@soap_eleme@5
$LL9@soap_eleme@5:

; 7435 :     if (tp->visible)

	cmp	WORD PTR [ebx+16], 0
	jne	SHORT $LN4@soap_eleme@5
	mov	ebx, DWORD PTR [ebx]
	test	ebx, ebx
	jne	SHORT $LL9@soap_eleme@5
$LN15@soap_eleme@5:

; 7436 :       break;
; 7437 :   if (tp || (soap->version == 2 && soap->position > 0) || id > 0 || (soap->mode & SOAP_XML_NIL))

	cmp	WORD PTR [esi+6], 2
	jne	SHORT $LN3@soap_eleme@5
	cmp	WORD PTR [esi+87222], 0
	jg	SHORT $LN4@soap_eleme@5
$LN3@soap_eleme@5:
	test	eax, eax
	jg	SHORT $LN4@soap_eleme@5
	test	DWORD PTR [esi+8], 131072		; 00020000H
	jne	SHORT $LN4@soap_eleme@5

; 7443 :   }
; 7444 :   soap->null = 1;

	mov	eax, 1

; 7445 :   soap->position = 0;

	xor	ecx, ecx

; 7446 :   soap->mustUnderstand = 0;

	xor	edx, edx
	pop	edi
	mov	WORD PTR [esi+87300], ax
	mov	WORD PTR [esi+87222], cx
	mov	WORD PTR [esi+87298], dx
	pop	esi

; 7447 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 7448 : }

	ret	0
$LN4@soap_eleme@5:

; 7438 :   { if (soap_element(soap, tag, id, type))

	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	edi
	mov	eax, esi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@soap_eleme@5
$LN16@soap_eleme@5:

; 7439 :       return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 7448 : }

	ret	0
$LN2@soap_eleme@5:

; 7440 :     if (!tp && soap_attribute(soap, "xsi:nil", "true"))

	test	ebx, ebx
	jne	SHORT $LN1@soap_eleme@5
	push	OFFSET ??_C@_04LOAJBDKD@true?$AA@
	mov	eax, OFFSET ??_C@_07KJDFMKIE@xsi?3nil?$AA@
	call	_soap_attribute
	add	esp, 4
	test	eax, eax

; 7441 :       return soap->error;

	jne	SHORT $LN16@soap_eleme@5
$LN1@soap_eleme@5:

; 7442 :     return soap_element_start_end_out(soap, tag);

	push	edi
	mov	edi, esi
	call	_soap_element_start_end_out
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 7448 : }

	ret	0
_soap_element_null ENDP
_TEXT	ENDS
PUBLIC	_soap_element_href
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_ref$ = 12						; size = 4
_soap_element_href PROC
; _soap$ = ecx
; _val$ = eax

; 7418 : { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Element '%s' reference %s='%s'\n", tag, ref, val));

	push	esi

; 7419 :   if (soap_element(soap, tag, id, NULL)
; 7420 :    || soap_attribute(soap, ref, val)
; 7421 :    || soap_element_start_end_out(soap, tag))

	push	eax
	mov	eax, DWORD PTR _ref$[esp+4]
	mov	esi, ecx
	call	_soap_attribute
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@soap_eleme@6
	mov	ecx, DWORD PTR _tag$[esp]
	push	edi
	push	ecx
	mov	edi, esi
	call	_soap_element_start_end_out
	add	esp, 4
	pop	edi
	test	eax, eax
	jne	SHORT $LN5@soap_eleme@6
	pop	esi

; 7423 :   return SOAP_OK;
; 7424 : }

	ret	0
$LN5@soap_eleme@6:

; 7422 :     return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	esi

; 7423 :   return SOAP_OK;
; 7424 : }

	ret	0
_soap_element_href ENDP
_TEXT	ENDS
PUBLIC	_soap_element_ref
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_soap_element_ref PROC
; _soap$ = ecx
; _href$ = eax

; 7401 : { register int n = 0;

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _tag$[esp+4]
	push	esi
	mov	esi, ecx
	xor	ebx, ebx

; 7402 :   const char *s = "href";
; 7403 :   if (soap->version == 2)

	cmp	WORD PTR [esi+6], 2
	push	edi
	mov	edi, OFFSET ??_C@_04CMBCJJJD@href?$AA@
	jne	SHORT $LN1@soap_eleme@7

; 7404 :   { s = "SOAP-ENC:ref";

	mov	edi, OFFSET ??_C@_0N@HAMJFIGF@SOAP?9ENC?3ref?$AA@

; 7405 :     n = 1;

	mov	ebx, 1
$LN1@soap_eleme@7:

; 7406 :   }
; 7407 :   sprintf(soap->href, "#_%d", href);

	push	eax
	lea	ecx, DWORD PTR [esi+82100]
	push	OFFSET ??_C@_04BDMFGIGK@?$CD_?$CFd?$AA@
	push	ecx
	call	_sprintf

; 7408 :   return soap_element_href(soap, tag, id, s, soap->href + n);

	push	0
	push	0
	push	ebp
	mov	eax, esi
	call	_soap_element
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN4@soap_eleme@7
	lea	edx, DWORD PTR [ebx+esi+82100]
	push	edx
	mov	eax, edi
	call	_soap_attribute
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@soap_eleme@7
	push	ebp
	mov	edi, esi
	call	_soap_element_start_end_out
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@soap_eleme@7
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7409 : }

	ret	0

; 7408 :   return soap_element_href(soap, tag, id, s, soap->href + n);

$LN4@soap_eleme@7:
	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7409 : }

	ret	0
_soap_element_ref ENDP
_TEXT	ENDS
PUBLIC	_soap_array_begin_out
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_s$80981 = -4						; size = 4
_soap$ = 8						; size = 4
_type$ = 12						; size = 4
_offset$ = 16						; size = 4
_soap_array_begin_out PROC
; _tag$ = ecx
; _id$ = eax

; 7227 : { if (soap_element(soap, tag, id, "SOAP-ENC:Array"))

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _type$[esp+4]
	push	esi
	mov	esi, DWORD PTR _soap$[esp+8]
	push	edi
	mov	edi, DWORD PTR _offset$[esp+12]
	push	OFFSET ??_C@_0P@EFIHKLBM@SOAP?9ENC?3Array?$AA@
	push	eax
	push	ecx
	mov	eax, esi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@soap_array@3

; 7228 :     return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 7255 : }

	pop	ecx
	ret	0
$LN10@soap_array@3:

; 7229 :   if (soap->version == 2)

	cmp	WORD PTR [esi+6], 2
	push	ebp
	jne	SHORT $LN9@soap_array@3

; 7230 :   { const char *s;
; 7231 :     s = soap_strrchr(type, '[');

	push	91					; 0000005bH
	push	ebx
	call	_strrchr

; 7232 :     if ((size_t)(s - type) < sizeof(soap->tmpbuf))

	mov	edi, eax
	sub	edi, ebx
	add	esp, 8
	mov	DWORD PTR _s$80981[esp+20], eax
	cmp	edi, 1024				; 00000400H
	jae	$LN13@soap_array@3

; 7233 :     { strncpy(soap->tmpbuf, type, s - type);

	push	edi
	lea	ebp, DWORD PTR [esi+79028]
	push	ebx
	push	ebp
	call	_strncpy
	add	esp, 12					; 0000000cH

; 7234 :       soap->tmpbuf[s - type] = '\0';

	mov	BYTE PTR [edi+esi+79028], 0

; 7235 :       if (type && *type && (soap_attribute(soap, "SOAP-ENC:itemType", soap->tmpbuf)))

	test	ebx, ebx
	je	SHORT $LN7@soap_array@3
	cmp	BYTE PTR [ebx], 0
	je	SHORT $LN7@soap_array@3
	push	ebp
	mov	eax, OFFSET ??_C@_0BC@GCPDJBOG@SOAP?9ENC?3itemType?$AA@
	call	_soap_attribute
	add	esp, 4
	test	eax, eax

; 7236 :         return soap->error;

	jne	SHORT $LN16@soap_array@3
$LN7@soap_array@3:

; 7237 :       if (s && (soap_attribute(soap, "SOAP-ENC:arraySize", s + 1)))

	mov	eax, DWORD PTR _s$80981[esp+20]
	test	eax, eax
	je	SHORT $LN13@soap_array@3
	inc	eax
	push	eax
	mov	eax, OFFSET ??_C@_0BD@IKLKJNBD@SOAP?9ENC?3arraySize?$AA@

; 7238 :         return soap->error;

	jmp	SHORT $LN17@soap_array@3
$LN9@soap_array@3:

; 7239 :     }
; 7240 :   }
; 7241 :   else
; 7242 :   { if (offset && (soap_attribute(soap, "SOAP-ENC:offset", offset)))

	test	edi, edi
	je	SHORT $LN4@soap_array@3
	push	edi
	mov	eax, OFFSET ??_C@_0BA@CCJOJBBI@SOAP?9ENC?3offset?$AA@
	call	_soap_attribute
	add	esp, 4
	test	eax, eax

; 7243 :       return soap->error;

	jne	SHORT $LN16@soap_array@3
$LN4@soap_array@3:

; 7244 :     if (type && *type && (soap_attribute(soap, "SOAP-ENC:arrayType", type)))

	test	ebx, ebx
	je	SHORT $LN14@soap_array@3
	cmp	BYTE PTR [ebx], 0
	je	SHORT $LN13@soap_array@3
	push	ebx
	mov	eax, OFFSET ??_C@_0BD@GFBEJDEK@SOAP?9ENC?3arrayType?$AA@
$LN17@soap_array@3:
	call	_soap_attribute
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@soap_array@3
$LN16@soap_array@3:

; 7245 :       return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 7255 : }

	pop	ecx
	ret	0
$LN13@soap_array@3:

; 7246 :   }
; 7247 : #ifndef WITH_LEAN
; 7248 :   if (type && *type && (soap->mode & SOAP_XML_CANONICAL))

	test	ebx, ebx
	je	SHORT $LN14@soap_array@3
	cmp	BYTE PTR [ebx], 0
	je	SHORT $LN14@soap_array@3
	test	DWORD PTR [esi+8], 16384		; 00004000H
	je	SHORT $LN14@soap_array@3

; 7249 :   { const char *s = strchr(type, ':');

	push	58					; 0000003aH
	push	ebx
	call	_strchr
	add	esp, 8

; 7250 :     if (s)

	test	eax, eax
	je	SHORT $LN14@soap_array@3

; 7251 :       soap_utilize_ns(soap, type, s - type);

	sub	eax, ebx
	push	ebx
	call	_soap_utilize_ns
	add	esp, 4
$LN14@soap_array@3:

; 7252 :   }
; 7253 : #endif
; 7254 :   return soap_element_start_end_out(soap, NULL);

	push	0
	mov	edi, esi
	call	_soap_element_start_end_out
	add	esp, 4
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 7255 : }

	pop	ecx
	ret	0
_soap_array_begin_out ENDP
_TEXT	ENDS
PUBLIC	_soap_element_begin_out
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_id$ = 12						; size = 4
_soap_element_begin_out PROC
; _tag$ = eax
; _type$ = ecx

; 7102 : { if (*tag == '-')

	cmp	BYTE PTR [eax], 45			; 0000002dH
	push	edi
	mov	edi, DWORD PTR _soap$[esp]
	jne	SHORT $LN2@soap_eleme@8

; 7103 :     return SOAP_OK;

	xor	eax, eax
	pop	edi

; 7107 : }

	ret	0
$LN2@soap_eleme@8:

; 7104 :   if (soap_element(soap, tag, id, type))

	mov	edx, DWORD PTR _id$[esp]
	push	ecx
	push	edx
	push	eax
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@soap_eleme@8

; 7105 :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi

; 7107 : }

	ret	0
$LN1@soap_eleme@8:

; 7106 :   return soap_element_start_end_out(soap, NULL);

	push	0
	call	_soap_element_start_end_out
	add	esp, 4
	pop	edi

; 7107 : }

	ret	0
_soap_element_begin_out ENDP
_TEXT	ENDS
PUBLIC	_soap_end_send
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_end_send PROC
; _soap$ = eax

; 5927 : {

	push	esi
	push	edi
	mov	esi, eax

; 5928 : #ifndef WITH_LEANER
; 5929 :   if (soap->dime.list)

	xor	edi, edi
	cmp	DWORD PTR [esi+90512], edi
	je	SHORT $LN19@soap_end_s

; 5930 :   { /* SOAP body referenced attachments must appear first */
; 5931 :     soap->dime.last->next = soap->dime.first;

	mov	eax, DWORD PTR [esi+90520]
	mov	ecx, DWORD PTR [esi+90516]
	mov	DWORD PTR [eax], ecx

; 5932 :     soap->dime.first = soap->dime.list->next;

	mov	eax, DWORD PTR [esi+90512]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [esi+90516], edx

; 5933 :     soap->dime.list->next = NULL;

	mov	DWORD PTR [eax], edi

; 5934 :     soap->dime.last = soap->dime.list;

	mov	eax, DWORD PTR [esi+90512]
	mov	DWORD PTR [esi+90520], eax
$LN19@soap_end_s:

; 5935 :   }
; 5936 :   if (soap_putdime(soap) || soap_putmime(soap))

	mov	eax, esi
	call	_soap_putdime
	test	eax, eax
	jne	$LN17@soap_end_s
	call	_soap_putmime
	test	eax, eax
	jne	$LN17@soap_end_s

; 5938 :   soap->mime.list = NULL;
; 5939 :   soap->mime.first = NULL;
; 5940 :   soap->mime.last = NULL;
; 5941 :   soap->dime.list = NULL;
; 5942 :   soap->dime.first = NULL;
; 5943 :   soap->dime.last = NULL;
; 5944 : #endif
; 5945 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End send\n"));
; 5946 :   if (soap->mode & SOAP_IO) /* need to flush the remaining data in buffer */

	test	BYTE PTR [esi+8], 3
	mov	DWORD PTR [esi+90532], edi
	mov	DWORD PTR [esi+90536], edi
	mov	DWORD PTR [esi+90540], edi
	mov	DWORD PTR [esi+90512], edi
	mov	DWORD PTR [esi+90516], edi
	mov	DWORD PTR [esi+90520], edi
	je	$LN1@soap_end_s

; 5947 :   { if (soap_flush(soap))

	mov	eax, esi
	call	_soap_flush
	test	eax, eax

; 5948 : #ifdef WITH_ZLIB
; 5949 :     { if (soap->mode & SOAP_ENC_ZLIB && soap->zlib_state == SOAP_ZLIB_DEFLATE)
; 5950 :       { soap->zlib_state = SOAP_ZLIB_NONE;
; 5951 :         deflateEnd(soap->d_stream);
; 5952 :       }
; 5953 :       return soap->error;
; 5954 :     }
; 5955 : #else
; 5956 :       return soap->error;

	jne	$LN17@soap_end_s

; 5957 : #endif
; 5958 : #ifdef WITH_ZLIB
; 5959 :     if (soap->mode & SOAP_ENC_ZLIB)
; 5960 :     { int r;
; 5961 :       soap->d_stream->avail_in = 0;
; 5962 :       do
; 5963 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Deflating remainder\n"));
; 5964 :         r = deflate(soap->d_stream, Z_FINISH);
; 5965 :         if (soap->d_stream->avail_out != SOAP_BUFLEN)
; 5966 :         { if (soap_flush_raw(soap, soap->z_buf, SOAP_BUFLEN - soap->d_stream->avail_out))
; 5967 :           { soap->zlib_state = SOAP_ZLIB_NONE;
; 5968 :             deflateEnd(soap->d_stream);
; 5969 :             return soap->error;
; 5970 :           }
; 5971 :           soap->d_stream->next_out = (Byte*)soap->z_buf;
; 5972 :           soap->d_stream->avail_out = SOAP_BUFLEN;
; 5973 :         }
; 5974 :       } while (r == Z_OK);
; 5975 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Deflated total %lu->%lu bytes\n", soap->d_stream->total_in, soap->d_stream->total_out));
; 5976 :       soap->z_ratio_out = (float)soap->d_stream->total_out / (float)soap->d_stream->total_in;
; 5977 :       soap->mode &= ~SOAP_ENC_ZLIB;
; 5978 :       soap->zlib_state = SOAP_ZLIB_NONE;
; 5979 :       if (deflateEnd(soap->d_stream) != Z_OK || r != Z_STREAM_END)
; 5980 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unable to end deflate: %s\n", soap->d_stream->msg?soap->d_stream->msg:""));
; 5981 :         return soap->error = SOAP_ZLIB_ERROR;
; 5982 :       }
; 5983 : #ifdef WITH_GZIP
; 5984 :       if (soap->zlib_out != SOAP_ZLIB_DEFLATE)
; 5985 :       { soap->z_buf[0] = soap->z_crc & 0xFF;
; 5986 :         soap->z_buf[1] = (soap->z_crc >> 8) & 0xFF;
; 5987 :         soap->z_buf[2] = (soap->z_crc >> 16) & 0xFF;
; 5988 :         soap->z_buf[3] = (soap->z_crc >> 24) & 0xFF;
; 5989 :         soap->z_buf[4] = soap->d_stream->total_in & 0xFF;
; 5990 :         soap->z_buf[5] = (soap->d_stream->total_in >> 8) & 0xFF;
; 5991 :         soap->z_buf[6] = (soap->d_stream->total_in >> 16) & 0xFF;
; 5992 :         soap->z_buf[7] = (soap->d_stream->total_in >> 24) & 0xFF;
; 5993 :         if (soap_flush_raw(soap, soap->z_buf, 8))
; 5994 :           return soap->error;
; 5995 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "gzip crc32=%lu\n", (unsigned long)soap->z_crc));
; 5996 :       }
; 5997 : #endif
; 5998 :     }
; 5999 : #endif
; 6000 :     if ((soap->mode & SOAP_IO) == SOAP_IO_STORE)

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, ecx
	and	eax, 3
	cmp	eax, 2
	jne	$LN14@soap_end_s

; 6001 :     { char *p;
; 6002 : #ifndef WITH_NOHTTP
; 6003 :       if (!(soap->mode & SOAP_ENC_XML))

	test	cl, 64					; 00000040H
	jne	$LN13@soap_end_s

; 6004 :       { soap->mode--;
; 6005 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Sending buffered message of length %u\n", (unsigned int)soap->blist->size));
; 6006 :         if (soap->status >= SOAP_POST)

	mov	eax, DWORD PTR [esi+90456]
	dec	ecx
	cmp	eax, 2000				; 000007d0H
	mov	DWORD PTR [esi+8], ecx
	jl	SHORT $LN12@soap_end_s

; 6007 :           soap->error = soap->fpost(soap, soap->endpoint, soap->host, soap->port, soap->path, soap->action, soap->blist->size);

	mov	ecx, DWORD PTR [esi+92]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [esi+90392]
	push	edx
	mov	edx, DWORD PTR [esi+90408]
	push	eax
	lea	ecx, DWORD PTR [esi+88344]
	push	ecx
	push	edx
	mov	edx, DWORD PTR [esi+12232]
	lea	eax, DWORD PTR [esi+89368]
	push	eax
	lea	ecx, DWORD PTR [esi+87320]
	push	ecx
	push	esi
	call	edx
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN27@soap_end_s
$LN12@soap_end_s:

; 6008 :         else if (soap->status != SOAP_STOP)

	cmp	eax, 1000				; 000003e8H
	je	SHORT $LN10@soap_end_s

; 6009 :           soap->error = soap->fresponse(soap, soap->status, soap->blist->size);

	mov	ecx, DWORD PTR [esi+92]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+12260]
	push	esi
	call	eax
	add	esp, 12					; 0000000cH
$LN27@soap_end_s:
	mov	DWORD PTR [esi+90460], eax
$LN10@soap_end_s:

; 6010 :         if (soap->error || soap_flush(soap))

	cmp	DWORD PTR [esi+90460], edi
	jne	SHORT $LN17@soap_end_s
	mov	eax, esi
	call	_soap_flush
	test	eax, eax
	jne	SHORT $LN17@soap_end_s

; 6011 :           return soap->error;
; 6012 :         soap->mode++;

	inc	DWORD PTR [esi+8]
$LN13@soap_end_s:

; 6013 :       }
; 6014 : #endif
; 6015 :       for (p = soap_first_block(soap); p; p = soap_next_block(soap))

	call	_soap_first_block
	cmp	eax, edi
	je	SHORT $LN5@soap_end_s
$LL7@soap_end_s:

; 6016 :       { DBGMSG(SENT, p, soap_block_size(soap));
; 6017 :         if ((soap->error = soap->fsend(soap, p, soap_block_size(soap))))

	mov	ecx, DWORD PTR [esi+92]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+4]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+12308]
	push	esi
	call	eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+90460], eax
	cmp	eax, edi
	jne	SHORT $LN25@soap_end_s
	call	_soap_next_block
	cmp	eax, edi
	jne	SHORT $LL7@soap_end_s
$LN5@soap_end_s:

; 6019 :           return soap->error;
; 6020 :         }
; 6021 :       }
; 6022 :       soap_end_block(soap);

	push	esi
	call	_soap_end_block
	add	esp, 4
	jmp	SHORT $LN1@soap_end_s
$LN25@soap_end_s:

; 6018 :         { soap_end_block(soap);

	push	esi
	call	_soap_end_block
	add	esp, 4
$LN17@soap_end_s:

; 5937 :     return soap->error;

	mov	eax, DWORD PTR [esi+90460]
$LN20@soap_end_s:
	pop	edi
	pop	esi

; 6046 : }

	ret	0
$LN14@soap_end_s:

; 6023 :     }
; 6024 : #ifndef WITH_LEANER
; 6025 :     else if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK)

	cmp	eax, 3
	jne	SHORT $LN1@soap_end_s

; 6026 :     { DBGMSG(SENT, "\r\n0\r\n\r\n", 7);
; 6027 :       if ((soap->error = soap->fsend(soap, "\r\n0\r\n\r\n", 7)))

	mov	ecx, DWORD PTR [esi+12308]
	push	7
	push	OFFSET ??_C@_07MEMIDCKI@?$AN?60?$AN?6?$AN?6?$AA@
	push	esi
	call	ecx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+90460], eax
	cmp	eax, edi

; 6028 :         return soap->error;

	jne	SHORT $LN20@soap_end_s
$LN1@soap_end_s:

; 6029 :     }
; 6030 : #endif
; 6031 :   }
; 6032 : #ifdef WITH_TCPFIN
; 6033 : #ifdef WITH_OPENSSL
; 6034 :   if (!soap->ssl && soap_valid_socket(soap->socket) && !soap->keep_alive && !(soap->omode & SOAP_IO_UDP))
; 6035 :     soap->fshutdownsocket(soap, soap->socket, 1); /* Send TCP FIN */
; 6036 : #else
; 6037 :   if (soap_valid_socket(soap->socket) && !soap->keep_alive && !(soap->omode & SOAP_IO_UDP))
; 6038 :     soap->fshutdownsocket(soap, soap->socket, 1); /* Send TCP FIN */
; 6039 : #endif
; 6040 : #endif
; 6041 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End of send phase\n"));
; 6042 :   soap->omode &= ~SOAP_XML_SEC;

	and	DWORD PTR [esi+16], -524289		; fff7ffffH

; 6043 :   soap->count = 0;

	mov	DWORD PTR [esi+12448], edi

; 6044 :   soap->part = SOAP_END;

	mov	edx, 9
	pop	edi
	mov	WORD PTR [esi+87304], dx

; 6045 :   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 6046 : }

	ret	0
_soap_end_send ENDP
_TEXT	ENDS
PUBLIC	_soap_move
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_move PROC
; _soap$ = ecx
; _n$ = eax

; 1638 : { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Moving %ld bytes forward\n", (long)n));

	push	esi
	push	edi
	mov	edi, eax
	mov	esi, ecx

; 1639 :   for (; n > 0; n--)

	test	edi, edi
	jle	SHORT $LN2@soap_move
	npad	6
$LL4@soap_move:

; 1640 :     if ((int)soap_getchar(soap) == EOF)

	mov	eax, DWORD PTR [esi+12436]
	test	eax, eax
	je	SHORT $LN8@soap_move
	cmp	eax, -1
	je	SHORT $LN7@soap_move
	mov	DWORD PTR [esi+12436], 0
$LN7@soap_move:
	mov	ecx, eax
	jmp	SHORT $LN12@soap_move
$LN8@soap_move:
	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN11@soap_move
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN14@soap_move
$LN11@soap_move:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ecx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
$LN12@soap_move:
	cmp	ecx, -1
	je	SHORT $LN14@soap_move
	dec	edi
	test	edi, edi
	jg	SHORT $LL4@soap_move
$LN2@soap_move:
	pop	edi

; 1642 :   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 1643 : }

	ret	0
$LN14@soap_move:
	pop	edi

; 1641 :       return SOAP_EOF;

	or	eax, -1
	pop	esi

; 1643 : }

	ret	0
_soap_move ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_soap_get_pi PROC
; _soap$ = ecx

; 1595 : { char buf[64];

	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+68], eax
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1596 :   register char *s = buf;
; 1597 :   register int i = sizeof(buf);
; 1598 :   register soap_wchar c = soap_getchar(soap);

	mov	ebx, DWORD PTR [esi+12436]
	push	edi
	lea	edi, DWORD PTR _buf$[esp+84]
	mov	ebp, 64					; 00000040H
	test	ebx, ebx
	je	SHORT $LN15@soap_get_p
	cmp	ebx, -1
	je	$LN10@soap_get_p
	mov	DWORD PTR [esi+12436], 0
	jmp	SHORT $LN19@soap_get_p
$LN15@soap_get_p:
	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN31@soap_get_p
	call	_soap_recv
	test	eax, eax
	jne	$LN29@soap_get_p
$LN31@soap_get_p:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ebx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
$LN19@soap_get_p:

; 1599 :   /* This is a quick way to parse XML PI and we could use a callback instead to
; 1600 :    * enable applications to intercept processing instructions */
; 1601 :   while ((int)c != EOF && c != '?')

	cmp	ebx, -1
	je	SHORT $LN10@soap_get_p
$LL11@soap_get_p:
	cmp	ebx, 63					; 0000003fH
	je	SHORT $LN10@soap_get_p

; 1602 :   { if (--i > 0)

	dec	ebp
	test	ebp, ebp
	jle	SHORT $LN9@soap_get_p

; 1603 :     { if (soap_blank(c))

	cmp	ebx, 32					; 00000020H
	ja	SHORT $LN8@soap_get_p

; 1604 :         c = ' ';

	mov	ebx, 32					; 00000020H
$LN8@soap_get_p:

; 1605 :       *s++ = (char)c;

	mov	BYTE PTR [edi], bl
	inc	edi
$LN9@soap_get_p:

; 1606 :     }
; 1607 :     c = soap_getchar(soap);

	mov	ebx, DWORD PTR [esi+12436]
	test	ebx, ebx
	je	SHORT $LN21@soap_get_p
	cmp	ebx, -1
	je	SHORT $LN10@soap_get_p
	mov	DWORD PTR [esi+12436], 0
	jmp	SHORT $LN25@soap_get_p
$LN21@soap_get_p:
	mov	ecx, DWORD PTR [esi+12428]
	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN24@soap_get_p
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN29@soap_get_p
$LN24@soap_get_p:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ebx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
$LN25@soap_get_p:

; 1599 :   /* This is a quick way to parse XML PI and we could use a callback instead to
; 1600 :    * enable applications to intercept processing instructions */
; 1601 :   while ((int)c != EOF && c != '?')

	cmp	ebx, -1
	jne	SHORT $LL11@soap_get_p
	jmp	SHORT $LN10@soap_get_p
$LN29@soap_get_p:

; 1606 :     }
; 1607 :     c = soap_getchar(soap);

	or	ebx, -1
$LN10@soap_get_p:

; 1608 :   }
; 1609 :   *s = '\0';
; 1610 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "XML PI <?%s?>\n", buf));
; 1611 :   if (!strncmp(buf, "xml ", 4))

	push	4
	lea	edx, DWORD PTR _buf$[esp+88]
	push	OFFSET ??_C@_04ONHKJKNE@xml?5?$AA@
	push	edx
	mov	BYTE PTR [edi], 0
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@soap_get_p

; 1612 :   { s = strstr(buf, " encoding=");

	lea	eax, DWORD PTR _buf$[esp+84]
	push	OFFSET ??_C@_0L@GJNPICMJ@?5encoding?$DN?$AA@
	push	eax
	call	_strstr
	add	esp, 8

; 1613 :     if (s && s[10])

	test	eax, eax
	je	SHORT $LN2@soap_get_p
	cmp	BYTE PTR [eax+10], 0
	je	SHORT $LN2@soap_get_p

; 1614 :     { if (!soap_tag_cmp(s + 11, "iso-8859-1*")
; 1615 :        || !soap_tag_cmp(s + 11, "latin1*"))

	lea	edi, DWORD PTR [eax+11]
	push	OFFSET ??_C@_0M@CIPLLKIK@iso?98859?91?$CK?$AA@
	push	edi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@soap_get_p
	push	OFFSET ??_C@_07KFPCELGH@latin1?$CK?$AA@
	push	edi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@soap_get_p

; 1618 :       }
; 1619 :       else if (!soap_tag_cmp(s + 11, "utf-8*"))

	push	OFFSET ??_C@_06ENEJBNNE@utf?98?$CK?$AA@
	push	edi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@soap_get_p

; 1620 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Switching to utf-8 encoding\n"));
; 1621 :         soap->mode &= ~SOAP_ENC_LATIN;

	and	DWORD PTR [esi+8], -33			; ffffffdfH
	jmp	SHORT $LN2@soap_get_p
$LN4@soap_get_p:

; 1616 :       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Switching to latin1 encoding\n"));
; 1617 :         soap->mode |= SOAP_ENC_LATIN;

	or	DWORD PTR [esi+8], 32			; 00000020H
$LN2@soap_get_p:

; 1622 :       }
; 1623 :     }
; 1624 :   }
; 1625 :   if ((int)c != EOF)

	cmp	ebx, -1
	je	SHORT $LN30@soap_get_p

; 1626 :     c = soap_getchar(soap);

	mov	eax, esi
	call	_soap_getchar
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1627 :   return c;
; 1628 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+68]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 68					; 00000044H
	ret	0
$LN30@soap_get_p:
	mov	ecx, DWORD PTR __$ArrayPad$[esp+84]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 68					; 00000044H
	ret	0
_soap_get_pi ENDP
_TEXT	ENDS
PUBLIC	_soap_get
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_get PROC
; _soap$ = eax

; 1499 : { register soap_wchar c;

	push	esi
	mov	esi, eax

; 1500 :   c = soap->ahead;

	mov	eax, DWORD PTR [esi+12436]
	push	edi

; 1501 :   if (c)

	test	eax, eax
	je	SHORT $LN47@soap_get

; 1502 :   { if ((int)c != EOF)

	cmp	eax, -1
	je	$LN48@soap_get

; 1503 :       soap->ahead = 0;

	mov	DWORD PTR [esi+12436], 0

; 1504 :   }
; 1505 :   else

	jmp	SHORT $LN51@soap_get
$LN47@soap_get:

; 1506 :     c = soap_get1(soap);

	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN50@soap_get
	call	_soap_recv
	test	eax, eax
	je	SHORT $LN50@soap_get
$LN112@soap_get:
	pop	edi
	or	eax, -1
	pop	esi

; 1584 :     }
; 1585 :     break;
; 1586 :   }
; 1587 :   return c;
; 1588 : }

	ret	0
$LN50@soap_get:

; 1506 :     c = soap_get1(soap);

	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx
$LN51@soap_get:

; 1507 :   while ((int)c != EOF)

	cmp	eax, -1
	je	$LN48@soap_get
	npad	2
$LL44@soap_get:

; 1508 :   { if (soap->cdata)

	cmp	WORD PTR [esi+12440], 0
	je	$LN59@soap_get

; 1509 :     { if (c == ']')

	cmp	eax, 93					; 0000005dH
	jne	$LN48@soap_get

; 1510 :       { c = soap_get1(soap);

	mov	ecx, DWORD PTR [esi+12428]
	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN52@soap_get
	call	_soap_recv
	test	eax, eax
	jne	$LN40@soap_get
$LN52@soap_get:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ecx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax

; 1511 :         if (c == ']')

	cmp	ecx, 93					; 0000005dH
	jne	$LN40@soap_get

; 1512 :         { c = soap_get0(soap);

	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN54@soap_get
	call	_soap_recv
	test	eax, eax
	jne	$LN39@soap_get
$LN54@soap_get:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ecx, BYTE PTR [eax+esi+12468]

; 1513 :           if (c == '>')

	cmp	ecx, 62					; 0000003eH
	jne	$LN39@soap_get

; 1514 :           { soap->cdata = 0;

	xor	edx, edx
	mov	WORD PTR [esi+12440], dx

; 1515 :             soap_get1(soap);

	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN56@soap_get
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN57@soap_get
$LN56@soap_get:
	inc	DWORD PTR [esi+12428]
$LN57@soap_get:

; 1516 :             c = soap_get1(soap);

	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN58@soap_get
	call	_soap_recv
	test	eax, eax
	je	SHORT $LN58@soap_get
	or	eax, -1
	jmp	SHORT $LN59@soap_get
$LN58@soap_get:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx
$LN59@soap_get:

; 1526 :         }
; 1527 :       }
; 1528 :       else
; 1529 :         return c;
; 1530 :     }
; 1531 :     switch (c)

	lea	ecx, DWORD PTR [eax-34]
	cmp	ecx, 28					; 0000001cH
	ja	$LN48@soap_get
	movzx	ecx, BYTE PTR $LN115@soap_get[ecx]
	jmp	DWORD PTR $LN122@soap_get[ecx*4]
	npad	9
$LL32@soap_get:

; 1532 :     { case '<':
; 1533 :         do c = soap_get1(soap);

	mov	edx, DWORD PTR [esi+12428]
	cmp	edx, DWORD PTR [esi+12432]
	jb	SHORT $LN60@soap_get
	call	_soap_recv
	test	eax, eax
	jne	$LN5@soap_get
$LN60@soap_get:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx

; 1534 :         while (soap_blank(c));

	test	eax, eax
	jl	SHORT $LN29@soap_get
	cmp	eax, 32					; 00000020H
	jle	SHORT $LL32@soap_get
$LN29@soap_get:

; 1535 :         if (c == '!' || c == '?' || c == '%')

	cmp	eax, 33					; 00000021H
	je	SHORT $LN27@soap_get
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN27@soap_get
	cmp	eax, 37					; 00000025H
	jne	$LN28@soap_get
$LN27@soap_get:

; 1536 :         { register int k = 1;

	mov	edi, 1

; 1537 :           if (c == '!')

	cmp	eax, 33					; 00000021H
	jne	$LN26@soap_get

; 1538 :           { c = soap_get1(soap);

	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN62@soap_get
	call	_soap_recv
	test	eax, eax
	jne	$LN112@soap_get
$LN62@soap_get:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx

; 1539 :             if (c == '[')

	cmp	eax, 91					; 0000005bH
	jne	SHORT $LN25@soap_get
	npad	7
$LL24@soap_get:

; 1540 :             { do c = soap_get1(soap);

	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN64@soap_get
	call	_soap_recv
	test	eax, eax
	jne	$LN112@soap_get
$LN64@soap_get:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx

; 1541 :               while ((int)c != EOF && c != '[');

	cmp	eax, -1
	je	$LN48@soap_get
	cmp	eax, 91					; 0000005bH
	jne	SHORT $LL24@soap_get

; 1542 :               if ((int)c == EOF)
; 1543 :                 break;
; 1544 :               soap->cdata = 1;
; 1545 :               c = soap_get1(soap);

	cmp	ecx, DWORD PTR [esi+12432]
	mov	eax, edi
	mov	WORD PTR [esi+12440], ax

; 1546 :               continue;

	jmp	$LN121@soap_get
$LN25@soap_get:

; 1547 :             }
; 1548 :             if (c == '-' && (c = soap_get1(soap)) == '-')

	cmp	eax, 45					; 0000002dH
	jne	$LN83@soap_get
	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN68@soap_get
	call	_soap_recv
	test	eax, eax
	jne	$LN112@soap_get
$LN68@soap_get:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN83@soap_get
$LL18@soap_get:

; 1549 :             { do
; 1550 :               { c = soap_get1(soap);

	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN70@soap_get
	call	_soap_recv
	test	eax, eax
	jne	$LN112@soap_get
$LN70@soap_get:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx

; 1551 :                 if (c == '-' && (c = soap_get1(soap)) == '-')

	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN17@soap_get
	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN72@soap_get
	call	_soap_recv
	test	eax, eax
	jne	$LN112@soap_get
$LN72@soap_get:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN83@soap_get
$LN17@soap_get:

; 1552 :                   break;
; 1553 :               } while ((int)c != EOF);

	cmp	eax, -1
	jne	SHORT $LL18@soap_get
	pop	edi
	pop	esi

; 1584 :     }
; 1585 :     break;
; 1586 :   }
; 1587 :   return c;
; 1588 : }

	ret	0
$LN26@soap_get:

; 1554 :             }
; 1555 :           }
; 1556 :           else if (c == '?')

	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN83@soap_get

; 1557 :             c = soap_get_pi(soap);

	mov	ecx, esi
	call	_soap_get_pi
$LN83@soap_get:

; 1558 :           while ((int)c != EOF)

	cmp	eax, -1
	je	$LN48@soap_get
	npad	1
$LL12@soap_get:

; 1559 :           { if (c == '<')

	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN10@soap_get

; 1560 :               k++;

	inc	edi
	jmp	SHORT $LN7@soap_get
$LN10@soap_get:

; 1561 :             else if (c == '>')

	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN7@soap_get

; 1562 :             { if (--k <= 0)

	dec	edi
	test	edi, edi
	jle	SHORT $LN98@soap_get
$LN7@soap_get:

; 1563 :                 break;
; 1564 :             }
; 1565 :             c = soap_get1(soap);

	mov	ecx, DWORD PTR [esi+12428]
	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN74@soap_get
	call	_soap_recv
	test	eax, eax
	jne	$LN112@soap_get
$LN74@soap_get:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx
	cmp	eax, -1
	jne	SHORT $LL12@soap_get
	pop	edi
	pop	esi

; 1584 :     }
; 1585 :     break;
; 1586 :   }
; 1587 :   return c;
; 1588 : }

	ret	0
$LN98@soap_get:

; 1566 :           }
; 1567 :           if ((int)c == EOF)
; 1568 :             break;
; 1569 :           c = soap_get1(soap);

	mov	edx, DWORD PTR [esi+12428]
	cmp	edx, DWORD PTR [esi+12432]
$LN121@soap_get:
	jb	SHORT $LN76@soap_get
	call	_soap_recv
	test	eax, eax
	jne	$LN112@soap_get
$LN76@soap_get:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx
	cmp	eax, -1
	jne	$LL44@soap_get
	pop	edi
	pop	esi

; 1584 :     }
; 1585 :     break;
; 1586 :   }
; 1587 :   return c;
; 1588 : }

	ret	0
$LN39@soap_get:
	pop	edi

; 1517 :           }
; 1518 :           else
; 1519 :           { soap_unget(soap, ']');

	mov	DWORD PTR [esi+12436], 93		; 0000005dH

; 1520 :             return ']';

	mov	eax, 93					; 0000005dH
	pop	esi

; 1584 :     }
; 1585 :     break;
; 1586 :   }
; 1587 :   return c;
; 1588 : }

	ret	0
$LN40@soap_get:

; 1521 :           }
; 1522 :         }
; 1523 :         else
; 1524 :         { soap_revget1(soap);

	dec	DWORD PTR [esi+12428]
	pop	edi

; 1525 :           return ']';

	mov	eax, 93					; 0000005dH
	pop	esi

; 1584 :     }
; 1585 :     break;
; 1586 :   }
; 1587 :   return c;
; 1588 : }

	ret	0
$LN28@soap_get:

; 1570 :           continue;
; 1571 :         }
; 1572 :         if (c == '/')

	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN5@soap_get
	pop	edi

; 1573 :           return SOAP_TT;

	mov	eax, -3					; fffffffdH
	pop	esi

; 1584 :     }
; 1585 :     break;
; 1586 :   }
; 1587 :   return c;
; 1588 : }

	ret	0
$LN5@soap_get:

; 1574 :         soap_revget1(soap);

	dec	DWORD PTR [esi+12428]
	pop	edi

; 1575 :         return SOAP_LT;

	mov	eax, -2					; fffffffeH
	pop	esi

; 1584 :     }
; 1585 :     break;
; 1586 :   }
; 1587 :   return c;
; 1588 : }

	ret	0
$LN4@soap_get:
	pop	edi

; 1576 :       case '>':
; 1577 :         return SOAP_GT;

	mov	eax, -4					; fffffffcH
	pop	esi

; 1584 :     }
; 1585 :     break;
; 1586 :   }
; 1587 :   return c;
; 1588 : }

	ret	0
$LN3@soap_get:
	pop	edi

; 1578 :       case '"':
; 1579 :         return SOAP_QT;

	mov	eax, -5					; fffffffbH
	pop	esi

; 1584 :     }
; 1585 :     break;
; 1586 :   }
; 1587 :   return c;
; 1588 : }

	ret	0
$LN2@soap_get:
	pop	edi

; 1580 :       case '\'':
; 1581 :         return SOAP_AP;

	mov	eax, -6					; fffffffaH
	pop	esi

; 1584 :     }
; 1585 :     break;
; 1586 :   }
; 1587 :   return c;
; 1588 : }

	ret	0
$LN1@soap_get:

; 1582 :       case '&':
; 1583 :         return soap_char(soap) | 0x80000000;

	mov	ecx, esi
	call	_soap_char
	or	eax, -2147483648			; 80000000H
$LN48@soap_get:
	pop	edi
	pop	esi

; 1584 :     }
; 1585 :     break;
; 1586 :   }
; 1587 :   return c;
; 1588 : }

	ret	0
$LN122@soap_get:
	DD	$LN3@soap_get
	DD	$LN1@soap_get
	DD	$LN2@soap_get
	DD	$LL32@soap_get
	DD	$LN4@soap_get
	DD	$LN48@soap_get
$LN115@soap_get:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	4
_soap_get ENDP
PUBLIC	_soap_send_empty_response
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_send_empty_response PROC
; _soap$ = esi
; _httpstatuscode$ = edx

; 14502: { register soap_mode m = soap->omode;

	push	edi
	mov	edi, DWORD PTR [esi+16]

; 14503:   soap->count = 0;
; 14504:   if ((m & SOAP_IO) == SOAP_IO_CHUNK)

	mov	eax, edi
	and	eax, 3
	mov	DWORD PTR [esi+12448], 0
	cmp	al, 3
	jne	SHORT $LN3@soap_send_@2

; 14505:   { soap->omode &= ~SOAP_IO_CHUNK;

	mov	ecx, edi
	and	ecx, -3					; fffffffdH

; 14506:     soap->omode |= SOAP_IO_BUFFER;

	or	ecx, 1
	mov	DWORD PTR [esi+16], ecx
$LN3@soap_send_@2:

; 14507:   }
; 14508:   if (soap_response(soap, httpstatuscode) || soap_end_send(soap))

	push	edx
	mov	eax, esi
	call	_soap_response
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_send_@2
	mov	eax, esi
	call	_soap_end_send
	test	eax, eax
	jne	SHORT $LN1@soap_send_@2

; 14511:   }
; 14512:   soap->omode = m;

	mov	DWORD PTR [esi+16], edi
	pop	edi

; 14513:   return SOAP_OK;
; 14514: }

	ret	0
$LN1@soap_send_@2:

; 14509:   { soap->omode = m;

	mov	DWORD PTR [esi+16], edi

; 14510:     return soap_closesock(soap);

	mov	edi, DWORD PTR [esi+90460]
	cmp	edi, -1
	je	SHORT $LN7@soap_send_@2
	cmp	edi, 28					; 0000001cH
	je	SHORT $LN7@soap_send_@2
	cmp	edi, 30					; 0000001eH
	je	SHORT $LN7@soap_send_@2
	cmp	WORD PTR [esi+90412], 0
	jne	SHORT $LN8@soap_send_@2
$LN7@soap_send_@2:
	mov	eax, DWORD PTR [esi+12304]
	test	eax, eax
	je	SHORT $LN6@soap_send_@2
	push	esi
	call	eax
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	jne	SHORT $LN4@soap_send_@2
$LN6@soap_send_@2:
	xor	eax, eax
	mov	WORD PTR [esi+90412], ax
$LN8@soap_send_@2:
	mov	DWORD PTR [esi+90460], edi
	mov	eax, edi
$LN4@soap_send_@2:
	pop	edi

; 14513:   return SOAP_OK;
; 14514: }

	ret	0
_soap_send_empty_response ENDP
_TEXT	ENDS
PUBLIC	_endpoint$GSCopy$
PUBLIC	_action$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_soap_connect_command
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_action$GSCopy$ = -1040					; size = 4
_count$ = -1036						; size = 4
_endpoint$GSCopy$ = -1032				; size = 4
_host$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_endpoint$ = 8						; size = 4
_action$ = 12						; size = 4
_soap_connect_command PROC
; _soap$ = ecx

; 13562: { char host[sizeof(soap->host)];

	sub	esp, 1040				; 00000410H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+1040], eax

; 13602:   if ((soap->mode & SOAP_IO) != SOAP_IO_STORE && !(soap->mode & SOAP_ENC_XML) && endpoint)

	mov	eax, DWORD PTR _action$[esp+1036]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _endpoint$[esp+1044]
	push	esi
	mov	esi, ecx
	push	edi
	lea	edi, DWORD PTR [esi+89368]
	lea	edx, DWORD PTR _host$[esp+1056]
	mov	DWORD PTR _action$GSCopy$[esp+1056], eax

; 13609: #ifndef WITH_LEANER
; 13610:     if ((k & SOAP_IO) == SOAP_IO_CHUNK)

	mov	DWORD PTR _endpoint$GSCopy$[esp+1056], ebp
	mov	DWORD PTR [esi+90460], 0
	mov	eax, edi
	sub	edx, edi
$LL19@soap_conne:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL19@soap_conne
	mov	ebx, DWORD PTR [esi+90408]
	push	esi
	mov	eax, ebp
	mov	DWORD PTR [esi+90456], 2000		; 000007d0H
	call	_soap_set_endpoint
	mov	eax, DWORD PTR [esi+12280]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@soap_conne
	mov	ecx, DWORD PTR [esi+90408]
	push	ecx
	push	edi
	push	ebp
	push	esi
	call	eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	je	$LN12@soap_conne

; 13563:   int port;
; 13564:   size_t count;
; 13565:   soap->error = SOAP_OK;
; 13566:   strcpy(host, soap->host); /* save previous host name to compare */
; 13567:   port = soap->port; /* save previous port to compare */
; 13568:   soap->status = http_command;
; 13569:   soap_set_endpoint(soap, endpoint);
; 13570: #ifndef WITH_LEANER
; 13571:   if (soap->fconnect)
; 13572:   { if ((soap->error = soap->fconnect(soap, endpoint, soap->host, soap->port)))
; 13573:       return soap->error;

	jmp	$LN17@soap_conne
$LN16@soap_conne:

; 13574:   }
; 13575:   else
; 13576: #endif
; 13577:   if (soap->fopen && *soap->host)

	cmp	DWORD PTR [esi+12296], 0
	je	$LN12@soap_conne
	cmp	BYTE PTR [edi], 0
	je	$LN12@soap_conne

; 13578:   { if (!soap->keep_alive || !soap_valid_socket(soap->socket) || strcmp(soap->host, host) || soap->port != port || !soap->fpoll || soap->fpoll(soap))

	cmp	WORD PTR [esi+90412], 0
	je	SHORT $LN11@soap_conne
	cmp	DWORD PTR [esi+12408], -1
	je	SHORT $LN11@soap_conne
	lea	ecx, DWORD PTR _host$[esp+1056]
	mov	eax, edi
$LL21@soap_conne:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN22@soap_conne
	test	dl, dl
	je	SHORT $LN23@soap_conne
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN22@soap_conne
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL21@soap_conne
$LN23@soap_conne:
	xor	eax, eax
	jmp	SHORT $LN24@soap_conne
$LN22@soap_conne:
	sbb	eax, eax
	sbb	eax, -1
$LN24@soap_conne:
	test	eax, eax
	jne	SHORT $LN11@soap_conne
	cmp	DWORD PTR [esi+90408], ebx
	jne	SHORT $LN11@soap_conne
	mov	eax, DWORD PTR [esi+12316]
	test	eax, eax
	je	SHORT $LN11@soap_conne
	push	esi
	call	eax
	add	esp, 4
	test	eax, eax
	je	SHORT $LN12@soap_conne
$LN11@soap_conne:

; 13579:     { soap->keep_alive = 0; /* to force close */
; 13580:       soap->omode &= ~SOAP_IO_UDP; /* to force close */

	and	DWORD PTR [esi+16], -5			; fffffffbH
	xor	edx, edx
	mov	WORD PTR [esi+90412], dx

; 13581:       soap_closesock(soap);

	call	_soap_closesock

; 13582:       DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Connect/reconnect to host='%s' path='%s' port=%d\n", soap->host, soap->path, soap->port));
; 13583: #ifndef WITH_LEAN
; 13584:       if (!strncmp(endpoint, "soap.udp:", 9))

	push	9
	push	OFFSET ??_C@_09LLHAEKON@soap?4udp?3?$AA@
	push	ebp
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@soap_conne

; 13585:         soap->omode |= SOAP_IO_UDP;

	or	DWORD PTR [esi+16], 4
$LN10@soap_conne:

; 13586: #endif
; 13587:       soap->socket = soap->fopen(soap, endpoint, soap->host, soap->port);

	mov	eax, DWORD PTR [esi+90408]
	mov	ecx, DWORD PTR [esi+12296]
	push	eax
	push	edi
	push	ebp
	push	esi
	call	ecx
	mov	DWORD PTR [esi+12408], eax

; 13588:       if (soap->error)

	mov	eax, DWORD PTR [esi+90460]
	add	esp, 16					; 00000010H
	test	eax, eax

; 13589:         return soap->error;

	jne	$LN17@soap_conne

; 13590:       soap->keep_alive = ((soap->omode & SOAP_IO_KEEPALIVE) != 0);

	mov	edx, DWORD PTR [esi+16]
	shr	edx, 4
	and	edx, 1
	mov	WORD PTR [esi+90412], dx
$LN12@soap_conne:

; 13591:     }
; 13592:   }
; 13593:   count = soap_count_attachments(soap);

	push	esi
	call	_soap_count_attachments
	add	esp, 4
	mov	DWORD PTR _count$[esp+1056], eax

; 13594:   if (soap_begin_send(soap))

	call	_soap_begin_send
	test	eax, eax
	je	SHORT $LN7@soap_conne
$LN25@soap_conne:

; 13595:     return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	jmp	$LN17@soap_conne
$LN7@soap_conne:

; 13596:   if (http_command != SOAP_POST)
; 13597:   { soap->mode &= ~SOAP_IO;
; 13598:     soap->mode |= SOAP_IO_BUFFER;
; 13599:   }
; 13600: #ifndef WITH_NOHTTP
; 13601:   soap->action = soap_strdup(soap, action);

	mov	eax, DWORD PTR _action$GSCopy$[esp+1056]
	push	eax
	push	esi
	call	_soap_strdup

; 13602:   if ((soap->mode & SOAP_IO) != SOAP_IO_STORE && !(soap->mode & SOAP_ENC_XML) && endpoint)

	mov	ebx, DWORD PTR [esi+8]
	mov	ecx, ebx
	and	cl, 3
	add	esp, 8
	mov	DWORD PTR [esi+90392], eax
	cmp	cl, 2
	je	SHORT $LN1@soap_conne
	test	bl, 64					; 00000040H
	jne	SHORT $LN1@soap_conne
	test	ebp, ebp
	je	SHORT $LN1@soap_conne

; 13603:   { unsigned int k = soap->mode;
; 13604:     soap->mode &= ~(SOAP_IO | SOAP_ENC_ZLIB);

	mov	eax, ebx
	and	eax, -1028				; fffffbfcH

; 13605:     if ((k & SOAP_IO) != SOAP_IO_FLUSH)

	mov	ebp, ebx
	and	ebp, 3
	mov	DWORD PTR [esi+8], eax
	je	SHORT $LN5@soap_conne

; 13606:       soap->mode |= SOAP_IO_BUFFER;

	or	eax, 1
	mov	DWORD PTR [esi+8], eax
$LN5@soap_conne:

; 13607:     if ((soap->error = soap->fpost(soap, endpoint, soap->host, soap->port, soap->path, action, count)))

	mov	edx, DWORD PTR _count$[esp+1056]
	mov	eax, DWORD PTR _action$GSCopy$[esp+1056]
	push	edx
	mov	edx, DWORD PTR [esi+90408]
	push	eax
	mov	eax, DWORD PTR _endpoint$GSCopy$[esp+1064]
	lea	ecx, DWORD PTR [esi+88344]
	push	ecx
	mov	ecx, DWORD PTR [esi+12232]
	push	edx
	push	edi
	push	eax
	push	esi
	call	ecx
	add	esp, 28					; 0000001cH
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax

; 13608:       return soap->error;

	jne	SHORT $LN17@soap_conne

; 13609: #ifndef WITH_LEANER
; 13610:     if ((k & SOAP_IO) == SOAP_IO_CHUNK)

	cmp	ebp, 3
	jne	SHORT $LN2@soap_conne

; 13611:     { if (soap_flush(soap))

	mov	eax, esi
	call	_soap_flush
	test	eax, eax

; 13612:         return soap->error;

	jne	$LN25@soap_conne
$LN2@soap_conne:

; 13613:     }
; 13614: #endif
; 13615:     soap->mode = k;

	mov	DWORD PTR [esi+8], ebx
$LN1@soap_conne:

; 13616:   }
; 13617:   if (http_command != SOAP_POST)
; 13618:     return soap_end_send(soap);
; 13619: #endif
; 13620:   return SOAP_OK;

	xor	eax, eax
$LN17@soap_conne:

; 13621: }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+1056]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 1040				; 00000410H
	ret	0
_soap_connect_command ENDP
_TEXT	ENDS
PUBLIC	_soap_connect
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_connect PROC
; _endpoint$ = ecx
; _action$ = eax

; 13552: { return soap_connect_command(soap, SOAP_POST, endpoint, action);

	push	eax
	push	ecx
	mov	ecx, DWORD PTR _soap$[esp+4]
	call	_soap_connect_command
	add	esp, 8

; 13553: }

	ret	0
_soap_connect ENDP
_TEXT	ENDS
PUBLIC	_soap_envelope_begin_out
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_envelope_begin_out PROC
; _soap$ = eax

; 13273: {

	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 13274: #ifndef WITH_LEANER
; 13275:   size_t n = 0;
; 13276:   if ((soap->mode & SOAP_ENC_MIME) && soap->mime.boundary && soap->mime.start && strlen(soap->mime.boundary) + strlen(soap->mime.start) < sizeof(soap->tmpbuf) - 80)

	mov	ebx, DWORD PTR [esi+8]
	push	edi
	test	ebx, 256				; 00000100H
	je	$LN21@soap_envel@2
	mov	eax, DWORD PTR [esi+90524]
	test	eax, eax
	je	$LN21@soap_envel@2
	mov	ebp, DWORD PTR [esi+90528]
	test	ebp, ebp
	je	$LN21@soap_envel@2
	lea	edx, DWORD PTR [eax+1]
$LL18@soap_envel@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL18@soap_envel@2
	sub	eax, edx
	mov	edx, eax
	mov	eax, ebp
	lea	edi, DWORD PTR [eax+1]
$LL19@soap_envel@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL19@soap_envel@2
	sub	eax, edi
	add	eax, edx
	cmp	eax, 944				; 000003b0H
	jae	SHORT $LN21@soap_envel@2

; 13277:   { const char *s;
; 13278:     if ((soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))

	test	bl, bl
	jns	SHORT $LN10@soap_envel@2
	test	ebx, 512				; 00000200H
	jne	SHORT $LN10@soap_envel@2

; 13279:       s = "application/dime";

	mov	eax, OFFSET ??_C@_0BB@KDHCEMMM@application?1dime?$AA@
	jmp	SHORT $LN5@soap_envel@2
$LN10@soap_envel@2:

; 13280:     else if (soap->version == 2)

	cmp	WORD PTR [esi+6], 2
	jne	SHORT $LN8@soap_envel@2

; 13281:     { if (soap->mode & SOAP_ENC_MTOM)

	test	ebx, 512				; 00000200H
	je	SHORT $LN7@soap_envel@2

; 13282:         s = "application/xop+xml; charset=utf-8; type=\"application/soap+xml\"";

	mov	eax, OFFSET ??_C@_0EA@OLHLLNHK@application?1xop?$CLxml?$DL?5charset?$DNutf@

; 13283:       else

	jmp	SHORT $LN5@soap_envel@2
$LN7@soap_envel@2:

; 13284:         s = "application/soap+xml; charset=utf-8";

	mov	eax, OFFSET ??_C@_0CE@HOOLIGFB@application?1soap?$CLxml?$DL?5charset?$DNut@

; 13285:     }
; 13286:     else

	jmp	SHORT $LN5@soap_envel@2
$LN8@soap_envel@2:

; 13287:       s = "text/xml; charset=utf-8";

	mov	eax, OFFSET ??_C@_0BI@JFLEALON@text?1xml?$DL?5charset?$DNutf?98?$AA@
$LN5@soap_envel@2:

; 13288:     sprintf(soap->tmpbuf, "--%s\r\nContent-Type: %s\r\nContent-Transfer-Encoding: binary\r\nContent-ID: %s\r\n\r\n", soap->mime.boundary, s, soap->mime.start);

	push	ebp
	push	eax
	mov	eax, DWORD PTR [esi+90524]
	push	eax
	lea	ebx, DWORD PTR [esi+79028]
	push	OFFSET ??_C@_0EO@EHIFGEMB@?9?9?$CFs?$AN?6Content?9Type?3?5?$CFs?$AN?6Content?9@
	push	ebx
	call	_sprintf

; 13289:     n = strlen(soap->tmpbuf);

	mov	eax, ebx
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL20@soap_envel@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL20@soap_envel@2
	sub	eax, edx

; 13290:     if (soap_send_raw(soap, soap->tmpbuf, n))

	push	eax
	push	ebx
	mov	eax, esi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@soap_envel@2
$LN25@soap_envel@2:

; 13291:       return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 13302: }

	ret	0
$LN21@soap_envel@2:

; 13292:   }
; 13293:   if (soap->mode & SOAP_IO_LENGTH)

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, ecx
	and	eax, 8
	je	SHORT $LN3@soap_envel@2

; 13294:     soap->dime.size = soap->count;	/* DIME in MIME correction */

	mov	edx, DWORD PTR [esi+12448]
	mov	DWORD PTR [esi+90480], edx
$LN3@soap_envel@2:

; 13295:   if (!(soap->mode & SOAP_IO_LENGTH) && (soap->mode & SOAP_ENC_DIME))

	test	eax, eax
	jne	SHORT $LN1@soap_envel@2
	test	cl, cl
	jns	SHORT $LN1@soap_envel@2

; 13296:   { if (soap_putdimehdr(soap))

	call	_soap_putdimehdr
	test	eax, eax

; 13297:       return soap->error;

	jne	SHORT $LN25@soap_envel@2
$LN1@soap_envel@2:

; 13298:   }
; 13299: #endif
; 13300:   soap->part = SOAP_IN_ENVELOPE;
; 13301:   return soap_element_begin_out(soap, "SOAP-ENV:Envelope", 0, NULL);

	push	0
	mov	eax, 2
	mov	WORD PTR [esi+87304], ax
	push	0
	push	OFFSET ??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@
	mov	eax, esi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@soap_envel@2
	push	eax
	mov	edi, esi
	call	_soap_element_start_end_out
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 13302: }

	ret	0
_soap_envelope_begin_out ENDP
_TEXT	ENDS
PUBLIC	_soap_getmimehdr
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_getmimehdr PROC
; _soap$ = esi

; 11410: { struct soap_multipart *content;

	push	ebx
	lea	ebx, DWORD PTR [esi+78004]
$LL32@soap_getmi@2:

; 11411:   do
; 11412:   { if (soap_getline(soap, soap->msgbuf, sizeof(soap->msgbuf)))

	push	1024					; 00000400H
	push	ebx
	mov	eax, esi
	call	_soap_getline
	add	esp, 8
	test	eax, eax
	jne	$LN42@soap_getmi@2

; 11414:   }
; 11415:   while (!*soap->msgbuf);

	cmp	BYTE PTR [ebx], al
	je	SHORT $LL32@soap_getmi@2

; 11416:   if (soap->msgbuf[0] == '-' && soap->msgbuf[1] == '-')

	cmp	BYTE PTR [ebx], 45			; 0000002dH
	jne	$LN52@soap_getmi@2
	cmp	BYTE PTR [esi+78005], 45		; 0000002dH
	jne	$LN52@soap_getmi@2

; 11417:   { char *s = soap->msgbuf + strlen(soap->msgbuf) - 1;

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL47@soap_getmi@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL47@soap_getmi@2
	sub	eax, edx

; 11418:     /* remove white space */
; 11419:     while (soap_blank(*s))

	cmp	BYTE PTR [eax+esi+78003], cl
	lea	eax, DWORD PTR [eax+esi+78003]
	jl	SHORT $LN26@soap_getmi@2
	npad	7
$LL27@soap_getmi@2:
	cmp	BYTE PTR [eax], 32			; 00000020H
	jg	SHORT $LN26@soap_getmi@2

; 11420:       s--;

	dec	eax
	cmp	BYTE PTR [eax], 0
	jge	SHORT $LL27@soap_getmi@2
$LN26@soap_getmi@2:

; 11421:     s[1] = '\0';

	mov	BYTE PTR [eax+1], 0

; 11422:     if (soap->mime.boundary)

	mov	ecx, DWORD PTR [esi+90524]

; 11423:     { if (strcmp(soap->msgbuf + 2, soap->mime.boundary))

	lea	eax, DWORD PTR [esi+78006]
	test	ecx, ecx
	je	SHORT $LN25@soap_getmi@2
	npad	1
$LL48@soap_getmi@2:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN49@soap_getmi@2
	test	dl, dl
	je	SHORT $LN50@soap_getmi@2
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN49@soap_getmi@2
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL48@soap_getmi@2
$LN50@soap_getmi@2:
	xor	eax, eax
	jmp	SHORT $LN51@soap_getmi@2
$LN42@soap_getmi@2:

; 11413:       return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	ebx

; 11462: }

	ret	0
$LN49@soap_getmi@2:

; 11423:     { if (strcmp(soap->msgbuf + 2, soap->mime.boundary))

	sbb	eax, eax
	sbb	eax, -1
$LN51@soap_getmi@2:
	test	eax, eax
	je	SHORT $LN23@soap_getmi@2

; 11424:         return soap->error = SOAP_MIME_ERROR;

	mov	eax, 36					; 00000024H
	mov	DWORD PTR [esi+90460], eax
	pop	ebx

; 11462: }

	ret	0
$LN25@soap_getmi@2:

; 11425:     }
; 11426:     else
; 11427:       soap->mime.boundary = soap_strdup(soap, soap->msgbuf + 2);

	push	eax
	push	esi
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR [esi+90524], eax
$LN23@soap_getmi@2:

; 11428:     if (soap_getline(soap, soap->msgbuf, sizeof(soap->msgbuf)))

	push	1024					; 00000400H
	lea	ebx, DWORD PTR [esi+78004]
	push	ebx
	mov	eax, esi
	call	_soap_getline
	add	esp, 8
	test	eax, eax

; 11429:       return soap->error;

	jne	SHORT $LN42@soap_getmi@2
$LN52@soap_getmi@2:

; 11430:   }
; 11431:   if (soap_set_mime_attachment(soap, NULL, 0, SOAP_MIME_NONE, NULL, NULL, NULL, NULL))

	mov	eax, esi
	call	_soap_set_mime_attachment
	test	eax, eax
	je	SHORT $LN21@soap_getmi@2

; 11432:     return soap->error = SOAP_EOM;

	mov	eax, 20					; 00000014H
	mov	DWORD PTR [esi+90460], eax
	pop	ebx

; 11462: }

	ret	0
$LN21@soap_getmi@2:

; 11433:   content = soap->mime.last;
; 11434:   for (;;)
; 11435:   { register char *key = soap->msgbuf;
; 11436:     register char *val;
; 11437:     if (!*key)

	cmp	BYTE PTR [ebx], 0
	push	ebp
	mov	ebp, DWORD PTR [esi+90540]
	push	edi
	je	$LN44@soap_getmi@2
$LL20@soap_getmi@2:

; 11438:       break;
; 11439:     DBGLOG(TEST,SOAP_MESSAGE(fdebug, "MIME header: %s\n", key));
; 11440:     val = strchr(soap->msgbuf, ':');

	push	58					; 0000003aH
	push	ebx
	call	_strchr
	mov	edi, eax
	add	esp, 8

; 11441:     if (val)

	test	edi, edi
	je	$LN2@soap_getmi@2

; 11442:     { *val = '\0';

	mov	BYTE PTR [edi], 0
	npad	7
$LL16@soap_getmi@2:

; 11443:       do val++;
; 11444:       while (*val && *val <= 32);

	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	je	SHORT $LN13@soap_getmi@2
	cmp	al, 32					; 00000020H
	jle	SHORT $LL16@soap_getmi@2
$LN13@soap_getmi@2:

; 11445:       if (!soap_tag_cmp(key, "Content-ID"))

	push	OFFSET ??_C@_0L@BJKBKLJG@Content?9ID?$AA@
	push	ebx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@soap_getmi@2

; 11446:         content->id = soap_strdup(soap, val);

	push	edi
	push	esi
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR [ebp+12], eax
	jmp	$LN2@soap_getmi@2
$LN12@soap_getmi@2:

; 11447:       else if (!soap_tag_cmp(key, "Content-Location"))

	push	OFFSET ??_C@_0BB@EPBMDIDM@Content?9Location?$AA@
	push	ebx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@soap_getmi@2

; 11448:         content->location = soap_strdup(soap, val);

	push	edi
	push	esi
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR [ebp+28], eax
	jmp	$LN2@soap_getmi@2
$LN10@soap_getmi@2:

; 11449:       else if (!soap_tag_cmp(key, "Content-Disposition"))

	push	OFFSET ??_C@_0BE@LMOOGHBG@Content?9Disposition?$AA@
	push	ebx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@soap_getmi@2

; 11450:         content->id = soap_strdup(soap, soap_get_header_attribute(soap, val, "name"));

	push	OFFSET ??_C@_04MEMAJGDJ@name?$AA@
	mov	eax, edi
	mov	ecx, esi
	call	_soap_get_header_attribute
	push	eax
	push	esi
	call	_soap_strdup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp+12], eax
	jmp	SHORT $LN2@soap_getmi@2
$LN8@soap_getmi@2:

; 11451:       else if (!soap_tag_cmp(key, "Content-Type"))

	push	OFFSET ??_C@_0N@LAFFMKKA@Content?9Type?$AA@
	push	ebx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@soap_getmi@2

; 11452:         content->type = soap_strdup(soap, val);

	push	edi
	push	esi
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR [ebp+16], eax
	jmp	SHORT $LN2@soap_getmi@2
$LN6@soap_getmi@2:

; 11453:       else if (!soap_tag_cmp(key, "Content-Description"))

	push	OFFSET ??_C@_0BE@CDHADPEM@Content?9Description?$AA@
	push	ebx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@soap_getmi@2

; 11454:         content->description = soap_strdup(soap, val);

	push	edi
	push	esi
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR [ebp+32], eax
	jmp	SHORT $LN2@soap_getmi@2
$LN4@soap_getmi@2:

; 11455:       else if (!soap_tag_cmp(key, "Content-Transfer-Encoding"))

	push	OFFSET ??_C@_0BK@MJFMDPAI@Content?9Transfer?9Encoding?$AA@
	push	ebx
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@soap_getmi@2

; 11456:         content->encoding = (enum soap_mime_encoding)soap_code_int(mime_codes, val, (long)SOAP_MIME_NONE);

	push	eax
	mov	eax, OFFSET _mime_codes
	call	_soap_code_int
	add	esp, 4
	mov	DWORD PTR [ebp+24], eax
$LN2@soap_getmi@2:

; 11457:     }
; 11458:     if (soap_getline(soap, key, sizeof(soap->msgbuf)))

	push	1024					; 00000400H
	push	ebx
	mov	eax, esi
	call	_soap_getline
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN45@soap_getmi@2
	cmp	BYTE PTR [esi+78004], al
	lea	ebx, DWORD PTR [esi+78004]
	jne	$LL20@soap_getmi@2
$LN44@soap_getmi@2:
	pop	edi
	pop	ebp

; 11460:   }
; 11461:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 11462: }

	ret	0
$LN45@soap_getmi@2:

; 11459:       return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	ebp
	pop	ebx

; 11462: }

	ret	0
_soap_getmimehdr ENDP
; Function compile flags: /Ogtpy
_p$ = 8						; size = 4
_n$ = 8							; size = 4
_soap_getdimefield PROC
; _soap$ = eax

; 11211: { register soap_wchar c;

	push	ebx
	mov	ebx, DWORD PTR _n$[esp]
	push	ebp
	push	esi
	push	edi
	mov	esi, eax

; 11212:   register size_t i;
; 11213:   register char *s;
; 11214:   register char *p = NULL;

	mov	DWORD PTR _p$[esp+12], 0

; 11215:   if (n)

	test	ebx, ebx
	je	$LN19@soap_getdi

; 11216:   { p = (char*)soap_malloc(soap, n + 1);

	lea	eax, DWORD PTR [ebx+1]
	mov	edi, esi
	call	_soap_malloc
	mov	DWORD PTR _p$[esp+12], eax

; 11217:     if (p)

	test	eax, eax
	je	$LN7@soap_getdi

; 11218:     { s = p;

	mov	edi, eax

; 11219:       for (i = n; i > 0; i--)

	mov	ebp, ebx
	test	ebx, ebx
	jbe	SHORT $LN4@soap_getdi
	npad	8
$LL6@soap_getdi:

; 11220:       { if ((int)(c = soap_get1(soap)) == EOF)

	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN11@soap_getdi
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN18@soap_getdi
$LN11@soap_getdi:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ecx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
	cmp	ecx, -1
	je	SHORT $LN18@soap_getdi

; 11223:         }
; 11224:         *s++ = (char)c;

	mov	BYTE PTR [edi], cl
	inc	edi
	sub	ebp, 1
	jne	SHORT $LL6@soap_getdi
$LN4@soap_getdi:

; 11225:       }
; 11226:       *s = '\0';
; 11227:       if ((soap->error = soap_move(soap, -(long)n&3)))

	mov	eax, ebx
	neg	eax
	and	eax, 3
	mov	ecx, esi
	mov	BYTE PTR [edi], 0
	call	_soap_move
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	je	SHORT $LN19@soap_getdi
	pop	edi
	pop	esi
	pop	ebp

; 11228:         return NULL;

	xor	eax, eax
	pop	ebx

; 11234: }

	ret	0
$LN18@soap_getdi:
	pop	edi

; 11221:         { soap->error = SOAP_EOF;

	mov	DWORD PTR [esi+90460], -1
	pop	esi
	pop	ebp

; 11222:           return NULL;

	xor	eax, eax
	pop	ebx

; 11234: }

	ret	0
$LN7@soap_getdi:

; 11229:     }
; 11230:     else
; 11231:       soap->error = SOAP_EOM;

	mov	DWORD PTR [esi+90460], 20		; 00000014H
$LN19@soap_getdi:

; 11232:   }
; 11233:   return p;

	mov	eax, DWORD PTR _p$[esp+12]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 11234: }

	ret	0
_soap_getdimefield ENDP
_TEXT	ENDS
PUBLIC	_soap_value
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_soap_value PROC

; 10910: { register size_t i;

	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]

; 10911:   register soap_wchar c = 0;
; 10912:   register char *s = soap->tmpbuf;
; 10913:   if (!soap->body)

	cmp	WORD PTR [ebx+12442], 0
	push	ebp
	lea	ebp, DWORD PTR [ebx+79028]
	push	esi
	mov	esi, ebp
	jne	SHORT $LL16@soap_value
	pop	esi
	pop	ebp

; 10914:     return SOAP_STR_EOS;

	mov	eax, OFFSET _soap_padding
	pop	ebx

; 10936: }

	ret	0
$LL16@soap_value:

; 10915:   do c = soap_get(soap);

	mov	eax, ebx
	call	_soap_get

; 10916:   while (soap_blank(c));

	test	eax, eax
	jl	SHORT $LN13@soap_value
	cmp	eax, 32					; 00000020H
	jle	SHORT $LL16@soap_value
$LN13@soap_value:
	push	edi

; 10917:   for (i = 0; i < sizeof(soap->tmpbuf) - 1; i++)

	xor	edi, edi
$LL12@soap_value:

; 10918:   { if (c == SOAP_TT || (int)c == EOF)

	cmp	eax, -3					; fffffffdH
	je	SHORT $LN36@soap_value
	cmp	eax, -1
	je	SHORT $LN36@soap_value

; 10919:       break;
; 10920:     *s++ = (char)c;

	mov	BYTE PTR [esi], al

; 10921:     c = soap_get(soap);

	mov	eax, ebx
	inc	esi
	call	_soap_get
	inc	edi
	cmp	edi, 1023				; 000003ffH
	jb	SHORT $LL12@soap_value
$LN36@soap_value:

; 10922:   }
; 10923:   for (s--; i > 0; i--, s--)

	dec	esi
	test	edi, edi
	jbe	SHORT $LN24@soap_value
$LL7@soap_value:

; 10924:   { if (!soap_blank(*s))

	mov	cl, BYTE PTR [esi]
	test	cl, cl
	jl	SHORT $LN24@soap_value
	cmp	cl, 32					; 00000020H
	jg	SHORT $LN24@soap_value
	dec	edi
	dec	esi
	test	edi, edi
	ja	SHORT $LL7@soap_value
$LN24@soap_value:

; 10925:       break;
; 10926:   }
; 10927:   s[1] = '\0';

	mov	BYTE PTR [esi+1], 0
	pop	edi

; 10928:   if ((int)c == EOF || c == SOAP_TT)

	cmp	eax, -1
	je	SHORT $LN1@soap_value
	cmp	eax, -3					; fffffffdH
	jne	SHORT $LN2@soap_value
$LN1@soap_value:

; 10929:     soap_unget(soap, c);

	mov	DWORD PTR [ebx+12436], eax
$LN2@soap_value:
	pop	esi

; 10930:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Element content value='%s'\n", soap->tmpbuf));
; 10931: #ifdef WITH_DOM
; 10932:   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 10933:     soap->dom->data = soap_strdup(soap, soap->tmpbuf);
; 10934: #endif
; 10935:   return soap->tmpbuf; /* return non-null pointer */

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 10936: }

	ret	0
_soap_value ENDP
_TEXT	ENDS
PUBLIC	_soap_outwliteral
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_t$ = -4						; size = 4
_p$ = 8							; size = 4
_type$ = 12						; size = 4
_soap_outwliteral PROC
; _soap$ = ecx
; _tag$ = eax

; 10826: { int i;

	push	ecx
	push	ebx
	push	esi
	mov	esi, eax

; 10827:   const char *t = NULL;

	xor	ebx, ebx
	push	edi
	mov	edi, ecx

; 10828:   if (tag && *tag != '-')

	test	esi, esi
	je	$LN6@soap_outwl
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	$LN6@soap_outwl

; 10829:   { if (soap->local_namespaces && (t = strchr(tag, ':')))

	cmp	DWORD PTR [edi+84], ebx
	je	$LN15@soap_outwl
	push	58					; 0000003aH
	push	esi
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _t$[esp+16], eax
	test	eax, eax
	je	$LN15@soap_outwl
	push	ebp

; 10830:     { strncpy(soap->tmpbuf, tag, t-tag);

	mov	ebx, eax
	sub	ebx, esi
	push	ebx
	lea	ebp, DWORD PTR [edi+79028]
	push	esi
	push	ebp
	call	_strncpy

; 10831:       soap->tmpbuf[t-tag] = '\0';

	mov	BYTE PTR [ebx+edi+79028], 0

; 10832:       for (i = 0; soap->local_namespaces[i].id; i++)

	mov	ebx, DWORD PTR [edi+84]
	mov	ecx, DWORD PTR [ebx]
	add	esp, 12					; 0000000cH
	xor	esi, esi
	test	ecx, ecx
	je	SHORT $LN39@soap_outwl
$LL14@soap_outwl:

; 10833:         if (!strcmp(soap->tmpbuf, soap->local_namespaces[i].id))

	mov	eax, ebp
$LL34@soap_outwl:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN35@soap_outwl
	test	dl, dl
	je	SHORT $LN36@soap_outwl
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN35@soap_outwl
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL34@soap_outwl
$LN36@soap_outwl:
	xor	eax, eax
	jmp	SHORT $LN37@soap_outwl
$LN35@soap_outwl:
	sbb	eax, eax
	sbb	eax, -1
$LN37@soap_outwl:
	test	eax, eax
	je	SHORT $LN39@soap_outwl
	inc	esi
	mov	eax, esi
	shl	eax, 4
	mov	ecx, DWORD PTR [eax+ebx]
	test	ecx, ecx
	jne	SHORT $LL14@soap_outwl
$LN39@soap_outwl:

; 10834:           break;
; 10835:       t++;
; 10836:       if (soap_element(soap, t, 0, type)
; 10837:        || soap_attribute(soap, "xmlns", soap->local_namespaces[i].ns ? soap->local_namespaces[i].ns : SOAP_STR_EOS)
; 10838:        || soap_element_start_end_out(soap, NULL))

	mov	ecx, DWORD PTR _type$[esp+16]
	mov	eax, DWORD PTR _t$[esp+20]
	push	ecx
	inc	eax
	push	0
	mov	DWORD PTR _t$[esp+28], eax
	push	eax
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	pop	ebp
	test	eax, eax
	jne	SHORT $LN9@soap_outwl
	mov	edx, DWORD PTR [edi+84]
	shl	esi, 4
	mov	eax, DWORD PTR [esi+edx+4]
	test	eax, eax
	jne	SHORT $LN20@soap_outwl
	mov	eax, OFFSET _soap_padding
$LN20@soap_outwl:
	push	eax
	mov	eax, OFFSET ??_C@_05PPEFOGKI@xmlns?$AA@
	mov	esi, edi
	call	_soap_attribute
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@soap_outwl

; 10840:     }
; 10841:     else
; 10842:     { t = tag;
; 10843:       if (soap_element_begin_out(soap, t, 0, type))

$LN21@soap_outwl:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN23@soap_outwl:

; 10834:           break;
; 10835:       t++;
; 10836:       if (soap_element(soap, t, 0, type)
; 10837:        || soap_attribute(soap, "xmlns", soap->local_namespaces[i].ns ? soap->local_namespaces[i].ns : SOAP_STR_EOS)
; 10838:        || soap_element_start_end_out(soap, NULL))

	test	eax, eax
	je	SHORT $LN40@soap_outwl
$LN9@soap_outwl:

; 10839:         return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 10860: }

	pop	ecx
	ret	0
$LN15@soap_outwl:

; 10840:     }
; 10841:     else
; 10842:     { t = tag;
; 10843:       if (soap_element_begin_out(soap, t, 0, type))

	cmp	BYTE PTR [esi], 45			; 0000002dH
	mov	DWORD PTR _t$[esp+16], esi
	je	SHORT $LN40@soap_outwl
	mov	eax, DWORD PTR _type$[esp+12]
	push	eax
	push	0
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN21@soap_outwl
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN23@soap_outwl
$LN40@soap_outwl:

; 10844:         return soap->error;
; 10845:     }
; 10846:     if (soap_send(soap, soap->tmpbuf))

	lea	ecx, DWORD PTR [edi+79028]
	test	ecx, ecx
	je	SHORT $LN41@soap_outwl
	mov	eax, ecx
	lea	esi, DWORD PTR [eax+1]
$LL38@soap_outwl:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL38@soap_outwl
	sub	eax, esi
	push	eax
	push	ecx
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax

; 10847:       return soap->error;

	jne	SHORT $LN9@soap_outwl
$LN41@soap_outwl:

; 10844:         return soap->error;
; 10845:     }
; 10846:     if (soap_send(soap, soap->tmpbuf))

	mov	ebx, DWORD PTR _t$[esp+16]
$LN6@soap_outwl:

; 10848:   }
; 10849:   if (p)

	mov	eax, DWORD PTR _p$[esp+12]
	test	eax, eax
	je	SHORT $LN33@soap_outwl

; 10850:   { wchar_t c;
; 10851:     const wchar_t *s = *p;

	mov	esi, DWORD PTR [eax]

; 10852:     while ((c = *s++))

	movzx	eax, WORD PTR [esi]
	test	ax, ax
	je	SHORT $LN33@soap_outwl
$LL4@soap_outwl:

; 10853:     { if (soap_pututf8(soap, (unsigned long)c))

	movzx	ecx, ax
	add	esi, 2
	call	_soap_pututf8
	test	eax, eax
	jne	SHORT $LN9@soap_outwl
	movzx	eax, WORD PTR [esi]
	test	ax, ax
	jne	SHORT $LL4@soap_outwl
$LN33@soap_outwl:

; 10854:         return soap->error;
; 10855:     }
; 10856:   }
; 10857:   if (t)

	test	ebx, ebx
	je	SHORT $LN1@soap_outwl

; 10858:     return soap_element_end_out(soap, t);

	mov	esi, ebx
	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebx

; 10860: }

	pop	ecx
	ret	0
$LN1@soap_outwl:
	pop	edi
	pop	esi

; 10859:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 10860: }

	pop	ecx
	ret	0
_soap_outwliteral ENDP
_TEXT	ENDS
PUBLIC	_soap_outliteral
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_t$ = 8							; size = 4
_tag$ = 8						; size = 4
_p$ = 12						; size = 4
_soap_outliteral PROC
; _soap$ = eax

; 10750: { int i;

	push	ebx
	mov	ebx, DWORD PTR _tag$[esp]
	push	esi
	push	edi
	mov	edi, eax

; 10751:   const char *t = NULL;

	mov	DWORD PTR _t$[esp+8], 0

; 10752:   if (tag && *tag != '-')

	test	ebx, ebx
	je	$LN34@soap_outli
	cmp	BYTE PTR [ebx], 45			; 0000002dH
	je	$LN34@soap_outli

; 10753:   { if (soap->local_namespaces && (t = strchr(tag, ':')))

	cmp	DWORD PTR [edi+84], 0
	je	$LN12@soap_outli
	push	58					; 0000003aH
	push	ebx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _t$[esp+8], eax
	test	eax, eax
	je	$LN12@soap_outli
	push	ebp

; 10754:     { strncpy(soap->tmpbuf, tag, t-tag);

	mov	esi, eax
	sub	esi, ebx
	push	esi
	lea	ebp, DWORD PTR [edi+79028]
	push	ebx
	push	ebp
	call	_strncpy

; 10755:       soap->tmpbuf[t-tag] = '\0';

	mov	BYTE PTR [esi+edi+79028], 0

; 10756:       for (i = 0; soap->local_namespaces[i].id; i++)

	mov	ebx, DWORD PTR [edi+84]
	mov	ecx, DWORD PTR [ebx]
	add	esp, 12					; 0000000cH
	xor	esi, esi
	test	ecx, ecx
	je	SHORT $LN33@soap_outli
	npad	4
$LL11@soap_outli:

; 10757:         if (!strcmp(soap->tmpbuf, soap->local_namespaces[i].id))

	mov	eax, ebp
$LL28@soap_outli:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN29@soap_outli
	test	dl, dl
	je	SHORT $LN30@soap_outli
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN29@soap_outli
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL28@soap_outli
$LN30@soap_outli:
	xor	eax, eax
	jmp	SHORT $LN31@soap_outli
$LN29@soap_outli:
	sbb	eax, eax
	sbb	eax, -1
$LN31@soap_outli:
	test	eax, eax
	je	SHORT $LN33@soap_outli
	inc	esi
	mov	eax, esi
	shl	eax, 4
	mov	ecx, DWORD PTR [eax+ebx]
	test	ecx, ecx
	jne	SHORT $LL11@soap_outli
$LN33@soap_outli:

; 10758:           break;
; 10759:       t++;

	mov	eax, DWORD PTR _t$[esp+12]
	inc	eax

; 10760:       if (soap_element(soap, t, 0, type)
; 10761:        || soap_attribute(soap, "xmlns", soap->local_namespaces[i].ns ? soap->local_namespaces[i].ns : SOAP_STR_EOS)
; 10762:        || soap_element_start_end_out(soap, NULL))

	push	0
	push	0
	mov	DWORD PTR _t$[esp+20], eax
	push	eax
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	pop	ebp
	test	eax, eax
	jne	SHORT $LN6@soap_outli
	mov	ecx, DWORD PTR [edi+84]
	shl	esi, 4
	mov	eax, DWORD PTR [esi+ecx+4]
	test	eax, eax
	jne	SHORT $LN17@soap_outli
	mov	eax, OFFSET _soap_padding
$LN17@soap_outli:
	push	eax
	mov	eax, OFFSET ??_C@_05PPEFOGKI@xmlns?$AA@
	mov	esi, edi
	call	_soap_attribute
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@soap_outli

; 10764:     }
; 10765:     else
; 10766:     { t = tag;
; 10767:       if (soap_element_begin_out(soap, t, 0, type))

$LN18@soap_outli:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN20@soap_outli:

; 10760:       if (soap_element(soap, t, 0, type)
; 10761:        || soap_attribute(soap, "xmlns", soap->local_namespaces[i].ns ? soap->local_namespaces[i].ns : SOAP_STR_EOS)
; 10762:        || soap_element_start_end_out(soap, NULL))

	test	eax, eax
	je	SHORT $LN34@soap_outli
$LN6@soap_outli:

; 10763:         return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 10778: }

	ret	0
$LN12@soap_outli:

; 10764:     }
; 10765:     else
; 10766:     { t = tag;
; 10767:       if (soap_element_begin_out(soap, t, 0, type))

	cmp	BYTE PTR [ebx], 45			; 0000002dH
	mov	DWORD PTR _t$[esp+8], ebx
	je	SHORT $LN34@soap_outli
	push	0
	push	0
	push	ebx
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN18@soap_outli
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN20@soap_outli
$LN34@soap_outli:

; 10768:         return soap->error;
; 10769:     }
; 10770:   }
; 10771:   if (p && *p)

	mov	eax, DWORD PTR _p$[esp+8]
	test	eax, eax
	je	SHORT $LN2@soap_outli
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@soap_outli

; 10772:   { if (soap_send(soap, *p))

	mov	eax, ecx
	lea	esi, DWORD PTR [eax+1]
	npad	5
$LL32@soap_outli:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL32@soap_outli
	sub	eax, esi
	push	eax
	push	ecx
	mov	eax, edi
	call	_soap_send_raw
	add	esp, 8
	test	eax, eax

; 10773:       return soap->error;

	jne	SHORT $LN6@soap_outli
$LN2@soap_outli:

; 10774:   }
; 10775:   if (t)

	mov	esi, DWORD PTR _t$[esp+8]
	test	esi, esi
	je	SHORT $LN1@soap_outli

; 10776:     return soap_element_end_out(soap, t);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebx

; 10778: }

	ret	0
$LN1@soap_outli:
	pop	edi
	pop	esi

; 10777:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 10778: }

	ret	0
_soap_outliteral ENDP
_TEXT	ENDS
PUBLIC	_soap_outdateTime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_n$ = 20						; size = 4
_soap_outdateTime PROC
; _tag$ = ecx
; _id$ = eax

; 10650: { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebx
	mov	ebx, DWORD PTR _p$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 10651:    || soap_string_out(soap, soap_dateTime2s(soap, *p), 0))

	push	eax
	mov	eax, DWORD PTR _n$[esp+12]
	mov	esi, ecx
	push	edi
	mov	ecx, ebx
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN9@soap_outda
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_outda
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_outda
$LN5@soap_outda:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_outda:
	test	eax, eax
	jne	SHORT $LN1@soap_outda
$LN9@soap_outda:
	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx]
	push	0
	push	edx
	push	eax
	push	edi
	call	_soap_dateTime2s
	add	esp, 12					; 0000000cH
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_outda

; 10653:   return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebx

; 10654: }

	ret	0
$LN1@soap_outda:

; 10652:     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 10654: }

	ret	0
_soap_outdateTime ENDP
_TEXT	ENDS
PUBLIC	_soap_outULONG64
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_n$ = 20						; size = 4
_soap_outULONG64 PROC
; _tag$ = ecx
; _id$ = eax

; 10076: { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, DWORD PTR _p$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 10077:    || soap_string_out(soap, soap_ULONG642s(soap, *p), 0))

	push	eax
	mov	eax, DWORD PTR _n$[esp+12]
	mov	esi, ecx
	push	edi
	mov	ecx, ebp
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN11@soap_outUL
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_outUL
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_outUL
$LN5@soap_outUL:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_outUL:
	test	eax, eax
	jne	SHORT $LN1@soap_outUL
$LN11@soap_outUL:
	mov	edx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebp]
	push	ebx
	push	edx
	push	eax
	lea	ebx, DWORD PTR [edi+79028]
	push	OFFSET ??_C@_05OINFJHGD@?$CFI64u?$AA@
	push	ebx
	call	_sprintf
	push	0
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 20					; 00000014H
	pop	ebx
	test	eax, eax
	jne	SHORT $LN1@soap_outUL

; 10079:   return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebp

; 10080: }

	ret	0
$LN1@soap_outUL:

; 10078:     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp

; 10080: }

	ret	0
_soap_outULONG64 ENDP
_TEXT	ENDS
PUBLIC	_soap_outunsignedLong
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_n$ = 20						; size = 4
_soap_outunsignedLong PROC
; _tag$ = ecx
; _id$ = eax

; 9993 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, DWORD PTR _p$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 9994 :    || soap_string_out(soap, soap_unsignedLong2s(soap, *p), 0))

	push	eax
	mov	eax, DWORD PTR _n$[esp+12]
	mov	esi, ecx
	push	edi
	mov	ecx, ebp
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN11@soap_outun
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_outun
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_outun
$LN5@soap_outun:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_outun:
	test	eax, eax
	jne	SHORT $LN1@soap_outun
$LN11@soap_outun:
	mov	edx, DWORD PTR [ebp]
	push	ebx
	push	edx
	lea	ebx, DWORD PTR [edi+79028]
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu?$AA@
	push	ebx
	call	_sprintf
	push	0
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 16					; 00000010H
	pop	ebx
	test	eax, eax
	jne	SHORT $LN1@soap_outun

; 9996 :   return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebp

; 9997 : }

	ret	0
$LN1@soap_outun:

; 9995 :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp

; 9997 : }

	ret	0
_soap_outunsignedLong ENDP
_TEXT	ENDS
PUBLIC	_soap_outunsignedInt
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_n$ = 20						; size = 4
_soap_outunsignedInt PROC
; _tag$ = ecx
; _id$ = eax

; 9910 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, DWORD PTR _p$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 9911 :    || soap_string_out(soap, soap_unsignedLong2s(soap, (unsigned long)*p), 0))

	push	eax
	mov	eax, DWORD PTR _n$[esp+12]
	mov	esi, ecx
	push	edi
	mov	ecx, ebp
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN11@soap_outun@2
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_outun@2
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_outun@2
$LN5@soap_outun@2:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_outun@2:
	test	eax, eax
	jne	SHORT $LN1@soap_outun@2
$LN11@soap_outun@2:
	mov	edx, DWORD PTR [ebp]
	push	ebx
	push	edx
	lea	ebx, DWORD PTR [edi+79028]
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu?$AA@
	push	ebx
	call	_sprintf
	push	0
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 16					; 00000010H
	pop	ebx
	test	eax, eax
	jne	SHORT $LN1@soap_outun@2

; 9913 :   return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebp

; 9914 : }

	ret	0
$LN1@soap_outun@2:

; 9912 :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp

; 9914 : }

	ret	0
_soap_outunsignedInt ENDP
_TEXT	ENDS
PUBLIC	_soap_outunsignedShort
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_n$ = 20						; size = 4
_soap_outunsignedShort PROC
; _tag$ = ecx
; _id$ = eax

; 9838 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, DWORD PTR _p$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 9839 :    || soap_string_out(soap, soap_unsignedLong2s(soap, (unsigned long)*p), 0))

	push	eax
	mov	eax, DWORD PTR _n$[esp+12]
	mov	esi, ecx
	push	edi
	mov	ecx, ebp
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN11@soap_outun@3
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_outun@3
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_outun@3
$LN5@soap_outun@3:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_outun@3:
	test	eax, eax
	jne	SHORT $LN1@soap_outun@3
$LN11@soap_outun@3:
	movzx	edx, WORD PTR [ebp]
	push	ebx
	push	edx
	lea	ebx, DWORD PTR [edi+79028]
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu?$AA@
	push	ebx
	call	_sprintf
	push	0
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 16					; 00000010H
	pop	ebx
	test	eax, eax
	jne	SHORT $LN1@soap_outun@3

; 9841 :   return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebp

; 9842 : }

	ret	0
$LN1@soap_outun@3:

; 9840 :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp

; 9842 : }

	ret	0
_soap_outunsignedShort ENDP
_TEXT	ENDS
PUBLIC	_soap_outunsignedByte
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_n$ = 20						; size = 4
_soap_outunsignedByte PROC
; _tag$ = ecx
; _id$ = eax

; 9767 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, DWORD PTR _p$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 9768 :    || soap_string_out(soap, soap_unsignedLong2s(soap, (unsigned long)*p), 0))

	push	eax
	mov	eax, DWORD PTR _n$[esp+12]
	mov	esi, ecx
	push	edi
	mov	ecx, ebp
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN11@soap_outun@4
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_outun@4
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_outun@4
$LN5@soap_outun@4:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_outun@4:
	test	eax, eax
	jne	SHORT $LN1@soap_outun@4
$LN11@soap_outun@4:
	movzx	edx, BYTE PTR [ebp]
	push	ebx
	push	edx
	lea	ebx, DWORD PTR [edi+79028]
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu?$AA@
	push	ebx
	call	_sprintf
	push	0
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 16					; 00000010H
	pop	ebx
	test	eax, eax
	jne	SHORT $LN1@soap_outun@4

; 9770 :   return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebp

; 9771 : }

	ret	0
$LN1@soap_outun@4:

; 9769 :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp

; 9771 : }

	ret	0
_soap_outunsignedByte ENDP
_TEXT	ENDS
PUBLIC	_soap_outdouble
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_n$ = 20						; size = 4
_soap_outdouble PROC
; _tag$ = ecx
; _id$ = eax

; 9676 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebx
	mov	ebx, DWORD PTR _p$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 9677 :    || soap_string_out(soap, soap_double2s(soap, *p), 0))

	push	eax
	mov	eax, DWORD PTR _n$[esp+12]
	mov	esi, ecx
	push	edi
	mov	ecx, ebx
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN9@soap_outdo
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_outdo
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_outdo
$LN5@soap_outdo:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_outdo:
	test	eax, eax
	jne	SHORT $LN1@soap_outdo
$LN9@soap_outdo:
	fld	QWORD PTR [ebx]
	push	0
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_soap_double2s
	add	esp, 8
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_outdo

; 9679 :   return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebx

; 9680 : }

	ret	0
$LN1@soap_outdo:

; 9678 :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 9680 : }

	ret	0
_soap_outdouble ENDP
_TEXT	ENDS
PUBLIC	_soap_outfloat
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_soap_outfloat PROC
; _tag$ = ecx
; _id$ = eax

; 9532 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _p$[esp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+12]

; 9533 :    || soap_string_out(soap, soap_float2s(soap, *p), 0))

	push	eax
	mov	esi, ecx
	push	edi
	mov	eax, 13					; 0000000dH
	mov	ecx, ebx
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN9@soap_outfl
	mov	ecx, DWORD PTR _type$[esp+12]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_outfl
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_outfl
$LN5@soap_outfl:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_outfl:
	test	eax, eax
	jne	SHORT $LN1@soap_outfl
$LN9@soap_outfl:
	fld	DWORD PTR [ebx]
	push	0
	sub	esp, 8
	fstp	DWORD PTR [esp]
	call	_soap_float2s
	add	esp, 8
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_outfl

; 9535 :   return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out

; 9536 : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ecx
	ret	0
$LN1@soap_outfl:

; 9534 :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]

; 9536 : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ecx
	ret	0
_soap_outfloat ENDP
_TEXT	ENDS
PUBLIC	_soap_outshort
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_n$ = 20						; size = 4
_soap_outshort PROC
; _tag$ = ecx
; _id$ = eax

; 9444 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, DWORD PTR _p$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 9445 :    || soap_string_out(soap, soap_long2s(soap, (long)*p), 0))

	push	eax
	mov	eax, DWORD PTR _n$[esp+12]
	mov	esi, ecx
	push	edi
	mov	ecx, ebp
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN11@soap_outsh
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_outsh
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_outsh
$LN5@soap_outsh:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_outsh:
	test	eax, eax
	jne	SHORT $LN1@soap_outsh
$LN11@soap_outsh:
	movsx	edx, WORD PTR [ebp]
	push	ebx
	push	edx
	lea	ebx, DWORD PTR [edi+79028]
	push	OFFSET ??_C@_03JALODAI@?$CFld?$AA@
	push	ebx
	call	_sprintf
	push	0
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 16					; 00000010H
	pop	ebx
	test	eax, eax
	jne	SHORT $LN1@soap_outsh

; 9447 :   return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebp

; 9448 : }

	ret	0
$LN1@soap_outsh:

; 9446 :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp

; 9448 : }

	ret	0
_soap_outshort ENDP
_TEXT	ENDS
PUBLIC	_soap_outbyte
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_soap_outbyte PROC
; _tag$ = ecx
; _id$ = eax

; 9373 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, DWORD PTR _p$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 9374 :    || soap_string_out(soap, soap_long2s(soap, (long)*p), 0))

	push	eax
	mov	esi, ecx
	push	edi
	mov	eax, 3
	mov	ecx, ebp
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN11@soap_outby
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_outby
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_outby
$LN5@soap_outby:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_outby:
	test	eax, eax
	jne	SHORT $LN1@soap_outby
$LN11@soap_outby:
	movsx	edx, BYTE PTR [ebp]
	push	ebx
	push	edx
	lea	ebx, DWORD PTR [edi+79028]
	push	OFFSET ??_C@_03JALODAI@?$CFld?$AA@
	push	ebx
	call	_sprintf
	push	0
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 16					; 00000010H
	pop	ebx
	test	eax, eax
	jne	SHORT $LN1@soap_outby

; 9376 :   return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebp

; 9377 : }

	ret	0
$LN1@soap_outby:

; 9375 :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp

; 9377 : }

	ret	0
_soap_outbyte ENDP
_TEXT	ENDS
PUBLIC	_soap_outLONG64
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_type$ = 16						; size = 4
_soap_outLONG64 PROC
; _id$ = eax
; _p$ = ecx

; 9278 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[ebp]

; 9279 :    || soap_string_out(soap, soap_LONG642s(soap, *p), 0))

	push	eax
	push	edi
	mov	eax, 16					; 00000010H
	mov	esi, ecx
	call	_soap_embedded_id
	mov	ecx, DWORD PTR _tag$[ebp]
	add	esp, 8
	cmp	BYTE PTR [ecx], 45			; 0000002dH
	je	SHORT $LN11@soap_outLO
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	push	eax
	push	ecx
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_outLO
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_outLO
$LN5@soap_outLO:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_outLO:
	test	eax, eax
	jne	SHORT $LN1@soap_outLO
$LN11@soap_outLO:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	lea	ebx, DWORD PTR [edi+79028]
	push	OFFSET ??_C@_05LLAMLEHD@?$CFI64d?$AA@
	push	ebx
	call	_sprintf
	push	0
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN1@soap_outLO

; 9281 :   return soap_element_end_out(soap, tag);

	mov	esi, DWORD PTR _tag$[ebp]
	mov	eax, edi
	call	_soap_element_end_out

; 9282 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@soap_outLO:

; 9280 :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]

; 9282 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_soap_outLONG64 ENDP
_TEXT	ENDS
PUBLIC	_soap_outlong
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_n$ = 20						; size = 4
_soap_outlong PROC
; _tag$ = ecx
; _id$ = eax

; 9195 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, DWORD PTR _p$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 9196 :    || soap_string_out(soap, soap_long2s(soap, *p), 0))

	push	eax
	mov	eax, DWORD PTR _n$[esp+12]
	mov	esi, ecx
	push	edi
	mov	ecx, ebp
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN11@soap_outlo
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_outlo
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_outlo
$LN5@soap_outlo:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_outlo:
	test	eax, eax
	jne	SHORT $LN1@soap_outlo
$LN11@soap_outlo:
	mov	edx, DWORD PTR [ebp]
	push	ebx
	push	edx
	lea	ebx, DWORD PTR [edi+79028]
	push	OFFSET ??_C@_03JALODAI@?$CFld?$AA@
	push	ebx
	call	_sprintf
	push	0
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 16					; 00000010H
	pop	ebx
	test	eax, eax
	jne	SHORT $LN1@soap_outlo

; 9198 :   return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebp

; 9199 : }

	ret	0
$LN1@soap_outlo:

; 9197 :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp

; 9199 : }

	ret	0
_soap_outlong ENDP
_TEXT	ENDS
PUBLIC	_soap_outint
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_soap_outint PROC
; _tag$ = ecx
; _id$ = eax

; 9112 : { if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, p, n), type)

	push	ebp
	mov	ebp, DWORD PTR _p$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _soap$[esp+8]

; 9113 :    || soap_string_out(soap, soap_long2s(soap, (long)*p), 0))

	push	eax
	mov	esi, ecx
	push	edi
	mov	eax, 1
	mov	ecx, ebp
	call	_soap_embedded_id
	add	esp, 8
	cmp	BYTE PTR [esi], 45			; 0000002dH
	je	SHORT $LN11@soap_outin
	mov	ecx, DWORD PTR _type$[esp+8]
	push	ecx
	push	eax
	push	esi
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@soap_outin
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN7@soap_outin
$LN5@soap_outin:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN7@soap_outin:
	test	eax, eax
	jne	SHORT $LN1@soap_outin
$LN11@soap_outin:
	mov	edx, DWORD PTR [ebp]
	push	ebx
	push	edx
	lea	ebx, DWORD PTR [edi+79028]
	push	OFFSET ??_C@_03JALODAI@?$CFld?$AA@
	push	ebx
	call	_sprintf
	push	0
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 16					; 00000010H
	pop	ebx
	test	eax, eax
	jne	SHORT $LN1@soap_outin

; 9115 :   return soap_element_end_out(soap, tag);

	mov	eax, edi
	call	_soap_element_end_out
	pop	edi
	pop	esi
	pop	ebp

; 9116 : }

	ret	0
$LN1@soap_outin:

; 9114 :     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp

; 9116 : }

	ret	0
_soap_outint ENDP
; Function compile flags: /Ogtpy
_n$ = 8						; size = 4
_d$ = 12						; size = 4
_soap_getattrval PROC
; _soap$ = edi
; _s$ = eax

; 7811 : { register size_t i;

	push	ebx
	mov	ebx, DWORD PTR _d$[esp]
	push	ebp

; 7812 :   for (i = 0; i < n; i++)

	xor	ebp, ebp
	push	esi
	mov	esi, eax
	cmp	DWORD PTR _n$[esp+8], ebp
	jbe	SHORT $LN15@soap_getat
$LL17@soap_getat:

; 7813 :   { register soap_wchar c = soap_get(soap);

	mov	eax, edi
	call	_soap_get

; 7814 :     switch (c)

	lea	ecx, DWORD PTR [eax+6]
	cmp	ecx, 53					; 00000035H
	ja	SHORT $LN3@soap_getat
	movzx	ecx, BYTE PTR $LN27@soap_getat[ecx]
	jmp	DWORD PTR $LN29@soap_getat[ecx*4]
$LN12@soap_getat:

; 7815 :     {
; 7816 :     case SOAP_TT:
; 7817 :       *s++ = '<';

	mov	BYTE PTR [esi], 60			; 0000003cH

; 7818 :       soap_unget(soap, '/');

	mov	DWORD PTR [edi+12436], 47		; 0000002fH

; 7819 :       break;

	jmp	SHORT $LN28@soap_getat
$LN11@soap_getat:

; 7820 :     case SOAP_LT:
; 7821 :       *s++ = '<';

	mov	BYTE PTR [esi], 60			; 0000003cH

; 7822 :       break;

	jmp	SHORT $LN28@soap_getat
$LN10@soap_getat:

; 7823 :     case SOAP_GT:
; 7824 :       if (d == ' ')

	cmp	ebx, 32					; 00000020H
	je	SHORT $LN21@soap_getat

; 7828 :       }
; 7829 :       *s++ = '>';

	mov	BYTE PTR [esi], 62			; 0000003eH

; 7830 :       break;

	jmp	SHORT $LN28@soap_getat
$LN8@soap_getat:

; 7831 :     case SOAP_QT:
; 7832 :       if (c == d)

	cmp	eax, ebx
	je	SHORT $LN22@soap_getat

; 7833 :       { *s = '\0';
; 7834 :         return SOAP_OK;
; 7835 :       }
; 7836 :       *s++ = '"';

	mov	BYTE PTR [esi], 34			; 00000022H

; 7837 :       break;

	jmp	SHORT $LN28@soap_getat
$LN6@soap_getat:

; 7838 :     case SOAP_AP:
; 7839 :       if (c == d)

	cmp	eax, ebx
	je	SHORT $LN22@soap_getat

; 7840 :       { *s = '\0';
; 7841 :         return SOAP_OK;
; 7842 :       }
; 7843 :       *s++ = '\'';

	mov	BYTE PTR [esi], 39			; 00000027H

; 7844 :       break;

	jmp	SHORT $LN28@soap_getat
$LN4@soap_getat:

; 7845 :     case '\t':
; 7846 :     case '\n':
; 7847 :     case '\r':
; 7848 :     case ' ':
; 7849 :     case '/':
; 7850 :       if (d == ' ')

	cmp	ebx, 32					; 00000020H
	je	SHORT $LN21@soap_getat
$LN3@soap_getat:

; 7851 :       { soap_unget(soap, c);
; 7852 :         *s = '\0';
; 7853 :         return SOAP_OK;
; 7854 :       }
; 7855 :     default:
; 7856 :       if ((int)c == EOF)

	cmp	eax, -1
	je	SHORT $LN25@soap_getat

; 7858 :       *s++ = (char)c;

	mov	BYTE PTR [esi], al
$LN28@soap_getat:

; 7812 :   for (i = 0; i < n; i++)

	inc	ebp

; 7858 :       *s++ = (char)c;

	inc	esi
	cmp	ebp, DWORD PTR _n$[esp+8]
	jb	SHORT $LL17@soap_getat
$LN15@soap_getat:
	pop	esi

; 7859 :     }
; 7860 :   }
; 7861 :   return soap->error = SOAP_EOM;

	mov	eax, 20					; 00000014H
	pop	ebp
	mov	DWORD PTR [edi+90460], eax
	pop	ebx

; 7862 : }

	ret	0
$LN21@soap_getat:

; 7825 :       { soap_unget(soap, c);

	mov	DWORD PTR [edi+12436], eax
$LN22@soap_getat:

; 7826 :         *s = '\0';

	mov	BYTE PTR [esi], 0
	pop	esi
	pop	ebp

; 7827 :         return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 7862 : }

	ret	0
$LN25@soap_getat:
	pop	esi
	pop	ebp

; 7857 :         return soap->error = SOAP_EOF;

	mov	DWORD PTR [edi+90460], -1
	or	eax, -1
	pop	ebx

; 7862 : }

	ret	0
	npad	3
$LN29@soap_getat:
	DD	$LN6@soap_getat
	DD	$LN8@soap_getat
	DD	$LN10@soap_getat
	DD	$LN12@soap_getat
	DD	$LN11@soap_getat
	DD	$LN4@soap_getat
	DD	$LN3@soap_getat
$LN27@soap_getat:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	5
	DB	6
	DB	6
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
_soap_getattrval ENDP
_TEXT	ENDS
PUBLIC	_soap_element_end_in
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_soap_element_end_in PROC
; _soap$ = esi

; 7602 :   register char *s;
; 7603 :   register int n = 0;
; 7604 :   if (tag && *tag == '-')

	mov	eax, DWORD PTR _tag$[esp-4]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN24@soap_eleme@9
	cmp	BYTE PTR [eax], 45			; 0000002dH
	jne	SHORT $LN24@soap_eleme@9

; 7605 :     return SOAP_OK;

	xor	eax, eax
	pop	edi

; 7662 : }

	ret	0
$LN24@soap_eleme@9:

; 7606 :   if (soap->error == SOAP_NO_TAG)

	cmp	DWORD PTR [esi+90460], 6
	jne	SHORT $LN23@soap_eleme@9

; 7607 :     soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], edi
$LN23@soap_eleme@9:

; 7608 : #ifdef WITH_DOM
; 7609 :   /* this whitespace or mixed content is not insignificant for DOM */
; 7610 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 7611 :   { if (!soap->peeked && !soap_string_in(soap, 3, -1, -1))
; 7612 :       return soap->error;
; 7613 :     if (soap->dom->prnt)
; 7614 :       soap->dom = soap->dom->prnt;
; 7615 :   }
; 7616 : #endif
; 7617 :   if (soap->peeked)

	cmp	WORD PTR [esi+87308], di
	je	SHORT $LL20@soap_eleme@9

; 7618 :   { if (*soap->tag)

	cmp	BYTE PTR [esi+80052], 0
	je	SHORT $LN38@soap_eleme@9

; 7619 :       n++;

	mov	edi, 1
$LN38@soap_eleme@9:

; 7620 :     soap->peeked = 0;

	xor	eax, eax
	mov	WORD PTR [esi+87308], ax
$LL20@soap_eleme@9:

; 7621 :   }
; 7622 :   do
; 7623 :   { while (((c = soap_get(soap)) != SOAP_TT))

	mov	eax, esi
	call	_soap_get
	cmp	eax, -3					; fffffffdH
	je	SHORT $LN19@soap_eleme@9
	npad	1
$LL17@soap_eleme@9:

; 7624 :     { if ((int)c == EOF)

	cmp	eax, -1
	je	SHORT $LN31@soap_eleme@9

; 7626 :       if (c == SOAP_LT)

	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN14@soap_eleme@9

; 7627 :         n++;

	inc	edi
	jmp	SHORT $LN10@soap_eleme@9
$LN14@soap_eleme@9:

; 7628 :       else if (c == '/')

	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN10@soap_eleme@9

; 7629 :       { c = soap_get(soap);

	mov	eax, esi
	call	_soap_get

; 7630 :         if (c == SOAP_GT)

	cmp	eax, -4					; fffffffcH
	jne	SHORT $LN11@soap_eleme@9

; 7631 :           n--;

	dec	edi

; 7632 :         else

	jmp	SHORT $LN10@soap_eleme@9
$LN11@soap_eleme@9:

; 7633 :           soap_unget(soap, c);

	mov	DWORD PTR [esi+12436], eax
$LN10@soap_eleme@9:

; 7621 :   }
; 7622 :   do
; 7623 :   { while (((c = soap_get(soap)) != SOAP_TT))

	mov	eax, esi
	call	_soap_get
	cmp	eax, -3					; fffffffdH
	jne	SHORT $LL17@soap_eleme@9
$LN19@soap_eleme@9:

; 7634 :       }
; 7635 :     }
; 7636 :   } while (n--);

	mov	ecx, edi
	dec	edi
	test	ecx, ecx
	jne	SHORT $LL20@soap_eleme@9
	push	ebx
	push	ebp

; 7637 :   s = soap->tag;

	lea	ebp, DWORD PTR [esi+80052]

; 7638 :   n = sizeof(soap->tag);
; 7639 :   while (soap_notblank(c = soap_get(soap)))

	mov	eax, esi
	mov	edi, ebp
	mov	ebx, 1024				; 00000400H
	call	_soap_get
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN8@soap_eleme@9
$LL9@soap_eleme@9:

; 7640 :   { if (--n > 0)

	dec	ebx
	test	ebx, ebx
	jle	SHORT $LN7@soap_eleme@9

; 7641 :       *s++ = (char)c;

	mov	BYTE PTR [edi], al
	inc	edi
$LN7@soap_eleme@9:
	mov	eax, esi
	call	_soap_get
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL9@soap_eleme@9
$LN8@soap_eleme@9:

; 7642 :   }
; 7643 :   *s = '\0';

	mov	BYTE PTR [edi], 0

; 7644 :   if ((int)c == EOF)

	cmp	eax, -1
	jne	SHORT $LN30@soap_eleme@9
	pop	ebp
	pop	ebx

; 7645 :     return soap->error = SOAP_EOF;

	mov	DWORD PTR [esi+90460], eax
	or	eax, eax
	pop	edi

; 7662 : }

	ret	0
$LN31@soap_eleme@9:

; 7625 :         return soap->error = SOAP_EOF;

	mov	DWORD PTR [esi+90460], -1
	or	eax, -1
	pop	edi

; 7662 : }

	ret	0
$LN30@soap_eleme@9:

; 7646 :   while (soap_blank(c))

	test	eax, eax
	jl	SHORT $LN4@soap_eleme@9
$LL5@soap_eleme@9:
	cmp	eax, 32					; 00000020H
	jg	SHORT $LN4@soap_eleme@9

; 7647 :     c = soap_get(soap);

	mov	eax, esi
	call	_soap_get
	test	eax, eax
	jge	SHORT $LL5@soap_eleme@9
$LN4@soap_eleme@9:

; 7648 :   if (c != SOAP_GT)

	cmp	eax, -4					; fffffffcH

; 7649 :     return soap->error = SOAP_SYNTAX_ERROR;

	jne	SHORT $LN49@soap_eleme@9

; 7650 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End element found (level=%u) '%s'='%s'\n", soap->level, soap->tag, tag?tag:""));
; 7651 : #ifndef WITH_LEAN
; 7652 :   if (tag && (soap->mode & SOAP_XML_STRICT))

	mov	ebx, DWORD PTR _tag$[esp+8]
	test	ebx, ebx
	je	SHORT $LN41@soap_eleme@9
	test	DWORD PTR [esi+8], 4096			; 00001000H
	je	SHORT $LN41@soap_eleme@9

; 7653 :   { soap_pop_namespace(soap);

	mov	edi, esi
	call	_soap_pop_namespace

; 7654 :     if (soap_match_tag(soap, soap->tag, tag))

	push	ebp
	push	esi
	mov	edi, ebx
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN41@soap_eleme@9
$LN49@soap_eleme@9:
	pop	ebp

; 7655 :     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "End element tag name does not match\n"));
; 7656 :       return soap->error = SOAP_SYNTAX_ERROR;

	mov	eax, 5
	pop	ebx
	mov	DWORD PTR [esi+90460], eax
	pop	edi

; 7662 : }

	ret	0
$LN41@soap_eleme@9:

; 7657 :     }
; 7658 :   }
; 7659 : #endif
; 7660 :   soap->level--;

	dec	DWORD PTR [esi+12444]
	pop	ebp
	pop	ebx

; 7661 :   return SOAP_OK;

	xor	eax, eax
	pop	edi

; 7662 : }

	ret	0
_soap_element_end_in ENDP
_TEXT	ENDS
PUBLIC	_soap_element_id
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_pp$81094 = -4						; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_n$ = 20						; size = 4
_type$ = 24						; size = 4
_t$ = 28						; size = 4
_soap_element_id PROC
; _p$ = ecx
; _a$ = eax

; 7457 : { if (!p || (a && !a->__ptr))

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _id$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR _tag$[esp+8]
	push	esi
	mov	esi, DWORD PTR _t$[esp+12]
	push	edi
	mov	edi, DWORD PTR _soap$[esp+16]
	test	ecx, ecx
	je	$LN8@soap_eleme@10
	test	eax, eax
	je	SHORT $LN9@soap_eleme@10
	cmp	DWORD PTR [eax], 0
	je	$LN8@soap_eleme@10
$LN9@soap_eleme@10:

; 7460 :   }
; 7461 : #ifndef WITH_NOIDREF
; 7462 :   if (soap->mode & SOAP_XML_TREE)

	test	DWORD PTR [edi+8], 32768		; 00008000H
	je	SHORT $LN7@soap_eleme@10
$LN29@soap_eleme@10:
	pop	edi
	pop	esi
	pop	ebp

; 7463 :     return 0;

	xor	eax, eax
	pop	ebx

; 7481 : #else
; 7482 :   return 0;
; 7483 : #endif
; 7484 : }

	pop	ecx
	ret	0
$LN7@soap_eleme@10:

; 7464 :   if (id < 0)

	test	ebx, ebx
	jge	SHORT $LN3@soap_eleme@10

; 7465 :   { struct soap_plist *pp;
; 7466 :     if (a)

	test	eax, eax
	je	SHORT $LN5@soap_eleme@10

; 7467 :       id = soap_array_pointer_lookup(soap, p, a, n, t, &pp);

	lea	ecx, DWORD PTR _pp$81094[esp+20]
	push	ecx
	push	esi
	mov	esi, DWORD PTR _n$[esp+24]
	push	eax
	mov	edx, edi
	mov	DWORD PTR _pp$81094[esp+32], 0
	call	_soap_array_pointer_lookup
	add	esp, 12					; 0000000cH

; 7468 :     else

	jmp	SHORT $LN27@soap_eleme@10
$LN5@soap_eleme@10:

; 7469 :       id = soap_pointer_lookup(soap, p, t, &pp);

	lea	edx, DWORD PTR _pp$81094[esp+20]
	call	_soap_pointer_lookup
$LN27@soap_eleme@10:
	mov	ebx, eax

; 7470 :     if (id)

	test	ebx, ebx
	je	SHORT $LN3@soap_eleme@10

; 7471 :     { if (soap_is_embedded(soap, pp))

	mov	esi, DWORD PTR _pp$81094[esp+20]
	mov	ecx, esi
	mov	eax, edi
	call	_soap_is_embedded

; 7472 :       { soap_element_ref(soap, tag, 0, id);

	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN2@soap_eleme@10
	push	ebp
	mov	eax, ebx
	call	_soap_element_ref
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	or	eax, -1
	pop	ebx

; 7481 : #else
; 7482 :   return 0;
; 7483 : #endif
; 7484 : }

	pop	ecx
	ret	0
$LN2@soap_eleme@10:

; 7473 :         return -1;
; 7474 :       }
; 7475 :       if (soap_is_single(soap, pp))

	mov	eax, esi
	call	_soap_is_single
	test	eax, eax

; 7476 :         return 0;

	jne	SHORT $LN29@soap_eleme@10

; 7477 :       soap_set_embedded(soap, pp);

	mov	eax, esi
	mov	ecx, edi
	call	_soap_set_embedded
$LN3@soap_eleme@10:
	pop	edi
	pop	esi
	pop	ebp

; 7478 :     }
; 7479 :   }
; 7480 :   return id;

	mov	eax, ebx
	pop	ebx

; 7481 : #else
; 7482 :   return 0;
; 7483 : #endif
; 7484 : }

	pop	ecx
	ret	0
$LN8@soap_eleme@10:

; 7458 :   { soap_element_null(soap, tag, id, type);

	mov	edx, DWORD PTR _type$[esp+16]
	push	edx
	push	edi
	mov	eax, ebx
	mov	ecx, ebp
	call	_soap_element_null
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 7459 :     return -1;

	or	eax, -1
	pop	ebx

; 7481 : #else
; 7482 :   return 0;
; 7483 : #endif
; 7484 : }

	pop	ecx
	ret	0
_soap_element_id ENDP
_TEXT	ENDS
PUBLIC	_soap_attachment
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_pp$ = -4						; size = 4
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_id$ = 16						; size = 4
_a$ = 20						; size = 4
_aid$ = 24						; size = 4
_atype$ = 28						; size = 4
_aoptions$ = 32						; size = 4
_type$ = 36						; size = 4
_t$ = 40						; size = 4
_soap_attachment PROC
; _p$ = ecx
; _n$ = eax

; 5254 : {

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _t$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+8]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, eax

; 5255 : #ifndef WITH_NOIDREF
; 5256 :   struct soap_plist *pp;
; 5257 :   int i;
; 5258 :   if (!p || !a->__ptr || (!aid && !atype))

	mov	eax, DWORD PTR _a$[esp+16]
	test	edi, edi
	je	$LN21@soap_attac
	cmp	DWORD PTR [eax], 0
	je	$LN21@soap_attac
	cmp	DWORD PTR _aid$[esp+16], 0
	jne	SHORT $LN22@soap_attac
	cmp	DWORD PTR _atype$[esp+16], 0
	je	$LN21@soap_attac
$LN22@soap_attac:

; 5260 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Attachment tag='%s' id='%s' (%d) type='%s'\n", tag, aid?aid:"", id, atype?atype:""));
; 5261 :   i = soap_array_pointer_lookup(soap, p, a, n, t, &pp);

	lea	ecx, DWORD PTR _pp$[esp+20]
	push	ecx
	push	ebx
	push	eax
	mov	edx, ebp
	mov	DWORD PTR _pp$[esp+32], 0
	call	_soap_array_pointer_lookup
	add	esp, 12					; 0000000cH

; 5262 :   if (!i)

	test	eax, eax
	jne	SHORT $LN63@soap_attac

; 5263 :   { i = soap_pointer_enter(soap, p, a, n, t, &pp);

	lea	edx, DWORD PTR _pp$[esp+20]
	push	edx
	push	ebx
	push	edi
	mov	edi, DWORD PTR _a$[esp+28]
	mov	esi, ebp
	call	_soap_pointer_enter
	add	esp, 12					; 0000000cH

; 5264 :     if (!i)

	test	eax, eax
	jne	SHORT $LN19@soap_attac
$LN68@soap_attac:
	pop	edi
	pop	esi

; 5265 :     { soap->error = SOAP_EOM;

	mov	DWORD PTR [ebp+90460], 20		; 00000014H
	pop	ebp

; 5266 :       return -1;

	or	eax, -1
	pop	ebx

; 5321 : }

	pop	ecx
	ret	0
$LN63@soap_attac:

; 5264 :     if (!i)

	mov	edi, DWORD PTR _a$[esp+16]
$LN19@soap_attac:

; 5267 :     }
; 5268 :   }
; 5269 :   if (id <= 0)

	cmp	DWORD PTR _id$[esp+16], 0
	jg	SHORT $LN18@soap_attac

; 5270 :     id = i;

	mov	DWORD PTR _id$[esp+16], eax
$LN18@soap_attac:

; 5271 :   if (!aid)

	mov	ebx, DWORD PTR _aid$[esp+16]
	test	ebx, ebx
	jne	SHORT $LN17@soap_attac

; 5272 :   { sprintf(soap->tmpbuf, soap->dime_id_format, id);

	mov	eax, DWORD PTR _id$[esp+16]
	mov	ecx, DWORD PTR [ebp+28]
	push	eax
	push	ecx
	lea	esi, DWORD PTR [ebp+79028]
	push	esi
	call	_sprintf

; 5273 :     aid = soap_strdup(soap, soap->tmpbuf);

	push	esi
	push	ebp
	call	_soap_strdup
	add	esp, 20					; 00000014H
	mov	DWORD PTR _aid$[esp+16], eax
	mov	ebx, eax
$LN17@soap_attac:

; 5274 :   }
; 5275 :   /* Add MTOM xop:Include element when necessary */
; 5276 :   /* TODO: this code to be obsoleted with new import/xop.h conventions */
; 5277 :   if ((soap->mode & SOAP_ENC_MTOM) && strcmp(tag, "xop:Include"))

	test	DWORD PTR [ebp+8], 512			; 00000200H
	mov	esi, DWORD PTR _tag$[esp+16]
	je	$LN66@soap_attac
	mov	ecx, OFFSET ??_C@_0M@BMFKMGMG@xop?3Include?$AA@
	mov	eax, esi
$LL56@soap_attac:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN57@soap_attac
	test	dl, dl
	je	SHORT $LN58@soap_attac
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN57@soap_attac
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL56@soap_attac
$LN58@soap_attac:
	xor	eax, eax
	jmp	SHORT $LN59@soap_attac
$LN57@soap_attac:
	sbb	eax, eax
	sbb	eax, -1
$LN59@soap_attac:
	test	eax, eax
	je	SHORT $LN66@soap_attac

; 5278 :   { if (soap_element_begin_out(soap, tag, 0, type)
; 5279 :      || soap_element_href(soap, "xop:Include", 0, "href", aid)
; 5280 :      || soap_element_end_out(soap, tag))

	mov	ecx, DWORD PTR _type$[esp+16]
	push	0
	push	ebp
	mov	eax, esi
	call	_soap_element_begin_out
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@soap_attac
	push	eax
	push	eax
	push	OFFSET ??_C@_0M@BMFKMGMG@xop?3Include?$AA@
	mov	eax, ebp
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN41@soap_attac
	push	OFFSET ??_C@_04CMBCJJJD@href?$AA@
	push	OFFSET ??_C@_0M@BMFKMGMG@xop?3Include?$AA@
	mov	eax, ebx
	mov	ecx, ebp
	call	_soap_element_href
	add	esp, 8
	jmp	SHORT $LN43@soap_attac
$LN41@soap_attac:
	mov	eax, DWORD PTR [ebp+90460]
$LN43@soap_attac:
	test	eax, eax
	jne	SHORT $LN14@soap_attac
	mov	eax, ebp
	call	_soap_element_end_out
	test	eax, eax
	je	SHORT $LN12@soap_attac
$LN14@soap_attac:

; 5281 :       return soap->error;

	mov	eax, DWORD PTR [ebp+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 5321 : }

	pop	ecx
	ret	0
$LN66@soap_attac:

; 5282 :   }
; 5283 :   else if (soap_element_href(soap, tag, 0, "href", aid))

	push	0
	push	0
	push	esi
	mov	eax, ebp
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN48@soap_attac
	push	OFFSET ??_C@_04CMBCJJJD@href?$AA@
	push	esi
	mov	eax, ebx
	mov	ecx, ebp
	call	_soap_element_href
	add	esp, 8
	jmp	SHORT $LN50@soap_attac
$LN48@soap_attac:
	mov	eax, DWORD PTR [ebp+90460]
$LN50@soap_attac:
	test	eax, eax
	je	SHORT $LN12@soap_attac

; 5284 :     return soap->error;

	mov	eax, DWORD PTR [ebp+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 5321 : }

	pop	ecx
	ret	0
$LN12@soap_attac:

; 5285 :   if (soap->mode & SOAP_IO_LENGTH)

	mov	eax, DWORD PTR [ebp+8]

; 5286 :   { if (pp->mark1 != 3)

	mov	edx, DWORD PTR _pp$[esp+20]
	test	al, 8
	je	$LN11@soap_attac
	cmp	BYTE PTR [edx+20], 3
	je	$LN1@soap_attac

; 5287 :     { struct soap_multipart *content;
; 5288 :       if (soap->mode & SOAP_ENC_MTOM)
; 5289 :         content = soap_new_multipart(soap, &soap->mime.first, &soap->mime.last, (char*)a->__ptr, a->__size);

	mov	ecx, DWORD PTR [edi]
	test	eax, 512				; 00000200H
	mov	eax, DWORD PTR [edi+4]
	push	eax
	mov	edi, ebp
	push	ecx
	je	SHORT $LN9@soap_attac
	lea	edx, DWORD PTR [ebp+90540]
	lea	esi, DWORD PTR [ebp+90536]

; 5290 :       else

	jmp	SHORT $LN67@soap_attac
$LN9@soap_attac:

; 5291 :         content = soap_new_multipart(soap, &soap->dime.first, &soap->dime.last, (char*)a->__ptr, a->__size);

	lea	edx, DWORD PTR [ebp+90520]
	lea	esi, DWORD PTR [ebp+90516]
$LN67@soap_attac:
	push	edx
	call	_soap_new_multipart
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 5292 :       if (!content)

	test	ebx, ebx

; 5293 :       { soap->error = SOAP_EOM;
; 5294 :         return -1;

	je	$LN68@soap_attac

; 5295 :       }
; 5296 :       if (!strncmp(aid, "cid:", 4)) /* RFC 2111 */

	mov	esi, DWORD PTR _aid$[esp+16]
	push	4
	push	OFFSET ??_C@_04MLBGAAHD@cid?3?$AA@
	push	esi
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@soap_attac

; 5297 :       { if (soap->mode & SOAP_ENC_MTOM)

	test	DWORD PTR [ebp+8], 512			; 00000200H
	je	SHORT $LN5@soap_attac

; 5298 :         { char *s = (char*)soap_malloc(soap, strlen(aid) - 1);

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL60@soap_attac:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL60@soap_attac
	sub	eax, edx
	dec	eax
	mov	edi, ebp
	call	_soap_malloc

; 5299 :           if (s)

	test	eax, eax
	je	SHORT $LN2@soap_attac

; 5300 :           { *s = '<';
; 5301 :             strcpy(s + 1, aid + 4);

	lea	ecx, DWORD PTR [esi+4]
	lea	esi, DWORD PTR [eax+1]
	mov	BYTE PTR [eax], 60			; 0000003cH
	sub	esi, ecx
$LL25@soap_attac:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [esi+ecx], dl
	inc	ecx
	test	dl, dl
	jne	SHORT $LL25@soap_attac

; 5302 :             strcat(s, ">");

	mov	edi, eax
	dec	edi
	npad	3
$LL61@soap_attac:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL61@soap_attac
	mov	cx, WORD PTR ??_C@_01PPODPGHN@?$DO?$AA@
	mov	WORD PTR [edi], cx

; 5303 :             content->id = s;

	mov	DWORD PTR [ebx+12], eax

; 5304 :           }
; 5305 :         }
; 5306 :         else

	jmp	SHORT $LN2@soap_attac
$LN5@soap_attac:

; 5307 :           content->id = aid + 4;

	add	esi, 4
$LN6@soap_attac:

; 5308 :       }
; 5309 :       else
; 5310 :         content->id = aid;

	mov	DWORD PTR [ebx+12], esi
$LN2@soap_attac:

; 5311 :       content->type = atype;
; 5312 :       content->options = aoptions;

	mov	eax, DWORD PTR _aoptions$[esp+16]
	mov	edx, DWORD PTR _atype$[esp+16]

; 5313 :       content->encoding = SOAP_MIME_BINARY;
; 5314 :       pp->mark1 = 3;

	mov	ecx, DWORD PTR _pp$[esp+20]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+20], eax
	mov	DWORD PTR [ebx+16], edx
	mov	DWORD PTR [ebx+24], 3
	pop	ebp
	mov	BYTE PTR [ecx+20], 3

; 5319 : #endif
; 5320 :   return -1;

	or	eax, -1
	pop	ebx

; 5321 : }

	pop	ecx
	ret	0
$LN11@soap_attac:

; 5315 :     }
; 5316 :   }
; 5317 :   else
; 5318 :     pp->mark2 = 3;

	mov	BYTE PTR [edx+21], 3
$LN1@soap_attac:
	pop	edi
	pop	esi
	pop	ebp

; 5319 : #endif
; 5320 :   return -1;

	or	eax, -1
	pop	ebx

; 5321 : }

	pop	ecx
	ret	0
$LN21@soap_attac:

; 5259 :     return soap_element_id(soap, tag, id, p, a, n, type, t);

	mov	ecx, DWORD PTR _type$[esp+16]
	mov	edx, DWORD PTR _id$[esp+16]
	push	ebx
	push	ecx
	mov	ecx, DWORD PTR _tag$[esp+24]
	push	esi
	push	edx
	push	ecx
	push	ebp
	mov	ecx, edi
	call	_soap_element_id
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 5321 : }

	pop	ecx
	ret	0
_soap_attachment ENDP
_TEXT	ENDS
PUBLIC	_soap_getbase64
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_i$79016 = -12						; size = 4
_j$79026 = -8						; size = 4
_k$79017 = -4						; size = 4
_n$ = 8							; size = 4
_soap_getbase64 PROC
; _soap$ = eax

; 1909 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, eax

; 1910 : #ifdef WITH_DOM
; 1911 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 1912 :   { soap->dom->data = soap_string_in(soap, 0, -1, -1);
; 1913 :     return (unsigned char*)soap_base642s(soap, soap->dom->data, NULL, 0, n);
; 1914 :   }
; 1915 : #endif
; 1916 : #ifdef WITH_FAST
; 1917 :   soap->labidx = 0;
; 1918 :   for (;;)
; 1919 :   { register size_t i, k;
; 1920 :     register char *s;
; 1921 :     if (soap_append_lab(soap, NULL, 2))

	push	2
	push	0
	mov	DWORD PTR [esi+12464], 0
	call	_soap_append_lab
	add	esp, 8
	test	eax, eax
	jne	$LN39@soap_getba
	npad	9
$LL27@soap_getba:

; 1923 :     s = soap->labbuf + soap->labidx;

	mov	eax, DWORD PTR [esi+12464]

; 1924 :     k = soap->lablen - soap->labidx;

	mov	ecx, DWORD PTR [esi+12460]
	mov	edi, DWORD PTR [esi+12456]
	add	edi, eax
	mov	ebx, ecx
	sub	ebx, eax

; 1925 :     soap->labidx = 3 * (soap->lablen / 3);

	mov	eax, -1431655765			; aaaaaaabH
	mul	ecx
	shr	edx, 1
	lea	eax, DWORD PTR [edx+edx*2]
	mov	DWORD PTR _k$79017[esp+28], ebx
	mov	DWORD PTR [esi+12464], eax

; 1926 :     if (!s)

	test	edi, edi
	je	$LN39@soap_getba

; 1927 :       return NULL;
; 1928 :     if (k > 2)

	cmp	ebx, 2
	jbe	$LN20@soap_getba

; 1929 :     { for (i = 0; i < k - 2; i += 3)

	lea	eax, DWORD PTR [ebx-2]
	mov	DWORD PTR _i$79016[esp+28], 0
	test	eax, eax
	jbe	SHORT $LN20@soap_getba
	npad	2
$LL42@soap_getba:

; 1930 :       { register unsigned long m = 0;

	xor	ebx, ebx

; 1931 :         register int j = 0;

	mov	DWORD PTR _j$79026[esp+28], ebx
$LL19@soap_getba:

; 1932 :         do
; 1933 :         { register soap_wchar c = soap_get(soap);

	mov	eax, esi
	call	_soap_get
	mov	ebp, eax

; 1934 :           if (c == '=' || c < 0)

	cmp	ebp, 61					; 0000003dH
	je	$LN43@soap_getba
	test	ebp, ebp
	jl	$LN43@soap_getba

; 1957 :           }
; 1958 :           c -= '+';

	sub	ebp, 43					; 0000002bH

; 1959 :           if (c >= 0 && c <= 79)

	cmp	ebp, 79					; 0000004fH
	ja	SHORT $LN5@soap_getba

; 1960 :           { register int b = soap_base64i[c];

	movsx	eax, BYTE PTR _soap_base64i[ebp]

; 1961 :             if (b >= 64)

	cmp	eax, 64					; 00000040H
	jge	SHORT $LN37@soap_getba

; 1964 :             }
; 1965 :             m = (m << 6) + b;

	shl	ebx, 6
	add	ebx, eax

; 1966 :             j++;

	inc	DWORD PTR _j$79026[esp+28]
	jmp	SHORT $LN18@soap_getba
$LN5@soap_getba:

; 1967 :           }
; 1968 :           else if (!soap_blank(c + '+'))

	add	ebp, 43					; 0000002bH
	js	SHORT $LN37@soap_getba
	cmp	ebp, 32					; 00000020H
	jg	SHORT $LN37@soap_getba
$LN18@soap_getba:

; 1969 :           { soap->error = SOAP_TYPE;
; 1970 :             return NULL;
; 1971 :           }
; 1972 :         } while (j < 4);

	cmp	DWORD PTR _j$79026[esp+28], 4
	jl	SHORT $LL19@soap_getba
	mov	eax, DWORD PTR _i$79016[esp+28]

; 1973 :         *s++ = (char)((m >> 16) & 0xFF);

	mov	ecx, ebx
	shr	ecx, 16					; 00000010H
	mov	BYTE PTR [edi], cl
	mov	ecx, DWORD PTR _k$79017[esp+28]
	inc	edi

; 1974 :         *s++ = (char)((m >> 8) & 0xFF);

	mov	edx, ebx
	shr	edx, 8
	mov	BYTE PTR [edi], dl
	inc	edi
	add	eax, 3

; 1975 :         *s++ = (char)(m & 0xFF);

	mov	BYTE PTR [edi], bl
	add	ecx, -2					; fffffffeH
	inc	edi
	mov	DWORD PTR _i$79016[esp+28], eax
	cmp	eax, ecx
	jb	SHORT $LL42@soap_getba
$LN20@soap_getba:

; 1910 : #ifdef WITH_DOM
; 1911 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 1912 :   { soap->dom->data = soap_string_in(soap, 0, -1, -1);
; 1913 :     return (unsigned char*)soap_base642s(soap, soap->dom->data, NULL, 0, n);
; 1914 :   }
; 1915 : #endif
; 1916 : #ifdef WITH_FAST
; 1917 :   soap->labidx = 0;
; 1918 :   for (;;)
; 1919 :   { register size_t i, k;
; 1920 :     register char *s;
; 1921 :     if (soap_append_lab(soap, NULL, 2))

	push	2
	push	0
	call	_soap_append_lab
	add	esp, 8
	test	eax, eax
	je	$LL27@soap_getba
$LN39@soap_getba:
	pop	edi
	pop	esi
	pop	ebp

; 1922 :       return NULL;

	xor	eax, eax
	pop	ebx

; 1976 :       }
; 1977 :     }
; 1978 :   }
; 1979 : #else
; 1980 :   if (soap_new_block(soap))
; 1981 :     return NULL;
; 1982 :   for (;;)
; 1983 :   { register int i;
; 1984 :     register char *s = (char*)soap_push_block(soap, 3 * SOAP_BLKLEN); /* must be multiple of 3 */
; 1985 :     if (!s)
; 1986 :     { soap_end_block(soap);
; 1987 :       return NULL;
; 1988 :     }
; 1989 :     for (i = 0; i < SOAP_BLKLEN; i++)
; 1990 :     { register unsigned long m = 0;
; 1991 :       register int j = 0;
; 1992 :       do
; 1993 :       { register soap_wchar c = soap_get(soap);
; 1994 :         if (c == '=' || c < 0)
; 1995 :         { unsigned char *p;
; 1996 :           i *= 3;
; 1997 :           switch (j)
; 1998 :           { case 2:
; 1999 :               *s++ = (char)((m >> 4) & 0xFF);
; 2000 :               i++;
; 2001 :               break;
; 2002 :             case 3:
; 2003 :               *s++ = (char)((m >> 10) & 0xFF);
; 2004 :               *s++ = (char)((m >> 2) & 0xFF);
; 2005 :               i += 2;
; 2006 :           }
; 2007 :           if (n)
; 2008 :             *n = (int)soap_size_block(soap, i);
; 2009 :           p = (unsigned char*)soap_save_block(soap, NULL, 0);
; 2010 :           if (c >= 0)
; 2011 :           { while ((int)((c = soap_get(soap)) != EOF) && c != SOAP_LT && c != SOAP_TT)
; 2012 :               ;
; 2013 :           }
; 2014 :           soap_unget(soap, c);
; 2015 :           return p;
; 2016 :         }
; 2017 :         c -= '+';
; 2018 :         if (c >= 0 && c <= 79)
; 2019 :         { int b = soap_base64i[c];
; 2020 :           if (b >= 64)
; 2021 :           { soap->error = SOAP_TYPE;
; 2022 :             return NULL;
; 2023 :           }
; 2024 :           m = (m << 6) + b;
; 2025 :           j++;
; 2026 :         }
; 2027 :         else if (!soap_blank(c))
; 2028 :         { soap->error = SOAP_TYPE;
; 2029 :           return NULL;
; 2030 :         }
; 2031 :       } while (j < 4);
; 2032 :       *s++ = (char)((m >> 16) & 0xFF);
; 2033 :       *s++ = (char)((m >> 8) & 0xFF);
; 2034 :       *s++ = (char)(m & 0xFF);
; 2035 :     }
; 2036 :   }
; 2037 : #endif
; 2038 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN37@soap_getba:
	pop	edi

; 1962 :             { soap->error = SOAP_TYPE;

	mov	DWORD PTR [esi+90460], 4
	pop	esi
	pop	ebp

; 1963 :               return NULL;

	xor	eax, eax
	pop	ebx

; 1976 :       }
; 1977 :     }
; 1978 :   }
; 1979 : #else
; 1980 :   if (soap_new_block(soap))
; 1981 :     return NULL;
; 1982 :   for (;;)
; 1983 :   { register int i;
; 1984 :     register char *s = (char*)soap_push_block(soap, 3 * SOAP_BLKLEN); /* must be multiple of 3 */
; 1985 :     if (!s)
; 1986 :     { soap_end_block(soap);
; 1987 :       return NULL;
; 1988 :     }
; 1989 :     for (i = 0; i < SOAP_BLKLEN; i++)
; 1990 :     { register unsigned long m = 0;
; 1991 :       register int j = 0;
; 1992 :       do
; 1993 :       { register soap_wchar c = soap_get(soap);
; 1994 :         if (c == '=' || c < 0)
; 1995 :         { unsigned char *p;
; 1996 :           i *= 3;
; 1997 :           switch (j)
; 1998 :           { case 2:
; 1999 :               *s++ = (char)((m >> 4) & 0xFF);
; 2000 :               i++;
; 2001 :               break;
; 2002 :             case 3:
; 2003 :               *s++ = (char)((m >> 10) & 0xFF);
; 2004 :               *s++ = (char)((m >> 2) & 0xFF);
; 2005 :               i += 2;
; 2006 :           }
; 2007 :           if (n)
; 2008 :             *n = (int)soap_size_block(soap, i);
; 2009 :           p = (unsigned char*)soap_save_block(soap, NULL, 0);
; 2010 :           if (c >= 0)
; 2011 :           { while ((int)((c = soap_get(soap)) != EOF) && c != SOAP_LT && c != SOAP_TT)
; 2012 :               ;
; 2013 :           }
; 2014 :           soap_unget(soap, c);
; 2015 :           return p;
; 2016 :         }
; 2017 :         c -= '+';
; 2018 :         if (c >= 0 && c <= 79)
; 2019 :         { int b = soap_base64i[c];
; 2020 :           if (b >= 64)
; 2021 :           { soap->error = SOAP_TYPE;
; 2022 :             return NULL;
; 2023 :           }
; 2024 :           m = (m << 6) + b;
; 2025 :           j++;
; 2026 :         }
; 2027 :         else if (!soap_blank(c))
; 2028 :         { soap->error = SOAP_TYPE;
; 2029 :           return NULL;
; 2030 :         }
; 2031 :       } while (j < 4);
; 2032 :       *s++ = (char)((m >> 16) & 0xFF);
; 2033 :       *s++ = (char)((m >> 8) & 0xFF);
; 2034 :       *s++ = (char)(m & 0xFF);
; 2035 :     }
; 2036 :   }
; 2037 : #endif
; 2038 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN43@soap_getba:

; 1935 :           { unsigned char *p;
; 1936 :             switch (j)

	mov	eax, DWORD PTR _j$79026[esp+28]
	sub	eax, 2
	je	SHORT $LN12@soap_getba
	sub	eax, 1
	jne	SHORT $LN44@soap_getba

; 1940 :                 break;
; 1941 :               case 3:
; 1942 :                 *s++ = (char)((m >> 10) & 0xFF);

	mov	eax, ebx
	shr	eax, 10					; 0000000aH

; 1943 :                 *s++ = (char)((m >> 2) & 0xFF);

	shr	ebx, 2
	mov	BYTE PTR [edi], al
	mov	BYTE PTR [edi+1], bl

; 1944 :                 i += 2;

	mov	ebx, DWORD PTR _i$79016[esp+28]
	add	ebx, 2
	jmp	SHORT $LN13@soap_getba
$LN12@soap_getba:

; 1937 :             { case 2:
; 1938 :                 *s++ = (char)((m >> 4) & 0xFF);

	shr	ebx, 4

; 1939 :                 i++;

	inc	DWORD PTR _i$79016[esp+28]
	mov	BYTE PTR [edi], bl
$LN44@soap_getba:
	mov	ebx, DWORD PTR _i$79016[esp+28]
$LN13@soap_getba:

; 1945 :             }
; 1946 :             if (n)

	mov	eax, DWORD PTR _n$[esp+24]
	test	eax, eax
	je	SHORT $LN45@soap_getba

; 1947 :               *n = (int)(soap->lablen + i - k);

	mov	ecx, ebx
	sub	ecx, DWORD PTR _k$79017[esp+28]
	add	ecx, DWORD PTR [esi+12460]
	mov	DWORD PTR [eax], ecx
$LN45@soap_getba:

; 1948 :             p = (unsigned char*)soap_malloc(soap, soap->lablen + i - k);

	mov	eax, ebx
	sub	eax, DWORD PTR _k$79017[esp+28]
	mov	edi, esi
	add	eax, DWORD PTR [esi+12460]
	call	_soap_malloc
	mov	edi, eax

; 1949 :             if (p)

	test	edi, edi
	je	SHORT $LN9@soap_getba

; 1950 :               memcpy(p, soap->labbuf, soap->lablen + i - k);

	sub	ebx, DWORD PTR _k$79017[esp+28]
	mov	edx, DWORD PTR [esi+12456]
	add	ebx, DWORD PTR [esi+12460]
	push	ebx
	push	edx
	push	edi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN9@soap_getba:

; 1951 :             if (c >= 0)

	test	ebp, ebp
	jl	SHORT $LN6@soap_getba
	npad	6
$LL7@soap_getba:

; 1952 :             { while ((int)((c = soap_get(soap)) != EOF) && c != SOAP_LT && c != SOAP_TT)

	mov	eax, esi
	call	_soap_get
	mov	ebp, eax
	cmp	ebp, -1
	je	SHORT $LN6@soap_getba
	cmp	ebp, -2					; fffffffeH
	je	SHORT $LN6@soap_getba
	cmp	ebp, -3					; fffffffdH
	jne	SHORT $LL7@soap_getba
$LN6@soap_getba:

; 1953 :                 ;
; 1954 :             }
; 1955 :             soap_unget(soap, c);
; 1956 :             return p;

	mov	eax, edi
	pop	edi
	mov	DWORD PTR [esi+12436], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 1976 :       }
; 1977 :     }
; 1978 :   }
; 1979 : #else
; 1980 :   if (soap_new_block(soap))
; 1981 :     return NULL;
; 1982 :   for (;;)
; 1983 :   { register int i;
; 1984 :     register char *s = (char*)soap_push_block(soap, 3 * SOAP_BLKLEN); /* must be multiple of 3 */
; 1985 :     if (!s)
; 1986 :     { soap_end_block(soap);
; 1987 :       return NULL;
; 1988 :     }
; 1989 :     for (i = 0; i < SOAP_BLKLEN; i++)
; 1990 :     { register unsigned long m = 0;
; 1991 :       register int j = 0;
; 1992 :       do
; 1993 :       { register soap_wchar c = soap_get(soap);
; 1994 :         if (c == '=' || c < 0)
; 1995 :         { unsigned char *p;
; 1996 :           i *= 3;
; 1997 :           switch (j)
; 1998 :           { case 2:
; 1999 :               *s++ = (char)((m >> 4) & 0xFF);
; 2000 :               i++;
; 2001 :               break;
; 2002 :             case 3:
; 2003 :               *s++ = (char)((m >> 10) & 0xFF);
; 2004 :               *s++ = (char)((m >> 2) & 0xFF);
; 2005 :               i += 2;
; 2006 :           }
; 2007 :           if (n)
; 2008 :             *n = (int)soap_size_block(soap, i);
; 2009 :           p = (unsigned char*)soap_save_block(soap, NULL, 0);
; 2010 :           if (c >= 0)
; 2011 :           { while ((int)((c = soap_get(soap)) != EOF) && c != SOAP_LT && c != SOAP_TT)
; 2012 :               ;
; 2013 :           }
; 2014 :           soap_unget(soap, c);
; 2015 :           return p;
; 2016 :         }
; 2017 :         c -= '+';
; 2018 :         if (c >= 0 && c <= 79)
; 2019 :         { int b = soap_base64i[c];
; 2020 :           if (b >= 64)
; 2021 :           { soap->error = SOAP_TYPE;
; 2022 :             return NULL;
; 2023 :           }
; 2024 :           m = (m << 6) + b;
; 2025 :           j++;
; 2026 :         }
; 2027 :         else if (!soap_blank(c))
; 2028 :         { soap->error = SOAP_TYPE;
; 2029 :           return NULL;
; 2030 :         }
; 2031 :       } while (j < 4);
; 2032 :       *s++ = (char)((m >> 16) & 0xFF);
; 2033 :       *s++ = (char)((m >> 8) & 0xFF);
; 2034 :       *s++ = (char)(m & 0xFF);
; 2035 :     }
; 2036 :   }
; 2037 : #endif
; 2038 : }

	add	esp, 12					; 0000000cH
	ret	0
_soap_getbase64 ENDP
_TEXT	ENDS
PUBLIC	_soap_gethex
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_k$78959 = -4						; size = 4
_n$ = 8							; size = 4
_soap_gethex PROC
; _soap$ = eax

; 1776 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, eax

; 1777 : #ifdef WITH_DOM
; 1778 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 1779 :   { soap->dom->data = soap_string_in(soap, 0, -1, -1);
; 1780 :     return (unsigned char*)soap_hex2s(soap, soap->dom->data, NULL, 0, n);
; 1781 :   }
; 1782 : #endif
; 1783 : #ifdef WITH_FAST
; 1784 :   soap->labidx = 0;
; 1785 :   for (;;)
; 1786 :   { register char *s;
; 1787 :     register size_t i, k;
; 1788 :     if (soap_append_lab(soap, NULL, 0))

	push	0
	push	0
	mov	DWORD PTR [esi+12464], 0
	call	_soap_append_lab
	add	esp, 8
	test	eax, eax
	jne	$LN36@soap_gethe
	npad	11
$LL12@soap_gethe:

; 1790 :     s = soap->labbuf + soap->labidx;

	mov	eax, DWORD PTR [esi+12464]

; 1791 :     k = soap->lablen - soap->labidx;

	mov	ecx, DWORD PTR [esi+12460]
	mov	edi, DWORD PTR [esi+12456]
	mov	ebx, ecx
	add	edi, eax
	sub	ebx, eax
	mov	DWORD PTR _k$78959[esp+20], ebx

; 1792 :     soap->labidx = soap->lablen;

	mov	DWORD PTR [esi+12464], ecx

; 1793 :     for (i = 0; i < k; i++)

	mov	ebp, 0
	je	$LN7@soap_gethe
	jmp	SHORT $LN9@soap_gethe
	npad	1
$LL41@soap_gethe:
	mov	ebx, DWORD PTR _k$78959[esp+20]
$LN9@soap_gethe:

; 1794 :     { register char d1, d2;
; 1795 :       register soap_wchar c;
; 1796 :       c = soap_get(soap);

	mov	eax, esi
	call	_soap_get

; 1797 :       if (soap_isxdigit(c))

	cmp	eax, 48					; 00000030H
	jl	SHORT $LN21@soap_gethe
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN40@soap_gethe
$LN21@soap_gethe:
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN22@soap_gethe
	cmp	eax, 70					; 00000046H
	jle	SHORT $LN40@soap_gethe
$LN22@soap_gethe:
	lea	ecx, DWORD PTR [eax-97]
	cmp	ecx, 5
	ja	$LN6@soap_gethe
$LN40@soap_gethe:

; 1798 :       { d1 = (char)c;

	mov	bl, al

; 1799 :         c = soap_get(soap);

	mov	eax, esi
	call	_soap_get

; 1800 :         if (soap_isxdigit(c))

	cmp	eax, 48					; 00000030H
	jl	SHORT $LN28@soap_gethe
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN30@soap_gethe
$LN28@soap_gethe:
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN29@soap_gethe
	cmp	eax, 70					; 00000046H
	jle	SHORT $LN30@soap_gethe
$LN29@soap_gethe:
	lea	edx, DWORD PTR [eax-97]
	cmp	edx, 5
	ja	SHORT $LN5@soap_gethe
$LN30@soap_gethe:

; 1816 :       }
; 1817 :       *s++ = ((d1 >= 'A' ? (d1 & 0x7) + 9 : d1 - '0') << 4) + (d2 >= 'A' ? (d2 & 0x7) + 9 : d2 - '0');

	cmp	bl, 65					; 00000041H
	movsx	ecx, bl
	jl	SHORT $LN15@soap_gethe
	and	ecx, 7
	add	ecx, 9
	jmp	SHORT $LN16@soap_gethe
$LN15@soap_gethe:
	sub	ecx, 48					; 00000030H
$LN16@soap_gethe:
	cmp	al, 65					; 00000041H
	movsx	eax, al
	jl	SHORT $LN17@soap_gethe
	and	eax, 7
	add	eax, 9
	jmp	SHORT $LN18@soap_gethe
$LN17@soap_gethe:
	sub	eax, 48					; 00000030H
$LN18@soap_gethe:
	shl	cl, 4
	add	cl, al
	mov	BYTE PTR [edi], cl
	inc	ebp
	inc	edi
	cmp	ebp, DWORD PTR _k$78959[esp+20]
	jb	$LL41@soap_gethe
$LN7@soap_gethe:

; 1777 : #ifdef WITH_DOM
; 1778 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 1779 :   { soap->dom->data = soap_string_in(soap, 0, -1, -1);
; 1780 :     return (unsigned char*)soap_hex2s(soap, soap->dom->data, NULL, 0, n);
; 1781 :   }
; 1782 : #endif
; 1783 : #ifdef WITH_FAST
; 1784 :   soap->labidx = 0;
; 1785 :   for (;;)
; 1786 :   { register char *s;
; 1787 :     register size_t i, k;
; 1788 :     if (soap_append_lab(soap, NULL, 0))

	push	0
	push	0
	call	_soap_append_lab
	add	esp, 8
	test	eax, eax
	je	$LL12@soap_gethe
$LN36@soap_gethe:
	pop	edi
	pop	esi
	pop	ebp

; 1789 :       return NULL;

	xor	eax, eax
	pop	ebx

; 1818 :     }
; 1819 :   }
; 1820 : #else
; 1821 :   if (soap_new_block(soap))
; 1822 :     return NULL;
; 1823 :   for (;;)
; 1824 :   { register int i;
; 1825 :     register char *s = (char*)soap_push_block(soap, SOAP_BLKLEN);
; 1826 :     if (!s)
; 1827 :     { soap_end_block(soap);
; 1828 :       return NULL;
; 1829 :     }
; 1830 :     for (i = 0; i < SOAP_BLKLEN; i++)
; 1831 :     { register char d1, d2;
; 1832 :       register soap_wchar c = soap_get(soap);
; 1833 :       if (soap_isxdigit(c))
; 1834 :       { d1 = (char)c;
; 1835 :         c = soap_get(soap);
; 1836 :         if (soap_isxdigit(c))
; 1837 :           d2 = (char)c;
; 1838 :         else
; 1839 :         { soap_end_block(soap);
; 1840 :           soap->error = SOAP_TYPE;
; 1841 :           return NULL;
; 1842 :         }
; 1843 :       }
; 1844 :       else
; 1845 :       { unsigned char *p;
; 1846 :         soap_unget(soap, c);
; 1847 :         if (n)
; 1848 :           *n = (int)soap_size_block(soap, i);
; 1849 :         p = (unsigned char*)soap_save_block(soap, NULL, 0);
; 1850 :         return p;
; 1851 :       }
; 1852 :       *s++ = ((d1 >= 'A' ? (d1 & 0x7) + 9 : d1 - '0') << 4) + (d2 >= 'A' ? (d2 & 0x7) + 9 : d2 - '0');
; 1853 :     }
; 1854 :   }
; 1855 : #endif
; 1856 : }

	pop	ecx
	ret	0
$LN5@soap_gethe:
	pop	edi

; 1801 :           d2 = (char)c;
; 1802 :         else
; 1803 :         { soap->error = SOAP_TYPE;

	mov	DWORD PTR [esi+90460], 4
	pop	esi
	pop	ebp

; 1804 :           return NULL;

	xor	eax, eax
	pop	ebx

; 1818 :     }
; 1819 :   }
; 1820 : #else
; 1821 :   if (soap_new_block(soap))
; 1822 :     return NULL;
; 1823 :   for (;;)
; 1824 :   { register int i;
; 1825 :     register char *s = (char*)soap_push_block(soap, SOAP_BLKLEN);
; 1826 :     if (!s)
; 1827 :     { soap_end_block(soap);
; 1828 :       return NULL;
; 1829 :     }
; 1830 :     for (i = 0; i < SOAP_BLKLEN; i++)
; 1831 :     { register char d1, d2;
; 1832 :       register soap_wchar c = soap_get(soap);
; 1833 :       if (soap_isxdigit(c))
; 1834 :       { d1 = (char)c;
; 1835 :         c = soap_get(soap);
; 1836 :         if (soap_isxdigit(c))
; 1837 :           d2 = (char)c;
; 1838 :         else
; 1839 :         { soap_end_block(soap);
; 1840 :           soap->error = SOAP_TYPE;
; 1841 :           return NULL;
; 1842 :         }
; 1843 :       }
; 1844 :       else
; 1845 :       { unsigned char *p;
; 1846 :         soap_unget(soap, c);
; 1847 :         if (n)
; 1848 :           *n = (int)soap_size_block(soap, i);
; 1849 :         p = (unsigned char*)soap_save_block(soap, NULL, 0);
; 1850 :         return p;
; 1851 :       }
; 1852 :       *s++ = ((d1 >= 'A' ? (d1 & 0x7) + 9 : d1 - '0') << 4) + (d2 >= 'A' ? (d2 & 0x7) + 9 : d2 - '0');
; 1853 :     }
; 1854 :   }
; 1855 : #endif
; 1856 : }

	pop	ecx
	ret	0
$LN6@soap_gethe:

; 1805 :         }
; 1806 :       }
; 1807 :       else
; 1808 :       { unsigned char *p;
; 1809 :         soap_unget(soap, c);

	mov	DWORD PTR [esi+12436], eax

; 1810 :         if (n)

	mov	eax, DWORD PTR _n$[esp+16]
	test	eax, eax
	je	SHORT $LN2@soap_gethe

; 1811 :           *n = (int)(soap->lablen + i - k);

	mov	ecx, ebp
	sub	ecx, ebx
	add	ecx, DWORD PTR [esi+12460]
	mov	DWORD PTR [eax], ecx
$LN2@soap_gethe:

; 1812 :         p = (unsigned char*)soap_malloc(soap, soap->lablen + i - k);

	mov	eax, ebp
	sub	eax, ebx
	add	eax, DWORD PTR [esi+12460]
	mov	edi, esi
	call	_soap_malloc
	mov	edi, eax

; 1813 :         if (p)

	test	edi, edi
	je	SHORT $LN1@soap_gethe

; 1814 :           memcpy(p, soap->labbuf, soap->lablen + i - k);

	mov	edx, DWORD PTR [esi+12456]
	sub	ebp, ebx
	add	ebp, DWORD PTR [esi+12460]
	push	ebp
	push	edx
	push	edi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@soap_gethe:

; 1815 :         return p;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1818 :     }
; 1819 :   }
; 1820 : #else
; 1821 :   if (soap_new_block(soap))
; 1822 :     return NULL;
; 1823 :   for (;;)
; 1824 :   { register int i;
; 1825 :     register char *s = (char*)soap_push_block(soap, SOAP_BLKLEN);
; 1826 :     if (!s)
; 1827 :     { soap_end_block(soap);
; 1828 :       return NULL;
; 1829 :     }
; 1830 :     for (i = 0; i < SOAP_BLKLEN; i++)
; 1831 :     { register char d1, d2;
; 1832 :       register soap_wchar c = soap_get(soap);
; 1833 :       if (soap_isxdigit(c))
; 1834 :       { d1 = (char)c;
; 1835 :         c = soap_get(soap);
; 1836 :         if (soap_isxdigit(c))
; 1837 :           d2 = (char)c;
; 1838 :         else
; 1839 :         { soap_end_block(soap);
; 1840 :           soap->error = SOAP_TYPE;
; 1841 :           return NULL;
; 1842 :         }
; 1843 :       }
; 1844 :       else
; 1845 :       { unsigned char *p;
; 1846 :         soap_unget(soap, c);
; 1847 :         if (n)
; 1848 :           *n = (int)soap_size_block(soap, i);
; 1849 :         p = (unsigned char*)soap_save_block(soap, NULL, 0);
; 1850 :         return p;
; 1851 :       }
; 1852 :       *s++ = ((d1 >= 'A' ? (d1 & 0x7) + 9 : d1 - '0') << 4) + (d2 >= 'A' ? (d2 & 0x7) + 9 : d2 - '0');
; 1853 :     }
; 1854 :   }
; 1855 : #endif
; 1856 : }

	pop	ecx
	ret	0
_soap_gethex ENDP
_TEXT	ENDS
PUBLIC	_soap_getutf8
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_c3$ = -8						; size = 4
_c4$ = -4						; size = 4
_soap_getutf8 PROC
; _soap$ = eax

; 1710 : { register soap_wchar c, c1, c2, c3, c4;

	sub	esp, 8
	push	esi
	mov	esi, eax

; 1711 :   c = soap->ahead;

	mov	eax, DWORD PTR [esi+12436]

; 1712 :   if (c > 0xFF)

	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN32@soap_getut

; 1713 :   { soap->ahead = 0;

	mov	DWORD PTR [esi+12436], 0
	pop	esi

; 1740 : }

	add	esp, 8
	ret	0
$LN32@soap_getut:
	push	ebx
	push	ebp
	push	edi
$again$78913:

; 1714 :     return c;
; 1715 :   }
; 1716 : again:
; 1717 :   c = soap_get(soap);

	mov	eax, esi
	call	_soap_get
	mov	edi, eax

; 1718 :   if (c < 0x80 || (soap->mode & SOAP_ENC_LATIN))

	cmp	edi, 128				; 00000080H
	jl	$LN33@soap_getut
	test	BYTE PTR [esi+8], 32			; 00000020H
	jne	$LN33@soap_getut

; 1719 :     return c;
; 1720 :   c1 = soap_get1(soap);

	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN12@soap_getut
	call	_soap_recv
	test	eax, eax
	jne	$LN24@soap_getut
$LN12@soap_getut:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ebp, BYTE PTR [eax+esi+12468]
	inc	eax

; 1721 :   if (c1 < 0x80)

	cmp	ebp, 128				; 00000080H
	mov	DWORD PTR [esi+12428], eax
	jl	SHORT $LN24@soap_getut

; 1724 :   }
; 1725 :   c1 &= 0x3F;

	and	ebp, 63					; 0000003fH

; 1726 :   if (c < 0xE0)

	cmp	edi, 224				; 000000e0H
	jl	SHORT $LN25@soap_getut

; 1728 :   c2 = (soap_wchar)soap_get1(soap) & 0x3F;

	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN14@soap_getut
	call	_soap_recv
	test	eax, eax
	je	SHORT $LN14@soap_getut
	or	eax, -1
	jmp	SHORT $LN15@soap_getut
$LN14@soap_getut:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx
$LN15@soap_getut:
	and	eax, 63					; 0000003fH
	mov	ebx, eax

; 1729 :   if (c == 0xEF && c1 == 0x3B && c2 == 0x3F)	/* ignore UTF-8 BOM */

	cmp	edi, 239				; 000000efH
	jne	SHORT $LN4@soap_getut
	cmp	ebp, 59					; 0000003bH
	jne	SHORT $LN26@soap_getut
	cmp	ebx, 63					; 0000003fH
	je	$again$78913

; 1732 :     return ((soap_wchar)(c & 0x0F) << 12) | (c1 << 6) | c2;

	mov	eax, edi
	and	eax, 15					; 0000000fH
	shl	eax, 6
	or	eax, ebp
	pop	edi
	shl	eax, 6
	pop	ebp
	or	eax, ebx
	pop	ebx
	pop	esi

; 1740 : }

	add	esp, 8
	ret	0
$LN24@soap_getut:

; 1722 :   { soap_revget1(soap); /* doesn't look like this is UTF8 */

	dec	DWORD PTR [esi+12428]

; 1723 :     return c;

	mov	eax, edi
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 1740 : }

	add	esp, 8
	ret	0
$LN25@soap_getut:

; 1727 :     return ((soap_wchar)(c & 0x1F) << 6) | c1;

	mov	eax, edi
	and	eax, 31					; 0000001fH
	pop	edi
	shl	eax, 6
	or	eax, ebp
	pop	ebp
	pop	ebx
	pop	esi

; 1740 : }

	add	esp, 8
	ret	0
$LN4@soap_getut:

; 1730 :     goto again;
; 1731 :   if (c < 0xF0)

	cmp	edi, 240				; 000000f0H
	jge	SHORT $LN3@soap_getut
$LN26@soap_getut:

; 1732 :     return ((soap_wchar)(c & 0x0F) << 12) | (c1 << 6) | c2;

	mov	eax, edi
	and	eax, 15					; 0000000fH
	shl	eax, 6
	or	eax, ebp
	pop	edi
	shl	eax, 6
	pop	ebp
	or	eax, ebx
	pop	ebx
	pop	esi

; 1740 : }

	add	esp, 8
	ret	0
$LN3@soap_getut:

; 1733 :   c3 = (soap_wchar)soap_get1(soap) & 0x3F;

	mov	ecx, DWORD PTR [esi+12428]
	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN16@soap_getut
	call	_soap_recv
	test	eax, eax
	je	SHORT $LN16@soap_getut
	or	eax, -1
	jmp	SHORT $LN17@soap_getut
$LN16@soap_getut:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx
$LN17@soap_getut:
	and	eax, 63					; 0000003fH

; 1734 :   if (c < 0xF8)

	cmp	edi, 248				; 000000f8H
	mov	ecx, eax
	mov	DWORD PTR _c3$[esp+24], ecx
	jge	SHORT $LN2@soap_getut

; 1735 :     return ((soap_wchar)(c & 0x07) << 18) | (c1 << 12) | (c2 << 6) | c3;

	mov	eax, edi
	and	eax, 7
	shl	eax, 6
	or	eax, ebp
	shl	eax, 6
	pop	edi
	or	eax, ebx
	pop	ebp

; 1739 :   return ((soap_wchar)(c & 0x01) << 30) | (c1 << 24) | (c2 << 18) | (c3 << 12) | (c4 << 6) | (soap_wchar)(soap_get1(soap) & 0x3F);

	shl	eax, 6
	pop	ebx
	or	eax, ecx
	pop	esi

; 1740 : }

	add	esp, 8
	ret	0
$LN2@soap_getut:

; 1736 :   c4 = (soap_wchar)soap_get1(soap) & 0x3F;

	mov	edx, DWORD PTR [esi+12428]
	cmp	edx, DWORD PTR [esi+12432]
	jb	SHORT $LN30@soap_getut
	call	_soap_recv
	test	eax, eax
	je	SHORT $LN30@soap_getut
	or	eax, -1
	jmp	SHORT $LN19@soap_getut
$LN30@soap_getut:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	inc	ecx
	mov	DWORD PTR [esi+12428], ecx
$LN19@soap_getut:
	and	eax, 63					; 0000003fH

; 1737 :   if (c < 0xFC)

	cmp	edi, 252				; 000000fcH
	mov	ecx, eax
	mov	DWORD PTR _c4$[esp+24], ecx
	jge	SHORT $LN1@soap_getut

; 1738 :     return ((soap_wchar)(c & 0x03) << 24) | (c1 << 18) | (c2 << 12) | (c3 << 6) | c4;

	mov	eax, edi
	and	eax, 3
	shl	eax, 6
	or	eax, ebp
	shl	eax, 6
	or	eax, ebx
	shl	eax, 6
	or	eax, DWORD PTR _c3$[esp+24]
	pop	edi
	pop	ebp

; 1739 :   return ((soap_wchar)(c & 0x01) << 30) | (c1 << 24) | (c2 << 18) | (c3 << 12) | (c4 << 6) | (soap_wchar)(soap_get1(soap) & 0x3F);

	shl	eax, 6
	pop	ebx
	or	eax, ecx
	pop	esi

; 1740 : }

	add	esp, 8
	ret	0
$LN1@soap_getut:

; 1739 :   return ((soap_wchar)(c & 0x01) << 30) | (c1 << 24) | (c2 << 18) | (c3 << 12) | (c4 << 6) | (soap_wchar)(soap_get1(soap) & 0x3F);

	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN31@soap_getut
	call	_soap_recv
	test	eax, eax
	je	SHORT $LN31@soap_getut
	or	ecx, -1
	jmp	SHORT $LN21@soap_getut
$LN31@soap_getut:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ecx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
$LN21@soap_getut:
	mov	eax, edi
	and	eax, 1
	shl	eax, 6
	or	eax, ebp
	shl	eax, 6
	or	eax, ebx
	shl	eax, 6
	or	eax, DWORD PTR _c3$[esp+24]
	and	ecx, 63					; 0000003fH
	shl	eax, 6
	or	eax, DWORD PTR _c4$[esp+24]
	shl	eax, 6
	or	eax, ecx
$LN33@soap_getut:
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 1740 : }

	add	esp, 8
	ret	0
_soap_getutf8 ENDP
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_faultcode$ = 8						; size = 4
_faultsubcodeQName$ = 12				; size = 4
_faultstring$ = 16					; size = 4
_faultdetailXML$ = 20					; size = 4
_soap_set_error PROC
; _soap$ = esi
; _soaperror$ = edi

; 14582: { *soap_faultcode(soap) = faultcode;

	push	ebx
	mov	ebx, DWORD PTR _faultsubcodeQName$[esp]
	push	ebp
	mov	ebp, DWORD PTR _faultdetailXML$[esp+4]
	mov	eax, esi
	call	_soap_fault
	cmp	WORD PTR [esi+6], 2
	mov	eax, DWORD PTR [esi+12208]
	jne	SHORT $LN7@soap_set_e@3
	mov	eax, DWORD PTR [eax+16]
$LN7@soap_set_e@3:
	mov	ecx, DWORD PTR _faultcode$[esp+4]
	mov	DWORD PTR [eax], ecx

; 14583:   if (faultsubcodeQName)

	test	ebx, ebx
	je	SHORT $LN3@soap_set_e@3

; 14584:     *soap_faultsubcode(soap) = faultsubcodeQName;

	mov	eax, esi
	call	_soap_faultsubcode
	mov	DWORD PTR [eax], ebx
$LN3@soap_set_e@3:

; 14585:   *soap_faultstring(soap) = faultstring;

	mov	eax, esi
	call	_soap_fault
	cmp	WORD PTR [esi+6], 2
	jne	SHORT $LN9@soap_set_e@3
	mov	edx, DWORD PTR [esi+12208]
	mov	eax, DWORD PTR [edx+20]
	jmp	SHORT $LN10@soap_set_e@3
$LN9@soap_set_e@3:
	mov	eax, DWORD PTR [esi+12208]
	add	eax, 4
$LN10@soap_set_e@3:
	mov	ecx, DWORD PTR _faultstring$[esp+4]
	mov	DWORD PTR [eax], ecx

; 14586:   if (faultdetailXML && *faultdetailXML)

	test	ebp, ebp
	je	SHORT $LN14@soap_set_e@3
	cmp	BYTE PTR [ebp], 0
	je	SHORT $LN14@soap_set_e@3

; 14587:   { register const char **s = soap_faultdetail(soap);

	mov	eax, esi
	call	_soap_faultdetail

; 14588:     if (s)

	test	eax, eax
	je	SHORT $LN14@soap_set_e@3

; 14589:       *s = faultdetailXML;

	mov	DWORD PTR [eax], ebp
$LN14@soap_set_e@3:
	pop	ebp

; 14590:   }
; 14591:   return soap->error = soaperror;

	mov	eax, edi
	mov	DWORD PTR [esi+90460], edi
	pop	ebx

; 14592: }

	ret	0
_soap_set_error ENDP
_TEXT	ENDS
PUBLIC	_soap_set_fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_set_fault PROC
; _soap$ = eax

; 14188: { const char **c = soap_faultcode(soap);

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, eax
	call	_soap_fault
	mov	ebp, 2
	cmp	WORD PTR [esi+6], bp
	jne	SHORT $LN65@soap_set_f@2
	mov	eax, DWORD PTR [esi+12208]
	mov	edi, DWORD PTR [eax+16]
	jmp	SHORT $LN66@soap_set_f@2
$LN65@soap_set_f@2:
	mov	edi, DWORD PTR [esi+12208]
$LN66@soap_set_f@2:

; 14189:   const char **s = soap_faultstring(soap);

	mov	eax, esi
	call	_soap_fault
	cmp	WORD PTR [esi+6], bp
	jne	SHORT $LN68@soap_set_f@2
	mov	ecx, DWORD PTR [esi+12208]
	mov	ebx, DWORD PTR [ecx+20]
	jmp	SHORT $LN69@soap_set_f@2
$LN68@soap_set_f@2:
	mov	ebx, DWORD PTR [esi+12208]
	add	ebx, 4
$LN69@soap_set_f@2:

; 14190:   if (soap->fseterror)

	mov	eax, DWORD PTR [esi+12320]
	test	eax, eax
	je	SHORT $LN60@soap_set_f@2

; 14191:     soap->fseterror(soap, c, s);

	push	ebx
	push	edi
	push	esi
	call	eax
	add	esp, 12					; 0000000cH
$LN60@soap_set_f@2:

; 14192:   if (!*c)

	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN57@soap_set_f@2

; 14193:   { if (soap->version == 2)

	cmp	WORD PTR [esi+6], bp
	jne	SHORT $LN58@soap_set_f@2

; 14194:       *c = "SOAP-ENV:Sender";

	mov	DWORD PTR [edi], OFFSET ??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@

; 14195:     else

	jmp	SHORT $LN57@soap_set_f@2
$LN58@soap_set_f@2:

; 14196:       *c = "SOAP-ENV:Client";

	mov	DWORD PTR [edi], OFFSET ??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@
$LN57@soap_set_f@2:

; 14197:   }
; 14198:   if (*s)

	cmp	DWORD PTR [ebx], 0
	jne	$LN1@soap_set_f@2

; 14199:     return;
; 14200:   switch (soap->error)

	mov	ecx, DWORD PTR [esi+90460]
	mov	eax, ecx
	cmp	eax, 1000				; 000003e8H
	jg	$LN64@soap_set_f@2
	je	$LN6@soap_set_f@2
	inc	eax
	cmp	eax, 47					; 0000002fH
	ja	$LN64@soap_set_f@2
	jmp	DWORD PTR $LN130@soap_set_f@2[eax*4]
$LN53@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14201:   {
; 14202: #ifndef WITH_LEAN
; 14203:     case SOAP_CLI_FAULT:
; 14204:       *s = "Client fault";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0N@JOEFJCHK@Client?5fault?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN52@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14205:       break;
; 14206:     case SOAP_SVR_FAULT:
; 14207:       *s = "Server fault";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0N@LCJPOAAP@Server?5fault?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN51@soap_set_f@2:

; 14208:       break;
; 14209:     case SOAP_TAG_MISMATCH:
; 14210:       *s = soap_set_validation_fault(soap, "tag name or namespace mismatch", NULL);

	lea	eax, DWORD PTR [esi+80052]
	add	esi, 78004				; 000130b4H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN72@soap_set_f@2
	push	eax
	push	OFFSET _soap_padding
	push	OFFSET ??_C@_0BP@EDHHHBAK@tag?5name?5or?5namespace?5mismatch?$AA@
	push	OFFSET ??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 20					; 00000014H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0

; 14208:       break;
; 14209:     case SOAP_TAG_MISMATCH:
; 14210:       *s = soap_set_validation_fault(soap, "tag name or namespace mismatch", NULL);

$LN72@soap_set_f@2:
	push	OFFSET _soap_padding
	push	OFFSET ??_C@_0BP@EDHHHBAK@tag?5name?5or?5namespace?5mismatch?$AA@
	push	OFFSET ??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 16					; 00000010H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN50@soap_set_f@2:

; 14211:       break;
; 14212:     case SOAP_TYPE:
; 14213:       *s = soap_set_validation_fault(soap, "data type mismatch ", soap->type);

	lea	edx, DWORD PTR [esi+83124]
	mov	edi, OFFSET ??_C@_0BE@GBNPKFOD@data?5type?5mismatch?5?$AA@
	mov	ecx, esi
	call	_soap_set_validation_fault
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ebx], eax
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN49@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14214:       break;
; 14215:     case SOAP_SYNTAX_ERROR:
; 14216:       *s = "Well-formedness violation";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0BK@BDHDOCNN@Well?9formedness?5violation?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN48@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14217:       break;
; 14218:     case SOAP_NO_TAG:
; 14219:       *s = "No XML element tag";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0BD@HDMBMFLH@No?5XML?5element?5tag?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN47@soap_set_f@2:

; 14220:       break;
; 14221:     case SOAP_MUSTUNDERSTAND:
; 14222:       *c = "SOAP-ENV:MustUnderstand";

	mov	DWORD PTR [edi], OFFSET ??_C@_0BI@MFGAEHIJ@SOAP?9ENV?3MustUnderstand?$AA@

; 14223:       sprintf(soap->msgbuf, "The data in element '%s' must be understood but cannot be handled", soap->tag);

	lea	edi, DWORD PTR [esi+78004]
	add	esi, 80052				; 000138b4H
	push	esi
	push	OFFSET ??_C@_0EC@DIEDGBJC@The?5data?5in?5element?5?8?$CFs?8?5must?5be@
	push	edi
	call	_sprintf
	add	esp, 12					; 0000000cH

; 14224:       *s = soap->msgbuf;

	mov	DWORD PTR [ebx], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN46@soap_set_f@2:

; 14225:       break;
; 14226:     case SOAP_VERSIONMISMATCH:
; 14227:       *c = "SOAP-ENV:VersionMismatch";

	mov	DWORD PTR [edi], OFFSET ??_C@_0BJ@OACCBMEJ@SOAP?9ENV?3VersionMismatch?$AA@
	pop	edi
	pop	esi
	pop	ebp

; 14228:       *s = "Invalid SOAP message or SOAP version mismatch";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0CO@JCAMFCDG@Invalid?5SOAP?5message?5or?5SOAP?5ver@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN45@soap_set_f@2:

; 14229:       break;
; 14230:     case SOAP_DATAENCODINGUNKNOWN:
; 14231:       *c = "SOAP-ENV:DataEncodingUnknown";

	mov	DWORD PTR [edi], OFFSET ??_C@_0BN@OABEEJDM@SOAP?9ENV?3DataEncodingUnknown?$AA@
	pop	edi
	pop	esi
	pop	ebp

; 14232:       *s = "Unsupported SOAP data encoding";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0BP@NKHANBGK@Unsupported?5SOAP?5data?5encoding?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN44@soap_set_f@2:

; 14233:       break;
; 14234:     case SOAP_NAMESPACE:
; 14235:       *s = soap_set_validation_fault(soap, "namespace error", NULL);

	lea	eax, DWORD PTR [esi+80052]
	add	esi, 78004				; 000130b4H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN80@soap_set_f@2
	push	eax
	push	OFFSET _soap_padding
	push	OFFSET ??_C@_0BA@DMKNFBBB@namespace?5error?$AA@
	push	OFFSET ??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 20					; 00000014H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0

; 14233:       break;
; 14234:     case SOAP_NAMESPACE:
; 14235:       *s = soap_set_validation_fault(soap, "namespace error", NULL);

$LN80@soap_set_f@2:
	push	OFFSET _soap_padding
	push	OFFSET ??_C@_0BA@DMKNFBBB@namespace?5error?$AA@
	push	OFFSET ??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 16					; 00000010H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN43@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14236:       break;
; 14237:     case SOAP_USER_ERROR:
; 14238:       *s = "User error";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0L@PDEMLIEM@User?5error?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN42@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14239:       break;
; 14240:     case SOAP_FATAL_ERROR:
; 14241:       *s = "Fatal error";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0M@HCPCIMCN@Fatal?5error?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN41@soap_set_f@2:

; 14242:       break;
; 14243:     case SOAP_NO_METHOD:
; 14244:       sprintf(soap->msgbuf, "Method '%s' not implemented: method name or namespace not recognized", soap->tag);

	lea	edi, DWORD PTR [esi+78004]
	add	esi, 80052				; 000138b4H
	push	esi
	push	OFFSET ??_C@_0EF@HBJFOFK@Method?5?8?$CFs?8?5not?5implemented?3?5met@
	push	edi
	call	_sprintf
	add	esp, 12					; 0000000cH

; 14245:       *s = soap->msgbuf;

	mov	DWORD PTR [ebx], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN40@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14246:       break;
; 14247:     case SOAP_NO_DATA:
; 14248:       *s = "Data required for operation";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0BM@MENEPEMK@Data?5required?5for?5operation?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN39@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14249:       break;
; 14250:     case SOAP_GET_METHOD:
; 14251:       *s = "HTTP GET method not implemented";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0CA@BHFEEBKL@HTTP?5GET?5method?5not?5implemented?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN38@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14252:       break;
; 14253:     case SOAP_PUT_METHOD:
; 14254:       *s = "HTTP PUT method not implemented";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0CA@DBKHPHAA@HTTP?5PUT?5method?5not?5implemented?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN37@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14255:       break;
; 14256:     case SOAP_HEAD_METHOD:
; 14257:       *s = "HTTP HEAD method not implemented";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0CB@GICAEFAM@HTTP?5HEAD?5method?5not?5implemented@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN36@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14258:       break;
; 14259:     case SOAP_HTTP_METHOD:
; 14260:       *s = "HTTP method not implemented";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0BM@KGAMDCLK@HTTP?5method?5not?5implemented?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN35@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14261:       break;
; 14262:     case SOAP_EOM:
; 14263:       *s = "Out of memory";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0O@NALGGDJF@Out?5of?5memory?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN34@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14264:       break;
; 14265:     case SOAP_MOE:
; 14266:       *s = "Memory overflow or memory corruption error";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0CL@HFBNDNPH@Memory?5overflow?5or?5memory?5corrup@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN33@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14267:       break;
; 14268:     case SOAP_HDR:
; 14269:       *s = "Header line too long";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0BF@GFHEHPAM@Header?5line?5too?5long?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN32@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14270:       break;
; 14271:     case SOAP_IOB:
; 14272:       *s = "Array index out of bounds";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0BK@IJNJOFHI@Array?5index?5out?5of?5bounds?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN31@soap_set_f@2:

; 14273:       break;
; 14274:     case SOAP_NULL:
; 14275:       *s = soap_set_validation_fault(soap, "nil not allowed", NULL);

	lea	eax, DWORD PTR [esi+80052]
	add	esi, 78004				; 000130b4H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN88@soap_set_f@2
	push	eax
	push	OFFSET _soap_padding
	push	OFFSET ??_C@_0BA@NJOHCEBG@nil?5not?5allowed?$AA@
	push	OFFSET ??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 20					; 00000014H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0

; 14273:       break;
; 14274:     case SOAP_NULL:
; 14275:       *s = soap_set_validation_fault(soap, "nil not allowed", NULL);

$LN88@soap_set_f@2:
	push	OFFSET _soap_padding
	push	OFFSET ??_C@_0BA@NJOHCEBG@nil?5not?5allowed?$AA@
	push	OFFSET ??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 16					; 00000010H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN30@soap_set_f@2:

; 14276:       break;
; 14277:     case SOAP_DUPLICATE_ID:
; 14278:       *s = soap_set_validation_fault(soap, "multiple definitions of id ", soap->id);

	lea	edx, DWORD PTR [esi+81076]
	mov	edi, OFFSET ??_C@_0BM@BCCCPBMJ@multiple?5definitions?5of?5id?5?$AA@
	mov	ecx, esi
	call	_soap_set_validation_fault
	mov	DWORD PTR [ebx], eax

; 14279:       if (soap->version == 2)

	cmp	WORD PTR [esi+6], bp
	jne	$LN1@soap_set_f@2

; 14280:         *soap_faultsubcode(soap) = "SOAP-ENC:DuplicateID";

	mov	eax, esi
	call	_soap_faultsubcode
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], OFFSET ??_C@_0BF@NPKHDOOL@SOAP?9ENC?3DuplicateID?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN28@soap_set_f@2:

; 14281:       break;
; 14282:     case SOAP_MISSING_ID:
; 14283:       *s = soap_set_validation_fault(soap, "missing id for ref ", soap->id);

	lea	edx, DWORD PTR [esi+81076]
	mov	edi, OFFSET ??_C@_0BE@MPBPOAHN@missing?5id?5for?5ref?5?$AA@
	mov	ecx, esi
	call	_soap_set_validation_fault
	mov	DWORD PTR [ebx], eax

; 14284:       if (soap->version == 2)

	cmp	WORD PTR [esi+6], bp
	jne	$LN1@soap_set_f@2

; 14285:         *soap_faultsubcode(soap) = "SOAP-ENC:MissingID";

	mov	eax, esi
	call	_soap_faultsubcode
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], OFFSET ??_C@_0BD@NNKPGICN@SOAP?9ENC?3MissingID?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN26@soap_set_f@2:

; 14286:       break;
; 14287:     case SOAP_HREF:
; 14288:       *s = soap_set_validation_fault(soap, "incompatible object type ref/id pair ", soap->id);

	lea	edx, DWORD PTR [esi+81076]
	mov	edi, OFFSET ??_C@_0CG@KLBPBEIF@incompatible?5object?5type?5ref?1id?5@
	mov	ecx, esi
	call	_soap_set_validation_fault
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ebx], eax
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN24@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14289:       break;
; 14290:     case SOAP_FAULT:
; 14291:       break;
; 14292: #ifndef WITH_NOIO
; 14293:     case SOAP_UDP_ERROR:
; 14294:       *s = "Message too large for UDP packet";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0CB@LLFCFDEP@Message?5too?5large?5for?5UDP?5packet@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN23@soap_set_f@2:

; 14295:       break;
; 14296:     case SOAP_TCP_ERROR:
; 14297:       *s = tcp_error(soap);

	mov	eax, esi
	call	_tcp_error
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ebx], eax
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN22@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14298:       break;
; 14299: #endif
; 14300:     case SOAP_HTTP_ERROR:
; 14301:       *s = "An HTTP processing error occurred";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0CC@KGMKOPGF@An?5HTTP?5processing?5error?5occurre@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN21@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14302:       break;
; 14303:     case SOAP_SSL_ERROR:
; 14304: #ifdef WITH_OPENSSL
; 14305:       *s = "SSL error";
; 14306: #else
; 14307:       *s = "OpenSSL not installed: recompile with -DWITH_OPENSSL";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0DF@GLMBMACG@OpenSSL?5not?5installed?3?5recompile@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN20@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14308: #endif
; 14309:       break;
; 14310:     case SOAP_PLUGIN_ERROR:
; 14311:       *s = "Plugin registry error";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0BG@IBFEEHMP@Plugin?5registry?5error?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN19@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14312:       break;
; 14313:     case SOAP_DIME_ERROR:
; 14314:       *s = "DIME format error";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0BC@JILKAMFB@DIME?5format?5error?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN18@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14315:       break;
; 14316:     case SOAP_DIME_HREF:
; 14317:       *s = "DIME href to missing attachment";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0CA@OHINPGEO@DIME?5href?5to?5missing?5attachment?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN17@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14318:       break;
; 14319:     case SOAP_DIME_MISMATCH:
; 14320:       *s = "DIME version/transmission error";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0CA@FOKLPDEJ@DIME?5version?1transmission?5error?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN16@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14321:       break;
; 14322:     case SOAP_DIME_END:
; 14323:       *s = "End of DIME error";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0BC@DMDFBBON@End?5of?5DIME?5error?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN15@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14324:       break;
; 14325:     case SOAP_MIME_ERROR:
; 14326:       *s = "MIME format error";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0BC@GALJBELM@MIME?5format?5error?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN14@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14327:       break;
; 14328:     case SOAP_MIME_HREF:
; 14329:       *s = "MIME href to missing attachment";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0CA@PFEDMHLA@MIME?5href?5to?5missing?5attachment?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN13@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14330:       break;
; 14331:     case SOAP_MIME_END:
; 14332:       *s = "End of MIME error";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0BC@EHHICPGI@End?5of?5MIME?5error?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN12@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14333:       break;
; 14334:     case SOAP_ZLIB_ERROR:
; 14335: #ifdef WITH_ZLIB
; 14336:       sprintf(soap->msgbuf, "Zlib/gzip error: '%s'", soap->d_stream->msg?soap->d_stream->msg:"");
; 14337:       *s = soap->msgbuf;
; 14338: #else
; 14339:       *s = "Zlib/gzip not installed for (de)compression: recompile with -DWITH_GZIP";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0EI@DMDOKJJA@Zlib?1gzip?5not?5installed?5for?5?$CIde?$CJ@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN11@soap_set_f@2:

; 14340: #endif
; 14341:       break;
; 14342:     case SOAP_REQUIRED:
; 14343:       *s = soap_set_validation_fault(soap, "missing required attribute", NULL);

	lea	eax, DWORD PTR [esi+80052]
	add	esi, 78004				; 000130b4H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN96@soap_set_f@2
	push	eax
	push	OFFSET _soap_padding
	push	OFFSET ??_C@_0BL@IAKLNEOE@missing?5required?5attribute?$AA@
	push	OFFSET ??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 20					; 00000014H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0

; 14340: #endif
; 14341:       break;
; 14342:     case SOAP_REQUIRED:
; 14343:       *s = soap_set_validation_fault(soap, "missing required attribute", NULL);

$LN96@soap_set_f@2:
	push	OFFSET _soap_padding
	push	OFFSET ??_C@_0BL@IAKLNEOE@missing?5required?5attribute?$AA@
	push	OFFSET ??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 16					; 00000010H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN10@soap_set_f@2:

; 14344:       break;
; 14345:     case SOAP_PROHIBITED:
; 14346:       *s = soap_set_validation_fault(soap, "prohibited attribute present", NULL);

	lea	eax, DWORD PTR [esi+80052]
	add	esi, 78004				; 000130b4H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN104@soap_set_f@2
	push	eax
	push	OFFSET _soap_padding
	push	OFFSET ??_C@_0BN@FOFAKJF@prohibited?5attribute?5present?$AA@
	push	OFFSET ??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 20					; 00000014H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0

; 14344:       break;
; 14345:     case SOAP_PROHIBITED:
; 14346:       *s = soap_set_validation_fault(soap, "prohibited attribute present", NULL);

$LN104@soap_set_f@2:
	push	OFFSET _soap_padding
	push	OFFSET ??_C@_0BN@FOFAKJF@prohibited?5attribute?5present?$AA@
	push	OFFSET ??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 16					; 00000010H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN9@soap_set_f@2:

; 14347:       break;
; 14348:     case SOAP_OCCURS:
; 14349:       *s = soap_set_validation_fault(soap, "occurrence violation", NULL);

	lea	eax, DWORD PTR [esi+80052]
	add	esi, 78004				; 000130b4H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN112@soap_set_f@2
	push	eax
	push	OFFSET _soap_padding
	push	OFFSET ??_C@_0BF@NAKMPMCF@occurrence?5violation?$AA@
	push	OFFSET ??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 20					; 00000014H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0

; 14347:       break;
; 14348:     case SOAP_OCCURS:
; 14349:       *s = soap_set_validation_fault(soap, "occurrence violation", NULL);

$LN112@soap_set_f@2:
	push	OFFSET _soap_padding
	push	OFFSET ??_C@_0BF@NAKMPMCF@occurrence?5violation?$AA@
	push	OFFSET ??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 16					; 00000010H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN8@soap_set_f@2:

; 14350:       break;
; 14351:     case SOAP_LENGTH:
; 14352:       *s = soap_set_validation_fault(soap, "content length violation", NULL);

	lea	eax, DWORD PTR [esi+80052]
	add	esi, 78004				; 000130b4H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN120@soap_set_f@2
	push	eax
	push	OFFSET _soap_padding
	push	OFFSET ??_C@_0BJ@BEFALLEK@content?5length?5violation?$AA@
	push	OFFSET ??_C@_0DG@HKJBMIKH@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 20					; 00000014H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0

; 14350:       break;
; 14351:     case SOAP_LENGTH:
; 14352:       *s = soap_set_validation_fault(soap, "content length violation", NULL);

$LN120@soap_set_f@2:
	push	OFFSET _soap_padding
	push	OFFSET ??_C@_0BJ@BEFALLEK@content?5length?5violation?$AA@
	push	OFFSET ??_C@_0CG@LEBAOEFP@Validation?5constraint?5violation?3@
	push	esi
	call	_sprintf
	add	esp, 16					; 00000010H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN7@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14353:       break;
; 14354:     case SOAP_FD_EXCEEDED:
; 14355:       *s = "Maximum number of open connections was reached";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0CP@LKNNNLAG@Maximum?5number?5of?5open?5connectio@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN5@soap_set_f@2:

; 14359:       break;
; 14360: #endif
; 14361:     case SOAP_EOF:
; 14362: #ifndef WITH_NOIO
; 14363:       strcpy(soap->msgbuf, soap_strerror(soap));

	mov	eax, esi
	call	_soap_strerror
	lea	edi, DWORD PTR [esi+78004]
	mov	edx, edi
$LL63@soap_set_f@2:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	inc	eax
	inc	edx
	test	cl, cl
	jne	SHORT $LL63@soap_set_f@2

; 14364: #ifndef WITH_LEAN
; 14365:       if (strlen(soap->msgbuf) + 25 < sizeof(soap->msgbuf))

	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
$LL128@soap_set_f@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL128@soap_set_f@2
	sub	eax, edx
	add	eax, 25					; 00000019H
	cmp	eax, 1024				; 00000400H
	jae	SHORT $LN4@soap_set_f@2

; 14366:       { memmove(soap->msgbuf + 25, soap->msgbuf, strlen(soap->msgbuf) + 1);

	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL129@soap_set_f@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL129@soap_set_f@2
	sub	eax, edx
	inc	eax
	push	eax
	push	edi
	add	esi, 78029				; 000130cdH
	push	esi
	call	_memmove

; 14367:         memcpy(soap->msgbuf, "End of file or no input: ", 25);

	movq	xmm0, QWORD PTR ??_C@_0BK@LNBGPKAI@End?5of?5file?5or?5no?5input?3?5?$AA@
	movq	QWORD PTR [edi], xmm0
	movq	xmm0, QWORD PTR ??_C@_0BK@LNBGPKAI@End?5of?5file?5or?5no?5input?3?5?$AA@+8
	movq	QWORD PTR [edi+8], xmm0
	movq	xmm0, QWORD PTR ??_C@_0BK@LNBGPKAI@End?5of?5file?5or?5no?5input?3?5?$AA@+16
	movq	QWORD PTR [edi+16], xmm0
	mov	dl, BYTE PTR ??_C@_0BK@LNBGPKAI@End?5of?5file?5or?5no?5input?3?5?$AA@+24
	add	esp, 12					; 0000000cH
	mov	BYTE PTR [edi+24], dl
$LN4@soap_set_f@2:

; 14368:       }
; 14369: #endif
; 14370:       *s = soap->msgbuf;

	mov	DWORD PTR [ebx], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN6@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp

; 14356:       break;
; 14357:     case SOAP_STOP:
; 14358:       *s = "Stopped: no response sent";

	mov	DWORD PTR [ebx], OFFSET ??_C@_0BK@GDNDADLI@Stopped?3?5no?5response?5sent?$AA@
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN64@soap_set_f@2:

; 14371:       break;
; 14372: #else
; 14373:       *s = "End of file or no input";
; 14374:       break;
; 14375: #endif
; 14376:     default:
; 14377: #ifndef WITH_NOHTTP
; 14378: #ifndef WITH_LEAN
; 14379:       if (soap->error > 200 && soap->error < 600)

	cmp	ecx, 200				; 000000c8H
	jle	SHORT $LN2@soap_set_f@2
	cmp	ecx, 600				; 00000258H
	jge	SHORT $LN2@soap_set_f@2

; 14380:       { sprintf(soap->msgbuf, "HTTP Error: %d %s", soap->error, http_error(soap, soap->error));

	add	esi, 78004				; 000130b4H
	call	_http_error
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BC@BJFDHNPP@HTTP?5Error?3?5?$CFd?5?$CFs?$AA@
	push	esi
	call	_sprintf
	add	esp, 16					; 00000010H
	pop	edi

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
$LN2@soap_set_f@2:

; 14381:         *s = soap->msgbuf;
; 14382:       }
; 14383:       else
; 14384: #endif
; 14385: #endif
; 14386:       { sprintf(soap->msgbuf, "Error %d", soap->error);

	push	ecx
	add	esi, 78004				; 000130b4H
	push	OFFSET ??_C@_08PNOEHBEA@Error?5?$CFd?$AA@
	push	esi
	call	_sprintf
	add	esp, 12					; 0000000cH

; 14387:         *s = soap->msgbuf;

	mov	DWORD PTR [ebx], esi
$LN1@soap_set_f@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 14388:       }
; 14389:     }
; 14390: }

	ret	0
	npad	2
$LN130@soap_set_f@2:
	DD	$LN5@soap_set_f@2
	DD	$LN64@soap_set_f@2
	DD	$LN53@soap_set_f@2
	DD	$LN52@soap_set_f@2
	DD	$LN51@soap_set_f@2
	DD	$LN50@soap_set_f@2
	DD	$LN49@soap_set_f@2
	DD	$LN48@soap_set_f@2
	DD	$LN32@soap_set_f@2
	DD	$LN47@soap_set_f@2
	DD	$LN44@soap_set_f@2
	DD	$LN43@soap_set_f@2
	DD	$LN42@soap_set_f@2
	DD	$LN1@soap_set_f@2
	DD	$LN41@soap_set_f@2
	DD	$LN40@soap_set_f@2
	DD	$LN39@soap_set_f@2
	DD	$LN38@soap_set_f@2
	DD	$LN64@soap_set_f@2
	DD	$LN37@soap_set_f@2
	DD	$LN36@soap_set_f@2
	DD	$LN35@soap_set_f@2
	DD	$LN34@soap_set_f@2
	DD	$LN33@soap_set_f@2
	DD	$LN31@soap_set_f@2
	DD	$LN30@soap_set_f@2
	DD	$LN28@soap_set_f@2
	DD	$LN26@soap_set_f@2
	DD	$LN24@soap_set_f@2
	DD	$LN23@soap_set_f@2
	DD	$LN22@soap_set_f@2
	DD	$LN21@soap_set_f@2
	DD	$LN12@soap_set_f@2
	DD	$LN19@soap_set_f@2
	DD	$LN18@soap_set_f@2
	DD	$LN17@soap_set_f@2
	DD	$LN16@soap_set_f@2
	DD	$LN15@soap_set_f@2
	DD	$LN14@soap_set_f@2
	DD	$LN13@soap_set_f@2
	DD	$LN46@soap_set_f@2
	DD	$LN20@soap_set_f@2
	DD	$LN45@soap_set_f@2
	DD	$LN11@soap_set_f@2
	DD	$LN10@soap_set_f@2
	DD	$LN9@soap_set_f@2
	DD	$LN8@soap_set_f@2
	DD	$LN7@soap_set_f@2
_soap_set_fault ENDP
; Function compile flags: /Ogtpy
_soap$ = 8						; size = 4
_status$ = 12						; size = 4
_count$ = 16						; size = 4
_http_response PROC

; 14060: { register int err;

	push	esi

; 14061: #ifdef WMW_RPM_IO
; 14062:   if (soap->rpmreqid)
; 14063:     httpOutputEnable(soap->rpmreqid);
; 14064: #endif
; 14065:   if (strlen(soap->http_version) > 4)

	mov	esi, DWORD PTR _soap$[esp]
	mov	edx, DWORD PTR [esi+32]
	mov	eax, edx
	push	edi
	lea	edi, DWORD PTR [eax+1]
	npad	2
$LL40@http_respo:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL40@http_respo
	sub	eax, edi
	cmp	eax, 4
	jbe	SHORT $LN32@http_respo

; 14066:     return soap->error = SOAP_EOM;

	mov	eax, 20					; 00000014H
	pop	edi
	mov	DWORD PTR [esi+90460], eax
	pop	esi

; 14129: }

	ret	0
$LN32@http_respo:
	push	ebp

; 14067:   if (!status || status == SOAP_HTML || status == SOAP_FILE)

	mov	ebp, DWORD PTR _status$[esp+8]
	test	ebp, ebp
	je	$LN30@http_respo
	cmp	ebp, 1002				; 000003eaH
	je	$LN30@http_respo
	cmp	ebp, 1003				; 000003ebH
	je	$LN30@http_respo

; 14084:       return err;
; 14085:   }
; 14086:   else if (status >= 200 && status < 600)

	lea	eax, DWORD PTR [ebp-200]
	cmp	eax, 399				; 0000018fH
	ja	$LN20@http_respo

; 14087:   { sprintf(soap->tmpbuf, "HTTP/%s %d %s", soap->http_version, status, http_error(soap, status));

	mov	ecx, ebp
	lea	edi, DWORD PTR [esi+79028]
	call	_http_error
	push	eax
	push	ebp
	push	edx
	push	OFFSET ??_C@_0O@OIHDPKBJ@HTTP?1?$CFs?5?$CFd?5?$CFs?$AA@
	push	edi
	call	_sprintf

; 14088:     if ((err = soap->fposthdr(soap, soap->tmpbuf, NULL)))

	mov	ecx, DWORD PTR [esi+12256]
	push	0
	push	edi
	push	esi
	call	ecx
	add	esp, 32					; 00000020H
	test	eax, eax

; 14089:       return err;

	jne	$LN47@http_respo

; 14090: #ifndef WITH_LEAN
; 14091:     if (status == 401)

	cmp	ebp, 401				; 00000191H
	jne	SHORT $LN18@http_respo

; 14092:     { sprintf(soap->tmpbuf, "Basic realm=\"%s\"", (soap->authrealm ? strlen(soap->authrealm) : 18) < sizeof(soap->tmpbuf) - 14 ? soap->authrealm : "gSOAP Web Service");

	mov	edx, DWORD PTR [esi+90396]
	test	edx, edx
	je	SHORT $LN39@http_respo
	mov	eax, edx
	push	ebx
	lea	ebx, DWORD PTR [eax+1]
	npad	4
$LL41@http_respo:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL41@http_respo
	sub	eax, ebx
	pop	ebx
	cmp	eax, 1010				; 000003f2H
	jae	SHORT $LN37@http_respo
$LN39@http_respo:
	mov	eax, edx
	jmp	SHORT $LN38@http_respo
$LN37@http_respo:
	mov	eax, OFFSET ??_C@_0BC@NIIEEHHB@gSOAP?5Web?5Service?$AA@
$LN38@http_respo:
	push	eax
	push	OFFSET ??_C@_0BB@GEFAMELB@Basic?5realm?$DN?$CC?$CFs?$CC?$AA@
	push	edi
	call	_sprintf

; 14093:       if ((err = soap->fposthdr(soap, "WWW-Authenticate", soap->tmpbuf)))

	mov	edx, DWORD PTR [esi+12256]
	push	edi
	push	OFFSET ??_C@_0BB@KEDJJIFI@WWW?9Authenticate?$AA@
	push	esi
	call	edx
	add	esp, 24					; 00000018H
	test	eax, eax
	je	$LN46@http_respo
	pop	ebp
	pop	edi
	pop	esi

; 14129: }

	ret	0
$LN18@http_respo:

; 14094:         return err;
; 14095:     }
; 14096:     else if ((status >= 301 && status <= 303) || status == 307)

	cmp	ebp, 301				; 0000012dH
	jl	SHORT $LN13@http_respo
	cmp	ebp, 303				; 0000012fH
	jle	SHORT $LN14@http_respo
$LN13@http_respo:
	cmp	ebp, 307				; 00000133H
	jne	$LN46@http_respo
$LN14@http_respo:

; 14097:     { if ((err = soap->fposthdr(soap, "Location", soap->endpoint)))

	mov	ecx, DWORD PTR [esi+12256]
	lea	eax, DWORD PTR [esi+87320]
	push	eax
	push	OFFSET ??_C@_08KDOEBHGA@Location?$AA@
	push	esi
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN46@http_respo
	pop	ebp
	pop	edi
	pop	esi

; 14129: }

	ret	0
$LN20@http_respo:

; 14098:         return err;
; 14099:     }
; 14100: #endif
; 14101:   }
; 14102:   else
; 14103:   { const char *s = *soap_faultcode(soap);

	call	_soap_faultcode
	mov	eax, DWORD PTR [eax]

; 14104:     if (soap->version == 2 && (!s || !strcmp(s, "SOAP-ENV:Sender")))

	or	edi, -1
	cmp	WORD PTR [esi+6], 2
	jne	SHORT $LN10@http_respo
	test	eax, eax
	je	SHORT $LN9@http_respo
	mov	ecx, OFFSET ??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@
	npad	2
$LL42@http_respo:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN43@http_respo
	test	dl, dl
	je	SHORT $LN44@http_respo
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN43@http_respo
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL42@http_respo
$LN44@http_respo:
	xor	eax, eax
	jmp	SHORT $LN45@http_respo
$LN43@http_respo:
	sbb	eax, eax
	sbb	eax, edi
$LN45@http_respo:
	test	eax, eax
	jne	SHORT $LN10@http_respo
$LN9@http_respo:

; 14105:       s = "400 Bad Request";

	mov	eax, OFFSET ??_C@_0BA@NLEABOII@400?5Bad?5Request?$AA@

; 14106:     else

	jmp	SHORT $LN8@http_respo
$LN10@http_respo:

; 14107:       s = "500 Internal Server Error";

	mov	eax, OFFSET ??_C@_0BK@FNMKOGBN@500?5Internal?5Server?5Error?$AA@
$LN8@http_respo:

; 14108:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Error %s (status=%d)\n", s, status));
; 14109: #ifdef WMW_RPM_IO
; 14110:     if (soap->rpmreqid || soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* RPM behaves as if standalone */
; 14111: #else
; 14112:     if (soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* standalone application */

	cmp	DWORD PTR [esi+12404], edi
	jne	SHORT $LN6@http_respo
	cmp	DWORD PTR [esi+12408], edi
	jne	SHORT $LN6@http_respo

; 14116:         return err;
; 14117:     }
; 14118:     else if ((err = soap->fposthdr(soap, "Status", s)))	/* CGI */

	mov	edx, DWORD PTR [esi+12256]
	push	eax
	push	OFFSET ??_C@_06PGDKHFME@Status?$AA@
	push	esi
	call	edx
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN46@http_respo
	pop	ebp
	pop	edi
	pop	esi

; 14129: }

	ret	0
$LN6@http_respo:

; 14113: #endif
; 14114:     { sprintf(soap->tmpbuf, "HTTP/%s %s", soap->http_version, s);

	push	eax
	mov	eax, DWORD PTR [esi+32]
	push	eax
	lea	edi, DWORD PTR [esi+79028]
	push	OFFSET ??_C@_0L@HINEDFNI@HTTP?1?$CFs?5?$CFs?$AA@
	push	edi
	call	_sprintf

; 14115:       if ((err = soap->fposthdr(soap, soap->tmpbuf, NULL)))

	mov	ecx, DWORD PTR [esi+12256]
	push	0
	push	edi
	push	esi
	call	ecx
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN46@http_respo
	pop	ebp
	pop	edi
	pop	esi

; 14129: }

	ret	0
$LN30@http_respo:

; 14068:   { const char *s;
; 14069:     if (count || ((soap->omode & SOAP_IO) == SOAP_IO_CHUNK))

	cmp	DWORD PTR _count$[esp+8], 0
	jne	SHORT $LN28@http_respo
	mov	eax, DWORD PTR [esi+16]
	and	eax, 3
	cmp	al, 3

; 14071:     else
; 14072:       s = "202 ACCEPTED";

	mov	eax, OFFSET ??_C@_0N@GGGJJCHF@202?5ACCEPTED?$AA@
	jne	SHORT $LN27@http_respo
$LN28@http_respo:

; 14070:       s = "200 OK";

	mov	eax, OFFSET ??_C@_06DAENNINM@200?5OK?$AA@
$LN27@http_respo:

; 14073:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Status = %s\n", s));
; 14074: #ifdef WMW_RPM_IO
; 14075:     if (soap->rpmreqid || soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* RPM behaves as if standalone */
; 14076: #else
; 14077:     if (soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* standalone application */

	or	edi, -1
	cmp	DWORD PTR [esi+12404], edi
	jne	SHORT $LN25@http_respo
	cmp	DWORD PTR [esi+12408], edi
	jne	SHORT $LN25@http_respo

; 14082:     }
; 14083:     else if ((err = soap->fposthdr(soap, "Status", s)))

	mov	ecx, DWORD PTR [esi+12256]
	push	eax
	push	OFFSET ??_C@_06PGDKHFME@Status?$AA@
	push	esi
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN46@http_respo
	pop	ebp
	pop	edi
	pop	esi

; 14129: }

	ret	0
$LN25@http_respo:

; 14078: #endif
; 14079:     { sprintf(soap->tmpbuf, "HTTP/%s %s", soap->http_version, s);

	push	eax
	push	edx
	lea	edi, DWORD PTR [esi+79028]
	push	OFFSET ??_C@_0L@HINEDFNI@HTTP?1?$CFs?5?$CFs?$AA@
	push	edi
	call	_sprintf

; 14080:       if ((err = soap->fposthdr(soap, soap->tmpbuf, NULL)))

	mov	edx, DWORD PTR [esi+12256]
	push	0
	push	edi
	push	esi
	call	edx
	add	esp, 28					; 0000001cH
	test	eax, eax

; 14081:         return err;

	jne	SHORT $LN47@http_respo
$LN46@http_respo:

; 14119:       return err;
; 14120:   }
; 14121:   if ((err = soap->fposthdr(soap, "Server", "gSOAP/2.7"))
; 14122:    || (err = soap_puthttphdr(soap, status, count)))

	mov	eax, DWORD PTR [esi+12256]
	push	OFFSET ??_C@_09MBLJBAGJ@gSOAP?12?47?$AA@
	push	OFFSET ??_C@_06LGMEBDBC@Server?$AA@
	push	esi
	call	eax
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN47@http_respo
	mov	ecx, DWORD PTR _count$[esp+8]
	push	ecx
	push	esi
	mov	eax, ebp
	call	_soap_puthttphdr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN47@http_respo

; 14123:     return err;
; 14124: #ifdef WITH_COOKIES
; 14125:   if (soap_putsetcookies(soap))
; 14126:     return soap->error;
; 14127: #endif
; 14128:   return soap->fposthdr(soap, NULL, NULL);

	mov	edx, DWORD PTR [esi+12256]
	push	eax
	push	eax
	push	esi
	call	edx
	add	esp, 12					; 0000000cH
$LN47@http_respo:
	pop	ebp
	pop	edi
	pop	esi

; 14129: }

	ret	0
_http_response ENDP
_TEXT	ENDS
PUBLIC	_soap_body_end_in
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_body_end_in PROC
; _soap$ = eax

; 13456: { if (soap->part == SOAP_NO_BODY)

	push	esi
	mov	esi, eax
	cmp	WORD PTR [esi+87304], 5
	jne	SHORT $LN1@soap_body_@3

; 13457:     return SOAP_OK;

	xor	eax, eax
	pop	esi

; 13460: }

	ret	0
$LN1@soap_body_@3:

; 13458:   soap->part = SOAP_END_BODY;

	mov	eax, 7

; 13459:   return soap_element_end_in(soap, "SOAP-ENV:Body");

	push	OFFSET ??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@
	mov	WORD PTR [esi+87304], ax
	call	_soap_element_end_in
	add	esp, 4
	pop	esi

; 13460: }

	ret	0
_soap_body_end_in ENDP
_TEXT	ENDS
PUBLIC	_soap_envelope_end_in
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_envelope_end_in PROC
; _soap$ = eax

; 13398: { soap->part = SOAP_END_ENVELOPE;

	push	esi
	mov	esi, eax
	mov	eax, 8

; 13399:   return soap_element_end_in(soap, "SOAP-ENV:Envelope");

	push	OFFSET ??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@
	mov	WORD PTR [esi+87304], ax
	call	_soap_element_end_in
	add	esp, 4
	pop	esi

; 13400: }

	ret	0
_soap_envelope_end_in ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_soap_getdimehdr
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tmp$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_soap_getdimehdr PROC
; _soap$ = esi

; 11245: { register soap_wchar c;

	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+16], eax

; 11246:   register char *s;
; 11247:   register int i;
; 11248:   unsigned char tmp[12];
; 11249:   size_t optlen, idlen, typelen;
; 11250:   if (!(soap->mode & SOAP_ENC_DIME))

	test	BYTE PTR [esi+8], -128			; ffffff80H
	jne	SHORT $LN13@soap_getdi@2

; 11251:     return soap->error = SOAP_DIME_END;

	mov	eax, 35					; 00000023H
	mov	DWORD PTR [esi+90460], eax

; 11284: }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+16]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 16					; 00000010H
	ret	0
$LN13@soap_getdi@2:

; 11252:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Get DIME header\n"));
; 11253:   if (soap->dime.buflen || soap->dime.chunksize)

	cmp	DWORD PTR [esi+90488], 0
	jne	$LN11@soap_getdi@2
	cmp	DWORD PTR [esi+90484], 0
	jne	$LN11@soap_getdi@2
	push	ebx
	push	edi

; 11257:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "... From chunked\n"));
; 11258:     return SOAP_OK;
; 11259:   }
; 11260:   s = (char*)tmp;

	lea	edi, DWORD PTR _tmp$[esp+24]

; 11261:   for (i = 12; i > 0; i--)

	mov	ebx, 12					; 0000000cH
$LL9@soap_getdi@2:

; 11262:   { if ((int)(c = soap_getchar(soap)) == EOF)

	mov	eax, esi
	call	_soap_getchar
	cmp	eax, -1
	je	SHORT $LN19@soap_getdi@2

; 11264:     *s++ = (char)c;

	mov	BYTE PTR [edi], al
	dec	ebx
	inc	edi
	test	ebx, ebx
	jg	SHORT $LL9@soap_getdi@2

; 11265:   }
; 11266:   if ((tmp[0] & 0xF8) != SOAP_DIME_VERSION)

	mov	al, BYTE PTR _tmp$[esp+24]
	mov	cl, al
	and	cl, 248					; 000000f8H
	cmp	cl, 8
	je	SHORT $LN5@soap_getdi@2

; 11267:     return soap->error = SOAP_DIME_MISMATCH;

	mov	eax, 34					; 00000022H
	mov	DWORD PTR [esi+90460], eax
$LN21@soap_getdi@2:
	pop	edi
	pop	ebx

; 11284: }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+16]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 16					; 00000010H
	ret	0
$LN19@soap_getdi@2:
	pop	edi

; 11263:       return soap->error = SOAP_EOF;

	mov	DWORD PTR [esi+90460], -1
	or	eax, -1
	pop	ebx

; 11284: }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+16]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 16					; 00000010H
	ret	0
$LN5@soap_getdi@2:

; 11268:   soap->dime.flags = (tmp[0] & 0x7) | (tmp[1] & 0xF0);

	mov	dl, BYTE PTR _tmp$[esp+25]

; 11269:   optlen = (tmp[2] << 8) | tmp[3];
; 11270:   idlen = (tmp[4] << 8) | tmp[5];

	movzx	edi, BYTE PTR _tmp$[esp+28]

; 11271:   typelen = (tmp[6] << 8) | tmp[7];

	movzx	ebx, BYTE PTR _tmp$[esp+30]
	movzx	ecx, BYTE PTR _tmp$[esp+31]
	and	dl, -16					; fffffff0H
	and	al, 7
	or	dl, al
	movzx	eax, BYTE PTR _tmp$[esp+29]
	mov	BYTE PTR [esi+90492], dl

; 11272:   soap->dime.size = (tmp[8] << 24) | (tmp[9] << 16) | (tmp[10] << 8) | tmp[11];

	movzx	edx, BYTE PTR _tmp$[esp+32]
	shl	edx, 8
	shl	edi, 8
	or	edi, eax
	movzx	eax, BYTE PTR _tmp$[esp+33]
	or	edx, eax
	movzx	eax, BYTE PTR _tmp$[esp+35]
	shl	ebx, 8
	or	ebx, ecx
	movzx	ecx, BYTE PTR _tmp$[esp+34]
	shl	edx, 8
	or	edx, ecx

; 11273:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "DIME size=%lu flags=0x%X\n", (unsigned long)soap->dime.size, soap->dime.flags));
; 11274:   if (!(soap->dime.options = soap_getdimefield(soap, optlen)) && soap->error)

	movzx	ecx, BYTE PTR _tmp$[esp+26]
	shl	edx, 8
	or	edx, eax
	mov	DWORD PTR [esi+90480], edx
	movzx	edx, BYTE PTR _tmp$[esp+27]
	shl	ecx, 8
	or	ecx, edx
	push	ecx
	mov	eax, esi
	call	_soap_getdimefield
	add	esp, 4
	mov	DWORD PTR [esi+90508], eax
	test	eax, eax
	jne	SHORT $LN4@soap_getdi@2
	mov	eax, DWORD PTR [esi+90460]
	test	eax, eax

; 11275:     return soap->error;

	jne	$LN21@soap_getdi@2
$LN4@soap_getdi@2:

; 11276:   if (!(soap->dime.id = soap_getdimefield(soap, idlen)) && soap->error)

	push	edi
	mov	eax, esi
	call	_soap_getdimefield
	add	esp, 4
	mov	DWORD PTR [esi+90500], eax
	test	eax, eax
	jne	SHORT $LN3@soap_getdi@2
	mov	eax, DWORD PTR [esi+90460]
	test	eax, eax

; 11277:     return soap->error;

	jne	$LN21@soap_getdi@2
$LN3@soap_getdi@2:

; 11278:   if (!(soap->dime.type = soap_getdimefield(soap, typelen)) && soap->error)

	push	ebx
	mov	eax, esi
	call	_soap_getdimefield
	add	esp, 4
	mov	DWORD PTR [esi+90504], eax
	test	eax, eax
	jne	SHORT $LN2@soap_getdi@2
	mov	eax, DWORD PTR [esi+90460]
	test	eax, eax

; 11279:     return soap->error;

	jne	$LN21@soap_getdi@2
$LN2@soap_getdi@2:

; 11280:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "DIME id=%s, type=%s, options=%s\n", soap->dime.id?soap->dime.id:"", soap->dime.type?soap->dime.type:"", soap->dime.options?soap->dime.options+4:""));
; 11281:   if (soap->dime.flags & SOAP_DIME_ME)

	test	BYTE PTR [esi+90492], 2
	je	SHORT $LN1@soap_getdi@2

; 11282:     soap->mode &= ~SOAP_ENC_DIME;

	and	DWORD PTR [esi+8], -129			; ffffff7fH
$LN1@soap_getdi@2:
	pop	edi

; 11283:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 11284: }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+16]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 16					; 00000010H
	ret	0
$LN11@soap_getdi@2:

; 11254:   { if (soap_move(soap, (long)(soap->dime.size - soap_tell(soap))))

	mov	ecx, DWORD PTR [esi+12448]
	xor	eax, eax
	cmp	DWORD PTR [esi+12436], eax
	setne	al
	sub	ecx, eax
	sub	ecx, DWORD PTR [esi+12432]
	mov	eax, DWORD PTR [esi+90480]
	add	ecx, DWORD PTR [esi+12428]
	sub	eax, ecx
	mov	ecx, esi
	call	_soap_move
	test	eax, eax
	je	SHORT $LN10@soap_getdi@2

; 11255:       return soap->error = SOAP_EOF;

	mov	DWORD PTR [esi+90460], -1
	or	eax, -1

; 11284: }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+16]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 16					; 00000010H
	ret	0
$LN10@soap_getdi@2:

; 11256:     soap_unget(soap, soap_getchar(soap)); /* skip padding and get hdr */

	mov	eax, esi
	call	_soap_getchar

; 11284: }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+16]
	mov	DWORD PTR [esi+12436], eax
	xor	ecx, esp
	xor	eax, eax
	call	@__security_check_cookie@4
	add	esp, 16					; 00000010H
	ret	0
_soap_getdimehdr ENDP
_TEXT	ENDS
PUBLIC	_soap_outwstring
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_pp$574746 = -4						; size = 4
_tag$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_n$ = 20						; size = 4
_soap_outwstring PROC
; _soap$ = ecx
; _id$ = eax

; 10488: { id = soap_element_id(soap, tag, id, *p, NULL, 0, type, n);

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _tag$[esp+8]
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR _p$[esp+16]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, eax
	test	ecx, ecx
	je	$LN14@soap_outws
	test	DWORD PTR [edi+8], 32768		; 00008000H
	je	SHORT $LN13@soap_outws
	xor	eax, eax
	jmp	SHORT $LN4@soap_outws
$LN13@soap_outws:
	test	eax, eax
	jge	SHORT $LN9@soap_outws
	mov	esi, DWORD PTR _n$[esp+16]
	lea	edx, DWORD PTR _pp$574746[esp+20]
	call	_soap_pointer_lookup
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN9@soap_outws
	mov	ebx, DWORD PTR _pp$574746[esp+20]
	mov	ecx, ebx
	mov	eax, edi
	call	_soap_is_embedded
	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN8@soap_outws
	push	ebp
	mov	eax, esi
	call	_soap_element_ref
	add	esp, 4
$LN1@soap_outws:

; 10496:     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10497:   return SOAP_OK;
; 10498: }

	pop	ecx
	ret	0

; 10488: { id = soap_element_id(soap, tag, id, *p, NULL, 0, type, n);

$LN8@soap_outws:
	mov	eax, ebx
	call	_soap_is_single
	test	eax, eax
	je	SHORT $LN7@soap_outws
	xor	eax, eax
	jmp	SHORT $LN4@soap_outws
$LN7@soap_outws:
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_set_embedded
$LN9@soap_outws:
	mov	eax, esi

; 10489:   if (id < 0)

	test	esi, esi

; 10490:     return soap->error;

	jl	SHORT $LN1@soap_outws
$LN4@soap_outws:

; 10491:   if (!**p && (soap->mode & SOAP_C_NILSTRING))

	mov	esi, DWORD PTR _p$[esp+16]
	mov	ecx, DWORD PTR [esi]
	cmp	WORD PTR [ecx], 0
	jne	SHORT $LN3@soap_outws
	test	DWORD PTR [edi+8], 8388608		; 00800000H
	je	SHORT $LN3@soap_outws

; 10492:     return soap_element_null(soap, tag, id, type);

	mov	edx, DWORD PTR _type$[esp+16]
	push	edx
	push	edi
	mov	ecx, ebp
	call	_soap_element_null
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10497:   return SOAP_OK;
; 10498: }

	pop	ecx
	ret	0

; 10488: { id = soap_element_id(soap, tag, id, *p, NULL, 0, type, n);

$LN14@soap_outws:
	mov	edx, DWORD PTR _type$[esp+16]
	push	edx
	push	edi
	mov	ecx, ebp
	call	_soap_element_null

; 10496:     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10497:   return SOAP_OK;
; 10498: }

	pop	ecx
	ret	0
$LN3@soap_outws:

; 10493:   if (soap_element_begin_out(soap, tag, id, type)
; 10494:    || soap_wstring_out(soap, *p, 0)
; 10495:    || soap_element_end_out(soap, tag))

	cmp	BYTE PTR [ebp], 45			; 0000002dH
	je	SHORT $LN38@soap_outws
	mov	ecx, DWORD PTR _type$[esp+16]
	push	ecx
	push	eax
	push	ebp
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN33@soap_outws
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN35@soap_outws
$LN33@soap_outws:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN35@soap_outws:
	test	eax, eax
	jne	$LN1@soap_outws
$LN38@soap_outws:
	mov	edx, DWORD PTR [esi]
	push	edx
	mov	eax, edi
	call	_soap_wstring_out
	add	esp, 4
	test	eax, eax
	jne	$LN1@soap_outws
	mov	esi, ebp
	mov	eax, edi
	call	_soap_element_end_out
	test	eax, eax
	jne	$LN1@soap_outws
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10497:   return SOAP_OK;
; 10498: }

	pop	ecx
	ret	0
_soap_outwstring ENDP
_TEXT	ENDS
PUBLIC	_soap_outstring
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_pp$574803 = -4						; size = 4
_tag$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_n$ = 20						; size = 4
_soap_outstring PROC
; _soap$ = ecx
; _id$ = eax

; 10428: { id = soap_element_id(soap, tag, id, *p, NULL, 0, type, n);

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _tag$[esp+8]
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR _p$[esp+16]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, eax
	test	ecx, ecx
	je	$LN14@soap_outst
	test	DWORD PTR [edi+8], 32768		; 00008000H
	je	SHORT $LN13@soap_outst
	xor	eax, eax
	jmp	SHORT $LN4@soap_outst
$LN13@soap_outst:
	test	eax, eax
	jge	SHORT $LN9@soap_outst
	mov	esi, DWORD PTR _n$[esp+16]
	lea	edx, DWORD PTR _pp$574803[esp+20]
	call	_soap_pointer_lookup
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN9@soap_outst
	mov	ebx, DWORD PTR _pp$574803[esp+20]
	mov	ecx, ebx
	mov	eax, edi
	call	_soap_is_embedded
	mov	ecx, edi
	test	eax, eax
	je	SHORT $LN8@soap_outst
	push	ebp
	mov	eax, esi
	call	_soap_element_ref
	add	esp, 4
$LN1@soap_outst:

; 10436:     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10437:   return SOAP_OK;
; 10438: }

	pop	ecx
	ret	0

; 10428: { id = soap_element_id(soap, tag, id, *p, NULL, 0, type, n);

$LN8@soap_outst:
	mov	eax, ebx
	call	_soap_is_single
	test	eax, eax
	je	SHORT $LN7@soap_outst
	xor	eax, eax
	jmp	SHORT $LN4@soap_outst
$LN7@soap_outst:
	mov	eax, ebx
	mov	ecx, edi
	call	_soap_set_embedded
$LN9@soap_outst:
	mov	eax, esi

; 10429:   if (id < 0)

	test	esi, esi

; 10430:     return soap->error;

	jl	SHORT $LN1@soap_outst
$LN4@soap_outst:

; 10431:   if (!**p && (soap->mode & SOAP_C_NILSTRING))

	mov	esi, DWORD PTR _p$[esp+16]
	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN3@soap_outst
	test	DWORD PTR [edi+8], 8388608		; 00800000H
	je	SHORT $LN3@soap_outst

; 10432:     return soap_element_null(soap, tag, id, type);

	mov	edx, DWORD PTR _type$[esp+16]
	push	edx
	push	edi
	mov	ecx, ebp
	call	_soap_element_null
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10437:   return SOAP_OK;
; 10438: }

	pop	ecx
	ret	0

; 10428: { id = soap_element_id(soap, tag, id, *p, NULL, 0, type, n);

$LN14@soap_outst:
	mov	edx, DWORD PTR _type$[esp+16]
	push	edx
	push	edi
	mov	ecx, ebp
	call	_soap_element_null

; 10436:     return soap->error;

	mov	eax, DWORD PTR [edi+90460]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10437:   return SOAP_OK;
; 10438: }

	pop	ecx
	ret	0
$LN3@soap_outst:

; 10433:   if (soap_element_begin_out(soap, tag, id, type)
; 10434:    || soap_string_out(soap, *p, 0)
; 10435:    || soap_element_end_out(soap, tag))

	cmp	BYTE PTR [ebp], 45			; 0000002dH
	je	SHORT $LN39@soap_outst
	mov	ecx, DWORD PTR _type$[esp+16]
	push	ecx
	push	eax
	push	ebp
	mov	eax, edi
	call	_soap_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN33@soap_outst
	mov	eax, DWORD PTR [edi+90460]
	jmp	SHORT $LN35@soap_outst
$LN33@soap_outst:
	push	0
	call	_soap_element_start_end_out
	add	esp, 4
$LN35@soap_outst:
	test	eax, eax
	jne	$LN1@soap_outst
$LN39@soap_outst:
	mov	eax, DWORD PTR [esi]
	push	0
	mov	ecx, edi
	call	_soap_string_out
	add	esp, 4
	test	eax, eax
	jne	$LN1@soap_outst
	mov	esi, ebp
	mov	eax, edi
	call	_soap_element_end_out
	test	eax, eax
	jne	$LN1@soap_outst
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10437:   return SOAP_OK;
; 10438: }

	pop	ecx
	ret	0
_soap_outstring ENDP
_TEXT	ENDS
PUBLIC	_soap_wstring_in
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_i$ = -4						; size = 4
_l$ = 8							; size = 4
_soap$ = 8						; size = 4
_flag$ = 12						; size = 4
_minlen$ = 16						; size = 4
_maxlen$ = 20						; size = 4
_soap_wstring_in PROC

; 8952 : { wchar_t *s;

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp+4]
	push	ebp
	push	esi
	push	edi

; 8953 :   register int i, n = 0;

	xor	edi, edi
	xor	ebp, ebp

; 8954 :   register long l = 0;

	mov	DWORD PTR _l$[esp+16], edi

; 8955 :   register soap_wchar c;
; 8956 :   char *t = NULL;
; 8957 :   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Reading wide string content\n"));
; 8958 :   if (soap->peeked)

	cmp	WORD PTR [ebx+87308], di
	je	$LN87@soap_wstri@2

; 8959 :   { if (!soap->body)

	cmp	WORD PTR [ebx+12442], di

; 8960 :       return NULL;

	je	$LN94@soap_wstri@2

; 8961 :     if (*soap->tag)

	cmp	BYTE PTR [ebx+80052], 0
	lea	eax, DWORD PTR [ebx+80052]
	je	$LN87@soap_wstri@2

; 8962 :     {
; 8963 : #ifndef WITH_LEAN
; 8964 :       struct soap_attribute *tp;
; 8965 :       t = soap->tmpbuf;

	lea	esi, DWORD PTR [ebx+79028]

; 8966 :       *t = '<';
; 8967 :       t[sizeof(soap->tmpbuf)-1] = '\0';
; 8968 :       strncpy(t + 1, soap->tag, sizeof(soap->tmpbuf) - 2);

	push	1022					; 000003feH
	push	eax
	lea	eax, DWORD PTR [esi+1]
	push	eax
	mov	BYTE PTR [esi], 60			; 0000003cH
	mov	BYTE PTR [esi+1023], 0
	call	_strncpy

; 8969 :       t += strlen(t);

	mov	eax, esi
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL79@soap_wstri@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL79@soap_wstri@2

; 8970 :       for (tp = soap->attributes; tp; tp = tp->next)

	mov	edi, DWORD PTR [ebx+87292]
	sub	eax, edx
	add	esi, eax
	test	edi, edi
	je	SHORT $LN86@soap_wstri@2
	npad	6
$LL42@soap_wstri@2:

; 8971 :       { if (tp->visible)

	cmp	WORD PTR [edi+16], 0
	je	SHORT $LN41@soap_wstri@2

; 8972 :         { if (t >= soap->tmpbuf + sizeof(soap->tmpbuf) - 2)

	lea	ebp, DWORD PTR [ebx+80050]
	cmp	esi, ebp
	jae	SHORT $LN86@soap_wstri@2

; 8973 :             break;
; 8974 :           *t++ = ' ';

	mov	BYTE PTR [esi], 32			; 00000020H
	inc	esi

; 8975 :           strcpy(t, tp->name);

	lea	eax, DWORD PTR [edi+18]
	mov	edx, esi
	sub	edx, eax
	npad	4
$LL48@soap_wstri@2:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL48@soap_wstri@2

; 8976 :           t += strlen(t);

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL80@soap_wstri@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL80@soap_wstri@2
	sub	eax, edx
	add	esi, eax

; 8977 :           if (t >= soap->tmpbuf + sizeof(soap->tmpbuf) - 2)

	cmp	esi, ebp
	jae	SHORT $LN86@soap_wstri@2

; 8978 :             break;
; 8979 :           if (tp->value)

	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN41@soap_wstri@2

; 8980 :           { *t++ = '=';

	mov	BYTE PTR [esi], 61			; 0000003dH
	inc	esi

; 8981 :             *t++ = '"';

	mov	BYTE PTR [esi], 34			; 00000022H

; 8982 :             strcpy(t, tp->value);

	mov	ecx, DWORD PTR [edi+4]
	inc	esi
	mov	edx, esi
$LL49@soap_wstri@2:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL49@soap_wstri@2

; 8983 :             t += strlen(t);

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$LL81@soap_wstri@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL81@soap_wstri@2
	sub	eax, edx
	add	esi, eax

; 8984 :             *t++ = '"';

	mov	BYTE PTR [esi], 34			; 00000022H
	inc	esi
$LN41@soap_wstri@2:
	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL42@soap_wstri@2
$LN86@soap_wstri@2:

; 8985 :           }
; 8986 :         }
; 8987 :       }
; 8988 :       *t++ = '>';

	mov	BYTE PTR [esi], 62			; 0000003eH

; 8989 :       *t = '\0';
; 8990 :       t = soap->tmpbuf;
; 8991 : #endif
; 8992 :       n = 1;
; 8993 :       soap->peeked = 0;

	xor	ecx, ecx
	mov	BYTE PTR [esi+1], 0
	lea	edi, DWORD PTR [ebx+79028]
	mov	ebp, 1
	mov	WORD PTR [ebx+87308], cx
$LN87@soap_wstri@2:

; 8994 :     }
; 8995 :   }
; 8996 :   if (soap_new_block(soap))

	push	12					; 0000000cH
	call	_malloc
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	$LN94@soap_wstri@2
	mov	edx, DWORD PTR [ebx+92]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [ebx+92], eax
$LL34@soap_wstri@2:

; 8997 :     return NULL;
; 8998 :   for (;;)
; 8999 :   { if (!(s = (wchar_t*)soap_push_block(soap, sizeof(wchar_t)*SOAP_BLKLEN)))

	push	520					; 00000208H
	call	_malloc
	add	esp, 4
	test	eax, eax
	je	$LN76@soap_wstri@2
	mov	ecx, DWORD PTR [ebx+92]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	edx, 512				; 00000200H
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebx+92]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR [ebx+92]
	add	DWORD PTR [ecx+8], edx
	lea	esi, DWORD PTR [eax+8]
	test	esi, esi
	je	$LN94@soap_wstri@2

; 9000 :       return NULL;
; 9001 :     for (i = 0; i < SOAP_BLKLEN; i++)

	mov	DWORD PTR _i$[esp+20], 0
$LL89@soap_wstri@2:

; 9002 :     { if (t)

	test	edi, edi
	je	SHORT $LN28@soap_wstri@2

; 9003 :       { *s++ = (wchar_t)*t++;

	movsx	dx, BYTE PTR [edi]
	mov	WORD PTR [esi], dx
	inc	edi
	add	esi, 2

; 9004 :         if (!*t)

	cmp	BYTE PTR [edi], 0
	jne	$LN30@soap_wstri@2

; 9005 :           t = NULL;

	xor	edi, edi

; 9006 :         continue;

	jmp	$LN30@soap_wstri@2
$LN28@soap_wstri@2:

; 9007 :       }
; 9008 :       c = soap_getutf8(soap);

	mov	eax, ebx
	call	_soap_getutf8

; 9009 :       switch (c)

	lea	ecx, DWORD PTR [eax+6]
	cmp	ecx, 68					; 00000044H
	ja	$LN5@soap_wstri@2
	movzx	ecx, BYTE PTR $LN82@soap_wstri@2[ecx]
	jmp	DWORD PTR $LN97@soap_wstri@2[ecx*4]
$LN24@soap_wstri@2:

; 9010 :       {
; 9011 :       case SOAP_TT:
; 9012 :         if (n == 0)

	test	ebp, ebp
	je	$end$81770

; 9013 :           goto end;
; 9014 :         n--;
; 9015 :         *s++ = '<';

	mov	edx, 60					; 0000003cH
	mov	WORD PTR [esi], dx
	dec	ebp

; 9016 :         soap_unget(soap, '/');

	mov	DWORD PTR [ebx+12436], 47		; 0000002fH

; 9017 :         break;

	jmp	$LN95@soap_wstri@2
$LN21@soap_wstri@2:

; 9018 :       case SOAP_LT:
; 9019 :         n++;

	inc	ebp

; 9020 :         *s++ = '<';

	mov	eax, 60					; 0000003cH

; 9021 :         break;

	jmp	$LN96@soap_wstri@2
$LN19@soap_wstri@2:

; 9022 :       case SOAP_GT:
; 9023 :         *s++ = '>';
; 9024 :         break;
; 9025 :       case SOAP_QT:
; 9026 :         *s++ = '"';

	mov	edx, 34					; 00000022H
	mov	WORD PTR [esi], dx

; 9027 :         break;

	jmp	$LN95@soap_wstri@2
$LN18@soap_wstri@2:

; 9028 :       case SOAP_AP:
; 9029 :         *s++ = '\'';

	mov	eax, 39					; 00000027H

; 9030 :         break;

	jmp	$LN96@soap_wstri@2
$LN17@soap_wstri@2:

; 9031 :       case '/':
; 9032 :         if (n > 0)

	test	ebp, ebp
	jle	SHORT $LN16@soap_wstri@2

; 9033 :         { c = soap_getutf8(soap);

	mov	eax, ebx
	call	_soap_getutf8

; 9034 :           if (c == SOAP_GT)

	cmp	eax, -4					; fffffffcH
	jne	SHORT $LN15@soap_wstri@2

; 9035 :             n--;

	dec	ebp
$LN15@soap_wstri@2:

; 9036 :           soap_unget(soap, c);

	mov	DWORD PTR [ebx+12436], eax
$LN16@soap_wstri@2:

; 9037 :         }
; 9038 :         *s++ = '/';

	mov	ecx, 47					; 0000002fH
	mov	WORD PTR [esi], cx

; 9039 :         break;

	jmp	SHORT $LN95@soap_wstri@2
$LN14@soap_wstri@2:

; 9040 :       case '<':
; 9041 :         if (flag)

	cmp	DWORD PTR _flag$[esp+16], 0
	je	SHORT $LN13@soap_wstri@2

; 9042 :           *s++ = (soap_wchar)'<';

	mov	edx, 60					; 0000003cH
	mov	WORD PTR [esi], dx

; 9043 :         else

	jmp	SHORT $LN95@soap_wstri@2
$LN13@soap_wstri@2:

; 9044 :         { *s++ = (soap_wchar)'&';

	mov	eax, 38					; 00000026H

; 9045 :           t = (char *)"lt;";

	mov	edi, OFFSET ??_C@_03MAABEHOM@lt?$DL?$AA@

; 9046 :         }
; 9047 :         break;

	jmp	SHORT $LN96@soap_wstri@2
$LN11@soap_wstri@2:

; 9048 :       case '>':
; 9049 :         if (flag)

	cmp	DWORD PTR _flag$[esp+16], 0
	je	SHORT $LN10@soap_wstri@2
$LN20@soap_wstri@2:

; 9050 :           *s++ = (soap_wchar)'>';

	mov	ecx, 62					; 0000003eH
	mov	WORD PTR [esi], cx

; 9051 :         else

	jmp	SHORT $LN95@soap_wstri@2
$LN10@soap_wstri@2:

; 9052 :         { *s++ = (soap_wchar)'&';

	mov	edx, 38					; 00000026H
	mov	WORD PTR [esi], dx

; 9053 :           t = (char *)"gt;";

	mov	edi, OFFSET ??_C@_03BHAAMAON@gt?$DL?$AA@

; 9054 : 		}
; 9055 :         break;

	jmp	SHORT $LN95@soap_wstri@2
$LN8@soap_wstri@2:

; 9056 :       case '"':
; 9057 :         if (flag)

	cmp	DWORD PTR _flag$[esp+16], 0
	je	SHORT $LN7@soap_wstri@2

; 9058 :           *s++ = (soap_wchar)'"';

	mov	eax, 34					; 00000022H

; 9059 :         else

	jmp	SHORT $LN96@soap_wstri@2
$LN7@soap_wstri@2:

; 9060 :         { *s++ = (soap_wchar)'&';

	mov	ecx, 38					; 00000026H
	mov	WORD PTR [esi], cx

; 9061 :           t = (char *)"quot;";

	mov	edi, OFFSET ??_C@_05LDHOCHGG@quot?$DL?$AA@

; 9062 :         }
; 9063 :         break;

	jmp	SHORT $LN95@soap_wstri@2
$LN5@soap_wstri@2:

; 9064 :       default:
; 9065 :         if ((int)c == EOF)

	cmp	eax, -1
	je	SHORT $end$81770
$LN96@soap_wstri@2:

; 9066 :           goto end;
; 9067 :         *s++ = (wchar_t)c & 0x7FFFFFFF;

	mov	WORD PTR [esi], ax
$LN95@soap_wstri@2:

; 9068 :       }
; 9069 :       l++;

	inc	DWORD PTR _l$[esp+16]
	add	esi, 2

; 9070 :       if ((soap->mode & SOAP_XML_STRICT) && maxlen >= 0 && l > maxlen)

	test	DWORD PTR [ebx+8], 4096			; 00001000H
	je	SHORT $LN30@soap_wstri@2
	mov	eax, DWORD PTR _maxlen$[esp+16]
	test	eax, eax
	jl	SHORT $LN30@soap_wstri@2
	cmp	DWORD PTR _l$[esp+16], eax
	jg	SHORT $LN69@soap_wstri@2
$LN30@soap_wstri@2:

; 9000 :       return NULL;
; 9001 :     for (i = 0; i < SOAP_BLKLEN; i++)

	mov	eax, DWORD PTR _i$[esp+20]
	inc	eax
	cmp	eax, 256				; 00000100H
	mov	DWORD PTR _i$[esp+20], eax
	jl	$LL89@soap_wstri@2

; 9074 :       }
; 9075 :     }
; 9076 :   }

	jmp	$LL34@soap_wstri@2
$LN76@soap_wstri@2:
	pop	edi
	pop	esi
	pop	ebp

; 8997 :     return NULL;
; 8998 :   for (;;)
; 8999 :   { if (!(s = (wchar_t*)soap_push_block(soap, sizeof(wchar_t)*SOAP_BLKLEN)))

	mov	DWORD PTR [ebx+90460], 20		; 00000014H

; 9073 :         return NULL;

	xor	eax, eax
	pop	ebx

; 9087 : #ifdef WITH_DOM
; 9088 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 9089 :     soap->dom->wide = s;
; 9090 : #endif
; 9091 :   return s;
; 9092 : }

	pop	ecx
	ret	0
$end$81770:

; 9077 : end:
; 9078 :   soap_unget(soap, c);
; 9079 :   *s = '\0';

	xor	edx, edx
	mov	DWORD PTR [ebx+12436], eax
	mov	WORD PTR [esi], dx

; 9080 :   soap_size_block(soap, sizeof(wchar_t) * (i + 1));

	mov	eax, DWORD PTR [ebx+92]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[esp+20]
	lea	edx, DWORD PTR [edx+edx+2]
	test	ecx, ecx
	je	SHORT $LN56@soap_wstri@2
	mov	esi, edx
	sub	esi, DWORD PTR [ecx+4]
	add	DWORD PTR [eax+8], esi
	mov	eax, DWORD PTR [ebx+92]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
$LN56@soap_wstri@2:

; 9081 :   if ((soap->mode & SOAP_XML_STRICT) && l < minlen)

	test	DWORD PTR [ebx+8], 4096			; 00001000H
	je	SHORT $LN1@soap_wstri@2
	mov	edx, DWORD PTR _l$[esp+16]
	cmp	edx, DWORD PTR _minlen$[esp+16]

; 9082 :   { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "String too short: %ld chars, minlen=%ld\n", l, minlen));
; 9083 :     soap->error = SOAP_LENGTH;
; 9084 :     return NULL;

	jl	SHORT $LN69@soap_wstri@2
$LN1@soap_wstri@2:
	pop	edi
	pop	esi
	pop	ebp

; 9085 :   }
; 9086 :   s = (wchar_t*)soap_save_block(soap, NULL, 0);

	mov	eax, ebx
	pop	ebx

; 9087 : #ifdef WITH_DOM
; 9088 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 9089 :     soap->dom->wide = s;
; 9090 : #endif
; 9091 :   return s;
; 9092 : }

	add	esp, 4

; 9085 :   }
; 9086 :   s = (wchar_t*)soap_save_block(soap, NULL, 0);

	jmp	_soap_save_block
$LN69@soap_wstri@2:

; 9071 :       { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "String too long: maxlen=%ld\n", maxlen));
; 9072 :         soap->error = SOAP_LENGTH;

	mov	DWORD PTR [ebx+90460], 45		; 0000002dH
$LN94@soap_wstri@2:
	pop	edi
	pop	esi
	pop	ebp

; 9073 :         return NULL;

	xor	eax, eax
	pop	ebx

; 9087 : #ifdef WITH_DOM
; 9088 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 9089 :     soap->dom->wide = s;
; 9090 : #endif
; 9091 :   return s;
; 9092 : }

	pop	ecx
	ret	0
	npad	2
$LN97@soap_wstri@2:
	DD	$LN18@soap_wstri@2
	DD	$LN19@soap_wstri@2
	DD	$LN20@soap_wstri@2
	DD	$LN24@soap_wstri@2
	DD	$LN21@soap_wstri@2
	DD	$LN8@soap_wstri@2
	DD	$LN17@soap_wstri@2
	DD	$LN14@soap_wstri@2
	DD	$LN11@soap_wstri@2
	DD	$LN5@soap_wstri@2
$LN82@soap_wstri@2:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	7
	DB	9
	DB	8
_soap_wstring_in ENDP
_TEXT	ENDS
PUBLIC	_soap$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_soap_string_in
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$GSCopy$ = -36					; size = 4
_t$ = -32						; size = 4
_n$ = -28						; size = 4
_l$ = -24						; size = 4
_i$ = -20						; size = 4
_k$81590 = -16						; size = 4
_buf$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_flag$ = 8						; size = 4
_soap_string_in PROC
; _soap$ = ecx

; 8409 : { register char *s;

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+36], eax
	push	ebx

; 8410 :   char *t = NULL;

	xor	ebx, ebx
	push	esi
	mov	esi, ecx
	push	edi

; 8688 : #else
; 8689 :     register size_t k = SOAP_BLKLEN;
; 8690 :     if (!(s = (char*)soap_push_block(soap, k)))
; 8691 :       return NULL;
; 8692 : #endif
; 8693 :     for (i = 0; i < k; i++)

	mov	DWORD PTR _soap$GSCopy$[esp+48], esi
	mov	DWORD PTR _t$[esp+48], ebx
	mov	DWORD PTR _l$[esp+48], ebx
	mov	DWORD PTR _n$[esp+48], ebx
	cmp	WORD PTR [esi+87308], bx
	je	$LN64@soap_strin@2

; 8411 :   register size_t i;
; 8412 :   register long l = 0;
; 8413 :   register int n = 0;
; 8414 :   register int m = 0;
; 8415 :   register soap_wchar c;
; 8416 : #if !defined(WITH_LEANER) && defined(HAVE_WCTOMB)
; 8417 :   char buf[MB_LEN_MAX > 8 ? MB_LEN_MAX : 8];
; 8418 : #else
; 8419 :   char buf[8];
; 8420 : #endif
; 8421 :   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Reading string content\n"));
; 8422 :   if (soap->peeked)
; 8423 :   { if (!soap->body)

	cmp	WORD PTR [esi+12442], bx

; 8424 :       return NULL;

	je	$LN88@soap_strin@2

; 8425 :     if (*soap->tag)

	cmp	BYTE PTR [esi+80052], bl
	lea	eax, DWORD PTR [esi+80052]
	je	$LN64@soap_strin@2

; 8426 :     {
; 8427 : #ifndef WITH_LEAN
; 8428 :       struct soap_attribute *tp;
; 8429 :       t = soap->tmpbuf;

	lea	edi, DWORD PTR [esi+79028]

; 8430 :       *t = '<';
; 8431 :       t[sizeof(soap->tmpbuf)-1] = '\0';
; 8432 :       strncpy(t + 1, soap->tag, sizeof(soap->tmpbuf) - 2);

	push	1022					; 000003feH
	push	eax
	lea	eax, DWORD PTR [edi+1]
	mov	BYTE PTR [edi], 60			; 0000003cH
	push	eax
	mov	BYTE PTR [edi+1023], bl
	call	_strncpy

; 8433 :       t += strlen(t);

	mov	eax, edi
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL91@soap_strin@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL91@soap_strin@2

; 8434 :       for (tp = soap->attributes; tp; tp = tp->next)

	mov	ebx, DWORD PTR [esi+87292]
	sub	eax, edx
	add	edi, eax
	test	ebx, ebx
	je	SHORT $LN83@soap_strin@2
$LN63@soap_strin@2:

; 8435 :       { if (tp->visible)

	cmp	WORD PTR [ebx+16], 0
	je	SHORT $LN62@soap_strin@2

; 8436 :         { if (t >= soap->tmpbuf + sizeof(soap->tmpbuf) - 2)

	mov	esi, DWORD PTR _soap$GSCopy$[esp+48]
	add	esi, 80050				; 000138b2H
	cmp	edi, esi
	jae	SHORT $LN83@soap_strin@2

; 8437 :             break;
; 8438 :           *t++ = ' ';

	mov	BYTE PTR [edi], 32			; 00000020H
	inc	edi

; 8439 :           strcpy(t, tp->name);

	lea	eax, DWORD PTR [ebx+18]
	mov	edx, edi
	sub	edx, eax
$LL69@soap_strin@2:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL69@soap_strin@2

; 8440 :           t += strlen(t);

	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
$LL92@soap_strin@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL92@soap_strin@2
	sub	eax, edx
	add	edi, eax

; 8441 :           if (t >= soap->tmpbuf + sizeof(soap->tmpbuf) - 2)

	cmp	edi, esi
	jae	SHORT $LN83@soap_strin@2

; 8442 :             break;
; 8443 :           if (tp->value)

	cmp	DWORD PTR [ebx+4], 0
	je	SHORT $LN62@soap_strin@2

; 8444 :           { *t++ = '=';

	mov	BYTE PTR [edi], 61			; 0000003dH
	inc	edi

; 8445 :             *t++ = '"';

	mov	BYTE PTR [edi], 34			; 00000022H

; 8446 :             strcpy(t, tp->value);

	mov	ecx, DWORD PTR [ebx+4]
	inc	edi
	mov	edx, edi
$LL70@soap_strin@2:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL70@soap_strin@2

; 8447 :             t += strlen(t);

	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
$LL93@soap_strin@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL93@soap_strin@2
	sub	eax, edx
	add	edi, eax

; 8448 :             *t++ = '"';

	mov	BYTE PTR [edi], 34			; 00000022H
	inc	edi
$LN62@soap_strin@2:
	mov	ebx, DWORD PTR [ebx]
	test	ebx, ebx
	jne	SHORT $LN63@soap_strin@2
$LN83@soap_strin@2:

; 8449 :           }
; 8450 :         }
; 8451 :       }
; 8452 :       *t++ = '>';
; 8453 :       *t = '\0';
; 8454 :       t = soap->tmpbuf;

	mov	edx, DWORD PTR _soap$GSCopy$[esp+48]
	lea	ebx, DWORD PTR [edx+79028]
	mov	BYTE PTR [edi], 62			; 0000003eH
	mov	BYTE PTR [edi+1], 0
	mov	DWORD PTR _t$[esp+48], ebx

; 8455 :       m = (int)strlen(soap->tmpbuf);

	lea	ecx, DWORD PTR [ebx+1]
$LL94@soap_strin@2:
	mov	al, BYTE PTR [ebx]
	inc	ebx
	test	al, al
	jne	SHORT $LL94@soap_strin@2
	sub	ebx, ecx

; 8456 : #endif
; 8457 :       n = 1;
; 8458 :       soap->peeked = 0;

	xor	ecx, ecx
	mov	DWORD PTR _n$[esp+48], 1
	mov	WORD PTR [edx+87308], cx
$LN64@soap_strin@2:

; 8459 :     }
; 8460 :   }
; 8461 : #ifdef WITH_CDATA
; 8462 :   if (!flag)
; 8463 :   { register int state = 0;
; 8464 : #ifdef WITH_FAST
; 8465 :     soap->labidx = 0;			/* use look-aside buffer */
; 8466 : #else
; 8467 :     if (soap_new_block(soap))
; 8468 :       return NULL;
; 8469 : #endif
; 8470 :     for (;;)
; 8471 :     {
; 8472 : #ifdef WITH_FAST
; 8473 :       register size_t k;
; 8474 :       if (soap_append_lab(soap, NULL, 0))	/* allocate more space in look-aside buffer if necessary */
; 8475 :         return NULL;
; 8476 :       s = soap->labbuf + soap->labidx;	/* space to populate */
; 8477 :       k = soap->lablen - soap->labidx;	/* number of bytes available */
; 8478 :       soap->labidx = soap->lablen;	/* claim this space */
; 8479 : #else
; 8480 :       register size_t k = SOAP_BLKLEN;
; 8481 :       if (!(s = (char*)soap_push_block(soap, k)))
; 8482 :         return NULL;
; 8483 : #endif
; 8484 :       for (i = 0; i < k; i++)
; 8485 :       { if (m > 0)
; 8486 :         { *s++ = *t++;	/* copy multibyte characters */
; 8487 :           m--;
; 8488 :           continue;
; 8489 :         }
; 8490 :         c = soap_getchar(soap);
; 8491 :         if ((int)c == EOF)
; 8492 :           goto end;
; 8493 :         if (c >= 0x80 && state != 1 && !(soap->mode & SOAP_ENC_LATIN))
; 8494 :         { soap_unget(soap, c);
; 8495 :           c = soap_getutf8(soap);
; 8496 :           if (soap->mode & SOAP_C_UTFSTRING)
; 8497 :           { if ((c & 0x80000000) && c >= -0x7FFFFF80 && c < SOAP_AP)
; 8498 :             { c &= 0x7FFFFFFF;
; 8499 :               t = buf;
; 8500 :               if (c < 0x0800)
; 8501 :                 *t++ = (char)(0xC0 | ((c >> 6) & 0x1F));
; 8502 :               else
; 8503 :               { if (c < 0x010000)
; 8504 :                   *t++ = (char)(0xE0 | ((c >> 12) & 0x0F));
; 8505 :                 else
; 8506 :                 { if (c < 0x200000)
; 8507 :                     *t++ = (char)(0xF0 | ((c >> 18) & 0x07));
; 8508 :                   else
; 8509 :                   { if (c < 0x04000000)
; 8510 :                       *t++ = (char)(0xF8 | ((c >> 24) & 0x03));
; 8511 :                     else
; 8512 :                     { *t++ = (char)(0xFC | ((c >> 30) & 0x01));
; 8513 :                       *t++ = (char)(0x80 | ((c >> 24) & 0x3F));
; 8514 :                     }
; 8515 :                     *t++ = (char)(0x80 | ((c >> 18) & 0x3F));
; 8516 :                   }
; 8517 :                   *t++ = (char)(0x80 | ((c >> 12) & 0x3F));
; 8518 :                 }
; 8519 :                 *t++ = (char)(0x80 | ((c >> 6) & 0x3F));
; 8520 :               }
; 8521 :               *t++ = (char)(0x80 | (c & 0x3F));
; 8522 :               m = (int)(t - buf) - 1;
; 8523 :               t = buf;
; 8524 :               *s++ = *t++;
; 8525 :               continue;
; 8526 :             }
; 8527 :           }
; 8528 :         }
; 8529 :         switch (state)
; 8530 :         { case 1:
; 8531 :             if (c == ']')
; 8532 :               state = 4;
; 8533 :             *s++ = c;
; 8534 :             continue;
; 8535 :           case 2:
; 8536 :             if (c == '-')
; 8537 :               state = 6;
; 8538 :             *s++ = c;
; 8539 :             continue;
; 8540 :           case 3:
; 8541 :             if (c == '?')
; 8542 :               state = 8;
; 8543 :             *s++ = c;
; 8544 :             continue;
; 8545 :           /* CDATA */
; 8546 :           case 4:
; 8547 :             if (c == ']')
; 8548 :               state = 5;
; 8549 :             else
; 8550 :               state = 1;
; 8551 :             *s++ = c;
; 8552 :             continue;
; 8553 :           case 5:
; 8554 :             if (c == '>')
; 8555 :               state = 0;
; 8556 :             else
; 8557 :               state = 1;
; 8558 :             *s++ = c;
; 8559 :             continue;
; 8560 :           /* comment */
; 8561 :           case 6:
; 8562 :             if (c == '-')
; 8563 :               state = 7;
; 8564 :             else
; 8565 :               state = 2;
; 8566 :             *s++ = c;
; 8567 :             continue;
; 8568 :           case 7:
; 8569 :             if (c == '>')
; 8570 :               state = 0;
; 8571 :             else
; 8572 :               state = 2;
; 8573 :             *s++ = c;
; 8574 :             continue;
; 8575 :           /* PI */
; 8576 :           case 8:
; 8577 :             if (c == '>')
; 8578 :               state = 0;
; 8579 :             else
; 8580 :               state = 3;
; 8581 :             *s++ = c;
; 8582 :             continue;
; 8583 :         }
; 8584 :         switch (c)
; 8585 :         {
; 8586 :         case '/':
; 8587 :           if (n > 0)
; 8588 :           { c = soap_getchar(soap);
; 8589 :             if (c == '>')
; 8590 :               n--;
; 8591 :             soap_unget(soap, c);
; 8592 :           }
; 8593 :           *s++ = '/';
; 8594 :           break;
; 8595 :         case '<':
; 8596 :           c = soap_getchar(soap);
; 8597 :           if (c == '/')
; 8598 :           { if (n == 0)
; 8599 :             { c = SOAP_TT;
; 8600 :               goto end;
; 8601 :             }
; 8602 :             n--;
; 8603 :           }
; 8604 :           else if (c == '!')
; 8605 :           { c = soap_getchar(soap);
; 8606 :             if (c == '[')
; 8607 :             { do c = soap_getchar(soap);
; 8608 :               while ((int)c != EOF && c != '[');
; 8609 :               if ((int)c == EOF)
; 8610 :                  goto end;
; 8611 :               t = (char*)"![CDATA[";
; 8612 :               m = 8;
; 8613 :               state = 1;
; 8614 :             }
; 8615 :             else if (c == '-')
; 8616 :             { if ((c = soap_getchar(soap)) == '-')
; 8617 :                 state = 2;
; 8618 :               t = (char*)"!-";
; 8619 :               m = 2;
; 8620 :               soap_unget(soap, c);
; 8621 :             }
; 8622 :             else
; 8623 :             { t = (char*)"!";
; 8624 :               m = 1;
; 8625 :               soap_unget(soap, c);
; 8626 :             }
; 8627 :             *s++ = '<';
; 8628 :             break;
; 8629 :           }
; 8630 :           else if (c == '?')
; 8631 :             state = 3;
; 8632 :           else
; 8633 :             n++;
; 8634 :           soap_unget(soap, c);
; 8635 :           *s++ = '<';
; 8636 :           break;
; 8637 :         case '>':
; 8638 :           *s++ = '>';
; 8639 :           break;
; 8640 :         case '"':
; 8641 :           *s++ = '"';
; 8642 :           break;
; 8643 :         default:
; 8644 : #ifndef WITH_LEANER
; 8645 : #ifdef HAVE_WCTOMB
; 8646 :           if (soap->mode & SOAP_C_MBSTRING)
; 8647 :           { m = wctomb(buf, c & 0x7FFFFFFF);
; 8648 :             if (m >= 1 && m <= (int)MB_CUR_MAX)
; 8649 :             { t = buf;
; 8650 :               *s++ = *t++;
; 8651 :               m--;
; 8652 :             }
; 8653 :             else
; 8654 :             { *s++ = SOAP_UNKNOWN_CHAR;
; 8655 :               m = 0;
; 8656 :             }
; 8657 :           }
; 8658 :           else
; 8659 : #endif
; 8660 : #endif
; 8661 :             *s++ = (char)(c & 0xFF);
; 8662 :         }
; 8663 :         l++;
; 8664 :         if ((soap->mode & SOAP_XML_STRICT) && maxlen >= 0 && l > maxlen)
; 8665 :         { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "String too long: maxlen=%ld\n", maxlen));
; 8666 :           soap->error = SOAP_LENGTH;
; 8667 :           return NULL;
; 8668 :         }
; 8669 :       }
; 8670 :     }
; 8671 :   }
; 8672 : #endif
; 8673 : #ifdef WITH_FAST
; 8674 :   soap->labidx = 0;			/* use look-aside buffer */

	mov	esi, DWORD PTR _soap$GSCopy$[esp+48]

; 8675 : #else
; 8676 :   if (soap_new_block(soap))
; 8677 :     return NULL;
; 8678 : #endif
; 8679 :   for (;;)
; 8680 :   {
; 8681 : #ifdef WITH_FAST
; 8682 :     register size_t k;
; 8683 :     if (soap_append_lab(soap, NULL, 0))	/* allocate more space in look-aside buffer if necessary */

	push	0
	push	0
	mov	DWORD PTR [esi+12464], 0
	call	_soap_append_lab
	add	esp, 8
	test	eax, eax
	jne	$LN88@soap_strin@2
	npad	2
$LL56@soap_strin@2:

; 8685 :     s = soap->labbuf + soap->labidx;	/* space to populate */

	mov	edx, DWORD PTR _soap$GSCopy$[esp+48]
	mov	eax, DWORD PTR [edx+12464]

; 8686 :     k = soap->lablen - soap->labidx;	/* number of bytes available */

	mov	ecx, DWORD PTR [edx+12460]
	mov	edi, DWORD PTR [edx+12456]
	mov	esi, ecx
	add	edi, eax
	sub	esi, eax
	mov	DWORD PTR _k$81590[esp+48], esi

; 8687 :     soap->labidx = soap->lablen;	/* claim this space */

	mov	DWORD PTR [edx+12464], ecx

; 8688 : #else
; 8689 :     register size_t k = SOAP_BLKLEN;
; 8690 :     if (!(s = (char*)soap_push_block(soap, k)))
; 8691 :       return NULL;
; 8692 : #endif
; 8693 :     for (i = 0; i < k; i++)

	mov	DWORD PTR _i$[esp+48], 0
	je	$LN51@soap_strin@2
	mov	esi, DWORD PTR _t$[esp+48]
$LN53@soap_strin@2:

; 8694 :     { if (m > 0)

	test	ebx, ebx
	jle	SHORT $LN50@soap_strin@2

; 8695 :       { *s++ = *t++;	/* copy multibyte characters */

	mov	al, BYTE PTR [esi]
	inc	esi
	mov	BYTE PTR [edi], al
	inc	edi
	mov	DWORD PTR _t$[esp+48], esi

; 8696 :         m--;

	dec	ebx

; 8697 :         continue;

	jmp	$LN52@soap_strin@2
$LN50@soap_strin@2:

; 8698 :       }
; 8699 :       if (soap->mode & SOAP_C_UTFSTRING)

	test	DWORD PTR [edx+8], 2097152		; 00200000H

; 8700 :       { if (((c = soap_get(soap)) & 0x80000000) && c >= -0x7FFFFF80 && c < SOAP_AP)

	mov	eax, DWORD PTR _soap$GSCopy$[esp+48]
	je	$LN49@soap_strin@2
	call	_soap_get
	test	eax, eax
	jns	$LN39@soap_strin@2
	lea	ecx, DWORD PTR [eax+2147483520]
	cmp	ecx, 2147483513				; 7fffff79H
	ja	$LN39@soap_strin@2

; 8701 :         { c &= 0x7FFFFFFF;

	and	eax, 2147483647				; 7fffffffH

; 8702 :           t = buf;
; 8703 :           if (c < 0x0800)

	cmp	eax, 2048				; 00000800H
	jge	SHORT $LN47@soap_strin@2

; 8704 :             *t++ = (char)(0xC0 | ((c >> 6) & 0x1F));

	mov	edx, eax
	sar	edx, 6
	and	dl, 31					; 0000001fH
	or	dl, -64					; ffffffc0H
	mov	BYTE PTR _buf$[esp+48], dl
	lea	ecx, DWORD PTR _buf$[esp+49]

; 8705 :           else

	jmp	$LN46@soap_strin@2
$LN47@soap_strin@2:

; 8706 :           { if (c < 0x010000)

	cmp	eax, 65536				; 00010000H
	jge	SHORT $LN45@soap_strin@2

; 8707 :               *t++ = (char)(0xE0 | ((c >> 12) & 0x0F));

	mov	ecx, eax
	sar	ecx, 12					; 0000000cH
	and	cl, 15					; 0000000fH
	or	cl, -32					; ffffffe0H
	mov	BYTE PTR _buf$[esp+48], cl
	lea	ecx, DWORD PTR _buf$[esp+49]

; 8708 :             else

	jmp	SHORT $LN44@soap_strin@2
$LN45@soap_strin@2:

; 8709 :             { if (c < 0x200000)

	cmp	eax, 2097152				; 00200000H
	jge	SHORT $LN43@soap_strin@2

; 8710 :                 *t++ = (char)(0xF0 | ((c >> 18) & 0x07));

	mov	edx, eax
	sar	edx, 18					; 00000012H
	and	dl, 7
	or	dl, -16					; fffffff0H
	mov	BYTE PTR _buf$[esp+48], dl
	lea	ecx, DWORD PTR _buf$[esp+49]

; 8711 :               else

	jmp	SHORT $LN42@soap_strin@2
$LN43@soap_strin@2:

; 8712 :               { if (c < 0x04000000)
; 8713 :                   *t++ = (char)(0xF8 | ((c >> 24) & 0x03));

	mov	ecx, eax
	sar	ecx, 24					; 00000018H
	cmp	eax, 67108864				; 04000000H
	jge	SHORT $LN41@soap_strin@2
	and	cl, 3
	or	cl, -8					; fffffff8H
	mov	BYTE PTR _buf$[esp+48], cl
	lea	ecx, DWORD PTR _buf$[esp+49]

; 8714 :                 else

	jmp	SHORT $LN40@soap_strin@2
$LN41@soap_strin@2:

; 8715 :                 { *t++ = (char)(0xFC | ((c >> 30) & 0x01));

	mov	edx, eax
	sar	edx, 30					; 0000001eH
	and	dl, 1

; 8716 :                   *t++ = (char)(0x80 | ((c >> 24) & 0x3F));

	and	cl, 63					; 0000003fH
	or	dl, -4					; fffffffcH
	or	cl, -128				; ffffff80H
	mov	BYTE PTR _buf$[esp+49], cl
	mov	BYTE PTR _buf$[esp+48], dl
	lea	ecx, DWORD PTR _buf$[esp+50]
$LN40@soap_strin@2:

; 8717 :                 }
; 8718 :                 *t++ = (char)(0x80 | ((c >> 18) & 0x3F));

	mov	edx, eax
	sar	edx, 18					; 00000012H
	and	dl, 63					; 0000003fH
	or	dl, -128				; ffffff80H
	mov	BYTE PTR [ecx], dl
	inc	ecx
$LN42@soap_strin@2:

; 8719 :               }
; 8720 :               *t++ = (char)(0x80 | ((c >> 12) & 0x3F));

	mov	edx, eax
	sar	edx, 12					; 0000000cH
	and	dl, 63					; 0000003fH
	or	dl, -128				; ffffff80H
	mov	BYTE PTR [ecx], dl
	inc	ecx
$LN44@soap_strin@2:

; 8721 :             }
; 8722 :             *t++ = (char)(0x80 | ((c >> 6) & 0x3F));

	mov	edx, eax
	sar	edx, 6
	and	dl, 63					; 0000003fH
	or	dl, -128				; ffffff80H
	mov	BYTE PTR [ecx], dl
	inc	ecx
$LN46@soap_strin@2:

; 8723 :           }
; 8724 :           *t++ = (char)(0x80 | (c & 0x3F));

	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [ecx], al

; 8725 :           m = (int)(t - buf) - 1;

	lea	eax, DWORD PTR _buf$[esp+48]
	sub	ecx, eax
	mov	ebx, ecx

; 8726 :           t = buf;
; 8727 :           *s++ = *t++;

	mov	cl, BYTE PTR _buf$[esp+48]
	lea	esi, DWORD PTR _buf$[esp+49]
	mov	BYTE PTR [edi], cl
	inc	edi
	mov	DWORD PTR _t$[esp+48], esi

; 8728 :           continue;

	jmp	$LN103@soap_strin@2
$LN49@soap_strin@2:

; 8729 :         }
; 8730 :       }
; 8731 :       else
; 8732 :         c = soap_getutf8(soap);

	call	_soap_getutf8
$LN39@soap_strin@2:

; 8733 :       switch (c)

	cmp	eax, -6					; fffffffaH
	jg	$LN71@soap_strin@2
	je	$LN30@soap_strin@2
	lea	ecx, DWORD PTR [eax+2147483614]
	cmp	ecx, 28					; 0000001cH
	ja	$LN11@soap_strin@2
	movzx	edx, BYTE PTR $LN95@soap_strin@2[ecx]
	jmp	DWORD PTR $LN105@soap_strin@2[edx*4]
$LN26@soap_strin@2:

; 8765 :       case (soap_wchar)('<' | 0x80000000):
; 8766 :         if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN25@soap_strin@2

; 8767 :           *s++ = '<';

	mov	BYTE PTR [edi], 60			; 0000003cH

; 8768 :         else

	jmp	$LN104@soap_strin@2
$LN25@soap_strin@2:

; 8769 :         { *s++ = '&';
; 8770 :           t = (char*)"lt;";

	mov	esi, OFFSET ??_C@_03MAABEHOM@lt?$DL?$AA@
	mov	BYTE PTR [edi], 38			; 00000026H
	mov	DWORD PTR _t$[esp+48], esi

; 8771 :           m = 3;

	mov	ebx, 3

; 8772 :         }
; 8773 :         break;

	jmp	$LN104@soap_strin@2
$LN23@soap_strin@2:

; 8774 :       case (soap_wchar)('>' | 0x80000000):
; 8775 :         if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN22@soap_strin@2
$LN32@soap_strin@2:

; 8776 :           *s++ = '>';

	mov	BYTE PTR [edi], 62			; 0000003eH

; 8777 :         else

	jmp	$LN104@soap_strin@2
$LN22@soap_strin@2:

; 8778 :         { *s++ = '&';
; 8779 :           t = (char*)"gt;";

	mov	esi, OFFSET ??_C@_03BHAAMAON@gt?$DL?$AA@
	mov	BYTE PTR [edi], 38			; 00000026H
	mov	DWORD PTR _t$[esp+48], esi

; 8780 :           m = 3;

	mov	ebx, 3

; 8781 :         }
; 8782 :         break;

	jmp	$LN104@soap_strin@2
$LN20@soap_strin@2:

; 8783 :       case (soap_wchar)('&' | 0x80000000):
; 8784 :         if (flag)
; 8785 :           *s++ = '&';

	mov	BYTE PTR [edi], 38			; 00000026H
	inc	edi
	cmp	DWORD PTR _flag$[ebp], 0

; 8786 :         else

	jne	$LN5@soap_strin@2

; 8787 :         { *s++ = '&';
; 8788 :           t = (char*)"amp;";

	mov	esi, OFFSET ??_C@_04DMIAPOKJ@amp?$DL?$AA@
	mov	DWORD PTR _t$[esp+48], esi

; 8789 :           m = 4;

	mov	ebx, 4

; 8790 :         }
; 8791 :         break;

	jmp	$LN5@soap_strin@2
$LN17@soap_strin@2:

; 8792 :       case (soap_wchar)('"' | 0x80000000):
; 8793 :         if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN16@soap_strin@2
$LN31@soap_strin@2:

; 8794 :           *s++ = '"';

	mov	BYTE PTR [edi], 34			; 00000022H

; 8795 :         else

	jmp	$LN104@soap_strin@2
$LN16@soap_strin@2:

; 8796 :         { *s++ = '&';
; 8797 :           t = (char*)"quot;";

	mov	esi, OFFSET ??_C@_05LDHOCHGG@quot?$DL?$AA@
	mov	BYTE PTR [edi], 38			; 00000026H
	mov	DWORD PTR _t$[esp+48], esi

; 8798 :           m = 5;

	mov	ebx, 5

; 8799 :         }
; 8800 :         break;

	jmp	$LN104@soap_strin@2
$LN14@soap_strin@2:

; 8801 :       case (soap_wchar)('\'' | 0x80000000):
; 8802 :         if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN13@soap_strin@2
$LN30@soap_strin@2:

; 8803 :           *s++ = '\'';

	mov	BYTE PTR [edi], 39			; 00000027H

; 8804 :         else

	jmp	$LN104@soap_strin@2
$LN13@soap_strin@2:

; 8805 :         { *s++ = '&';
; 8806 :           t = (char*)"apos;";

	mov	esi, OFFSET ??_C@_05HNAHLMAI@apos?$DL?$AA@
	mov	BYTE PTR [edi], 38			; 00000026H
	mov	DWORD PTR _t$[esp+48], esi

; 8807 :           m = 5;

	mov	ebx, 5

; 8808 :         }
; 8809 :         break;

	jmp	$LN104@soap_strin@2
$LN71@soap_strin@2:

; 8733 :       switch (c)

	lea	ecx, DWORD PTR [eax+5]
	cmp	ecx, 52					; 00000034H
	ja	SHORT $LN11@soap_strin@2
	movzx	ecx, BYTE PTR $LN96@soap_strin@2[ecx]
	jmp	DWORD PTR $LN106@soap_strin@2[ecx*4]
$LN36@soap_strin@2:

; 8734 :       {
; 8735 :       case SOAP_TT:
; 8736 :         if (n == 0)

	cmp	DWORD PTR _n$[esp+48], 0
	je	$end$81626

; 8737 :           goto end;
; 8738 :         n--;

	mov	ebx, 1
	sub	DWORD PTR _n$[esp+48], ebx

; 8739 :         *s++ = '<';
; 8740 :         t = (char*)"/";

	mov	esi, OFFSET ??_C@_01KMDKNFGN@?1?$AA@
	mov	BYTE PTR [edi], 60			; 0000003cH
	add	edi, ebx
	mov	DWORD PTR _t$[esp+48], esi

; 8741 :         m = 1;
; 8742 :         break;

	jmp	$LN5@soap_strin@2
$LN33@soap_strin@2:

; 8743 :       case SOAP_LT:
; 8744 :         n++;

	inc	DWORD PTR _n$[esp+48]

; 8745 :         *s++ = '<';

	mov	BYTE PTR [edi], 60			; 0000003cH

; 8746 :         break;

	jmp	SHORT $LN104@soap_strin@2
$LN29@soap_strin@2:

; 8747 :       case SOAP_GT:
; 8748 :         *s++ = '>';
; 8749 :         break;
; 8750 :       case SOAP_QT:
; 8751 :         *s++ = '"';
; 8752 :         break;
; 8753 :       case SOAP_AP:
; 8754 :         *s++ = '\'';
; 8755 :         break;
; 8756 :       case '/':
; 8757 :         if (n > 0)

	cmp	DWORD PTR _n$[esp+48], 0
	jle	SHORT $LN28@soap_strin@2

; 8758 :         { c = soap_get(soap);

	mov	eax, DWORD PTR _soap$GSCopy$[esp+48]
	call	_soap_get

; 8759 :           if (c == SOAP_GT)

	cmp	eax, -4					; fffffffcH
	jne	SHORT $LN27@soap_strin@2

; 8760 :             n--;

	dec	DWORD PTR _n$[esp+48]
$LN27@soap_strin@2:

; 8761 :           soap_unget(soap, c);

	mov	edx, DWORD PTR _soap$GSCopy$[esp+48]
	mov	DWORD PTR [edx+12436], eax
$LN28@soap_strin@2:

; 8762 :         }
; 8763 :         *s++ = '/';

	mov	BYTE PTR [edi], 47			; 0000002fH

; 8764 :         break;

	jmp	SHORT $LN104@soap_strin@2
$LN11@soap_strin@2:

; 8810 :       default:
; 8811 :         if ((int)c == EOF)

	cmp	eax, -1
	je	$end$81626

; 8812 :           goto end;
; 8813 : #ifndef WITH_LEANER
; 8814 : #ifdef HAVE_WCTOMB
; 8815 :         if (soap->mode & SOAP_C_MBSTRING)

	mov	ecx, DWORD PTR _soap$GSCopy$[esp+48]
	test	DWORD PTR [ecx+8], 4194304		; 00400000H
	je	SHORT $LN8@soap_strin@2

; 8816 :         { m = wctomb(buf, c & 0x7FFFFFFF);

	push	eax
	lea	edx, DWORD PTR _buf$[esp+52]
	push	edx
	call	_wctomb
	mov	ebx, eax
	add	esp, 8

; 8817 :           if (m >= 1 && m <= (int)MB_CUR_MAX)

	cmp	ebx, 1
	jl	SHORT $LN7@soap_strin@2
	call	____mb_cur_max_func
	cmp	ebx, eax
	jg	SHORT $LN7@soap_strin@2

; 8818 :           { t = buf;
; 8819 :             *s++ = *t++;

	mov	al, BYTE PTR _buf$[esp+48]
	mov	BYTE PTR [edi], al
	lea	esi, DWORD PTR _buf$[esp+49]
	inc	edi
	mov	DWORD PTR _t$[esp+48], esi

; 8820 :             m--;

	dec	ebx

; 8821 :           }
; 8822 :           else

	jmp	SHORT $LN5@soap_strin@2
$LN7@soap_strin@2:

; 8823 :           { *s++ = SOAP_UNKNOWN_CHAR;

	mov	BYTE PTR [edi], 127			; 0000007fH
	inc	edi

; 8824 :             m = 0;

	xor	ebx, ebx

; 8825 :           }
; 8826 :         }
; 8827 :         else

	jmp	SHORT $LN5@soap_strin@2
$LN8@soap_strin@2:

; 8828 : #endif
; 8829 : #endif
; 8830 :           *s++ = (char)(c & 0xFF);

	mov	BYTE PTR [edi], al
$LN104@soap_strin@2:
	inc	edi
$LN5@soap_strin@2:

; 8831 :       }
; 8832 :       l++;

	inc	DWORD PTR _l$[esp+48]
$LN103@soap_strin@2:
	mov	edx, DWORD PTR _soap$GSCopy$[esp+48]
$LN52@soap_strin@2:

; 8688 : #else
; 8689 :     register size_t k = SOAP_BLKLEN;
; 8690 :     if (!(s = (char*)soap_push_block(soap, k)))
; 8691 :       return NULL;
; 8692 : #endif
; 8693 :     for (i = 0; i < k; i++)

	mov	eax, DWORD PTR _i$[esp+48]
	inc	eax
	mov	DWORD PTR _i$[esp+48], eax
	cmp	eax, DWORD PTR _k$81590[esp+48]
	jb	$LN53@soap_strin@2
$LN51@soap_strin@2:

; 8675 : #else
; 8676 :   if (soap_new_block(soap))
; 8677 :     return NULL;
; 8678 : #endif
; 8679 :   for (;;)
; 8680 :   {
; 8681 : #ifdef WITH_FAST
; 8682 :     register size_t k;
; 8683 :     if (soap_append_lab(soap, NULL, 0))	/* allocate more space in look-aside buffer if necessary */

	mov	esi, DWORD PTR _soap$GSCopy$[esp+48]
	push	0
	push	0
	call	_soap_append_lab
	add	esp, 8
	test	eax, eax
	je	$LL56@soap_strin@2
$LN88@soap_strin@2:

; 8684 :       return NULL;

	xor	eax, eax

; 8865 :   return t;
; 8866 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+36]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$end$81626:

; 8833 :       if ((soap->mode & SOAP_XML_STRICT) && maxlen >= 0 && l > maxlen)
; 8834 :       { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "String too long: maxlen=%ld\n", maxlen));
; 8835 :         soap->error = SOAP_LENGTH;
; 8836 :         return NULL;
; 8837 :       }
; 8838 :     }
; 8839 :   }
; 8840 : end:
; 8841 :   soap_unget(soap, c);

	mov	ecx, DWORD PTR _soap$GSCopy$[esp+48]
	mov	DWORD PTR [ecx+12436], eax

; 8842 :   *s = '\0';

	mov	BYTE PTR [edi], 0

; 8843 : #ifdef WITH_FAST
; 8844 :   t = soap_strdup(soap, soap->labbuf);

	mov	ebx, DWORD PTR [ecx+12456]
	xor	eax, eax
	test	ebx, ebx
	je	SHORT $LN72@soap_strin@2
	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL97@soap_strin@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL97@soap_strin@2
	mov	edi, DWORD PTR _soap$GSCopy$[esp+48]
	sub	eax, edx
	inc	eax
	call	_soap_malloc
	test	eax, eax
	je	SHORT $LN72@soap_strin@2
	mov	esi, eax
	mov	ecx, ebx
	sub	esi, ebx
$LL75@soap_strin@2:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [esi+ecx], dl
	inc	ecx
	test	dl, dl
	jne	SHORT $LL75@soap_strin@2
$LN72@soap_strin@2:

; 8845 : #else
; 8846 :   soap_size_block(soap, i+1);
; 8847 :   t = soap_save_block(soap, NULL, 0);
; 8848 : #endif
; 8849 :   if ((soap->mode & SOAP_XML_STRICT) && l < minlen)

	mov	ecx, DWORD PTR _soap$GSCopy$[esp+48]
	test	DWORD PTR [ecx+8], 4096			; 00001000H
	mov	DWORD PTR _t$[esp+48], eax
	je	SHORT $LN3@soap_strin@2
	cmp	DWORD PTR _l$[esp+48], -1
	jge	SHORT $LN3@soap_strin@2

; 8850 :   { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "String too short: %ld chars, minlen=%ld\n", l, minlen));
; 8851 :     soap->error = SOAP_LENGTH;

	mov	DWORD PTR [ecx+90460], 45		; 0000002dH

; 8852 :     return NULL;

	xor	eax, eax

; 8865 :   return t;
; 8866 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+36]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@soap_strin@2:

; 8853 :   }
; 8854 : #ifdef WITH_DOM
; 8855 :   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 8856 :   { if (flag == 3)
; 8857 :       soap->dom->tail = t;
; 8858 :     else
; 8859 :       soap->dom->data = t;
; 8860 :   }
; 8861 : #endif
; 8862 :   if (flag == 2)

	cmp	DWORD PTR _flag$[ebp], 2
	jne	SHORT $LN1@soap_strin@2

; 8863 :     if (soap_s2QName(soap, t, &t))

	lea	edx, DWORD PTR _t$[esp+48]
	push	edx
	push	eax
	push	ecx
	call	_soap_s2QName
	add	esp, 12					; 0000000cH
	test	eax, eax

; 8864 :       return NULL;

	jne	$LN88@soap_strin@2
$LN1@soap_strin@2:

; 8865 :   return t;
; 8866 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+48]
	mov	eax, DWORD PTR _t$[esp+48]
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN105@soap_strin@2:
	DD	$LN17@soap_strin@2
	DD	$LN20@soap_strin@2
	DD	$LN14@soap_strin@2
	DD	$LN26@soap_strin@2
	DD	$LN23@soap_strin@2
	DD	$LN11@soap_strin@2
$LN95@soap_strin@2:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	4
	npad	3
$LN106@soap_strin@2:
	DD	$LN31@soap_strin@2
	DD	$LN32@soap_strin@2
	DD	$LN36@soap_strin@2
	DD	$LN33@soap_strin@2
	DD	$LN29@soap_strin@2
	DD	$LN11@soap_strin@2
$LN96@soap_strin@2:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
_soap_string_in ENDP
_TEXT	ENDS
PUBLIC	_soap_peek_element
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_t$ = -8						; size = 4
_tq$ = -4						; size = 4
_soap_peek_element PROC
; _soap$ = eax

; 7919 : {

	sub	esp, 8
	push	esi
	mov	esi, eax

; 7920 : #ifdef WITH_DOM
; 7921 :   register struct soap_dom_attribute **att = NULL;
; 7922 :   register char *lead = NULL;
; 7923 : #endif
; 7924 :   register struct soap_attribute *tp, *tq = NULL;
; 7925 :   const char *t;
; 7926 :   register char *s;
; 7927 :   register soap_wchar c;
; 7928 :   register int i;
; 7929 :   if (soap->peeked)

	cmp	WORD PTR [esi+87308], 0
	je	SHORT $LN124@soap_peek_

; 7930 :   { if (!*soap->tag)

	cmp	BYTE PTR [esi+80052], 0

; 7931 :       return soap->error = SOAP_NO_TAG;

	je	$LN316@soap_peek_

; 7932 :     return SOAP_OK;

	xor	eax, eax
	pop	esi

; 8282 : }

	add	esp, 8
	ret	0
$LN124@soap_peek_:

; 7933 :   }
; 7934 :   soap->peeked = 1;

	mov	eax, 1
	mov	WORD PTR [esi+87308], ax

; 7935 :   soap->id[0] = '\0';
; 7936 :   soap->href[0] = '\0';
; 7937 :   soap->type[0] = '\0';
; 7938 :   soap->arrayType[0] = '\0';
; 7939 :   soap->arraySize[0] = '\0';
; 7940 :   soap->arrayOffset[0] = '\0';
; 7941 :   soap->other = 0;
; 7942 :   soap->root = -1;

	or	edx, -1

; 7943 :   soap->position = 0;

	xor	eax, eax
	xor	ecx, ecx
	mov	WORD PTR [esi+87288], dx
	mov	WORD PTR [esi+87222], ax

; 7944 :   soap->null = 0;
; 7945 :   soap->mustUnderstand = 0;

	xor	edx, edx

; 7946 :   c = soap_getutf8(soap);

	mov	eax, esi
	mov	BYTE PTR [esi+81076], 0
	mov	BYTE PTR [esi+82100], 0
	mov	BYTE PTR [esi+83124], 0
	mov	BYTE PTR [esi+84148], 0
	mov	BYTE PTR [esi+85172], 0
	mov	BYTE PTR [esi+86196], 0
	mov	WORD PTR [esi+87220], cx
	mov	WORD PTR [esi+87300], cx
	mov	WORD PTR [esi+87298], dx
	call	_soap_getutf8

; 7947 : #ifdef WITH_DOM
; 7948 :   /* whitespace leading to start tag is not insignificant for DOM */
; 7949 :   if (soap_blank(c))
; 7950 :   { soap->labidx = 0;
; 7951 :     do
; 7952 :     { if (soap_append_lab(soap, NULL, 0))
; 7953 :         return SOAP_EOM;
; 7954 :       s = soap->labbuf + soap->labidx;
; 7955 :       i = soap->lablen - soap->labidx;
; 7956 :       soap->labidx = soap->lablen;
; 7957 :       while (soap_blank(c) && i--)
; 7958 :       { *s++ = c;
; 7959 :         c = soap_getutf8(soap);
; 7960 :       }
; 7961 :     }
; 7962 :     while (soap_blank(c));
; 7963 :     *s = '\0';
; 7964 :     lead = soap_strdup(soap, soap->labbuf);
; 7965 :   }
; 7966 : #else
; 7967 :   while (soap_blank(c))

	test	eax, eax
	jl	SHORT $LN121@soap_peek_
$LL122@soap_peek_:
	cmp	eax, 32					; 00000020H
	jg	SHORT $LN121@soap_peek_

; 7968 :     c = soap_getutf8(soap);

	mov	eax, esi
	call	_soap_getutf8
	test	eax, eax
	jge	SHORT $LL122@soap_peek_
$LN121@soap_peek_:

; 7969 : #endif
; 7970 :   if (c != SOAP_LT)

	cmp	eax, -2					; fffffffeH
	je	SHORT $LN120@soap_peek_

; 7971 :   { *soap->tag = '\0';

	mov	BYTE PTR [esi+80052], 0

; 7972 :     if ((int)c == EOF)

	cmp	eax, -1
	jne	SHORT $LN119@soap_peek_

; 7973 :       return soap->error = SOAP_EOF;

	mov	DWORD PTR [esi+90460], eax
	or	eax, eax
	pop	esi

; 8282 : }

	add	esp, 8
	ret	0
$LN119@soap_peek_:

; 7974 :     soap_unget(soap, c);

	mov	DWORD PTR [esi+12436], eax
$LN316@soap_peek_:

; 7975 : #ifdef WITH_DOM
; 7976 :     /* whitespace leading to end tag is not insignificant for DOM */
; 7977 :     if ((soap->mode & SOAP_XML_DOM) && soap->dom)
; 7978 :       soap->dom->tail = soap_strdup(soap, lead);
; 7979 : #endif
; 7980 :     return soap->error = SOAP_NO_TAG;

	mov	eax, 6
	mov	DWORD PTR [esi+90460], eax
	pop	esi

; 8282 : }

	add	esp, 8
	ret	0
$LN120@soap_peek_:
	push	ebp

; 7981 :   }
; 7982 :   s = soap->tag;

	lea	ebp, DWORD PTR [esi+80052]
	push	ebx
	npad	3
$LL118@soap_peek_:

; 7983 :   do c = soap_get1(soap);

	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN127@soap_peek_
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN192@soap_peek_
$LN127@soap_peek_:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ebx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax

; 7984 :   while (soap_blank(c));

	test	ebx, ebx
	jl	SHORT $LN115@soap_peek_
	cmp	ebx, 32					; 00000020H
	jle	SHORT $LL118@soap_peek_
	jmp	SHORT $LN115@soap_peek_
$LN192@soap_peek_:

; 7983 :   do c = soap_get1(soap);

	or	ebx, -1
$LN115@soap_peek_:
	push	edi

; 7985 :   i = sizeof(soap->tag);

	mov	edi, 1024				; 00000400H

; 7986 :   while (c != '>' && c != '/' && soap_notblank(c) && (int)c != EOF)

	cmp	ebx, 62					; 0000003eH
	je	SHORT $LN290@soap_peek_
$LL114@soap_peek_:
	cmp	ebx, 47					; 0000002fH
	je	SHORT $LN290@soap_peek_
	cmp	ebx, 32					; 00000020H
	jle	SHORT $LN290@soap_peek_
	cmp	ebx, -1
	je	SHORT $LN290@soap_peek_

; 7987 :   { if (--i > 0)

	dec	edi
	test	edi, edi
	jle	SHORT $LN112@soap_peek_

; 7988 :       *s++ = (char)c;

	mov	BYTE PTR [ebp], bl
	inc	ebp
$LN112@soap_peek_:

; 7989 :     c = soap_get1(soap);

	mov	ecx, DWORD PTR [esi+12428]
	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN289@soap_peek_
	call	_soap_recv
	test	eax, eax
	je	SHORT $LN289@soap_peek_
	or	ebx, -1
	jmp	SHORT $LL114@soap_peek_
$LN289@soap_peek_:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ebx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
	cmp	ebx, 62					; 0000003eH
	jne	SHORT $LL114@soap_peek_
$LN290@soap_peek_:

; 7990 :   }
; 7991 :   while (soap_blank(c))

	test	ebx, ebx
	jl	SHORT $LN110@soap_peek_
$LL111@soap_peek_:
	cmp	ebx, 32					; 00000020H
	jg	SHORT $LN110@soap_peek_

; 7992 :     c = soap_get1(soap);

	mov	edx, DWORD PTR [esi+12428]
	cmp	edx, DWORD PTR [esi+12432]
	jb	SHORT $LN131@soap_peek_
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN193@soap_peek_
$LN131@soap_peek_:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ebx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
	test	ebx, ebx
	jge	SHORT $LL111@soap_peek_

; 7990 :   }
; 7991 :   while (soap_blank(c))

	jmp	SHORT $LN110@soap_peek_
$LN193@soap_peek_:

; 7992 :     c = soap_get1(soap);

	or	ebx, -1
$LN110@soap_peek_:

; 7993 :   *s = '\0';
; 7994 : #ifdef WITH_DOM
; 7995 :   if (soap->mode & SOAP_XML_DOM)
; 7996 :   { register struct soap_dom_element *elt;
; 7997 :     elt = (struct soap_dom_element*)soap_malloc(soap, sizeof(struct soap_dom_element));
; 7998 :     if (!elt)
; 7999 :       return soap->error = SOAP_EOM;
; 8000 :     elt->next = NULL;
; 8001 :     elt->nstr = NULL;
; 8002 :     elt->name = soap_strdup(soap, soap->tag);
; 8003 :     elt->prnt = soap->dom;
; 8004 :     elt->elts = NULL;
; 8005 :     elt->atts = NULL;
; 8006 :     elt->data = NULL;
; 8007 :     elt->wide = NULL;
; 8008 :     elt->type = 0;
; 8009 :     elt->node = NULL;
; 8010 :     elt->head = lead;
; 8011 :     elt->tail = NULL;
; 8012 :     elt->soap = soap;
; 8013 :     if (soap->dom)
; 8014 :     { struct soap_dom_element *p = soap->dom->elts;
; 8015 :       if (p)
; 8016 :       { while (p->next)
; 8017 :           p = p->next;
; 8018 :         p->next = elt;
; 8019 :       }
; 8020 :       else
; 8021 :         soap->dom->elts = elt;
; 8022 :     }
; 8023 :     soap->dom = elt;
; 8024 :     att = &elt->atts;
; 8025 :   }
; 8026 : #endif
; 8027 :   soap_pop_namespace(soap);

	mov	edi, esi
	mov	BYTE PTR [ebp], 0
	call	_soap_pop_namespace

; 8028 :   for (tp = soap->attributes; tp; tp = tp->next)

	mov	eax, DWORD PTR [esi+87292]
	test	eax, eax
	je	SHORT $LN156@soap_peek_
$LL109@soap_peek_:

; 8029 :     tp->visible = 0;

	xor	ecx, ecx
	mov	WORD PTR [eax+16], cx
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL109@soap_peek_
$LN156@soap_peek_:

; 8030 :   while ((int)c != EOF && c != '>' && c != '/')

	cmp	ebx, -1
	je	$LN184@soap_peek_
	npad	5
$LL106@soap_peek_:
	cmp	ebx, 62					; 0000003eH
	je	$LN105@soap_peek_
	cmp	ebx, 47					; 0000002fH
	je	$LN105@soap_peek_

; 8031 :   { s = soap->tmpbuf;

	lea	eax, DWORD PTR [esi+79028]
	mov	edi, eax

; 8032 :     i = sizeof(soap->tmpbuf);

	mov	ebp, 1024				; 00000400H

; 8033 :     while (c != '=' && c != '>' && c != '/' && soap_notblank(c) && (int)c != EOF)

	cmp	ebx, 61					; 0000003dH
	je	SHORT $LN284@soap_peek_
$LL104@soap_peek_:
	cmp	ebx, 62					; 0000003eH
	je	SHORT $LN284@soap_peek_
	cmp	ebx, 47					; 0000002fH
	je	SHORT $LN284@soap_peek_
	cmp	ebx, 32					; 00000020H
	jle	SHORT $LN284@soap_peek_
	cmp	ebx, -1
	je	SHORT $LN284@soap_peek_

; 8034 :     { if (--i > 0)

	dec	ebp
	test	ebp, ebp
	jle	SHORT $LN102@soap_peek_

; 8035 :         *s++ = (char)c;

	mov	BYTE PTR [edi], bl
	inc	edi
$LN102@soap_peek_:

; 8036 :       c = soap_get1(soap);

	mov	edx, DWORD PTR [esi+12428]
	cmp	edx, DWORD PTR [esi+12432]
	jb	SHORT $LN288@soap_peek_
	call	_soap_recv
	test	eax, eax
	je	SHORT $LN288@soap_peek_
	or	ebx, -1
	jmp	SHORT $LL104@soap_peek_
$LN288@soap_peek_:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ebx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
	cmp	ebx, 61					; 0000003dH
	jne	SHORT $LL104@soap_peek_
$LN284@soap_peek_:

; 8037 :     }
; 8038 :     *s = '\0';

	mov	BYTE PTR [edi], 0

; 8039 :     if (i == sizeof(soap->tmpbuf))

	cmp	ebp, 1024				; 00000400H
	je	$LN170@soap_peek_

; 8041 : #ifdef WITH_DOM
; 8042 :     /* add attribute name to dom */
; 8043 :     if (att)
; 8044 :     { *att = (struct soap_dom_attribute*)soap_malloc(soap, sizeof(struct soap_dom_attribute));
; 8045 :        if (!*att)
; 8046 :          return soap->error = SOAP_EOM;
; 8047 :        (*att)->next = NULL;
; 8048 :        (*att)->nstr = NULL;
; 8049 :        (*att)->name = soap_strdup(soap, soap->tmpbuf);
; 8050 :        (*att)->data = NULL;
; 8051 :        (*att)->wide = NULL;
; 8052 :        (*att)->soap = soap;
; 8053 :     }
; 8054 : #endif
; 8055 :     if (!strncmp(soap->tmpbuf, "xmlns", 5))

	push	5
	lea	eax, DWORD PTR [esi+79028]
	push	OFFSET ??_C@_05PPEFOGKI@xmlns?$AA@
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN100@soap_peek_

; 8056 :     { if (soap->tmpbuf[5] == ':')

	mov	al, BYTE PTR [esi+79033]
	cmp	al, 58					; 0000003aH
	jne	SHORT $LN99@soap_peek_

; 8057 :         t = soap->tmpbuf + 6;

	lea	eax, DWORD PTR [esi+79034]
	mov	DWORD PTR _t$[esp+24], eax
	jmp	SHORT $LN95@soap_peek_
$LN99@soap_peek_:

; 8058 :       else if (soap->tmpbuf[5])

	xor	ecx, ecx
	test	al, al
	setne	cl
	dec	ecx
	and	ecx, OFFSET _soap_padding
	mov	DWORD PTR _t$[esp+24], ecx

; 8059 :         t = NULL;
; 8060 :       else
; 8061 :         t = SOAP_STR_EOS;
; 8062 :     }
; 8063 :     else

	jmp	SHORT $LN95@soap_peek_
$LN100@soap_peek_:

; 8064 :       t = NULL;

	mov	DWORD PTR _t$[esp+24], 0
$LN95@soap_peek_:

; 8065 :     tq = NULL;
; 8066 :     for (tp = soap->attributes; tp; tq = tp, tp = tp->next)

	mov	ebp, DWORD PTR [esi+87292]
	mov	DWORD PTR _tq$[esp+24], 0
	test	ebp, ebp
	je	SHORT $LN185@soap_peek_
$LL94@soap_peek_:

; 8067 :     { if (!SOAP_STRCMP(tp->name, soap->tmpbuf))

	lea	edi, DWORD PTR [esi+79028]
	lea	eax, DWORD PTR [ebp+18]
	npad	4
$LL200@soap_peek_:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edi]
	jne	SHORT $LN201@soap_peek_
	test	cl, cl
	je	SHORT $LN202@soap_peek_
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edi+1]
	jne	SHORT $LN201@soap_peek_
	add	eax, 2
	add	edi, 2
	test	cl, cl
	jne	SHORT $LL200@soap_peek_
$LN202@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN203@soap_peek_
$LN201@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN203@soap_peek_:
	test	eax, eax
	je	SHORT $LN167@soap_peek_
	mov	DWORD PTR _tq$[esp+24], ebp
	mov	ebp, DWORD PTR [ebp]
	test	ebp, ebp
	jne	SHORT $LL94@soap_peek_

; 8068 :         break;
; 8069 :     }
; 8070 :     if (!tp)

	jmp	SHORT $LN185@soap_peek_
$LN167@soap_peek_:
	test	ebp, ebp
	jne	$LN160@soap_peek_
$LN185@soap_peek_:

; 8071 :     { tp = (struct soap_attribute*)SOAP_MALLOC(soap, sizeof(struct soap_attribute) + strlen(soap->tmpbuf));

	lea	eax, DWORD PTR [esi+79028]
	lea	edx, DWORD PTR [eax+1]
$LL204@soap_peek_:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL204@soap_peek_
	sub	eax, edx
	add	eax, 20					; 00000014H
	push	eax
	call	_malloc
	mov	ebp, eax

; 8072 :       if (!tp)

	xor	edi, edi
	add	esp, 4
	cmp	ebp, edi
	je	$LN174@soap_peek_

; 8073 :         return soap->error = SOAP_EOM;
; 8074 :       strcpy(tp->name, soap->tmpbuf);

	lea	eax, DWORD PTR [esi+79028]
	mov	edx, ebp
	sub	edx, eax
	add	edx, 18					; 00000012H
$LL135@soap_peek_:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL135@soap_peek_

; 8075 :       tp->value = NULL;

	mov	DWORD PTR [ebp+4], edi

; 8076 :       tp->size = 0;

	mov	DWORD PTR [ebp+8], edi

; 8077 :       /* if attribute name is qualified, append it to the end of the list */
; 8078 :       if (tq && strchr(soap->tmpbuf, ':'))

	mov	edi, DWORD PTR _tq$[esp+24]
	test	edi, edi
	je	SHORT $LN88@soap_peek_
	lea	eax, DWORD PTR [esi+79028]
	push	58					; 0000003aH
	push	eax
	call	_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN88@soap_peek_

; 8079 :       { tq->next = tp;

	mov	DWORD PTR [edi], ebp

; 8080 :         tp->next = NULL;

	mov	DWORD PTR [ebp], 0

; 8081 :       }
; 8082 :       else

	jmp	SHORT $LN160@soap_peek_
$LN88@soap_peek_:

; 8083 :       { tp->next = soap->attributes;

	mov	eax, DWORD PTR [esi+87292]
	mov	DWORD PTR [ebp], eax

; 8084 :         soap->attributes = tp;

	mov	DWORD PTR [esi+87292], ebp
$LN160@soap_peek_:

; 8085 :       }
; 8086 :     }
; 8087 :     while (soap_blank(c))

	test	ebx, ebx
	jl	SHORT $LN285@soap_peek_
$LL86@soap_peek_:
	cmp	ebx, 32					; 00000020H
	jg	SHORT $LN285@soap_peek_

; 8088 :       c = soap_get1(soap);

	mov	ecx, DWORD PTR [esi+12428]
	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN136@soap_peek_
	call	_soap_recv
	test	eax, eax
	jne	$LN194@soap_peek_
$LN136@soap_peek_:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ebx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
	test	ebx, ebx
	jge	SHORT $LL86@soap_peek_
$LN285@soap_peek_:

; 8089 :     if (c == '=')

	cmp	ebx, 61					; 0000003dH
	jne	$LN84@soap_peek_
$LL83@soap_peek_:

; 8090 :     { do c = soap_getutf8(soap);

	mov	eax, esi
	call	_soap_getutf8
	mov	ebx, eax

; 8091 :       while (soap_blank(c));

	test	ebx, ebx
	jl	SHORT $LN80@soap_peek_
	cmp	ebx, 32					; 00000020H
	jle	SHORT $LL83@soap_peek_
$LN80@soap_peek_:

; 8092 :       if (c != SOAP_QT && c != SOAP_AP)

	cmp	ebx, -5					; fffffffbH
	je	SHORT $LN79@soap_peek_
	cmp	ebx, -6					; fffffffaH
	je	SHORT $LN79@soap_peek_

; 8093 :       { soap_unget(soap, c);

	mov	DWORD PTR [esi+12436], ebx

; 8094 :         c = ' '; /* blank delimiter */

	mov	ebx, 32					; 00000020H
$LN79@soap_peek_:

; 8095 :       }
; 8096 :       if (soap_getattrval(soap, tp->value, tp->size, c))

	mov	edx, DWORD PTR [ebp+8]
	mov	eax, DWORD PTR [ebp+4]
	push	ebx
	push	edx
	mov	edi, esi
	call	_soap_getattrval
	add	esp, 8
	test	eax, eax
	je	$LL64@soap_peek_

; 8097 :       {
; 8098 : #ifdef WITH_FAST
; 8099 :         if (soap->error != SOAP_EOM)

	cmp	DWORD PTR [esi+90460], 20		; 00000014H
	jne	$LN175@soap_peek_

; 8100 :           return soap->error;
; 8101 :         soap->error = SOAP_OK;

	xor	edi, edi
	mov	DWORD PTR [esi+90460], edi

; 8102 :         if (soap_store_lab(soap, tp->value, tp->size))

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebp+4]
	push	eax
	push	ecx
	mov	DWORD PTR [esi+12464], edi
	call	_soap_append_lab
	add	esp, 8
	test	eax, eax
	jne	$LN175@soap_peek_

; 8103 :           return soap->error;
; 8104 :         if (tp->value)

	mov	eax, DWORD PTR [ebp+4]
	cmp	eax, edi
	je	SHORT $LN162@soap_peek_

; 8105 :           SOAP_FREE(soap, tp->value);

	push	eax
	call	_free
	add	esp, 4
$LN162@soap_peek_:

; 8106 :         for (;;)
; 8107 :         { if (soap_getattrval(soap, soap->labbuf + soap->labidx, soap->lablen - soap->labidx, c))

	mov	ecx, DWORD PTR [esi+12464]
	mov	eax, DWORD PTR [esi+12460]
	sub	eax, ecx
	push	ebx
	push	eax
	mov	eax, DWORD PTR [esi+12456]
	add	eax, ecx
	mov	edi, esi
	call	_soap_getattrval
	add	esp, 8
	test	eax, eax
	je	SHORT $LN72@soap_peek_
	npad	4
$LL74@soap_peek_:

; 8108 :           { if (soap->error != SOAP_EOM)

	cmp	DWORD PTR [esi+90460], 20		; 00000014H
	jne	$LN175@soap_peek_

; 8109 :               return soap->error;
; 8110 :             soap->error = SOAP_OK;
; 8111 :             soap->labidx = soap->lablen;

	mov	ecx, DWORD PTR [esi+12460]

; 8112 :             if (soap_append_lab(soap, NULL, 0))

	push	0
	push	0
	mov	DWORD PTR [esi+90460], 0
	mov	DWORD PTR [esi+12464], ecx
	call	_soap_append_lab
	add	esp, 8
	test	eax, eax
	jne	$LN175@soap_peek_
	mov	ecx, DWORD PTR [esi+12464]
	mov	edx, DWORD PTR [esi+12460]
	mov	eax, DWORD PTR [esi+12456]
	sub	edx, ecx
	push	ebx
	push	edx
	add	eax, ecx
	mov	edi, esi
	call	_soap_getattrval
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL74@soap_peek_
$LN72@soap_peek_:

; 8113 :               return soap->error;
; 8114 :           }
; 8115 :           else
; 8116 :             break;
; 8117 :         }
; 8118 :         if (soap->labidx)

	cmp	DWORD PTR [esi+12464], 0
	je	SHORT $LN68@soap_peek_

; 8119 :           tp->size = soap->lablen;

	mov	eax, DWORD PTR [esi+12460]
	mov	DWORD PTR [ebp+8], eax

; 8120 :         else

	jmp	SHORT $LN66@soap_peek_
$LN194@soap_peek_:

; 8088 :       c = soap_get1(soap);

	or	ebx, -1
$LN84@soap_peek_:

; 8167 :       tp->visible = 1; /* seen this attribute w/o value */

	mov	ecx, 1
	mov	WORD PTR [ebp+16], cx
$LN60@soap_peek_:

; 8168 : #ifdef WITH_DOM
; 8169 :     if (att)
; 8170 :       att = &(*att)->next;
; 8171 : #endif
; 8172 :     if (t && tp->value)

	cmp	DWORD PTR _t$[esp+24], 0
	je	SHORT $LN58@soap_peek_
	mov	ebp, DWORD PTR [ebp+4]
	test	ebp, ebp
	je	SHORT $LN58@soap_peek_

; 8173 :     { if (soap_push_namespace(soap, t, tp->value))

	mov	edx, DWORD PTR _t$[esp+24]
	push	edx
	push	esi
	mov	edi, ebp
	call	_soap_push_namespace
	add	esp, 8
	test	eax, eax
	jne	$LN175@soap_peek_
$LN58@soap_peek_:

; 8030 :   while ((int)c != EOF && c != '>' && c != '/')

	cmp	ebx, -1
	jne	$LL106@soap_peek_
	pop	edi

; 8185 :     return soap->error = SOAP_EOF;

	or	eax, ebx
	pop	ebx
	pop	ebp
	mov	DWORD PTR [esi+90460], eax
	pop	esi

; 8282 : }

	add	esp, 8
	ret	0
$LN68@soap_peek_:

; 8121 :         { tp->size = strlen(soap->labbuf) + 1;

	mov	eax, DWORD PTR [esi+12456]
	lea	edx, DWORD PTR [eax+1]
$LL205@soap_peek_:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL205@soap_peek_
	sub	eax, edx
	inc	eax
	mov	DWORD PTR [ebp+8], eax

; 8122 :           if (tp->size < SOAP_LABLEN)

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN66@soap_peek_

; 8123 :             tp->size = SOAP_LABLEN;

	mov	DWORD PTR [ebp+8], 256			; 00000100H
$LN66@soap_peek_:

; 8124 :         }
; 8125 :         if (!(tp->value = (char*)SOAP_MALLOC(soap, tp->size)))

	mov	ecx, DWORD PTR [ebp+8]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR [ebp+4], eax
	test	eax, eax
	je	$LN174@soap_peek_

; 8127 :         strcpy(tp->value, soap->labbuf);

	mov	ecx, DWORD PTR [esi+12456]
	mov	edx, eax
	npad	1
$LL138@soap_peek_:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL138@soap_peek_
	npad	6
$LL64@soap_peek_:

; 8128 : #else
; 8129 :         size_t n;
; 8130 :         if (soap->error != SOAP_EOM)
; 8131 :           return soap->error;
; 8132 :         soap->error = SOAP_OK;
; 8133 :         if (soap_new_block(soap))
; 8134 :           return soap->error;
; 8135 :         for (;;)
; 8136 :         { if (!(s = (char*)soap_push_block(soap, SOAP_BLKLEN)))
; 8137 :             return soap->error;
; 8138 :           if (soap_getattrval(soap, s, SOAP_BLKLEN, c))
; 8139 :           { if (soap->error != SOAP_EOM)
; 8140 :               return soap->error;
; 8141 :             soap->error = SOAP_OK;
; 8142 :           }
; 8143 :           else
; 8144 :             break;
; 8145 :         }
; 8146 :         n = tp->size + soap->blist->size;
; 8147 :         if (!(s = (char*)SOAP_MALLOC(soap, n)))
; 8148 :           return soap->error = SOAP_EOM;
; 8149 :         if (tp->value)
; 8150 :         { memcpy(s, tp->value, tp->size);
; 8151 :           SOAP_FREE(soap, tp->value);
; 8152 :         }
; 8153 :         soap_save_block(soap, s + tp->size, 0);
; 8154 :         tp->value = s;
; 8155 :         tp->size = n;
; 8156 : #endif
; 8157 :       }
; 8158 :       do c = soap_get1(soap);

	mov	edx, DWORD PTR [esi+12428]
	cmp	edx, DWORD PTR [esi+12432]
	jb	SHORT $LN139@soap_peek_
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN195@soap_peek_
$LN139@soap_peek_:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ebx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax

; 8159 :       while (soap_blank(c));

	test	ebx, ebx
	jl	SHORT $LN61@soap_peek_
	cmp	ebx, 32					; 00000020H
	jle	SHORT $LL64@soap_peek_

; 8160 :       tp->visible = 2; /* seen this attribute w/ value */

	mov	eax, 2
	mov	WORD PTR [ebp+16], ax

; 8161 : #ifdef WITH_DOM
; 8162 :       if (att)
; 8163 :         (*att)->data = soap_strdup(soap, tp->value);
; 8164 : #endif
; 8165 :     }
; 8166 :     else

	jmp	$LN60@soap_peek_
$LN195@soap_peek_:

; 8128 : #else
; 8129 :         size_t n;
; 8130 :         if (soap->error != SOAP_EOM)
; 8131 :           return soap->error;
; 8132 :         soap->error = SOAP_OK;
; 8133 :         if (soap_new_block(soap))
; 8134 :           return soap->error;
; 8135 :         for (;;)
; 8136 :         { if (!(s = (char*)soap_push_block(soap, SOAP_BLKLEN)))
; 8137 :             return soap->error;
; 8138 :           if (soap_getattrval(soap, s, SOAP_BLKLEN, c))
; 8139 :           { if (soap->error != SOAP_EOM)
; 8140 :               return soap->error;
; 8141 :             soap->error = SOAP_OK;
; 8142 :           }
; 8143 :           else
; 8144 :             break;
; 8145 :         }
; 8146 :         n = tp->size + soap->blist->size;
; 8147 :         if (!(s = (char*)SOAP_MALLOC(soap, n)))
; 8148 :           return soap->error = SOAP_EOM;
; 8149 :         if (tp->value)
; 8150 :         { memcpy(s, tp->value, tp->size);
; 8151 :           SOAP_FREE(soap, tp->value);
; 8152 :         }
; 8153 :         soap_save_block(soap, s + tp->size, 0);
; 8154 :         tp->value = s;
; 8155 :         tp->size = n;
; 8156 : #endif
; 8157 :       }
; 8158 :       do c = soap_get1(soap);

	or	ebx, -1
$LN61@soap_peek_:

; 8160 :       tp->visible = 2; /* seen this attribute w/ value */

	mov	eax, 2
	mov	WORD PTR [ebp+16], ax

; 8161 : #ifdef WITH_DOM
; 8162 :       if (att)
; 8163 :         (*att)->data = soap_strdup(soap, tp->value);
; 8164 : #endif
; 8165 :     }
; 8166 :     else

	jmp	$LN60@soap_peek_
$LN170@soap_peek_:
	pop	edi
	pop	ebx

; 8040 :       return soap->error = SOAP_SYNTAX_ERROR;

	mov	eax, 5
	pop	ebp
	mov	DWORD PTR [esi+90460], eax
	pop	esi

; 8282 : }

	add	esp, 8
	ret	0
$LN174@soap_peek_:
	pop	edi
	pop	ebx

; 8126 :           return soap->error = SOAP_EOM;

	mov	eax, 20					; 00000014H
	pop	ebp
	mov	DWORD PTR [esi+90460], eax
	pop	esi

; 8282 : }

	add	esp, 8
	ret	0
$LN175@soap_peek_:

; 8174 :         return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	ebx
	pop	ebp
	pop	esi

; 8282 : }

	add	esp, 8
	ret	0
$LN105@soap_peek_:

; 8175 :     }
; 8176 :   }
; 8177 : #ifdef WITH_DOM
; 8178 :   if (att)
; 8179 :   { soap->dom->nstr = soap_current_namespace(soap, soap->tag);
; 8180 :     for (att = &soap->dom->atts; *att; att = &(*att)->next)
; 8181 :       (*att)->nstr = soap_current_namespace(soap, (*att)->name);
; 8182 :   }
; 8183 : #endif
; 8184 :   if ((int)c == EOF)

	cmp	ebx, -1
	jne	SHORT $LN57@soap_peek_
$LN184@soap_peek_:
	pop	edi
	pop	ebx

; 8185 :     return soap->error = SOAP_EOF;

	or	eax, -1
	pop	ebp
	mov	DWORD PTR [esi+90460], eax
	pop	esi

; 8282 : }

	add	esp, 8
	ret	0
$LN57@soap_peek_:

; 8186 :   if (!(soap->body = (c != '/')))

	xor	eax, eax
	cmp	ebx, 47					; 0000002fH
	setne	al
	movzx	eax, ax
	mov	WORD PTR [esi+12442], ax
	test	ax, ax
	jne	SHORT $LN53@soap_peek_
	npad	11
$LL55@soap_peek_:

; 8187 :     do c = soap_get1(soap);

	mov	ecx, DWORD PTR [esi+12428]
	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN141@soap_peek_
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN53@soap_peek_
$LN141@soap_peek_:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ecx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax

; 8188 :     while (soap_blank(c));

	test	ecx, ecx
	jl	SHORT $LN53@soap_peek_
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LL55@soap_peek_
$LN53@soap_peek_:

; 8189 : #ifdef WITH_DOM
; 8190 :   if (soap->mode & SOAP_XML_DOM)
; 8191 :   { if (!soap->body && soap->dom->prnt)
; 8192 :       soap->dom = soap->dom->prnt;
; 8193 :   }
; 8194 : #endif
; 8195 :   for (tp = soap->attributes; tp; tp = tp->next)

	mov	ebx, DWORD PTR [esi+87292]
	test	ebx, ebx
	je	$LN49@soap_peek_
$LL51@soap_peek_:

; 8196 :   { if (tp->visible && tp->value)

	cmp	WORD PTR [ebx+16], 0
	je	$LN50@soap_peek_
	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN50@soap_peek_

; 8197 :     {
; 8198 : #ifndef WITH_NOIDREF
; 8199 :       if (!strcmp(tp->name, "id"))

	lea	ebp, DWORD PTR [ebx+18]
	mov	ecx, OFFSET ??_C@_02EGCJHIOB@id?$AA@
	mov	eax, ebp
$LL206@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN207@soap_peek_
	test	dl, dl
	je	SHORT $LN208@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN207@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL206@soap_peek_
$LN208@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN209@soap_peek_
$LN207@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN209@soap_peek_:
	test	eax, eax
	jne	SHORT $LN47@soap_peek_

; 8200 :       { if ((soap->version > 0 && !(soap->mode & SOAP_XML_TREE))
; 8201 :          || (soap->mode & SOAP_XML_GRAPH))

	cmp	WORD PTR [esi+6], ax
	jle	SHORT $LN44@soap_peek_
	test	DWORD PTR [esi+8], 32768		; 00008000H
	je	SHORT $LN45@soap_peek_
$LN44@soap_peek_:
	test	DWORD PTR [esi+8], 65536		; 00010000H
	je	$LN50@soap_peek_
$LN45@soap_peek_:

; 8202 :         { *soap->id = '#';

	mov	BYTE PTR [esi+81076], 35		; 00000023H

; 8203 :           strncpy(soap->id + 1, tp->value, sizeof(soap->id) - 2);

	mov	edx, DWORD PTR [ebx+4]
	push	1022					; 000003feH
	push	edx
	lea	eax, DWORD PTR [esi+81077]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 8204 :           soap->id[sizeof(soap->id)-1] = '\0';

	mov	BYTE PTR [esi+82099], 0

; 8205 :         }
; 8206 :       }

	jmp	$LN50@soap_peek_
$LN47@soap_peek_:

; 8207 :       else if (!strcmp(tp->name, "href"))

	mov	ecx, OFFSET ??_C@_04CMBCJJJD@href?$AA@
	mov	eax, ebp
	npad	6
$LL210@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN211@soap_peek_
	test	dl, dl
	je	SHORT $LN212@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN211@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL210@soap_peek_
$LN212@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN213@soap_peek_
$LN211@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN213@soap_peek_:
	test	eax, eax
	jne	SHORT $LN42@soap_peek_

; 8208 :       { if (soap->version == 1
; 8209 :          || (soap->mode & SOAP_XML_GRAPH)
; 8210 :          || (soap->mode & SOAP_ENC_MTOM))

	cmp	WORD PTR [esi+6], 1
	je	SHORT $LN40@soap_peek_
	test	DWORD PTR [esi+8], 66048		; 00010200H
	je	$LN50@soap_peek_
$LN40@soap_peek_:

; 8211 :         { strncpy(soap->href, tp->value, sizeof(soap->href) - 1);

	push	1023					; 000003ffH
	lea	eax, DWORD PTR [esi+82100]
	push	edi
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 8212 :           soap->href[sizeof(soap->href)-1] = '\0';

	mov	BYTE PTR [esi+83123], 0

; 8213 :         }
; 8214 :       }
; 8215 :       else

	jmp	$LN50@soap_peek_
$LN42@soap_peek_:

; 8216 : #endif
; 8217 :       if (!soap_match_tag(soap, tp->name, "xsi:type"))

	push	ebp
	push	esi
	mov	edi, OFFSET ??_C@_08JNIDGPLJ@xsi?3type?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN38@soap_peek_

; 8218 :       { strncpy(soap->type, tp->value, sizeof(soap->type) - 1);

	mov	ecx, DWORD PTR [ebx+4]
	push	1023					; 000003ffH
	push	ecx
	lea	eax, DWORD PTR [esi+83124]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 8219 :         soap->type[sizeof(soap->type)-1] = '\0';

	mov	BYTE PTR [esi+84147], 0

; 8220 :       }
; 8221 :       else if ((!soap_match_tag(soap, tp->name, "xsi:null")

	jmp	$LN50@soap_peek_
$LN38@soap_peek_:

; 8222 :              || !soap_match_tag(soap, tp->name, "xsi:nil"))
; 8223 :             && (!strcmp(tp->value, "1")
; 8224 :              || !strcmp(tp->value, "true")))

	push	ebp
	push	esi
	mov	edi, OFFSET ??_C@_08DJPLLOHP@xsi?3null?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@soap_peek_
	push	ebp
	push	esi
	mov	edi, OFFSET ??_C@_07KJDFMKIE@xsi?3nil?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN36@soap_peek_
$LN35@soap_peek_:
	mov	edi, DWORD PTR [ebx+4]
	mov	ecx, OFFSET ??_C@_01HIHLOKLC@1?$AA@
	mov	eax, edi
$LL214@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN215@soap_peek_
	test	dl, dl
	je	SHORT $LN216@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN215@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL214@soap_peek_
$LN216@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN217@soap_peek_
$LN215@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN217@soap_peek_:
	test	eax, eax
	je	$LN34@soap_peek_
	mov	ecx, OFFSET ??_C@_04LOAJBDKD@true?$AA@
	mov	eax, edi
	npad	7
$LL218@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN219@soap_peek_
	test	dl, dl
	je	SHORT $LN220@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN219@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL218@soap_peek_
$LN220@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN221@soap_peek_
$LN219@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN221@soap_peek_:
	test	eax, eax
	je	$LN34@soap_peek_
$LN36@soap_peek_:

; 8226 :       }
; 8227 :       else if (soap->version == 1)

	movzx	eax, WORD PTR [esi+6]
	cmp	ax, 1
	jne	$LN32@soap_peek_

; 8228 :       { if (!soap_match_tag(soap, tp->name, "SOAP-ENC:arrayType"))

	push	ebp
	push	esi
	mov	edi, OFFSET ??_C@_0BD@GFBEJDEK@SOAP?9ENC?3arrayType?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	$LN31@soap_peek_

; 8229 :         { s = soap_strrchr(tp->value, '[');

	mov	eax, DWORD PTR [ebx+4]
	push	91					; 0000005bH
	push	eax
	call	_strrchr
	mov	edi, eax
	add	esp, 8

; 8230 :           if (s && (size_t)(s - tp->value) < sizeof(soap->arrayType))

	test	edi, edi
	je	SHORT $LN30@soap_peek_
	mov	edx, edi
	sub	edx, DWORD PTR [ebx+4]
	cmp	edx, 1024				; 00000400H
	jae	SHORT $LN30@soap_peek_

; 8231 :           { strncpy(soap->arrayType, tp->value, s - tp->value);

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, edi
	sub	ecx, eax
	push	ecx
	push	eax
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	call	_strncpy

; 8232 :             soap->arrayType[s - tp->value] = '\0';
; 8233 :             strncpy(soap->arraySize, s, sizeof(soap->arraySize) - 1);

	push	1023					; 000003ffH
	mov	edx, edi
	sub	edx, DWORD PTR [ebx+4]
	lea	eax, DWORD PTR [esi+85172]
	push	edi
	push	eax
	mov	BYTE PTR [edx+esi+84148], 0
	call	_strncpy
	add	esp, 24					; 00000018H

; 8237 :           soap->arraySize[sizeof(soap->arrayType)-1] = '\0';

	mov	BYTE PTR [esi+86195], 0

; 8238 :           soap->arrayType[sizeof(soap->arrayType)-1] = '\0';

	mov	BYTE PTR [esi+85171], 0
	jmp	$LN50@soap_peek_
$LN30@soap_peek_:

; 8234 :           }
; 8235 :           else
; 8236 :             strncpy(soap->arrayType, tp->value, sizeof(soap->arrayType) - 1);

	mov	eax, DWORD PTR [ebx+4]
	push	1023					; 000003ffH
	push	eax
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 8237 :           soap->arraySize[sizeof(soap->arrayType)-1] = '\0';

	mov	BYTE PTR [esi+86195], 0

; 8238 :           soap->arrayType[sizeof(soap->arrayType)-1] = '\0';

	mov	BYTE PTR [esi+85171], 0
	jmp	$LN50@soap_peek_
$LN31@soap_peek_:

; 8239 :         }
; 8240 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENC:offset"))

	push	ebp
	push	esi
	mov	edi, OFFSET ??_C@_0BA@CCJOJBBI@SOAP?9ENC?3offset?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@soap_peek_

; 8241 :           strncpy(soap->arrayOffset, tp->value, sizeof(soap->arrayOffset));

	mov	ecx, DWORD PTR [ebx+4]
	push	1024					; 00000400H
	push	ecx
	lea	eax, DWORD PTR [esi+86196]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH
	jmp	$LN50@soap_peek_
$LN27@soap_peek_:

; 8242 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENC:position"))

	push	ebp
	push	esi
	mov	edi, OFFSET ??_C@_0BC@LJIIOGEO@SOAP?9ENC?3position?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@soap_peek_

; 8243 :           soap->position = soap_getposition(tp->value, soap->positions);

	mov	eax, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR [esi+87224]
	push	edx
	push	eax
	call	_soap_getposition
	add	esp, 8
	mov	WORD PTR [esi+87222], ax
	jmp	$LN50@soap_peek_
$LN25@soap_peek_:

; 8244 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENC:root"))

	push	ebp
	push	esi
	mov	edi, OFFSET ??_C@_0O@BGJHDLJG@SOAP?9ENC?3root?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	$LN23@soap_peek_

; 8245 :           soap->root = ((!strcmp(tp->value, "1") || !strcmp(tp->value, "true")));

	mov	edi, DWORD PTR [ebx+4]
	mov	ecx, OFFSET ??_C@_01HIHLOKLC@1?$AA@
	mov	eax, edi
	npad	5
$LL222@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN223@soap_peek_
	test	dl, dl
	je	SHORT $LN293@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN223@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL222@soap_peek_
$LN293@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN225@soap_peek_
$LN223@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN225@soap_peek_:
	test	eax, eax
	je	SHORT $LN143@soap_peek_
	mov	ecx, OFFSET ??_C@_04LOAJBDKD@true?$AA@
	mov	eax, edi
$LL226@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN227@soap_peek_
	test	dl, dl
	je	SHORT $LN228@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN227@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL226@soap_peek_
$LN228@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN229@soap_peek_
$LN227@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN229@soap_peek_:
	test	eax, eax
	je	SHORT $LN143@soap_peek_
	xor	eax, eax
	mov	WORD PTR [esi+87288], ax

; 8246 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENV:mustUnderstand")

	jmp	$LN50@soap_peek_
$LN143@soap_peek_:

; 8245 :           soap->root = ((!strcmp(tp->value, "1") || !strcmp(tp->value, "true")));

	mov	eax, 1
	mov	WORD PTR [esi+87288], ax

; 8246 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENV:mustUnderstand")

	jmp	$LN50@soap_peek_
$LN23@soap_peek_:

; 8247 :               && (!strcmp(tp->value, "1") || !strcmp(tp->value, "true")))

	push	ebp
	push	esi
	mov	edi, OFFSET ??_C@_0BI@ENKFHJBH@SOAP?9ENV?3mustUnderstand?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@soap_peek_
	mov	edi, DWORD PTR [ebx+4]
	mov	ecx, OFFSET ??_C@_01HIHLOKLC@1?$AA@
	mov	eax, edi
$LL230@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN231@soap_peek_
	test	dl, dl
	je	SHORT $LN232@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN231@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL230@soap_peek_
$LN232@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN233@soap_peek_
$LN231@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN233@soap_peek_:
	test	eax, eax
	je	SHORT $LN20@soap_peek_
	mov	ecx, OFFSET ??_C@_04LOAJBDKD@true?$AA@
	mov	eax, edi
$LL234@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN235@soap_peek_
	test	dl, dl
	je	SHORT $LN236@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN235@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL234@soap_peek_
$LN236@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN237@soap_peek_
$LN235@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN237@soap_peek_:
	test	eax, eax
	jne	SHORT $LN21@soap_peek_
$LN20@soap_peek_:

; 8248 :           soap->mustUnderstand = 1;

	mov	ecx, 1
	mov	WORD PTR [esi+87298], cx
	jmp	$LN50@soap_peek_
$LN21@soap_peek_:

; 8249 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENV:actor"))

	push	ebp
	push	esi
	mov	edi, OFFSET ??_C@_0P@OHPBIEEK@SOAP?9ENV?3actor?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	$LN50@soap_peek_

; 8250 :         { if ((!soap->actor || strcmp(soap->actor, tp->value))
; 8251 :            && strcmp(tp->value, "http://schemas.xmlsoap.org/soap/actor/next"))

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN16@soap_peek_
	mov	ecx, DWORD PTR [ebx+4]
$LL238@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN239@soap_peek_
	test	dl, dl
	je	SHORT $LN240@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN239@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL238@soap_peek_
$LN240@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN241@soap_peek_
$LN239@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN241@soap_peek_:
	test	eax, eax
	je	$LN50@soap_peek_
$LN16@soap_peek_:
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, OFFSET ??_C@_0CL@EFBJIKLI@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
$LL242@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN243@soap_peek_
	test	dl, dl
	je	SHORT $LN244@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN243@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL242@soap_peek_
$LN244@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN245@soap_peek_
$LN243@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN245@soap_peek_:
	test	eax, eax
	je	$LN50@soap_peek_

; 8252 :             soap->other = 1;

	mov	edx, 1
	mov	WORD PTR [esi+87220], dx

; 8253 :         }
; 8254 :       }

	jmp	$LN50@soap_peek_
$LN32@soap_peek_:

; 8255 :       else if (soap->version == 2)

	cmp	ax, 2
	jne	$LN50@soap_peek_

; 8256 :       {
; 8257 : #ifndef WITH_NOIDREF
; 8258 :         if (!strcmp(tp->name, "ref")
; 8259 :          || !soap_match_tag(soap, tp->name, "SOAP-ENC:ref"))

	mov	ecx, OFFSET ??_C@_03GCDGINBO@ref?$AA@
	mov	eax, ebp
$LL246@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN247@soap_peek_
	test	dl, dl
	je	SHORT $LN248@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN247@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL246@soap_peek_
$LN248@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN249@soap_peek_
$LN247@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN249@soap_peek_:
	test	eax, eax
	je	$LN12@soap_peek_
	push	ebp
	push	esi
	mov	edi, OFFSET ??_C@_0N@HAMJFIGF@SOAP?9ENC?3ref?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN12@soap_peek_

; 8265 : #endif
; 8266 : 	if (!soap_match_tag(soap, tp->name, "SOAP-ENC:itemType"))

	push	ebp
	push	esi
	mov	edi, OFFSET ??_C@_0BC@GCPDJBOG@SOAP?9ENC?3itemType?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@soap_peek_

; 8267 :           strncpy(soap->arrayType, tp->value, sizeof(soap->arrayType) - 1);

	mov	eax, DWORD PTR [ebx+4]
	push	1023					; 000003ffH
	push	eax
	lea	eax, DWORD PTR [esi+84148]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH
	jmp	$LN50@soap_peek_
$LN10@soap_peek_:

; 8268 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENC:arraySize"))

	push	ebp
	push	esi
	mov	edi, OFFSET ??_C@_0BD@IKLKJNBD@SOAP?9ENC?3arraySize?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@soap_peek_

; 8269 :           strncpy(soap->arraySize, tp->value, sizeof(soap->arraySize) - 1);

	mov	ecx, DWORD PTR [ebx+4]
	push	1023					; 000003ffH
	push	ecx
	lea	eax, DWORD PTR [esi+85172]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 8270 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENV:mustUnderstand")

	jmp	$LN50@soap_peek_
$LN8@soap_peek_:

; 8271 :               && (!strcmp(tp->value, "1") || !strcmp(tp->value, "true")))

	push	ebp
	push	esi
	mov	edi, OFFSET ??_C@_0BI@ENKFHJBH@SOAP?9ENV?3mustUnderstand?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@soap_peek_
	mov	edi, DWORD PTR [ebx+4]
	mov	ecx, OFFSET ??_C@_01HIHLOKLC@1?$AA@
	mov	eax, edi
$LL250@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN251@soap_peek_
	test	dl, dl
	je	SHORT $LN252@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN251@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL250@soap_peek_
$LN252@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN253@soap_peek_
$LN251@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN253@soap_peek_:
	test	eax, eax
	je	SHORT $LN5@soap_peek_
	mov	ecx, OFFSET ??_C@_04LOAJBDKD@true?$AA@
	mov	eax, edi
$LL254@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN255@soap_peek_
	test	dl, dl
	je	SHORT $LN256@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN255@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL254@soap_peek_
$LN256@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN257@soap_peek_
$LN255@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN257@soap_peek_:
	test	eax, eax
	jne	SHORT $LN6@soap_peek_
$LN5@soap_peek_:

; 8272 :           soap->mustUnderstand = 1;

	mov	edx, 1
	mov	WORD PTR [esi+87298], dx
	jmp	$LN50@soap_peek_
$LN6@soap_peek_:

; 8273 :         else if (!soap_match_tag(soap, tp->name, "SOAP-ENV:role"))

	push	ebp
	push	esi
	mov	edi, OFFSET ??_C@_0O@HCOOBFLG@SOAP?9ENV?3role?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	$LN50@soap_peek_

; 8274 :         { if ((!soap->actor || strcmp(soap->actor, tp->value))
; 8275 :            && strcmp(tp->value, "http://www.w3.org/2003/05/soap-envelope/role/next"))

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN291@soap_peek_
	mov	ecx, DWORD PTR [ebx+4]
$LL258@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN259@soap_peek_
	test	dl, dl
	je	SHORT $LN260@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN259@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL258@soap_peek_
$LN260@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN261@soap_peek_
$LN259@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN261@soap_peek_:
	test	eax, eax
	je	SHORT $LN50@soap_peek_
$LN291@soap_peek_:
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, OFFSET ??_C@_0DC@KBJFLDJI@http?3?1?1www?4w3?4org?12003?105?1soap?9e@
$LL262@soap_peek_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN263@soap_peek_
	test	dl, dl
	je	SHORT $LN264@soap_peek_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN263@soap_peek_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL262@soap_peek_
$LN264@soap_peek_:
	xor	eax, eax
	jmp	SHORT $LN265@soap_peek_
$LN263@soap_peek_:
	sbb	eax, eax
	sbb	eax, -1
$LN265@soap_peek_:
	test	eax, eax
	je	SHORT $LN50@soap_peek_

; 8276 :             soap->other = 1;

	mov	eax, 1
	mov	WORD PTR [esi+87220], ax
	jmp	SHORT $LN50@soap_peek_
$LN12@soap_peek_:

; 8260 :         { *soap->href = '#';

	mov	BYTE PTR [esi+82100], 35		; 00000023H

; 8261 :           strncpy(soap->href + 1, tp->value, sizeof(soap->href) - 2);

	mov	ecx, DWORD PTR [ebx+4]
	push	1022					; 000003feH
	push	ecx
	lea	edx, DWORD PTR [esi+82101]
	push	edx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 8262 :           soap->href[sizeof(soap->href)-1] = '\0';

	mov	BYTE PTR [esi+83123], 0

; 8263 :         }
; 8264 :         else

	jmp	SHORT $LN50@soap_peek_
$LN34@soap_peek_:

; 8225 :       { soap->null = 1;

	mov	eax, 1
	mov	WORD PTR [esi+87300], ax
$LN50@soap_peek_:
	mov	ebx, DWORD PTR [ebx]
	test	ebx, ebx
	jne	$LL51@soap_peek_
$LN49@soap_peek_:
	pop	edi
	pop	ebx
	pop	ebp

; 8277 :         }
; 8278 :       }
; 8279 :     }
; 8280 :   }
; 8281 :   return soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0
	xor	eax, eax
	pop	esi

; 8282 : }

	add	esp, 8
	ret	0
_soap_peek_element ENDP
_TEXT	ENDS
PUBLIC	_soap_element_begin_in
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_nillable$ = 8						; size = 4
_type$ = 12						; size = 4
_soap_element_begin_in PROC
; _soap$ = esi
; _tag$ = eax

; 7573 : { if (!soap_peek_element(soap))

	push	ebx
	mov	ebx, DWORD PTR _type$[esp]
	push	edi
	mov	edi, eax
	mov	eax, esi
	call	_soap_peek_element
	test	eax, eax
	jne	$LN9@soap_eleme@11

; 7574 :   { if (soap->other)

	cmp	WORD PTR [esi+87220], ax
	je	SHORT $LN8@soap_eleme@11

; 7575 :       return soap->error = SOAP_TAG_MISMATCH;

	mov	eax, 3
	pop	edi
	mov	DWORD PTR [esi+90460], eax
	pop	ebx

; 7592 : }

	ret	0
$LN8@soap_eleme@11:

; 7576 :     if (tag && *tag == '-')

	test	edi, edi
	je	SHORT $LN7@soap_eleme@11
	cmp	BYTE PTR [edi], 45			; 0000002dH
	jne	SHORT $LN7@soap_eleme@11
	pop	edi

; 7577 :       return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 7592 : }

	ret	0
$LN7@soap_eleme@11:

; 7578 :     if (!(soap->error = soap_match_tag(soap, soap->tag, tag)))

	lea	eax, DWORD PTR [esi+80052]
	push	eax
	push	esi
	call	_soap_match_tag
	add	esp, 8
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	jne	$LN1@soap_eleme@11

; 7579 :     { soap->peeked = 0;

	xor	ecx, ecx
	mov	WORD PTR [esi+87308], cx

; 7580 :       if (type && *soap->type && soap_match_tag(soap, soap->type, type))

	test	ebx, ebx
	je	SHORT $LN5@soap_eleme@11
	cmp	BYTE PTR [esi+83124], cl
	lea	eax, DWORD PTR [esi+83124]
	je	SHORT $LN5@soap_eleme@11
	push	eax
	push	esi
	mov	edi, ebx
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@soap_eleme@11

; 7581 :         return soap->error = SOAP_TYPE;

	mov	eax, 4
	pop	edi
	mov	DWORD PTR [esi+90460], eax
	pop	ebx

; 7592 : }

	ret	0
$LN5@soap_eleme@11:

; 7582 :       if (!nillable && soap->null && (soap->mode & SOAP_XML_STRICT))

	cmp	DWORD PTR _nillable$[esp+4], 0
	jne	SHORT $LN4@soap_eleme@11
	cmp	WORD PTR [esi+87300], 0
	je	SHORT $LN4@soap_eleme@11
	test	DWORD PTR [esi+8], 4096			; 00001000H
	je	SHORT $LN4@soap_eleme@11

; 7583 :         return soap->error = SOAP_NULL;

	mov	eax, 23					; 00000017H
	pop	edi
	mov	DWORD PTR [esi+90460], eax
	pop	ebx

; 7592 : }

	ret	0
$LN4@soap_eleme@11:

; 7584 :       if (soap->body)

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN1@soap_eleme@11

; 7585 :         soap->level++;

	inc	DWORD PTR [esi+12444]

; 7591 :   return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	ebx

; 7592 : }

	ret	0
$LN9@soap_eleme@11:

; 7586 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Begin element found (level=%u) '%s'='%s'\n", soap->level, soap->tag, tag?tag:""));
; 7587 :     }
; 7588 :   }
; 7589 :   else if (soap->error == SOAP_NO_TAG && tag && *tag == '-')

	cmp	DWORD PTR [esi+90460], 6
	jne	SHORT $LN1@soap_eleme@11
	test	edi, edi
	je	SHORT $LN1@soap_eleme@11
	cmp	BYTE PTR [edi], 45			; 0000002dH
	jne	SHORT $LN1@soap_eleme@11

; 7590 :     soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0
$LN1@soap_eleme@11:

; 7591 :   return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	ebx

; 7592 : }

	ret	0
_soap_element_begin_in ENDP
_TEXT	ENDS
PUBLIC	_soap_xop_forward
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_size$ = 12						; size = 4
_type$ = 16						; size = 4
_options$ = 20						; size = 4
_soap_xop_forward PROC
; _soap$ = eax
; _id$ = edi

; 2048 : { /* Check MTOM xop:Include element (within hex/base64Binary) */

	push	ebx
	push	esi
	mov	esi, eax

; 2049 :   /* TODO: this code to be obsoleted with new import/xop.h conventions */
; 2050 :   int body = soap->body; /* should save type too? */

	movsx	ebx, WORD PTR [esi+12442]

; 2051 :   if (!soap_peek_element(soap))

	call	_soap_peek_element
	test	eax, eax
	jne	SHORT $LN1@soap_xop_f@2

; 2052 :   { if (!soap_element_begin_in(soap, "xop:Include", 0, NULL) && *soap->href)

	push	eax
	push	eax
	mov	eax, OFFSET ??_C@_0M@BMFKMGMG@xop?3Include?$AA@
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@soap_xop_f@2
	cmp	BYTE PTR [esi+82100], al
	je	SHORT $LN2@soap_xop_f@2

; 2053 :     { if (soap_dime_forward(soap, ptr, size, id, type, options))

	mov	eax, DWORD PTR _options$[esp+4]
	mov	ecx, DWORD PTR _type$[esp+4]
	mov	edx, DWORD PTR _size$[esp+4]
	push	eax
	mov	eax, DWORD PTR _ptr$[esp+8]
	push	ecx
	push	edx
	push	eax
	call	_soap_dime_forward
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN2@soap_xop_f@2
$LN7@soap_xop_f@2:

; 2054 :         return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	esi
	pop	ebx

; 2061 : }

	ret	0
$LN2@soap_xop_f@2:

; 2055 :     }
; 2056 :     if (soap->body && soap_element_end_in(soap, NULL))

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN1@soap_xop_f@2
	push	0
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 2057 :       return soap->error;

	jne	SHORT $LN7@soap_xop_f@2
$LN1@soap_xop_f@2:

; 2058 :   }
; 2059 :   soap->body = body;

	mov	WORD PTR [esi+12442], bx
	pop	esi

; 2060 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 2061 : }

	ret	0
_soap_xop_forward ENDP
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z$0
__tryblocktable$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z$10
__ehfuncinfo$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z
_TEXT	SEGMENT
__Ok$ = -28						; size = 8
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Str$ = 12						; size = 4
__State$ = 16						; size = 4
__Count$ = 16						; size = 4
?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Read_s, COMDAT

; 679  : 		{	// read up to _Count characters into buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR __Count$[ebp]
	mov	esi, DWORD PTR _this$[ebp]

; 680  : 		_DEBUG_POINTER(_Str);
; 681  : 		ios_base::iostate _State = ios_base::goodbit;
; 682  : 		_Chcount = 0;
; 683  : 		const sentry _Ok(*this, true);

	push	1
	push	esi
	lea	eax, DWORD PTR __Ok$[ebp]
	xor	edi, edi
	push	eax
	mov	DWORD PTR __State$[ebp], edi
	mov	DWORD PTR [esi+4], edi
	call	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], edi

; 684  : 
; 685  : 		if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	je	SHORT $LN10@Read_s

; 686  : 			{	// state okay, use facet to extract
; 687  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 688  : 			const streamsize _Num = _Myios::rdbuf()->_Sgetn_s(_Str, _Str_size, _Count);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+esi+40]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Str$[ebp]
	mov	eax, DWORD PTR [eax+28]
	push	ebx
	push	-1
	push	edx
	call	eax

; 689  : 			_Chcount += _Num;

	add	DWORD PTR [esi+4], eax

; 690  : 			if (_Num != _Count)

	cmp	eax, ebx
	je	SHORT $LN1@Read_s

; 691  : 				_State |= ios_base::eofbit | ios_base::failbit;	// short read

	mov	edi, 3
$LN1@Read_s:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN10@Read_s
__catch$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z$0:

; 692  : 			_CATCH_IO_END

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	or	eax, 4
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN24@Read_s
	or	eax, 4
$LN24@Read_s:
	push	1
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN71@Read_s
	ret	0
$LN71@Read_s:
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
$LN10@Read_s:

; 693  : 			}
; 694  : 
; 695  : 		_Myios::setstate(_State);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN53@Read_s
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN55@Read_s
	or	eax, 4
$LN55@Read_s:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN53@Read_s:

; 696  : 		return (*this);

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR __Ok$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN70@Read_s
	lea	ecx, DWORD PTR [eax+4]
	call	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
$LN70@Read_s:
	mov	eax, esi

; 697  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z$2:
	lea	eax, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Read_s
; Function compile flags: /Ogtpy
;	COMDAT ?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z PROC ; std::basic_istream<char,std::char_traits<char> >::read, COMDAT
; __Str$ = ecx
; __Count$ = eax

; 701  : 		return _Read_s(_Str, (size_t)-1, _Count);

	mov	edx, DWORD PTR _this$[esp-4]
	push	eax
	push	ecx
	push	edx
	call	?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z ; std::basic_istream<char,std::char_traits<char> >::_Read_s

; 702  : 		}

	ret	4
?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::read
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z$9 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z$0
__tryblocktable$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z$9
__ehfuncinfo$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z
_TEXT	SEGMENT
__Ok$ = -28						; size = 8
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Str$ = 12						; size = 4
__State$ = 16						; size = 4
__Count$ = 16						; size = 4
?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::write, COMDAT

; 529  : 		{	// insert _Count characters from array _Str

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR __Count$[ebp]
	mov	esi, DWORD PTR _this$[ebp]

; 530  : 		if (0 < _Count)
; 531  : 			_DEBUG_POINTER(_Str);
; 532  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 533  : 		const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __State$[ebp], edi
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], edi

; 534  : 
; 535  : 		if (!_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	jne	SHORT $LN4@write@3

; 536  : 			_State |= ios_base::badbit;

	mov	edi, 4

; 537  : 		else

	jmp	SHORT $LN12@write@3
$LN4@write@3:

; 538  : 			{	// state okay, insert characters
; 539  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 540  : 			if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+esi+40]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Str$[ebp]
	mov	edx, DWORD PTR [edx+32]
	push	ebx
	push	eax
	call	edx
	cmp	eax, ebx
	je	SHORT $LN1@write@3

; 541  : 				_State |= ios_base::badbit;

	mov	edi, 4
$LN1@write@3:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN12@write@3
__catch$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z$0:

; 542  : 			_CATCH_IO_END

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	or	eax, 4
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN26@write@3
	or	eax, 4
$LN26@write@3:
	push	1
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN61@write@3
	ret	0
$LN61@write@3:
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
$LN12@write@3:

; 543  : 			}
; 544  : 
; 545  : 		_Myios::setstate(_State);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN55@write@3
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN57@write@3
	or	eax, 4
$LN57@write@3:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN55@write@3:

; 546  : 		return (*this);

	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, esi

; 547  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::write
PUBLIC	_soap_sprint_fault
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\stdsoap2.cpp
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_soap_sprint_fault PROC
; _soap$ = eax

; 14737: { if (soap_check_state(soap))

	push	ebx
	push	esi
	mov	esi, eax
	test	esi, esi
	je	$LN5@soap_sprin
	movzx	eax, WORD PTR [esi+4]
	mov	ebx, 2
	cmp	ax, 1
	je	SHORT $LN6@soap_sprin
	cmp	ax, bx
	jne	$LN5@soap_sprin
$LN6@soap_sprin:

; 14739:   else if (soap->error)

	cmp	DWORD PTR [esi+90460], 0
	je	$LN25@soap_sprin
	push	ebp
	push	edi

; 14740:   { const char *c, *v = NULL, *s, **d;
; 14741:     d = soap_faultcode(soap);

	mov	eax, esi
	xor	ebp, ebp
	call	_soap_fault
	cmp	WORD PTR [esi+6], bx
	jne	SHORT $LN19@soap_sprin
	mov	eax, DWORD PTR [esi+12208]
	mov	edi, DWORD PTR [eax+16]
	jmp	SHORT $LN20@soap_sprin
$LN19@soap_sprin:
	mov	edi, DWORD PTR [esi+12208]
$LN20@soap_sprin:

; 14742:     if (!*d)

	cmp	DWORD PTR [edi], ebp
	jne	SHORT $LN2@soap_sprin

; 14743:       soap_set_fault(soap);

	mov	eax, esi
	call	_soap_set_fault
$LN2@soap_sprin:

; 14744:     c = *d;

	mov	edi, DWORD PTR [edi]

; 14745:     if (soap->version == 2)

	cmp	WORD PTR [esi+6], bx
	jne	SHORT $LN1@soap_sprin

; 14746:       v = *soap_faultsubcode(soap);

	mov	eax, esi
	call	_soap_faultsubcode
	mov	ebp, DWORD PTR [eax]
$LN1@soap_sprin:

; 14747:     s = *soap_faultstring(soap);

	mov	eax, esi
	call	_soap_fault
	cmp	WORD PTR [esi+6], bx
	jne	SHORT $LN22@soap_sprin
	mov	ecx, DWORD PTR [esi+12208]
	mov	eax, DWORD PTR [ecx+20]
	jmp	SHORT $LN23@soap_sprin
$LN22@soap_sprin:
	mov	eax, DWORD PTR [esi+12208]
	add	eax, 4
$LN23@soap_sprin:
	mov	ebx, DWORD PTR [eax]

; 14748:     d = soap_faultdetail(soap);

	mov	eax, esi
	call	_soap_faultdetail

; 14749: #ifdef WIN32
; 14750:     _snprintf
; 14751: #else
; 14752:     snprintf
; 14753: #endif
; 14754:       (buf, len, "%s%d fault: %s [%s]\n\"%s\"\nDetail: %s\n", soap->version ? "SOAP 1." : "Error ", soap->version ? (int)soap->version : soap->error, c, v ? v : "no subcode", s ? s : "[no reason]", d && *d ? *d : "[no detail]");

	test	eax, eax
	je	SHORT $LN9@soap_sprin
	mov	eax, DWORD PTR [eax]
	mov	edx, eax
	test	eax, eax
	jne	SHORT $LN10@soap_sprin
$LN9@soap_sprin:
	mov	edx, OFFSET ??_C@_0M@NIEENCAP@?$FLno?5detail?$FN?$AA@
$LN10@soap_sprin:
	test	ebx, ebx
	jne	SHORT $LN12@soap_sprin
	mov	ebx, OFFSET ??_C@_0M@NEEDGNL@?$FLno?5reason?$FN?$AA@
$LN12@soap_sprin:
	mov	ecx, ebp
	test	ebp, ebp
	jne	SHORT $LN14@soap_sprin
	mov	ecx, OFFSET ??_C@_0L@HPHPPAL@no?5subcode?$AA@
$LN14@soap_sprin:
	movzx	eax, WORD PTR [esi+6]
	test	ax, ax
	je	SHORT $LN15@soap_sprin
	movsx	esi, ax
	jmp	SHORT $LN16@soap_sprin
$LN15@soap_sprin:
	mov	esi, DWORD PTR [esi+90460]
$LN16@soap_sprin:
	test	ax, ax
	mov	eax, OFFSET ??_C@_07IBLMOOJE@SOAP?51?4?$AA@
	jne	SHORT $LN18@soap_sprin
	mov	eax, OFFSET ??_C@_06BAOMBKPD@Error?5?$AA@
$LN18@soap_sprin:
	push	edx
	mov	edx, DWORD PTR _len$[esp+16]
	push	ebx
	push	ecx
	push	edi
	push	esi
	mov	esi, DWORD PTR _buf$[esp+32]
	push	eax
	push	OFFSET ??_C@_0CF@JFPNHCMD@?$CFs?$CFd?5fault?3?5?$CFs?5?$FL?$CFs?$FN?6?$CC?$CFs?$CC?6Detail?3@
	push	edx
	push	esi
	call	__snprintf
	add	esp, 36					; 00000024H
	pop	edi
	pop	ebp

; 14755:   }
; 14756:   return buf;

	mov	eax, esi
	pop	esi
	pop	ebx

; 14757: }

	ret	0
$LN5@soap_sprin:

; 14738:     strncpy(buf, "Error: soap struct not initialized", len);

	mov	eax, DWORD PTR _len$[esp+4]
	mov	esi, DWORD PTR _buf$[esp+4]
	push	eax
	push	OFFSET ??_C@_0CD@LNJDOMMI@Error?3?5soap?5struct?5not?5initializ@
	push	esi
	call	_strncpy
	add	esp, 12					; 0000000cH

; 14755:   }
; 14756:   return buf;

	mov	eax, esi
	pop	esi
	pop	ebx

; 14757: }

	ret	0
$LN25@soap_sprin:

; 14755:   }
; 14756:   return buf;

	mov	eax, DWORD PTR _buf$[esp+4]
	pop	esi
	pop	ebx

; 14757: }

	ret	0
_soap_sprint_fault ENDP
_TEXT	ENDS
PUBLIC	_soap_print_fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_soap_print_fault PROC
; _soap$ = eax

; 14677: { if (soap_check_state(soap))

	push	ebx
	push	esi
	mov	esi, eax
	test	esi, esi
	je	$LN5@soap_print@2
	movzx	eax, WORD PTR [esi+4]
	mov	ebx, 2
	cmp	ax, 1
	je	SHORT $LN6@soap_print@2
	cmp	ax, bx
	jne	$LN5@soap_print@2
$LN6@soap_print@2:

; 14679:   else if (soap->error)

	cmp	DWORD PTR [esi+90460], 0
	je	$LN3@soap_print@2
	push	ebp
	push	edi

; 14680:   { const char *c, *v = NULL, *s, **d;
; 14681:     d = soap_faultcode(soap);

	mov	eax, esi
	xor	ebp, ebp
	call	_soap_fault
	cmp	WORD PTR [esi+6], bx
	jne	SHORT $LN19@soap_print@2
	mov	eax, DWORD PTR [esi+12208]
	mov	edi, DWORD PTR [eax+16]
	jmp	SHORT $LN20@soap_print@2
$LN19@soap_print@2:
	mov	edi, DWORD PTR [esi+12208]
$LN20@soap_print@2:

; 14682:     if (!*d)

	cmp	DWORD PTR [edi], ebp
	jne	SHORT $LN2@soap_print@2

; 14683:       soap_set_fault(soap);

	mov	eax, esi
	call	_soap_set_fault
$LN2@soap_print@2:

; 14684:     c = *d;

	mov	edi, DWORD PTR [edi]

; 14685:     if (soap->version == 2)

	cmp	WORD PTR [esi+6], bx
	jne	SHORT $LN1@soap_print@2

; 14686:       v = *soap_faultsubcode(soap);

	mov	eax, esi
	call	_soap_faultsubcode
	mov	ebp, DWORD PTR [eax]
$LN1@soap_print@2:

; 14687:     s = *soap_faultstring(soap);

	mov	eax, esi
	call	_soap_fault
	cmp	WORD PTR [esi+6], bx
	jne	SHORT $LN22@soap_print@2
	mov	ecx, DWORD PTR [esi+12208]
	mov	eax, DWORD PTR [ecx+20]
	jmp	SHORT $LN23@soap_print@2
$LN22@soap_print@2:
	mov	eax, DWORD PTR [esi+12208]
	add	eax, 4
$LN23@soap_print@2:
	mov	ebx, DWORD PTR [eax]

; 14688:     d = soap_faultdetail(soap);

	mov	eax, esi
	call	_soap_faultdetail

; 14689:     fprintf(fd, "%s%d fault: %s [%s]\n\"%s\"\nDetail: %s\n", soap->version ? "SOAP 1." : "Error ", soap->version ? (int)soap->version : soap->error, c, v ? v : "no subcode", s ? s : "[no reason]", d && *d ? *d : "[no detail]");

	test	eax, eax
	je	SHORT $LN9@soap_print@2
	mov	eax, DWORD PTR [eax]
	mov	edx, eax
	test	eax, eax
	jne	SHORT $LN10@soap_print@2
$LN9@soap_print@2:
	mov	edx, OFFSET ??_C@_0M@NIEENCAP@?$FLno?5detail?$FN?$AA@
$LN10@soap_print@2:
	test	ebx, ebx
	jne	SHORT $LN12@soap_print@2
	mov	ebx, OFFSET ??_C@_0M@NEEDGNL@?$FLno?5reason?$FN?$AA@
$LN12@soap_print@2:
	mov	ecx, ebp
	test	ebp, ebp
	jne	SHORT $LN14@soap_print@2
	mov	ecx, OFFSET ??_C@_0L@HPHPPAL@no?5subcode?$AA@
$LN14@soap_print@2:
	movzx	eax, WORD PTR [esi+6]
	test	ax, ax
	je	SHORT $LN15@soap_print@2
	movsx	esi, ax
	jmp	SHORT $LN16@soap_print@2
$LN15@soap_print@2:
	mov	esi, DWORD PTR [esi+90460]
$LN16@soap_print@2:
	test	ax, ax
	mov	eax, OFFSET ??_C@_07IBLMOOJE@SOAP?51?4?$AA@
	jne	SHORT $LN18@soap_print@2
	mov	eax, OFFSET ??_C@_06BAOMBKPD@Error?5?$AA@
$LN18@soap_print@2:
	push	edx
	mov	edx, DWORD PTR _fd$[esp+16]
	push	ebx
	push	ecx
	push	edi
	push	esi
	push	eax
	push	OFFSET ??_C@_0CF@JFPNHCMD@?$CFs?$CFd?5fault?3?5?$CFs?5?$FL?$CFs?$FN?6?$CC?$CFs?$CC?6Detail?3@
	push	edx
	call	_fprintf
	add	esp, 32					; 00000020H
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 14690:   }
; 14691: }

	ret	0
$LN5@soap_print@2:

; 14678:     fprintf(fd, "Error: soap struct state not initialized\n");

	mov	eax, DWORD PTR _fd$[esp+4]
	push	OFFSET ??_C@_0CK@KAKMECOH@Error?3?5soap?5struct?5state?5not?5ini@
	push	eax
	call	_fprintf
	add	esp, 8
$LN3@soap_print@2:
	pop	esi
	pop	ebx

; 14690:   }
; 14691: }

	ret	0
_soap_print_fault ENDP
; Function compile flags: /Ogtpy
_faultcode$ = 8					; size = 4
_faultdetailXML$ = 12					; size = 4
_soap_copy_fault PROC
; _soap$ = ecx
; _faultstring$ = eax

; 14619: { char *r = NULL, *s = NULL, *t = NULL;

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _faultdetailXML$[esp+4]
	push	esi
	push	edi
	xor	ebx, ebx
	xor	edi, edi
	mov	esi, ecx

; 14620:   if (faultsubcodeQName)
; 14621:     r = soap_strdup(soap, faultsubcodeQName);
; 14622:   if (faultstring)

	test	eax, eax
	je	SHORT $LN2@soap_copy_@2

; 14623:     s = soap_strdup(soap, faultstring);

	push	eax
	push	esi
	call	_soap_strdup
	add	esp, 8
	mov	ebx, eax
$LN2@soap_copy_@2:

; 14624:   if (faultdetailXML)

	test	ebp, ebp
	je	SHORT $LN1@soap_copy_@2

; 14625:     t = soap_strdup(soap, faultdetailXML);

	push	ebp
	push	esi
	call	_soap_strdup
	add	esp, 8
	mov	edi, eax
$LN1@soap_copy_@2:

; 14626:   return soap_set_error(soap, faultcode, r, s, t, SOAP_FAULT);

	mov	eax, DWORD PTR _faultcode$[esp+12]
	push	edi
	push	ebx
	push	0
	push	eax
	mov	edi, 12					; 0000000cH
	call	_soap_set_error
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 14627: }

	ret	0
_soap_copy_fault ENDP
_TEXT	ENDS
PUBLIC	_soap_set_receiver_error
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_faultstring$ = 8					; size = 4
_faultdetailXML$ = 12					; size = 4
_soap_set_receiver_error PROC
; _soap$ = esi
; _soaperror$ = edi

; 14611: { return soap_set_error(soap, soap->version == 2 ? "SOAP-ENV:Receiver" : "SOAP-ENV:Server", NULL, faultstring, faultdetailXML, soaperror);

	cmp	WORD PTR [esi+6], 2
	push	ebx
	mov	ebx, OFFSET ??_C@_0BC@DABIKIOO@SOAP?9ENV?3Receiver?$AA@
	je	SHORT $LN4@soap_set_r
	mov	ebx, OFFSET ??_C@_0BA@NJHKENFI@SOAP?9ENV?3Server?$AA@
$LN4@soap_set_r:
	mov	eax, esi
	call	_soap_fault
	cmp	WORD PTR [esi+6], 2
	mov	eax, DWORD PTR [esi+12208]
	jne	SHORT $LN11@soap_set_r
	mov	eax, DWORD PTR [eax+16]
$LN11@soap_set_r:
	mov	DWORD PTR [eax], ebx
	mov	eax, esi
	call	_soap_fault
	cmp	WORD PTR [esi+6], 2
	jne	SHORT $LN13@soap_set_r
	mov	ecx, DWORD PTR [esi+12208]
	mov	eax, DWORD PTR [ecx+20]
	jmp	SHORT $LN14@soap_set_r
$LN13@soap_set_r:
	mov	eax, DWORD PTR [esi+12208]
	add	eax, 4
$LN14@soap_set_r:
	mov	ebx, DWORD PTR _faultdetailXML$[esp]
	mov	edx, DWORD PTR _faultstring$[esp]
	mov	DWORD PTR [eax], edx
	test	ebx, ebx
	je	SHORT $LN18@soap_set_r
	cmp	BYTE PTR [ebx], 0
	je	SHORT $LN18@soap_set_r
	mov	eax, esi
	call	_soap_faultdetail
	test	eax, eax
	je	SHORT $LN18@soap_set_r
	mov	DWORD PTR [eax], ebx
$LN18@soap_set_r:
	mov	eax, edi
	mov	DWORD PTR [esi+90460], edi
	pop	ebx

; 14612: }

	ret	0
_soap_set_receiver_error ENDP
_TEXT	ENDS
PUBLIC	_soap_set_sender_error
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_faultstring$ = 8					; size = 4
_faultdetailXML$ = 12					; size = 4
_soap_set_sender_error PROC
; _soap$ = esi

; 14601: { return soap_set_error(soap, soap->version == 2 ? "SOAP-ENV:Sender" : "SOAP-ENV:Client", NULL, faultstring, faultdetailXML, soaperror);

	cmp	WORD PTR [esi+6], 2
	push	ebp
	mov	ebp, DWORD PTR _faultdetailXML$[esp]
	push	edi
	mov	edi, OFFSET ??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@
	je	SHORT $LN4@soap_set_s
	mov	edi, OFFSET ??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@
$LN4@soap_set_s:
	mov	eax, esi
	call	_soap_fault
	cmp	WORD PTR [esi+6], 2
	mov	eax, DWORD PTR [esi+12208]
	jne	SHORT $LN11@soap_set_s
	mov	eax, DWORD PTR [eax+16]
$LN11@soap_set_s:
	mov	DWORD PTR [eax], edi
	mov	eax, esi
	call	_soap_fault
	cmp	WORD PTR [esi+6], 2
	jne	SHORT $LN13@soap_set_s
	mov	ecx, DWORD PTR [esi+12208]
	mov	eax, DWORD PTR [ecx+20]
	jmp	SHORT $LN14@soap_set_s
$LN13@soap_set_s:
	mov	eax, DWORD PTR [esi+12208]
	add	eax, 4
$LN14@soap_set_s:
	mov	edx, DWORD PTR _faultstring$[esp+4]
	mov	DWORD PTR [eax], edx
	test	ebp, ebp
	je	SHORT $LN18@soap_set_s
	cmp	BYTE PTR [ebp], 0
	je	SHORT $LN18@soap_set_s
	mov	eax, esi
	call	_soap_faultdetail
	test	eax, eax
	je	SHORT $LN18@soap_set_s
	mov	DWORD PTR [eax], ebp
$LN18@soap_set_s:
	mov	eax, 28					; 0000001cH
	pop	edi
	mov	DWORD PTR [esi+90460], eax
	pop	ebp

; 14602: }

	ret	0
_soap_set_sender_error ENDP
_TEXT	ENDS
PUBLIC	_soap_body_begin_in
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_body_begin_in PROC
; _soap$ = eax

; 13441: { soap->part = SOAP_IN_BODY;

	push	esi
	mov	esi, eax
	mov	eax, 6
	mov	WORD PTR [esi+87304], ax

; 13442:   if (soap_element_begin_in(soap, "SOAP-ENV:Body", 0, NULL))

	push	0
	push	0
	mov	eax, OFFSET ??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@soap_body_@4

; 13443:     return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	esi

; 13447: }

	ret	0
$LN2@soap_body_@4:

; 13444:   if (!soap->body)

	cmp	WORD PTR [esi+12442], 0
	jne	SHORT $LN1@soap_body_@4

; 13445:     soap->part = SOAP_NO_BODY;

	mov	ecx, 5
	mov	WORD PTR [esi+87304], cx
$LN1@soap_body_@4:

; 13446:   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 13447: }

	ret	0
_soap_body_begin_in ENDP
_TEXT	ENDS
PUBLIC	_soap_envelope_begin_in
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_envelope_begin_in PROC
; _soap$ = eax

; 13344: { register struct Namespace *p;

	push	esi
	mov	esi, eax
	push	edi

; 13345:   soap->part = SOAP_IN_ENVELOPE;

	mov	eax, 2
	mov	WORD PTR [esi+87304], ax

; 13346:   if (soap_element_begin_in(soap, "SOAP-ENV:Envelope", 0, NULL))

	push	0
	push	0
	mov	eax, OFFSET ??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	$LN12@soap_envel@3

; 13347:   {
; 13348: #ifndef WITH_LEAN
; 13349:     if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "html", 0, NULL))

	cmp	DWORD PTR [esi+90460], 3
	jne	SHORT $LN11@soap_envel@3
	push	0
	push	0
	mov	eax, OFFSET ??_C@_04PNIFHPHN@html?$AA@
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@soap_envel@3

; 13350:     { /* get HTML from buffer, stop receiving to avoid HTML parsing issues */
; 13351:       char *s;
; 13352: #ifndef WITH_NOIO
; 13353:       size_t (*f)(struct soap*, char*, size_t) = soap->frecv;

	mov	edi, DWORD PTR [esi+12312]

; 13354:       soap->frecv = frecv_stop;

	mov	DWORD PTR [esi+12312], OFFSET _frecv_stop

; 13355: #endif
; 13356:       soap_revert(soap);

	cmp	WORD PTR [esi+87308], ax
	jne	SHORT $LN17@soap_envel@3
	mov	ecx, 1
	mov	WORD PTR [esi+87308], cx
	cmp	WORD PTR [esi+12442], ax
	je	SHORT $LN17@soap_envel@3
	dec	DWORD PTR [esi+12444]
$LN17@soap_envel@3:

; 13357:       s = soap_string_in(soap, 1, -1, -1);

	push	1
	mov	ecx, esi
	call	_soap_string_in

; 13358: #ifndef WITH_NOIO
; 13359:       soap->frecv = f;
; 13360: #endif
; 13361:       return soap_set_receiver_error(soap, "HTTP Error", s, SOAP_HTTP_ERROR);

	push	eax
	mov	DWORD PTR [esi+12312], edi
	push	OFFSET ??_C@_0L@LOBKJNKF@HTTP?5Error?$AA@
	mov	edi, 29					; 0000001dH
	call	_soap_set_receiver_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 13389: }

	ret	0
$LN11@soap_envel@3:

; 13362:     }
; 13363: #endif
; 13364:     if (soap->error == SOAP_TAG_MISMATCH)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 3
	jne	$LN13@soap_envel@3

; 13365:       return soap->error = SOAP_VERSIONMISMATCH;

	mov	eax, 39					; 00000027H
	pop	edi
	mov	DWORD PTR [esi+90460], eax
	pop	esi

; 13389: }

	ret	0
$LN12@soap_envel@3:
	push	ebx

; 13366:     return soap->error;
; 13367:   }
; 13368:   p = soap->local_namespaces;

	mov	ebx, DWORD PTR [esi+84]

; 13369:   if (p)

	test	ebx, ebx
	je	$LN1@soap_envel@3

; 13370:   { const char *ns = p[0].out;

	mov	edi, DWORD PTR [ebx+12]

; 13371:     if (!ns)

	test	edi, edi
	jne	SHORT $LN8@soap_envel@3

; 13372:       ns = p[0].ns;

	mov	edi, DWORD PTR [ebx+4]
$LN8@soap_envel@3:

; 13373:     if (!strcmp(ns, soap_env1))

	mov	ecx, OFFSET _soap_env1
	mov	eax, edi
	npad	6
$LL23@soap_envel@3:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN24@soap_envel@3
	test	dl, dl
	je	SHORT $LN25@soap_envel@3
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN24@soap_envel@3
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL23@soap_envel@3
$LN25@soap_envel@3:
	xor	eax, eax
	jmp	SHORT $LN26@soap_envel@3
$LN24@soap_envel@3:
	sbb	eax, eax
	sbb	eax, -1
$LN26@soap_envel@3:
	test	eax, eax
	jne	SHORT $LN7@soap_envel@3

; 13374:     { soap->version = 1; /* make sure we use SOAP 1.1 */

	mov	edx, 1
	mov	WORD PTR [esi+6], dx

; 13375:       if (p[1].out)

	mov	eax, DWORD PTR [ebx+28]
	test	eax, eax
	je	SHORT $LN6@soap_envel@3

; 13376:         SOAP_FREE(soap, p[1].out);

	push	eax
	call	_free
	add	esp, 4
$LN6@soap_envel@3:

; 13377:       if ((p[1].out = (char*)SOAP_MALLOC(soap, sizeof(soap_enc1))))

	push	42					; 0000002aH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR [ebx+28], eax
	test	eax, eax
	je	$LN1@soap_envel@3

; 13378:         strcpy(p[1].out, soap_enc1);

	mov	ecx, OFFSET _soap_enc1
	mov	edx, eax
	npad	2
$LL15@soap_envel@3:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL15@soap_envel@3
	pop	ebx
	pop	edi

; 13386:     }
; 13387:   }
; 13388:   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 13389: }

	ret	0
$LN7@soap_envel@3:

; 13379:     }
; 13380:     else if (!strcmp(ns, soap_env2))

	mov	ecx, OFFSET _soap_env2
	mov	eax, edi
$LL27@soap_envel@3:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN28@soap_envel@3
	test	dl, dl
	je	SHORT $LN29@soap_envel@3
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN28@soap_envel@3
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL27@soap_envel@3
$LN29@soap_envel@3:
	xor	eax, eax
	jmp	SHORT $LN30@soap_envel@3
$LN28@soap_envel@3:
	sbb	eax, eax
	sbb	eax, -1
$LN30@soap_envel@3:
	test	eax, eax
	jne	SHORT $LN1@soap_envel@3

; 13381:     { soap->version = 2; /* make sure we use SOAP 1.2 */

	mov	eax, 2
	mov	WORD PTR [esi+6], ax

; 13382:       if (p[1].out)

	mov	eax, DWORD PTR [ebx+28]
	test	eax, eax
	je	SHORT $LN2@soap_envel@3

; 13383:         SOAP_FREE(soap, p[1].out);

	push	eax
	call	_free
	add	esp, 4
$LN2@soap_envel@3:

; 13384:       if ((p[1].out = (char*)SOAP_MALLOC(soap, sizeof(soap_enc2))))

	push	40					; 00000028H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR [ebx+28], eax
	test	eax, eax
	je	SHORT $LN1@soap_envel@3

; 13385:         strcpy(p[1].out, soap_enc2);

	mov	ecx, OFFSET _soap_enc2
	mov	edx, eax
$LL16@soap_envel@3:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL16@soap_envel@3
$LN1@soap_envel@3:

; 13386:     }
; 13387:   }
; 13388:   return SOAP_OK;

	xor	eax, eax
	pop	ebx
$LN13@soap_envel@3:
	pop	edi
	pop	esi

; 13389: }

	ret	0
_soap_envelope_begin_in ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_s$ = -8220						; size = 4
_httpcmd$ = -8216					; size = 2
_l$83546 = -8212					; size = 4
_status$ = -8208					; size = 2
_k$ = -8204						; size = 2
tv416 = -8200						; size = 4
_header$ = -8196					; size = 8192
__$ArrayPad$ = -4					; size = 4
_soap$ = 8						; size = 4
_http_parse PROC

; 12908: { char header[SOAP_HDRLEN], *s;

	mov	eax, 8220				; 0000201cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+8220], eax
	push	ebx

; 12909:   unsigned short httpcmd = 0, status = 0, k = 0;

	xor	ebx, ebx
	push	ebp
	mov	ebp, DWORD PTR _soap$[esp+8224]
	push	esi

; 12910:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Waiting for HTTP request/response...\n"));
; 12911:   *soap->endpoint = '\0';

	lea	eax, DWORD PTR [ebp+87320]
	push	edi
	mov	DWORD PTR tv416[esp+8236], eax
	mov	BYTE PTR [eax], bl

; 12912:   soap->length = 0;
; 12913:   soap->userid = NULL;
; 12914:   soap->passwd = NULL;
; 12915:   soap->action = NULL;
; 12916:   soap->authrealm = NULL;
; 12917:   soap->proxy_from = NULL;
; 12918:   soap->http_content = NULL;
; 12919:   soap->status = 0;
; 12920:   do
; 12921:   { if (soap_getline(soap, soap->msgbuf, sizeof(soap->msgbuf)))

	lea	eax, DWORD PTR [ebp+78004]
	push	1024					; 00000400H
	push	eax
	mov	eax, ebp
	mov	DWORD PTR _httpcmd$[esp+8244], ebx
	mov	DWORD PTR _status$[esp+8244], ebx
	mov	DWORD PTR [ebp+12452], ebx
	mov	DWORD PTR [ebp+12224], ebx
	mov	DWORD PTR [ebp+12228], ebx
	mov	DWORD PTR [ebp+90392], ebx
	mov	DWORD PTR [ebp+90396], ebx
	mov	DWORD PTR [ebp+90452], ebx
	mov	DWORD PTR [ebp+36], ebx
	mov	DWORD PTR [ebp+90456], ebx
	call	_soap_getline
	add	esp, 8
	test	eax, eax
	jne	$LN84@http_parse@2
$LL66@http_parse@2:

; 12925:     }
; 12926:     DBGLOG(TEST,SOAP_MESSAGE(fdebug, "HTTP status: %s\n", soap->msgbuf));
; 12927:     for (;;)
; 12928:     { if (soap_getline(soap, header, SOAP_HDRLEN))

	lea	eax, DWORD PTR _header$[esp+8236]
	push	8192					; 00002000H
	push	eax
	mov	eax, ebp
	call	_soap_getline
	add	esp, 8
	test	eax, eax
	jne	$LN81@http_parse@2
$LL61@http_parse@2:

; 12931:           DBGLOG(TEST,SOAP_MESSAGE(fdebug, "EOF in HTTP header, continue anyway\n"));
; 12932:           break;
; 12933:         }
; 12934:         return soap->error;
; 12935:       }
; 12936:       if (!*header)

	cmp	BYTE PTR _header$[esp+8236], bl
	je	$LN82@http_parse@2

; 12937:         break;
; 12938:       DBGLOG(TEST,SOAP_MESSAGE(fdebug, "HTTP header: %s\n", header));
; 12939:       s = strchr(header, ':');

	lea	ecx, DWORD PTR _header$[esp+8236]
	push	58					; 0000003aH
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _s$[esp+8236], eax

; 12940:       if (s)

	cmp	eax, ebx
	je	$LN47@http_parse@2

; 12941:       { char *t;
; 12942:         *s = '\0';

	mov	BYTE PTR [eax], bl
	mov	ecx, DWORD PTR _s$[esp+8236]
	npad	5
$LL55@http_parse@2:

; 12943:         do s++;

	inc	ecx
	mov	DWORD PTR _s$[esp+8236], ecx

; 12944:         while (*s && *s <= 32);

	mov	al, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN52@http_parse@2
	cmp	al, 32					; 00000020H
	jle	SHORT $LL55@http_parse@2
$LN52@http_parse@2:

; 12945:         if (*s == '"')

	cmp	BYTE PTR [ecx], 34			; 00000022H
	jne	SHORT $LN51@http_parse@2

; 12946:           s++;

	inc	ecx
	mov	DWORD PTR _s$[esp+8236], ecx
$LN51@http_parse@2:

; 12947:         t = s + strlen(s) - 1;

	mov	eax, ecx
	lea	esi, DWORD PTR [eax+1]
	npad	2
$LL87@http_parse@2:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL87@http_parse@2
	sub	eax, esi
	lea	eax, DWORD PTR [eax+ecx-1]

; 12948:         while (t > s && *t <= 32)

	cmp	eax, ecx
	jbe	SHORT $LN93@http_parse@2
$LL50@http_parse@2:
	cmp	BYTE PTR [eax], 32			; 00000020H
	jg	SHORT $LN49@http_parse@2

; 12949:           t--;

	dec	eax
	cmp	eax, ecx
	ja	SHORT $LL50@http_parse@2
$LN49@http_parse@2:

; 12950:         if (t >= s && *t == '"')

	cmp	eax, ecx
$LN93@http_parse@2:
	jb	SHORT $LN48@http_parse@2
	cmp	BYTE PTR [eax], 34			; 00000022H
	jne	SHORT $LN48@http_parse@2

; 12951:           t--;

	dec	eax
$LN48@http_parse@2:

; 12952:         t[1] = '\0';

	mov	BYTE PTR [eax+1], bl

; 12953:         if ((soap->error = soap->fparsehdr(soap, header, s)))

	mov	edx, DWORD PTR _s$[esp+8236]
	mov	ecx, DWORD PTR [ebp+12268]
	push	edx
	lea	eax, DWORD PTR _header$[esp+8240]
	push	eax
	push	ebp
	call	ecx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp+90460], eax
	cmp	eax, ebx
	je	SHORT $LN47@http_parse@2

; 12954:         { if (soap->error < SOAP_STOP)

	cmp	eax, 1000				; 000003e8H
	jl	$LN67@http_parse@2

; 12955:             return soap->error;
; 12956:           status = soap->error;

	movzx	edx, ax
	mov	DWORD PTR _status$[esp+8236], edx

; 12957:           soap->error = SOAP_OK;

	mov	DWORD PTR [ebp+90460], ebx
$LN47@http_parse@2:
	lea	eax, DWORD PTR _header$[esp+8236]
	push	8192					; 00002000H
	push	eax
	mov	eax, ebp
	call	_soap_getline
	add	esp, 8
	test	eax, eax
	je	$LL61@http_parse@2
$LN81@http_parse@2:

; 12929:       { if (soap->error == SOAP_EOF)

	cmp	DWORD PTR [ebp+90460], -1
	jne	$LN15@http_parse@2

; 12930:         { soap->error = SOAP_OK;

	mov	DWORD PTR [ebp+90460], ebx
$LN82@http_parse@2:

; 12958:         }
; 12959:       }
; 12960:     }
; 12961:     if ((s = strchr(soap->msgbuf, ' ')))

	push	32					; 00000020H
	lea	esi, DWORD PTR [ebp+78004]
	push	esi
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _s$[esp+8236], eax
	cmp	eax, ebx
	je	SHORT $LN43@http_parse@2

; 12962:     { k = (unsigned short)soap_strtoul(s, &s, 10);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _s$[esp+8240]
	push	ecx
	push	eax
	call	_strtoul

; 12963:       if (!soap_blank(*s))

	mov	edx, DWORD PTR _s$[esp+8248]
	movzx	edi, ax
	mov	al, BYTE PTR [edx]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[esp+8236], edi
	test	al, al
	jl	SHORT $LN43@http_parse@2
	cmp	al, 32					; 00000020H
	jg	SHORT $LN43@http_parse@2

; 12965:     }
; 12966:     else
; 12967:       k = 0;
; 12968:   } while (k == 100);

	cmp	di, 100					; 00000064H
	jne	SHORT $LN85@http_parse@2
	push	1024					; 00000400H
	push	esi
	mov	eax, ebp
	call	_soap_getline
	add	esp, 8
	test	eax, eax
	je	$LL66@http_parse@2
$LN84@http_parse@2:

; 12922:     { if (soap->error == SOAP_EOF)

	or	eax, -1
	cmp	DWORD PTR [ebp+90460], eax

; 12923:         return SOAP_EOF;

	je	$LN67@http_parse@2

; 12924:       return soap->error = 414;

	mov	eax, 414				; 0000019eH
	mov	DWORD PTR [ebp+90460], eax
	jmp	$LN67@http_parse@2
$LN43@http_parse@2:

; 12964:         k = 0;

	xor	edi, edi
	mov	DWORD PTR _k$[esp+8236], edi
$LN85@http_parse@2:

; 12969:   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Finished HTTP header parsing, status = %d\n", k));
; 12970:   s = strstr(soap->msgbuf, "HTTP/");

	push	OFFSET ??_C@_05FKGKDBHO@HTTP?1?$AA@
	push	esi
	call	_strstr
	add	esp, 8
	mov	DWORD PTR _s$[esp+8236], eax

; 12971:   if (s && s[7] != '1')

	cmp	eax, ebx
	je	SHORT $LN91@http_parse@2
	cmp	BYTE PTR [eax+7], 49			; 00000031H
	je	SHORT $LN91@http_parse@2

; 12972:   { if (soap->keep_alive == 1)

	cmp	WORD PTR [ebp+90412], 1
	jne	SHORT $LN40@http_parse@2

; 12973:       soap->keep_alive = 0;

	xor	ecx, ecx
	mov	WORD PTR [ebp+90412], cx
$LN40@http_parse@2:

; 12974:     if (k == 0 && (soap->omode & SOAP_IO) == SOAP_IO_CHUNK) /* k == 0 for HTTP request */

	cmp	di, bx
	jne	SHORT $LN91@http_parse@2
	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, ecx
	and	edx, 3
	cmp	dl, 3
	jne	SHORT $LN91@http_parse@2

; 12975:     { soap->imode |= SOAP_IO_CHUNK;

	or	DWORD PTR [ebp+12], 3

; 12976:       soap->omode = (soap->omode & ~SOAP_IO) | SOAP_IO_STORE;

	and	ecx, -2					; fffffffeH
	or	ecx, 2
	mov	DWORD PTR [ebp+16], ecx
$LN91@http_parse@2:

; 12977:     }
; 12978:   }
; 12979:   if (soap->keep_alive < 0)

	cmp	WORD PTR [ebp+90412], bx
	jge	SHORT $LN38@http_parse@2

; 12980:     soap->keep_alive = 1;

	mov	ecx, 1
	mov	WORD PTR [ebp+90412], cx
$LN38@http_parse@2:

; 12981:   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Keep alive connection = %d\n", soap->keep_alive));
; 12982:   if (k == 0)

	cmp	di, bx
	jne	$LN10@http_parse@2

; 12983:   { size_t l = 0;
; 12984:     if (s)

	cmp	eax, ebx
	je	$LN26@http_parse@2

; 12985:     { if (!strncmp(soap->msgbuf, "POST ", l = 5))

	mov	edi, 5
	push	edi
	push	OFFSET ??_C@_05LPJJJLLB@POST?5?$AA@
	push	esi
	mov	DWORD PTR _l$83546[esp+8248], edi
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN35@http_parse@2

; 12986:         httpcmd = 1;

	mov	DWORD PTR _httpcmd$[esp+8236], 1
	jmp	$LN92@http_parse@2
$LN35@http_parse@2:

; 12987:       else if (!strncmp(soap->msgbuf, "GET ", l = 4))

	mov	edi, 4
	push	edi
	push	OFFSET ??_C@_04IBPFIGHK@GET?5?$AA@
	push	esi
	mov	DWORD PTR _l$83546[esp+8248], edi
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN33@http_parse@2

; 12988:         httpcmd = 2;

	mov	DWORD PTR _httpcmd$[esp+8236], 2
	jmp	SHORT $LN92@http_parse@2
$LN33@http_parse@2:

; 12989:       else if (!strncmp(soap->msgbuf, "PUT ", l = 4))

	push	4
	push	OFFSET ??_C@_04DCMJKHH@PUT?5?$AA@
	push	esi
	mov	DWORD PTR _l$83546[esp+8248], edi
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN31@http_parse@2

; 12990:         httpcmd = 3;

	mov	DWORD PTR _httpcmd$[esp+8236], 3
	jmp	SHORT $LN92@http_parse@2
$LN31@http_parse@2:

; 12991:       else if (!strncmp(soap->msgbuf, "DELETE ", l = 7))

	mov	edi, 7
	push	edi
	push	OFFSET ??_C@_07GOAKFIAN@DELETE?5?$AA@
	push	esi
	mov	DWORD PTR _l$83546[esp+8248], edi
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN29@http_parse@2

; 12992:         httpcmd = 4;

	mov	DWORD PTR _httpcmd$[esp+8236], 4
	jmp	SHORT $LN92@http_parse@2
$LN29@http_parse@2:

; 12993:       else if (!strncmp(soap->msgbuf, "HEAD ", l = 5))

	mov	edi, 5
	push	edi
	push	OFFSET ??_C@_05PMJKDPIC@HEAD?5?$AA@
	push	esi
	mov	DWORD PTR _l$83546[esp+8248], edi
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN92@http_parse@2

; 12994:         httpcmd = 5;

	mov	DWORD PTR _httpcmd$[esp+8236], edi
$LN92@http_parse@2:

; 12995:     }
; 12996:     if (s && httpcmd)

	mov	eax, DWORD PTR _s$[esp+8236]
	cmp	eax, ebx
	je	$LN26@http_parse@2
	cmp	WORD PTR _httpcmd$[esp+8236], bx
	je	$LN26@http_parse@2

; 12997:     { size_t m = strlen(soap->endpoint);

	mov	ecx, DWORD PTR tv416[esp+8236]
	lea	esi, DWORD PTR [ecx+1]
	npad	7
$LL88@http_parse@2:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL88@http_parse@2
	sub	ecx, esi
	mov	esi, ecx

; 12998:       size_t n = m + (s - soap->msgbuf) - l - 1;

	mov	edx, esi
	sub	edx, ebp
	sub	edx, edi
	lea	edi, DWORD PTR [edx+eax-78005]

; 12999:       if (m > n)

	cmp	esi, edi

; 13000:         m = n;

	cmova	esi, edi

; 13001:       if (n >= sizeof(soap->endpoint))

	cmp	edi, 1024				; 00000400H
	jb	SHORT $LN24@http_parse@2

; 13002:         n = sizeof(soap->endpoint) - 1;

	mov	edi, 1023				; 000003ffH
$LN24@http_parse@2:

; 13003:       strncpy(soap->path, soap->msgbuf + l, n - m);

	mov	ecx, DWORD PTR _l$83546[esp+8236]
	mov	eax, edi
	sub	eax, esi
	push	eax
	lea	edx, DWORD PTR [ecx+ebp+78004]
	push	edx
	lea	ebx, DWORD PTR [ebp+88344]
	push	ebx
	call	_strncpy

; 13004:       soap->path[n - m] = '\0';

	mov	eax, ebp
	add	esp, 12					; 0000000cH
	sub	eax, esi
	mov	BYTE PTR [eax+edi+88344], 0

; 13005:       strcat(soap->endpoint, soap->path);

	mov	eax, ebx
	mov	ecx, ebx
	npad	6
$LL89@http_parse@2:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL89@http_parse@2
	mov	edi, DWORD PTR tv416[esp+8236]
	sub	eax, ecx
	mov	esi, ecx
	dec	edi
$LL90@http_parse@2:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL90@http_parse@2
	mov	ecx, eax
	shr	ecx, 2
	rep movsd
	mov	ecx, eax

; 13006:       DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Target endpoint='%s'\n", soap->endpoint));
; 13007:       if (httpcmd > 1)

	mov	eax, DWORD PTR _httpcmd$[esp+8236]
	and	ecx, 3
	rep movsb
	cmp	ax, 1
	jbe	$LN23@http_parse@2

; 13008:       { switch (httpcmd)

	movzx	eax, ax
	add	eax, -2					; fffffffeH
	cmp	eax, 3
	ja	SHORT $LN16@http_parse@2
	jmp	DWORD PTR $LN94@http_parse@2[eax*4]
$LN20@http_parse@2:

; 13009:         { case  2: soap->error = soap->fget(soap); break;

	mov	ecx, DWORD PTR [ebp+12236]
	push	ebp
	call	ecx
	add	esp, 4
	mov	DWORD PTR [ebp+90460], eax
	jmp	SHORT $LN21@http_parse@2
$LN19@http_parse@2:

; 13010:           case  3: soap->error = soap->fput(soap); break;

	mov	edx, DWORD PTR [ebp+12240]
	push	ebp
	call	edx
	add	esp, 4
	mov	DWORD PTR [ebp+90460], eax
	jmp	SHORT $LN21@http_parse@2
$LN18@http_parse@2:

; 13011:           case  4: soap->error = soap->fdel(soap); break;

	mov	eax, DWORD PTR [ebp+12244]
	push	ebp
	call	eax
	add	esp, 4
	mov	DWORD PTR [ebp+90460], eax
	jmp	SHORT $LN21@http_parse@2
$LN17@http_parse@2:

; 13012:           case  5: soap->error = soap->fhead(soap); break;

	mov	ecx, DWORD PTR [ebp+12248]
	push	ebp
	call	ecx
	add	esp, 4
	mov	DWORD PTR [ebp+90460], eax
	jmp	SHORT $LN21@http_parse@2
$LN16@http_parse@2:

; 13013: 	  default: soap->error = SOAP_HTTP_METHOD; break;

	mov	DWORD PTR [ebp+90460], 19		; 00000013H
$LN21@http_parse@2:

; 13014: 	}
; 13015:         if (soap->error == SOAP_OK)

	cmp	DWORD PTR [ebp+90460], 0
	jne	SHORT $LN15@http_parse@2

; 13016:           soap->error = SOAP_STOP; /* prevents further processing */

	mov	DWORD PTR [ebp+90460], 1000		; 000003e8H
$LN15@http_parse@2:

; 13017:         return soap->error;

	mov	eax, DWORD PTR [ebp+90460]
	jmp	$LN67@http_parse@2
$LN23@http_parse@2:

; 13018:       }
; 13019:       if (status)

	cmp	WORD PTR _status$[esp+8236], 0
	je	SHORT $LN10@http_parse@2

; 13020:         return soap->error = status;

	movzx	eax, WORD PTR _status$[esp+8236]
	mov	DWORD PTR [ebp+90460], eax
	jmp	$LN67@http_parse@2
$LN26@http_parse@2:

; 13021:     }
; 13022:     else if (status)

	mov	ecx, DWORD PTR _status$[esp+8236]
	cmp	cx, bx
	je	SHORT $LN12@http_parse@2

; 13023:       return soap->error = status;

	movzx	eax, cx
	mov	DWORD PTR [ebp+90460], eax
	jmp	$LN67@http_parse@2
$LN12@http_parse@2:

; 13024:     else if (s)

	cmp	eax, ebx
	je	SHORT $LN10@http_parse@2

; 13025:       return soap->error = 405;

	mov	eax, 405				; 00000195H
	mov	DWORD PTR [ebp+90460], eax
	jmp	$LN67@http_parse@2
$LN10@http_parse@2:

; 13026:   }
; 13027:   soap->status = k;

	mov	eax, DWORD PTR _k$[esp+8236]
	movzx	edi, ax
	mov	DWORD PTR [ebp+90456], edi

; 13028:   /* Status OK (HTTP 200) */
; 13029:   if (k == 0 || k == 200)

	test	ax, ax
	je	SHORT $LN8@http_parse@2
	mov	edx, 200				; 000000c8H
	cmp	ax, dx
	je	SHORT $LN8@http_parse@2

; 13031:   /* Status 201 (Created), 202 (Accepted), ... and HTTP 400 and 500 errors.
; 13032:      Only keep parsing HTTP body when content-length>0 or chunked is set.
; 13033:   */
; 13034:   if (((k > 200 && k <= 299) || k == 400 || k == 500) && (soap->length > 0 || (soap->imode & SOAP_IO) == SOAP_IO_CHUNK))

	mov	ecx, edx
	cmp	ax, cx
	jbe	SHORT $LN5@http_parse@2
	mov	edx, 299				; 0000012bH
	cmp	ax, dx
	jbe	SHORT $LN6@http_parse@2
$LN5@http_parse@2:
	mov	ecx, 400				; 00000190H
	cmp	ax, cx
	je	SHORT $LN6@http_parse@2
	mov	edx, 500				; 000001f4H
	cmp	ax, dx
	jne	SHORT $LN7@http_parse@2
$LN6@http_parse@2:
	cmp	DWORD PTR [ebp+12452], 0
	ja	SHORT $LN8@http_parse@2
	mov	ecx, DWORD PTR [ebp+12]
	and	ecx, 3
	cmp	cl, 3
	je	SHORT $LN8@http_parse@2
$LN7@http_parse@2:

; 13035:     return SOAP_OK;
; 13036:   /* HTTP 400 and 500 headers are supposed to set content-length or chunked.
; 13037:      For those that don't we keep parsing the body only if content type is
; 13038:      given and connection closes.
; 13039:   */
; 13040:   if ((k == 400 || k == 500) && (soap->http_content || soap->keep_alive == 0))

	mov	edx, 400				; 00000190H
	cmp	ax, dx
	je	SHORT $LN2@http_parse@2
	mov	ecx, 500				; 000001f4H
	cmp	ax, cx
	jne	SHORT $LN3@http_parse@2
$LN2@http_parse@2:
	cmp	DWORD PTR [ebp+36], 0
	jne	SHORT $LN8@http_parse@2
	cmp	WORD PTR [ebp+90412], 0
	je	SHORT $LN8@http_parse@2
$LN3@http_parse@2:

; 13041:     return SOAP_OK;
; 13042:   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "HTTP error %d\n", k));
; 13043:   return soap_set_receiver_error(soap, "HTTP Error", soap->msgbuf, k);

	lea	eax, DWORD PTR [ebp+78004]
	push	eax
	push	OFFSET ??_C@_0L@LOBKJNKF@HTTP?5Error?$AA@
	mov	esi, ebp
	call	_soap_set_receiver_error
	add	esp, 8
	jmp	SHORT $LN67@http_parse@2
$LN8@http_parse@2:

; 13030:     return SOAP_OK;

	xor	eax, eax
$LN67@http_parse@2:

; 13044: }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+8236]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 8220				; 0000201cH
	ret	0
	npad	3
$LN94@http_parse@2:
	DD	$LN20@http_parse@2
	DD	$LN19@http_parse@2
	DD	$LN18@http_parse@2
	DD	$LN17@http_parse@2
_http_parse ENDP
_TEXT	ENDS
PUBLIC	_soap_getdime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_options$83116 = -8					; size = 4
_type$83088 = -8					; size = 4
_type$83115 = -4					; size = 4
_options$83089 = -4					; size = 4
_soap_getdime PROC
; _soap$ = eax

; 11295: { while (soap->dime.flags & SOAP_DIME_CF)

	sub	esp, 8
	push	esi
	mov	esi, eax
	test	BYTE PTR [esi+90492], 1
	je	SHORT $LN41@soap_getdi@3
	npad	1
$LL42@soap_getdi@3:

; 11296:   { if (soap_getdimehdr(soap))

	call	_soap_getdimehdr
	test	eax, eax
	jne	SHORT $LN68@soap_getdi@3

; 11298:     if (soap_move(soap, (long)soap->dime.size))

	mov	eax, DWORD PTR [esi+90480]
	mov	ecx, esi
	call	_soap_move
	test	eax, eax
	jne	SHORT $LN69@soap_getdi@3

; 11295: { while (soap->dime.flags & SOAP_DIME_CF)

	test	BYTE PTR [esi+90492], 1
	jne	SHORT $LL42@soap_getdi@3
$LN41@soap_getdi@3:

; 11300:   }
; 11301:   if (soap_move(soap, (long)(((soap->dime.size+3)&(~3))-soap_tell(soap))))

	mov	ecx, DWORD PTR [esi+12448]
	xor	eax, eax
	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+12436], edi
	setne	al
	sub	ecx, eax
	sub	ecx, DWORD PTR [esi+12432]
	mov	eax, DWORD PTR [esi+90480]
	add	ecx, DWORD PTR [esi+12428]
	add	eax, 3
	and	eax, -4					; fffffffcH
	sub	eax, ecx
	mov	ecx, esi
	call	_soap_move
	test	eax, eax
	je	SHORT $LN62@soap_getdi@3

; 11302:     return soap->error = SOAP_EOF;

	or	eax, -1
	pop	edi
	mov	DWORD PTR [esi+90460], eax
	pop	esi

; 11399: }

	add	esp, 8
	ret	0
$LN68@soap_getdi@3:

; 11297:       return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	esi

; 11399: }

	add	esp, 8
	ret	0
$LN69@soap_getdi@3:

; 11299:       return soap->error = SOAP_EOF;

	or	eax, -1
	mov	DWORD PTR [esi+90460], eax
	pop	esi

; 11399: }

	add	esp, 8
	ret	0
$LN62@soap_getdi@3:
	push	ebx
	push	ebp

; 11303:   for (;;)
; 11304:   { register struct soap_multipart *content;
; 11305:     if (soap_getdimehdr(soap))

	call	_soap_getdimehdr
$LN103@soap_getdi@3:
	test	eax, eax
	jne	$LN81@soap_getdi@3

; 11306:       break;
; 11307:     if (soap->fdimewriteopen && ((soap->dime.ptr = (char*)soap->fdimewriteopen(soap, soap->dime.id, soap->dime.type, soap->dime.options)) || soap->error))

	mov	eax, DWORD PTR [esi+12360]
	cmp	eax, edi
	je	SHORT $LN34@soap_getdi@3
	mov	ecx, DWORD PTR [esi+90508]
	mov	edx, DWORD PTR [esi+90504]
	push	ecx
	mov	ecx, DWORD PTR [esi+90500]
	push	edx
	push	ecx
	push	esi
	call	eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+90496], eax
	cmp	eax, edi
	jne	$LN95@soap_getdi@3
	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, edi
	jne	$LN100@soap_getdi@3
$LN34@soap_getdi@3:

; 11349:     }
; 11350:     else if (soap->dime.flags & SOAP_DIME_CF)

	test	BYTE PTR [esi+90492], 1
	je	$LN17@soap_getdi@3

; 11351:     { const char *id, *type, *options;
; 11352:       id = soap->dime.id;
; 11353:       type = soap->dime.type;

	mov	ecx, DWORD PTR [esi+90504]

; 11354:       options = soap->dime.options;

	mov	edx, DWORD PTR [esi+90508]
	mov	ebx, DWORD PTR [esi+90500]

; 11355:       if (soap_new_block(soap))

	push	12					; 0000000cH
	mov	DWORD PTR _type$83115[esp+28], ecx
	mov	DWORD PTR _options$83116[esp+28], edx
	call	_malloc
	add	esp, 4
	cmp	eax, edi
	je	$LN83@soap_getdi@3
	mov	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [esi+92], eax
	npad	3
$LL15@soap_getdi@3:

; 11356:         return SOAP_EOM;
; 11357:       for (;;)
; 11358:       { register soap_wchar c;
; 11359:         register size_t i;
; 11360:         register char *s;
; 11361:         s = (char*)soap_push_block(soap, soap->dime.size);

	mov	edi, DWORD PTR [esi+90480]
	lea	edx, DWORD PTR [edi+8]
	push	edx
	call	_malloc
	add	esp, 4
	test	eax, eax
	je	$LN93@soap_getdi@3
	mov	ecx, DWORD PTR [esi+92]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR [esi+92]
	add	DWORD PTR [ecx+8], edi
	lea	edi, DWORD PTR [eax+8]

; 11362:         if (!s)

	test	edi, edi
	je	$LN85@soap_getdi@3

; 11363:           return soap->error = SOAP_EOM;
; 11364:         for (i = soap->dime.size; i > 0; i--)

	mov	ebp, DWORD PTR [esi+90480]
	test	ebp, ebp
	jbe	SHORT $LN10@soap_getdi@3
	npad	10
$LL12@soap_getdi@3:

; 11365:         { if ((int)(c = soap_get1(soap)) == EOF)

	mov	edx, DWORD PTR [esi+12428]
	cmp	edx, DWORD PTR [esi+12432]
	jb	SHORT $LN45@soap_getdi@3
	call	_soap_recv
	test	eax, eax
	jne	$LN98@soap_getdi@3
$LN45@soap_getdi@3:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ecx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
	cmp	ecx, -1
	je	$LN98@soap_getdi@3

; 11367:           *s++ = (char)c;

	mov	BYTE PTR [edi], cl
	inc	edi
	sub	ebp, 1
	jne	SHORT $LL12@soap_getdi@3
$LN10@soap_getdi@3:

; 11368:         }
; 11369:         if (soap_move(soap, -(long)soap->dime.size&3))

	mov	eax, DWORD PTR [esi+90480]
	neg	eax
	and	eax, 3
	mov	ecx, esi
	call	_soap_move
	test	eax, eax
	jne	$LN98@soap_getdi@3

; 11370:           return soap->error = SOAP_EOF;
; 11371:         if (!(soap->dime.flags & SOAP_DIME_CF))

	test	BYTE PTR [esi+90492], 1
	je	$LN79@soap_getdi@3

; 11372:           break;
; 11373:         if (soap_getdimehdr(soap))

	call	_soap_getdimehdr
	test	eax, eax
	je	$LL15@soap_getdi@3
$LN86@soap_getdi@3:

; 11393:       return soap->error;

	mov	eax, DWORD PTR [esi+90460]
$LN100@soap_getdi@3:
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 11399: }

	add	esp, 8
	ret	0
$LN95@soap_getdi@3:

; 11308:     { const char *id, *type, *options;
; 11309:       size_t size, n;
; 11310:       if (!soap->dime.ptr)
; 11311:         return soap->error;
; 11312:       id = soap->dime.id;
; 11313:       type = soap->dime.type;

	mov	edx, DWORD PTR [esi+90504]

; 11314:       options = soap->dime.options;

	mov	eax, DWORD PTR [esi+90508]
	mov	ebx, DWORD PTR [esi+90500]
	mov	DWORD PTR _type$83088[esp+24], edx
	mov	DWORD PTR _options$83089[esp+24], eax
	npad	3
$LL31@soap_getdi@3:

; 11315:       for (;;)
; 11316:       { size = soap->dime.size;

	mov	ebp, DWORD PTR [esi+90480]
	npad	10
$LL29@soap_getdi@3:

; 11317:         for (;;)
; 11318:         { n = soap->buflen - soap->bufidx;

	mov	eax, DWORD PTR [esi+12428]
	mov	edi, DWORD PTR [esi+12432]

; 11319:           if (size < n)
; 11320:             n = size;
; 11321:           if ((soap->error = soap->fdimewrite(soap, (void*)soap->dime.ptr, soap->buf + soap->bufidx, n)))

	mov	edx, DWORD PTR [esi+90496]
	sub	edi, eax
	cmp	ebp, edi
	cmovb	edi, ebp
	push	edi
	lea	ecx, DWORD PTR [eax+esi+12468]
	mov	eax, DWORD PTR [esi+12376]
	push	ecx
	push	edx
	push	esi
	call	eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	jne	SHORT $LN28@soap_getdi@3

; 11322:             break;
; 11323:           size -= n;

	sub	ebp, edi

; 11324:           if (!size)

	je	SHORT $LN71@soap_getdi@3

; 11326:             break;
; 11327:           }
; 11328:           if (soap_recv(soap))

	call	_soap_recv
	test	eax, eax
	je	SHORT $LL29@soap_getdi@3
$LN72@soap_getdi@3:

; 11329:           { soap->error = SOAP_EOF;

	mov	DWORD PTR [esi+90460], -1
$end$83104:

; 11340:           break;
; 11341:       }
; 11342: end:
; 11343:       if (soap->fdimewriteclose)

	mov	eax, DWORD PTR [esi+12368]
	test	eax, eax
	je	SHORT $LN19@soap_getdi@3

; 11344:         soap->fdimewriteclose(soap, (void*)soap->dime.ptr);

	mov	ecx, DWORD PTR [esi+90496]
	push	ecx
	push	esi
	call	eax
	add	esp, 8
$LN19@soap_getdi@3:

; 11345:       soap->dime.size = 0;
; 11346:       soap->dime.id = id;
; 11347:       soap->dime.type = type;

	mov	edx, DWORD PTR _type$83088[esp+24]

; 11348:       soap->dime.options = options;

	mov	eax, DWORD PTR _options$83089[esp+24]
	mov	DWORD PTR [esi+90480], 0
	mov	DWORD PTR [esi+90500], ebx
	mov	DWORD PTR [esi+90504], edx
	mov	DWORD PTR [esi+90508], eax
	jmp	$LN4@soap_getdi@3
$LN71@soap_getdi@3:

; 11325:           { soap->bufidx += n;

	add	DWORD PTR [esi+12428], edi
$LN28@soap_getdi@3:

; 11330:             goto end;
; 11331:           }
; 11332:         }
; 11333:         if (soap_move(soap, -(long)soap->dime.size&3))

	mov	eax, DWORD PTR [esi+90480]
	neg	eax
	and	eax, 3
	mov	ecx, esi
	call	_soap_move
	test	eax, eax
	jne	SHORT $LN72@soap_getdi@3

; 11334:         { soap->error = SOAP_EOF;
; 11335:           break;
; 11336:         }
; 11337:         if (!(soap->dime.flags & SOAP_DIME_CF))

	test	BYTE PTR [esi+90492], 1
	je	SHORT $end$83104

; 11338:           break;
; 11339:         if (soap_getdimehdr(soap))

	call	_soap_getdimehdr
	test	eax, eax
	je	$LL31@soap_getdi@3

; 11398:   return soap->error = SOAP_OK;

	jmp	SHORT $end$83104
$LN79@soap_getdi@3:

; 11374:           return soap->error;
; 11375:       }
; 11376:       soap->dime.size = soap->blist->size++; /* allocate one more for '\0' */

	mov	eax, DWORD PTR [esi+92]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+90480], ecx
	inc	DWORD PTR [eax+8]

; 11377:       if (!(soap->dime.ptr = soap_save_block(soap, NULL, 0)))

	mov	eax, esi
	call	_soap_save_block
	mov	DWORD PTR [esi+90496], eax
	test	eax, eax
	je	$LN86@soap_getdi@3

; 11378:         return soap->error;
; 11379:       soap->dime.ptr[soap->dime.size] = '\0'; /* force 0-terminated */

	mov	edx, DWORD PTR [esi+90480]

; 11380:       soap->dime.id = id;
; 11381:       soap->dime.type = type;
; 11382:       soap->dime.options = options;

	mov	ecx, DWORD PTR _options$83116[esp+24]
	mov	BYTE PTR [eax+edx], 0
	mov	eax, DWORD PTR _type$83115[esp+24]
	mov	DWORD PTR [esi+90500], ebx
	mov	DWORD PTR [esi+90504], eax
	mov	DWORD PTR [esi+90508], ecx

; 11383:     }
; 11384:     else

	jmp	SHORT $LN4@soap_getdi@3
$LN17@soap_getdi@3:

; 11385:       soap->dime.ptr = soap_getdimefield(soap, soap->dime.size);

	mov	edx, DWORD PTR [esi+90480]
	push	edx
	mov	eax, esi
	call	_soap_getdimefield
	add	esp, 4
	mov	DWORD PTR [esi+90496], eax
$LN4@soap_getdi@3:

; 11386:     content = soap_new_multipart(soap, &soap->dime.first, &soap->dime.last, soap->dime.ptr, soap->dime.size);

	mov	ebp, DWORD PTR [esi+90480]
	mov	ebx, DWORD PTR [esi+90496]
	mov	eax, 36					; 00000024H
	mov	edi, esi
	call	_soap_malloc
	xor	ecx, ecx
	cmp	eax, ecx
	je	$LN85@soap_getdi@3
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	cmp	DWORD PTR [esi+90516], ecx
	jne	SHORT $LN56@soap_getdi@3
	mov	DWORD PTR [esi+90516], eax
$LN56@soap_getdi@3:
	mov	edx, DWORD PTR [esi+90520]
	cmp	edx, ecx
	je	SHORT $LN55@soap_getdi@3
	mov	DWORD PTR [edx], eax
$LN55@soap_getdi@3:
	mov	DWORD PTR [esi+90520], eax

; 11389:     content->id = soap->dime.id;

	mov	edx, DWORD PTR [esi+90500]
	mov	DWORD PTR [eax+12], edx

; 11390:     content->type = soap->dime.type;

	mov	edx, DWORD PTR [esi+90504]
	mov	DWORD PTR [eax+16], edx

; 11391:     content->options = soap->dime.options;

	mov	edx, DWORD PTR [esi+90508]
	mov	DWORD PTR [eax+20], edx

; 11392:     if (soap->error)

	cmp	DWORD PTR [esi+90460], ecx
	jne	$LN86@soap_getdi@3

; 11394:     soap_resolve_attachment(soap, content);

	push	esi
	mov	edi, eax
	call	_soap_resolve_attachment
	add	esp, 4
	call	_soap_getdimehdr
	xor	edi, edi
	jmp	$LN103@soap_getdi@3
$LN93@soap_getdi@3:

; 11356:         return SOAP_EOM;
; 11357:       for (;;)
; 11358:       { register soap_wchar c;
; 11359:         register size_t i;
; 11360:         register char *s;
; 11361:         s = (char*)soap_push_block(soap, soap->dime.size);

	mov	DWORD PTR [esi+90460], 20		; 00000014H
$LN85@soap_getdi@3:

; 11387:     if (!content)
; 11388:       return soap->error = SOAP_EOM;

	mov	DWORD PTR [esi+90460], 20		; 00000014H
$LN83@soap_getdi@3:
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, 20					; 00000014H
	pop	esi

; 11399: }

	add	esp, 8
	ret	0
$LN81@soap_getdi@3:

; 11395:   }
; 11396:   if (soap->error != SOAP_DIME_END)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, 35					; 00000023H

; 11397:     return soap->error;

	jne	$LN100@soap_getdi@3
	pop	ebp
	pop	ebx

; 11398:   return soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], edi
	pop	edi
	xor	eax, eax
	pop	esi

; 11399: }

	add	esp, 8
	ret	0
$LN98@soap_getdi@3:
	pop	ebp
	pop	ebx

; 11366:             return soap->error = SOAP_EOF;

	or	eax, -1
	pop	edi
	mov	DWORD PTR [esi+90460], eax
	pop	esi

; 11399: }

	add	esp, 8
	ret	0
_soap_getdime ENDP
_TEXT	ENDS
PUBLIC	_soap_inwliteral
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_p$ = 12						; size = 4
_soap_inwliteral PROC
; _soap$ = eax

; 10871: { if (soap_element_begin_in(soap, tag, 1, NULL))

	push	ebx
	mov	ebx, DWORD PTR _p$[esp]
	push	ebp
	mov	ebp, DWORD PTR _tag$[esp+4]
	push	esi
	mov	esi, eax
	push	0
	push	1
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@soap_inwli

; 10872:   { if (soap->error != SOAP_NO_TAG || soap_unget(soap, soap_get(soap)) == SOAP_TT)

	cmp	DWORD PTR [esi+90460], 6
	jne	SHORT $LN12@soap_inwli
	mov	eax, esi
	call	_soap_get
	mov	DWORD PTR [esi+12436], eax
	cmp	eax, -3					; fffffffdH
	je	SHORT $LN12@soap_inwli

; 10874:     soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0
$LN25@soap_inwli:
	push	edi

; 10875:   }
; 10876:   if (!p)

	test	ebx, ebx
	jne	SHORT $LN26@soap_inwli

; 10877:   { if (!(p = (wchar_t**)soap_malloc(soap, sizeof(wchar_t*))))

	lea	eax, DWORD PTR [ebx+4]
	mov	edi, esi
	call	_soap_malloc
	mov	ebx, eax
	test	ebx, ebx

; 10878:       return NULL;

	je	SHORT $LN28@soap_inwli
$LN26@soap_inwli:

; 10879:   }
; 10880:   if (soap->body)

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN9@soap_inwli

; 10881:   { *p = soap_wstring_in(soap, 0, -1, -1);

	push	-1
	push	-1
	push	0
	push	esi
	call	_soap_wstring_in
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ebx], eax

; 10882:     if (!*p)

	test	eax, eax

; 10883:       return NULL;

	je	SHORT $LN28@soap_inwli

; 10884:     if (!**p && tag && *tag == '-')

	cmp	WORD PTR [eax], 0
	jne	SHORT $LN2@soap_inwli
	test	ebp, ebp
	je	SHORT $LN2@soap_inwli
	cmp	BYTE PTR [ebp], 45			; 0000002dH
	jne	SHORT $LN2@soap_inwli
$LN29@soap_inwli:

; 10885:     { soap->error = SOAP_NO_TAG;

	mov	DWORD PTR [esi+90460], 6
$LN28@soap_inwli:
	pop	edi
	pop	esi
	pop	ebp

; 10886:       return NULL;

	xor	eax, eax
	pop	ebx

; 10900: }

	ret	0
$LN12@soap_inwli:
	pop	esi
	pop	ebp

; 10873:       return NULL;

	xor	eax, eax
	pop	ebx

; 10900: }

	ret	0
$LN9@soap_inwli:

; 10887:     }
; 10888:   }
; 10889:   else if (tag && *tag == '-')

	test	ebp, ebp
	je	SHORT $LN5@soap_inwli
	cmp	BYTE PTR [ebp], 45			; 0000002dH

; 10890:   { soap->error = SOAP_NO_TAG;
; 10891:     return NULL;

	je	SHORT $LN29@soap_inwli
$LN5@soap_inwli:

; 10892:   }
; 10893:   else if (soap->null)

	cmp	WORD PTR [esi+87300], 0
	je	SHORT $LN3@soap_inwli

; 10894:     *p = NULL;

	mov	DWORD PTR [ebx], 0

; 10895:   else

	jmp	SHORT $LN2@soap_inwli
$LN3@soap_inwli:

; 10896:     *p = soap_wstrdup(soap, (wchar_t*)SOAP_STR_EOS);

	mov	eax, 2
	mov	edi, esi
	call	_soap_malloc
	test	eax, eax
	je	SHORT $LN17@soap_inwli
	mov	cx, WORD PTR _soap_padding
	mov	WORD PTR [eax], cx
$LN17@soap_inwli:
	mov	DWORD PTR [ebx], eax
$LN2@soap_inwli:

; 10897:   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN1@soap_inwli
	push	ebp
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 10898:     return NULL;

	jne	SHORT $LN28@soap_inwli
$LN1@soap_inwli:
	pop	edi
	pop	esi
	pop	ebp

; 10899:   return p;

	mov	eax, ebx
	pop	ebx

; 10900: }

	ret	0
_soap_inwliteral ENDP
_TEXT	ENDS
PUBLIC	_soap_inliteral
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_soap_inliteral PROC
; _soap$ = ecx
; _p$ = eax

; 10787: { if (soap_element_begin_in(soap, tag, 1, NULL))

	push	ebx
	mov	ebx, DWORD PTR _tag$[esp]
	push	esi
	push	edi
	mov	edi, eax
	push	0
	mov	esi, ecx
	push	1
	mov	eax, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@soap_inlit

; 10788:   { if (soap->error != SOAP_NO_TAG || soap_unget(soap, soap_get(soap)) == SOAP_TT)

	cmp	DWORD PTR [esi+90460], 6
	jne	SHORT $LN12@soap_inlit
	mov	eax, esi
	call	_soap_get
	mov	DWORD PTR [esi+12436], eax
	cmp	eax, -3					; fffffffdH
	je	SHORT $LN12@soap_inlit

; 10789:       return NULL;
; 10790:     soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0
$LN17@soap_inlit:

; 10791:   }
; 10792:   if (!p)

	test	edi, edi
	jne	SHORT $LN18@soap_inlit

; 10793:   { if (!(p = (char**)soap_malloc(soap, sizeof(char*))))

	lea	eax, DWORD PTR [edi+4]
	mov	edi, esi
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi

; 10794:       return NULL;

	je	SHORT $LN12@soap_inlit
$LN18@soap_inlit:

; 10795:   }
; 10796:   if (soap->body)

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN9@soap_inlit

; 10797:   { *p = soap_string_in(soap, 0, -1, -1);

	push	0
	mov	ecx, esi
	call	_soap_string_in
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 10798:     if (!*p)

	test	eax, eax

; 10799:       return NULL;

	je	SHORT $LN12@soap_inlit

; 10800:     if (!**p && tag && *tag == '-')

	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN19@soap_inlit
	test	ebx, ebx
	je	SHORT $LN19@soap_inlit
	cmp	BYTE PTR [ebx], 45			; 0000002dH
	jne	SHORT $LN19@soap_inlit
$LN20@soap_inlit:

; 10801:     { soap->error = SOAP_NO_TAG;

	mov	DWORD PTR [esi+90460], 6
$LN12@soap_inlit:
	pop	edi
	pop	esi

; 10802:       return NULL;

	xor	eax, eax
	pop	ebx

; 10816: }

	ret	0
$LN9@soap_inlit:

; 10803:     }
; 10804:   }
; 10805:   else if (tag && *tag == '-')

	test	ebx, ebx
	je	SHORT $LN5@soap_inlit
	cmp	BYTE PTR [ebx], 45			; 0000002dH

; 10806:   { soap->error = SOAP_NO_TAG;
; 10807:     return NULL;

	je	SHORT $LN20@soap_inlit
$LN5@soap_inlit:

; 10808:   }
; 10809:   else if (soap->null)

	cmp	WORD PTR [esi+87300], 0
	je	SHORT $LN3@soap_inlit

; 10810:     *p = NULL;

	mov	DWORD PTR [edi], 0

; 10811:   else

	jmp	SHORT $LN19@soap_inlit
$LN3@soap_inlit:

; 10812:     *p = soap_strdup(soap, SOAP_STR_EOS);

	push	OFFSET _soap_padding
	push	esi
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR [edi], eax
$LN19@soap_inlit:

; 10813:   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN1@soap_inlit
	push	ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 10814:     return NULL;

	jne	SHORT $LN12@soap_inlit
$LN1@soap_inlit:

; 10815:   return p;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 10816: }

	ret	0
_soap_inliteral ENDP
_TEXT	ENDS
PUBLIC	_soap_indateTime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_indateTime PROC

; 10722: { if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	eax, DWORD PTR _tag$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	ebp
	mov	ebp, DWORD PTR _t$[esp+4]
	push	esi
	push	0
	push	0
	mov	esi, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_indat
	pop	esi
	pop	ebp

; 10723:     return NULL;

	xor	eax, eax
	pop	ebx

; 10741: }

	ret	0
$LN7@soap_indat:

; 10724:   if (*soap->type
; 10725:    && soap_match_tag(soap, soap->type, type)
; 10726:    && soap_match_tag(soap, soap->type, ":dateTime"))

	cmp	BYTE PTR [ebx+83124], 0
	lea	esi, DWORD PTR [ebx+83124]
	push	edi
	je	SHORT $LN10@soap_indat
	mov	edi, DWORD PTR _type$[esp+12]
	push	esi
	push	ebx
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@soap_indat
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_09ONEMIJDH@?3dateTime?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@soap_indat

; 10727:   { soap->error = SOAP_TYPE;
; 10728:     soap_revert(soap);

	mov	eax, ebx
	mov	DWORD PTR [ebx+90460], 4
	call	_soap_revert
$LN13@soap_indat:
	pop	edi
	pop	esi
	pop	ebp

; 10729:     return NULL;

	xor	eax, eax
	pop	ebx

; 10741: }

	ret	0
$LN10@soap_indat:

; 10730:   }
; 10731:   p = (time_t*)soap_id_enter(soap, soap->id, p, t, sizeof(time_t), 0, NULL, NULL, NULL);

	mov	eax, DWORD PTR _p$[esp+12]
	push	0
	push	0
	push	8
	push	ebp
	push	eax
	lea	ecx, DWORD PTR [ebx+81076]
	push	ebx
	xor	eax, eax
	call	_soap_id_enter
	mov	edi, eax

; 10732:   if (*soap->href)

	lea	eax, DWORD PTR [ebx+82100]
	add	esp, 24					; 00000018H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@soap_indat

; 10733:     p = (time_t*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(time_t), 0, NULL);

	push	0
	push	8
	push	0
	push	ebp
	push	0
	push	edi
	push	ebx
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	mov	edi, eax
	jmp	SHORT $LN11@soap_indat
$LN5@soap_indat:

; 10734:   else if (p)

	test	edi, edi
	je	SHORT $LN11@soap_indat

; 10735:   { if (soap_s2dateTime(soap, soap_value(soap), p))

	push	ebx
	call	_soap_value
	push	ebx
	mov	esi, eax
	call	_soap_s2dateTime
	add	esp, 8
	test	eax, eax

; 10736:       return NULL;

	jne	SHORT $LN13@soap_indat
$LN11@soap_indat:

; 10737:   }
; 10738:   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN1@soap_indat
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	esi, ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 10739:     return NULL;

	jne	SHORT $LN13@soap_indat
$LN1@soap_indat:

; 10740:   return p;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10741: }

	ret	0
_soap_indateTime ENDP
_TEXT	ENDS
PUBLIC	_soap_inwstring
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_p$ = 12						; size = 4
_t$ = 16						; size = 4
_minlen$ = 20						; size = 4
_maxlen$ = 24						; size = 4
_soap_inwstring PROC
; _soap$ = eax

; 10509: { if (soap_element_begin_in(soap, tag, 1, NULL))

	push	ebx
	mov	ebx, DWORD PTR _p$[esp]
	push	ebp
	mov	ebp, DWORD PTR _tag$[esp+4]
	push	esi
	mov	esi, eax
	push	0
	push	1
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@soap_inwst

; 10510:   { if (!tag || *tag != '-' || soap->error != SOAP_NO_TAG)

	test	ebp, ebp
	je	$LN14@soap_inwst
	cmp	BYTE PTR [ebp], 45			; 0000002dH
	jne	$LN14@soap_inwst
	cmp	DWORD PTR [esi+90460], 6
	jne	$LN14@soap_inwst

; 10512:     soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0
$LN27@soap_inwst:
	push	edi

; 10513:   }
; 10514:   if (!p)

	test	ebx, ebx
	jne	SHORT $LN28@soap_inwst

; 10515:   { if (!(p = (wchar_t**)soap_malloc(soap, sizeof(wchar_t*))))

	lea	eax, DWORD PTR [ebx+4]
	mov	edi, esi
	call	_soap_malloc
	mov	ebx, eax
	test	ebx, ebx

; 10516:       return NULL;

	je	SHORT $LN30@soap_inwst
$LN28@soap_inwst:

; 10517:   }
; 10518:   if (soap->body)

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN11@soap_inwst

; 10519:   { *p = soap_wstring_in(soap, 1, minlen, maxlen);

	mov	eax, DWORD PTR _maxlen$[esp+12]
	mov	ecx, DWORD PTR _minlen$[esp+12]
	push	eax
	push	ecx
	push	1
	push	esi
	call	_soap_wstring_in
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ebx], eax

; 10520:     if (!*p || !(wchar_t*)soap_id_enter(soap, soap->id, *p, t, sizeof(wchar_t*), 0, NULL, NULL, NULL))

	test	eax, eax
	je	SHORT $LN30@soap_inwst
	mov	edx, DWORD PTR _t$[esp+12]
	push	0
	push	0
	push	4
	push	edx
	push	eax
	lea	ecx, DWORD PTR [esi+81076]
	push	esi
	xor	eax, eax
	call	_soap_id_enter
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN30@soap_inwst

; 10521:       return NULL;
; 10522:     if (!**p && tag && *tag == '-')

	mov	eax, DWORD PTR [ebx]
	cmp	WORD PTR [eax], 0
	jne	SHORT $LN3@soap_inwst
	test	ebp, ebp
	je	SHORT $LN3@soap_inwst
	cmp	BYTE PTR [ebp], 45			; 0000002dH
	jne	SHORT $LN3@soap_inwst
$LN31@soap_inwst:

; 10523:     { soap->error = SOAP_NO_TAG;

	mov	DWORD PTR [esi+90460], 6
$LN30@soap_inwst:
	pop	edi
	pop	esi
	pop	ebp

; 10524:       return NULL;

	xor	eax, eax
	pop	ebx

; 10540: }

	ret	0
$LN14@soap_inwst:
	pop	esi
	pop	ebp

; 10511:       return NULL;

	xor	eax, eax
	pop	ebx

; 10540: }

	ret	0
$LN11@soap_inwst:

; 10525:     }
; 10526:   }
; 10527:   else if (tag && *tag == '-')

	test	ebp, ebp
	je	SHORT $LN6@soap_inwst
	cmp	BYTE PTR [ebp], 45			; 0000002dH

; 10528:   { soap->error = SOAP_NO_TAG;
; 10529:     return NULL;

	je	SHORT $LN31@soap_inwst
$LN6@soap_inwst:

; 10530:   }
; 10531:   else if (soap->null)

	cmp	WORD PTR [esi+87300], 0
	je	SHORT $LN4@soap_inwst

; 10532:     *p = NULL;

	mov	DWORD PTR [ebx], 0

; 10533:   else

	jmp	SHORT $LN3@soap_inwst
$LN4@soap_inwst:

; 10534:     *p = soap_wstrdup(soap, (wchar_t*)SOAP_STR_EOS);

	mov	eax, 2
	mov	edi, esi
	call	_soap_malloc
	test	eax, eax
	je	SHORT $LN19@soap_inwst
	mov	cx, WORD PTR _soap_padding
	mov	WORD PTR [eax], cx
$LN19@soap_inwst:
	mov	DWORD PTR [ebx], eax
$LN3@soap_inwst:

; 10535:   if (*soap->href)

	cmp	BYTE PTR [esi+82100], 0
	lea	eax, DWORD PTR [esi+82100]
	je	SHORT $LN2@soap_inwst

; 10536:     p = (wchar_t**)soap_id_lookup(soap, soap->href, (void**)p, t, sizeof(wchar_t**), 0);

	mov	edx, DWORD PTR _t$[esp+12]
	push	4
	push	edx
	push	ebx
	mov	ecx, esi
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH
	mov	ebx, eax
$LN2@soap_inwst:

; 10537:   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN1@soap_inwst
	push	ebp
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 10538:     return NULL;

	jne	SHORT $LN30@soap_inwst
$LN1@soap_inwst:
	pop	edi
	pop	esi
	pop	ebp

; 10539:   return p;

	mov	eax, ebx
	pop	ebx

; 10540: }

	ret	0
_soap_inwstring ENDP
_TEXT	ENDS
PUBLIC	_soap_instring
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_t$ = 12						; size = 4
_flag$ = 16						; size = 4
_soap_instring PROC
; _soap$ = ecx
; _p$ = eax

; 10447: { if (soap_element_begin_in(soap, tag, 1, NULL))

	push	ebx
	mov	ebx, DWORD PTR _tag$[esp]
	push	ebp
	mov	ebp, DWORD PTR _t$[esp+4]
	push	esi
	push	edi
	mov	edi, eax
	push	0
	mov	esi, ecx
	push	1
	mov	eax, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@soap_instr

; 10448:   { if (!tag || *tag != '-' || soap->error != SOAP_NO_TAG)

	test	ebx, ebx
	je	$LN14@soap_instr
	cmp	BYTE PTR [ebx], 45			; 0000002dH
	jne	SHORT $LN14@soap_instr
	cmp	DWORD PTR [esi+90460], 6
	jne	SHORT $LN14@soap_instr

; 10449:       return NULL;
; 10450:     soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0
$LN19@soap_instr:

; 10451:   }
; 10452:   if (!p)

	test	edi, edi
	jne	SHORT $LN20@soap_instr

; 10453:   { if (!(p = (char**)soap_malloc(soap, sizeof(char*))))

	lea	eax, DWORD PTR [edi+4]
	mov	edi, esi
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi

; 10454:       return NULL;

	je	SHORT $LN14@soap_instr
$LN20@soap_instr:

; 10455:   }
; 10456:   if (soap->body)

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN11@soap_instr

; 10457:   { *p = soap_string_in(soap, flag, minlen, maxlen);

	mov	eax, DWORD PTR _flag$[esp+12]
	push	eax
	mov	ecx, esi
	call	_soap_string_in
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 10458:     if (!*p || !(char*)soap_id_enter(soap, soap->id, *p, t, sizeof(char*), 0, NULL, NULL, NULL))

	test	eax, eax
	je	SHORT $LN14@soap_instr
	push	0
	push	0
	push	4
	push	ebp
	push	eax
	lea	ecx, DWORD PTR [esi+81076]
	push	esi
	xor	eax, eax
	call	_soap_id_enter
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN14@soap_instr

; 10459:       return NULL;
; 10460:     if (!**p && tag && *tag == '-')

	mov	ecx, DWORD PTR [edi]
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN21@soap_instr
	test	ebx, ebx
	je	SHORT $LN21@soap_instr
	cmp	BYTE PTR [ebx], 45			; 0000002dH
	jne	SHORT $LN21@soap_instr
$LN22@soap_instr:

; 10461:     { soap->error = SOAP_NO_TAG;

	mov	DWORD PTR [esi+90460], 6
$LN14@soap_instr:
	pop	edi
	pop	esi
	pop	ebp

; 10462:       return NULL;

	xor	eax, eax
	pop	ebx

; 10478: }

	ret	0
$LN11@soap_instr:

; 10463:     }
; 10464:   }
; 10465:   else if (tag && *tag == '-')

	test	ebx, ebx
	je	SHORT $LN6@soap_instr
	cmp	BYTE PTR [ebx], 45			; 0000002dH

; 10466:   { soap->error = SOAP_NO_TAG;
; 10467:     return NULL;

	je	SHORT $LN22@soap_instr
$LN6@soap_instr:

; 10468:   }
; 10469:   else if (soap->null)

	cmp	WORD PTR [esi+87300], 0
	je	SHORT $LN4@soap_instr

; 10470:     *p = NULL;

	mov	DWORD PTR [edi], 0

; 10471:   else

	jmp	SHORT $LN21@soap_instr
$LN4@soap_instr:

; 10472:     *p = soap_strdup(soap, SOAP_STR_EOS);

	push	OFFSET _soap_padding
	push	esi
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR [edi], eax
$LN21@soap_instr:

; 10473:   if (*soap->href)

	cmp	BYTE PTR [esi+82100], 0
	lea	eax, DWORD PTR [esi+82100]
	je	SHORT $LN2@soap_instr

; 10474:     p = (char**)soap_id_lookup(soap, soap->href, (void**)p, t, sizeof(char**), 0);

	push	4
	push	ebp
	push	edi
	mov	ecx, esi
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH
	mov	edi, eax
$LN2@soap_instr:

; 10475:   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN1@soap_instr
	push	ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 10476:     return NULL;

	jne	SHORT $LN14@soap_instr
$LN1@soap_instr:

; 10477:   return p;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10478: }

	ret	0
_soap_instring ENDP
_TEXT	ENDS
PUBLIC	_soap_inULONG64
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_t$ = 20						; size = 4
_soap_inULONG64 PROC
; _soap$ = eax

; 10123: { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, DWORD PTR _t$[esp]
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR _tag$[esp+4]
	push	0
	push	0
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_inULO
	pop	esi

; 10124:     return NULL;

	xor	eax, eax
	pop	ebp

; 10147: }

	ret	0
$LN7@soap_inULO:

; 10125:   if (*soap->type
; 10126:    && soap_match_tag(soap, soap->type, type)
; 10127:    && soap_match_tag(soap, soap->type, ":positiveInteger")
; 10128:    && soap_match_tag(soap, soap->type, ":nonNegativeInteger")
; 10129:    && soap_match_tag(soap, soap->type, ":unsignedLong")
; 10130:    && soap_match_tag(soap, soap->type, ":unsignedInt")
; 10131:    && soap_match_tag(soap, soap->type, ":unsignedShort")
; 10132:    && soap_match_tag(soap, soap->type, ":unsignedByte"))

	cmp	BYTE PTR [esi+83124], 0
	push	ebx
	lea	ebx, DWORD PTR [esi+83124]
	push	edi
	je	$LN14@soap_inULO
	mov	edi, DWORD PTR _type$[esp+12]
	push	ebx
	push	esi
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN14@soap_inULO
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BB@NDNOKOEA@?3positiveInteger?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@soap_inULO
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BE@PMBJAKPA@?3nonNegativeInteger?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@soap_inULO
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0O@FKBEEKGD@?3unsignedLong?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@soap_inULO
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0N@EEHCOMNL@?3unsignedInt?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@soap_inULO
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@soap_inULO
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@soap_inULO

; 10133:   { soap->error = SOAP_TYPE;
; 10134:     soap_revert(soap);

	mov	eax, esi
	mov	DWORD PTR [esi+90460], 4
	call	_soap_revert
$LN18@soap_inULO:
	pop	edi
	pop	ebx
	pop	esi

; 10135:     return NULL;

	xor	eax, eax
	pop	ebp

; 10147: }

	ret	0
$LN14@soap_inULO:

; 10136:   }
; 10137:   p = (ULONG64*)soap_id_enter(soap, soap->id, p, t, sizeof(ULONG64), 0, NULL, NULL, NULL);

	mov	eax, DWORD PTR _p$[esp+12]
	push	0
	push	0
	push	8
	push	ebp
	push	eax
	lea	ecx, DWORD PTR [esi+81076]
	push	esi
	xor	eax, eax
	call	_soap_id_enter
	mov	edi, eax

; 10138:   if (*soap->href)

	lea	eax, DWORD PTR [esi+82100]
	add	esp, 24					; 00000018H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@soap_inULO

; 10139:     p = (ULONG64*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(ULONG64), 0, NULL);

	push	0
	push	8
	push	0
	push	ebp
	push	0
	push	edi
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	mov	edi, eax
	jmp	SHORT $LN15@soap_inULO
$LN5@soap_inULO:

; 10140:   else if (p)

	test	edi, edi
	je	SHORT $LN15@soap_inULO

; 10141:   { if (soap_s2ULONG64(soap, soap_value(soap), p))

	push	esi
	call	_soap_value
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@soap_inULO
	push	edi
	push	OFFSET ??_C@_05OINFJHGD@?$CFI64u?$AA@
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN10@soap_inULO
	mov	DWORD PTR [esi+90460], 4
$LN10@soap_inULO:
	cmp	DWORD PTR [esi+90460], 0

; 10142:       return NULL;

	jne	SHORT $LN18@soap_inULO
$LN15@soap_inULO:

; 10143:   }
; 10144:   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN1@soap_inULO
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 10145:     return NULL;

	jne	$LN18@soap_inULO
$LN1@soap_inULO:

; 10146:   return p;

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 10147: }

	ret	0
_soap_inULONG64 ENDP
_TEXT	ENDS
PUBLIC	_soap_inunsignedLong
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inunsignedLong PROC

; 10033: { if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	eax, DWORD PTR _tag$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	esi
	push	0
	push	0
	mov	esi, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_inuns
	pop	esi

; 10034:     return NULL;

	xor	eax, eax
	pop	ebx

; 10056: }

	ret	0
$LN7@soap_inuns:

; 10035: #ifndef WITH_LEAN
; 10036:   if (*soap->type
; 10037:    && soap_match_tag(soap, soap->type, type)
; 10038:    && soap_match_tag(soap, soap->type, ":unsignedInt")
; 10039:    && soap_match_tag(soap, soap->type, ":unsignedShort")
; 10040:    && soap_match_tag(soap, soap->type, ":unsignedByte"))

	cmp	BYTE PTR [ebx+83124], 0
	lea	esi, DWORD PTR [ebx+83124]
	push	edi
	je	SHORT $LN6@soap_inuns
	mov	edi, DWORD PTR _type$[esp+8]
	push	esi
	push	ebx
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inuns
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0N@EEHCOMNL@?3unsignedInt?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inuns
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inuns
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inuns

; 10041:   { soap->error = SOAP_TYPE;
; 10042:     soap_revert(soap);

	mov	eax, ebx
	mov	DWORD PTR [ebx+90460], 4
	call	_soap_revert
	pop	edi
	pop	esi

; 10043:     return NULL;

	xor	eax, eax
	pop	ebx

; 10056: }

	ret	0
$LN6@soap_inuns:

; 10044:   }
; 10045: #endif
; 10046:   p = (unsigned long*)soap_id_enter(soap, soap->id, p, t, sizeof(unsigned long), 0, NULL, NULL, NULL);

	mov	esi, DWORD PTR _t$[esp+8]
	mov	eax, DWORD PTR _p$[esp+8]
	push	ebp
	push	0
	push	0
	push	4
	push	esi
	push	eax
	lea	ecx, DWORD PTR [ebx+81076]
	push	ebx
	xor	eax, eax
	call	_soap_id_enter
	mov	ebp, eax

; 10047:   if (*soap->href)

	lea	eax, DWORD PTR [ebx+82100]
	add	esp, 24					; 00000018H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@soap_inuns

; 10048:     p = (unsigned long*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(unsigned long), 0, NULL);

	push	0
	push	4
	push	0
	push	esi
	push	0
	push	ebp
	push	ebx
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	mov	ebp, eax
	jmp	SHORT $LN10@soap_inuns
$LN5@soap_inuns:

; 10049:   else if (p)

	test	ebp, ebp
	je	SHORT $LN10@soap_inuns

; 10050:   { if (soap_s2unsignedLong(soap, soap_value(soap), p))

	push	ebp
	push	ebx
	call	_soap_value
	add	esp, 4
	mov	esi, eax
	mov	edi, ebx
	call	_soap_s2unsignedLong
	add	esp, 4
	test	eax, eax

; 10051:       return NULL;

	jne	SHORT $LN13@soap_inuns
$LN10@soap_inuns:

; 10052:   }
; 10053:   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN1@soap_inuns
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	esi, ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_inuns
$LN13@soap_inuns:
	pop	ebp
	pop	edi
	pop	esi

; 10054:     return NULL;

	xor	eax, eax
	pop	ebx

; 10056: }

	ret	0
$LN1@soap_inuns:

; 10055:   return p;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 10056: }

	ret	0
_soap_inunsignedLong ENDP
_TEXT	ENDS
PUBLIC	_soap_inunsignedInt
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inunsignedInt PROC

; 9950 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	eax, DWORD PTR _tag$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	esi
	push	0
	push	0
	mov	esi, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_inuns@2
	pop	esi

; 9951 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9973 : }

	ret	0
$LN7@soap_inuns@2:

; 9952 : #ifndef WITH_LEAN
; 9953 :   if (*soap->type
; 9954 :    && soap_match_tag(soap, soap->type, type)
; 9955 :    && soap_match_tag(soap, soap->type, ":unsignedInt")
; 9956 :    && soap_match_tag(soap, soap->type, ":unsignedShort")
; 9957 :    && soap_match_tag(soap, soap->type, ":unsignedByte"))

	cmp	BYTE PTR [ebx+83124], 0
	lea	esi, DWORD PTR [ebx+83124]
	push	edi
	je	SHORT $LN6@soap_inuns@2
	mov	edi, DWORD PTR _type$[esp+8]
	push	esi
	push	ebx
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inuns@2
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0N@EEHCOMNL@?3unsignedInt?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inuns@2
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inuns@2
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inuns@2

; 9958 :   { soap->error = SOAP_TYPE;
; 9959 :     soap_revert(soap);

	mov	eax, ebx
	mov	DWORD PTR [ebx+90460], 4
	call	_soap_revert
	pop	edi
	pop	esi

; 9960 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9973 : }

	ret	0
$LN6@soap_inuns@2:

; 9961 :   }
; 9962 : #endif
; 9963 :   p = (unsigned int*)soap_id_enter(soap, soap->id, p, t, sizeof(unsigned int), 0, NULL, NULL, NULL);

	mov	esi, DWORD PTR _t$[esp+8]
	mov	eax, DWORD PTR _p$[esp+8]
	push	ebp
	push	0
	push	0
	push	4
	push	esi
	push	eax
	lea	ecx, DWORD PTR [ebx+81076]
	push	ebx
	xor	eax, eax
	call	_soap_id_enter
	mov	ebp, eax

; 9964 :   if (*soap->href)

	lea	eax, DWORD PTR [ebx+82100]
	add	esp, 24					; 00000018H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@soap_inuns@2

; 9965 :     p = (unsigned int*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(unsigned int), 0, NULL);

	push	0
	push	4
	push	0
	push	esi
	push	0
	push	ebp
	push	ebx
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	mov	ebp, eax
	jmp	SHORT $LN10@soap_inuns@2
$LN5@soap_inuns@2:

; 9966 :   else if (p)

	test	ebp, ebp
	je	SHORT $LN10@soap_inuns@2

; 9967 :   { if (soap_s2unsignedInt(soap, soap_value(soap), p))

	push	ebp
	push	ebx
	call	_soap_value
	add	esp, 4
	mov	esi, eax
	mov	edi, ebx
	call	_soap_s2unsignedInt
	add	esp, 4
	test	eax, eax

; 9968 :       return NULL;

	jne	SHORT $LN13@soap_inuns@2
$LN10@soap_inuns@2:

; 9969 :   }
; 9970 :   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN1@soap_inuns@2
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	esi, ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_inuns@2
$LN13@soap_inuns@2:
	pop	ebp
	pop	edi
	pop	esi

; 9971 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9973 : }

	ret	0
$LN1@soap_inuns@2:

; 9972 :   return p;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 9973 : }

	ret	0
_soap_inunsignedInt ENDP
_TEXT	ENDS
PUBLIC	_soap_inunsignedShort
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inunsignedShort PROC

; 9869 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	eax, DWORD PTR _tag$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	esi
	push	0
	push	0
	mov	esi, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_inuns@3
	pop	esi

; 9870 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9891 : }

	ret	0
$LN7@soap_inuns@3:

; 9871 : #ifndef WITH_LEAN
; 9872 :   if (*soap->type
; 9873 :    && soap_match_tag(soap, soap->type, type)
; 9874 :    && soap_match_tag(soap, soap->type, ":unsignedShort")
; 9875 :    && soap_match_tag(soap, soap->type, ":unsignedByte"))

	cmp	BYTE PTR [ebx+83124], 0
	lea	esi, DWORD PTR [ebx+83124]
	push	edi
	je	SHORT $LN6@soap_inuns@3
	mov	edi, DWORD PTR _type$[esp+8]
	push	esi
	push	ebx
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inuns@3
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0P@HNEDPCPK@?3unsignedShort?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inuns@3
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inuns@3

; 9876 :   { soap->error = SOAP_TYPE;
; 9877 :     soap_revert(soap);

	mov	eax, ebx
	mov	DWORD PTR [ebx+90460], 4
	call	_soap_revert
	pop	edi
	pop	esi

; 9878 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9891 : }

	ret	0
$LN6@soap_inuns@3:

; 9879 :   }
; 9880 : #endif
; 9881 :   p = (unsigned short*)soap_id_enter(soap, soap->id, p, t, sizeof(unsigned short), 0, NULL, NULL, NULL);

	mov	esi, DWORD PTR _t$[esp+8]
	mov	eax, DWORD PTR _p$[esp+8]
	push	ebp
	push	0
	push	0
	push	2
	push	esi
	push	eax
	lea	ecx, DWORD PTR [ebx+81076]
	push	ebx
	xor	eax, eax
	call	_soap_id_enter
	mov	ebp, eax

; 9882 :   if (*soap->href)

	lea	eax, DWORD PTR [ebx+82100]
	add	esp, 24					; 00000018H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@soap_inuns@3

; 9883 :     p = (unsigned short*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(unsigned short), 0, NULL);

	push	0
	push	2
	push	0
	push	esi
	push	0
	push	ebp
	push	ebx
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	mov	ebp, eax
	jmp	SHORT $LN10@soap_inuns@3
$LN5@soap_inuns@3:

; 9884 :   else if (p)

	test	ebp, ebp
	je	SHORT $LN10@soap_inuns@3

; 9885 :   { if (soap_s2unsignedShort(soap, soap_value(soap), p))

	push	ebp
	push	ebx
	call	_soap_value
	add	esp, 4
	mov	esi, eax
	mov	edi, ebx
	call	_soap_s2unsignedShort
	add	esp, 4
	test	eax, eax

; 9886 :       return NULL;

	jne	SHORT $LN13@soap_inuns@3
$LN10@soap_inuns@3:

; 9887 :   }
; 9888 :   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN1@soap_inuns@3
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	esi, ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_inuns@3
$LN13@soap_inuns@3:
	pop	ebp
	pop	edi
	pop	esi

; 9889 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9891 : }

	ret	0
$LN1@soap_inuns@3:

; 9890 :   return p;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 9891 : }

	ret	0
_soap_inunsignedShort ENDP
_TEXT	ENDS
PUBLIC	_soap_inunsignedByte
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inunsignedByte PROC

; 9798 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	eax, DWORD PTR _tag$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	esi
	push	0
	push	0
	mov	esi, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_inuns@4
	pop	esi

; 9799 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9819 : }

	ret	0
$LN7@soap_inuns@4:

; 9800 : #ifndef WITH_LEAN
; 9801 :   if (*soap->type
; 9802 :    && soap_match_tag(soap, soap->type, type)
; 9803 :    && soap_match_tag(soap, soap->type, ":unsignedByte"))

	cmp	BYTE PTR [ebx+83124], 0
	lea	esi, DWORD PTR [ebx+83124]
	push	edi
	je	SHORT $LN6@soap_inuns@4
	mov	edi, DWORD PTR _type$[esp+8]
	push	esi
	push	ebx
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inuns@4
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_0O@LDNBLIGF@?3unsignedByte?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inuns@4

; 9804 :   { soap->error = SOAP_TYPE;
; 9805 :     soap_revert(soap);

	mov	eax, ebx
	mov	DWORD PTR [ebx+90460], 4
	call	_soap_revert
	pop	edi
	pop	esi

; 9806 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9819 : }

	ret	0
$LN6@soap_inuns@4:

; 9807 :   }
; 9808 : #endif
; 9809 :   p = (unsigned char*)soap_id_enter(soap, soap->id, p, t, sizeof(unsigned char), 0, NULL, NULL, NULL);

	mov	esi, DWORD PTR _t$[esp+8]
	mov	eax, DWORD PTR _p$[esp+8]
	push	ebp
	push	0
	push	0
	push	1
	push	esi
	push	eax
	lea	ecx, DWORD PTR [ebx+81076]
	push	ebx
	xor	eax, eax
	call	_soap_id_enter
	mov	ebp, eax

; 9810 :   if (*soap->href)

	lea	eax, DWORD PTR [ebx+82100]
	add	esp, 24					; 00000018H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@soap_inuns@4

; 9811 :     p = (unsigned char*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(unsigned char), 0, NULL);

	push	0
	push	1
	push	0
	push	esi
	push	0
	push	ebp
	push	ebx
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	mov	ebp, eax
	jmp	SHORT $LN10@soap_inuns@4
$LN5@soap_inuns@4:

; 9812 :   else if (p)

	test	ebp, ebp
	je	SHORT $LN10@soap_inuns@4

; 9813 :   { if (soap_s2unsignedByte(soap, soap_value(soap), p))

	push	ebp
	push	ebx
	call	_soap_value
	add	esp, 4
	mov	esi, eax
	mov	edi, ebx
	call	_soap_s2unsignedByte
	add	esp, 4
	test	eax, eax

; 9814 :       return NULL;

	jne	SHORT $LN13@soap_inuns@4
$LN10@soap_inuns@4:

; 9815 :   }
; 9816 :   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN1@soap_inuns@4
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	esi, ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_inuns@4
$LN13@soap_inuns@4:
	pop	ebp
	pop	edi
	pop	esi

; 9817 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9819 : }

	ret	0
$LN1@soap_inuns@4:

; 9818 :   return p;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 9819 : }

	ret	0
_soap_inunsignedByte ENDP
_TEXT	ENDS
PUBLIC	_soap_indouble
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_indouble PROC

; 9732 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	eax, DWORD PTR _tag$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	ebp
	mov	ebp, DWORD PTR _t$[esp+4]
	push	esi
	push	0
	push	0
	mov	esi, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_indou
$LN13@soap_indou:
	pop	esi
	pop	ebp

; 9733 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9748 : }

	ret	0
$LN7@soap_indou:

; 9734 : #ifndef WITH_LEAN
; 9735 :   if (*soap->type != '\0' && soap_isnumeric(soap, type))

	cmp	BYTE PTR [ebx+83124], 0
	je	SHORT $LN6@soap_indou
	mov	eax, DWORD PTR _type$[esp+8]
	call	_soap_isnumeric
	test	eax, eax

; 9736 :     return NULL;

	jne	SHORT $LN13@soap_indou
$LN6@soap_indou:

; 9737 : #endif
; 9738 :   p = (double*)soap_id_enter(soap, soap->id, p, t, sizeof(double), 0, NULL, NULL, NULL);

	mov	eax, DWORD PTR _p$[esp+8]
	push	edi
	push	0
	push	0
	push	8
	push	ebp
	push	eax
	lea	ecx, DWORD PTR [ebx+81076]
	push	ebx
	xor	eax, eax
	call	_soap_id_enter
	mov	edi, eax

; 9739 :   if (*soap->href)

	lea	eax, DWORD PTR [ebx+82100]
	add	esp, 24					; 00000018H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@soap_indou

; 9740 :     p = (double*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(double), 0, NULL);

	push	0
	push	8
	push	0
	push	ebp
	push	0
	push	edi
	push	ebx
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	mov	edi, eax
	jmp	SHORT $LN10@soap_indou
$LN5@soap_indou:

; 9741 :   else if (p)

	test	edi, edi
	je	SHORT $LN10@soap_indou

; 9742 :   { if (soap_s2double(soap, soap_value(soap), p))

	push	ebx
	call	_soap_value
	push	ebx
	mov	esi, eax
	call	_soap_s2double
	add	esp, 8
	test	eax, eax

; 9743 :       return NULL;

	jne	SHORT $LN12@soap_indou
$LN10@soap_indou:

; 9744 :   }
; 9745 :   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN1@soap_indou
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	esi, ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_indou
$LN12@soap_indou:
	pop	edi
	pop	esi
	pop	ebp

; 9746 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9748 : }

	ret	0
$LN1@soap_indou:

; 9747 :   return p;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 9748 : }

	ret	0
_soap_indouble ENDP
_TEXT	ENDS
PUBLIC	_soap_infloat
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_soap_infloat PROC

; 9625 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	ebp
	mov	ebp, DWORD PTR _tag$[esp+4]
	push	esi
	push	0
	push	0
	mov	eax, ebp
	mov	esi, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_inflo
$LN13@soap_inflo:
	pop	esi
	pop	ebp

; 9626 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9641 : }

	ret	0
$LN7@soap_inflo:

; 9627 : #ifndef WITH_LEAN
; 9628 :   if (*soap->type != '\0' && soap_isnumeric(soap, type))

	cmp	BYTE PTR [ebx+83124], 0
	je	SHORT $LN6@soap_inflo
	mov	eax, DWORD PTR _type$[esp+8]
	call	_soap_isnumeric
	test	eax, eax

; 9629 :     return NULL;

	jne	SHORT $LN13@soap_inflo
$LN6@soap_inflo:

; 9630 : #endif
; 9631 :   p = (float*)soap_id_enter(soap, soap->id, p, t, sizeof(float), 0, NULL, NULL, NULL);

	mov	eax, DWORD PTR _p$[esp+8]
	push	edi
	push	0
	push	0
	push	4
	push	13					; 0000000dH
	push	eax
	lea	ecx, DWORD PTR [ebx+81076]
	push	ebx
	xor	eax, eax
	call	_soap_id_enter
	mov	edi, eax

; 9632 :   if (*soap->href)

	lea	eax, DWORD PTR [ebx+82100]
	add	esp, 24					; 00000018H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@soap_inflo

; 9633 :     p = (float*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(float), 0, NULL);

	push	0
	push	4
	push	0
	push	13					; 0000000dH
	push	0
	push	edi
	push	ebx
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	mov	edi, eax
	jmp	SHORT $LN10@soap_inflo
$LN5@soap_inflo:

; 9634 :   else if (p)

	test	edi, edi
	je	SHORT $LN10@soap_inflo

; 9635 :   { if (soap_s2float(soap, soap_value(soap), p))

	push	ebx
	call	_soap_value
	push	ebx
	mov	esi, eax
	call	_soap_s2float
	add	esp, 8
	test	eax, eax

; 9636 :       return NULL;

	jne	SHORT $LN12@soap_inflo
$LN10@soap_inflo:

; 9637 :   }
; 9638 :   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN1@soap_inflo
	push	ebp
	mov	esi, ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_inflo
$LN12@soap_inflo:
	pop	edi
	pop	esi
	pop	ebp

; 9639 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9641 : }

	ret	0
$LN1@soap_inflo:

; 9640 :   return p;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 9641 : }

	ret	0
_soap_infloat ENDP
_TEXT	ENDS
PUBLIC	_soap_inshort
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inshort PROC

; 9475 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	eax, DWORD PTR _tag$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	esi
	push	0
	push	0
	mov	esi, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_insho
	pop	esi

; 9476 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9497 : }

	ret	0
$LN7@soap_insho:

; 9477 : #ifndef WITH_LEAN
; 9478 :   if (*soap->type
; 9479 :    && soap_match_tag(soap, soap->type, type)
; 9480 :    && soap_match_tag(soap, soap->type, ":short")
; 9481 :    && soap_match_tag(soap, soap->type, ":byte"))

	cmp	BYTE PTR [ebx+83124], 0
	lea	esi, DWORD PTR [ebx+83124]
	push	edi
	je	SHORT $LN6@soap_insho
	mov	edi, DWORD PTR _type$[esp+8]
	push	esi
	push	ebx
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_insho
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_06DFBHHOOH@?3short?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_insho
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_05FFGLOOMC@?3byte?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_insho

; 9482 :   { soap->error = SOAP_TYPE;
; 9483 :     soap_revert(soap);

	mov	eax, ebx
	mov	DWORD PTR [ebx+90460], 4
	call	_soap_revert
	pop	edi
	pop	esi

; 9484 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9497 : }

	ret	0
$LN6@soap_insho:

; 9485 :   }
; 9486 : #endif
; 9487 :   p = (short*)soap_id_enter(soap, soap->id, p, t, sizeof(short), 0, NULL, NULL, NULL);

	mov	esi, DWORD PTR _t$[esp+8]
	mov	eax, DWORD PTR _p$[esp+8]
	push	ebp
	push	0
	push	0
	push	2
	push	esi
	push	eax
	lea	ecx, DWORD PTR [ebx+81076]
	push	ebx
	xor	eax, eax
	call	_soap_id_enter
	mov	ebp, eax

; 9488 :   if (*soap->href)

	lea	eax, DWORD PTR [ebx+82100]
	add	esp, 24					; 00000018H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@soap_insho

; 9489 :     p = (short*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(short), 0, NULL);

	push	0
	push	2
	push	0
	push	esi
	push	0
	push	ebp
	push	ebx
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	mov	ebp, eax
	jmp	SHORT $LN10@soap_insho
$LN5@soap_insho:

; 9490 :   else if (p)

	test	ebp, ebp
	je	SHORT $LN10@soap_insho

; 9491 :   { if (soap_s2short(soap, soap_value(soap), p))

	push	ebp
	push	ebx
	call	_soap_value
	add	esp, 4
	mov	esi, eax
	mov	edi, ebx
	call	_soap_s2short
	add	esp, 4
	test	eax, eax

; 9492 :       return NULL;

	jne	SHORT $LN13@soap_insho
$LN10@soap_insho:

; 9493 :   }
; 9494 :   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN1@soap_insho
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	esi, ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_insho
$LN13@soap_insho:
	pop	ebp
	pop	edi
	pop	esi

; 9495 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9497 : }

	ret	0
$LN1@soap_insho:

; 9496 :   return p;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 9497 : }

	ret	0
_soap_inshort ENDP
_TEXT	ENDS
PUBLIC	_soap_inbyte
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_soap_inbyte PROC

; 9404 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	eax, DWORD PTR _tag$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	esi
	push	0
	push	0
	mov	esi, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_inbyt
	pop	esi

; 9405 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9425 : }

	ret	0
$LN7@soap_inbyt:

; 9406 : #ifndef WITH_LEAN
; 9407 :   if (*soap->type
; 9408 :    && soap_match_tag(soap, soap->type, type)
; 9409 :    && soap_match_tag(soap, soap->type, ":byte"))

	cmp	BYTE PTR [ebx+83124], 0
	lea	esi, DWORD PTR [ebx+83124]
	push	edi
	je	SHORT $LN6@soap_inbyt
	mov	edi, DWORD PTR _type$[esp+8]
	push	esi
	push	ebx
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inbyt
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_05FFGLOOMC@?3byte?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inbyt

; 9410 :   { soap->error = SOAP_TYPE;
; 9411 :     soap_revert(soap);

	mov	eax, ebx
	mov	DWORD PTR [ebx+90460], 4
	call	_soap_revert
	pop	edi
	pop	esi

; 9412 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9425 : }

	ret	0
$LN6@soap_inbyt:

; 9413 :   }
; 9414 : #endif
; 9415 :   p = (char*)soap_id_enter(soap, soap->id, p, t, sizeof(char), 0, NULL, NULL, NULL);

	mov	eax, DWORD PTR _p$[esp+8]
	push	ebp
	push	0
	push	0
	push	1
	push	3
	push	eax
	lea	ecx, DWORD PTR [ebx+81076]
	push	ebx
	xor	eax, eax
	call	_soap_id_enter
	mov	ebp, eax

; 9416 :   if (*soap->href)

	lea	eax, DWORD PTR [ebx+82100]
	add	esp, 24					; 00000018H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@soap_inbyt

; 9417 :     p = (char*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(char), 0, NULL);

	push	0
	push	1
	push	0
	push	3
	push	0
	push	ebp
	push	ebx
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	mov	ebp, eax
	jmp	SHORT $LN10@soap_inbyt
$LN5@soap_inbyt:

; 9418 :   else if (p)

	test	ebp, ebp
	je	SHORT $LN10@soap_inbyt

; 9419 :   { if (soap_s2byte(soap, soap_value(soap), p))

	push	ebp
	push	ebx
	call	_soap_value
	add	esp, 4
	mov	esi, eax
	mov	edi, ebx
	call	_soap_s2byte
	add	esp, 4
	test	eax, eax

; 9420 :       return NULL;

	jne	SHORT $LN13@soap_inbyt
$LN10@soap_inbyt:

; 9421 :   }
; 9422 :   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN1@soap_inbyt
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	esi, ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_inbyt
$LN13@soap_inbyt:
	pop	ebp
	pop	edi
	pop	esi

; 9423 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9425 : }

	ret	0
$LN1@soap_inbyt:

; 9424 :   return p;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 9425 : }

	ret	0
_soap_inbyte ENDP
_TEXT	ENDS
PUBLIC	_soap_inLONG64
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tag$ = 8						; size = 4
_p$ = 12						; size = 4
_type$ = 16						; size = 4
_soap_inLONG64 PROC
; _soap$ = eax

; 9325 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	push	ebp
	mov	ebp, DWORD PTR _tag$[esp]
	push	esi
	mov	esi, eax
	push	0
	push	0
	mov	eax, ebp
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_inLON@3
	pop	esi

; 9326 :     return NULL;

	xor	eax, eax
	pop	ebp

; 9354 : }

	ret	0
$LN7@soap_inLON@3:

; 9327 : #ifndef WITH_LEAN
; 9328 :   if (*soap->type
; 9329 :    && soap_match_tag(soap, soap->type, type)
; 9330 :    && soap_match_tag(soap, soap->type, ":integer")
; 9331 :    && soap_match_tag(soap, soap->type, ":positiveInteger")
; 9332 :    && soap_match_tag(soap, soap->type, ":negativeInteger")
; 9333 :    && soap_match_tag(soap, soap->type, ":nonPositiveInteger")
; 9334 :    && soap_match_tag(soap, soap->type, ":nonNegativeInteger")
; 9335 :    && soap_match_tag(soap, soap->type, ":long")
; 9336 :    && soap_match_tag(soap, soap->type, ":int")
; 9337 :    && soap_match_tag(soap, soap->type, ":short")
; 9338 :    && soap_match_tag(soap, soap->type, ":byte"))

	cmp	BYTE PTR [esi+83124], 0
	push	ebx
	lea	ebx, DWORD PTR [esi+83124]
	push	edi
	je	$LN14@soap_inLON@3
	mov	edi, DWORD PTR _type$[esp+12]
	push	ebx
	push	esi
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN14@soap_inLON@3
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_08ICEBEHNK@?3integer?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN14@soap_inLON@3
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BB@NDNOKOEA@?3positiveInteger?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN14@soap_inLON@3
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BB@FHGJHLHJ@?3negativeInteger?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	$LN14@soap_inLON@3
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BE@HIKONPMJ@?3nonPositiveInteger?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@soap_inLON@3
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BE@PMBJAKPA@?3nonNegativeInteger?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@soap_inLON@3
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_05LMKOBMME@?3long?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@soap_inLON@3
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_04JNHIEKJE@?3int?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@soap_inLON@3
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_06DFBHHOOH@?3short?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@soap_inLON@3
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_05FFGLOOMC@?3byte?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@soap_inLON@3

; 9339 :   { soap->error = SOAP_TYPE;
; 9340 :     soap_revert(soap);

	mov	eax, esi
	mov	DWORD PTR [esi+90460], 4
	call	_soap_revert
$LN18@soap_inLON@3:
	pop	edi
	pop	ebx
	pop	esi

; 9341 :     return NULL;

	xor	eax, eax
	pop	ebp

; 9354 : }

	ret	0
$LN14@soap_inLON@3:

; 9342 :   }
; 9343 : #endif
; 9344 :   p = (LONG64*)soap_id_enter(soap, soap->id, p, t, sizeof(LONG64), 0, NULL, NULL, NULL);

	mov	eax, DWORD PTR _p$[esp+12]
	push	0
	push	0
	push	8
	push	16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR [esi+81076]
	push	esi
	xor	eax, eax
	call	_soap_id_enter
	mov	edi, eax

; 9345 :   if (*soap->href)

	lea	eax, DWORD PTR [esi+82100]
	add	esp, 24					; 00000018H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@soap_inLON@3

; 9346 :     p = (LONG64*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(LONG64), 0, NULL);

	push	0
	push	8
	push	0
	push	16					; 00000010H
	push	0
	push	edi
	push	esi
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	mov	edi, eax
	jmp	SHORT $LN15@soap_inLON@3
$LN5@soap_inLON@3:

; 9347 :   else if (p)

	test	edi, edi
	je	SHORT $LN15@soap_inLON@3

; 9348 :   { if (soap_s2LONG64(soap, soap_value(soap), p))

	push	esi
	call	_soap_value
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@soap_inLON@3
	push	edi
	push	OFFSET ??_C@_05LLAMLEHD@?$CFI64d?$AA@
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN10@soap_inLON@3
	mov	DWORD PTR [esi+90460], 4
$LN10@soap_inLON@3:
	cmp	DWORD PTR [esi+90460], 0

; 9349 :       return NULL;

	jne	$LN18@soap_inLON@3
$LN15@soap_inLON@3:

; 9350 :   }
; 9351 :   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN1@soap_inLON@3
	push	ebp
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax

; 9352 :     return NULL;

	jne	$LN18@soap_inLON@3
$LN1@soap_inLON@3:

; 9353 :   return p;

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 9354 : }

	ret	0
_soap_inLONG64 ENDP
_TEXT	ENDS
PUBLIC	_soap_inlong
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_t$ = 24						; size = 4
_soap_inlong PROC

; 9235 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	eax, DWORD PTR _tag$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	esi
	push	0
	push	0
	mov	esi, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_inlon
	pop	esi

; 9236 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9258 : }

	ret	0
$LN7@soap_inlon:

; 9237 : #ifndef WITH_LEAN
; 9238 :   if (*soap->type
; 9239 :    && soap_match_tag(soap, soap->type, type)
; 9240 :    && soap_match_tag(soap, soap->type, ":int")
; 9241 :    && soap_match_tag(soap, soap->type, ":short")
; 9242 :    && soap_match_tag(soap, soap->type, ":byte"))

	cmp	BYTE PTR [ebx+83124], 0
	lea	esi, DWORD PTR [ebx+83124]
	push	edi
	je	SHORT $LN6@soap_inlon
	mov	edi, DWORD PTR _type$[esp+8]
	push	esi
	push	ebx
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inlon
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_04JNHIEKJE@?3int?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inlon
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_06DFBHHOOH@?3short?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inlon
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_05FFGLOOMC@?3byte?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inlon

; 9243 :   { soap->error = SOAP_TYPE;
; 9244 :     soap_revert(soap);

	mov	eax, ebx
	mov	DWORD PTR [ebx+90460], 4
	call	_soap_revert
	pop	edi
	pop	esi

; 9245 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9258 : }

	ret	0
$LN6@soap_inlon:

; 9246 :   }
; 9247 : #endif
; 9248 :   p = (long*)soap_id_enter(soap, soap->id, p, t, sizeof(long), 0, NULL, NULL, NULL);

	mov	esi, DWORD PTR _t$[esp+8]
	mov	eax, DWORD PTR _p$[esp+8]
	push	ebp
	push	0
	push	0
	push	4
	push	esi
	push	eax
	lea	ecx, DWORD PTR [ebx+81076]
	push	ebx
	xor	eax, eax
	call	_soap_id_enter
	mov	ebp, eax

; 9249 :   if (*soap->href)

	lea	eax, DWORD PTR [ebx+82100]
	add	esp, 24					; 00000018H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@soap_inlon

; 9250 :     p = (long*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(long), 0, NULL);

	push	0
	push	4
	push	0
	push	esi
	push	0
	push	ebp
	push	ebx
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	mov	ebp, eax
	jmp	SHORT $LN10@soap_inlon
$LN5@soap_inlon:

; 9251 :   else if (p)

	test	ebp, ebp
	je	SHORT $LN10@soap_inlon

; 9252 :   { if (soap_s2long(soap, soap_value(soap), p))

	push	ebp
	push	ebx
	call	_soap_value
	add	esp, 4
	mov	esi, eax
	mov	edi, ebx
	call	_soap_s2long
	add	esp, 4
	test	eax, eax

; 9253 :       return NULL;

	jne	SHORT $LN13@soap_inlon
$LN10@soap_inlon:

; 9254 :   }
; 9255 :   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN1@soap_inlon
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	esi, ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_inlon
$LN13@soap_inlon:
	pop	ebp
	pop	edi
	pop	esi

; 9256 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9258 : }

	ret	0
$LN1@soap_inlon:

; 9257 :   return p;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 9258 : }

	ret	0
_soap_inlong ENDP
_TEXT	ENDS
PUBLIC	_soap_inint
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap$ = 8						; size = 4
_tag$ = 12						; size = 4
_p$ = 16						; size = 4
_type$ = 20						; size = 4
_soap_inint PROC

; 9152 : { if (soap_element_begin_in(soap, tag, 0, NULL))

	mov	eax, DWORD PTR _tag$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _soap$[esp]
	push	esi
	push	0
	push	0
	mov	esi, ebx
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@soap_inint
	pop	esi

; 9153 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9175 : }

	ret	0
$LN7@soap_inint:

; 9154 : #ifndef WITH_LEAN
; 9155 :   if (*soap->type
; 9156 :    && soap_match_tag(soap, soap->type, type)
; 9157 :    && soap_match_tag(soap, soap->type, ":int")
; 9158 :    && soap_match_tag(soap, soap->type, ":short")
; 9159 :    && soap_match_tag(soap, soap->type, ":byte"))

	cmp	BYTE PTR [ebx+83124], 0
	lea	esi, DWORD PTR [ebx+83124]
	push	edi
	je	SHORT $LN6@soap_inint
	mov	edi, DWORD PTR _type$[esp+8]
	push	esi
	push	ebx
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inint
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_04JNHIEKJE@?3int?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inint
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_06DFBHHOOH@?3short?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inint
	push	esi
	push	ebx
	mov	edi, OFFSET ??_C@_05FFGLOOMC@?3byte?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@soap_inint

; 9160 :   { soap->error = SOAP_TYPE;
; 9161 :     soap_revert(soap);

	mov	eax, ebx
	mov	DWORD PTR [ebx+90460], 4
	call	_soap_revert
	pop	edi
	pop	esi

; 9162 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9175 : }

	ret	0
$LN6@soap_inint:

; 9163 :   }
; 9164 : #endif
; 9165 :   p = (int*)soap_id_enter(soap, soap->id, p, t, sizeof(int), 0, NULL, NULL, NULL);

	mov	eax, DWORD PTR _p$[esp+8]
	push	ebp
	push	0
	push	0
	push	4
	push	1
	push	eax
	lea	ecx, DWORD PTR [ebx+81076]
	push	ebx
	xor	eax, eax
	call	_soap_id_enter
	mov	ebp, eax

; 9166 :   if (*soap->href)

	lea	eax, DWORD PTR [ebx+82100]
	add	esp, 24					; 00000018H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@soap_inint

; 9167 :     p = (int*)soap_id_forward(soap, soap->href, p, 0, t, 0, sizeof(int), 0, NULL);

	push	0
	push	4
	push	0
	push	1
	push	0
	push	ebp
	push	ebx
	call	_soap_id_forward
	add	esp, 28					; 0000001cH
	mov	ebp, eax
	jmp	SHORT $LN10@soap_inint
$LN5@soap_inint:

; 9168 :   else if (p)

	test	ebp, ebp
	je	SHORT $LN10@soap_inint

; 9169 :   { if (soap_s2int(soap, soap_value(soap), p))

	push	ebp
	push	ebx
	call	_soap_value
	add	esp, 4
	mov	esi, eax
	mov	edi, ebx
	call	_soap_s2int
	add	esp, 4
	test	eax, eax

; 9170 :       return NULL;

	jne	SHORT $LN13@soap_inint
$LN10@soap_inint:

; 9171 :   }
; 9172 :   if (soap->body && soap_element_end_in(soap, tag))

	cmp	WORD PTR [ebx+12442], 0
	je	SHORT $LN1@soap_inint
	mov	ecx, DWORD PTR _tag$[esp+12]
	push	ecx
	mov	esi, ebx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@soap_inint
$LN13@soap_inint:
	pop	ebp
	pop	edi
	pop	esi

; 9173 :     return NULL;

	xor	eax, eax
	pop	ebx

; 9175 : }

	ret	0
$LN1@soap_inint:

; 9174 :   return p;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 9175 : }

	ret	0
_soap_inint ENDP
_TEXT	ENDS
PUBLIC	_soap_check_result
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_check_result PROC
; _soap$ = eax

; 7511 : { if (soap->version == 2 && soap->encodingStyle)

	push	esi
	mov	esi, eax
	cmp	DWORD PTR [esi+40], 0
	je	$LN8@soap_check

; 7512 :   { soap_instring(soap, ":result", NULL, NULL, 0, 2, -1, -1);

	push	0
	push	1
	mov	eax, OFFSET ??_C@_07EFBDHEMP@?3result?$AA@
	call	_soap_element_begin_in
	add	esp, 8
	test	eax, eax
	jne	$LN8@soap_check
	push	edi
	mov	eax, 4
	mov	edi, esi
	call	_soap_malloc
	mov	edi, eax
	test	edi, edi
	je	$LN27@soap_check
	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN13@soap_check
	push	2
	mov	ecx, esi
	call	_soap_string_in
	add	esp, 4
	mov	DWORD PTR [edi], eax
	test	eax, eax
	je	SHORT $LN27@soap_check
	push	0
	push	0
	push	4
	push	0
	push	eax
	lea	ecx, DWORD PTR [esi+81076]
	push	esi
	xor	eax, eax
	call	_soap_id_enter
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN27@soap_check
	jmp	SHORT $LN10@soap_check
$LN13@soap_check:
	cmp	WORD PTR [esi+87300], 0
	je	SHORT $LN11@soap_check
	mov	DWORD PTR [edi], 0
	jmp	SHORT $LN10@soap_check
$LN11@soap_check:
	push	OFFSET _soap_padding
	push	esi
	call	_soap_strdup
	add	esp, 8
	mov	DWORD PTR [edi], eax
$LN10@soap_check:
	cmp	BYTE PTR [esi+82100], 0
	lea	eax, DWORD PTR [esi+82100]
	je	SHORT $LN9@soap_check
	push	4
	push	0
	push	edi
	mov	ecx, esi
	call	_soap_id_lookup
	add	esp, 12					; 0000000cH
$LN9@soap_check:
	cmp	WORD PTR [esi+12442], 0
	je	SHORT $LN27@soap_check
	push	OFFSET ??_C@_07EFBDHEMP@?3result?$AA@
	call	_soap_element_end_in
	add	esp, 4
$LN27@soap_check:
	pop	edi
$LN8@soap_check:
	pop	esi

; 7513 :     /* just ignore content for compliance reasons, but should compare tag to element's QName value? */
; 7514 :   }
; 7515 : }

	ret	0
_soap_check_result ENDP
_TEXT	ENDS
PUBLIC	_soap_end_recv
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_end_recv PROC
; _soap$ = eax

; 6055 : { soap->part = SOAP_END;

	push	ebx
	push	esi
	mov	esi, eax

; 6056 : #ifndef WITH_LEANER
; 6057 :   if ((soap->mode & SOAP_ENC_DIME) && soap_getdime(soap))

	test	BYTE PTR [esi+8], -128			; ffffff80H
	mov	eax, 9
	mov	WORD PTR [esi+87304], ax
	je	SHORT $LN15@soap_end_r
	mov	eax, esi
	call	_soap_getdime
	test	eax, eax
	je	SHORT $LN15@soap_end_r

; 6058 :   { soap->dime.first = NULL;

	xor	ebx, ebx
	mov	DWORD PTR [esi+90516], ebx

; 6059 :     soap->dime.last = NULL;

	mov	DWORD PTR [esi+90520], ebx
$LN45@soap_end_r:

; 6060 :     return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	esi
	pop	ebx

; 6143 : }

	ret	0
$LN15@soap_end_r:

; 6061 :   }
; 6062 :   soap->dime.list = soap->dime.first;

	mov	ecx, DWORD PTR [esi+90516]

; 6063 :   soap->dime.first = NULL;
; 6064 :   soap->dime.last = NULL;
; 6065 :   /* Check if MIME attachments and mime-post-check flag is set, if set call soap_resolve() and return */
; 6066 :   if (soap->mode & SOAP_ENC_MIME)

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	mov	DWORD PTR [esi+90512], ecx
	mov	DWORD PTR [esi+90516], ebx
	mov	DWORD PTR [esi+90520], ebx
	test	eax, 256				; 00000100H
	je	SHORT $LN12@soap_end_r

; 6067 :   {
; 6068 : #ifndef WITH_NOIDREF
; 6069 :     if (soap->mode & SOAP_MIME_POSTCHECK)

	test	eax, 268435456				; 10000000H
	je	SHORT $LL19@soap_end_r

; 6070 :     { soap_resolve(soap);

	push	esi
	call	_soap_resolve
	add	esp, 4
	pop	esi

; 6142 :   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 6143 : }

	ret	0

; 6071 :       return SOAP_OK;
; 6072 :     }
; 6073 : #endif
; 6074 :     if (soap_getmime(soap))

$LL19@soap_end_r:
	push	ebx
	push	esi
	call	_soap_get_mime_attachment
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL19@soap_end_r
	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, ebx

; 6075 :       return soap->error;

	jne	$LN16@soap_end_r
$LN12@soap_end_r:

; 6076 :   }
; 6077 :   soap->mime.list = soap->mime.first;

	mov	edx, DWORD PTR [esi+90536]
	mov	DWORD PTR [esi+90532], edx

; 6078 :   soap->mime.first = NULL;

	mov	DWORD PTR [esi+90536], ebx

; 6079 :   soap->mime.last = NULL;

	mov	DWORD PTR [esi+90540], ebx

; 6080 :   soap->mime.boundary = NULL;

	mov	DWORD PTR [esi+90524], ebx

; 6081 :   if (soap->xlist)

	cmp	DWORD PTR [esi+90544], ebx
	je	SHORT $LN8@soap_end_r
	push	edi

; 6082 :   { struct soap_multipart *content;
; 6083 :     for (content = soap->mime.list; content; content = content->next)

	mov	edi, edx
	cmp	edi, ebx
	je	SHORT $LN43@soap_end_r
	npad	6
$LL10@soap_end_r:

; 6084 :       soap_resolve_attachment(soap, content);

	push	esi
	call	_soap_resolve_attachment
	mov	edi, DWORD PTR [edi]
	add	esp, 4
	cmp	edi, ebx
	jne	SHORT $LL10@soap_end_r
$LN43@soap_end_r:
	pop	edi
$LN8@soap_end_r:

; 6085 :   }
; 6086 : #endif
; 6087 :   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "End of receive message ok\n"));
; 6088 : #ifdef WITH_ZLIB
; 6089 :   if (soap->mode & SOAP_ENC_ZLIB)
; 6090 :   { /* Make sure end of compressed content is reached */
; 6091 :     while (soap->d_stream->next_out != Z_NULL)
; 6092 :       if ((int)soap_get1(soap) == EOF)
; 6093 :         break;
; 6094 :     soap->mode &= ~SOAP_ENC_ZLIB;
; 6095 :     memcpy(soap->buf, soap->z_buf, SOAP_BUFLEN);
; 6096 :     soap->bufidx = (char*)soap->d_stream->next_in - soap->z_buf;
; 6097 :     soap->buflen = soap->z_buflen;
; 6098 :     soap->zlib_state = SOAP_ZLIB_NONE;
; 6099 :     if (inflateEnd(soap->d_stream) != Z_OK)
; 6100 :       return soap->error = SOAP_ZLIB_ERROR;
; 6101 :     DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Inflate end ok\n"));
; 6102 : #ifdef WITH_GZIP
; 6103 :     if (soap->zlib_in == SOAP_ZLIB_GZIP)
; 6104 :     { soap_wchar c;
; 6105 :       short i;
; 6106 :       DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Inflate gzip crc check\n"));
; 6107 :       for (i = 0; i < 8; i++)
; 6108 :       { if ((int)(c = soap_get1(soap)) == EOF)
; 6109 :           return soap->error = SOAP_EOF;
; 6110 :         soap->z_buf[i] = (char)c;
; 6111 :       }
; 6112 :       if (soap->z_crc != ((uLong)(unsigned char)soap->z_buf[0] | ((uLong)(unsigned char)soap->z_buf[1] << 8) | ((uLong)(unsigned char)soap->z_buf[2] << 16) | ((uLong)(unsigned char)soap->z_buf[3] << 24)))
; 6113 :       { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Gzip error: crc check failed, message corrupted? (crc32=%lu)\n", (unsigned long)soap->z_crc));
; 6114 :         return soap->error = SOAP_ZLIB_ERROR;
; 6115 :       }
; 6116 :       if (soap->d_stream->total_out != ((uLong)(unsigned char)soap->z_buf[4] | ((uLong)(unsigned char)soap->z_buf[5] << 8) | ((uLong)(unsigned char)soap->z_buf[6] << 16) | ((uLong)(unsigned char)soap->z_buf[7] << 24)))
; 6117 :       { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Gzip error: incorrect message length\n"));
; 6118 :         return soap->error = SOAP_ZLIB_ERROR;
; 6119 :       }
; 6120 :     }
; 6121 :     soap->zlib_in = SOAP_ZLIB_NONE;
; 6122 : #endif
; 6123 :   }
; 6124 : #endif
; 6125 :   if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK)

	mov	eax, DWORD PTR [esi+8]
	and	eax, 3
	cmp	al, 3
	jne	SHORT $LN36@soap_end_r
	npad	6
$LL6@soap_end_r:

; 6126 :     while ((int)soap_getchar(soap) != EOF) /* advance to last chunk */

	mov	eax, DWORD PTR [esi+12436]
	cmp	eax, ebx
	je	SHORT $LN23@soap_end_r
	cmp	eax, -1
	je	SHORT $LN22@soap_end_r
	mov	DWORD PTR [esi+12436], ebx
$LN22@soap_end_r:
	mov	ecx, eax
	jmp	SHORT $LN27@soap_end_r
$LN23@soap_end_r:
	mov	ecx, DWORD PTR [esi+12428]
	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN26@soap_end_r
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN36@soap_end_r
$LN26@soap_end_r:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ecx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
$LN27@soap_end_r:
	cmp	ecx, -1
	jne	SHORT $LL6@soap_end_r
$LN36@soap_end_r:

; 6127 :       ;
; 6128 :   if (soap->fdisconnect && (soap->error = soap->fdisconnect(soap)))

	mov	eax, DWORD PTR [esi+12284]
	cmp	eax, ebx
	je	SHORT $LN4@soap_end_r
	push	esi
	call	eax
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
	cmp	eax, ebx

; 6129 :     return soap->error;

	jne	SHORT $LN16@soap_end_r
$LN4@soap_end_r:

; 6130 : #ifndef WITH_NOIDREF
; 6131 :   if (soap_resolve(soap))

	push	esi
	call	_soap_resolve
	add	esp, 4
	test	eax, eax

; 6132 :     return soap->error;

	jne	$LN45@soap_end_r

; 6133 : #endif
; 6134 : #ifndef WITH_LEANER
; 6135 :   if (soap->xlist)

	cmp	DWORD PTR [esi+90544], ebx
	je	SHORT $LN2@soap_end_r

; 6136 :   { if (soap->mode & SOAP_ENC_MTOM)

	test	DWORD PTR [esi+8], 512			; 00000200H
	je	SHORT $LN1@soap_end_r

; 6137 :       return soap->error = SOAP_MIME_HREF;

	mov	eax, 37					; 00000025H
	mov	DWORD PTR [esi+90460], eax
	pop	esi
	pop	ebx

; 6143 : }

	ret	0
$LN1@soap_end_r:

; 6138 :     return soap->error = SOAP_DIME_HREF;

	mov	eax, 33					; 00000021H
	mov	DWORD PTR [esi+90460], eax
	pop	esi
	pop	ebx

; 6143 : }

	ret	0
$LN2@soap_end_r:

; 6139 :   }
; 6140 : #endif
; 6141 :   soap_free_temp(soap);

	call	_soap_free_temp

; 6142 :   return SOAP_OK;

	xor	eax, eax
$LN16@soap_end_r:
	pop	esi
	pop	ebx

; 6143 : }

	ret	0
_soap_end_recv ENDP
_TEXT	ENDS
PUBLIC	_soap_accept
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_linger$80024 = -284					; size = 4
_blocking$80015 = -284					; size = 4
_nonblocking$80011 = -284				; size = 4
_set$ = -280						; size = 4
_timeout$79986 = -276					; size = 8
_n$ = -268						; size = 4
_len$ = -264						; size = 4
_fd$79987 = -260					; size = 260
_soap_accept PROC
; _soap$ = eax

; 4380 : { int n = (int)sizeof(soap->peer);

	sub	esp, 284				; 0000011cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 4381 : #ifndef WITH_LEAN
; 4382 :   int len = SOAP_BUFLEN;
; 4383 :   int set = 1;
; 4384 : #endif
; 4385 :   soap->error = SOAP_OK;

	xor	ebp, ebp

; 4386 : #ifndef WITH_LEAN
; 4387 :   if ((soap->omode & SOAP_IO_UDP))

	test	BYTE PTR [esi+16], 4
	mov	ebx, 1
	mov	DWORD PTR _n$[esp+296], 16		; 00000010H
	mov	DWORD PTR _len$[esp+296], 65536		; 00010000H
	mov	DWORD PTR _set$[esp+296], ebx
	mov	DWORD PTR [esi+90460], ebp
	je	SHORT $LN34@soap_accep

; 4388 :     return soap->socket = soap->master;

	mov	eax, DWORD PTR [esi+12404]
	mov	DWORD PTR [esi+12408], eax
	pop	esi
	pop	ebp
	pop	ebx

; 4527 :   }
; 4528 : }

	add	esp, 284				; 0000011cH
	ret	0
$LN34@soap_accep:
	push	edi

; 4389 : #endif
; 4390 :   memset((void*)&soap->peer, 0, sizeof(soap->peer));

	lea	edi, DWORD PTR [esi+94692]
	pxor	xmm0, xmm0
	movq	QWORD PTR [edi], xmm0
	movq	QWORD PTR [edi+8], xmm0

; 4391 :   soap->socket = SOAP_INVALID_SOCKET;

	or	eax, -1

; 4392 :   soap->errmode = 0;
; 4393 :   soap->keep_alive = 0;

	xor	ecx, ecx
	mov	DWORD PTR [esi+12408], eax
	mov	DWORD PTR [esi+90464], ebp
	mov	WORD PTR [esi+90412], cx

; 4394 :   if (soap_valid_socket(soap->master))

	cmp	DWORD PTR [esi+12404], eax
	je	$LN33@soap_accep
$LL32@soap_accep:

; 4395 :   { register int err;
; 4396 :     for (;;)
; 4397 :     {
; 4398 : #ifndef WITH_LEAN
; 4399 :       if (soap->accept_timeout || soap->send_timeout || soap->recv_timeout)

	cmp	DWORD PTR [esi+60], ebp
	jne	SHORT $LL28@soap_accep
	cmp	DWORD PTR [esi+52], ebp
	jne	SHORT $LL28@soap_accep
	cmp	DWORD PTR [esi+48], ebp
	je	$LN45@soap_accep
$LL28@soap_accep:

; 4400 :       {
; 4401 : #ifndef WIN32
; 4402 :         if ((int)soap->socket >= (int)FD_SETSIZE)
; 4403 :         { soap->error = SOAP_FD_EXCEEDED;
; 4404 :           return SOAP_INVALID_SOCKET;	/* Hint: MUST increase FD_SETSIZE */
; 4405 :         }
; 4406 : #endif
; 4407 :         for (;;)
; 4408 :         { struct timeval timeout;
; 4409 :           fd_set fd;
; 4410 :           register int r;
; 4411 :           if (soap->accept_timeout > 0)

	mov	ecx, DWORD PTR [esi+60]
	cmp	ecx, ebp
	jle	SHORT $LN59@soap_accep

; 4412 :           { timeout.tv_sec = soap->accept_timeout;

	mov	DWORD PTR _timeout$79986[esp+300], ecx

; 4413 :             timeout.tv_usec = 0;

	jmp	SHORT $LN60@soap_accep
$LN59@soap_accep:

; 4414 :           }
; 4415 :           else if (soap->accept_timeout < 0)

	jge	SHORT $LN24@soap_accep

; 4416 :           { timeout.tv_sec = -soap->accept_timeout/1000000;

	mov	eax, -1125899907			; bce4217dH
	imul	ecx
	sar	edx, 18					; 00000012H
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _timeout$79986[esp+300], eax

; 4417 :             timeout.tv_usec = -soap->accept_timeout%1000000;

	mov	eax, ecx
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$79986[esp+304], edx

; 4418 :           }
; 4419 : 	  else

	jmp	SHORT $LN23@soap_accep
$LN24@soap_accep:

; 4420 :           { timeout.tv_sec = 60;

	mov	DWORD PTR _timeout$79986[esp+300], 60	; 0000003cH
$LN60@soap_accep:

; 4421 :             timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$79986[esp+304], ebp
$LN23@soap_accep:

; 4422 :           }
; 4423 :           FD_ZERO(&fd);
; 4424 :           FD_SET(soap->master, &fd);

	mov	eax, DWORD PTR [esi+12404]

; 4425 :           r = select((int)soap->master + 1, &fd, &fd, &fd, &timeout);

	lea	edx, DWORD PTR _timeout$79986[esp+300]
	push	edx
	lea	ecx, DWORD PTR _fd$79987[esp+304]
	push	ecx
	mov	edx, ecx
	push	edx
	mov	DWORD PTR _fd$79987[esp+316], eax
	push	ecx
	inc	eax
	push	eax
	mov	DWORD PTR _fd$79987[esp+320], ebx
	call	_select@20

; 4426 :           if (r > 0)

	cmp	eax, ebp
	jg	$LN45@soap_accep

; 4427 :             break;
; 4428 :           if (!r && soap->accept_timeout)

	jne	SHORT $LN17@soap_accep
	cmp	DWORD PTR [esi+60], ebp
	je	SHORT $LL28@soap_accep

; 4429 :           { soap->errnum = 0;
; 4430 :             soap_set_receiver_error(soap, "Timeout", "accept failed in soap_accept()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0BP@HJFOKHGA@accept?5failed?5in?5soap_accept?$CI?$CJ?$AA@
	mov	DWORD PTR [esi+90468], ebp
	push	OFFSET ??_C@_07MKALMBDJ@Timeout?$AA@

; 4431 :             return SOAP_INVALID_SOCKET;

	jmp	$LN63@soap_accep
$LN17@soap_accep:

; 4432 :           }
; 4433 : 	  if (r < 0)

	cmp	eax, ebp
	jge	$LL28@soap_accep

; 4434 :           { r = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0

; 4435 :             if (r != SOAP_EINTR)

	cmp	eax, 10004				; 00002714H
	je	$LL28@soap_accep

; 4436 :             { soap->errnum = r;
; 4437 :               soap_closesock(soap);

	mov	edi, DWORD PTR [esi+90460]
	mov	DWORD PTR [esi+90468], eax
	cmp	edi, -1
	je	SHORT $LN38@soap_accep
	cmp	edi, 28					; 0000001cH
	je	SHORT $LN38@soap_accep
	cmp	edi, 30					; 0000001eH
	je	SHORT $LN38@soap_accep
	cmp	WORD PTR [esi+90412], bp
	jne	SHORT $LN39@soap_accep
$LN38@soap_accep:
	mov	eax, DWORD PTR [esi+12304]
	cmp	eax, ebp
	je	SHORT $LN37@soap_accep
	push	esi
	call	eax
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
	cmp	eax, ebp
	jne	SHORT $LN40@soap_accep
$LN37@soap_accep:
	xor	edx, edx
	mov	WORD PTR [esi+90412], dx
$LN39@soap_accep:
	mov	DWORD PTR [esi+90460], edi
$LN40@soap_accep:

; 4438 :               soap_set_sender_error(soap, tcp_error(soap), "accept failed in soap_accept()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0BP@HJFOKHGA@accept?5failed?5in?5soap_accept?$CI?$CJ?$AA@
	mov	eax, esi
	call	_tcp_error
	push	eax
	call	_soap_set_sender_error

; 4520 :       }
; 4521 :     }
; 4522 :   }
; 4523 :   else
; 4524 :   { soap->errnum = 0;
; 4525 :     soap_set_receiver_error(soap, tcp_error(soap), "no master socket in soap_accept()", SOAP_TCP_ERROR);

	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 4526 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	pop	ebx

; 4527 :   }
; 4528 : }

	add	esp, 284				; 0000011cH
	ret	0
$LN45@soap_accep:

; 4439 :               return SOAP_INVALID_SOCKET;
; 4440 :             }
; 4441 : 	  }
; 4442 :         }
; 4443 :       }
; 4444 :       if (soap->accept_timeout || soap->send_timeout || soap->recv_timeout)

	cmp	DWORD PTR [esi+60], ebp
	jne	SHORT $LN13@soap_accep
	cmp	DWORD PTR [esi+52], ebp
	jne	SHORT $LN13@soap_accep
	cmp	DWORD PTR [esi+48], ebp
	jne	SHORT $LN13@soap_accep

; 4446 :       else
; 4447 :         SOAP_SOCKBLOCK(soap->master)

	mov	eax, DWORD PTR [esi+12404]
	lea	edx, DWORD PTR _blocking$80015[esp+300]
	push	edx
	push	-2147195266				; 8004667eH
	mov	DWORD PTR _blocking$80015[esp+308], ebp
	push	eax
	jmp	SHORT $LN61@soap_accep
$LN13@soap_accep:

; 4445 :         SOAP_SOCKNONBLOCK(soap->master)

	mov	edx, DWORD PTR [esi+12404]
	lea	ecx, DWORD PTR _nonblocking$80011[esp+300]
	push	ecx
	push	-2147195266				; 8004667eH
	mov	DWORD PTR _nonblocking$80011[esp+308], ebx
	push	edx
$LN61@soap_accep:
	call	_ioctlsocket@12

; 4448 : #endif
; 4449 :       soap->socket = soap->faccept(soap, soap->master, (struct sockaddr*)&soap->peer, &n);

	mov	ecx, DWORD PTR [esi+12404]
	mov	edx, DWORD PTR [esi+12300]
	lea	eax, DWORD PTR _n$[esp+300]
	push	eax
	push	edi
	push	ecx
	push	esi
	call	edx

; 4450 :       soap->peerlen = (size_t)n;

	mov	ecx, DWORD PTR _n$[esp+316]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+12408], eax
	mov	DWORD PTR [esi+94708], ecx

; 4451 :       if (soap_valid_socket(soap->socket))

	cmp	eax, -1
	jne	SHORT $LN48@soap_accep

; 4512 :       }
; 4513 :       err = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0

; 4514 :       if (err != 0 && err != SOAP_EINTR && err != SOAP_EAGAIN && err != SOAP_EWOULDBLOCK)

	cmp	eax, ebp
	je	$LL32@soap_accep
	cmp	eax, 10004				; 00002714H
	je	$LL32@soap_accep
	cmp	eax, 10035				; 00002733H
	je	$LL32@soap_accep

; 4515 :       { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Accept failed from %s\n", soap->host));
; 4516 :         soap->errnum = err;
; 4517 :         soap_set_receiver_error(soap, tcp_error(soap), "accept failed in soap_accept()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0BP@HJFOKHGA@accept?5failed?5in?5soap_accept?$CI?$CJ?$AA@

; 4518 :         soap_closesock(soap);
; 4519 :         return SOAP_INVALID_SOCKET;

	jmp	SHORT $LN66@soap_accep
$LN48@soap_accep:

; 4452 :       {
; 4453 : #ifdef WITH_IPV6
; 4454 : /* Use soap->host to store the numeric form of the remote host */
; 4455 :         getnameinfo((struct sockaddr*)&soap->peer, n, soap->host, sizeof(soap->host), NULL, 0, NI_NUMERICHOST | NI_NUMERICSERV);
; 4456 :         DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Accept socket %d from %s\n", soap->socket, soap->host));
; 4457 :         soap->ip = 0; /* info stored in soap->peer and soap->host */
; 4458 :         soap->port = 0; /* info stored in soap->peer and soap->host */
; 4459 : #else
; 4460 :         soap->ip = ntohl(soap->peer.sin_addr.s_addr);

	mov	edx, DWORD PTR [esi+94696]
	push	edx
	call	_ntohl@4
	mov	DWORD PTR [esi+90404], eax

; 4461 :         soap->port = (int)ntohs(soap->peer.sin_port); /* does not return port number on some systems */

	movzx	eax, WORD PTR [esi+94694]
	push	eax
	call	_ntohs@4
	movzx	ecx, ax

; 4462 :         DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Accept socket %d at port %d from IP %d.%d.%d.%d\n", soap->socket, soap->port, (int)(soap->ip>>24)&0xFF, (int)(soap->ip>>16)&0xFF, (int)(soap->ip>>8)&0xFF, (int)soap->ip&0xFF));
; 4463 : #endif
; 4464 : #ifndef WITH_LEAN
; 4465 :         if (soap->accept_flags == SO_LINGER)

	mov	eax, DWORD PTR [esi+76]
	mov	DWORD PTR [esi+90408], ecx
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN10@soap_accep

; 4466 :         { struct linger linger;
; 4467 :           memset((void*)&linger, 0, sizeof(linger));
; 4468 :           linger.l_onoff = 1;
; 4469 :           linger.l_linger = 0;
; 4470 :           if (setsockopt(soap->socket, SOL_SOCKET, SO_LINGER, (char*)&linger, sizeof(struct linger)))

	push	4
	lea	ecx, DWORD PTR _linger$80024[esp+304]
	push	ecx
	mov	DWORD PTR _linger$80024[esp+308], ebp
	mov	edx, ebx
	push	128					; 00000080H
	mov	WORD PTR _linger$80024[esp+312], dx
	mov	edx, DWORD PTR [esi+12408]
	push	65535					; 0000ffffH
	xor	eax, eax
	push	edx
	mov	WORD PTR _linger$80024[esp+322], ax
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN55@soap_accep

; 4471 :           { soap->errnum = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0

; 4472 :             soap_set_receiver_error(soap, tcp_error(soap), "setsockopt SO_LINGER failed in soap_accept()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CN@IPOEJJJL@setsockopt?5SO_LINGER?5failed?5in?5s@
$LN66@soap_accep:
	mov	DWORD PTR [esi+90468], eax
	mov	eax, esi
	call	_tcp_error
	push	eax
	mov	edi, 28					; 0000001cH
	call	_soap_set_receiver_error
	add	esp, 8

; 4473 :             soap_closesock(soap);

	call	_soap_closesock
	pop	edi
	pop	esi
	pop	ebp

; 4526 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	pop	ebx

; 4527 :   }
; 4528 : }

	add	esp, 284				; 0000011cH
	ret	0
$LN10@soap_accep:

; 4474 :             return SOAP_INVALID_SOCKET;
; 4475 :           }
; 4476 :         }
; 4477 :         else if (soap->accept_flags && setsockopt(soap->socket, SOL_SOCKET, soap->accept_flags, (char*)&set, sizeof(int)))

	cmp	eax, ebp
	je	SHORT $LN55@soap_accep
	mov	edx, DWORD PTR [esi+12408]
	push	4
	lea	ecx, DWORD PTR _set$[esp+304]
	push	ecx
	push	eax
	push	65535					; 0000ffffH
	push	edx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN55@soap_accep

; 4478 :         { soap->errnum = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0

; 4479 :           soap_set_receiver_error(soap, tcp_error(soap), "setsockopt failed in soap_accept()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CD@BMBLFJEF@setsockopt?5failed?5in?5soap_accept@

; 4480 :           soap_closesock(soap);
; 4481 :           return SOAP_INVALID_SOCKET;

	jmp	SHORT $LN66@soap_accep
$LN55@soap_accep:

; 4482 :         }
; 4483 :         if (((soap->imode | soap->omode) & SOAP_IO_KEEPALIVE) && setsockopt(soap->socket, SOL_SOCKET, SO_KEEPALIVE, (char*)&set, sizeof(int)))

	mov	eax, DWORD PTR [esi+16]
	or	eax, DWORD PTR [esi+12]
	test	al, 16					; 00000010H
	je	SHORT $LN56@soap_accep
	mov	edx, DWORD PTR [esi+12408]
	push	4
	lea	ecx, DWORD PTR _set$[esp+304]
	push	ecx
	push	8
	push	65535					; 0000ffffH
	push	edx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN56@soap_accep

; 4484 :         { soap->errnum = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0

; 4485 :           soap_set_receiver_error(soap, tcp_error(soap), "setsockopt SO_KEEPALIVE failed in soap_accept()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0DA@HHADOPDB@setsockopt?5SO_KEEPALIVE?5failed?5i@

; 4486 :           soap_closesock(soap);
; 4487 :           return SOAP_INVALID_SOCKET;

	jmp	$LN66@soap_accep
$LN56@soap_accep:

; 4488 :         }
; 4489 :         if (setsockopt(soap->socket, SOL_SOCKET, SO_SNDBUF, (char*)&len, sizeof(int)))

	mov	ecx, DWORD PTR [esi+12408]
	push	4
	lea	eax, DWORD PTR _len$[esp+304]
	push	eax
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	push	ecx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN5@soap_accep

; 4490 :         { soap->errnum = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0

; 4491 :           soap_set_receiver_error(soap, tcp_error(soap), "setsockopt SO_SNDBUF failed in soap_accept()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CN@DKDDHJHM@setsockopt?5SO_SNDBUF?5failed?5in?5s@

; 4492 :           soap_closesock(soap);
; 4493 :           return SOAP_INVALID_SOCKET;

	jmp	$LN66@soap_accep
$LN5@soap_accep:

; 4494 :         }
; 4495 :         if (setsockopt(soap->socket, SOL_SOCKET, SO_RCVBUF, (char*)&len, sizeof(int)))

	mov	eax, DWORD PTR [esi+12408]
	push	4
	lea	edx, DWORD PTR _len$[esp+304]
	push	edx
	push	4098					; 00001002H
	push	65535					; 0000ffffH
	push	eax
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN4@soap_accep

; 4496 :         { soap->errnum = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0

; 4497 :           soap_set_receiver_error(soap, tcp_error(soap), "setsockopt SO_RCVBUF failed in soap_accept()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CN@IBIGNPMJ@setsockopt?5SO_RCVBUF?5failed?5in?5s@

; 4498 :           soap_closesock(soap);
; 4499 :           return SOAP_INVALID_SOCKET;

	jmp	$LN66@soap_accep
$LN4@soap_accep:

; 4500 :         }
; 4501 : #ifdef TCP_NODELAY
; 4502 :         if (!(soap->omode & SOAP_IO_UDP) && setsockopt(soap->socket, IPPROTO_TCP, TCP_NODELAY, (char*)&set, sizeof(int)))

	test	BYTE PTR [esi+16], 4
	jne	SHORT $LN3@soap_accep
	mov	edx, DWORD PTR [esi+12408]
	push	4
	lea	ecx, DWORD PTR _set$[esp+304]
	push	ecx
	push	ebx
	push	6
	push	edx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN3@soap_accep

; 4503 :         { soap->errnum = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0

; 4504 :           soap_set_receiver_error(soap, tcp_error(soap), "setsockopt TCP_NODELAY failed in soap_accept()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CP@BOBCLGJD@setsockopt?5TCP_NODELAY?5failed?5in@

; 4505 :           soap_closesock(soap);
; 4506 :           return SOAP_INVALID_SOCKET;

	jmp	$LN66@soap_accep
$LN3@soap_accep:

; 4507 :         }
; 4508 : #endif
; 4509 : #endif
; 4510 :         soap->keep_alive = (((soap->imode | soap->omode) & SOAP_IO_KEEPALIVE) != 0);

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+12]
	shr	eax, 4
	shr	ecx, 4
	or	eax, ecx
	and	eax, ebx
	pop	edi
	mov	WORD PTR [esi+90412], ax

; 4511 :         return soap->socket;

	mov	eax, DWORD PTR [esi+12408]
	pop	esi
	pop	ebp
	pop	ebx

; 4527 :   }
; 4528 : }

	add	esp, 284				; 0000011cH
	ret	0
$LN33@soap_accep:

; 4520 :       }
; 4521 :     }
; 4522 :   }
; 4523 :   else
; 4524 :   { soap->errnum = 0;
; 4525 :     soap_set_receiver_error(soap, tcp_error(soap), "no master socket in soap_accept()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CC@JGPGJFPH@no?5master?5socket?5in?5soap_accept?$CI@
	mov	eax, esi
	mov	DWORD PTR [esi+90468], ebp
	call	_tcp_error
	push	eax
$LN63@soap_accep:
	mov	edi, 28					; 0000001cH
	call	_soap_set_receiver_error
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 4526 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	pop	ebx

; 4527 :   }
; 4528 : }

	add	esp, 284				; 0000011cH
	ret	0
_soap_accept ENDP
_TEXT	ENDS
PUBLIC	_soap_poll
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_timeout$ = -788					; size = 8
_sfd$ = -780						; size = 260
_xfd$ = -520						; size = 260
_rfd$ = -260						; size = 260
_soap$ = 8						; size = 4
_soap_poll PROC

; 4287 : {

	sub	esp, 788				; 00000314H
	push	ebx
	push	esi

; 4288 : #ifndef WITH_LEAN
; 4289 :   struct timeval timeout;
; 4290 :   fd_set rfd, sfd, xfd;
; 4291 :   register int r;
; 4292 : #ifndef WIN32
; 4293 :   if ((int)soap->socket >= (int)FD_SETSIZE)
; 4294 :     return SOAP_FD_EXCEEDED;	/* Hint: MUST increase FD_SETSIZE */
; 4295 : #endif
; 4296 :   timeout.tv_sec = 0;
; 4297 :   timeout.tv_usec = 0;
; 4298 :   FD_ZERO(&rfd);
; 4299 :   FD_ZERO(&sfd);
; 4300 :   FD_ZERO(&xfd);
; 4301 :   if (soap_valid_socket(soap->socket))

	mov	esi, DWORD PTR _soap$[esp+792]
	mov	eax, DWORD PTR [esi+12408]
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR _timeout$[esp+800], ebx
	mov	DWORD PTR _timeout$[esp+804], ebx
	mov	DWORD PTR _rfd$[esp+800], ebx
	mov	DWORD PTR _sfd$[esp+800], ebx
	mov	DWORD PTR _xfd$[esp+800], ebx
	cmp	eax, -1
	je	SHORT $LN29@soap_poll

; 4302 :   { FD_SET(soap->socket, &rfd);
; 4303 :     FD_SET(soap->socket, &sfd);
; 4304 :     FD_SET(soap->socket, &xfd);
; 4305 :     r = select((int)soap->socket + 1, &rfd, &sfd, &xfd, &timeout);

	lea	ecx, DWORD PTR _timeout$[esp+800]
	push	ecx
	lea	edx, DWORD PTR _xfd$[esp+804]
	push	edx
	lea	ecx, DWORD PTR _sfd$[esp+808]
	push	ecx
	lea	edx, DWORD PTR _rfd$[esp+812]
	mov	DWORD PTR _rfd$[esp+816], eax
	mov	DWORD PTR _sfd$[esp+816], eax
	mov	DWORD PTR _xfd$[esp+816], eax
	push	edx
	inc	eax
	push	eax
	mov	DWORD PTR _rfd$[esp+820], 1
	mov	DWORD PTR _sfd$[esp+820], 1
	mov	DWORD PTR _xfd$[esp+820], 1
	call	_select@20
	mov	edi, eax

; 4306 :     if (r > 0 && FD_ISSET(soap->socket, &xfd))

	cmp	edi, ebx
	jle	$LN38@soap_poll
	mov	ecx, DWORD PTR [esi+12408]
	lea	eax, DWORD PTR _xfd$[esp+800]
	push	eax
	push	ecx
	call	___WSAFDIsSet@8
	test	eax, eax

; 4307 :       r = -1;
; 4308 :   }

	jne	$LN35@soap_poll
	jmp	SHORT $LN9@soap_poll
$LN29@soap_poll:

; 4309 :   else if (soap_valid_socket(soap->master))

	mov	eax, DWORD PTR [esi+12404]
	cmp	eax, -1
	je	SHORT $LN14@soap_poll

; 4310 :   { FD_SET(soap->master, &sfd);
; 4311 :     r = select((int)soap->master + 1, NULL, &sfd, NULL, &timeout);

	lea	edx, DWORD PTR _timeout$[esp+800]
	push	edx
	push	ebx
	lea	ecx, DWORD PTR _sfd$[esp+808]
	push	ecx
	mov	DWORD PTR _sfd$[esp+816], eax
	push	ebx
	inc	eax
	push	eax
	mov	DWORD PTR _sfd$[esp+820], 1
	call	_select@20
	mov	edi, eax
$LN9@soap_poll:

; 4315 :   if (r > 0)

	cmp	edi, ebx
	jle	SHORT $LN38@soap_poll

; 4316 :   {
; 4317 : #ifdef WITH_OPENSSL
; 4318 :     if (soap->imode & SOAP_ENC_SSL)
; 4319 :     {
; 4320 :       if (soap_valid_socket(soap->socket)
; 4321 :        && FD_ISSET(soap->socket, &sfd)
; 4322 :        && (!FD_ISSET(soap->socket, &rfd)
; 4323 :         || SSL_peek(soap->ssl, soap->tmpbuf, 1) > 0))
; 4324 :         return SOAP_OK;
; 4325 :     }
; 4326 :     else
; 4327 : #endif
; 4328 :       if (soap_valid_socket(soap->socket)
; 4329 :        && FD_ISSET(soap->socket, &sfd)
; 4330 :        && (!FD_ISSET(soap->socket, &rfd)
; 4331 :         || recv(soap->socket, soap->tmpbuf, 1, MSG_PEEK) > 0))

	mov	eax, DWORD PTR [esi+12408]
	cmp	eax, -1
	je	$LN37@soap_poll
	lea	edx, DWORD PTR _sfd$[esp+800]
	push	edx
	push	eax
	call	___WSAFDIsSet@8
	test	eax, eax
	je	$LN37@soap_poll
	mov	ecx, DWORD PTR [esi+12408]
	lea	eax, DWORD PTR _rfd$[esp+800]
	push	eax
	push	ecx
	call	___WSAFDIsSet@8
	test	eax, eax
	je	SHORT $LN14@soap_poll
	mov	eax, DWORD PTR [esi+12408]
	push	2
	push	1
	lea	edx, DWORD PTR [esi+79028]
	push	edx
	push	eax
	call	_recv@16
	test	eax, eax
	jle	SHORT $LN37@soap_poll
$LN14@soap_poll:
	pop	edi
	pop	esi

; 4312 :   }
; 4313 :   else
; 4314 :     return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 4345 : #else
; 4346 :   return SOAP_OK;
; 4347 : #endif
; 4348 : }

	add	esp, 788				; 00000314H
	ret	0
$LN38@soap_poll:

; 4332 :         return SOAP_OK;
; 4333 :   }
; 4334 :   else if (r < 0)

	jge	SHORT $LN4@soap_poll
$LN35@soap_poll:

; 4335 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	DWORD PTR [esi+90468], eax

; 4336 :     if ((soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) && soap_socket_errno(soap->master) != SOAP_EINTR)

	or	eax, -1
	cmp	DWORD PTR [esi+12404], eax
	jne	SHORT $LN2@soap_poll
	cmp	DWORD PTR [esi+12408], eax
	je	SHORT $LN37@soap_poll
$LN2@soap_poll:
	call	_WSAGetLastError@0
	cmp	eax, 10004				; 00002714H
	je	SHORT $LN37@soap_poll

; 4337 :     { soap_set_receiver_error(soap, tcp_error(soap), "select failed in soap_poll()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0BN@DONKIDPM@select?5failed?5in?5soap_poll?$CI?$CJ?$AA@
	mov	eax, esi
	call	_tcp_error
	push	eax
	mov	edi, 28					; 0000001cH
	call	_soap_set_receiver_error
	add	esp, 8

; 4338 :       return soap->error = SOAP_TCP_ERROR;

	mov	DWORD PTR [esi+90460], edi
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 4345 : #else
; 4346 :   return SOAP_OK;
; 4347 : #endif
; 4348 : }

	add	esp, 788				; 00000314H
	ret	0
$LN4@soap_poll:

; 4339 :     }
; 4340 :   }
; 4341 :   else
; 4342 :     soap->errnum = 0;

	mov	DWORD PTR [esi+90468], ebx
$LN37@soap_poll:
	pop	edi
	pop	esi

; 4343 :   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Polling: other end down on socket=%d select=%d\n", soap->socket, r));
; 4344 :   return SOAP_EOF;

	or	eax, -1
	pop	ebx

; 4345 : #else
; 4346 :   return SOAP_OK;
; 4347 : #endif
; 4348 : }

	add	esp, 788				; 00000314H
	ret	0
_soap_poll ENDP
_TEXT	ENDS
PUBLIC	_soap_bind
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_set$ = -8						; size = 4
_len$ = -4						; size = 4
_host$ = 8						; size = 4
_port$ = 12						; size = 4
_backlog$ = 16						; size = 4
_soap_bind PROC
; _soap$ = ecx

; 4134 : {

	sub	esp, 8
	push	ebp
	mov	ebp, DWORD PTR _host$[esp+8]
	push	esi
	mov	esi, ecx

; 4135 : #ifdef WITH_IPV6
; 4136 :   struct addrinfo *addrinfo = NULL;
; 4137 :   struct addrinfo hints;
; 4138 :   struct addrinfo res;
; 4139 :   int err;
; 4140 : #endif
; 4141 : #ifndef WITH_LEAN
; 4142 :   int len = SOAP_BUFLEN;
; 4143 :   int set = 1;
; 4144 : #endif
; 4145 :   if (soap_valid_socket(soap->master))

	mov	eax, DWORD PTR [esi+12404]
	push	edi
	or	edi, -1
	mov	DWORD PTR _len$[esp+20], 65536		; 00010000H
	mov	DWORD PTR _set$[esp+20], 1
	cmp	eax, edi
	je	SHORT $LN16@soap_bind

; 4146 :   { soap->fclosesocket(soap, soap->master);

	push	eax
	mov	eax, DWORD PTR [esi+12288]
	push	esi
	call	eax
	add	esp, 8

; 4147 :     soap->master = SOAP_INVALID_SOCKET;

	mov	DWORD PTR [esi+12404], edi
$LN16@soap_bind:

; 4148 :   }
; 4149 :   soap->socket = SOAP_INVALID_SOCKET;
; 4150 :   soap->errmode = 1;
; 4151 :   if (tcp_init(soap))

	cmp	DWORD PTR _tcp_done, 0
	mov	DWORD PTR [esi+12408], edi
	mov	DWORD PTR [esi+90464], 1
	jne	SHORT $LN15@soap_bind
	call	_tcp_init
	test	eax, eax
	je	SHORT $LN15@soap_bind

; 4152 :   { soap_set_receiver_error(soap, tcp_error(soap), "TCP init failed in soap_bind()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0BP@EOFJAGHM@TCP?5init?5failed?5in?5soap_bind?$CI?$CJ?$AA@
$LN30@soap_bind:
	mov	eax, esi
	call	_tcp_error
	push	eax
	mov	edi, 28					; 0000001cH
	call	_soap_set_receiver_error
	add	esp, 8
	pop	edi
	pop	esi

; 4153 :     return SOAP_INVALID_SOCKET;

	or	eax, -1
	pop	ebp

; 4276 : }

	add	esp, 8
	ret	0
$LN15@soap_bind:

; 4154 :   }
; 4155 : #ifdef WITH_IPV6
; 4156 :   memset((void*)&hints, 0, sizeof(hints));
; 4157 :   hints.ai_family = PF_UNSPEC;
; 4158 : #ifndef WITH_LEAN
; 4159 :   if ((soap->omode & SOAP_IO_UDP))
; 4160 :     hints.ai_socktype = SOCK_DGRAM;
; 4161 :   else
; 4162 : #endif
; 4163 :     hints.ai_socktype = SOCK_STREAM;
; 4164 :   hints.ai_flags = AI_PASSIVE;
; 4165 :   soap->errmode = 2;
; 4166 :   err = getaddrinfo(host, soap_int2s(soap, port), &hints, &addrinfo);
; 4167 :   if (addrinfo)
; 4168 :   { res = *addrinfo;
; 4169 :     memcpy(&soap->peer, addrinfo->ai_addr, addrinfo->ai_addrlen);
; 4170 :     soap->peerlen = addrinfo->ai_addrlen;
; 4171 :     res.ai_addr = (struct sockaddr*)&soap->peer;
; 4172 :     res.ai_addrlen = soap->peerlen;
; 4173 :     freeaddrinfo(addrinfo);
; 4174 :   }
; 4175 :   if (err || !addrinfo)
; 4176 :   { soap_set_receiver_error(soap, SOAP_GAI_STRERROR(err), "getaddrinfo failed in soap_bind()", SOAP_TCP_ERROR);
; 4177 :     return SOAP_INVALID_SOCKET;
; 4178 :   }
; 4179 :   soap->master = (int)socket(res.ai_family, res.ai_socktype, res.ai_protocol);
; 4180 : #else
; 4181 : #ifndef WITH_LEAN
; 4182 :   if ((soap->omode & SOAP_IO_UDP))

	test	BYTE PTR [esi+16], 4

; 4183 :     soap->master = (int)socket(AF_INET, SOCK_DGRAM, 0);

	push	0
	je	SHORT $LN14@soap_bind
	push	2

; 4184 :   else

	jmp	SHORT $LN29@soap_bind
$LN14@soap_bind:

; 4185 : #endif
; 4186 :     soap->master = (int)socket(AF_INET, SOCK_STREAM, 0);

	push	1
$LN29@soap_bind:
	push	2
	call	_socket@12

; 4187 : #endif
; 4188 :   soap->errmode = 0;
; 4189 :   if (!soap_valid_socket(soap->master))

	mov	ecx, eax
	mov	DWORD PTR [esi+12404], eax
	mov	DWORD PTR [esi+90464], 0
	cmp	ecx, edi
	jne	SHORT $LN12@soap_bind

; 4190 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	DWORD PTR [esi+90468], eax

; 4191 :     soap_set_receiver_error(soap, tcp_error(soap), "socket failed in soap_bind()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0BN@LIAJIIPM@socket?5failed?5in?5soap_bind?$CI?$CJ?$AA@

; 4192 :     return SOAP_INVALID_SOCKET;

	jmp	SHORT $LN30@soap_bind
$LN12@soap_bind:

; 4193 :   }
; 4194 : #ifndef WITH_LEAN
; 4195 :   if ((soap->omode & SOAP_IO_UDP))

	test	BYTE PTR [esi+16], 4
	je	SHORT $LN11@soap_bind

; 4196 :     soap->socket = soap->master;

	mov	DWORD PTR [esi+12408], ecx
$LN11@soap_bind:

; 4197 : #endif
; 4198 : #ifdef SOCKET_CLOSE_ON_EXEC
; 4199 : #ifdef WIN32
; 4200 : #ifndef UNDER_CE
; 4201 :   SetHandleInformation((HANDLE)soap->master, HANDLE_FLAG_INHERIT, 0);
; 4202 : #endif
; 4203 : #else
; 4204 :   fcntl(soap->master, F_SETFD, 1);
; 4205 : #endif
; 4206 : #endif
; 4207 : #ifndef WITH_LEAN
; 4208 :   if (soap->bind_flags && setsockopt(soap->master, SOL_SOCKET, soap->bind_flags, (char*)&set, sizeof(int)))

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN27@soap_bind
	push	4
	lea	edx, DWORD PTR _set$[esp+24]
	push	edx
	push	eax
	push	65535					; 0000ffffH
	push	ecx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN27@soap_bind

; 4209 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	DWORD PTR [esi+90468], eax

; 4210 :     soap_set_receiver_error(soap, tcp_error(soap), "setsockopt failed in soap_bind()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CB@LHEHKJOM@setsockopt?5failed?5in?5soap_bind?$CI?$CJ@

; 4211 :     return SOAP_INVALID_SOCKET;

	jmp	$LN30@soap_bind
$LN27@soap_bind:

; 4212 :   }
; 4213 :   if (((soap->imode | soap->omode) & SOAP_IO_KEEPALIVE) && setsockopt(soap->master, SOL_SOCKET, SO_KEEPALIVE, (char*)&set, sizeof(int)))

	mov	eax, DWORD PTR [esi+12]
	or	eax, DWORD PTR [esi+16]
	test	al, 16					; 00000010H
	je	SHORT $LN28@soap_bind
	mov	edx, DWORD PTR [esi+12404]
	push	4
	lea	ecx, DWORD PTR _set$[esp+24]
	push	ecx
	push	8
	push	65535					; 0000ffffH
	push	edx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN28@soap_bind

; 4214 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	DWORD PTR [esi+90468], eax

; 4215 :     soap_set_receiver_error(soap, tcp_error(soap), "setsockopt SO_KEEPALIVE failed in soap_bind()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CO@IMNBHKGL@setsockopt?5SO_KEEPALIVE?5failed?5i@

; 4216 :     return SOAP_INVALID_SOCKET;

	jmp	$LN30@soap_bind
$LN28@soap_bind:

; 4217 :   }
; 4218 :   if (setsockopt(soap->master, SOL_SOCKET, SO_SNDBUF, (char*)&len, sizeof(int)))

	mov	ecx, DWORD PTR [esi+12404]
	push	4
	lea	eax, DWORD PTR _len$[esp+24]
	push	eax
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	push	ecx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN8@soap_bind

; 4219 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	DWORD PTR [esi+90468], eax

; 4220 :     soap_set_receiver_error(soap, tcp_error(soap), "setsockopt SO_SNDBUF failed in soap_bind()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CL@HDDANLDN@setsockopt?5SO_SNDBUF?5failed?5in?5s@

; 4221 :     return SOAP_INVALID_SOCKET;

	jmp	$LN30@soap_bind
$LN8@soap_bind:

; 4222 :   }
; 4223 :   if (setsockopt(soap->master, SOL_SOCKET, SO_RCVBUF, (char*)&len, sizeof(int)))

	mov	eax, DWORD PTR [esi+12404]
	push	4
	lea	edx, DWORD PTR _len$[esp+24]
	push	edx
	push	4098					; 00001002H
	push	65535					; 0000ffffH
	push	eax
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN7@soap_bind

; 4224 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	DWORD PTR [esi+90468], eax

; 4225 :     soap_set_receiver_error(soap, tcp_error(soap), "setsockopt SO_RCVBUF failed in soap_bind()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CL@JJJGHOEP@setsockopt?5SO_RCVBUF?5failed?5in?5s@

; 4226 :     return SOAP_INVALID_SOCKET;

	jmp	$LN30@soap_bind
$LN7@soap_bind:

; 4227 :   }
; 4228 : #ifdef TCP_NODELAY
; 4229 :   if (!(soap->omode & SOAP_IO_UDP) && setsockopt(soap->master, IPPROTO_TCP, TCP_NODELAY, (char*)&set, sizeof(int)))

	test	BYTE PTR [esi+16], 4
	jne	SHORT $LN6@soap_bind
	mov	edx, DWORD PTR [esi+12404]
	push	4
	lea	ecx, DWORD PTR _set$[esp+24]
	push	ecx
	push	1
	push	6
	push	edx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN6@soap_bind

; 4230 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	DWORD PTR [esi+90468], eax

; 4231 :     soap_set_receiver_error(soap, tcp_error(soap), "setsockopt TCP_NODELAY failed in soap_bind()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CN@KADDKKPF@setsockopt?5TCP_NODELAY?5failed?5in@

; 4232 :     return SOAP_INVALID_SOCKET;

	jmp	$LN30@soap_bind
$LN6@soap_bind:

; 4233 :   }
; 4234 : #endif
; 4235 : #endif
; 4236 : #ifdef WITH_IPV6
; 4237 :   soap->errmode = 0;
; 4238 :   if (bind(soap->master, res.ai_addr, (int)res.ai_addrlen))
; 4239 :   { soap->errnum = soap_socket_errno(soap->master);
; 4240 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not bind to host\n"));
; 4241 :     soap_closesock(soap);
; 4242 :     soap_set_receiver_error(soap, tcp_error(soap), "bind failed in soap_bind()", SOAP_TCP_ERROR);
; 4243 :     return SOAP_INVALID_SOCKET;
; 4244 :   }
; 4245 : #else
; 4246 :   soap->peerlen = sizeof(soap->peer);
; 4247 :   memset((void*)&soap->peer, 0, sizeof(soap->peer));

	lea	edi, DWORD PTR [esi+94692]
	mov	DWORD PTR [esi+94708], 16		; 00000010H
	pxor	xmm0, xmm0
	movq	QWORD PTR [edi], xmm0

; 4248 :   soap->peer.sin_family = AF_INET;

	mov	eax, 2
	movq	QWORD PTR [edi+8], xmm0
	mov	WORD PTR [edi], ax

; 4249 :   soap->errmode = 2;

	mov	DWORD PTR [esi+90464], eax

; 4250 :   if (host)

	test	ebp, ebp
	je	SHORT $LN5@soap_bind

; 4251 :   { if (soap->fresolve(soap, host, &soap->peer.sin_addr))

	mov	edx, DWORD PTR [esi+12276]
	lea	ecx, DWORD PTR [esi+94696]
	push	ecx
	push	ebp
	push	esi
	call	edx
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@soap_bind

; 4252 :     { soap_set_receiver_error(soap, tcp_error(soap), "get host by name failed in soap_bind()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CH@FGHBILAG@get?5host?5by?5name?5failed?5in?5soap_@

; 4253 :       return SOAP_INVALID_SOCKET;

	jmp	$LN30@soap_bind
$LN5@soap_bind:

; 4254 :     }
; 4255 :   }
; 4256 :   else
; 4257 :     soap->peer.sin_addr.s_addr = htonl(INADDR_ANY);

	push	0
	call	_htonl@4
	mov	DWORD PTR [esi+94696], eax
$LN3@soap_bind:

; 4258 :   soap->peer.sin_port = htons((short)port);

	mov	eax, DWORD PTR _port$[esp+16]
	push	eax
	call	_htons@4

; 4259 :   soap->errmode = 0;
; 4260 :   if (bind(soap->master, (struct sockaddr*)&soap->peer, (int)soap->peerlen))

	mov	ecx, DWORD PTR [esi+94708]
	mov	edx, DWORD PTR [esi+12404]
	push	ecx
	push	edi
	push	edx
	mov	WORD PTR [esi+94694], ax
	mov	DWORD PTR [esi+90464], 0
	call	_bind@12
	test	eax, eax
	je	SHORT $LN2@soap_bind

; 4261 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	DWORD PTR [esi+90468], eax

; 4262 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not bind to host\n"));
; 4263 :     soap_closesock(soap);

	call	_soap_closesock

; 4264 :     soap_set_receiver_error(soap, tcp_error(soap), "bind failed in soap_bind()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0BL@GFJLCODA@bind?5failed?5in?5soap_bind?$CI?$CJ?$AA@

; 4265 :     return SOAP_INVALID_SOCKET;

	jmp	$LN30@soap_bind
$LN2@soap_bind:

; 4266 :   }
; 4267 : #endif
; 4268 :   if (!(soap->omode & SOAP_IO_UDP) && listen(soap->master, backlog))

	test	BYTE PTR [esi+16], 4
	jne	SHORT $LN1@soap_bind
	mov	eax, DWORD PTR _backlog$[esp+16]
	mov	ecx, DWORD PTR [esi+12404]
	push	eax
	push	ecx
	call	_listen@8
	test	eax, eax
	je	SHORT $LN1@soap_bind

; 4269 :   { soap->errnum = soap_socket_errno(soap->master);

	call	_WSAGetLastError@0
	mov	DWORD PTR [esi+90468], eax

; 4270 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not bind to host\n"));
; 4271 :     soap_closesock(soap);

	call	_soap_closesock

; 4272 :     soap_set_receiver_error(soap, tcp_error(soap), "listen failed in soap_bind()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0BN@GKFGOOJD@listen?5failed?5in?5soap_bind?$CI?$CJ?$AA@

; 4273 :     return SOAP_INVALID_SOCKET;

	jmp	$LN30@soap_bind
$LN1@soap_bind:

; 4274 :   }
; 4275 :   return soap->master;

	mov	eax, DWORD PTR [esi+12404]
	pop	edi
	pop	esi
	pop	ebp

; 4276 : }

	add	esp, 8
	ret	0
_soap_bind ENDP
_TEXT	ENDS
PUBLIC	_host$GSCopy$
PUBLIC	_endpoint$GSCopy$
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_host$GSCopy$ = -292					; size = 4
_blocking$79820 = -292					; size = 4
_nonblocking$79816 = -292				; size = 4
_k$79781 = -292						; size = 4
_blocking$79768 = -288					; size = 4
_nonblocking$79764 = -288				; size = 4
_linger$79717 = -288					; size = 4
_timeout$79785 = -284					; size = 8
_retry$ = -284						; size = 4
_set$ = -276						; size = 4
_len$ = -272						; size = 4
_endpoint$GSCopy$ = -268				; size = 4
_fds$79786 = -264					; size = 260
_soap$ = 8						; size = 4
_endpoint$ = 12						; size = 4
_host$ = 16						; size = 4
_port$ = 20						; size = 4
_tcp_connect PROC

; 3556 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 292				; 00000124H

; 3884 : #endif
; 3885 :   soap->socket = fd;
; 3886 :   soap->imode &= ~SOAP_ENC_SSL;
; 3887 :   soap->omode &= ~SOAP_ENC_SSL;
; 3888 :   if (!soap_tag_cmp(endpoint, "https:*"))

	mov	eax, DWORD PTR _endpoint$[ebp]
	mov	ecx, DWORD PTR _host$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _soap$[ebp]
	mov	DWORD PTR _endpoint$GSCopy$[esp+300], eax
	mov	eax, DWORD PTR [esi+12408]
	push	edi
	mov	edi, 1
	mov	DWORD PTR _host$GSCopy$[esp+304], ecx
	mov	DWORD PTR _retry$[esp+304], 10		; 0000000aH
	mov	DWORD PTR _len$[esp+304], 65536		; 00010000H
	mov	DWORD PTR _set$[esp+304], edi
	cmp	eax, -1
	je	SHORT $LN48@tcp_connec
	mov	edx, DWORD PTR [esi+12288]
	push	eax
	push	esi
	call	edx
	add	esp, 8
$LN48@tcp_connec:
	mov	DWORD PTR [esi+90464], edi
	xor	edi, edi
	mov	DWORD PTR [esi+12408], -1
	cmp	DWORD PTR _tcp_done, edi
	jne	SHORT $LN47@tcp_connec
	call	_tcp_init
	cmp	eax, edi
	je	SHORT $LN47@tcp_connec
	mov	DWORD PTR [esi+90468], edi
	push	OFFSET ??_C@_0CB@DBACHNOG@TCP?5init?5failed?5in?5tcp_connect?$CI?$CJ@
$LN99@tcp_connec:
	mov	eax, esi
	call	_tcp_error
	push	eax
	call	_soap_set_sender_error
	add	esp, 8
	or	eax, -1

; 4123 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@tcp_connec:

; 3557 : #ifdef WITH_IPV6
; 3558 :   struct addrinfo hints, *res, *ressave;
; 3559 : #endif
; 3560 :   SOAP_SOCKET fd;
; 3561 :   int err = 0;
; 3562 : #ifndef WITH_LEAN
; 3563 :   int retry = 10;
; 3564 :   int len = SOAP_BUFLEN;
; 3565 :   int set = 1;
; 3566 : #endif
; 3567 :   if (soap_valid_socket(soap->socket))
; 3568 :     soap->fclosesocket(soap, soap->socket);
; 3569 :   soap->socket = SOAP_INVALID_SOCKET;
; 3570 :   if (tcp_init(soap))
; 3571 :   { soap->errnum = 0;
; 3572 :     soap_set_sender_error(soap, tcp_error(soap), "TCP init failed in tcp_connect()", SOAP_TCP_ERROR);
; 3573 :     return SOAP_INVALID_SOCKET;
; 3574 :   }
; 3575 :   soap->errmode = 0;

	mov	DWORD PTR [esi+90464], edi
$again$79709:

; 3576 : #ifdef WITH_IPV6
; 3577 :   memset((void*)&hints, 0, sizeof(hints));
; 3578 :   hints.ai_family = PF_UNSPEC;
; 3579 : #ifndef WITH_LEAN
; 3580 :   if ((soap->omode & SOAP_IO_UDP))
; 3581 :     hints.ai_socktype = SOCK_DGRAM;
; 3582 :   else
; 3583 : #endif
; 3584 :     hints.ai_socktype = SOCK_STREAM;
; 3585 :   soap->errmode = 2;
; 3586 :   if (soap->proxy_host)
; 3587 :     err = getaddrinfo(soap->proxy_host, soap_int2s(soap, soap->proxy_port), &hints, &res);
; 3588 :   else
; 3589 :     err = getaddrinfo(host, soap_int2s(soap, port), &hints, &res);
; 3590 :   if (err)
; 3591 :   { soap_set_sender_error(soap, SOAP_GAI_STRERROR(err), "getaddrinfo failed in tcp_connect()", SOAP_TCP_ERROR);
; 3592 :     return SOAP_INVALID_SOCKET;
; 3593 :   }
; 3594 :   ressave = res;
; 3595 : again:
; 3596 :   fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
; 3597 :   soap->errmode = 0;
; 3598 : #else
; 3599 : #ifndef WITH_LEAN
; 3600 : again:
; 3601 : #endif
; 3602 : #ifndef WITH_LEAN
; 3603 :   if ((soap->omode & SOAP_IO_UDP))
; 3604 :     fd = socket(AF_INET, SOCK_DGRAM, 0);

	xor	ebx, ebx
	test	BYTE PTR [esi+16], 4
	push	ebx
	je	SHORT $LN46@tcp_connec
	push	2

; 3605 :   else

	jmp	SHORT $LN94@tcp_connec
$LN46@tcp_connec:

; 3606 : #endif
; 3607 :     fd = socket(AF_INET, SOCK_STREAM, 0);

	push	1
$LN94@tcp_connec:
	push	2
	call	_socket@12
	mov	edi, eax

; 3608 : #endif
; 3609 :   if (!soap_valid_socket(fd))

	cmp	edi, -1
	je	$LN65@tcp_connec

; 3623 :   }
; 3624 : #ifdef SOCKET_CLOSE_ON_EXEC
; 3625 : #ifdef WIN32
; 3626 : #ifndef UNDER_CE
; 3627 :   SetHandleInformation((HANDLE)fd, HANDLE_FLAG_INHERIT, 0);
; 3628 : #endif
; 3629 : #else
; 3630 :   fcntl(fd, F_SETFD, 1);
; 3631 : #endif
; 3632 : #endif
; 3633 : #ifndef WITH_LEAN
; 3634 :   if (soap->connect_flags == SO_LINGER)

	mov	eax, DWORD PTR [esi+68]
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN43@tcp_connec

; 3635 :   { struct linger linger;
; 3636 :     memset((void*)&linger, 0, sizeof(linger));
; 3637 :     linger.l_onoff = 1;
; 3638 :     linger.l_linger = 0;
; 3639 :     if (setsockopt(fd, SOL_SOCKET, SO_LINGER, (char*)&linger, sizeof(struct linger)))

	push	4
	lea	edx, DWORD PTR _linger$79717[esp+308]
	push	edx
	push	128					; 00000080H
	push	65535					; 0000ffffH
	mov	DWORD PTR _linger$79717[esp+320], ebx
	mov	eax, 1
	xor	ecx, ecx
	push	edi
	mov	WORD PTR _linger$79717[esp+324], ax
	mov	WORD PTR _linger$79717[esp+326], cx
	call	_setsockopt@20
	test	eax, eax
	je	SHORT $LN40@tcp_connec

; 3640 :     { soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0

; 3641 :       soap_set_sender_error(soap, tcp_error(soap), "setsockopt SO_LINGER failed in tcp_connect()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CN@JFNFHAEF@setsockopt?5SO_LINGER?5failed?5in?5t@
$LN106@tcp_connec:

; 3640 :     { soap->errnum = soap_socket_errno(fd);

	mov	DWORD PTR [esi+90468], eax
$LN101@tcp_connec:

; 3641 :       soap_set_sender_error(soap, tcp_error(soap), "setsockopt SO_LINGER failed in tcp_connect()", SOAP_TCP_ERROR);

	mov	eax, esi
	call	_tcp_error
	push	eax
$LN103@tcp_connec:
	call	_soap_set_sender_error

; 3642 :       soap->fclosesocket(soap, fd);

	mov	eax, DWORD PTR [esi+12288]
	push	edi
	push	esi
	call	eax
	add	esp, 16					; 00000010H
	or	eax, -1

; 4123 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@tcp_connec:

; 3643 : #ifdef WITH_IPV6
; 3644 :       freeaddrinfo(ressave);
; 3645 : #endif
; 3646 :       return SOAP_INVALID_SOCKET;
; 3647 :     }
; 3648 :   }
; 3649 :   else if (soap->connect_flags && setsockopt(fd, SOL_SOCKET, soap->connect_flags, (char*)&set, sizeof(int)))

	cmp	eax, ebx
	je	SHORT $LN40@tcp_connec
	push	4
	lea	ecx, DWORD PTR _set$[esp+308]
	push	ecx
	push	eax
	push	65535					; 0000ffffH
	push	edi
	call	_setsockopt@20
	test	eax, eax
	jne	$LN67@tcp_connec
$LN40@tcp_connec:

; 3653 : #ifdef WITH_IPV6
; 3654 :     freeaddrinfo(ressave);
; 3655 : #endif
; 3656 :     return SOAP_INVALID_SOCKET;
; 3657 :   }
; 3658 :   if ((soap->keep_alive || soap->tcp_keep_alive) && setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char*)&set, sizeof(int)))

	cmp	WORD PTR [esi+90412], bx
	jne	SHORT $LN38@tcp_connec
	cmp	WORD PTR [esi+90414], bx
	je	SHORT $LN39@tcp_connec
$LN38@tcp_connec:
	push	4
	lea	edx, DWORD PTR _set$[esp+308]
	push	edx
	push	8
	push	65535					; 0000ffffH
	push	edi
	call	_setsockopt@20
	test	eax, eax
	jne	$LN68@tcp_connec
$LN39@tcp_connec:

; 3662 : #ifdef WITH_IPV6
; 3663 :     freeaddrinfo(ressave);
; 3664 : #endif
; 3665 :     return SOAP_INVALID_SOCKET;
; 3666 :   }
; 3667 :   if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, (char*)&len, sizeof(int)))

	push	4
	lea	eax, DWORD PTR _len$[esp+308]
	push	eax
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	push	edi
	call	_setsockopt@20
	test	eax, eax
	jne	$LN69@tcp_connec

; 3675 :   }
; 3676 :   if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, (char*)&len, sizeof(int)))

	push	4
	lea	ecx, DWORD PTR _len$[esp+308]
	push	ecx
	push	4098					; 00001002H
	push	65535					; 0000ffffH
	push	edi
	call	_setsockopt@20
	test	eax, eax
	jne	$LN70@tcp_connec

; 3680 : #ifdef WITH_IPV6
; 3681 :     freeaddrinfo(ressave);
; 3682 : #endif
; 3683 :     return SOAP_INVALID_SOCKET;
; 3684 :   }
; 3685 : #ifdef TCP_KEEPIDLE
; 3686 :   if (soap->tcp_keep_idle && setsockopt((SOAP_SOCKET)fd, IPPROTO_TCP, TCP_KEEPIDLE, (unsigned int*)&(soap->tcp_keep_idle), sizeof(int)))
; 3687 :   { soap->errnum = soap_socket_errno(fd);
; 3688 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt TCP_KEEPIDLE failed in tcp_connect()", SOAP_TCP_ERROR);
; 3689 :     soap->fclosesocket(soap, (SOAP_SOCKET)fd);
; 3690 : #ifdef WITH_IPV6
; 3691 :     freeaddrinfo(ressave);
; 3692 : #endif
; 3693 :     return SOAP_INVALID_SOCKET;
; 3694 :   }
; 3695 : #endif
; 3696 : #ifdef TCP_KEEPINTVL
; 3697 :   if (soap->tcp_keep_intvl && setsockopt((SOAP_SOCKET)fd, IPPROTO_TCP, TCP_KEEPINTVL, (unsigned int*)&(soap->tcp_keep_intvl), sizeof(int)))
; 3698 :   { soap->errnum = soap_socket_errno(fd);
; 3699 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt TCP_KEEPINTVL failed in tcp_connect()", SOAP_TCP_ERROR);
; 3700 :     soap->fclosesocket(soap, (SOAP_SOCKET)fd);
; 3701 : #ifdef WITH_IPV6
; 3702 :     freeaddrinfo(ressave);
; 3703 : #endif
; 3704 :     return SOAP_INVALID_SOCKET;
; 3705 :   }
; 3706 : #endif
; 3707 : #ifdef TCP_KEEPCNT
; 3708 :   if (soap->tcp_keep_cnt && setsockopt((SOAP_SOCKET)fd, IPPROTO_TCP, TCP_KEEPCNT, (unsigned int*)&(soap->tcp_keep_cnt), sizeof(int)))
; 3709 :   { soap->errnum = soap_socket_errno(fd);
; 3710 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt TCP_KEEPCNT failed in tcp_connect()", SOAP_TCP_ERROR);
; 3711 :     soap->fclosesocket(soap, (SOAP_SOCKET)fd);
; 3712 : #ifdef WITH_IPV6
; 3713 :     freeaddrinfo(ressave);
; 3714 : #endif
; 3715 :     return SOAP_INVALID_SOCKET;
; 3716 :   }
; 3717 : #endif
; 3718 : #ifdef TCP_NODELAY
; 3719 :   if (!(soap->omode & SOAP_IO_UDP) && setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char*)&set, sizeof(int)))

	test	BYTE PTR [esi+16], 4
	jne	SHORT $LN35@tcp_connec
	push	4
	lea	edx, DWORD PTR _set$[esp+308]
	push	edx
	push	1
	push	6
	push	edi
	call	_setsockopt@20
	test	eax, eax
	jne	$LN71@tcp_connec
$LN35@tcp_connec:

; 3723 : #ifdef WITH_IPV6
; 3724 :     freeaddrinfo(ressave);
; 3725 : #endif
; 3726 :     return SOAP_INVALID_SOCKET;
; 3727 :   }
; 3728 : #endif
; 3729 : #endif
; 3730 :   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Opening socket %d to host='%s' port=%d\n", fd, host, port));
; 3731 : #ifndef WITH_IPV6
; 3732 :   soap->peerlen = sizeof(soap->peer);

	mov	DWORD PTR [esi+94708], 16		; 00000010H

; 3733 :   memset((void*)&soap->peer, 0, sizeof(soap->peer));

	pxor	xmm0, xmm0
	movq	QWORD PTR [esi+94692], xmm0

; 3734 :   soap->peer.sin_family = AF_INET;

	mov	eax, 2
	movq	QWORD PTR [esi+94700], xmm0
	mov	WORD PTR [esi+94692], ax

; 3735 :   soap->errmode = 2;

	mov	DWORD PTR [esi+90464], eax

; 3736 :   if (soap->proxy_host)

	mov	eax, DWORD PTR [esi+90436]

; 3737 :   { if (soap->fresolve(soap, soap->proxy_host, &soap->peer.sin_addr))

	lea	ecx, DWORD PTR [esi+94696]
	push	ecx
	cmp	eax, ebx
	je	SHORT $LN34@tcp_connec
	mov	edx, DWORD PTR [esi+12276]
	push	eax
	push	esi
	call	edx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN72@tcp_connec

; 3744 :     }
; 3745 :     soap->peer.sin_port = htons((short)soap->proxy_port);

	movzx	eax, WORD PTR [esi+90440]
	push	eax

; 3746 :   }
; 3747 :   else

	jmp	SHORT $LN95@tcp_connec
$LN34@tcp_connec:

; 3748 :   { if (soap->fresolve(soap, host, &soap->peer.sin_addr))

	mov	edx, DWORD PTR _host$GSCopy$[esp+308]
	mov	eax, DWORD PTR [esi+12276]
	push	edx
	push	esi
	call	eax
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN73@tcp_connec

; 3750 :       soap->fclosesocket(soap, fd);
; 3751 : #ifdef WITH_IPV6
; 3752 :       freeaddrinfo(ressave);
; 3753 : #endif
; 3754 :       return SOAP_INVALID_SOCKET;
; 3755 :     }
; 3756 :     soap->peer.sin_port = htons((short)port);

	mov	ecx, DWORD PTR _port$[ebp]
	push	ecx
$LN95@tcp_connec:
	call	_htons@4

; 3757 :   }
; 3758 :   soap->errmode = 0;
; 3759 : #ifndef WITH_LEAN
; 3760 :   if ((soap->omode & SOAP_IO_UDP))

	test	BYTE PTR [esi+16], 4
	mov	WORD PTR [esi+94694], ax
	mov	DWORD PTR [esi+90464], ebx
	jne	$LN1@tcp_connec

; 3766 :   }
; 3767 : #endif
; 3768 : #endif
; 3769 : #ifndef WITH_LEAN
; 3770 :   if (soap->connect_timeout)

	cmp	DWORD PTR [esi+56], ebx
	je	SHORT $LN29@tcp_connec

; 3771 :     SOAP_SOCKNONBLOCK(fd)

	lea	edx, DWORD PTR _nonblocking$79764[esp+304]
	mov	DWORD PTR _nonblocking$79764[esp+304], 1
	push	edx

; 3772 :   else

	jmp	SHORT $LN96@tcp_connec
$LN29@tcp_connec:

; 3773 :     SOAP_SOCKBLOCK(fd)

	lea	eax, DWORD PTR _blocking$79768[esp+304]
	mov	DWORD PTR _blocking$79768[esp+304], ebx
	push	eax
$LN96@tcp_connec:
	push	-2147195266				; 8004667eH
	push	edi
	call	_ioctlsocket@12
$LN27@tcp_connec:

; 3774 : #endif
; 3775 :   for (;;)
; 3776 :   {
; 3777 : #ifdef WITH_IPV6
; 3778 :     if (connect(fd, res->ai_addr, (int)res->ai_addrlen))
; 3779 : #else
; 3780 :     if (connect(fd, (struct sockaddr*)&soap->peer, sizeof(soap->peer)))

	push	16					; 00000010H
	lea	eax, DWORD PTR [esi+94692]
	push	eax
	push	edi
	call	_connect@12
	test	eax, eax
	je	$LN25@tcp_connec

; 3781 : #endif
; 3782 :     { err = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	ebx, eax

; 3783 : #ifndef WITH_LEAN
; 3784 :       if (err == SOAP_EADDRINUSE)

	cmp	ebx, 10048				; 00002740H
	je	SHORT $LN83@tcp_connec

; 3787 :           goto again;
; 3788 :       }
; 3789 :       else if (soap->connect_timeout && (err == SOAP_EINPROGRESS || err == SOAP_EAGAIN || err == SOAP_EWOULDBLOCK))

	cmp	DWORD PTR [esi+56], 0
	je	SHORT $LN21@tcp_connec
	cmp	ebx, 10036				; 00002734H
	je	$LN82@tcp_connec
	cmp	ebx, 10035				; 00002733H
	je	$LN82@tcp_connec
$LN21@tcp_connec:

; 3852 :       }
; 3853 : #endif
; 3854 : #ifdef WITH_IPV6
; 3855 :       if (res->ai_next)
; 3856 :       { res = res->ai_next;
; 3857 :         soap->fclosesocket(soap, fd);
; 3858 :         goto again;
; 3859 :       }
; 3860 : #endif
; 3861 :       if (err && err != SOAP_EINTR)

	test	ebx, ebx
	je	SHORT $LN27@tcp_connec
	cmp	ebx, 10004				; 00002714H
	je	SHORT $LN27@tcp_connec

; 3862 :       { soap->errnum = err;

	mov	DWORD PTR [esi+90468], ebx

; 3863 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not connect to host\n"));
; 3864 :         soap_set_sender_error(soap, tcp_error(soap), "connect failed in tcp_connect()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@

; 3865 :         soap->fclosesocket(soap, fd);
; 3866 : #ifdef WITH_IPV6
; 3867 :         freeaddrinfo(ressave);
; 3868 : #endif
; 3869 :         return SOAP_INVALID_SOCKET;

	jmp	$LN105@tcp_connec
$LN83@tcp_connec:

; 3785 :       { soap->fclosesocket(soap, fd);

	mov	ecx, DWORD PTR [esi+12288]
	push	edi
	push	esi
	call	ecx

; 3786 :         if (retry-- > 0)

	mov	eax, DWORD PTR _retry$[esp+312]
	mov	edx, eax
	dec	eax
	add	esp, 8
	mov	DWORD PTR _retry$[esp+304], eax
	test	edx, edx
	jg	$again$79709

; 3862 :       { soap->errnum = err;

	mov	DWORD PTR [esi+90468], ebx

; 3863 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not connect to host\n"));
; 3864 :         soap_set_sender_error(soap, tcp_error(soap), "connect failed in tcp_connect()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@

; 3865 :         soap->fclosesocket(soap, fd);
; 3866 : #ifdef WITH_IPV6
; 3867 :         freeaddrinfo(ressave);
; 3868 : #endif
; 3869 :         return SOAP_INVALID_SOCKET;

	jmp	$LN105@tcp_connec
$LN65@tcp_connec:

; 3610 :   {
; 3611 : #ifdef WITH_IPV6
; 3612 :     if (res->ai_next)
; 3613 :     { res = res->ai_next;
; 3614 :       goto again;
; 3615 :     }
; 3616 : #endif
; 3617 :     soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	DWORD PTR [esi+90468], eax

; 3618 :     soap_set_sender_error(soap, tcp_error(soap), "socket failed in tcp_connect()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0BP@IBLNNK@socket?5failed?5in?5tcp_connect?$CI?$CJ?$AA@

; 3619 : #ifdef WITH_IPV6
; 3620 :     freeaddrinfo(ressave);
; 3621 : #endif
; 3622 :     return SOAP_INVALID_SOCKET;

	jmp	$LN99@tcp_connec
$LN67@tcp_connec:

; 3650 :   { soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	DWORD PTR [esi+90468], eax

; 3651 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt failed in tcp_connect()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CD@GCKLAJL@setsockopt?5failed?5in?5tcp_connect@
	mov	eax, esi
	call	_tcp_error
	push	eax
	call	_soap_set_sender_error

; 3652 :     soap->fclosesocket(soap, fd);

	mov	ecx, DWORD PTR [esi+12288]
	push	edi
	push	esi
	call	ecx
	add	esp, 16					; 00000010H
	or	eax, -1

; 4123 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN68@tcp_connec:

; 3659 :   { soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	DWORD PTR [esi+90468], eax

; 3660 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt SO_KEEPALIVE failed in tcp_connect()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0DA@GNDCAGOP@setsockopt?5SO_KEEPALIVE?5failed?5i@
	mov	eax, esi
	call	_tcp_error
	push	eax
	call	_soap_set_sender_error

; 3661 :     soap->fclosesocket(soap, fd);

	mov	edx, DWORD PTR [esi+12288]
	push	edi
	push	esi
	call	edx
	add	esp, 16					; 00000010H
	or	eax, -1

; 4123 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN69@tcp_connec:

; 3668 :   { soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0

; 3669 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt SO_SNDBUF failed in tcp_connect()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CN@CAACJAKC@setsockopt?5SO_SNDBUF?5failed?5in?5t@

; 3670 :     soap->fclosesocket(soap, fd);
; 3671 : #ifdef WITH_IPV6
; 3672 :     freeaddrinfo(ressave);
; 3673 : #endif
; 3674 :     return SOAP_INVALID_SOCKET;

	jmp	$LN106@tcp_connec
$LN70@tcp_connec:

; 3677 :   { soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0

; 3678 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt SO_RCVBUF failed in tcp_connect()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CN@JLLHDGBH@setsockopt?5SO_RCVBUF?5failed?5in?5t@
$LN107@tcp_connec:

; 3677 :   { soap->errnum = soap_socket_errno(fd);

	mov	DWORD PTR [esi+90468], eax
$LN104@tcp_connec:

; 3678 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt SO_RCVBUF failed in tcp_connect()", SOAP_TCP_ERROR);

	mov	eax, esi
	call	_tcp_error
	push	eax
	call	_soap_set_sender_error

; 3679 :     soap->fclosesocket(soap, fd);

	mov	ecx, DWORD PTR [esi+12288]
	push	edi
	push	esi
	call	ecx
	add	esp, 16					; 00000010H
	or	eax, -1

; 4123 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@tcp_connec:

; 3720 :   { soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	DWORD PTR [esi+90468], eax

; 3721 :     soap_set_sender_error(soap, tcp_error(soap), "setsockopt TCP_NODELAY failed in tcp_connect()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CP@ECDFPEN@setsockopt?5TCP_NODELAY?5failed?5in@
$LN105@tcp_connec:
	mov	eax, esi
	call	_tcp_error
	push	eax
	call	_soap_set_sender_error

; 3722 :     soap->fclosesocket(soap, fd);

	mov	edx, DWORD PTR [esi+12288]
	push	edi
	push	esi
	call	edx
	add	esp, 16					; 00000010H
	or	eax, -1

; 4123 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@tcp_connec:

; 3738 :     { soap_set_sender_error(soap, tcp_error(soap), "get proxy host by name failed in tcp_connect()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CP@BEACMDAL@get?5proxy?5host?5by?5name?5failed?5in@

; 3739 :       soap->fclosesocket(soap, fd);
; 3740 : #ifdef WITH_IPV6
; 3741 :       freeaddrinfo(ressave);
; 3742 : #endif
; 3743 :       return SOAP_INVALID_SOCKET;

	jmp	$LN101@tcp_connec
$LN73@tcp_connec:

; 3749 :     { soap_set_sender_error(soap, tcp_error(soap), "get host by name failed in tcp_connect()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CJ@HHNLALCP@get?5host?5by?5name?5failed?5in?5tcp_c@

; 3761 :   {
; 3762 : #ifdef WITH_IPV6
; 3763 :     freeaddrinfo(ressave);
; 3764 : #endif
; 3765 :     return fd;

	jmp	SHORT $LN104@tcp_connec
$LN82@tcp_connec:
	lea	ebx, DWORD PTR [edi+1]
$LL19@tcp_connec:

; 3790 :       {
; 3791 :         SOAP_SOCKLEN_T k;
; 3792 : #ifndef WIN32
; 3793 :         if ((int)soap->socket >= (int)FD_SETSIZE)
; 3794 :         { soap->error = SOAP_FD_EXCEEDED;
; 3795 : #ifdef WITH_IPV6
; 3796 :           freeaddrinfo(ressave);
; 3797 : #endif
; 3798 :           return SOAP_INVALID_SOCKET;	/* Hint: MUST increase FD_SETSIZE */
; 3799 :         }
; 3800 : #endif
; 3801 :         for (;;)
; 3802 :         { struct timeval timeout;
; 3803 :           fd_set fds;
; 3804 :           register int r;
; 3805 :           if (soap->connect_timeout > 0)

	mov	ecx, DWORD PTR [esi+56]
	test	ecx, ecx
	jle	SHORT $LN17@tcp_connec

; 3806 :           { timeout.tv_sec = soap->connect_timeout;

	mov	DWORD PTR _timeout$79785[esp+304], ecx

; 3807 :             timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$79785[esp+308], 0

; 3808 :           }
; 3809 :           else

	jmp	SHORT $LN16@tcp_connec
$LN17@tcp_connec:

; 3810 :           { timeout.tv_sec = -soap->connect_timeout/1000000;

	mov	eax, -1125899907			; bce4217dH
	imul	ecx
	sar	edx, 18					; 00000012H
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _timeout$79785[esp+304], eax

; 3811 :             timeout.tv_usec = -soap->connect_timeout%1000000;

	mov	eax, ecx
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$79785[esp+308], edx
$LN16@tcp_connec:

; 3812 :           }
; 3813 :           FD_ZERO(&fds);
; 3814 :           FD_SET(fd, &fds);
; 3815 :           r = select((int)fd + 1, NULL, &fds, NULL, &timeout);

	lea	edx, DWORD PTR _timeout$79785[esp+304]
	push	edx
	push	0
	lea	eax, DWORD PTR _fds$79786[esp+312]
	push	eax
	push	0
	push	ebx
	mov	DWORD PTR _fds$79786[esp+328], edi
	mov	DWORD PTR _fds$79786[esp+324], 1
	call	_select@20

; 3816 :           if (r > 0)

	test	eax, eax
	jg	SHORT $LN75@tcp_connec

; 3817 :             break;
; 3818 :           if (!r)

	je	SHORT $LN76@tcp_connec

; 3827 :           }
; 3828 :           r = soap_socket_errno(fd);

	call	_WSAGetLastError@0

; 3829 :           if (r != SOAP_EINTR)

	cmp	eax, 10004				; 00002714H
	je	SHORT $LL19@tcp_connec

; 3830 :           { soap->errnum = r;
; 3831 :             DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not connect to host\n"));
; 3832 :             soap_set_sender_error(soap, tcp_error(soap), "connect failed in tcp_connect()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@

; 3833 :             soap->fclosesocket(soap, fd);
; 3834 : #ifdef WITH_IPV6
; 3835 :             freeaddrinfo(ressave);
; 3836 : #endif
; 3837 :             return SOAP_INVALID_SOCKET;

	jmp	$LN107@tcp_connec
$LN75@tcp_connec:

; 3838 :           }
; 3839 :         }
; 3840 :         k = (SOAP_SOCKLEN_T)sizeof(soap->errnum);
; 3841 :         if (!getsockopt(fd, SOL_SOCKET, SO_ERROR, (char*)&soap->errnum, &k) && !soap->errnum)	/* portability note: see SOAP_SOCKLEN_T definition in stdsoap2.h */

	lea	ecx, DWORD PTR _k$79781[esp+304]
	push	ecx
	lea	ebx, DWORD PTR [esi+90468]
	push	ebx
	push	4103					; 00001007H
	push	65535					; 0000ffffH
	push	edi
	mov	DWORD PTR _k$79781[esp+324], 4
	call	_getsockopt@20
	test	eax, eax
	jne	SHORT $LN8@tcp_connec
	cmp	DWORD PTR [ebx], eax
	je	SHORT $LN25@tcp_connec
$LN8@tcp_connec:

; 3842 :           break;
; 3843 :         DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not connect to host\n"));
; 3844 :         if (!soap->errnum)

	cmp	DWORD PTR [ebx], 0
	jne	SHORT $LN7@tcp_connec

; 3845 :           soap->errnum = soap_socket_errno(fd);

	call	_WSAGetLastError@0
	mov	DWORD PTR [ebx], eax
$LN7@tcp_connec:

; 3846 :         soap_set_sender_error(soap, tcp_error(soap), "connect failed in tcp_connect()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@

; 3847 :         soap->fclosesocket(soap, fd);
; 3848 : #ifdef WITH_IPV6
; 3849 :         freeaddrinfo(ressave);
; 3850 : #endif
; 3851 :         return SOAP_INVALID_SOCKET;

	jmp	$LN105@tcp_connec
$LN76@tcp_connec:

; 3819 :           { soap->errnum = 0;
; 3820 :             DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Connect timeout\n"));
; 3821 :             soap_set_sender_error(soap, "Timeout", "connect failed in tcp_connect()", SOAP_TCP_ERROR);

	push	OFFSET ??_C@_0CA@EGALGEOM@connect?5failed?5in?5tcp_connect?$CI?$CJ?$AA@
	mov	DWORD PTR [esi+90468], 0
	push	OFFSET ??_C@_07MKALMBDJ@Timeout?$AA@

; 3822 :             soap->fclosesocket(soap, fd);
; 3823 : #ifdef WITH_IPV6
; 3824 :             freeaddrinfo(ressave);
; 3825 : #endif
; 3826 :             return SOAP_INVALID_SOCKET;

	jmp	$LN103@tcp_connec
$LN25@tcp_connec:

; 3870 :       }
; 3871 :     }
; 3872 :     else
; 3873 :       break;
; 3874 :   }
; 3875 : #ifdef WITH_IPV6
; 3876 :   soap->peerlen = 0; /* IPv6: already connected so use send() */
; 3877 :   freeaddrinfo(ressave);
; 3878 : #endif
; 3879 : #ifndef WITH_LEAN
; 3880 :   if (soap->recv_timeout || soap->send_timeout)

	cmp	DWORD PTR [esi+48], 0
	jne	SHORT $LN3@tcp_connec
	cmp	DWORD PTR [esi+52], 0
	jne	SHORT $LN3@tcp_connec

; 3882 :   else
; 3883 :     SOAP_SOCKBLOCK(fd)

	lea	eax, DWORD PTR _blocking$79820[esp+304]
	mov	DWORD PTR _blocking$79820[esp+304], 0
	push	eax
	jmp	SHORT $LN98@tcp_connec
$LN3@tcp_connec:

; 3881 :     SOAP_SOCKNONBLOCK(fd)

	lea	ecx, DWORD PTR _nonblocking$79816[esp+304]
	mov	DWORD PTR _nonblocking$79816[esp+304], 1
	push	ecx
$LN98@tcp_connec:
	push	-2147195266				; 8004667eH
	push	edi
	call	_ioctlsocket@12

; 3884 : #endif
; 3885 :   soap->socket = fd;
; 3886 :   soap->imode &= ~SOAP_ENC_SSL;
; 3887 :   soap->omode &= ~SOAP_ENC_SSL;
; 3888 :   if (!soap_tag_cmp(endpoint, "https:*"))

	mov	edx, DWORD PTR _endpoint$GSCopy$[esp+304]
	mov	eax, -2049				; fffff7ffH
	and	DWORD PTR [esi+12], eax
	and	DWORD PTR [esi+16], eax
	push	OFFSET ??_C@_07NHIIGDKE@https?3?$CK?$AA@
	push	edx
	mov	DWORD PTR [esi+12408], edi
	call	_soap_tag_cmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@tcp_connec

; 3889 :   {
; 3890 : #ifdef WITH_OPENSSL
; 3891 :     BIO *bio;
; 3892 :     int r;
; 3893 :     if (soap->proxy_host)
; 3894 :     { unsigned int k = soap->omode; /* make sure we only parse HTTP */
; 3895 :       size_t n = soap->count; /* save the content length */
; 3896 :       char *userid, *passwd;
; 3897 :       soap->omode &= ~SOAP_ENC; /* mask IO and ENC */
; 3898 :       soap->omode |= SOAP_IO_BUFFER;
; 3899 :       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Connecting to %s proxy server\n", soap->proxy_http_version));
; 3900 :       sprintf(soap->tmpbuf, "CONNECT %s:%d HTTP/%s", host, port, soap->proxy_http_version);
; 3901 :       if (soap_begin_send(soap)
; 3902 :        || (soap->error = soap->fposthdr(soap, soap->tmpbuf, NULL)))
; 3903 :       { soap->fclosesocket(soap, fd);
; 3904 :         return SOAP_INVALID_SOCKET;
; 3905 :       }
; 3906 : #ifndef WITH_LEAN
; 3907 :       if (soap->proxy_userid && soap->proxy_passwd && strlen(soap->proxy_userid) + strlen(soap->proxy_passwd) < 761)
; 3908 :       { sprintf(soap->tmpbuf + 262, "%s:%s", soap->proxy_userid, soap->proxy_passwd);
; 3909 :         strcpy(soap->tmpbuf, "Basic ");
; 3910 :         soap_s2base64(soap, (const unsigned char*)(soap->tmpbuf + 262), soap->tmpbuf + 6, (int)strlen(soap->tmpbuf + 262));
; 3911 :         if ((soap->error = soap->fposthdr(soap, "Proxy-Authorization", soap->tmpbuf)))
; 3912 :         { soap->fclosesocket(soap, fd);
; 3913 :           return soap->error;
; 3914 :         }
; 3915 :       }
; 3916 : #endif
; 3917 :       if ((soap->error = soap->fposthdr(soap, NULL, NULL))
; 3918 :        || soap_flush(soap))
; 3919 :       { soap->fclosesocket(soap, fd);
; 3920 :         return SOAP_INVALID_SOCKET;
; 3921 :       }
; 3922 :       soap->omode = k;
; 3923 :       k = soap->imode;
; 3924 :       soap->imode &= ~SOAP_ENC; /* mask IO and ENC */
; 3925 :       userid = soap->userid; /* preserve */
; 3926 :       passwd = soap->passwd; /* preserve */
; 3927 :       if ((soap->error = soap->fparse(soap)))
; 3928 :       { soap->fclosesocket(soap, fd);
; 3929 :         return SOAP_INVALID_SOCKET;
; 3930 :       }
; 3931 :       soap->userid = userid; /* restore */
; 3932 :       soap->passwd = passwd; /* restore */
; 3933 :       soap->imode = k; /* restore */
; 3934 :       soap->count = n; /* restore */
; 3935 :       if (soap_begin_send(soap))
; 3936 :       { soap->fclosesocket(soap, fd);
; 3937 :         return SOAP_INVALID_SOCKET;
; 3938 :       }
; 3939 :       if (endpoint)
; 3940 :         strncpy(soap->endpoint, endpoint, sizeof(soap->endpoint)-1); /* restore */
; 3941 :     }
; 3942 :     if (!soap->ctx && (soap->error = soap->fsslauth(soap)))
; 3943 :     { soap_set_sender_error(soap, "SSL error", "SSL authentication failed in tcp_connect(): check password, key file, and ca file.", SOAP_SSL_ERROR);
; 3944 :       soap->fclosesocket(soap, fd);
; 3945 :       return SOAP_INVALID_SOCKET;
; 3946 :     }
; 3947 :     soap->ssl = SSL_new(soap->ctx);
; 3948 :     if (!soap->ssl)
; 3949 :     { soap->fclosesocket(soap, fd);
; 3950 :       soap->error = SOAP_SSL_ERROR;
; 3951 :       return SOAP_INVALID_SOCKET;
; 3952 :     }
; 3953 :     if (soap->session)
; 3954 :     { if (!strcmp(soap->session_host, host) && soap->session_port == port)
; 3955 :         SSL_set_session(soap->ssl, soap->session);
; 3956 :       SSL_SESSION_free(soap->session);
; 3957 :       soap->session = NULL;
; 3958 :     }
; 3959 :     soap->imode |= SOAP_ENC_SSL;
; 3960 :     soap->omode |= SOAP_ENC_SSL;
; 3961 :     bio = BIO_new_socket(fd, BIO_NOCLOSE);
; 3962 :     SSL_set_bio(soap->ssl, bio, bio);
; 3963 : #ifndef WITH_LEAN
; 3964 :     /* Connect timeout: set SSL sockets to non-blocking */
; 3965 :     if (soap->connect_timeout)
; 3966 :       SOAP_SOCKNONBLOCK(fd)
; 3967 :     else
; 3968 :       SOAP_SOCKBLOCK(fd)
; 3969 :     /* Try connecting until success or timeout */
; 3970 :     for (;;)
; 3971 :     { if ((r = SSL_connect(soap->ssl)) <= 0)
; 3972 :       { int err = SSL_get_error(soap->ssl, r);
; 3973 :         if (err != SSL_ERROR_NONE && err != SSL_ERROR_WANT_READ && err != SSL_ERROR_WANT_WRITE)
; 3974 :         { soap_set_sender_error(soap, soap_ssl_error(soap, r), "SSL connect failed in tcp_connect()", SOAP_SSL_ERROR);
; 3975 :           soap->fclosesocket(soap, fd);
; 3976 :           return SOAP_INVALID_SOCKET;
; 3977 :         }
; 3978 :         if (soap->connect_timeout)
; 3979 :         {
; 3980 : #ifndef WIN32
; 3981 :           if ((int)soap->socket >= (int)FD_SETSIZE)
; 3982 :           { soap->error = SOAP_FD_EXCEEDED;
; 3983 :             return SOAP_INVALID_SOCKET;	/* Hint: MUST increase FD_SETSIZE */
; 3984 :           }
; 3985 : #endif
; 3986 :           for (;;)
; 3987 :           { struct timeval timeout;
; 3988 :             fd_set fds;
; 3989 :             register int r;
; 3990 :             if (soap->connect_timeout > 0)
; 3991 :             { timeout.tv_sec = soap->connect_timeout;
; 3992 :               timeout.tv_usec = 0;
; 3993 :             }
; 3994 :             else
; 3995 :             { timeout.tv_sec = -soap->connect_timeout/1000000;
; 3996 :               timeout.tv_usec = -soap->connect_timeout%1000000;
; 3997 :             }
; 3998 :             FD_ZERO(&fds);
; 3999 :             FD_SET(fd, &fds);
; 4000 :             r = select((int)fd + 1, &fds, &fds, &fds, &timeout);
; 4001 :             if (r > 0)
; 4002 :               break;
; 4003 :             if (!r)
; 4004 :             { soap->errnum = 0;
; 4005 :               DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Connect timeout\n"));
; 4006 :               soap_set_sender_error(soap, "Timeout", "connect failed in tcp_connect()", SOAP_TCP_ERROR);
; 4007 :               soap->fclosesocket(soap, fd);
; 4008 :               return SOAP_INVALID_SOCKET;
; 4009 :             }
; 4010 :           }
; 4011 :           continue;
; 4012 :         }
; 4013 :       }
; 4014 :       break;
; 4015 :     }
; 4016 :     /* Set SSL sockets to nonblocking */
; 4017 :     SOAP_SOCKNONBLOCK(fd)
; 4018 : #endif
; 4019 :     /* Check server credentials when required */
; 4020 :     if ((soap->ssl_flags & SOAP_SSL_REQUIRE_SERVER_AUTHENTICATION))
; 4021 :     { int err;
; 4022 :       if ((err = SSL_get_verify_result(soap->ssl)) != X509_V_OK)
; 4023 :       { soap_set_sender_error(soap, X509_verify_cert_error_string(err), "SSL certificate presented by peer cannot be verified in tcp_connect()", SOAP_SSL_ERROR);
; 4024 :         soap->fclosesocket(soap, fd);
; 4025 :         return SOAP_INVALID_SOCKET;
; 4026 :       }
; 4027 :       if (!(soap->ssl_flags & SOAP_SSL_SKIP_HOST_CHECK))
; 4028 :       { X509_NAME *subj;
; 4029 :         int ext_count;
; 4030 :         int ok = 0;
; 4031 :         X509 *peer;
; 4032 :         peer = SSL_get_peer_certificate(soap->ssl);
; 4033 :         if (!peer)
; 4034 :         { soap_set_sender_error(soap, "SSL error", "No SSL certificate was presented by the peer in tcp_connect()", SOAP_SSL_ERROR);
; 4035 :           soap->fclosesocket(soap, fd);
; 4036 :           return SOAP_INVALID_SOCKET;
; 4037 :         }
; 4038 :         ext_count = X509_get_ext_count(peer);
; 4039 :         if (ext_count > 0)
; 4040 :         { int i;
; 4041 :           for (i = 0; i < ext_count; i++)
; 4042 :           { X509_EXTENSION *ext = X509_get_ext(peer, i);
; 4043 :             const char *ext_str = OBJ_nid2sn(OBJ_obj2nid(X509_EXTENSION_get_object(ext)));
; 4044 :             if (ext_str && !strcmp(ext_str, "subjectAltName"))
; 4045 :             { X509V3_EXT_METHOD *meth = X509V3_EXT_get(ext);
; 4046 :               void *ext_data;
; 4047 : #if (OPENSSL_VERSION_NUMBER >= 0x0090800fL)
; 4048 :               const unsigned char *data;
; 4049 : #else
; 4050 :               unsigned char *data;
; 4051 : #endif
; 4052 :               STACK_OF(CONF_VALUE) *val;
; 4053 :               int j;
; 4054 :               if (!meth)
; 4055 :                 break;
; 4056 :               data = ext->value->data;
; 4057 : #if (OPENSSL_VERSION_NUMBER > 0x00907000L)
; 4058 :               if (meth->it)
; 4059 :                 ext_data = ASN1_item_d2i(NULL, &data, ext->value->length, ASN1_ITEM_ptr(meth->it));
; 4060 :               else
; 4061 :               { /* OpenSSL not perfectly portable at this point (?):
; 4062 :                    Some compilers appear to prefer
; 4063 :                    meth->d2i(NULL, (const unsigned char**)&data, ...
; 4064 :                    or
; 4065 :                    meth->d2i(NULL, &data, ext->value->length);
; 4066 :                 */
; 4067 :                 ext_data = meth->d2i(NULL, &data, ext->value->length);
; 4068 :               }
; 4069 : #else
; 4070 :               ext_data = meth->d2i(NULL, &data, ext->value->length);
; 4071 : #endif
; 4072 :               val = meth->i2v(meth, ext_data, NULL);
; 4073 :               for (j = 0; j < sk_CONF_VALUE_num(val); j++)
; 4074 :               { CONF_VALUE *nval = sk_CONF_VALUE_value(val, j);
; 4075 :                 if (nval && !strcmp(nval->name, "DNS") && !strcmp(nval->value, host))
; 4076 :                 { ok = 1;
; 4077 :                   break;
; 4078 :                 }
; 4079 :               }
; 4080 :             }
; 4081 :             if (ok)
; 4082 :               break;
; 4083 :           }
; 4084 :         }
; 4085 :         if (!ok && (subj = X509_get_subject_name(peer)))
; 4086 :         { int i = -1;
; 4087 :           do
; 4088 :           { ASN1_STRING *name;
; 4089 :             i = X509_NAME_get_index_by_NID(subj, NID_commonName, i);
; 4090 :             if (i == -1)
; 4091 :               break;
; 4092 :             name = X509_NAME_ENTRY_get_data(X509_NAME_get_entry(subj, i));
; 4093 :             if (name)
; 4094 :             { if (!soap_tag_cmp(host, (const char*)name))
; 4095 :                 ok = 1;
; 4096 :               else
; 4097 :               { unsigned char *tmp = NULL;
; 4098 :                 ASN1_STRING_to_UTF8(&tmp, name);
; 4099 :                 if (tmp)
; 4100 :                 { if (!soap_tag_cmp(host, (const char*)tmp))
; 4101 :                     ok = 1;
; 4102 :                   OPENSSL_free(tmp);
; 4103 :                 }
; 4104 :               }
; 4105 :             }
; 4106 :           } while (!ok);
; 4107 :         }
; 4108 :         X509_free(peer);
; 4109 :         if (!ok)
; 4110 :         { soap_set_sender_error(soap, "SSL error", "SSL certificate host name mismatch in tcp_connect()", SOAP_SSL_ERROR);
; 4111 :           soap->fclosesocket(soap, fd);
; 4112 :           return SOAP_INVALID_SOCKET;
; 4113 :         }
; 4114 :       }
; 4115 :     }
; 4116 : #else
; 4117 :     soap->fclosesocket(soap, fd);

	mov	eax, DWORD PTR [esi+12288]
	push	edi
	push	esi
	call	eax
	add	esp, 8

; 4118 :     soap->error = SOAP_SSL_ERROR;

	mov	DWORD PTR [esi+90460], 30		; 0000001eH
	or	eax, -1

; 4123 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@tcp_connec:

; 4119 :     return SOAP_INVALID_SOCKET;
; 4120 : #endif
; 4121 :   }
; 4122 :   return fd;

	mov	eax, edi

; 4123 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_tcp_connect ENDP
; Function compile flags: /Ogtpy
_timeout$78546 = -288					; size = 8
_k$78535 = -280						; size = 4
_retries$ = -276					; size = 4
_timeout$78518 = -272					; size = 8
_fd$78547 = -264					; size = 260
_fd$78519 = -264					; size = 260
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_frecv	PROC

; 856  : { register int r;

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi

; 857  : #ifndef WITH_LEAN
; 858  :   register int retries = 100; /* max 100 retries with non-blocking sockets */
; 859  : #endif
; 860  :   soap->errnum = 0;

	mov	esi, DWORD PTR _soap$[ebp]

; 861  : #if defined(__cplusplus) && !defined(WITH_LEAN)
; 862  :   if (soap->is)

	mov	eax, DWORD PTR [esi+12416]
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR _retries$[esp+304], 100	; 00000064H
	mov	DWORD PTR [esi+90468], ebx
	cmp	eax, ebx
	je	SHORT $LN34@frecv

; 863  :   { if (soap->is->good())

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+eax+8], ebx
	jne	$LN33@frecv

; 864  :       return soap->is->read(s, (std::streamsize)n).gcount();

	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	push	ecx
	push	edx
	push	eax
	call	?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z ; std::basic_istream<char,std::char_traits<char> >::_Read_s
	mov	eax, DWORD PTR [eax+4]

; 1030 : #endif
; 1031 : #endif
; 1032 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@frecv:

; 865  :     return 0;
; 866  :   }
; 867  : #endif
; 868  :   if (soap_valid_socket(soap->socket))

	cmp	DWORD PTR [esi+12408], -1
	je	$LN30@frecv
$LL31@frecv:

; 869  :   { for (;;)
; 870  :     {
; 871  : #ifdef WITH_OPENSSL
; 872  :       register int err = 0;
; 873  : #endif
; 874  : #ifndef WITH_LEAN
; 875  : #ifdef WITH_OPENSSL
; 876  :       if (soap->recv_timeout && !soap->ssl) /* SSL: sockets are nonblocking */
; 877  : #else
; 878  :       if (soap->recv_timeout)

	cmp	DWORD PTR [esi+48], ebx
	je	$LN47@frecv
	npad	7
$LL28@frecv:

; 879  : #endif
; 880  :       {
; 881  : #ifndef WIN32
; 882  :         if ((int)soap->socket >= (int)FD_SETSIZE)
; 883  :         { soap->error = SOAP_FD_EXCEEDED;
; 884  :           return 0;	/* Hint: MUST increase FD_SETSIZE */
; 885  :         }
; 886  : #endif
; 887  :         for (;;)
; 888  :         { struct timeval timeout;
; 889  :           fd_set fd;
; 890  :           if (soap->recv_timeout > 0)

	mov	ecx, DWORD PTR [esi+48]
	cmp	ecx, ebx
	jle	SHORT $LN26@frecv

; 891  :           { timeout.tv_sec = soap->recv_timeout;

	mov	DWORD PTR _timeout$78518[esp+304], ecx

; 892  :             timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$78518[esp+308], ebx

; 893  :           }
; 894  :           else

	jmp	SHORT $LN25@frecv
$LN26@frecv:

; 895  :           { timeout.tv_sec = -soap->recv_timeout/1000000;

	mov	eax, -1125899907			; bce4217dH
	imul	ecx
	sar	edx, 18					; 00000012H
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _timeout$78518[esp+304], eax

; 896  :             timeout.tv_usec = -soap->recv_timeout%1000000;

	mov	eax, ecx
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$78518[esp+308], edx
$LN25@frecv:

; 897  :           }
; 898  :           FD_ZERO(&fd);
; 899  :           FD_SET(soap->socket, &fd);

	mov	eax, DWORD PTR [esi+12408]

; 900  :           r = select((int)soap->socket + 1, &fd, NULL, &fd, &timeout);

	lea	edx, DWORD PTR _timeout$78518[esp+304]
	push	edx
	lea	ecx, DWORD PTR _fd$78519[esp+308]
	push	ecx
	push	ebx
	mov	edx, ecx
	mov	DWORD PTR _fd$78519[esp+320], eax
	push	edx
	inc	eax
	push	eax
	mov	DWORD PTR _fd$78519[esp+324], 1
	call	_select@20

; 901  :           if (r > 0)

	cmp	eax, ebx
	jg	SHORT $LN47@frecv

; 902  :             break;
; 903  :           if (!r)

	je	$LN48@frecv

; 905  :             return 0;
; 906  :           }
; 907  :           r = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0

; 908  :           if (r != SOAP_EINTR && r != SOAP_EAGAIN && r != SOAP_EWOULDBLOCK)

	cmp	eax, 10004				; 00002714H
	je	SHORT $LL28@frecv
	cmp	eax, 10035				; 00002733H
	je	SHORT $LL28@frecv

; 1028 :   soap->errnum = soap_errno;

	mov	DWORD PTR [esi+90468], eax

; 1029 :   return 0;

	xor	eax, eax

; 1030 : #endif
; 1031 : #endif
; 1032 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@frecv:

; 909  :           { soap->errnum = r;
; 910  :             return 0;
; 911  :           }
; 912  :         }
; 913  :       }
; 914  : #endif
; 915  : #ifdef WITH_OPENSSL
; 916  :       if (soap->ssl)
; 917  :       { r = SSL_read(soap->ssl, s, (int)n);
; 918  :         if (r > 0)
; 919  :           return (size_t)r;
; 920  :         err = SSL_get_error(soap->ssl, r);
; 921  :         if (err != SSL_ERROR_NONE && err != SSL_ERROR_WANT_READ && err != SSL_ERROR_WANT_WRITE)
; 922  :           return 0;
; 923  :       }
; 924  :       else if (soap->bio)
; 925  :       { r = BIO_read(soap->bio, s, (int)n);
; 926  :         if (r > 0)
; 927  :           return (size_t)r;
; 928  :         return 0;
; 929  :       }
; 930  :       else
; 931  : #endif
; 932  :       {
; 933  : #ifndef WITH_LEAN
; 934  :         if ((soap->omode & SOAP_IO_UDP))

	test	BYTE PTR [esi+16], 4
	je	SHORT $LN17@frecv

; 935  :         { SOAP_SOCKLEN_T k = (SOAP_SOCKLEN_T)sizeof(soap->peer);
; 936  :           memset((void*)&soap->peer, 0, sizeof(soap->peer));

	lea	eax, DWORD PTR [esi+94692]
	pxor	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0

; 937  :           r = recvfrom(soap->socket, s, (SOAP_WINSOCKINT)n, soap->socket_flags, (struct sockaddr*)&soap->peer, &k);	/* portability note: see SOAP_SOCKLEN_T definition in stdsoap2.h */

	lea	ecx, DWORD PTR _k$78535[esp+304]
	push	ecx
	mov	ecx, DWORD PTR _s$[ebp]
	push	eax
	movq	QWORD PTR [eax+8], xmm0
	mov	edx, DWORD PTR [esi+64]
	mov	eax, DWORD PTR _n$[ebp]
	push	edx
	mov	edx, DWORD PTR [esi+12408]
	push	eax
	push	ecx
	push	edx
	mov	DWORD PTR _k$78535[esp+328], 16		; 00000010H
	call	_recvfrom@24

; 938  :           soap->peerlen = (size_t)k;
; 939  : #ifndef WITH_IPV6
; 940  :           soap->ip = ntohl(soap->peer.sin_addr.s_addr);

	mov	ecx, DWORD PTR [esi+94696]
	mov	edi, eax
	mov	eax, DWORD PTR _k$78535[esp+304]
	push	ecx
	mov	DWORD PTR [esi+94708], eax
	call	_ntohl@4
	mov	DWORD PTR [esi+90404], eax

; 941  : #endif
; 942  :         }
; 943  :         else

	jmp	SHORT $LN16@frecv
$LN17@frecv:

; 944  : #endif
; 945  :           r = recv(soap->socket, s, (int)n, soap->socket_flags);

	mov	edx, DWORD PTR [esi+64]
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	push	edx
	mov	edx, DWORD PTR [esi+12408]
	push	eax
	push	ecx
	push	edx
	call	_recv@16
	mov	edi, eax
$LN16@frecv:

; 946  : #ifdef PALM
; 947  :         /* CycleSyncDisplay(curStatusMsg); */
; 948  : #endif
; 949  :         if (r >= 0)

	cmp	edi, ebx
	jge	$LN50@frecv

; 951  :         r = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0

; 952  :         if (r != SOAP_EINTR && r != SOAP_EAGAIN && r != SOAP_EWOULDBLOCK)

	cmp	eax, 10004				; 00002714H
	je	SHORT $LN14@frecv
	cmp	eax, 10035				; 00002733H
	jne	$LN49@frecv
$LN14@frecv:

; 953  :         { soap->errnum = r;
; 954  :           return 0;
; 955  :         }
; 956  :       }
; 957  : #ifndef WITH_LEAN
; 958  :       { struct timeval timeout;
; 959  :         fd_set fd;
; 960  :         if (soap->recv_timeout > 0)

	mov	ecx, DWORD PTR [esi+48]
	cmp	ecx, ebx
	jle	SHORT $LN59@frecv

; 961  :         { timeout.tv_sec = soap->recv_timeout;

	mov	DWORD PTR _timeout$78546[esp+304], ecx

; 962  :           timeout.tv_usec = 0;

	jmp	SHORT $LN60@frecv
$LN59@frecv:

; 963  :         }
; 964  :         else if (soap->recv_timeout < 0)

	jge	SHORT $LN11@frecv

; 965  :         { timeout.tv_sec = -soap->recv_timeout/1000000;

	mov	eax, -1125899907			; bce4217dH
	imul	ecx
	sar	edx, 18					; 00000012H
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _timeout$78546[esp+304], eax

; 966  :           timeout.tv_usec = -soap->recv_timeout%1000000;

	mov	eax, ecx
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$78546[esp+308], edx

; 967  :         }
; 968  :         else

	jmp	SHORT $LN10@frecv
$LN11@frecv:

; 969  :         { timeout.tv_sec = 5;

	mov	DWORD PTR _timeout$78546[esp+304], 5
$LN60@frecv:

; 970  :           timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$78546[esp+308], ebx
$LN10@frecv:

; 971  :         }
; 972  : #ifndef WIN32
; 973  :         if ((int)soap->socket >= (int)FD_SETSIZE)
; 974  :         { soap->error = SOAP_FD_EXCEEDED;
; 975  :           return 0;	/* Hint: MUST increase FD_SETSIZE */
; 976  :         }
; 977  : #endif
; 978  :         FD_ZERO(&fd);
; 979  :         FD_SET(soap->socket, &fd);

	mov	eax, DWORD PTR [esi+12408]

; 980  : #ifdef WITH_OPENSSL
; 981  :         if (soap->ssl && err == SSL_ERROR_WANT_WRITE)
; 982  :           r = select((int)soap->socket + 1, NULL, &fd, &fd, &timeout);
; 983  :         else
; 984  :           r = select((int)soap->socket + 1, &fd, NULL, &fd, &timeout);
; 985  : #else
; 986  :         r = select((int)soap->socket + 1, &fd, NULL, &fd, &timeout);

	lea	edx, DWORD PTR _timeout$78546[esp+304]
	push	edx
	lea	ecx, DWORD PTR _fd$78547[esp+308]
	push	ecx
	push	ebx
	mov	edx, ecx
	mov	DWORD PTR _fd$78547[esp+320], eax
	push	edx
	inc	eax
	push	eax
	mov	DWORD PTR _fd$78547[esp+324], 1
	call	_select@20

; 987  : #endif
; 988  :         if (!r && soap->recv_timeout)

	cmp	eax, ebx
	jne	SHORT $LN61@frecv
	cmp	DWORD PTR [esi+48], ebx
	je	SHORT $LN3@frecv
$LN48@frecv:

; 904  :           { soap->errnum = 0;

	mov	DWORD PTR [esi+90468], ebx

; 1029 :   return 0;

	xor	eax, eax

; 1030 : #endif
; 1031 : #endif
; 1032 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@frecv:

; 989  :         { soap->errnum = 0;
; 990  :           return 0;
; 991  :         }
; 992  :         if (r < 0)

	jge	SHORT $LN3@frecv

; 993  :         { r = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0

; 994  :           if (r != SOAP_EINTR && r != SOAP_EAGAIN && r != SOAP_EWOULDBLOCK)

	cmp	eax, 10004				; 00002714H
	je	SHORT $LN3@frecv
	cmp	eax, 10035				; 00002733H
	jne	SHORT $LN49@frecv
$LN3@frecv:

; 995  :           { soap->errnum = r;
; 996  :             return 0;
; 997  :           }
; 998  :         }
; 999  :         if (retries-- <= 0)

	mov	eax, DWORD PTR _retries$[esp+304]
	mov	ecx, eax
	dec	eax
	mov	DWORD PTR _retries$[esp+304], eax
	test	ecx, ecx
	jg	$LL31@frecv

; 1000 :         { soap->errnum = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0

; 1028 :   soap->errnum = soap_errno;

	mov	DWORD PTR [esi+90468], eax

; 1029 :   return 0;

	xor	eax, eax

; 1030 : #endif
; 1031 : #endif
; 1032 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@frecv:

; 950  :           return (size_t)r;

	mov	eax, edi

; 1030 : #endif
; 1031 : #endif
; 1032 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@frecv:

; 1001 :           return 0;
; 1002 :         }
; 1003 :       }
; 1004 : #endif
; 1005 : #ifdef PALM
; 1006 :       r = soap_socket_errno(soap->socket);
; 1007 :       if (r != SOAP_EINTR && retries-- <= 0)
; 1008 :       { soap->errnum = r;
; 1009 :         return 0;
; 1010 :       }
; 1011 : #endif
; 1012 :     }
; 1013 :   }
; 1014 : #ifdef WITH_FASTCGI
; 1015 :   return fread(s, 1, n, stdin);
; 1016 : #else
; 1017 : #ifdef UNDER_CE
; 1018 :   return fread(s, 1, n, soap->recvfd);
; 1019 : #else
; 1020 : #ifdef WMW_RPM_IO
; 1021 :   if (soap->rpmreqid)
; 1022 :     r = httpBlockRead(soap->rpmreqid, s, n);
; 1023 :   else
; 1024 : #endif
; 1025 :     r = read(soap->recvfd, s, (unsigned int)n);

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [esi+12424]
	push	edx
	push	eax
	push	ecx
	call	_read
	add	esp, 12					; 0000000cH

; 1026 :   if (r >= 0)

	cmp	eax, ebx

; 1027 :     return (size_t)r;

	jge	SHORT $LN35@frecv

; 1028 :   soap->errnum = soap_errno;

	call	DWORD PTR __imp__GetLastError@0
$LN49@frecv:
	mov	DWORD PTR [esi+90468], eax
$LN33@frecv:

; 1029 :   return 0;

	xor	eax, eax
$LN35@frecv:

; 1030 : #endif
; 1031 : #endif
; 1032 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_frecv	ENDP
; Function compile flags: /Ogtpy
_timeout$78424 = -552					; size = 8
_timeout$78367 = -544					; size = 8
_timeout$78392 = -536					; size = 8
_fd$78425 = -528					; size = 260
_fd$78368 = -528					; size = 260
_fd$78393 = -264					; size = 260
_soap$ = 8						; size = 4
_s$ = 12						; size = 4
_n$ = 16						; size = 4
_fsend	PROC

; 504  : { register int nwritten, err;

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 556				; 0000022cH
	push	ebx
	push	esi

; 505  : #if defined(__cplusplus) && !defined(WITH_LEAN)
; 506  :   if (soap->os)

	mov	esi, DWORD PTR _soap$[ebp]
	mov	eax, DWORD PTR [esi+12412]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN59@fsend

; 507  :   { soap->os->write(s, (std::streamsize)n);

	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	push	ecx
	push	edx
	push	eax
	call	?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z ; std::basic_ostream<char,std::char_traits<char> >::write

; 508  :     if (soap->os->good())

	mov	eax, DWORD PTR [esi+12412]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+eax+8], edi

; 509  :       return SOAP_OK;

	je	$LN49@fsend
$LN63@fsend:

; 510  :     soap->errnum = 0;

	mov	DWORD PTR [esi+90468], edi

; 511  :     return SOAP_EOF;

	or	eax, -1

; 699  :   }
; 700  :   return SOAP_OK;
; 701  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@fsend:

; 512  :   }
; 513  : #endif
; 514  :   while (n)

	mov	ebx, DWORD PTR _n$[ebp]
	cmp	ebx, edi
	je	$LN49@fsend
	npad	4
$LL50@fsend:

; 515  :   { if (soap_valid_socket(soap->socket))

	cmp	DWORD PTR [esi+12408], -1
	je	$LN48@fsend

; 516  :     {
; 517  : #ifndef WITH_LEAN
; 518  :       if (soap->send_timeout)

	cmp	DWORD PTR [esi+52], edi
	je	$LN62@fsend
$LL46@fsend:

; 519  :       {
; 520  : #ifndef WIN32
; 521  :         if ((int)soap->socket >= (int)FD_SETSIZE)
; 522  :           return SOAP_FD_EXCEEDED;	/* Hint: MUST increase FD_SETSIZE */
; 523  : #endif
; 524  :         for (;;)
; 525  :         { struct timeval timeout;
; 526  :           fd_set fd;
; 527  :           register int r;
; 528  :           if (soap->send_timeout > 0)

	mov	ecx, DWORD PTR [esi+52]
	cmp	ecx, edi
	jle	SHORT $LN44@fsend

; 529  :           { timeout.tv_sec = soap->send_timeout;

	mov	DWORD PTR _timeout$78367[esp+568], ecx

; 530  :             timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$78367[esp+572], edi

; 531  :           }
; 532  :           else

	jmp	SHORT $LN43@fsend
$LN44@fsend:

; 533  :           { timeout.tv_sec = -soap->send_timeout/1000000;

	mov	eax, -1125899907			; bce4217dH
	imul	ecx
	sar	edx, 18					; 00000012H
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _timeout$78367[esp+568], eax

; 534  :             timeout.tv_usec = -soap->send_timeout%1000000;

	mov	eax, ecx
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$78367[esp+572], edx
$LN43@fsend:

; 535  :           }
; 536  :           FD_ZERO(&fd);
; 537  :           FD_SET(soap->socket, &fd);

	mov	eax, DWORD PTR [esi+12408]

; 538  : #ifdef WITH_OPENSSL
; 539  :           if (soap->ssl)
; 540  :             r = select((int)soap->socket + 1, &fd, &fd, &fd, &timeout);
; 541  :           else
; 542  : #endif
; 543  :           r = select((int)soap->socket + 1, NULL, &fd, &fd, &timeout);

	lea	edx, DWORD PTR _timeout$78367[esp+568]
	push	edx
	lea	ecx, DWORD PTR _fd$78368[esp+572]
	push	ecx
	mov	edx, ecx
	push	edx
	mov	DWORD PTR _fd$78368[esp+584], eax
	push	edi
	inc	eax
	push	eax
	mov	DWORD PTR _fd$78368[esp+588], 1
	call	_select@20

; 544  :           if (r > 0)

	cmp	eax, edi
	jg	SHORT $LN62@fsend

; 545  :             break;
; 546  :           if (!r)

	je	$LN63@fsend

; 547  :           { soap->errnum = 0;
; 548  :             return SOAP_EOF;
; 549  :           }
; 550  :           err = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0

; 551  :           if (err != SOAP_EINTR && err != SOAP_EAGAIN && err != SOAP_EWOULDBLOCK)

	cmp	eax, 10004				; 00002714H
	je	SHORT $LL46@fsend
	cmp	eax, 10035				; 00002733H
	je	SHORT $LL46@fsend
$LN64@fsend:

; 552  :           { soap->errnum = err;

	mov	DWORD PTR [esi+90468], eax

; 553  :             return SOAP_EOF;

	or	eax, -1

; 699  :   }
; 700  :   return SOAP_OK;
; 701  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@fsend:

; 554  :           }
; 555  :         }
; 556  :       }
; 557  : #endif
; 558  : #ifdef WITH_OPENSSL
; 559  :       if (soap->ssl)
; 560  :         nwritten = SSL_write(soap->ssl, s, (int)n);
; 561  :       else if (soap->bio)
; 562  :         nwritten = BIO_write(soap->bio, s, (int)n);
; 563  :       else
; 564  : #endif
; 565  : #ifndef WITH_LEAN
; 566  :       if ((soap->omode & SOAP_IO_UDP))

	test	BYTE PTR [esi+16], 4
	je	$LN35@fsend

; 567  :       { if (soap->peerlen)

	mov	eax, DWORD PTR [esi+94708]

; 568  :           nwritten = sendto(soap->socket, s, (SOAP_WINSOCKINT)n, soap->socket_flags, (struct sockaddr*)&soap->peer, (SOAP_WINSOCKINT)soap->peerlen);

	mov	ecx, DWORD PTR [esi+64]
	mov	edx, DWORD PTR _s$[ebp]
	cmp	eax, edi
	je	SHORT $LN34@fsend
	push	eax
	lea	eax, DWORD PTR [esi+94692]
	push	eax
	mov	eax, DWORD PTR [esi+12408]
	push	ecx
	push	ebx
	push	edx
	push	eax
	call	_sendto@24

; 569  :         else

	jmp	SHORT $LN33@fsend
$LN34@fsend:

; 570  :           nwritten = send(soap->socket, s, (SOAP_WINSOCKINT)n, soap->socket_flags);

	mov	eax, DWORD PTR [esi+12408]
	push	ecx
	push	ebx
	push	edx
	push	eax
	call	_send@16
$LN33@fsend:

; 571  :         /* retry and back-off algorithm */
; 572  :         /* TODO: this is not very clear from specs so verify and limit conditions under which we should loop (e.g. ENOBUFS) */
; 573  :         if (nwritten < 0)

	cmp	eax, edi
	jge	$LN76@fsend

; 574  :         { struct timeval timeout;
; 575  :           fd_set fd;
; 576  :           int udp_repeat;
; 577  :           int udp_delay;
; 578  : #ifndef WIN32
; 579  :           if ((int)soap->socket >= (int)FD_SETSIZE)
; 580  :             return SOAP_FD_EXCEEDED;	/* Hint: MUST increase FD_SETSIZE */
; 581  : #endif
; 582  :           if ((soap->connect_flags & SO_BROADCAST))

	movsx	ebx, BYTE PTR [esi+68]
	and	ebx, 32					; 00000020H
	or	ebx, 16					; 00000010H
	shr	ebx, 4

; 583  :             udp_repeat = 3; /* SOAP-over-UDP MULTICAST_UDP_REPEAT - 1 */
; 584  :           else
; 585  :             udp_repeat = 1; /* SOAP-over-UDP UNICAST_UDP_REPEAT - 1 */
; 586  :           udp_delay = (soap_random % 201) + 50; /* UDP_MIN_DELAY .. UDP_MAX_DELAY */

	call	_rand
	cdq
	mov	ecx, 201				; 000000c9H
	idiv	ecx
	mov	edi, edx
	add	edi, 50					; 00000032H
	npad	7
$LL29@fsend:

; 587  :           do
; 588  :           { timeout.tv_sec = 0;
; 589  :             timeout.tv_usec = 1000 * udp_delay; /* ms */
; 590  :             FD_ZERO(&fd);
; 591  :             FD_SET(soap->socket, &fd);

	mov	eax, DWORD PTR [esi+12408]
	mov	edx, edi
	imul	edx, 1000				; 000003e8H

; 592  :             select((int)soap->socket + 1, NULL, NULL, &fd, &timeout);

	lea	ecx, DWORD PTR _timeout$78392[esp+568]
	push	ecx
	mov	DWORD PTR _timeout$78392[esp+576], edx
	lea	edx, DWORD PTR _fd$78393[esp+572]
	push	edx
	push	0
	mov	DWORD PTR _fd$78393[esp+584], eax
	push	0
	inc	eax
	push	eax
	mov	DWORD PTR _timeout$78392[esp+588], 0
	mov	DWORD PTR _fd$78393[esp+588], 1
	call	_select@20

; 593  :             if (soap->peerlen)

	mov	eax, DWORD PTR [esi+94708]
	test	eax, eax
	je	SHORT $LN22@fsend

; 594  :               nwritten = sendto(soap->socket, s, (SOAP_WINSOCKINT)n, soap->socket_flags, (struct sockaddr*)&soap->peer, (SOAP_WINSOCKINT)soap->peerlen);

	mov	ecx, DWORD PTR [esi+64]
	mov	edx, DWORD PTR _n$[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+94692]
	push	eax
	mov	eax, DWORD PTR _s$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [esi+12408]
	push	edx
	push	eax
	push	ecx
	call	_sendto@24

; 595  :             else

	jmp	SHORT $LN21@fsend
$LN22@fsend:

; 596  :               nwritten = send(soap->socket, s, (SOAP_WINSOCKINT)n, soap->socket_flags);

	mov	edx, DWORD PTR [esi+64]
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	push	edx
	mov	edx, DWORD PTR [esi+12408]
	push	eax
	push	ecx
	push	edx
	call	_send@16
$LN21@fsend:

; 597  :             udp_delay <<= 1;

	add	edi, edi

; 598  :             if (udp_delay > 500) /* UDP_UPPER_DELAY */

	cmp	edi, 500				; 000001f4H
	jle	SHORT $LN28@fsend

; 599  :               udp_delay = 500;

	mov	edi, 500				; 000001f4H
$LN28@fsend:

; 600  :           }
; 601  :           while (nwritten < 0 && --udp_repeat > 0);

	test	eax, eax
	jge	SHORT $LN74@fsend
	dec	ebx
	test	ebx, ebx
	jg	$LL29@fsend
$LN74@fsend:

; 602  :         }
; 603  :       }
; 604  :       else

	mov	ebx, DWORD PTR _n$[ebp]
	xor	edi, edi
$LN18@fsend:

; 608  : #else
; 609  :         nwritten = send(soap->socket, (void*)s, n, soap->socket_flags);
; 610  : #endif
; 611  :       if (nwritten <= 0)

	cmp	eax, edi
$LN76@fsend:
	jg	$LN2@fsend

; 612  :       {
; 613  : #if defined(WITH_OPENSSL) || !defined(WITH_LEAN)
; 614  :         register int r = 0;
; 615  : #endif
; 616  :         err = soap_socket_errno(soap->socket);

	call	_WSAGetLastError@0

; 617  : #ifdef WITH_OPENSSL
; 618  :         if (soap->ssl && (r = SSL_get_error(soap->ssl, nwritten)) != SSL_ERROR_NONE && r != SSL_ERROR_WANT_READ && r != SSL_ERROR_WANT_WRITE)
; 619  :         { soap->errnum = err;
; 620  :           return SOAP_EOF;
; 621  :         }
; 622  : #endif
; 623  :         if (err == SOAP_EWOULDBLOCK || err == SOAP_EAGAIN)

	cmp	eax, 10035				; 00002733H
	je	SHORT $LN15@fsend

; 655  :           { soap->errnum = r;
; 656  :             return SOAP_EOF;
; 657  :           }
; 658  : #endif
; 659  :         }
; 660  :         else if (err && err != SOAP_EINTR)

	cmp	eax, edi
	je	$LN1@fsend
	cmp	eax, 10004				; 00002714H
	jmp	$LN78@fsend
$LN35@fsend:

; 605  : #endif
; 606  : #if !defined(PALM) && !defined(AS400)
; 607  :         nwritten = send(soap->socket, s, (int)n, soap->socket_flags);

	mov	eax, DWORD PTR [esi+64]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [esi+12408]
	push	eax
	push	ebx
	push	ecx
	push	edx
	call	_send@16
	jmp	SHORT $LN18@fsend
$LN15@fsend:

; 624  :         {
; 625  : #ifndef WITH_LEAN
; 626  :           struct timeval timeout;
; 627  :           fd_set fd;
; 628  : #ifndef WIN32
; 629  :           if ((int)soap->socket >= (int)FD_SETSIZE)
; 630  :             return SOAP_FD_EXCEEDED; /* Hint: MUST increase FD_SETSIZE */
; 631  : #endif
; 632  :           if (soap->send_timeout > 0)

	mov	ecx, DWORD PTR [esi+52]
	cmp	ecx, edi
	jle	SHORT $LN77@fsend

; 633  :           { timeout.tv_sec = soap->send_timeout;

	mov	DWORD PTR _timeout$78424[esp+568], ecx

; 634  :             timeout.tv_usec = 0;

	mov	DWORD PTR _timeout$78424[esp+572], edi
	jmp	SHORT $LN11@fsend
$LN77@fsend:

; 635  :           }
; 636  :           else if (soap->send_timeout < 0)

	jge	SHORT $LN12@fsend

; 637  :           { timeout.tv_sec = -soap->send_timeout/1000000;

	mov	eax, -1125899907			; bce4217dH
	imul	ecx
	sar	edx, 18					; 00000012H
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _timeout$78424[esp+568], eax

; 638  :             timeout.tv_usec = -soap->send_timeout%1000000;

	mov	eax, ecx
	neg	eax
	cdq
	mov	ecx, 1000000				; 000f4240H
	idiv	ecx
	mov	DWORD PTR _timeout$78424[esp+572], edx

; 639  :           }
; 640  :           else

	jmp	SHORT $LN11@fsend
$LN12@fsend:

; 641  :           { timeout.tv_sec = 0;

	mov	DWORD PTR _timeout$78424[esp+568], edi

; 642  :             timeout.tv_usec = 10000;

	mov	DWORD PTR _timeout$78424[esp+572], 10000 ; 00002710H
$LN11@fsend:

; 643  :           }
; 644  :           FD_ZERO(&fd);
; 645  :           FD_SET(soap->socket, &fd);

	mov	eax, DWORD PTR [esi+12408]

; 646  : #ifdef WITH_OPENSSL
; 647  :           if (soap->ssl && r == SSL_ERROR_WANT_READ)
; 648  :             r = select((int)soap->socket + 1, &fd, NULL, &fd, &timeout);
; 649  :           else
; 650  :             r = select((int)soap->socket + 1, NULL, &fd, &fd, &timeout);
; 651  : #else
; 652  :           r = select((int)soap->socket + 1, NULL, &fd, &fd, &timeout);

	lea	edx, DWORD PTR _timeout$78424[esp+568]
	push	edx
	lea	ecx, DWORD PTR _fd$78425[esp+572]
	push	ecx
	mov	edx, ecx
	push	edx
	mov	DWORD PTR _fd$78425[esp+584], eax
	push	edi
	inc	eax
	push	eax
	mov	DWORD PTR _fd$78425[esp+588], 1
	call	_select@20

; 653  : #endif
; 654  :           if (r < 0 && (r = soap_socket_errno(soap->socket)) != SOAP_EINTR)

	test	eax, eax
	jge	SHORT $LN1@fsend
	call	_WSAGetLastError@0
	cmp	eax, 10004				; 00002714H

; 661  :         { soap->errnum = err;
; 662  :           return SOAP_EOF;
; 663  :         }
; 664  :         nwritten = 0; /* and call write() again */
; 665  :       }
; 666  :     }
; 667  :     else

	jmp	SHORT $LN78@fsend
$LN48@fsend:

; 668  :     {
; 669  : #ifdef WITH_FASTCGI
; 670  :       nwritten = fwrite((void*)s, 1, n, stdout);
; 671  :       fflush(stdout);
; 672  : #else
; 673  : #ifdef UNDER_CE
; 674  :       nwritten = fwrite(s, 1, n, soap->sendfd);
; 675  : #else
; 676  : #ifdef VXWORKS
; 677  : #ifdef WMW_RPM_IO
; 678  :       if (soap->rpmreqid)
; 679  :         nwritten = (httpBlockPut(soap->rpmreqid, s, n) == 0) ? n : -1;
; 680  :       else
; 681  : #endif
; 682  :         nwritten = fwrite(s, sizeof(char), n, fdopen(soap->sendfd, "w"));
; 683  : #else
; 684  :       nwritten = write(soap->sendfd, s, (unsigned int)n);

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [esi+12420]
	push	ebx
	push	eax
	push	ecx
	call	_write
	add	esp, 12					; 0000000cH

; 685  : #endif
; 686  : #endif
; 687  : #endif
; 688  :       if (nwritten <= 0)

	cmp	eax, edi
	jg	SHORT $LN2@fsend

; 689  :       { err = soap_errno;

	call	DWORD PTR __imp__GetLastError@0

; 690  :         if (err && err != SOAP_EINTR && err != SOAP_EWOULDBLOCK && err != SOAP_EAGAIN)

	cmp	eax, edi
	je	SHORT $LN1@fsend
	cmp	eax, 10004				; 00002714H
	je	SHORT $LN1@fsend
	cmp	eax, 10035				; 00002733H
$LN78@fsend:
	jne	$LN64@fsend
$LN1@fsend:

; 691  :         { soap->errnum = err;
; 692  :           return SOAP_EOF;
; 693  :         }
; 694  :         nwritten = 0; /* and call write() again */

	xor	eax, eax
$LN2@fsend:

; 695  :       }
; 696  :     }
; 697  :     n -= nwritten;
; 698  :     s += nwritten;

	add	DWORD PTR _s$[ebp], eax
	sub	ebx, eax
	mov	DWORD PTR _n$[ebp], ebx
	cmp	ebx, edi
	jne	$LL50@fsend
$LN49@fsend:

; 699  :   }
; 700  :   return SOAP_OK;
; 701  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_fsend	ENDP
PUBLIC	_soap_stream_fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_v$84576 = -4						; size = 4
_os$ = 8						; size = 4
_soap_stream_fault PROC
; _soap$ = eax

; 14703: { if (soap_check_state(soap))

	push	ecx
	push	ebx
	push	esi
	mov	esi, eax
	test	esi, esi
	je	$LN5@soap_strea@2
	movzx	eax, WORD PTR [esi+4]
	mov	ebx, 2
	cmp	ax, 1
	je	SHORT $LN6@soap_strea@2
	cmp	ax, bx
	jne	$LN5@soap_strea@2
$LN6@soap_strea@2:

; 14705:   else if (soap->error)

	cmp	DWORD PTR [esi+90460], 0
	je	$LN35@soap_strea@2
	push	ebp
	push	edi

; 14706:   { const char *c, *v = NULL, *s, **d;
; 14707:     d = soap_faultcode(soap);

	mov	eax, esi
	mov	DWORD PTR _v$84576[esp+20], 0
	call	_soap_fault
	cmp	WORD PTR [esi+6], bx
	jne	SHORT $LN19@soap_strea@2
	mov	eax, DWORD PTR [esi+12208]
	mov	edi, DWORD PTR [eax+16]
	jmp	SHORT $LN20@soap_strea@2
$LN19@soap_strea@2:
	mov	edi, DWORD PTR [esi+12208]
$LN20@soap_strea@2:

; 14708:     if (!*d)

	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN2@soap_strea@2

; 14709:       soap_set_fault(soap);

	mov	eax, esi
	call	_soap_set_fault
$LN2@soap_strea@2:

; 14710:     c = *d;

	mov	ebp, DWORD PTR [edi]

; 14711:     if (soap->version == 2)

	cmp	WORD PTR [esi+6], bx
	jne	SHORT $LN1@soap_strea@2

; 14712:       v = *soap_faultsubcode(soap);

	mov	eax, esi
	call	_soap_faultsubcode
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _v$84576[esp+20], ecx
$LN1@soap_strea@2:

; 14713:     s = *soap_faultstring(soap);

	mov	eax, esi
	call	_soap_fault
	cmp	WORD PTR [esi+6], bx
	jne	SHORT $LN22@soap_strea@2
	mov	edx, DWORD PTR [esi+12208]
	mov	eax, DWORD PTR [edx+20]
	jmp	SHORT $LN23@soap_strea@2
$LN22@soap_strea@2:
	mov	eax, DWORD PTR [esi+12208]
	add	eax, 4
$LN23@soap_strea@2:
	mov	ebx, DWORD PTR [eax]

; 14714:     d = soap_faultdetail(soap);

	mov	eax, esi
	call	_soap_faultdetail

; 14715:     os << (soap->version ? "SOAP 1." : "Error ")
; 14716:        << (soap->version ? (int)soap->version : soap->error)
; 14717:        << " fault: " << c
; 14718:        << "[" << (v ? v : "no subcode") << "]"
; 14719:        << std::endl
; 14720:        << "\"" << (s ? s : "[no reason]") << "\""
; 14721:        << std::endl
; 14722:        << "Detail: " << (d && *d ? *d : "[no detail]")
; 14723:        << std::endl;

	test	eax, eax
	je	SHORT $LN9@soap_strea@2
	mov	eax, DWORD PTR [eax]
	mov	edi, eax
	test	eax, eax
	jne	SHORT $LN10@soap_strea@2
$LN9@soap_strea@2:
	mov	edi, OFFSET ??_C@_0M@NIEENCAP@?$FLno?5detail?$FN?$AA@
$LN10@soap_strea@2:
	test	ebx, ebx
	jne	SHORT $LN12@soap_strea@2
	mov	ebx, OFFSET ??_C@_0M@NEEDGNL@?$FLno?5reason?$FN?$AA@
$LN12@soap_strea@2:
	mov	ecx, DWORD PTR _v$84576[esp+20]
	test	ecx, ecx
	jne	SHORT $LN14@soap_strea@2
	mov	ecx, OFFSET ??_C@_0L@HPHPPAL@no?5subcode?$AA@
$LN14@soap_strea@2:
	movzx	eax, WORD PTR [esi+6]
	test	ax, ax
	je	SHORT $LN17@soap_strea@2
	movsx	esi, ax
	jmp	SHORT $LN18@soap_strea@2
$LN17@soap_strea@2:
	mov	esi, DWORD PTR [esi+90460]
$LN18@soap_strea@2:
	test	ax, ax
	mov	eax, OFFSET ??_C@_07IBLMOOJE@SOAP?51?4?$AA@
	jne	SHORT $LN16@soap_strea@2
	mov	eax, OFFSET ??_C@_06BAOMBKPD@Error?5?$AA@
$LN16@soap_strea@2:
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	push	ecx
	push	OFFSET ??_C@_01OHGJGJJP@?$FL?$AA@
	push	ebp
	push	OFFSET ??_C@_08PPEKPCIO@?5fault?3?5?$AA@
	push	esi
	push	eax
	mov	eax, DWORD PTR _os$[esp+44]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	push	ebx
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	push	edi
	push	OFFSET ??_C@_08IAKGCGCB@Detail?3?5?$AA@
	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	pop	edi
	pop	ebp
	mov	ecx, esi
	pop	esi
	pop	ebx

; 14724:   }
; 14725: }

	add	esp, 4

; 14715:     os << (soap->version ? "SOAP 1." : "Error ")
; 14716:        << (soap->version ? (int)soap->version : soap->error)
; 14717:        << " fault: " << c
; 14718:        << "[" << (v ? v : "no subcode") << "]"
; 14719:        << std::endl
; 14720:        << "\"" << (s ? s : "[no reason]") << "\""
; 14721:        << std::endl
; 14722:        << "Detail: " << (d && *d ? *d : "[no detail]")
; 14723:        << std::endl;

	jmp	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN5@soap_strea@2:

; 14704:     os << "Error: soap struct state not initialized\n";

	mov	ecx, DWORD PTR _os$[esp+8]
	push	OFFSET ??_C@_0CK@KAKMECOH@Error?3?5soap?5struct?5state?5not?5ini@
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 14715:     os << (soap->version ? "SOAP 1." : "Error ")
; 14716:        << (soap->version ? (int)soap->version : soap->error)
; 14717:        << " fault: " << c
; 14718:        << "[" << (v ? v : "no subcode") << "]"
; 14719:        << std::endl
; 14720:        << "\"" << (s ? s : "[no reason]") << "\""
; 14721:        << std::endl
; 14722:        << "Detail: " << (d && *d ? *d : "[no detail]")
; 14723:        << std::endl;

$LN35@soap_strea@2:
	pop	esi
	pop	ebx

; 14724:   }
; 14725: }

	pop	ecx
	ret	0
_soap_stream_fault ENDP
_TEXT	ENDS
PUBLIC	_soap_receiver_fault_subcode
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_faultdetailXML$ = 8					; size = 4
_soap_receiver_fault_subcode PROC
; _soap$ = ecx
; _faultstring$ = eax

; 14666: { return soap_copy_fault(soap, soap->version == 2 ? "SOAP-ENV:Receiver" : "SOAP-ENV:Server", faultsubcodeQName, faultstring, faultdetailXML);

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	cmp	WORD PTR [esi+6], 2
	push	edi
	mov	ebp, OFFSET ??_C@_0BC@DABIKIOO@SOAP?9ENV?3Receiver?$AA@
	je	SHORT $LN4@soap_recei
	mov	ebp, OFFSET ??_C@_0BA@NJHKENFI@SOAP?9ENV?3Server?$AA@
$LN4@soap_recei:
	xor	ebx, ebx
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN6@soap_recei
	push	eax
	push	esi
	call	_soap_strdup
	add	esp, 8
	mov	ebx, eax
$LN6@soap_recei:
	mov	eax, DWORD PTR _faultdetailXML$[esp+12]
	test	eax, eax
	je	SHORT $LN5@soap_recei
	push	eax
	push	esi
	call	_soap_strdup
	add	esp, 8
	mov	edi, eax
$LN5@soap_recei:
	push	edi
	push	ebx
	push	0
	push	ebp
	mov	edi, 12					; 0000000cH
	call	_soap_set_error
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 14667: }

	ret	0
_soap_receiver_fault_subcode ENDP
_TEXT	ENDS
PUBLIC	_soap_receiver_fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_faultstring$ = 8					; size = 4
_soap_receiver_fault PROC
; _soap$ = ecx
; _faultdetailXML$ = eax

; 14656: { return soap_receiver_fault_subcode(soap, NULL, faultstring, faultdetailXML);

	push	eax
	mov	eax, DWORD PTR _faultstring$[esp]
	call	_soap_receiver_fault_subcode
	add	esp, 4

; 14657: }

	ret	0
_soap_receiver_fault ENDP
_TEXT	ENDS
PUBLIC	_soap_sender_fault_subcode
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_faultdetailXML$ = 8					; size = 4
_soap_sender_fault_subcode PROC
; _soap$ = ecx
; _faultstring$ = eax

; 14646: { return soap_copy_fault(soap, soap->version == 2 ? "SOAP-ENV:Sender" : "SOAP-ENV:Client", faultsubcodeQName, faultstring, faultdetailXML);

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	cmp	WORD PTR [esi+6], 2
	push	edi
	mov	ebp, OFFSET ??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@
	je	SHORT $LN4@soap_sende
	mov	ebp, OFFSET ??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@
$LN4@soap_sende:
	xor	ebx, ebx
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN6@soap_sende
	push	eax
	push	esi
	call	_soap_strdup
	add	esp, 8
	mov	ebx, eax
$LN6@soap_sende:
	mov	eax, DWORD PTR _faultdetailXML$[esp+12]
	test	eax, eax
	je	SHORT $LN5@soap_sende
	push	eax
	push	esi
	call	_soap_strdup
	add	esp, 8
	mov	edi, eax
$LN5@soap_sende:
	push	edi
	push	ebx
	push	0
	push	ebp
	mov	edi, 12					; 0000000cH
	call	_soap_set_error
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 14647: }

	ret	0
_soap_sender_fault_subcode ENDP
_TEXT	ENDS
PUBLIC	_soap_sender_fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_faultstring$ = 8					; size = 4
_soap_sender_fault PROC
; _soap$ = ecx
; _faultdetailXML$ = eax

; 14636: { return soap_sender_fault_subcode(soap, NULL, faultstring, faultdetailXML);

	push	eax
	mov	eax, DWORD PTR _faultstring$[esp]
	call	_soap_sender_fault_subcode
	add	esp, 4

; 14637: }

	ret	0
_soap_sender_fault ENDP
_TEXT	ENDS
PUBLIC	_soap_recv_header
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_recv_header PROC
; _soap$ = esi

; 13469: { if (soap_getheader(soap) && soap->error == SOAP_TAG_MISMATCH)

	mov	eax, esi
	call	_soap_getheader
	test	eax, eax
	je	SHORT $LN3@soap_recv_@2
	cmp	DWORD PTR [esi+90460], 3
	jne	SHORT $LN3@soap_recv_@2

; 13470:     soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0

; 13473:   return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 13474: }

	ret	0
$LN3@soap_recv_@2:

; 13471:   else if (soap->error == SOAP_OK && soap->fheader)

	cmp	DWORD PTR [esi+90460], 0
	jne	SHORT $LN7@soap_recv_@2
	mov	eax, DWORD PTR [esi+12272]
	test	eax, eax
	je	SHORT $LN7@soap_recv_@2

; 13472:     soap->error = soap->fheader(soap);

	push	esi
	call	eax
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
$LN7@soap_recv_@2:

; 13473:   return soap->error;

	mov	eax, DWORD PTR [esi+90460]

; 13474: }

	ret	0
_soap_recv_header ENDP
; Function compile flags: /Ogtpy
_content$ = -16					; size = 4
_m$ = -12						; size = 4
_i$ = -8						; size = 4
_t$ = -4						; size = 4
_s$ = 8							; size = 4
_soap$ = 8						; size = 4
_handle$ = 12						; size = 4
_soap_get_mime_attachment PROC

; 11513: { register soap_wchar c = 0;

	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 11514:   register size_t i, m = 0;
; 11515:   register char *s, *t = NULL;
; 11516:   register struct soap_multipart *content;
; 11517:   register short flag = 0;
; 11518:   if (!(soap->mode & SOAP_ENC_MIME))

	mov	esi, DWORD PTR _soap$[esp+20]
	push	edi
	xor	edi, edi
	xor	ebx, ebx
	test	DWORD PTR [esi+8], 256			; 00000100H
	mov	DWORD PTR _m$[esp+28], edi
	mov	DWORD PTR _t$[esp+28], edi
	jne	SHORT $LN45@soap_get_m
	pop	edi
	pop	esi

; 11519:     return NULL;

	xor	eax, eax
	pop	ebx

; 11616: }

	add	esp, 16					; 00000010H
	ret	0
$LN45@soap_get_m:
	push	ebp

; 11520:   content = soap->mime.last;

	mov	ebp, DWORD PTR [esi+90540]
	mov	DWORD PTR _content$[esp+32], ebp

; 11521:   if (!content)

	cmp	ebp, edi
	jne	SHORT $LN44@soap_get_m

; 11522:   { if (soap_getmimehdr(soap))

	call	_soap_getmimehdr
	test	eax, eax

; 11523:       return NULL;

	jne	$LN119@soap_get_m

; 11524:     content = soap->mime.last;

	mov	eax, DWORD PTR [esi+90540]
	mov	DWORD PTR _content$[esp+32], eax
	mov	ebp, eax
	jmp	SHORT $LN112@soap_get_m
$LN44@soap_get_m:

; 11525:   }
; 11526:   else if (content != soap->mime.first)

	cmp	ebp, DWORD PTR [esi+90536]
	je	SHORT $LN112@soap_get_m

; 11527:   { if (soap->fmimewriteopen && ((content->ptr = (char*)soap->fmimewriteopen(soap, (void*)handle, content->id, content->type, content->description, content->encoding)) || soap->error))

	mov	eax, DWORD PTR [esi+12384]
	cmp	eax, edi
	je	SHORT $LN112@soap_get_m
	mov	ecx, DWORD PTR [ebp+24]
	mov	edx, DWORD PTR [ebp+32]
	push	ecx
	mov	ecx, DWORD PTR [ebp+16]
	push	edx
	mov	edx, DWORD PTR [ebp+12]
	push	ecx
	mov	ecx, DWORD PTR _handle$[esp+40]
	push	edx
	push	ecx
	push	esi
	call	eax
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebp+4], eax
	test	eax, eax
	jne	SHORT $LN112@soap_get_m
	cmp	DWORD PTR [esi+90460], ebx

; 11528:     { if (!content->ptr)
; 11529:         return NULL;

	jne	$LN119@soap_get_m
$LN112@soap_get_m:

; 11530:     }
; 11531:   }
; 11532:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Parsing MIME content id=%s type=%s\n", content->id?content->id:"", content->type?content->type:""));
; 11533:   if (!content->ptr && soap_new_block(soap))

	cmp	DWORD PTR [ebp+4], ebx
	jne	SHORT $LL36@soap_get_m
	push	12					; 0000000cH
	call	_malloc
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	$LN79@soap_get_m
	mov	edx, DWORD PTR [esi+92]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [esi+92], eax
	jmp	SHORT $LL36@soap_get_m
	npad	5
$LL111@soap_get_m:

; 11582:         break;
; 11583:     }

	mov	ebp, DWORD PTR _content$[esp+32]
$LL36@soap_get_m:

; 11534:   { soap->error = SOAP_EOM;
; 11535:     return NULL;
; 11536:   }
; 11537:   for (;;)
; 11538:   { if (content->ptr)

	cmp	DWORD PTR [ebp+4], 0
	je	SHORT $LN34@soap_get_m

; 11539:       s = soap->tmpbuf;

	lea	ebp, DWORD PTR [esi+79028]
	mov	DWORD PTR _s$[esp+28], ebp
	jmp	SHORT $LN32@soap_get_m
$LN34@soap_get_m:

; 11540:     else if (!(s = (char*)soap_push_block(soap, sizeof(soap->tmpbuf))))

	push	1032					; 00000408H
	call	_malloc
	add	esp, 4
	test	eax, eax
	je	$LN96@soap_get_m
	mov	ecx, DWORD PTR [esi+92]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	edx, 1024				; 00000400H
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR [esi+92]
	add	DWORD PTR [ecx+8], edx
	add	eax, 8
	mov	DWORD PTR _s$[esp+28], eax
	je	$LN79@soap_get_m
	mov	ebp, eax
$LN32@soap_get_m:

; 11542:       return NULL;
; 11543:     }
; 11544:     for (i = 0; i < sizeof(soap->tmpbuf); i++)

	xor	edx, edx
	mov	DWORD PTR _i$[esp+32], edx
	npad	4
$LL113@soap_get_m:

; 11545:     { if (m > 0)

	cmp	DWORD PTR _m$[esp+32], 0
	jbe	SHORT $LN28@soap_get_m

; 11546:       { *s++ = *t++;

	mov	eax, DWORD PTR _t$[esp+32]
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	BYTE PTR [ebp], cl
	inc	ebp

; 11547:         m--;

	dec	DWORD PTR _m$[esp+32]
	mov	DWORD PTR _t$[esp+32], eax

; 11548:       }
; 11549:       else

	jmp	$LN120@soap_get_m
$LN28@soap_get_m:

; 11550:       { if (!flag)

	test	di, di
	jne	SHORT $LN106@soap_get_m

; 11551:         { c = soap_get1(soap);

	mov	edx, DWORD PTR [esi+12428]
	cmp	edx, DWORD PTR [esi+12432]
	jb	SHORT $LN48@soap_get_m
	call	_soap_recv
	test	eax, eax
	jne	$LN107@soap_get_m
$LN48@soap_get_m:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ebx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax

; 11552:           if ((int)c == EOF)

	cmp	ebx, -1
	je	$LN107@soap_get_m

; 11554:             return NULL;
; 11555:           }
; 11556:         }
; 11557:         if (flag || c == '\r')

	cmp	ebx, 13					; 0000000dH
	jne	$LN109@soap_get_m
$LN106@soap_get_m:

; 11558:         { t = soap->msgbuf;
; 11559:           memset(t, 0, sizeof(soap->msgbuf));

	push	1024					; 00000400H
	xor	edi, edi
	lea	ebp, DWORD PTR [esi+78004]
	push	edi
	push	ebp
	call	_memset

; 11560:           strcpy(t, "\n--");

	mov	DWORD PTR [ebp], 2960650		; 002d2d0aH

; 11561:           if (soap->mime.boundary)

	mov	eax, DWORD PTR [esi+90524]
	add	esp, 12					; 0000000cH
	cmp	eax, edi
	je	SHORT $LL21@soap_get_m

; 11562:             strncat(t, soap->mime.boundary, sizeof(soap->msgbuf)-4);

	push	1020					; 000003fcH
	push	eax
	push	ebp
	call	_strncat
	add	esp, 12					; 0000000cH
	npad	3
$LL21@soap_get_m:

; 11563:           do c = soap_getchar(soap);

	mov	ebx, DWORD PTR [esi+12436]
	cmp	ebx, edi
	je	SHORT $LN57@soap_get_m
	cmp	ebx, -1
	je	SHORT $LN20@soap_get_m
	mov	DWORD PTR [esi+12436], edi
	jmp	SHORT $LN20@soap_get_m
$LN57@soap_get_m:
	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN60@soap_get_m
	call	_soap_recv
	test	eax, eax
	je	SHORT $LN60@soap_get_m
	or	ebx, -1
	jmp	SHORT $LN20@soap_get_m
$LN60@soap_get_m:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ebx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
$LN20@soap_get_m:

; 11564:           while (c == *t++);

	movsx	ecx, BYTE PTR [ebp]
	inc	ebp
	cmp	ebx, ecx
	je	SHORT $LL21@soap_get_m

; 11565:           if ((int)c == EOF)

	cmp	ebx, -1
	je	$LN107@soap_get_m

; 11568:           }
; 11569:           if (!*--t)

	dec	ebp
	cmp	BYTE PTR [ebp], 0
	je	$LN110@soap_get_m

; 11570:             goto end;
; 11571:           *t = (char)c;
; 11572:           flag = (c == '\r');

	xor	edx, edx
	cmp	ebx, 13					; 0000000dH
	sete	dl
	mov	BYTE PTR [ebp], bl

; 11573:           m = t - soap->msgbuf + 1 - flag;
; 11574:           t = soap->msgbuf;
; 11575:           c = '\r';

	mov	ebx, 13					; 0000000dH
	movzx	edi, dx
	movsx	eax, di
	sub	ebp, eax
	sub	ebp, esi
	sub	ebp, 78003				; 000130b3H
	lea	eax, DWORD PTR [esi+78004]
	mov	DWORD PTR _m$[esp+32], ebp
	mov	ebp, DWORD PTR _s$[esp+28]
	mov	DWORD PTR _t$[esp+32], eax
$LN109@soap_get_m:

; 11576:         }
; 11577:         *s++ = (char)c;

	mov	edx, DWORD PTR _i$[esp+32]
	mov	BYTE PTR [ebp], bl
	inc	ebp
$LN120@soap_get_m:
	inc	edx
	mov	DWORD PTR _s$[esp+28], ebp
	mov	DWORD PTR _i$[esp+32], edx
	cmp	edx, 1024				; 00000400H
	jb	$LL113@soap_get_m

; 11578:       }
; 11579:     }
; 11580:     if (content->ptr && soap->fmimewrite)

	mov	ecx, DWORD PTR _content$[esp+32]
	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	je	$LL111@soap_get_m
	mov	eax, DWORD PTR [esi+12400]
	test	eax, eax
	je	$LL111@soap_get_m

; 11581:     { if ((soap->error = soap->fmimewrite(soap, (void*)content->ptr, soap->tmpbuf, i)))

	push	edx
	lea	edx, DWORD PTR [esi+79028]
	push	edx
	push	ecx
	push	esi
	call	eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+90460], eax
	test	eax, eax
	jne	SHORT $end$83253

; 11582:         break;
; 11583:     }

	jmp	$LL111@soap_get_m
$LN96@soap_get_m:

; 11540:     else if (!(s = (char*)soap_push_block(soap, sizeof(soap->tmpbuf))))

	mov	DWORD PTR [esi+90460], 20		; 00000014H
$LN79@soap_get_m:
	pop	ebp
	pop	edi

; 11541:     { soap->error = SOAP_EOM;

	mov	DWORD PTR [esi+90460], 20		; 00000014H
	pop	esi

; 11610:       return NULL;

	xor	eax, eax
	pop	ebx

; 11616: }

	add	esp, 16					; 00000010H
	ret	0
$LN107@soap_get_m:
	pop	ebp
	pop	edi

; 11553:           { soap->error = SOAP_EOF;

	mov	DWORD PTR [esi+90460], -1
	pop	esi

; 11610:       return NULL;

	xor	eax, eax
	pop	ebx

; 11616: }

	add	esp, 16					; 00000010H
	ret	0
$LN110@soap_get_m:

; 11566:           { soap->error = SOAP_EOF;
; 11567:             return NULL;

	mov	ebp, DWORD PTR _s$[esp+28]
$end$83253:

; 11584:   }
; 11585: end:
; 11586:   *s = '\0'; /* force 0-terminated */
; 11587:   if (content->ptr)

	mov	edi, DWORD PTR _content$[esp+32]
	mov	BYTE PTR [ebp], 0
	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	je	SHORT $LN13@soap_get_m

; 11588:   { if (!soap->error && soap->fmimewrite)

	cmp	DWORD PTR [esi+90460], 0
	jne	SHORT $LN12@soap_get_m
	mov	eax, DWORD PTR [esi+12400]
	test	eax, eax
	je	SHORT $LN12@soap_get_m

; 11589:       soap->error = soap->fmimewrite(soap, (void*)content->ptr, soap->tmpbuf, i);

	mov	edx, DWORD PTR _i$[esp+32]
	push	edx
	lea	edx, DWORD PTR [esi+79028]
	push	edx
	push	ecx
	push	esi
	call	eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+90460], eax
$LN12@soap_get_m:

; 11590:     if (soap->fmimewriteclose)

	mov	eax, DWORD PTR [esi+12392]
	test	eax, eax
	je	SHORT $LN11@soap_get_m

; 11591:       soap->fmimewriteclose(soap, (void*)content->ptr);

	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	push	esi
	call	eax
	add	esp, 8
$LN11@soap_get_m:

; 11592:     if (soap->error)

	cmp	DWORD PTR [esi+90460], 0
	je	SHORT $LN9@soap_get_m
	pop	ebp
	pop	edi
	pop	esi

; 11610:       return NULL;

	xor	eax, eax
	pop	ebx

; 11616: }

	add	esp, 16					; 00000010H
	ret	0
$LN13@soap_get_m:

; 11593:       return NULL;
; 11594:   }
; 11595:   else
; 11596:   { content->size = soap_size_block(soap, i+1)-1;

	mov	eax, DWORD PTR [esi+92]
	mov	edx, DWORD PTR _i$[esp+32]
	mov	ecx, DWORD PTR [eax+4]
	inc	edx
	test	ecx, ecx
	je	SHORT $LN62@soap_get_m
	mov	ebp, edx
	sub	ebp, DWORD PTR [ecx+4]
	add	DWORD PTR [eax+8], ebp
	mov	eax, DWORD PTR [esi+92]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
$LN62@soap_get_m:
	mov	edx, DWORD PTR [esi+92]
	mov	eax, DWORD PTR [edx+8]
	dec	eax
	mov	DWORD PTR [edi+8], eax

; 11597:     content->ptr = soap_save_block(soap, NULL, 0);

	mov	eax, esi
	call	_soap_save_block
	mov	DWORD PTR [edi+4], eax
$LN9@soap_get_m:

; 11598:   }
; 11599:   soap_resolve_attachment(soap, content);

	push	esi
	call	_soap_resolve_attachment
	add	esp, 4

; 11600:   if (c == '-' && soap_getchar(soap) == '-')

	cmp	ebx, 45					; 0000002dH
	jne	SHORT $LN75@soap_get_m
	mov	eax, esi
	call	_soap_getchar
	cmp	eax, ebx
	jne	SHORT $LL5@soap_get_m

; 11601:   { soap->mode &= ~SOAP_ENC_MIME;

	and	DWORD PTR [esi+8], -257			; fffffeffH

; 11602:     if ((soap->mode & SOAP_MIME_POSTCHECK) && soap_end_recv(soap))

	test	DWORD PTR [esi+8], 268435456		; 10000000H
	je	$LN1@soap_get_m
	mov	eax, esi
	call	_soap_end_recv
	test	eax, eax
	je	$LN1@soap_get_m
	pop	ebp
	pop	edi
	pop	esi

; 11610:       return NULL;

	xor	eax, eax
	pop	ebx

; 11616: }

	add	esp, 16					; 00000010H
	ret	0
$LN75@soap_get_m:

; 11603:       return NULL;
; 11604:   }
; 11605:   else
; 11606:   { while (c != '\r' && (int)c != EOF && soap_blank(c))

	cmp	ebx, 13					; 0000000dH
	je	SHORT $LN82@soap_get_m
$LL5@soap_get_m:
	cmp	ebx, -1
	je	SHORT $LN4@soap_get_m
	cmp	ebx, 32					; 00000020H
	ja	SHORT $LN4@soap_get_m

; 11607:       c = soap_getchar(soap);

	mov	ebx, DWORD PTR [esi+12436]
	test	ebx, ebx
	je	SHORT $LN66@soap_get_m
	cmp	ebx, -1
	je	SHORT $LN70@soap_get_m
	mov	DWORD PTR [esi+12436], 0
	jmp	SHORT $LN70@soap_get_m
$LN66@soap_get_m:
	mov	ecx, DWORD PTR [esi+12428]
	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN69@soap_get_m
	call	_soap_recv
	test	eax, eax
	je	SHORT $LN69@soap_get_m
	or	ebx, -1
	jmp	SHORT $LL5@soap_get_m
$LN69@soap_get_m:
	mov	eax, DWORD PTR [esi+12428]
	movzx	ebx, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
$LN70@soap_get_m:

; 11603:       return NULL;
; 11604:   }
; 11605:   else
; 11606:   { while (c != '\r' && (int)c != EOF && soap_blank(c))

	cmp	ebx, 13					; 0000000dH
	jne	SHORT $LL5@soap_get_m

; 11608:     if (c != '\r' || soap_getchar(soap) != '\n')

	jmp	SHORT $LN82@soap_get_m
$LN4@soap_get_m:
	cmp	ebx, 13					; 0000000dH
	jne	SHORT $LN2@soap_get_m
$LN82@soap_get_m:
	mov	eax, esi
	call	_soap_getchar
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN2@soap_get_m

; 11611:     }
; 11612:     if (soap_getmimehdr(soap))

	call	_soap_getmimehdr
	test	eax, eax

; 11613:       return NULL;

	jne	SHORT $LN119@soap_get_m
$LN1@soap_get_m:
	pop	ebp

; 11614:   }
; 11615:   return content;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 11616: }

	add	esp, 16					; 00000010H
	ret	0
$LN2@soap_get_m:

; 11609:     { soap->error = SOAP_MIME_ERROR;

	mov	DWORD PTR [esi+90460], 36		; 00000024H
$LN119@soap_get_m:
	pop	ebp
	pop	edi
	pop	esi

; 11610:       return NULL;

	xor	eax, eax
	pop	ebx

; 11616: }

	add	esp, 16					; 00000010H
	ret	0
_soap_get_mime_attachment ENDP
_TEXT	ENDS
PUBLIC	_soap_check_mime_attachments
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_check_mime_attachments PROC
; _soap$ = eax

; 11499: { if (soap->mode & SOAP_MIME_POSTCHECK)

	test	DWORD PTR [eax+8], 268435456		; 10000000H
	je	SHORT $LN1@soap_check@2

; 11500:     return soap_get_mime_attachment(soap, NULL) != NULL;

	push	0
	push	eax
	call	_soap_get_mime_attachment
	add	esp, 8
	neg	eax
	sbb	eax, eax
	neg	eax

; 11502: }

	ret	0
$LN1@soap_check@2:

; 11501:   return 0;

	xor	eax, eax

; 11502: }

	ret	0
_soap_check_mime_attachments ENDP
_TEXT	ENDS
PUBLIC	_soap_init
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_init PROC
; _soap$ = edx

; 6452 : { soap->state = SOAP_INIT;

	mov	eax, 1
	push	ebx

; 6453 : #ifdef SOAP_MEM_DEBUG
; 6454 :   soap_init_mht(soap);
; 6455 : #endif
; 6456 :   soap->version = 0;
; 6457 :   soap_imode(soap, SOAP_IO_DEFAULT);

	xor	ebx, ebx
	xor	ecx, ecx
	mov	WORD PTR [edx+4], ax

; 6458 :   soap_omode(soap, SOAP_IO_DEFAULT);
; 6459 :   soap->plugins = NULL;
; 6460 :   soap->user = NULL;
; 6461 :   soap->userid = NULL;
; 6462 :   soap->passwd = NULL;
; 6463 : #ifndef WITH_NOHTTP
; 6464 :   soap->fpost = http_post;
; 6465 :   soap->fget = http_get;
; 6466 :   soap->fput = http_put;
; 6467 :   soap->fdel = http_del;
; 6468 :   soap->fhead = http_head;
; 6469 :   soap->fform = NULL;
; 6470 :   soap->fposthdr = http_post_header;
; 6471 :   soap->fresponse = http_response;
; 6472 :   soap->fparse = http_parse;
; 6473 :   soap->fparsehdr = http_parse_header;
; 6474 : #endif
; 6475 :   soap->fheader = NULL;
; 6476 :   soap->fconnect = NULL;
; 6477 :   soap->fdisconnect = NULL;
; 6478 : #ifndef WITH_NOIO
; 6479 : #ifndef WITH_IPV6
; 6480 :   soap->fresolve = tcp_gethost;
; 6481 : #else
; 6482 :   soap->fresolve = NULL;
; 6483 : #endif
; 6484 :   soap->faccept = tcp_accept;
; 6485 :   soap->fopen = tcp_connect;
; 6486 :   soap->fclose = tcp_disconnect;
; 6487 :   soap->fclosesocket = tcp_closesocket;
; 6488 :   soap->fshutdownsocket = tcp_shutdownsocket;
; 6489 :   soap->fsend = fsend;
; 6490 :   soap->frecv = frecv;
; 6491 :   soap->fpoll = soap_poll;
; 6492 : #else
; 6493 :   soap->fopen = NULL;
; 6494 :   soap->fclose = NULL;
; 6495 :   soap->fpoll = NULL;
; 6496 : #endif
; 6497 :   soap->fseterror = NULL;
; 6498 :   soap->fignore = NULL;
; 6499 :   soap->fserveloop = NULL;
; 6500 :   soap->fplugin = fplugin;
; 6501 :   soap->fmalloc = NULL;
; 6502 : #ifndef WITH_LEANER
; 6503 :   soap->fprepareinit = NULL;
; 6504 :   soap->fpreparesend = NULL;
; 6505 :   soap->fpreparerecv = NULL;
; 6506 :   soap->fpreparefinal = NULL;
; 6507 :   soap->fdimereadopen = NULL;
; 6508 :   soap->fdimewriteopen = NULL;
; 6509 :   soap->fdimereadclose = NULL;
; 6510 :   soap->fdimewriteclose = NULL;
; 6511 :   soap->fdimeread = NULL;
; 6512 :   soap->fdimewrite = NULL;
; 6513 :   soap->fmimereadopen = NULL;
; 6514 :   soap->fmimewriteopen = NULL;
; 6515 :   soap->fmimereadclose = NULL;
; 6516 :   soap->fmimewriteclose = NULL;
; 6517 :   soap->fmimeread = NULL;
; 6518 :   soap->fmimewrite = NULL;
; 6519 : #endif
; 6520 :   soap->float_format = "%.9G"; /* Alternative: use "%G" */
; 6521 :   soap->double_format = "%.17lG"; /* Alternative: use "%lG" */
; 6522 :   soap->dime_id_format = "cid:id%d"; /* default DIME id format */
; 6523 :   soap->http_version = "1.1";
; 6524 :   soap->proxy_http_version = "1.0";
; 6525 :   soap->http_content = NULL;
; 6526 :   soap->actor = NULL;
; 6527 :   soap->keep_alive = 0;

	xor	eax, eax
	push	edi
	mov	WORD PTR [edx+6], cx
	mov	DWORD PTR [edx+12], ebx
	mov	DWORD PTR [edx+16], ebx
	mov	DWORD PTR [edx+8], ebx
	mov	DWORD PTR [edx+12220], ebx
	mov	DWORD PTR [edx+12216], ebx
	mov	DWORD PTR [edx+12224], ebx
	mov	DWORD PTR [edx+12228], ebx
	mov	DWORD PTR [edx+12232], OFFSET _http_post
	mov	DWORD PTR [edx+12236], OFFSET _http_get
	mov	DWORD PTR [edx+12240], OFFSET _http_put
	mov	DWORD PTR [edx+12244], OFFSET _http_del
	mov	DWORD PTR [edx+12248], OFFSET _http_head
	mov	DWORD PTR [edx+12252], ebx
	mov	DWORD PTR [edx+12256], OFFSET _http_post_header
	mov	DWORD PTR [edx+12260], OFFSET _http_response
	mov	DWORD PTR [edx+12264], OFFSET _http_parse
	mov	DWORD PTR [edx+12268], OFFSET _http_parse_header
	mov	DWORD PTR [edx+12272], ebx
	mov	DWORD PTR [edx+12280], ebx
	mov	DWORD PTR [edx+12284], ebx
	mov	DWORD PTR [edx+12276], OFFSET _tcp_gethost
	mov	DWORD PTR [edx+12300], OFFSET _tcp_accept
	mov	DWORD PTR [edx+12296], OFFSET _tcp_connect
	mov	DWORD PTR [edx+12304], OFFSET _tcp_disconnect
	mov	DWORD PTR [edx+12288], OFFSET _tcp_closesocket
	mov	DWORD PTR [edx+12292], OFFSET _tcp_shutdownsocket
	mov	DWORD PTR [edx+12308], OFFSET _fsend
	mov	DWORD PTR [edx+12312], OFFSET _frecv
	mov	DWORD PTR [edx+12316], OFFSET _soap_poll
	mov	DWORD PTR [edx+12320], ebx
	mov	DWORD PTR [edx+12324], ebx
	mov	DWORD PTR [edx+12328], ebx
	mov	DWORD PTR [edx+12332], OFFSET _fplugin
	mov	DWORD PTR [edx+12336], ebx
	mov	DWORD PTR [edx+12340], ebx
	mov	DWORD PTR [edx+12344], ebx
	mov	DWORD PTR [edx+12348], ebx
	mov	DWORD PTR [edx+12352], ebx
	mov	DWORD PTR [edx+12356], ebx
	mov	DWORD PTR [edx+12360], ebx
	mov	DWORD PTR [edx+12364], ebx
	mov	DWORD PTR [edx+12368], ebx
	mov	DWORD PTR [edx+12372], ebx
	mov	DWORD PTR [edx+12376], ebx
	mov	DWORD PTR [edx+12380], ebx
	mov	DWORD PTR [edx+12384], ebx
	mov	DWORD PTR [edx+12388], ebx
	mov	DWORD PTR [edx+12392], ebx
	mov	DWORD PTR [edx+12396], ebx
	mov	DWORD PTR [edx+12400], ebx
	mov	DWORD PTR [edx+20], OFFSET ??_C@_04OEJDHHEG@?$CF?49G?$AA@
	mov	DWORD PTR [edx+24], OFFSET ??_C@_06MNPIOIFE@?$CF?417lG?$AA@
	mov	DWORD PTR [edx+28], OFFSET ??_C@_08HGNFPOFN@cid?3id?$CFd?$AA@
	mov	DWORD PTR [edx+32], OFFSET ??_C@_03GCKCNDHP@1?41?$AA@
	mov	DWORD PTR [edx+90432], OFFSET ??_C@_03HLLJOCDO@1?40?$AA@
	mov	DWORD PTR [edx+36], ebx
	mov	DWORD PTR [edx+44], ebx
	mov	WORD PTR [edx+90412], ax

; 6528 :   soap->tcp_keep_alive = 0;

	mov	WORD PTR [edx+90414], cx

; 6529 :   soap->tcp_keep_idle = 0;

	mov	DWORD PTR [edx+90416], ebx

; 6530 :   soap->tcp_keep_intvl = 0;

	mov	DWORD PTR [edx+90420], ebx

; 6531 :   soap->tcp_keep_cnt = 0;

	mov	DWORD PTR [edx+90424], ebx

; 6532 :   soap->max_keep_alive = SOAP_MAXKEEPALIVE;

	mov	DWORD PTR [edx+90428], 100		; 00000064H

; 6533 :   soap->recv_timeout = 0;

	mov	DWORD PTR [edx+48], ebx

; 6534 :   soap->send_timeout = 0;

	mov	DWORD PTR [edx+52], ebx

; 6535 :   soap->connect_timeout = 0;

	mov	DWORD PTR [edx+56], ebx

; 6536 :   soap->accept_timeout = 0;

	mov	DWORD PTR [edx+60], ebx

; 6537 :   soap->socket_flags = 0;

	mov	DWORD PTR [edx+64], ebx

; 6538 :   soap->connect_flags = 0;

	mov	DWORD PTR [edx+68], ebx

; 6539 :   soap->bind_flags = 0;

	mov	DWORD PTR [edx+72], ebx

; 6540 :   soap->accept_flags = 0;

	mov	DWORD PTR [edx+76], ebx

; 6541 :   soap->ip = 0;

	mov	DWORD PTR [edx+90404], ebx

; 6542 :   soap->labbuf = NULL;

	mov	DWORD PTR [edx+12456], ebx

; 6543 :   soap->lablen = 0;

	mov	DWORD PTR [edx+12460], ebx

; 6544 :   soap->labidx = 0;

	mov	DWORD PTR [edx+12464], ebx

; 6545 :   soap->encodingStyle = SOAP_STR_EOS;
; 6546 : #ifndef WITH_NONAMESPACES
; 6547 :   soap->namespaces = namespaces;
; 6548 : #else
; 6549 :   soap->namespaces = NULL;
; 6550 : #endif
; 6551 :   soap->local_namespaces = NULL;

	mov	DWORD PTR [edx+84], ebx

; 6552 :   soap->nlist = NULL;

	mov	DWORD PTR [edx+88], ebx

; 6553 :   soap->blist = NULL;

	mov	DWORD PTR [edx+92], ebx

; 6554 :   soap->clist = NULL;

	mov	DWORD PTR [edx+96], ebx

; 6555 :   soap->alist = NULL;

	mov	DWORD PTR [edx+100], ebx

; 6556 :   soap->attributes = NULL;

	mov	DWORD PTR [edx+87292], ebx

; 6557 :   soap->header = NULL;

	mov	DWORD PTR [edx+12204], ebx

; 6558 :   soap->fault = NULL;

	mov	DWORD PTR [edx+12208], ebx

; 6559 :   soap->master = SOAP_INVALID_SOCKET;
; 6560 :   soap->socket = SOAP_INVALID_SOCKET;
; 6561 :   soap->os = NULL;

	mov	DWORD PTR [edx+12412], ebx

; 6562 :   soap->is = NULL;

	mov	DWORD PTR [edx+12416], ebx

; 6563 : #ifndef WITH_LEANER
; 6564 :   soap->dom = NULL;

	mov	DWORD PTR [edx+90472], ebx

; 6565 :   soap->dime.list = NULL;

	mov	DWORD PTR [edx+90512], ebx

; 6566 :   soap->dime.first = NULL;

	mov	DWORD PTR [edx+90516], ebx

; 6567 :   soap->dime.last = NULL;

	mov	DWORD PTR [edx+90520], ebx

; 6568 :   soap->mime.list = NULL;

	mov	DWORD PTR [edx+90532], ebx
	mov	DWORD PTR [edx+40], OFFSET _soap_padding
	mov	DWORD PTR [edx+80], OFFSET _namespaces
	or	eax, -1
	mov	DWORD PTR [edx+12404], eax
	mov	DWORD PTR [edx+12408], eax

; 6569 :   soap->mime.first = NULL;

	mov	DWORD PTR [edx+90536], ebx

; 6570 :   soap->mime.last = NULL;

	mov	DWORD PTR [edx+90540], ebx

; 6571 :   soap->mime.boundary = NULL;

	mov	DWORD PTR [edx+90524], ebx

; 6572 :   soap->mime.start = NULL;

	mov	DWORD PTR [edx+90528], ebx

; 6573 :   soap->xlist = NULL;

	mov	DWORD PTR [edx+90544], ebx

; 6574 : #endif
; 6575 : #ifndef UNDER_CE
; 6576 :   soap->recvfd = 0;

	mov	DWORD PTR [edx+12424], ebx

; 6577 :   soap->sendfd = 1;

	mov	DWORD PTR [edx+12420], 1

; 6578 : #else
; 6579 :   soap->recvfd = stdin;
; 6580 :   soap->sendfd = stdout;
; 6581 : #endif
; 6582 :   soap->host[0] = '\0';

	mov	BYTE PTR [edx+89368], bl

; 6583 :   soap->port = 0;

	mov	DWORD PTR [edx+90408], ebx

; 6584 :   soap->action = NULL;

	mov	DWORD PTR [edx+90392], ebx

; 6585 :   soap->proxy_host = NULL;

	mov	DWORD PTR [edx+90436], ebx

; 6586 :   soap->proxy_port = 8080;

	mov	DWORD PTR [edx+90440], 8080		; 00001f90H

; 6587 :   soap->proxy_userid = NULL;

	mov	DWORD PTR [edx+90444], ebx

; 6588 :   soap->proxy_passwd = NULL;

	mov	DWORD PTR [edx+90448], ebx

; 6589 :   soap->authrealm = NULL;

	mov	DWORD PTR [edx+90396], ebx

; 6590 :   soap->prolog = NULL;

	mov	DWORD PTR [edx+90400], ebx

; 6591 : #ifdef WITH_ZLIB
; 6592 :   soap->zlib_state = SOAP_ZLIB_NONE;
; 6593 :   soap->zlib_in = SOAP_ZLIB_NONE;
; 6594 :   soap->zlib_out = SOAP_ZLIB_NONE;
; 6595 :   soap->d_stream = (z_stream*)SOAP_MALLOC(soap, sizeof(z_stream));
; 6596 :   soap->d_stream->zalloc = Z_NULL;
; 6597 :   soap->d_stream->zfree = Z_NULL;
; 6598 :   soap->d_stream->opaque = Z_NULL;
; 6599 :   soap->z_buf = NULL;
; 6600 :   soap->z_level = 6;
; 6601 : #endif
; 6602 : #ifndef WITH_LEAN
; 6603 :   soap->c14ninclude = NULL;

	mov	DWORD PTR [edx+94668], ebx

; 6604 :   soap->c14nexclude = NULL;

	mov	DWORD PTR [edx+94672], ebx

; 6605 :   soap->cookies = NULL;

	mov	DWORD PTR [edx+94676], ebx

; 6606 :   soap->cookie_domain = NULL;

	mov	DWORD PTR [edx+94680], ebx

; 6607 :   soap->cookie_path = NULL;

	mov	DWORD PTR [edx+94684], ebx

; 6608 :   soap->cookie_max = 32;
; 6609 : #endif
; 6610 : #ifdef SOAP_DEBUG
; 6611 :   soap_init_logs(soap);
; 6612 : #endif
; 6613 : #ifdef WMW_RPM_IO
; 6614 :   soap->rpmreqid = NULL;
; 6615 : #endif
; 6616 : #ifdef PALM
; 6617 :   palmNetLibOpen();
; 6618 : #endif
; 6619 : #ifndef WITH_NOIDREF
; 6620 :   soap_init_iht(soap);

	xor	eax, eax
	mov	DWORD PTR [edx+94688], 32		; 00000020H
	lea	edi, DWORD PTR [edx+104]
	mov	ecx, 1999				; 000007cfH
	rep stosd

; 6621 :   soap_init_pht(soap);

	mov	DWORD PTR [edx+12196], ebx
	mov	WORD PTR [edx+12200], ax
	lea	edi, DWORD PTR [edx+8100]
	mov	ecx, 1024				; 00000400H
	rep stosd
	pop	edi

; 6622 : #endif
; 6623 : #ifdef SOAP_DEBUG
; 6624 :   soap_set_recv_logfile(soap, "RECV.log");
; 6625 :   soap_set_sent_logfile(soap, "SENT.log");
; 6626 :   soap_set_test_logfile(soap, "TEST.log");
; 6627 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Initializing context\n"));
; 6628 : #endif
; 6629 : #ifdef WITH_OPENSSL
; 6630 :   if (!soap_ssl_init_done)
; 6631 :   { soap_ssl_init();
; 6632 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Initializing OpenSSL, version=%ld\n", (long)OPENSSL_VERSION_NUMBER));
; 6633 :   }
; 6634 :   soap->fsslauth = ssl_auth_init;
; 6635 :   soap->fsslverify = ssl_verify_callback;
; 6636 :   soap->bio = NULL;
; 6637 :   soap->ssl = NULL;
; 6638 :   soap->ctx = NULL;
; 6639 :   soap->ssl_flags = SOAP_SSL_DEFAULT;
; 6640 :   soap->keyfile = NULL;
; 6641 :   soap->password = NULL;
; 6642 :   soap->dhfile = NULL;
; 6643 :   soap->cafile = NULL;
; 6644 :   soap->capath = NULL;
; 6645 :   soap->crlfile = NULL;
; 6646 :   soap->randfile = NULL;
; 6647 :   soap->session = NULL;
; 6648 : #endif
; 6649 :   soap_begin(soap);

	mov	eax, edx
	pop	ebx
	jmp	_soap_begin
_soap_init ENDP
_TEXT	ENDS
PUBLIC	_soap_done
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_done PROC
; _soap$ = eax

; 3304 : {

	push	ebx
	push	esi
	mov	esi, eax

; 3305 : #ifdef SOAP_DEBUG
; 3306 :   int i;
; 3307 : #endif
; 3308 :   if (soap_check_state(soap))

	xor	ebx, ebx
	cmp	esi, ebx
	je	$LN9@soap_done
	movzx	eax, WORD PTR [esi+4]
	cmp	ax, 1
	je	SHORT $LN10@soap_done
	cmp	ax, 2
	jne	$LN9@soap_done
$LN10@soap_done:
	push	edi

; 3309 :     return;
; 3310 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Done with context\n"));
; 3311 :   soap_free_temp(soap);

	call	_soap_free_temp

; 3312 :   while (soap->clist)

	cmp	DWORD PTR [esi+96], ebx
	je	SHORT $LN7@soap_done
	npad	3
$LL8@soap_done:

; 3313 :   { struct soap_clist *p = soap->clist->next;

	mov	eax, DWORD PTR [esi+96]
	mov	edi, DWORD PTR [eax]

; 3314 :     SOAP_FREE(soap, soap->clist);

	push	eax
	call	_free
	add	esp, 4

; 3315 :     soap->clist = p;

	mov	DWORD PTR [esi+96], edi
	cmp	edi, ebx
	jne	SHORT $LL8@soap_done
$LN7@soap_done:

; 3316 :   }
; 3317 :   soap->keep_alive = 0; /* to force close the socket */

	xor	eax, eax
	mov	WORD PTR [esi+90412], ax

; 3318 :   soap_closesock(soap);

	call	_soap_closesock

; 3319 : #ifdef WITH_COOKIES
; 3320 :   soap_free_cookies(soap);
; 3321 : #endif
; 3322 :   while (soap->plugins)

	cmp	DWORD PTR [esi+12220], ebx
	je	SHORT $LN5@soap_done
	npad	5
$LL6@soap_done:

; 3323 :   { register struct soap_plugin *p = soap->plugins->next;

	mov	eax, DWORD PTR [esi+12220]
	mov	edi, DWORD PTR [eax]

; 3324 :     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Removing plugin '%s'\n", soap->plugins->id));
; 3325 :     if (soap->plugins->fcopy || soap->state == SOAP_INIT)

	cmp	DWORD PTR [eax+12], ebx
	jne	SHORT $LN3@soap_done
	cmp	WORD PTR [esi+4], 1
	jne	SHORT $LN4@soap_done
$LN3@soap_done:

; 3326 :       soap->plugins->fdelete(soap, soap->plugins);

	mov	ecx, DWORD PTR [eax+16]
	push	eax
	push	esi
	call	ecx
	add	esp, 8
$LN4@soap_done:

; 3327 :     SOAP_FREE(soap, soap->plugins);

	mov	edx, DWORD PTR [esi+12220]
	push	edx
	call	_free
	add	esp, 4

; 3328 :     soap->plugins = p;

	mov	DWORD PTR [esi+12220], edi
	cmp	edi, ebx
	jne	SHORT $LL6@soap_done
$LN5@soap_done:

; 3329 :   }
; 3330 :   soap->fplugin = fplugin;
; 3331 :   soap->fmalloc = NULL;
; 3332 : #ifndef WITH_NOHTTP
; 3333 :   soap->fpost = http_post;
; 3334 :   soap->fget = http_get;
; 3335 :   soap->fput = http_put;
; 3336 :   soap->fdel = http_del;
; 3337 :   soap->fhead = http_head;
; 3338 :   soap->fform = NULL;
; 3339 :   soap->fposthdr = http_post_header;
; 3340 :   soap->fresponse = http_response;
; 3341 :   soap->fparse = http_parse;
; 3342 :   soap->fparsehdr = http_parse_header;
; 3343 : #endif
; 3344 :   soap->fheader = NULL;
; 3345 : #ifndef WITH_NOIO
; 3346 : #ifndef WITH_IPV6
; 3347 :   soap->fresolve = tcp_gethost;
; 3348 : #else
; 3349 :   soap->fresolve = NULL;
; 3350 : #endif
; 3351 :   soap->faccept = tcp_accept;
; 3352 :   soap->fopen = tcp_connect;
; 3353 :   soap->fclose = tcp_disconnect;
; 3354 :   soap->fclosesocket = tcp_closesocket;
; 3355 :   soap->fshutdownsocket = tcp_shutdownsocket;
; 3356 :   soap->fsend = fsend;
; 3357 :   soap->frecv = frecv;
; 3358 :   soap->fpoll = soap_poll;
; 3359 : #else
; 3360 :   soap->fopen = NULL;
; 3361 :   soap->fclose = NULL;
; 3362 :   soap->fpoll = NULL;
; 3363 : #endif
; 3364 : #ifndef WITH_LEANER
; 3365 :   soap->fprepareinit = NULL;
; 3366 :   soap->fpreparesend = NULL;
; 3367 :   soap->fpreparerecv = NULL;
; 3368 :   soap->fpreparefinal = NULL;
; 3369 : #endif
; 3370 :   soap->fseterror = NULL;
; 3371 :   soap->fignore = NULL;
; 3372 :   soap->fserveloop = NULL;
; 3373 : #ifdef WITH_OPENSSL
; 3374 :   if (soap->session)
; 3375 :   { SSL_SESSION_free(soap->session);
; 3376 :     soap->session = NULL;
; 3377 :   }
; 3378 : #endif
; 3379 :   if (soap->state == SOAP_INIT)

	cmp	WORD PTR [esi+4], 1
	mov	DWORD PTR [esi+12332], OFFSET _fplugin
	mov	DWORD PTR [esi+12336], ebx
	mov	DWORD PTR [esi+12232], OFFSET _http_post
	mov	DWORD PTR [esi+12236], OFFSET _http_get
	mov	DWORD PTR [esi+12240], OFFSET _http_put
	mov	DWORD PTR [esi+12244], OFFSET _http_del
	mov	DWORD PTR [esi+12248], OFFSET _http_head
	mov	DWORD PTR [esi+12252], ebx
	mov	DWORD PTR [esi+12256], OFFSET _http_post_header
	mov	DWORD PTR [esi+12260], OFFSET _http_response
	mov	DWORD PTR [esi+12264], OFFSET _http_parse
	mov	DWORD PTR [esi+12268], OFFSET _http_parse_header
	mov	DWORD PTR [esi+12272], ebx
	mov	DWORD PTR [esi+12276], OFFSET _tcp_gethost
	mov	DWORD PTR [esi+12300], OFFSET _tcp_accept
	mov	DWORD PTR [esi+12296], OFFSET _tcp_connect
	mov	DWORD PTR [esi+12304], OFFSET _tcp_disconnect
	mov	DWORD PTR [esi+12288], OFFSET _tcp_closesocket
	mov	DWORD PTR [esi+12292], OFFSET _tcp_shutdownsocket
	mov	DWORD PTR [esi+12308], OFFSET _fsend
	mov	DWORD PTR [esi+12312], OFFSET _frecv
	mov	DWORD PTR [esi+12316], OFFSET _soap_poll
	mov	DWORD PTR [esi+12340], ebx
	mov	DWORD PTR [esi+12344], ebx
	mov	DWORD PTR [esi+12348], ebx
	mov	DWORD PTR [esi+12352], ebx
	mov	DWORD PTR [esi+12320], ebx
	mov	DWORD PTR [esi+12324], ebx
	mov	DWORD PTR [esi+12328], ebx
	pop	edi
	jne	SHORT $LN9@soap_done

; 3380 :   { if (soap_valid_socket(soap->master))

	mov	eax, DWORD PTR [esi+12404]
	cmp	eax, -1
	je	SHORT $LN9@soap_done

; 3381 :     { soap->fclosesocket(soap, soap->master);

	push	eax
	push	esi
	call	_tcp_closesocket
	add	esp, 8

; 3382 :       soap->master = SOAP_INVALID_SOCKET;

	mov	DWORD PTR [esi+12404], -1
$LN9@soap_done:
	pop	esi
	pop	ebx

; 3383 :     }
; 3384 : #ifdef WITH_OPENSSL
; 3385 :     if (soap->ctx)
; 3386 :     { SSL_CTX_free(soap->ctx);
; 3387 :       soap->ctx = NULL;
; 3388 :     }
; 3389 : #endif
; 3390 :   }
; 3391 : #ifdef WITH_ZLIB
; 3392 :   if (soap->d_stream)
; 3393 :   { SOAP_FREE(soap, (void*)soap->d_stream);
; 3394 :     soap->d_stream = NULL;
; 3395 :   }
; 3396 :   if (soap->z_buf)
; 3397 :   { SOAP_FREE(soap, (void*)soap->z_buf);
; 3398 :     soap->z_buf = NULL;
; 3399 :   }
; 3400 : #endif
; 3401 : #ifdef SOAP_DEBUG
; 3402 :   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free logfiles\n"));
; 3403 :   for (i = 0; i < SOAP_MAXLOGS; i++)
; 3404 :   { if (soap->logfile[i])
; 3405 :     { SOAP_FREE(soap, (void*)soap->logfile[i]);
; 3406 :       soap->logfile[i] = NULL;
; 3407 :     }
; 3408 :     soap_close_logfile(soap, i);
; 3409 :   }
; 3410 :   soap->state = 0;
; 3411 : #endif
; 3412 : #ifdef SOAP_MEM_DEBUG
; 3413 :   soap_free_mht(soap);
; 3414 : #endif
; 3415 : }

	ret	0
_soap_done ENDP
PUBLIC	??1soap@@UAE@XZ					; soap::~soap
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
??1soap@@UAE@XZ PROC					; soap::~soap
; _this$ = ecx

; 14884: { soap_destroy(this);

	push	esi
	mov	esi, ecx
	movzx	eax, WORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7soap@@6B@
	cmp	ax, 1
	je	SHORT $LN13@soap
	cmp	ax, 2
	jne	SHORT $LN12@soap
$LN13@soap:
	cmp	DWORD PTR [esi+96], 0
	je	SHORT $LN4@soap
	push	edi
$LL5@soap:
	mov	edi, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+96], eax
	mov	ecx, DWORD PTR [edi+16]
	push	edi
	call	ecx
	push	edi
	call	_free
	add	esp, 8
	cmp	DWORD PTR [esi+96], 0
	jne	SHORT $LL5@soap
	pop	edi
$LN4@soap:
	mov	DWORD PTR [esi+12208], 0
	mov	DWORD PTR [esi+12204], 0
$LN12@soap:

; 14885:   soap_end(this);

	mov	eax, esi
	call	_soap_end

; 14886:   soap_done(this);

	mov	eax, esi
	pop	esi
	jmp	_soap_done
??1soap@@UAE@XZ ENDP					; soap::~soap
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gsoap@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gsoap@@UAEPAXI@Z PROC				; soap::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1soap@@UAE@XZ				; soap::~soap
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@102
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@102:
	mov	eax, esi
	pop	esi
	ret	4
??_Gsoap@@UAEPAXI@Z ENDP				; soap::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0soap@@QAE@XZ					; soap::soap
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
??0soap@@QAE@XZ PROC					; soap::soap
; _this$ = esi

; 14856: { soap_init(this);

	mov	edx, esi
	mov	DWORD PTR [esi], OFFSET ??_7soap@@6B@
	call	_soap_init

; 14857: }

	mov	eax, esi
	ret	0
??0soap@@QAE@XZ ENDP					; soap::soap
_TEXT	ENDS
PUBLIC	_soap_send_fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_status$ = -532						; size = 4
_timeout$84316 = -528					; size = 8
_sfd$84318 = -520					; size = 260
_rfd$84317 = -260					; size = 260
_soap_send_fault PROC
; _soap$ = eax

; 14399: { register int status = soap->error;

	sub	esp, 532				; 00000214H
	push	ebx
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR [esi+90460]

; 14400:   int r = 1;

	mov	ebx, 1
	push	edi
	mov	DWORD PTR _status$[esp+544], eax
	mov	edi, ebx

; 14401:   if (status == SOAP_STOP)

	cmp	eax, 1000				; 000003e8H
	jne	SHORT $LN18@soap_send_@3
	pop	edi
	pop	esi
	pop	ebx

; 14453: }

	add	esp, 532				; 00000214H
	ret	0
$LN18@soap_send_@3:

; 14402:     return status;
; 14403:   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Sending back fault struct for error code %d\n", soap->error));
; 14404:   soap->keep_alive = 0; /* to terminate connection */

	xor	eax, eax
	mov	WORD PTR [esi+90412], ax

; 14405:   soap_set_fault(soap);

	mov	eax, esi
	call	_soap_set_fault

; 14406: #ifndef WITH_NOIO
; 14407: #ifndef WITH_LEAN
; 14408:   if (soap_valid_socket(soap->socket))

	mov	eax, DWORD PTR [esi+12408]
	cmp	eax, -1
	je	$LN28@soap_send_@3

; 14409:   { struct timeval timeout;
; 14410:     fd_set rfd, sfd;
; 14411:     timeout.tv_sec = 0;
; 14412:     timeout.tv_usec = 0;
; 14413:     FD_ZERO(&rfd);
; 14414:     FD_ZERO(&sfd);
; 14415:     FD_SET(soap->socket, &rfd);
; 14416:     FD_SET(soap->socket, &sfd);
; 14417:     r = select((int)soap->socket + 1, &rfd, &sfd, NULL, &timeout);

	lea	ecx, DWORD PTR _timeout$84316[esp+544]
	push	ecx
	push	0
	lea	edx, DWORD PTR _sfd$84318[esp+552]
	push	edx
	lea	ecx, DWORD PTR _rfd$84317[esp+556]
	mov	DWORD PTR _rfd$84317[esp+560], eax
	mov	DWORD PTR _sfd$84318[esp+560], eax
	push	ecx
	inc	eax
	push	eax
	mov	DWORD PTR _timeout$84316[esp+564], 0
	mov	DWORD PTR _timeout$84316[esp+568], 0
	mov	DWORD PTR _rfd$84317[esp+564], ebx
	mov	DWORD PTR _sfd$84318[esp+564], ebx
	call	_select@20
	mov	edi, eax

; 14418:     if (r > 0)

	test	edi, edi
	jle	SHORT $LN28@soap_send_@3

; 14419:     { if (!FD_ISSET(soap->socket, &sfd)
; 14420:        || (FD_ISSET(soap->socket, &rfd)
; 14421:         && recv(soap->socket, soap->tmpbuf, 1, MSG_PEEK) < 0))

	mov	eax, DWORD PTR [esi+12408]
	lea	edx, DWORD PTR _sfd$84318[esp+544]
	push	edx
	push	eax
	call	___WSAFDIsSet@8
	test	eax, eax
	je	SHORT $LN6@soap_send_@3
	mov	edx, DWORD PTR [esi+12408]
	lea	ecx, DWORD PTR _rfd$84317[esp+544]
	push	ecx
	push	edx
	call	___WSAFDIsSet@8
	test	eax, eax
	je	SHORT $LN28@soap_send_@3
	mov	ecx, DWORD PTR [esi+12408]
	push	2
	push	ebx
	lea	eax, DWORD PTR [esi+79028]
	push	eax
	push	ecx
	call	_recv@16
	test	eax, eax
	jge	SHORT $LN28@soap_send_@3
$LN6@soap_send_@3:

; 14422:         r = 0;

	xor	edi, edi
$LN28@soap_send_@3:

; 14423:     }
; 14424:   }
; 14425: #endif
; 14426: #endif
; 14427:   if ((status != SOAP_EOF || (!soap->recv_timeout && !soap->send_timeout)) && r > 0)

	mov	ebx, DWORD PTR _status$[esp+544]
	cmp	ebx, -1
	jne	SHORT $LN4@soap_send_@3
	cmp	DWORD PTR [esi+48], 0
	jne	$LN5@soap_send_@3
	cmp	DWORD PTR [esi+52], 0
	jne	$LN5@soap_send_@3
$LN4@soap_send_@3:
	test	edi, edi
	jle	$LN5@soap_send_@3

; 14428:   { soap->error = SOAP_OK;
; 14429:     soap_serializeheader(soap);
; 14430:     soap_serializefault(soap);

	mov	eax, esi
	mov	DWORD PTR [esi+90460], 0
	call	_soap_fault
	mov	eax, DWORD PTR [esi+12208]
	test	eax, eax
	je	SHORT $LN21@soap_send_@3
	mov	ecx, esi
	call	?soap_serialize_SOAP_ENV__Fault@@YAXPAUsoap@@PBUSOAP_ENV__Fault@@@Z ; soap_serialize_SOAP_ENV__Fault
$LN21@soap_send_@3:

; 14431:     soap_begin_count(soap);

	call	_soap_begin_count

; 14432:     if (soap->mode & SOAP_IO_LENGTH)

	test	BYTE PTR [esi+8], 8
	je	SHORT $LN3@soap_send_@3

; 14433:     { soap_envelope_begin_out(soap);

	mov	eax, esi
	call	_soap_envelope_begin_out

; 14434:       soap_putheader(soap);

	call	_soap_putheader

; 14435:       soap_body_begin_out(soap);

	mov	eax, esi
	call	_soap_body_begin_out

; 14436:       soap_putfault(soap);

	call	_soap_putfault

; 14437:       soap_body_end_out(soap);

	mov	edi, esi
	call	_soap_body_end_out

; 14438:       soap_envelope_end_out(soap);

	call	_soap_envelope_end_out
$LN3@soap_send_@3:

; 14439:     }
; 14440:     soap_end_count(soap);

	mov	eax, DWORD PTR [esi+12352]
	test	eax, eax
	je	SHORT $LN24@soap_send_@3
	push	esi
	call	eax
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax
$LN24@soap_send_@3:

; 14441:     if (soap_response(soap, status)
; 14442:      || soap_envelope_begin_out(soap)
; 14443:      || soap_putheader(soap)
; 14444:      || soap_body_begin_out(soap)
; 14445:      || soap_putfault(soap)
; 14446:      || soap_body_end_out(soap)
; 14447:      || soap_envelope_end_out(soap))

	push	ebx
	mov	eax, esi
	call	_soap_response
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_send_@3
	mov	eax, esi
	call	_soap_envelope_begin_out
	test	eax, eax
	jne	SHORT $LN1@soap_send_@3
	call	_soap_putheader
	test	eax, eax
	jne	SHORT $LN1@soap_send_@3
	mov	eax, esi
	call	_soap_body_begin_out
	test	eax, eax
	jne	SHORT $LN1@soap_send_@3
	call	_soap_putfault
	test	eax, eax
	jne	SHORT $LN1@soap_send_@3
	mov	edi, esi
	call	_soap_body_end_out
	test	eax, eax
	jne	SHORT $LN1@soap_send_@3
	call	_soap_envelope_end_out
	test	eax, eax
	jne	SHORT $LN1@soap_send_@3

; 14448:       return soap_closesock(soap);
; 14449:     soap_end_send(soap);

	mov	eax, esi
	call	_soap_end_send
$LN5@soap_send_@3:

; 14450:   }
; 14451:   soap->error = status;

	mov	DWORD PTR [esi+90460], ebx
$LN1@soap_send_@3:

; 14452:   return soap_closesock(soap);

	call	_soap_closesock
	pop	edi
	pop	esi
	pop	ebx

; 14453: }

	add	esp, 532				; 00000214H
	ret	0
_soap_send_fault ENDP
_TEXT	ENDS
PUBLIC	_soap_begin_recv
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_begin_recv PROC
; _soap$ = eax

; 12684: { soap_wchar c;

	push	ebx
	push	esi
	mov	esi, eax

; 12685:   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Initializing for input\n"));
; 12686:   soap->error = SOAP_OK;

	xor	ebx, ebx
	push	edi
	mov	DWORD PTR [esi+90460], ebx

; 12687:   soap_free_temp(soap);

	call	_soap_free_temp

; 12688:   soap_set_local_namespaces(soap);

	push	esi
	call	_soap_set_local_namespaces

; 12689:   soap->version = 0;	/* don't assume we're parsing SOAP content by default */

	xor	eax, eax

; 12690: #ifndef WITH_NOIDREF
; 12691:   soap_free_iht(soap);

	push	esi
	mov	WORD PTR [esi+6], ax
	call	_soap_free_iht

; 12692: #endif
; 12693:   if ((soap->imode & SOAP_IO) == SOAP_IO_CHUNK)

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, eax
	and	ecx, 3
	add	esp, 8
	cmp	cl, 3
	jne	SHORT $LN37@soap_begin@4

; 12694:     soap->omode |= SOAP_IO_CHUNK;

	or	DWORD PTR [esi+16], 3
$LN37@soap_begin@4:

; 12695:   soap->imode &= ~SOAP_IO;

	and	eax, -4					; fffffffcH
	mov	DWORD PTR [esi+12], eax

; 12696:   soap->mode = soap->imode;

	mov	DWORD PTR [esi+8], eax

; 12697:   if (!soap->keep_alive)

	cmp	WORD PTR [esi+90412], bx
	jne	SHORT $LN36@soap_begin@4

; 12698:   { soap->buflen = 0;

	mov	DWORD PTR [esi+12432], ebx

; 12699:     soap->bufidx = 0;

	mov	DWORD PTR [esi+12428], ebx
$LN36@soap_begin@4:

; 12700:   }
; 12701:   if (!(soap->mode & SOAP_IO_KEEPALIVE))

	test	al, 16					; 00000010H
	jne	SHORT $LN35@soap_begin@4

; 12702:     soap->keep_alive = 0;

	xor	edx, edx
	mov	WORD PTR [esi+90412], dx
$LN35@soap_begin@4:

; 12703:   soap->ahead = 0;
; 12704:   soap->peeked = 0;

	xor	eax, eax

; 12705:   soap->level = 0;
; 12706:   soap->part = SOAP_BEGIN;

	xor	ecx, ecx

; 12707:   soap->alloced = 0;

	xor	edx, edx

; 12708:   soap->count = 0;
; 12709:   soap->length = 0;
; 12710:   soap->cdata = 0;
; 12711:   *soap->endpoint = '\0';
; 12712:   soap->action = NULL;
; 12713:   soap->header = NULL;
; 12714:   soap->fault = NULL;
; 12715:   soap->status = 0;
; 12716: #ifndef WITH_LEANER
; 12717:   soap->dom = NULL;
; 12718:   soap->dime.chunksize = 0;
; 12719:   soap->dime.buflen = 0;
; 12720:   soap->dime.list = NULL;
; 12721:   soap->dime.first = NULL;
; 12722:   soap->dime.last = NULL;
; 12723:   soap->mime.list = NULL;
; 12724:   soap->mime.first = NULL;
; 12725:   soap->mime.last = NULL;
; 12726:   soap->mime.boundary = NULL;
; 12727:   soap->mime.start = NULL;
; 12728:   soap->xlist = NULL;
; 12729: #endif
; 12730: #ifdef WIN32
; 12731: #ifndef UNDER_CE
; 12732: #ifndef WITH_FASTCGI
; 12733:   if (!soap_valid_socket(soap->socket))

	cmp	DWORD PTR [esi+12408], -1
	mov	DWORD PTR [esi+12436], ebx
	mov	WORD PTR [esi+87308], ax
	mov	DWORD PTR [esi+12444], ebx
	mov	WORD PTR [esi+87304], cx
	mov	WORD PTR [esi+87306], dx
	mov	DWORD PTR [esi+12448], ebx
	mov	DWORD PTR [esi+12452], ebx
	mov	WORD PTR [esi+12440], ax
	mov	BYTE PTR [esi+87320], bl
	mov	DWORD PTR [esi+90392], ebx
	mov	DWORD PTR [esi+12204], ebx
	mov	DWORD PTR [esi+12208], ebx
	mov	DWORD PTR [esi+90456], ebx
	mov	DWORD PTR [esi+90472], ebx
	mov	DWORD PTR [esi+90484], ebx
	mov	DWORD PTR [esi+90488], ebx
	mov	DWORD PTR [esi+90512], ebx
	mov	DWORD PTR [esi+90516], ebx
	mov	DWORD PTR [esi+90520], ebx
	mov	DWORD PTR [esi+90532], ebx
	mov	DWORD PTR [esi+90536], ebx
	mov	DWORD PTR [esi+90540], ebx
	mov	DWORD PTR [esi+90524], ebx
	mov	DWORD PTR [esi+90528], ebx
	mov	DWORD PTR [esi+90544], ebx
	jne	SHORT $LN34@soap_begin@4

; 12734: #ifdef __BORLANDC__
; 12735:     setmode(soap->recvfd, O_BINARY);
; 12736: #else
; 12737:     _setmode(soap->recvfd, _O_BINARY);

	mov	ecx, DWORD PTR [esi+12424]
	push	32768					; 00008000H
	push	ecx
	call	__setmode
	add	esp, 8
$LN34@soap_begin@4:

; 12738: #endif
; 12739: #endif
; 12740: #endif
; 12741: #endif
; 12742: #ifdef WITH_ZLIB
; 12743:   soap->mode &= ~SOAP_ENC_ZLIB;
; 12744:   soap->zlib_in = SOAP_ZLIB_NONE;
; 12745:   soap->zlib_out = SOAP_ZLIB_NONE;
; 12746:   soap->d_stream->next_in = Z_NULL;
; 12747:   soap->d_stream->avail_in = 0;
; 12748:   soap->d_stream->next_out = (Byte*)soap->buf;
; 12749:   soap->d_stream->avail_out = SOAP_BUFLEN;
; 12750:   soap->z_ratio_in = 1.0;
; 12751: #endif
; 12752: #ifndef WITH_LEANER
; 12753:   if (soap->fprepareinit)

	mov	eax, DWORD PTR [esi+12340]
	cmp	eax, ebx
	je	SHORT $LN33@soap_begin@4

; 12754:     soap->fprepareinit(soap);

	push	esi
	call	eax
	add	esp, 4
$LN33@soap_begin@4:

; 12755: #endif
; 12756:   c = soap_getchar(soap);

	mov	edi, DWORD PTR [esi+12436]
	cmp	edi, ebx
	je	SHORT $LN47@soap_begin@4
	cmp	edi, -1
	je	SHORT $LN51@soap_begin@4
	mov	DWORD PTR [esi+12436], ebx
	jmp	SHORT $LN51@soap_begin@4
$LN47@soap_begin@4:
	mov	edx, DWORD PTR [esi+12428]
	cmp	edx, DWORD PTR [esi+12432]
	jb	SHORT $LN50@soap_begin@4
	call	_soap_recv
	test	eax, eax
	je	SHORT $LN50@soap_begin@4
	or	edi, -1
$LN32@soap_begin@4:

; 12785:   else if ((c & 0xFFFC) == (SOAP_DIME_VERSION | SOAP_DIME_MB) && (soap_get0(soap) & 0xFFF0) == 0x20)

	mov	edx, edi
	and	edx, 65532				; 0000fffcH
	cmp	edx, 12					; 0000000cH
	jne	$LN65@soap_begin@4
	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	$LN42@soap_begin@4
	call	_soap_recv
	test	eax, eax
	je	$LN42@soap_begin@4
	or	eax, -1
	jmp	$LN43@soap_begin@4

; 12755: #endif
; 12756:   c = soap_getchar(soap);

$LN50@soap_begin@4:
	mov	eax, DWORD PTR [esi+12428]
	movzx	edi, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
$LN51@soap_begin@4:

; 12757: #ifdef WITH_GZIP
; 12758:   if (c == 0x1F)
; 12759:   { if (soap_getgziphdr(soap))
; 12760:       return soap->error;
; 12761:     if (inflateInit2(soap->d_stream, -MAX_WBITS) != Z_OK)
; 12762:       return soap->error = SOAP_ZLIB_ERROR;
; 12763:     soap->zlib_state = SOAP_ZLIB_INFLATE;
; 12764:     soap->mode |= SOAP_ENC_ZLIB;
; 12765:     soap->zlib_in = SOAP_ZLIB_GZIP;
; 12766:     soap->z_crc = crc32(0L, NULL, 0);
; 12767:     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "gzip initialized\n"));
; 12768:     if (!soap->z_buf)
; 12769:       soap->z_buf = (char*)SOAP_MALLOC(soap, SOAP_BUFLEN);
; 12770:     memcpy(soap->z_buf, soap->buf, SOAP_BUFLEN);
; 12771:     /* should not chunk over plain transport, so why bother to check? */
; 12772:     /* if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK) */
; 12773:     /*   soap->z_buflen = soap->bufidx; */
; 12774:     /* else */
; 12775:     soap->d_stream->next_in = (Byte*)(soap->z_buf + soap->bufidx);
; 12776:     soap->d_stream->avail_in = soap->buflen - soap->bufidx;
; 12777:     soap->z_buflen = soap->buflen;
; 12778:     soap->buflen = soap->bufidx;
; 12779:     c = soap_getchar(soap);
; 12780:   }
; 12781: #endif
; 12782: #ifndef WITH_LEANER
; 12783:   if (c == '-' && soap_get0(soap) == '-')

	cmp	edi, 45					; 0000002dH
	jne	SHORT $LN32@soap_begin@4
	mov	eax, DWORD PTR [esi+12428]
	cmp	eax, DWORD PTR [esi+12432]
	jb	SHORT $LN40@soap_begin@4
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN32@soap_begin@4
$LN40@soap_begin@4:
	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN32@soap_begin@4

; 12784:     soap->mode |= SOAP_ENC_MIME;

	or	DWORD PTR [esi+8], 256			; 00000100H
$LN66@soap_begin@4:

; 12794:   soap_unget(soap, c);

	mov	DWORD PTR [esi+12436], edi

; 12795: #ifndef WITH_NOHTTP
; 12796:   /* if not XML or (start of)BOM or MIME/DIME/ZLIB, assume HTTP header */
; 12797:   if (c != '<' && c != 0xEF && !(soap->mode & (SOAP_ENC_MIME | SOAP_ENC_DIME | SOAP_ENC_ZLIB)))

	cmp	edi, 60					; 0000003cH
	je	$LN67@soap_begin@4
	cmp	edi, 239				; 000000efH
	je	$LN67@soap_begin@4
	mov	eax, DWORD PTR [esi+8]
	test	eax, 1408				; 00000580H
	jne	$LN67@soap_begin@4

; 12798:   { soap->mode &= ~SOAP_IO;

	and	eax, -4					; fffffffcH
	mov	DWORD PTR [esi+8], eax

; 12799:     soap->error = soap->fparse(soap);

	mov	eax, DWORD PTR [esi+12264]
	push	esi
	call	eax
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax

; 12800:     if (soap->error && soap->error < SOAP_STOP)

	cmp	eax, ebx
	je	$LN24@soap_begin@4
	cmp	eax, 1000				; 000003e8H
	jge	$LN68@soap_begin@4

; 12801:     { soap->keep_alive = 0; /* force close later */

	xor	ecx, ecx
	pop	edi
	mov	WORD PTR [esi+90412], cx
	pop	esi
	pop	ebx

; 12900: }

	ret	0
$LN42@soap_begin@4:

; 12785:   else if ((c & 0xFFFC) == (SOAP_DIME_VERSION | SOAP_DIME_MB) && (soap_get0(soap) & 0xFFF0) == 0x20)

	mov	ecx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [ecx+esi+12468]
$LN43@soap_begin@4:
	and	eax, 65520				; 0000fff0H
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN65@soap_begin@4

; 12786:     soap->mode |= SOAP_ENC_DIME;

	or	DWORD PTR [esi+8], 128			; 00000080H

; 12787:   else

	jmp	SHORT $LN27@soap_begin@4
$LN65@soap_begin@4:

; 12788: #endif
; 12789:   { while (soap_blank(c))

	cmp	edi, ebx
	jl	SHORT $LN27@soap_begin@4
	npad	6
$LL28@soap_begin@4:
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN27@soap_begin@4

; 12790:       c = soap_getchar(soap);

	mov	edi, DWORD PTR [esi+12436]
	cmp	edi, ebx
	je	SHORT $LN53@soap_begin@4
	cmp	edi, -1
	je	SHORT $LN57@soap_begin@4
	mov	DWORD PTR [esi+12436], ebx
	jmp	SHORT $LN57@soap_begin@4
$LN53@soap_begin@4:
	mov	edx, DWORD PTR [esi+12428]
	cmp	edx, DWORD PTR [esi+12432]
	jb	SHORT $LN56@soap_begin@4
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN62@soap_begin@4
$LN56@soap_begin@4:
	mov	eax, DWORD PTR [esi+12428]
	movzx	edi, BYTE PTR [eax+esi+12468]
	inc	eax
	mov	DWORD PTR [esi+12428], eax
$LN57@soap_begin@4:

; 12788: #endif
; 12789:   { while (soap_blank(c))

	cmp	edi, ebx
	jge	SHORT $LL28@soap_begin@4
$LN27@soap_begin@4:

; 12791:   }
; 12792:   if ((int)c == EOF)

	cmp	edi, -1
	jne	$LN66@soap_begin@4
$LN62@soap_begin@4:
	pop	edi

; 12793:     return soap->error = SOAP_EOF;

	mov	DWORD PTR [esi+90460], -1
	pop	esi
	or	eax, -1
	pop	ebx

; 12900: }

	ret	0
$LN24@soap_begin@4:

; 12802:       return soap->error;
; 12803:     }
; 12804:     if (soap->error == SOAP_STOP)

	cmp	eax, 1000				; 000003e8H
$LN68@soap_begin@4:
	jne	SHORT $LN23@soap_begin@4
	pop	edi
	pop	esi

; 12805:       return soap->error;

	mov	eax, 1000				; 000003e8H
	pop	ebx

; 12900: }

	ret	0
$LN23@soap_begin@4:

; 12806:     if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK)

	mov	edx, DWORD PTR [esi+8]
	and	edx, 3
	cmp	dl, 3
	jne	SHORT $LN22@soap_begin@4

; 12807:     { soap->chunkbuflen = soap->buflen;

	mov	eax, DWORD PTR [esi+12432]

; 12808:       soap->buflen = soap->bufidx;

	mov	ecx, DWORD PTR [esi+12428]
	mov	DWORD PTR [esi+87316], eax
	mov	DWORD PTR [esi+12432], ecx

; 12809:       soap->chunksize = 0;

	mov	DWORD PTR [esi+87312], ebx
	jmp	SHORT $LN20@soap_begin@4
$LN22@soap_begin@4:

; 12810:     }
; 12811: #ifndef WITH_LEANER
; 12812:     else if (soap->fpreparerecv && soap->buflen != soap->bufidx)

	mov	edx, DWORD PTR [esi+12348]
	cmp	edx, ebx
	je	SHORT $LN20@soap_begin@4
	mov	eax, DWORD PTR [esi+12432]
	mov	ecx, DWORD PTR [esi+12428]
	cmp	eax, ecx
	je	SHORT $LN20@soap_begin@4

; 12813:       soap->fpreparerecv(soap, soap->buf + soap->bufidx, soap->buflen - soap->bufidx);

	sub	eax, ecx
	push	eax
	lea	eax, DWORD PTR [ecx+esi+12468]
	push	eax
	push	esi
	call	edx
	add	esp, 12					; 0000000cH
$LN20@soap_begin@4:

; 12814: #endif
; 12815:     /* Note: fparse should not use soap_unget to push back last char */
; 12816:     if (soap_get0(soap) == (int)EOF)

	mov	ecx, DWORD PTR [esi+12428]
	cmp	ecx, DWORD PTR [esi+12432]
	jb	SHORT $LN44@soap_begin@4
	call	_soap_recv
	test	eax, eax
	jne	SHORT $LN63@soap_begin@4
$LN44@soap_begin@4:
	mov	edx, DWORD PTR [esi+12428]
	movzx	eax, BYTE PTR [edx+esi+12468]
	cmp	eax, -1
	jne	SHORT $LN19@soap_begin@4
$LN63@soap_begin@4:

; 12817:     { if (soap->status == 200)

	mov	eax, DWORD PTR [esi+90456]
	cmp	eax, 200				; 000000c8H
	jne	SHORT $LN18@soap_begin@4

; 12818:         return soap->error = SOAP_NO_DATA;

	mov	eax, 14					; 0000000eH
$LN18@soap_begin@4:
	pop	edi
	mov	DWORD PTR [esi+90460], eax
	pop	esi
	pop	ebx

; 12900: }

	ret	0
$LN19@soap_begin@4:

; 12819:       return soap->error = soap->status;
; 12820:     }
; 12821: #ifdef WITH_ZLIB
; 12822:     if (soap->zlib_in != SOAP_ZLIB_NONE)
; 12823:     {
; 12824: #ifdef WITH_GZIP
; 12825:       if (soap->zlib_in != SOAP_ZLIB_DEFLATE)
; 12826:       { c = soap_get1(soap);
; 12827:         if (c == 0x1F)
; 12828:         { if (soap_getgziphdr(soap))
; 12829:             return soap->error;
; 12830:           if (inflateInit2(soap->d_stream, -MAX_WBITS) != Z_OK)
; 12831:             return soap->error = SOAP_ZLIB_ERROR;
; 12832:           soap->z_crc = crc32(0L, NULL, 0);
; 12833:           DBGLOG(TEST, SOAP_MESSAGE(fdebug, "gzip initialized\n"));
; 12834:         }
; 12835:         else
; 12836:         { soap_revget1(soap);
; 12837:           if (inflateInit(soap->d_stream) != Z_OK)
; 12838:             return soap->error = SOAP_ZLIB_ERROR;
; 12839:           soap->zlib_in = SOAP_ZLIB_DEFLATE;
; 12840:         }
; 12841:       }
; 12842:       else
; 12843: #endif
; 12844:       if (inflateInit(soap->d_stream) != Z_OK)
; 12845:         return soap->error = SOAP_ZLIB_ERROR;
; 12846:       soap->zlib_state = SOAP_ZLIB_INFLATE;
; 12847:       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Inflate initialized\n"));
; 12848:       soap->mode |= SOAP_ENC_ZLIB;
; 12849:       if (!soap->z_buf)
; 12850:         soap->z_buf = (char*)SOAP_MALLOC(soap, SOAP_BUFLEN);
; 12851:       memcpy(soap->z_buf, soap->buf, SOAP_BUFLEN);
; 12852:       soap->d_stream->next_in = (Byte*)(soap->z_buf + soap->bufidx);
; 12853:       soap->d_stream->avail_in = soap->buflen - soap->bufidx;
; 12854:       soap->z_buflen = soap->buflen;
; 12855:       soap->buflen = soap->bufidx;
; 12856:     }
; 12857: #endif
; 12858:     if (soap->error)

	mov	eax, DWORD PTR [esi+90460]
	cmp	eax, ebx
	je	SHORT $LN67@soap_begin@4

; 12859:     { if (soap->error == SOAP_FORM && soap->fform)

	cmp	eax, 1001				; 000003e9H
	jne	SHORT $LN15@soap_begin@4
	mov	eax, DWORD PTR [esi+12252]
	cmp	eax, ebx
	je	SHORT $LN15@soap_begin@4

; 12860:       { soap->error = soap->fform(soap);

	push	esi
	call	eax
	add	esp, 4
	mov	DWORD PTR [esi+90460], eax

; 12861:         if (soap->error == SOAP_OK)

	cmp	eax, ebx
	jne	SHORT $LN15@soap_begin@4

; 12862:           soap->error = SOAP_STOP; /* prevents further processing */

	mov	DWORD PTR [esi+90460], 1000		; 000003e8H
$LN15@soap_begin@4:

; 12863:       }
; 12864:       return soap->error;

	mov	eax, DWORD PTR [esi+90460]
	pop	edi
	pop	esi
	pop	ebx

; 12900: }

	ret	0
$LN67@soap_begin@4:

; 12865:     }
; 12866:   }
; 12867: #endif
; 12868: #ifndef WITH_LEANER
; 12869:   if (soap->mode & SOAP_ENC_MIME)

	test	DWORD PTR [esi+8], 256			; 00000100H
	je	SHORT $LN6@soap_begin@4

; 12870:   { if (soap_getmimehdr(soap))

	call	_soap_getmimehdr
	test	eax, eax

; 12871:       return soap->error;

	jne	SHORT $LN15@soap_begin@4

; 12872:     if (soap->mime.start)

	cmp	DWORD PTR [esi+90528], ebx
	je	SHORT $LN9@soap_begin@4
	npad	5
$LL11@soap_begin@4:

; 12873:     { do
; 12874:       { if (!soap->mime.last->id)

	mov	eax, DWORD PTR [esi+90540]
	mov	eax, DWORD PTR [eax+12]
	cmp	eax, ebx
	je	SHORT $LN9@soap_begin@4

; 12875:           break;
; 12876:         if (!soap_match_cid(soap, soap->mime.start, soap->mime.last->id))

	mov	ecx, DWORD PTR [esi+90528]
	push	eax
	push	ecx
	push	esi
	call	_soap_match_cid
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@soap_begin@4

; 12877:           break;
; 12878:       } while (soap_get_mime_attachment(soap, NULL));

	push	ebx
	push	esi
	call	_soap_get_mime_attachment
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL11@soap_begin@4
$LN9@soap_begin@4:

; 12879:     }
; 12880:     if (soap_get_header_attribute(soap, soap->mime.first->type, "application/dime"))

	mov	edx, DWORD PTR [esi+90536]
	mov	eax, DWORD PTR [edx+16]
	push	OFFSET ??_C@_0BB@KDHCEMMM@application?1dime?$AA@
	mov	ecx, esi
	call	_soap_get_header_attribute
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@soap_begin@4

; 12881:       soap->mode |= SOAP_ENC_DIME;

	or	DWORD PTR [esi+8], 128			; 00000080H
$LN6@soap_begin@4:

; 12882:   }
; 12883:   if (soap->mode & SOAP_ENC_DIME)

	test	BYTE PTR [esi+8], -128			; ffffff80H
	je	SHORT $LN5@soap_begin@4

; 12884:   { if (soap_getdimehdr(soap))

	call	_soap_getdimehdr
	test	eax, eax

; 12885:       return soap->error;

	jne	$LN15@soap_begin@4

; 12886:     if (soap->dime.flags & SOAP_DIME_CF)

	test	BYTE PTR [esi+90492], 1
	je	SHORT $LN1@soap_begin@4

; 12887:     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Chunked DIME SOAP message\n"));
; 12888:       soap->dime.chunksize = soap->dime.size;
; 12889:       if (soap->buflen - soap->bufidx >= soap->dime.chunksize)

	mov	ecx, DWORD PTR [esi+12432]
	mov	edx, DWORD PTR [esi+12428]
	mov	eax, DWORD PTR [esi+90480]
	mov	edi, ecx
	sub	edi, edx
	mov	DWORD PTR [esi+90484], eax
	cmp	edi, eax
	jb	SHORT $LN2@soap_begin@4

; 12890:       { soap->dime.buflen = soap->buflen;
; 12891:         soap->buflen = soap->bufidx + soap->dime.chunksize;

	add	eax, edx
	mov	DWORD PTR [esi+90488], ecx
	mov	DWORD PTR [esi+12432], eax

; 12892:       }
; 12893:       else

	jmp	SHORT $LN1@soap_begin@4
$LN2@soap_begin@4:

; 12894:         soap->dime.chunksize -= soap->buflen - soap->bufidx;

	sub	eax, ecx
	add	eax, edx
	mov	DWORD PTR [esi+90484], eax
$LN1@soap_begin@4:

; 12895:     }
; 12896:     soap->count = soap->buflen - soap->bufidx;

	mov	eax, DWORD PTR [esi+12432]
	sub	eax, DWORD PTR [esi+12428]
	mov	DWORD PTR [esi+12448], eax
$LN5@soap_begin@4:
	pop	edi
	pop	esi

; 12897:   }
; 12898: #endif
; 12899:   return SOAP_OK;

	xor	eax, eax
	pop	ebx

; 12900: }

	ret	0
_soap_begin_recv ENDP
_TEXT	ENDS
PUBLIC	_soap_init2
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_imode$ = 8						; size = 4
_soap_init2 PROC
; _soap$ = esi
; _omode$ = edi

; 6669 : { soap_init(soap);

	mov	edx, esi
	call	_soap_init

; 6670 :   soap_imode(soap, imode);

	mov	eax, DWORD PTR _imode$[esp-4]
	mov	DWORD PTR [esi+12], eax

; 6671 :   soap_omode(soap, omode);

	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+8], edi

; 6672 : }

	ret	0
_soap_init2 ENDP
_TEXT	ENDS
PUBLIC	_soap_init1
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_init1 PROC
; _soap$ = esi
; _mode$ = edi

; 6659 : { soap_init2(soap, mode, mode);

	mov	edx, esi
	call	_soap_init
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+8], edi

; 6660 : }

	ret	0
_soap_init1 ENDP
_TEXT	ENDS
PUBLIC	_soap_free
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_free PROC
; _soap$ = esi

; 4732 : { soap_done(soap);

	mov	eax, esi
	call	_soap_done

; 4733 :   free(soap);

	push	esi
	call	_free
	pop	ecx

; 4734 : }

	ret	0
_soap_free ENDP
_TEXT	ENDS
PUBLIC	_soap_new2
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_imode$ = 8						; size = 4
_soap_new2 PROC
; _omode$ = edi

; 4719 : { struct soap *soap = (struct soap*)malloc(sizeof(struct soap));

	push	esi
	push	95832					; 00017658H
	call	_malloc
	mov	esi, eax
	add	esp, 4

; 4720 :   if (soap)

	test	esi, esi
	je	SHORT $LN4@soap_new2

; 4721 :     soap_init2(soap, imode, omode);

	mov	edx, esi
	call	_soap_init
	mov	eax, DWORD PTR _imode$[esp]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+8], edi

; 4722 :   return soap;

	mov	eax, esi
$LN4@soap_new2:
	pop	esi

; 4723 : }

	ret	0
_soap_new2 ENDP
_TEXT	ENDS
PUBLIC	_soap_new
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_new PROC

; 4709 : { return soap_new2(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);

	push	esi
	push	95832					; 00017658H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN6@soap_new
	mov	edx, esi
	call	_soap_init
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+8], 0
	mov	eax, esi
$LN6@soap_new:
	pop	esi

; 4710 : }

	ret	0
_soap_new ENDP
_TEXT	ENDS
PUBLIC	_soap_new1
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_new1 PROC
; _mode$ = edi

; 4699 : { return soap_new2(mode, mode);

	push	esi
	push	95832					; 00017658H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN6@soap_new1
	mov	edx, esi
	call	_soap_init
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+8], edi
	mov	eax, esi
$LN6@soap_new1:
	pop	esi

; 4700 : }

	ret	0
_soap_new1 ENDP
_TEXT	ENDS
PUBLIC	_soap_cleanup
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_cleanup PROC
; _soap$ = eax

; 3425 : { soap_done(soap);

	call	_soap_done

; 3426 : #ifdef WIN32
; 3427 :   if (!tcp_done)

	cmp	DWORD PTR _tcp_done, 0
	je	SHORT $LN2@soap_clean

; 3428 :     return;
; 3429 :   tcp_done = 0;

	mov	DWORD PTR _tcp_done, 0

; 3430 :   WSACleanup();

	jmp	_WSACleanup@0
$LN2@soap_clean:

; 3431 : #endif
; 3432 : }

	ret	0
_soap_cleanup ENDP
PUBLIC	??0soap@@QAE@HH@Z				; soap::soap
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_im$ = 8						; size = 4
??0soap@@QAE@HH@Z PROC					; soap::soap
; _this$ = esi
; _om$ = edi

; 14870: { soap_init2(this, im, om);

	mov	edx, esi
	mov	DWORD PTR [esi], OFFSET ??_7soap@@6B@
	call	_soap_init
	mov	eax, DWORD PTR _im$[esp-4]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+8], edi

; 14871: }

	mov	eax, esi
	ret	4
??0soap@@QAE@HH@Z ENDP					; soap::soap
_TEXT	ENDS
PUBLIC	??0soap@@QAE@H@Z				; soap::soap
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
??0soap@@QAE@H@Z PROC					; soap::soap
; _this$ = esi
; _m$ = edi

; 14863: { soap_init1(this, m);

	mov	edx, esi
	mov	DWORD PTR [esi], OFFSET ??_7soap@@6B@
	call	_soap_init
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+8], edi

; 14864: }

	mov	eax, esi
	ret	0
??0soap@@QAE@H@Z ENDP					; soap::soap
_TEXT	ENDS
PUBLIC	_soap_recv_empty_response
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_recv_empty_response PROC
; _soap$ = eax

; 14525: { if (soap_begin_recv(soap) || soap_end_recv(soap))

	push	esi
	mov	esi, eax
	call	_soap_begin_recv
	test	eax, eax
	jne	SHORT $LN2@soap_recv_@3
	mov	eax, esi
	call	_soap_end_recv
	test	eax, eax
	je	SHORT $LN3@soap_recv_@3
$LN2@soap_recv_@3:

; 14526:   { if (soap->error != 202)

	cmp	DWORD PTR [esi+90460], 202		; 000000caH
	je	SHORT $LN1@soap_recv_@3

; 14527:       return soap_closesock(soap);

	call	_soap_closesock
	pop	esi

; 14531: }

	ret	0
$LN1@soap_recv_@3:

; 14528:     soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0
$LN3@soap_recv_@3:

; 14529:   }
; 14530:   return SOAP_OK;

	xor	eax, eax
	pop	esi

; 14531: }

	ret	0
_soap_recv_empty_response ENDP
PUBLIC	_soap_recv_fault
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_soap_recv_fault PROC
; _soap$ = eax

; 14462: { register int status = soap->error;

	push	ebx
	push	esi
	mov	esi, eax
	mov	ebx, DWORD PTR [esi+90460]
	push	edi

; 14463:   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Receiving SOAP Fault\n"));
; 14464:   soap->error = SOAP_OK;

	mov	DWORD PTR [esi+90460], 0

; 14465:   if (soap_getfault(soap))

	call	?soap_in_SOAP_ENV__Fault@@YAPAUSOAP_ENV__Fault@@PAUsoap@@PBDPAU1@1@Z ; soap_in_SOAP_ENV__Fault
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN21@soap_recv_@4
	call	?soap_getindependent@@YAHPAUsoap@@@Z	; soap_getindependent
	test	eax, eax
	je	SHORT $LN21@soap_recv_@4
	xor	eax, eax
	jmp	SHORT $LN23@soap_recv_@4
$LN21@soap_recv_@4:
	mov	eax, edi
$LN23@soap_recv_@4:
	mov	DWORD PTR [esi+12208], eax
	test	eax, eax
	jne	SHORT $LN14@soap_recv_@4

; 14466:   { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Error: soap_get_soapfault() failed. Is this a SOAP message at all?\n"));
; 14467:     *soap_faultcode(soap) = (soap->version == 2 ? "SOAP-ENV:Sender" : "SOAP-ENV:Client");

	cmp	WORD PTR [esi+6], 2
	mov	edi, OFFSET ??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@
	je	SHORT $LN18@soap_recv_@4
	mov	edi, OFFSET ??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@
$LN18@soap_recv_@4:
	mov	eax, esi
	call	_soap_fault
	cmp	WORD PTR [esi+6], 2
	mov	eax, DWORD PTR [esi+12208]
	jne	SHORT $LN26@soap_recv_@4
	mov	eax, DWORD PTR [eax+16]
$LN26@soap_recv_@4:
	mov	DWORD PTR [eax], edi

; 14468:     soap->error = status;
; 14469:     soap_set_fault(soap);

	mov	eax, esi
	mov	DWORD PTR [esi+90460], ebx
	call	_soap_set_fault

; 14488:       return soap_closesock(soap);

	call	_soap_closesock

; 14490:   }
; 14491:   return soap_closesock(soap);
; 14492: }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
$LN14@soap_recv_@4:

; 14470:   }
; 14471:   else
; 14472:   { register const char *s = *soap_faultcode(soap);

	mov	eax, esi
	call	_soap_fault
	cmp	WORD PTR [esi+6], 2
	jne	SHORT $LN28@soap_recv_@4
	mov	ecx, DWORD PTR [esi+12208]
	mov	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN29@soap_recv_@4
$LN28@soap_recv_@4:
	mov	eax, DWORD PTR [esi+12208]
$LN29@soap_recv_@4:
	mov	ebx, DWORD PTR [eax]

; 14473:     if (!soap_match_tag(soap, s, "SOAP-ENV:Server") || !soap_match_tag(soap, s, "SOAP-ENV:Receiver"))

	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BA@NJHKENFI@SOAP?9ENV?3Server?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@soap_recv_@4
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BC@DABIKIOO@SOAP?9ENV?3Receiver?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@soap_recv_@4

; 14475:     else if (!soap_match_tag(soap, s, "SOAP-ENV:Client") || !soap_match_tag(soap, s, "SOAP-ENV:Sender"))

	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BA@JGDIJGNL@SOAP?9ENV?3Client?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@soap_recv_@4
	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BA@IGHKKIMP@SOAP?9ENV?3Sender?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@soap_recv_@4

; 14477:     else if (!soap_match_tag(soap, s, "SOAP-ENV:MustUnderstand"))

	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BI@MFGAEHIJ@SOAP?9ENV?3MustUnderstand?$AA@
	call	_soap_match_tag
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@soap_recv_@4

; 14478:       status = SOAP_MUSTUNDERSTAND;

	lea	edi, DWORD PTR [eax+8]
	jmp	SHORT $LN3@soap_recv_@4
$LN6@soap_recv_@4:

; 14479:     else if (!soap_match_tag(soap, s, "SOAP-ENV:VersionMismatch"))

	push	ebx
	push	esi
	mov	edi, OFFSET ??_C@_0BJ@OACCBMEJ@SOAP?9ENV?3VersionMismatch?$AA@
	call	_soap_match_tag
	add	esp, 8
	mov	edi, eax
	neg	edi
	sbb	edi, edi
	and	edi, -27				; ffffffe5H
	add	edi, 39					; 00000027H

; 14480:       status = SOAP_VERSIONMISMATCH;
; 14481:     else
; 14482:     { DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Fault code %s\n", s));
; 14483:       status = SOAP_FAULT;

	jmp	SHORT $LN3@soap_recv_@4
$LN8@soap_recv_@4:

; 14476:       status = SOAP_CLI_FAULT;

	mov	edi, 1
	jmp	SHORT $LN3@soap_recv_@4
$LN11@soap_recv_@4:

; 14474:       status = SOAP_SVR_FAULT;

	mov	edi, 2
$LN3@soap_recv_@4:

; 14484:     }
; 14485:     if (soap_body_end_in(soap)
; 14486:      || soap_envelope_end_in(soap)
; 14487:      || soap_end_recv(soap))

	cmp	WORD PTR [esi+87304], 5
	je	SHORT $LN36@soap_recv_@4
	mov	edx, 7
	push	OFFSET ??_C@_0O@DLKLKBNF@SOAP?9ENV?3Body?$AA@
	mov	WORD PTR [esi+87304], dx
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_recv_@4
$LN36@soap_recv_@4:
	mov	eax, 8
	push	OFFSET ??_C@_0BC@GKKKFKAB@SOAP?9ENV?3Envelope?$AA@
	mov	WORD PTR [esi+87304], ax
	call	_soap_element_end_in
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@soap_recv_@4
	mov	eax, esi
	call	_soap_end_recv
	test	eax, eax
	jne	SHORT $LN1@soap_recv_@4

; 14489:     soap->error = status;

	mov	DWORD PTR [esi+90460], edi
$LN1@soap_recv_@4:

; 14488:       return soap_closesock(soap);

	call	_soap_closesock

; 14490:   }
; 14491:   return soap_closesock(soap);
; 14492: }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
_soap_recv_fault ENDP
END
