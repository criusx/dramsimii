; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\CriuS\Documents\Visual Studio 2008\Projects\DRAMsimIIhg\src\TimingSpecification.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CP@FEOJHBG@tAL?5must?5be?5?$DM?$DN?5tRCD?5to?5ensure?5pr@ ; `string'
PUBLIC	??_C@_0BK@FAIBNGFG@DRDRAM?5not?5yet?5supported?4?$AA@ ; `string'
PUBLIC	??_C@_05MKELIOBI@rtrs?$FL?$AA@			; `string'
;	COMDAT ??_C@_05MKELIOBI@rtrs?$FL?$AA@
CONST	SEGMENT
??_C@_05MKELIOBI@rtrs?$FL?$AA@ DB 'rtrs[', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FAIBNGFG@DRDRAM?5not?5yet?5supported?4?$AA@
CONST	SEGMENT
??_C@_0BK@FAIBNGFG@DRDRAM?5not?5yet?5supported?4?$AA@ DB 'DRDRAM not yet '
	DB	'supported.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FEOJHBG@tAL?5must?5be?5?$DM?$DN?5tRCD?5to?5ensure?5pr@
CONST	SEGMENT
??_C@_0CP@FEOJHBG@tAL?5must?5be?5?$DM?$DN?5tRCD?5to?5ensure?5pr@ DB 'tAL '
	DB	'must be <= tRCD to ensure proper operation', 00H ; `string'
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
PUBLIC	??8TimingSpecification@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::TimingSpecification::operator==
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\timingspecification.cpp
_TEXT	SEGMENT
??8TimingSpecification@DRAMsimII@@QBE_NABV01@@Z PROC	; DRAMsimII::TimingSpecification::operator==
; _this$ = ecx
; _right$ = eax

; 190  : 	return (t_al == right.t_al && t_burst == right.t_burst && t_cas == right.t_cas && t_ccd == right.t_ccd && t_cmd == right.t_cmd &&
; 191  : 		t_cwd == right.t_cwd && t_faw == right.t_faw && t_ras == right.t_ras && t_rc == right.t_rc && t_rcd == right.t_rcd &&
; 192  : 		t_rfc == right.t_rfc && t_rp == right.t_rp && t_rrd == right.t_rrd && t_rtp == right.t_rtp && t_rtrs == right.t_rtrs &&
; 193  : 		t_wr == right.t_wr && t_wtr == right.t_wtr && t_int_burst == right.t_int_burst && t_buffer_delay == right.t_buffer_delay &&
; 194  : 		t_refi == right.t_refi && t_ost == right.t_ost);

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	$LN3@operator
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]
	jne	$LN3@operator
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR [eax+8]
	jne	$LN3@operator
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR [eax+12]
	jne	$LN3@operator
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR [eax+16]
	jne	$LN3@operator
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR [eax+24]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+28]
	cmp	edx, DWORD PTR [eax+28]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+32]
	cmp	edx, DWORD PTR [eax+32]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+36]
	cmp	edx, DWORD PTR [eax+36]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+40]
	cmp	edx, DWORD PTR [eax+40]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+44]
	cmp	edx, DWORD PTR [eax+44]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+48]
	cmp	edx, DWORD PTR [eax+48]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+52]
	cmp	edx, DWORD PTR [eax+52]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+56]
	cmp	edx, DWORD PTR [eax+56]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+60]
	cmp	edx, DWORD PTR [eax+60]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+64]
	cmp	edx, DWORD PTR [eax+64]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+72]
	cmp	edx, DWORD PTR [eax+72]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+76]
	cmp	edx, DWORD PTR [eax+76]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR [ecx+80]
	cmp	edx, DWORD PTR [eax+80]
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR [ecx+68]
	cmp	ecx, DWORD PTR [eax+68]
	jne	SHORT $LN3@operator
	mov	eax, 1

; 195  : 
; 196  : }

	ret	0
$LN3@operator:

; 190  : 	return (t_al == right.t_al && t_burst == right.t_burst && t_cas == right.t_cas && t_ccd == right.t_ccd && t_cmd == right.t_cmd &&
; 191  : 		t_cwd == right.t_cwd && t_faw == right.t_faw && t_ras == right.t_ras && t_rc == right.t_rc && t_rcd == right.t_rcd &&
; 192  : 		t_rfc == right.t_rfc && t_rp == right.t_rp && t_rrd == right.t_rrd && t_rtp == right.t_rtp && t_rtrs == right.t_rtrs &&
; 193  : 		t_wr == right.t_wr && t_wtr == right.t_wtr && t_int_burst == right.t_int_burst && t_buffer_delay == right.t_buffer_delay &&
; 194  : 		t_refi == right.t_refi && t_ost == right.t_ost);

	xor	eax, eax

; 195  : 
; 196  : }

	ret	0
??8TimingSpecification@DRAMsimII@@QBE_NABV01@@Z ENDP	; DRAMsimII::TimingSpecification::operator==
_TEXT	ENDS
PUBLIC	??0TimingSpecification@DRAMsimII@@AAE@XZ	; DRAMsimII::TimingSpecification::TimingSpecification
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
??0TimingSpecification@DRAMsimII@@AAE@XZ PROC		; DRAMsimII::TimingSpecification::TimingSpecification
; _this$ = eax

; 51   : {}

	or	ecx, -1
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], ecx
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+56], ecx
	mov	DWORD PTR [eax+60], ecx
	mov	DWORD PTR [eax+64], ecx
	mov	DWORD PTR [eax+68], 0
	mov	DWORD PTR [eax+72], ecx
	mov	DWORD PTR [eax+76], ecx
	mov	DWORD PTR [eax+80], ecx
	ret	0
??0TimingSpecification@DRAMsimII@@AAE@XZ ENDP		; DRAMsimII::TimingSpecification::TimingSpecification
PUBLIC	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVTimingSpecification@0@@Z ; DRAMsimII::operator<<
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVTimingSpecification@0@@Z PROC ; DRAMsimII::operator<<
; _os$ = esi
; _this_a$ = eax

; 199  : 	os << "rtrs[" << this_a.t_rtrs << "] ";

	mov	ecx, DWORD PTR [eax+56]
	push	OFFSET ??_C@_02PBFOLPKM@?$FN?5?$AA@
	push	ecx
	push	OFFSET ??_C@_05MKELIOBI@rtrs?$FL?$AA@
	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 200  : 	return os;

	mov	eax, esi

; 201  : }

	ret	0
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVTimingSpecification@0@@Z ENDP ; DRAMsimII::operator<<
_TEXT	ENDS
PUBLIC	??0TimingSpecification@DRAMsimII@@QAE@ABVSettings@1@@Z ; DRAMsimII::TimingSpecification::TimingSpecification
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
??0TimingSpecification@DRAMsimII@@QAE@ABVSettings@1@@Z PROC ; DRAMsimII::TimingSpecification::TimingSpecification
; _this$ = eax
; _settings$ = ecx

; 57   : {

	mov	edx, DWORD PTR [ecx+392]
	push	ebx
	mov	DWORD PTR [eax+76], edx
	mov	edx, DWORD PTR [ecx+356]
	push	esi
	push	edi
	mov	DWORD PTR [eax+80], edx

; 58   : 	switch(settings.dramType)

	mov	edx, DWORD PTR [ecx+200]
	mov	edi, 4
	cmp	edx, edi
	ja	$LN11@TimingSpec
	jmp	DWORD PTR $LN26@TimingSpec[edx*4]
$LN7@TimingSpec:

; 59   : 	{
; 60   : 	case DDR:
; 61   : 
; 62   : 		t_ccd = 2;					// internal fetch is 1 cycle, 2 beats for DDR

	mov	esi, 2
	mov	DWORD PTR [eax+12], esi

; 63   : 		t_al = 0;					// no such thing in DDR

	xor	edx, edx
	mov	DWORD PTR [eax], edx

; 64   : 		t_burst = settings.tBurst;	// depending on system config! can be 2, 4, or 8

	mov	edi, DWORD PTR [ecx+328]
	mov	DWORD PTR [eax+4], edi

; 65   : 		t_cas = settings.tCAS;

	mov	edi, DWORD PTR [ecx+332]
	mov	DWORD PTR [eax+8], edi

; 66   : 		t_cmd = 2;					// protocol specific, cannot be changed

	mov	DWORD PTR [eax+16], esi

; 67   : 		t_cwd = 2;					// protocol specific, cannot be changed

	mov	DWORD PTR [eax+20], esi

; 68   : 		t_int_burst = 2;			// protocol specific, cannot be changed

	mov	DWORD PTR [eax+72], esi

; 69   : 		t_faw = 0;					// no such thing in DDR

	mov	DWORD PTR [eax+24], edx

; 70   : 		t_ras = settings.tRAS;		// 40 ns @ 2.5 ns per beat == 16 beats

	mov	esi, DWORD PTR [ecx+344]
	mov	DWORD PTR [eax+28], esi

; 71   : 		t_rc = settings.tRC;		// 55 ns t_rc

	mov	esi, DWORD PTR [ecx+348]
	mov	DWORD PTR [eax+32], esi

; 72   : 		t_rcd = settings.tRCD;

	mov	esi, DWORD PTR [ecx+352]
	mov	DWORD PTR [eax+36], esi

; 73   : 		t_rfc = settings.tRFC;		// 70 ns @ 2.5 ns per beat == 28 beats

	mov	esi, DWORD PTR [ecx+360]
	mov	DWORD PTR [eax+40], esi

; 74   : 		t_rp = settings.tRP;		// 15 ns @ 2.5ns per beat = 6 beats

	mov	esi, DWORD PTR [ecx+364]
	mov	DWORD PTR [eax+44], esi

; 75   : 		t_rrd = settings.tRRD;

	mov	esi, DWORD PTR [ecx+368]
	mov	DWORD PTR [eax+48], esi

; 76   : 		t_rtp = settings.tRTP;

	mov	esi, DWORD PTR [ecx+372]
	mov	DWORD PTR [eax+52], esi

; 77   : 		t_rtrs = settings.tRTRS;

	mov	esi, DWORD PTR [ecx+320]
	mov	DWORD PTR [eax+56], esi

; 78   : 		t_wr = settings.tWR;		// 15 ns @ 2.5 ns per beat = 6 beats

	mov	esi, DWORD PTR [ecx+376]
	mov	DWORD PTR [eax+60], esi

; 79   : 		t_wtr = settings.tWTR;

	mov	esi, DWORD PTR [ecx+380]
	mov	DWORD PTR [eax+64], esi

; 80   : 		t_rtrs = settings.tRTRS;

	mov	ecx, DWORD PTR [ecx+320]
	mov	DWORD PTR [eax+56], ecx

; 174  : 		t_wr = settings.tWR;	
; 175  : 		t_ost = 0;					// does not exist in SDRAM

	mov	DWORD PTR [eax+68], edx
$LN11@TimingSpec:

; 181  : 		break;
; 182  : 
; 183  : 	default:
; 184  : 		break;
; 185  : 	}	
; 186  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
$LN6@TimingSpec:

; 81   : 		t_ost = 0;					// does not exist for DDR
; 82   : 		assert(t_rcd + t_cwd + t_burst + t_wr >= t_ras);
; 83   : 		break;
; 84   : 
; 85   : 	case DDR2:
; 86   : 
; 87   : 		t_ccd = 4;					// two cycles, 4 beats in DDR2
; 88   : 		t_al = settings.postedCAS ? settings.tAL : 0; // if posted CAS is disabled, tAL should be zero		

	xor	edx, edx
	mov	DWORD PTR [eax+12], edi
	cmp	BYTE PTR [ecx+288], dl
	je	SHORT $LN12@TimingSpec
	mov	edx, DWORD PTR [ecx+324]
$LN12@TimingSpec:
	mov	DWORD PTR [eax], edx

; 89   : 		t_rcd = settings.tRCD;

	mov	esi, DWORD PTR [ecx+352]
	mov	DWORD PTR [eax+36], esi

; 90   : 		t_burst = settings.tBurst; // can be 4 or 8

	mov	esi, DWORD PTR [ecx+328]
	mov	DWORD PTR [eax+4], esi

; 91   : 		t_cas = settings.tCAS;

	mov	esi, DWORD PTR [ecx+332]
	mov	DWORD PTR [eax+8], esi

; 92   : 		t_cmd = 2;					// protocol specific, cannot be changed

	mov	esi, 2
	mov	DWORD PTR [eax+16], esi

; 93   : 		t_rtp = settings.tRTP;

	mov	ebx, DWORD PTR [ecx+372]
	mov	DWORD PTR [eax+52], ebx

; 94   : 		t_rc = settings.tRC;

	mov	ebx, DWORD PTR [ecx+348]
	mov	DWORD PTR [eax+32], ebx

; 95   : 		t_ras = settings.tRAS;		

	mov	ebx, DWORD PTR [ecx+344]
	mov	DWORD PTR [eax+28], ebx

; 96   : 		//assert(t_rcd + t_burst + t_rtp - t_ccd == t_rc);
; 97   : 		assert(settings.tCWD + 2 == settings.tCAS);
; 98   : 		t_cwd = t_cas - 2;			// protocol specific, cannot be changed

	mov	ebx, DWORD PTR [eax+8]
	sub	ebx, esi

; 99   : 		t_int_burst = 4;			// protocol specific, cannot be changed
; 100  : 		t_faw = settings.tFAW;		
; 101  : 		t_rp = settings.tRP;
; 102  : 		t_rfc = settings.tRFC;
; 103  : 		t_rrd = settings.tRRD;		
; 104  : 		t_rtrs = settings.tRTRS;
; 105  : 		t_wr = settings.tWR;
; 106  : 		t_wtr = settings.tWTR;
; 107  : 		t_ost = 5;					// 2.5 cycles to turn off, 2 to turn on
; 108  : 
; 109  : 		// DRAM will delay internally if tRAS is not met
; 110  : 		// this MHC will account for any issues
; 111  : 		//assert(t_rcd + t_rtp + t_burst - t_ccd >= t_ras);
; 112  : 		assert(t_rcd + t_cwd + t_burst + t_wr >= t_ras);	
; 113  : 
; 114  : 		if (t_al > t_rcd)

	cmp	edx, DWORD PTR [eax+36]
	mov	DWORD PTR [eax+20], ebx
	mov	DWORD PTR [eax+72], edi
	mov	esi, DWORD PTR [ecx+340]
	mov	DWORD PTR [eax+24], esi
	mov	esi, DWORD PTR [ecx+364]
	mov	DWORD PTR [eax+44], esi
	mov	esi, DWORD PTR [ecx+360]
	mov	DWORD PTR [eax+40], esi
	mov	esi, DWORD PTR [ecx+368]
	mov	DWORD PTR [eax+48], esi
	mov	esi, DWORD PTR [ecx+320]
	mov	DWORD PTR [eax+56], esi
	mov	esi, DWORD PTR [ecx+376]
	mov	DWORD PTR [eax+60], esi
	mov	ecx, DWORD PTR [ecx+380]
	mov	DWORD PTR [eax+64], ecx
	mov	DWORD PTR [eax+68], 5
	jle	$LN11@TimingSpec

; 115  : 		{
; 116  : 			cerr << "tAL must be <= tRCD to ensure proper operation" << endl;

	push	OFFSET ??_C@_0CP@FEOJHBG@tAL?5must?5be?5?$DM?$DN?5tRCD?5to?5ensure?5pr@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 117  : 			exit(-20);

	push	-20					; ffffffecH
	call	_exit
$LN27@TimingSpec:
$LN4@TimingSpec:

; 118  : 		}
; 119  : 		assert(t_al >= 0 && t_al <= 8); // must be 0..4 cycles, or 0..8 beats
; 120  : 		assert(t_al + t_cmd == t_rcd);
; 121  : 
; 122  : 
; 123  : 		break;
; 124  : 
; 125  : 	case DDR3:
; 126  : 
; 127  : 		t_ccd = 8;					// four cycles, eight beats in DDR3

	mov	edi, 8

; 128  : 		t_al = settings.postedCAS ? settings.tAL : 0; // if posted CAS is disabled, tAL should be zero

	xor	edx, edx
	mov	DWORD PTR [eax+12], edi
	cmp	BYTE PTR [ecx+288], dl
	je	SHORT $LN14@TimingSpec
	mov	edx, DWORD PTR [ecx+324]
$LN14@TimingSpec:
	mov	DWORD PTR [eax], edx

; 129  : 		t_burst = 8;				// protocol specific, cannot be changed

	mov	DWORD PTR [eax+4], edi

; 130  : 		t_cas = settings.tCAS;

	mov	edx, DWORD PTR [ecx+332]
	mov	DWORD PTR [eax+8], edx

; 131  : 		t_cmd = 2;					// protocol specific, cannot be changed
; 132  : 		assert(settings.tCWD + 2 == settings.tCAS);
; 133  : 		t_cwd = t_cas - 2;			// fixed
; 134  : 		t_int_burst = 8;			// protocol specific, cannot be changed

	mov	DWORD PTR [eax+72], edi
	mov	esi, 2
	sub	edx, esi
	mov	DWORD PTR [eax+16], esi
	mov	DWORD PTR [eax+20], edx

; 135  : 		t_faw = settings.tFAW;

	mov	edx, DWORD PTR [ecx+340]
	mov	DWORD PTR [eax+24], edx

; 136  : 		t_ras = settings.tRAS;		// 27 ns @ 0.75ns per beat = 36 beats

	mov	edx, DWORD PTR [ecx+344]
	mov	DWORD PTR [eax+28], edx

; 137  : 		t_rc = settings.tRC;		// 36 ns @ 0.75ns per beat = 48 beats

	mov	edx, DWORD PTR [ecx+348]
	mov	DWORD PTR [eax+32], edx

; 138  : 		t_rcd = settings.tRCD;

	mov	edx, DWORD PTR [ecx+352]
	mov	DWORD PTR [eax+36], edx

; 139  : 		t_rfc = settings.tRFC;

	mov	edx, DWORD PTR [ecx+360]
	mov	DWORD PTR [eax+40], edx

; 140  : 		t_rp = settings.tRP;		// 9 ns @ 0.75ns per beat = 12 beats

	mov	edx, DWORD PTR [ecx+364]
	mov	DWORD PTR [eax+44], edx

; 141  : 		t_rrd = settings.tRRD;

	mov	edx, DWORD PTR [ecx+368]
	mov	DWORD PTR [eax+48], edx

; 142  : 		t_rtrs = settings.tRTRS;

	mov	edx, DWORD PTR [ecx+320]
	mov	DWORD PTR [eax+56], edx

; 143  : 		t_rtp = settings.tRTP;

	mov	edx, DWORD PTR [ecx+372]
	mov	DWORD PTR [eax+52], edx

; 144  : 		t_wr = settings.tWR;

	mov	edx, DWORD PTR [ecx+376]
	mov	DWORD PTR [eax+60], edx

; 145  : 		t_wtr = settings.tWTR;

	mov	ecx, DWORD PTR [ecx+380]
	mov	DWORD PTR [eax+64], ecx

; 146  : 		t_ost = 5;					// 2.5 cycles to turn off, 2 to turn on

	mov	DWORD PTR [eax+68], 5

; 181  : 		break;
; 182  : 
; 183  : 	default:
; 184  : 		break;
; 185  : 	}	
; 186  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
$LN3@TimingSpec:

; 147  : 
; 148  : 		// DRAM will delay internally if tRAS is not met
; 149  : 		// this MHC will account for any issues
; 150  : 		//assert(t_rcd + t_rtp + t_burst - t_ccd >= t_ras);
; 151  : 		assert(t_rcd + t_cwd + t_burst + t_wr >= t_ras);
; 152  : 		assert(t_al == t_cas - 2 || t_al == t_cas - 4);
; 153  : 
; 154  : 		break;
; 155  : 
; 156  : 	case SDRAM:
; 157  : 
; 158  : 		t_ccd = 1;					// one cycle, one beat in SDR
; 159  : 		t_al = 0;					// no such thing as posted CAS in SDRAM

	xor	edx, edx
	mov	DWORD PTR [eax], edx
	mov	esi, 1
	mov	DWORD PTR [eax+12], esi

; 160  : 		t_burst = settings.tBurst;	// depending on system config, can be 1, 2, 4, or 8

	mov	edi, DWORD PTR [ecx+328]
	mov	DWORD PTR [eax+4], edi

; 161  : 		t_cas = settings.tCAS;

	mov	edi, DWORD PTR [ecx+332]
	mov	DWORD PTR [eax+8], edi

; 162  : 		t_cmd = 1;					// protocol specific, cannot be changed

	mov	DWORD PTR [eax+16], esi

; 163  : 		t_cwd = 0;					//no such thing in SDRAM
; 164  : 		t_int_burst = 1;			// prefetch length is 1

	mov	DWORD PTR [eax+72], esi
	mov	DWORD PTR [eax+20], edx

; 165  : 		t_faw = 0;					// no such thing in SDRAM

	mov	DWORD PTR [eax+24], edx

; 166  : 		t_ras = settings.tRAS;		

	mov	esi, DWORD PTR [ecx+344]
	mov	DWORD PTR [eax+28], esi

; 167  : 		t_rc = settings.tRC;		

	mov	esi, DWORD PTR [ecx+348]
	mov	DWORD PTR [eax+32], esi

; 168  : 		t_rcd = settings.tRCD;

	mov	esi, DWORD PTR [ecx+352]
	mov	DWORD PTR [eax+36], esi

; 169  : 		t_rfc = settings.tRC;		// same as t_rc

	mov	esi, DWORD PTR [ecx+348]
	mov	DWORD PTR [eax+40], esi

; 170  : 		t_rp = settings.tRP;		// 12 ns @ 1.25ns per cycle = 9.6 cycles

	mov	esi, DWORD PTR [ecx+364]
	mov	DWORD PTR [eax+44], esi

; 171  : 		t_rrd = 0;					// no such thing in SDRAM

	mov	DWORD PTR [eax+48], edx

; 172  : 		t_rtp = settings.tRTP;

	mov	esi, DWORD PTR [ecx+372]
	mov	DWORD PTR [eax+52], esi

; 173  : 		t_rtrs = settings.tRTRS;	// no such thing in SDRAM

	mov	esi, DWORD PTR [ecx+320]

; 181  : 		break;
; 182  : 
; 183  : 	default:
; 184  : 		break;
; 185  : 	}	
; 186  : }

	pop	edi
	mov	DWORD PTR [eax+56], esi
	mov	ecx, DWORD PTR [ecx+376]
	pop	esi
	mov	DWORD PTR [eax+60], ecx
	mov	DWORD PTR [eax+68], edx
	pop	ebx
	ret	0
$LN2@TimingSpec:
	push	OFFSET ??_C@_0BK@FAIBNGFG@DRDRAM?5not?5yet?5supported?4?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 176  : 		break;
; 177  : 
; 178  : 	case DRDRAM:
; 179  : 		cerr << "DRDRAM not yet supported." << endl;

	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 180  : 		exit(-12);

	push	-12					; fffffff4H
	call	_exit
$LN28@TimingSpec:
$LN24@TimingSpec:
	npad	2
$LN26@TimingSpec:

; 181  : 		break;
; 182  : 
; 183  : 	default:
; 184  : 		break;
; 185  : 	}	
; 186  : }

	DD	$LN7@TimingSpec
	DD	$LN6@TimingSpec
	DD	$LN4@TimingSpec
	DD	$LN2@TimingSpec
	DD	$LN3@TimingSpec
??0TimingSpecification@DRAMsimII@@QAE@ABVSettings@1@@Z ENDP ; DRAMsimII::TimingSpecification::TimingSpecification
END
