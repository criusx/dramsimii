; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\CriuS\Documents\Visual Studio 2008\Projects\DRAMsimIIhg\src\Bank.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::Queue<DRAMsimII::Command>
PUBLIC	??0?$allocator@PAVCommand@DRAMsimII@@@std@@QAE@XZ ; std::allocator<DRAMsimII::Command *>::allocator<DRAMsimII::Command *>
PUBLIC	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
PUBLIC	??0_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::_Container_base_aux
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
PUBLIC	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
PUBLIC	??$?0PAVCommand@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVCommand@DRAMsimII@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Command *>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVCommand@DRAMsimII@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Command *> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Command *> >
PUBLIC	??0?$allocator@PAVCommand@DRAMsimII@@@std@@QAE@ABV01@@Z ; std::allocator<DRAMsimII::Command *>::allocator<DRAMsimII::Command *>
PUBLIC	??0?$_Vector_val@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVCommand@DRAMsimII@@@1@@Z ; std::_Vector_val<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Vector_val<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
PUBLIC	?_Buy@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE_NI@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Buy
PUBLIC	?_Construct_n@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXIABQAVCommand@DRAMsimII@@@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Construct_n
PUBLIC	??0?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@I@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
PUBLIC	?_Checked_iterator_base@?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEPAPAVCommand@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVCommand@DRAMsimII@@AAV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@@std@@YAPAPAVCommand@DRAMsimII@@AAV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> > >
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@PAPAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@2@@stdext@@YAPAPAVCommand@DRAMsimII@@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVCommand@DRAMsimII@@@4@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *> >
PUBLIC	??$_Umove@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@1@0PAPAV23@@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Umove<std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> > >
PUBLIC	?reserve@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::reserve
PUBLIC	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push
PUBLIC	??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ; DRAMsimII::Queue<DRAMsimII::Command>::Queue<DRAMsimII::Command>
PUBLIC	??1_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::~_Container_base_aux
PUBLIC	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Command *> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Command *> >
PUBLIC	??1?$_Vector_val@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_val<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::~_Vector_val<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
PUBLIC	?_Tidy@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Tidy
PUBLIC	??1?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::~vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
PUBLIC	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop
PUBLIC	??E?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator++
PUBLIC	??E?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator++
PUBLIC	??E?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator++
PUBLIC	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
PUBLIC	?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ; DRAMsimII::Command::getCommandType
PUBLIC	?tCCD@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tCCD
PUBLIC	?getLength@Command@DRAMsimII@@QBEIXZ		; DRAMsimII::Command::getLength
PUBLIC	?tAL@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tAL
PUBLIC	?tCAS@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tCAS
PUBLIC	?tRTP@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRTP
PUBLIC	?tRAS@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRAS
PUBLIC	?tCWD@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tCWD
PUBLIC	?tWR@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tWR
PUBLIC	?tCMD@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tCMD
PUBLIC	?tRCD@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRCD
PUBLIC	?tRP@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRP
PUBLIC	?tWTR@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tWTR
PUBLIC	?tRC@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRC
PUBLIC	??$max@_J@std@@YAAB_JAB_J0@Z			; std::max<__int64>
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
PUBLIC	?back@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::back
PUBLIC	?freecount@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ ; DRAMsimII::Queue<DRAMsimII::Command>::freecount
PUBLIC	?getBank@Address@DRAMsimII@@QBEIXZ		; DRAMsimII::Address::getBank
PUBLIC	?remove@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Command>::remove
PUBLIC	?isBasicPrecharge@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isBasicPrecharge
PUBLIC	?push_front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push_front
PUBLIC	?insert@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Command>::insert
PUBLIC	?isPrecharge@Command@DRAMsimII@@QBE_NXZ		; DRAMsimII::Command::isPrecharge
PUBLIC	?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tBurst
PUBLIC	?getRow@Address@DRAMsimII@@QBEIXZ		; DRAMsimII::Address::getRow
PUBLIC	?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ	; DRAMsimII::Event::getEnqueueTime
PUBLIC	?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ	; DRAMsimII::Event::getAddress
PUBLIC	?isFull@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBE_NXZ ; DRAMsimII::Queue<DRAMsimII::Command>::isFull
PUBLIC	?isRead@Command@DRAMsimII@@QBE_NXZ		; DRAMsimII::Command::isRead
PUBLIC	?isWrite@Command@DRAMsimII@@QBE_NXZ		; DRAMsimII::Command::isWrite
PUBLIC	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isReadOrWrite
PUBLIC	?getCommandOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4CommandOrderingAlgorithm@2@XZ ; DRAMsimII::SystemConfiguration::getCommandOrderingAlgorithm
PUBLIC	?getSeniorityAgeLimit@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getSeniorityAgeLimit
PUBLIC	?isAutoPrecharge@SystemConfiguration@DRAMsimII@@QBE_NXZ ; DRAMsimII::SystemConfiguration::isAutoPrecharge
PUBLIC	?isEmpty@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBE_NXZ ; DRAMsimII::Queue<DRAMsimII::Command>::isEmpty
PUBLIC	?size@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ ; DRAMsimII::Queue<DRAMsimII::Command>::size
PUBLIC	?isRefresh@Command@DRAMsimII@@QBE_NXZ		; DRAMsimII::Command::isRefresh
PUBLIC	?begin@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::begin
PUBLIC	?end@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::end
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVCommand@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Command *,int,DRAMsimII::Command * const *,DRAMsimII::Command * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Command *,int,DRAMsimII::Command * const *,DRAMsimII::Command * const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@PAVCommand@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<DRAMsimII::Command *,int,DRAMsimII::Command * const *,DRAMsimII::Command * const &>::_Ranit<DRAMsimII::Command *,int,DRAMsimII::Command * const *,DRAMsimII::Command * const &>
PUBLIC	??0?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@PAPAVCommand@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
PUBLIC	??0?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@PAPAVCommand@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
PUBLIC	?_Make_iter@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Make_iter
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
PUBLIC	??8?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator==
PUBLIC	??9?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator!=
PUBLIC	??$_Copy_opt@PAPAVCommand@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Command * *,DRAMsimII::Command * *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAPAVCommand@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00@Z ; stdext::unchecked_copy<DRAMsimII::Command * *,DRAMsimII::Command * *>
PUBLIC	?erase@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@0@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::erase
PUBLIC	?deallocate@?$allocator@PAVCommand@DRAMsimII@@@std@@QAEXPAPAVCommand@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Command *>::deallocate
PUBLIC	??$_Allocate@PAVCommand@DRAMsimII@@@std@@YAPAPAVCommand@DRAMsimII@@IPAPAV12@@Z ; std::_Allocate<DRAMsimII::Command *>
PUBLIC	?allocate@?$allocator@PAVCommand@DRAMsimII@@@std@@QAEPAPAVCommand@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Command *>::allocate
PUBLIC	?capacity@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::capacity
PUBLIC	?max_size@?$allocator@PAVCommand@DRAMsimII@@@std@@QBEIXZ ; std::allocator<DRAMsimII::Command *>::max_size
PUBLIC	?max_size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::max_size
PUBLIC	??$_Destroy_range@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAXPAPAVCommand@DRAMsimII@@0AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::Command *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAXPAPAVCommand@DRAMsimII@@0AAV?$allocator@PAVCommand@DRAMsimII@@@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::Command *> >
PUBLIC	?_Destroy@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEXPAPAVCommand@DRAMsimII@@0@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Destroy
PUBLIC	??$_Iter_cat@PAPAVCommand@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCommand@DRAMsimII@@@Z ; std::_Iter_cat<DRAMsimII::Command * *>
PUBLIC	??$_Fill_n@PAPAVCommand@DRAMsimII@@IPAV12@@std@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *>
PUBLIC	??$_Fill_n@PAPAVCommand@DRAMsimII@@IPAV12@@std@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *>
PUBLIC	??$unchecked_fill_n@PAPAVCommand@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@@Z ; stdext::unchecked_fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *>
PUBLIC	??$_Uninit_fill_n@PAPAVCommand@DRAMsimII@@IPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVCommand@DRAMsimII@@IPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@stdext@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@AAV?$allocator@PAVCommand@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
PUBLIC	?_Ufill@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@PAPAV34@IABQAV34@@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Ufill
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Xlen
PUBLIC	??$_Uninit_copy@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Command * *,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_copy<DRAMsimII::Command * *,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *> >
PUBLIC	??$_Uninit_move@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<DRAMsimII::Command * *,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<DRAMsimII::Command * *,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *> >
PUBLIC	??$_Umove@PAPAVCommand@DRAMsimII@@@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@PAPAV23@00@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Umove<DRAMsimII::Command * *>
PUBLIC	??$_Fill@PAPAVCommand@DRAMsimII@@PAV12@@std@@YAXPAPAVCommand@DRAMsimII@@0ABQAV12@@Z ; std::_Fill<DRAMsimII::Command * *,DRAMsimII::Command *>
PUBLIC	??$fill@PAPAVCommand@DRAMsimII@@PAV12@@std@@YAXPAPAVCommand@DRAMsimII@@0ABQAV12@@Z ; std::fill<DRAMsimII::Command * *,DRAMsimII::Command *>
PUBLIC	??$_Checked_base@PAPAVCommand@DRAMsimII@@@std@@YAPAPAVCommand@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<DRAMsimII::Command * *>
PUBLIC	??$_Checked_base@PAPAVCommand@DRAMsimII@@@std@@YAPAPAVCommand@DRAMsimII@@AAPAPAV12@@Z ; std::_Checked_base<DRAMsimII::Command * *>
PUBLIC	??$_Iter_random@PAPAVCommand@DRAMsimII@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCommand@DRAMsimII@@0@Z ; std::_Iter_random<DRAMsimII::Command * *,DRAMsimII::Command * *>
PUBLIC	??$_Move_cat@PAPAVCommand@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCommand@DRAMsimII@@@Z ; std::_Move_cat<DRAMsimII::Command * *>
PUBLIC	??$_Ptr_cat@PAPAVCommand@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCommand@DRAMsimII@@0@Z ; std::_Ptr_cat<DRAMsimII::Command * *,DRAMsimII::Command * *>
PUBLIC	??$_Copy_backward_opt@PAPAVCommand@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<DRAMsimII::Command * *,DRAMsimII::Command * *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PAPAVCommand@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<DRAMsimII::Command * *,DRAMsimII::Command * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAPAVCommand@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<DRAMsimII::Command * *,DRAMsimII::Command * *>
PUBLIC	?_Insert_n@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@IABQAVCommand@DRAMsimII@@@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Insert_n
PUBLIC	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
PUBLIC	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
PUBLIC	??Y?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator+=
PUBLIC	??Y?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator+=
PUBLIC	??H?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator+
PUBLIC	?resize@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXIPAVCommand@DRAMsimII@@@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::resize
PUBLIC	?resize@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::resize
PUBLIC	??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAPAVCommand@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[]
PUBLIC	??4?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::operator=
PUBLIC	??8?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::operator==
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?dec@std@@YAAAVios_base@1@AAV21@@Z		; std::dec
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::size
PUBLIC	??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEABQAVCommand@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[]
PUBLIC	?read@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPAVCommand@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Command>::read
PUBLIC	?at@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Command>::at
PUBLIC	??A?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@1@I@Z ; DRAMsimII::Queue<DRAMsimII::Command>::operator[]
PUBLIC	??$?6VCommand@DRAMsimII@@@DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABV?$Queue@VCommand@DRAMsimII@@@0@@Z ; DRAMsimII::operator<<<DRAMsimII::Command>
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BG@GJDAHMDK@Unhandled?5CAS?5variant?$AA@	; `string'
PUBLIC	??_C@_0M@NMKFEDGM@?$FN?5open?5row?$FL?$AA@	; `string'
PUBLIC	??_C@_06KAELOPMD@?$FN?5act?$FL?$AA@		; `string'
PUBLIC	??_C@_0L@ECHFMGHC@last?5RAS?5?$FL?$AA@		; `string'
PUBLIC	??_C@_03MFAIBKPK@PBQ?$AA@			; `string'
PUBLIC	??_C@_0BG@KEOIJAJD@Input?5pointer?5is?5NULL?$AA@ ; `string'
PUBLIC	??_C@_0CF@LLADOICC@Attempting?5to?5insert?5NULL?5into?5q@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_04GMJPAGIJ@?$FN?5P?$FL?$AA@		; `string'
PUBLIC	??_C@_04GLJGKOFF@?$FN?5T?$FL?$AA@		; `string'
PUBLIC	??_C@_04HOKKPEEB@?$FN?5H?$FL?$AA@		; `string'
PUBLIC	??_C@_04HCPPBLKA@?$FN?5C?$FL?$AA@		; `string'
PUBLIC	??_C@_08NMFLJNNF@Queue?5S?$FL?$AA@		; `string'
PUBLIC	??_C@_01GPOEFGEJ@?7?$AA@			; `string'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_01GPOEFGEJ@?7?$AA@
CONST	SEGMENT
??_C@_01GPOEFGEJ@?7?$AA@ DB 09H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NMFLJNNF@Queue?5S?$FL?$AA@
CONST	SEGMENT
??_C@_08NMFLJNNF@Queue?5S?$FL?$AA@ DB 'Queue S[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCPPBLKA@?$FN?5C?$FL?$AA@
CONST	SEGMENT
??_C@_04HCPPBLKA@?$FN?5C?$FL?$AA@ DB '] C[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HOKKPEEB@?$FN?5H?$FL?$AA@
CONST	SEGMENT
??_C@_04HOKKPEEB@?$FN?5H?$FL?$AA@ DB '] H[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GLJGKOFF@?$FN?5T?$FL?$AA@
CONST	SEGMENT
??_C@_04GLJGKOFF@?$FN?5T?$FL?$AA@ DB '] T[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GMJPAGIJ@?$FN?5P?$FL?$AA@
CONST	SEGMENT
??_C@_04GMJPAGIJ@?$FN?5P?$FL?$AA@ DB '] P[', 00H	; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LLADOICC@Attempting?5to?5insert?5NULL?5into?5q@
CONST	SEGMENT
??_C@_0CF@LLADOICC@Attempting?5to?5insert?5NULL?5into?5q@ DB 'Attempting '
	DB	'to insert NULL into queue', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KEOIJAJD@Input?5pointer?5is?5NULL?$AA@
CONST	SEGMENT
??_C@_0BG@KEOIJAJD@Input?5pointer?5is?5NULL?$AA@ DB 'Input pointer is NUL'
	DB	'L', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03MFAIBKPK@PBQ?$AA@
CONST	SEGMENT
??_C@_03MFAIBKPK@PBQ?$AA@ DB 'PBQ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ECHFMGHC@last?5RAS?5?$FL?$AA@
CONST	SEGMENT
??_C@_0L@ECHFMGHC@last?5RAS?5?$FL?$AA@ DB 'last RAS [', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06KAELOPMD@?$FN?5act?$FL?$AA@
CONST	SEGMENT
??_C@_06KAELOPMD@?$FN?5act?$FL?$AA@ DB '] act[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NMKFEDGM@?$FN?5open?5row?$FL?$AA@
CONST	SEGMENT
??_C@_0M@NMKFEDGM@?$FN?5open?5row?$FL?$AA@ DB '] open row[', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GJDAHMDK@Unhandled?5CAS?5variant?$AA@
CONST	SEGMENT
??_C@_0BG@GJDAHMDK@Unhandled?5CAS?5variant?$AA@ DB 'Unhandled CAS variant'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
PUBLIC	?issueREF@Bank@DRAMsimII@@QAEXXZ		; DRAMsimII::Bank::issueREF
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVCommand@DRAMsimII@@IPAV12@@std@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAPAVCommand@DRAMsimII@@IPAV12@@std@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n@11
	push	esi
	npad	7
$LL3@Fill_n@11:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@11
	pop	esi
$LN1@Fill_n@11:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPAVCommand@DRAMsimII@@IPAV12@@std@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<DRAMsimII::Command * *,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<DRAMsimII::Command * *,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEPAPAVCommand@DRAMsimII@@XZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEPAPAVCommand@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 305  : 		return (this->_Myptr);

	mov	eax, DWORD PTR [eax+4]

; 306  : 		}

	ret	0
?_Checked_iterator_base@?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEPAPAVCommand@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAVCommand@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCommand@DRAMsimII@@@Z
_TEXT	SEGMENT
??$_Iter_cat@PAPAVCommand@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCommand@DRAMsimII@@@Z PROC ; std::_Iter_cat<DRAMsimII::Command * *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAPAVCommand@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCommand@DRAMsimII@@@Z ENDP ; std::_Iter_cat<DRAMsimII::Command * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVCommand@DRAMsimII@@AAV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVCommand@DRAMsimII@@AAV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVCommand@DRAMsimII@@AAV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAVCommand@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PAPAVCommand@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<DRAMsimII::Command * *,DRAMsimII::Command * *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;
; 2711 : 	if (_Off > 0)
; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H

; 2713 : 	return _Result;

	mov	eax, esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAPAVCommand@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<DRAMsimII::Command * *,DRAMsimII::Command * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVCommand@DRAMsimII@@@std@@YAPAPAVCommand@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAPAVCommand@DRAMsimII@@@std@@YAPAPAVCommand@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<DRAMsimII::Command * *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAPAVCommand@DRAMsimII@@@std@@YAPAPAVCommand@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<DRAMsimII::Command * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@@std@@YAPAPAVCommand@DRAMsimII@@AAV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@@std@@YAPAPAVCommand@DRAMsimII@@AAV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@@std@@YAPAPAVCommand@DRAMsimII@@AAV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAVCommand@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCommand@DRAMsimII@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAPAVCommand@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCommand@DRAMsimII@@@Z PROC ; std::_Move_cat<DRAMsimII::Command * *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAPAVCommand@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCommand@DRAMsimII@@@Z ENDP ; std::_Move_cat<DRAMsimII::Command * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAVCommand@DRAMsimII@@PAV12@@std@@YAXPAPAVCommand@DRAMsimII@@0ABQAV12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Fill@PAPAVCommand@DRAMsimII@@PAV12@@std@@YAXPAPAVCommand@DRAMsimII@@0ABQAV12@@Z PROC ; std::_Fill<DRAMsimII::Command * *,DRAMsimII::Command *>, COMDAT
; __First$ = eax
; __Last$ = edx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	cmp	eax, edx
	je	SHORT $LN1@Fill@7
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	npad	6
$LL3@Fill@7:

; 3159 : 		*_First = _Val;

	mov	DWORD PTR [eax], ecx
	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL3@Fill@7
$LN1@Fill@7:

; 3160 : 	}

	ret	0
??$_Fill@PAPAVCommand@DRAMsimII@@PAV12@@std@@YAXPAPAVCommand@DRAMsimII@@0ABQAV12@@Z ENDP ; std::_Fill<DRAMsimII::Command * *,DRAMsimII::Command *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVCommand@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Copy_opt@PAPAVCommand@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<DRAMsimII::Command * *,DRAMsimII::Command * *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCommand@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<DRAMsimII::Command * *,DRAMsimII::Command * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVCommand@DRAMsimII@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCommand@DRAMsimII@@0@Z
_TEXT	SEGMENT
??$_Iter_random@PAPAVCommand@DRAMsimII@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCommand@DRAMsimII@@0@Z PROC ; std::_Iter_random<DRAMsimII::Command * *,DRAMsimII::Command * *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCommand@DRAMsimII@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCommand@DRAMsimII@@0@Z ENDP ; std::_Iter_random<DRAMsimII::Command * *,DRAMsimII::Command * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVCommand@DRAMsimII@@@std@@YAPAPAVCommand@DRAMsimII@@AAPAPAV12@@Z
_TEXT	SEGMENT
??$_Checked_base@PAPAVCommand@DRAMsimII@@@std@@YAPAPAVCommand@DRAMsimII@@AAPAPAV12@@Z PROC ; std::_Checked_base<DRAMsimII::Command * *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAPAVCommand@DRAMsimII@@@std@@YAPAPAVCommand@DRAMsimII@@AAPAPAV12@@Z ENDP ; std::_Checked_base<DRAMsimII::Command * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAXPAPAVCommand@DRAMsimII@@0AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAXPAPAVCommand@DRAMsimII@@0AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::Command *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAXPAPAVCommand@DRAMsimII@@0AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVCommand@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCommand@DRAMsimII@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAPAVCommand@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCommand@DRAMsimII@@0@Z PROC ; std::_Ptr_cat<DRAMsimII::Command * *,DRAMsimII::Command * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCommand@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCommand@DRAMsimII@@0@Z ENDP ; std::_Ptr_cat<DRAMsimII::Command * *,DRAMsimII::Command * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 8
__Iosbase$ = 16						; size = 4
__Fill$ = 20						; size = 1
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi
; __Val$ = edx

; 1117 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	push	edx
	mov	edx, DWORD PTR __Fill$[esp]
	push	edx
	mov	edx, DWORD PTR __Iosbase$[esp+4]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+12]
	push	edx
	push	esi
	call	eax
	mov	eax, esi

; 1118 : 		}

	ret	16					; 00000010H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAVCommand@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVCommand@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
??$?0PAVCommand@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVCommand@DRAMsimII@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Command *>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0PAVCommand@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVCommand@DRAMsimII@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Command *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAPAVCommand@DRAMsimII@@PAV12@@std@@YAXPAPAVCommand@DRAMsimII@@0ABQAV12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$fill@PAPAVCommand@DRAMsimII@@PAV12@@std@@YAXPAPAVCommand@DRAMsimII@@0ABQAV12@@Z PROC ; std::fill<DRAMsimII::Command * *,DRAMsimII::Command *>, COMDAT
; __First$ = eax
; __Last$ = ecx

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	cmp	eax, ecx
	je	SHORT $LN11@fill@6
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
	npad	6
$LL13@fill@6:
	mov	DWORD PTR [eax], edx
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL13@fill@6
$LN11@fill@6:

; 3188 : 	}

	ret	0
??$fill@PAPAVCommand@DRAMsimII@@PAV12@@std@@YAXPAPAVCommand@DRAMsimII@@0ABQAV12@@Z ENDP ; std::fill<DRAMsimII::Command * *,DRAMsimII::Command *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAPAVCommand@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAPAVCommand@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<DRAMsimII::Command * *,DRAMsimII::Command * *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN18@unchecked_@12
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@unchecked_@12:
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCommand@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<DRAMsimII::Command * *,DRAMsimII::Command * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAXPAPAVCommand@DRAMsimII@@0AAV?$allocator@PAVCommand@DRAMsimII@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAXPAPAVCommand@DRAMsimII@@0AAV?$allocator@PAVCommand@DRAMsimII@@@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::Command *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAXPAPAVCommand@DRAMsimII@@0AAV?$allocator@PAVCommand@DRAMsimII@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jl	SHORT $LN4@max@7
	mov	eax, ecx
$LN4@max@7:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$max@_J@std@@YAAB_JAB_J0@Z
_TEXT	SEGMENT
??$max@_J@std@@YAAB_JAB_J0@Z PROC			; std::max<__int64>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]
	jg	SHORT $LN3@max@8
	jl	SHORT $LN4@max@8
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jb	SHORT $LN4@max@8
$LN3@max@8:
	mov	eax, ecx
$LN4@max@8:

; 3385 : 	}

	ret	0
??$max@_J@std@@YAAB_JAB_J0@Z ENDP			; std::max<__int64>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVCommand@DRAMsimII@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCommand@DRAMsimII@@@std@@QBEIXZ PROC ; std::allocator<DRAMsimII::Command *>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCommand@DRAMsimII@@@std@@QBEIXZ ENDP ; std::allocator<DRAMsimII::Command *>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVCommand@DRAMsimII@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@PAVCommand@DRAMsimII@@@std@@QAE@ABV01@@Z PROC ; std::allocator<DRAMsimII::Command *>::allocator<DRAMsimII::Command *>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@PAVCommand@DRAMsimII@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<DRAMsimII::Command *>::allocator<DRAMsimII::Command *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVCommand@DRAMsimII@@@std@@QAEXPAPAVCommand@DRAMsimII@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@PAVCommand@DRAMsimII@@@std@@QAEXPAPAVCommand@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::Command *>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@PAVCommand@DRAMsimII@@@std@@QAEXPAPAVCommand@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::Command *>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVCommand@DRAMsimII@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCommand@DRAMsimII@@@std@@QAE@XZ PROC	; std::allocator<DRAMsimII::Command *>::allocator<DRAMsimII::Command *>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCommand@DRAMsimII@@@std@@QAE@XZ ENDP	; std::allocator<DRAMsimII::Command *>::allocator<DRAMsimII::Command *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEXPAPAVCommand@DRAMsimII@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEXPAPAVCommand@DRAMsimII@@0@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	0
?_Destroy@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEXPAPAVCommand@DRAMsimII@@0@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@15
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@15:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
__Fill$ = 12						; size = 1
__Val$ = 16						; size = 8
__Dest$ = 24						; size = 8
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi

; 1092 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	mov	edx, DWORD PTR __Val$[esp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	push	edx
	mov	edx, DWORD PTR __Val$[esp]
	push	edx
	mov	edx, DWORD PTR __Fill$[esp+4]
	push	edx
	mov	edx, DWORD PTR __Iosbase$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	edx
	push	esi
	call	eax
	mov	eax, esi

; 1093 : 		}

	ret	24					; 00000018H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 8
__Iosbase$ = 16						; size = 4
__Fill$ = 20						; size = 1
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi
; __Val$ = edx

; 1073 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+32]
	push	edx
	mov	edx, DWORD PTR __Fill$[esp]
	push	edx
	mov	edx, DWORD PTR __Iosbase$[esp+4]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+12]
	push	edx
	push	esi
	call	eax
	mov	eax, esi

; 1074 : 		}

	ret	16					; 00000010H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::size
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?isEmpty@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isEmpty@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBE_NXZ PROC ; DRAMsimII::Queue<DRAMsimII::Command>::isEmpty, COMDAT
; _this$ = ecx

; 375  : 			return (count == 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	sete	al

; 376  : 		}

	ret	0
?isEmpty@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBE_NXZ ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::isEmpty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isFull@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isFull@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBE_NXZ PROC ; DRAMsimII::Queue<DRAMsimII::Command>::isFull, COMDAT
; _this$ = eax

; 369  : 			return (entry.size() == count);

	mov	ecx, DWORD PTR [eax+28]
	sub	ecx, DWORD PTR [eax+24]
	xor	edx, edx
	sar	ecx, 2
	cmp	ecx, DWORD PTR [eax]
	sete	dl
	mov	al, dl

; 370  : 		}

	ret	0
?isFull@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBE_NXZ ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::isFull
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?freecount@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?freecount@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::Queue<DRAMsimII::Command>::freecount, COMDAT
; _this$ = ecx

; 363  : 			return entry.size() - count;

	mov	eax, DWORD PTR [ecx+28]
	sub	eax, DWORD PTR [ecx+24]
	sar	eax, 2
	sub	eax, DWORD PTR [ecx]

; 364  : 		}

	ret	0
?freecount@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::freecount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?size@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::Queue<DRAMsimII::Command>::size, COMDAT
; _this$ = eax

; 244  : 			return count;

	mov	eax, DWORD PTR [eax]

; 245  : 		}

	ret	0
?size@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::size
_TEXT	ENDS
PUBLIC	?isEmpty@Bank@DRAMsimII@@QBE_NXZ		; DRAMsimII::Bank::isEmpty
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.cpp
_TEXT	SEGMENT
?isEmpty@Bank@DRAMsimII@@QBE_NXZ PROC			; DRAMsimII::Bank::isEmpty
; _this$ = ecx

; 510  : 	return perBankQueue.isEmpty();

	xor	eax, eax
	cmp	DWORD PTR [ecx+8], eax
	sete	al

; 511  : }

	ret	0
?isEmpty@Bank@DRAMsimII@@QBE_NXZ ENDP			; DRAMsimII::Bank::isEmpty
_TEXT	ENDS
PUBLIC	?next@Bank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ; DRAMsimII::Bank::next
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?next@Bank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z PROC ; DRAMsimII::Bank::next
; _this$ = ecx
; _nextCommandType$ = eax

; 243  : 	switch (nextCommandType)

	cmp	eax, 12					; 0000000cH
	ja	SHORT $LN1@next@2
	movzx	eax, BYTE PTR $LN11@next@2[eax]
	jmp	DWORD PTR $LN12@next@2[eax*4]
$LN6@next@2:

; 244  : 	{
; 245  : 	case Command::ACTIVATE:
; 246  : 		return nextActivateTime;

	mov	eax, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR [ecx+92]

; 264  : 		break;
; 265  : 	}
; 266  : }

	ret	0
$LN5@next@2:

; 247  : 		break;
; 248  : 	case Command::READ:
; 249  : 	case Command::READ_AND_PRECHARGE:
; 250  : 		return nextReadTime;

	mov	eax, DWORD PTR [ecx+96]
	mov	edx, DWORD PTR [ecx+100]

; 264  : 		break;
; 265  : 	}
; 266  : }

	ret	0
$LN4@next@2:

; 251  : 		break;
; 252  : 	case Command::WRITE:
; 253  : 	case Command::WRITE_AND_PRECHARGE:
; 254  : 		return nextWriteTime;

	mov	eax, DWORD PTR [ecx+104]
	mov	edx, DWORD PTR [ecx+108]

; 264  : 		break;
; 265  : 	}
; 266  : }

	ret	0
$LN3@next@2:

; 255  : 		break;
; 256  : 	case Command::PRECHARGE:
; 257  : 		return nextPrechargeTime;

	mov	eax, DWORD PTR [ecx+112]
	mov	edx, DWORD PTR [ecx+116]

; 264  : 		break;
; 265  : 	}
; 266  : }

	ret	0
$LN2@next@2:

; 258  : 		break;
; 259  : 	case Command::REFRESH_ALL:
; 260  : 		return 0;

	xor	eax, eax
	xor	edx, edx

; 264  : 		break;
; 265  : 	}
; 266  : }

	ret	0
$LN1@next@2:

; 261  : 		break;
; 262  : 	default:
; 263  : 		return TICK_MAX;

	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH

; 264  : 		break;
; 265  : 	}
; 266  : }

	ret	0
	npad	3
$LN12@next@2:
	DD	$LN6@next@2
	DD	$LN5@next@2
	DD	$LN4@next@2
	DD	$LN3@next@2
	DD	$LN2@next@2
	DD	$LN1@next@2
$LN11@next@2:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	2
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
?next@Bank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ENDP ; DRAMsimII::Bank::next
; Function compile flags: /Ogtpy
?issueREF@Bank@DRAMsimII@@QAEXXZ PROC			; DRAMsimII::Bank::issueREF
; _this$ = ecx

; 235  : 	assert(!activated);
; 236  : }

	ret	0
?issueREF@Bank@DRAMsimII@@QAEXXZ ENDP			; DRAMsimII::Bank::issueREF
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\systemconfiguration.h
_TEXT	ENDS
;	COMDAT ?isAutoPrecharge@SystemConfiguration@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isAutoPrecharge@SystemConfiguration@DRAMsimII@@QBE_NXZ PROC ; DRAMsimII::SystemConfiguration::isAutoPrecharge, COMDAT
; _this$ = eax

; 106  : 		bool isAutoPrecharge() const { return autoPrecharge; }

	mov	al, BYTE PTR [eax+346]
	ret	0
?isAutoPrecharge@SystemConfiguration@DRAMsimII@@QBE_NXZ ENDP ; DRAMsimII::SystemConfiguration::isAutoPrecharge
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getSeniorityAgeLimit@SystemConfiguration@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getSeniorityAgeLimit@SystemConfiguration@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::SystemConfiguration::getSeniorityAgeLimit, COMDAT
; _this$ = eax

; 101  : 		unsigned getSeniorityAgeLimit() const { return seniorityAgeLimit; }

	mov	eax, DWORD PTR [eax+320]
	ret	0
?getSeniorityAgeLimit@SystemConfiguration@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::SystemConfiguration::getSeniorityAgeLimit
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCommandOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4CommandOrderingAlgorithm@2@XZ
_TEXT	SEGMENT
?getCommandOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4CommandOrderingAlgorithm@2@XZ PROC ; DRAMsimII::SystemConfiguration::getCommandOrderingAlgorithm, COMDAT
; _this$ = eax

; 90   : 		CommandOrderingAlgorithm getCommandOrderingAlgorithm() const { return commandOrderingAlgorithm; }

	mov	eax, DWORD PTR [eax+288]
	ret	0
?getCommandOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4CommandOrderingAlgorithm@2@XZ ENDP ; DRAMsimII::SystemConfiguration::getCommandOrderingAlgorithm
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\timingspecification.h
_TEXT	ENDS
;	COMDAT ?tRC@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tRC@TimingSpecification@DRAMsimII@@QBEHXZ PROC		; DRAMsimII::TimingSpecification::tRC, COMDAT
; _this$ = eax

; 82   : 		int tRC() const { return t_rc; }

	mov	eax, DWORD PTR [eax+32]
	ret	0
?tRC@TimingSpecification@DRAMsimII@@QBEHXZ ENDP		; DRAMsimII::TimingSpecification::tRC
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tWTR@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tWTR@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tWTR, COMDAT
; _this$ = eax

; 80   : 		int tWTR() const { return t_wtr; };

	mov	eax, DWORD PTR [eax+64]
	ret	0
?tWTR@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tWTR
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tRP@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tRP@TimingSpecification@DRAMsimII@@QBEHXZ PROC		; DRAMsimII::TimingSpecification::tRP, COMDAT
; _this$ = eax

; 76   : 		int tRP() const { return t_rp; }

	mov	eax, DWORD PTR [eax+44]
	ret	0
?tRP@TimingSpecification@DRAMsimII@@QBEHXZ ENDP		; DRAMsimII::TimingSpecification::tRP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tRCD@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tRCD@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRCD, COMDAT
; _this$ = eax

; 75   : 		int tRCD() const { return t_rcd; }

	mov	eax, DWORD PTR [eax+36]
	ret	0
?tRCD@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRCD
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tCMD@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tCMD@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tCMD, COMDAT
; _this$ = eax

; 73   : 		int tCMD() const { return t_cmd; }

	mov	eax, DWORD PTR [eax+16]
	ret	0
?tCMD@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tCMD
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tWR@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tWR@TimingSpecification@DRAMsimII@@QBEHXZ PROC		; DRAMsimII::TimingSpecification::tWR, COMDAT
; _this$ = eax

; 71   : 		int tWR() const { return t_wr; }

	mov	eax, DWORD PTR [eax+60]
	ret	0
?tWR@TimingSpecification@DRAMsimII@@QBEHXZ ENDP		; DRAMsimII::TimingSpecification::tWR
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tCWD@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tCWD@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tCWD, COMDAT
; _this$ = eax

; 70   : 		int tCWD() const { return t_cwd; }

	mov	eax, DWORD PTR [eax+20]
	ret	0
?tCWD@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tCWD
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tRAS@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tRAS@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRAS, COMDAT
; _this$ = eax

; 69   : 		int tRAS() const { return t_ras; }

	mov	eax, DWORD PTR [eax+28]
	ret	0
?tRAS@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRAS
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tRTP@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tRTP@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRTP, COMDAT
; _this$ = eax

; 68   : 		int tRTP() const { return t_rtp; }

	mov	eax, DWORD PTR [eax+52]
	ret	0
?tRTP@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRTP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tBurst, COMDAT
; _this$ = eax

; 67   : 		int tBurst() const { return t_burst; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?tBurst@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tBurst
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tCCD@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tCCD@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tCCD, COMDAT
; _this$ = eax

; 66   : 		int tCCD() const { return t_ccd; }

	mov	eax, DWORD PTR [eax+12]
	ret	0
?tCCD@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tCCD
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tCAS@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tCAS@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tCAS, COMDAT
; _this$ = eax

; 65   : 		int tCAS() const { return t_cas; }

	mov	eax, DWORD PTR [eax+8]
	ret	0
?tCAS@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tCAS
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tAL@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tAL@TimingSpecification@DRAMsimII@@QBEHXZ PROC		; DRAMsimII::TimingSpecification::tAL, COMDAT
; _this$ = eax

; 64   : 		int tAL() const { return t_al; }

	mov	eax, DWORD PTR [eax]
	ret	0
?tAL@TimingSpecification@DRAMsimII@@QBEHXZ ENDP		; DRAMsimII::TimingSpecification::tAL
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\command.h
_TEXT	ENDS
;	COMDAT ?isRefresh@Command@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isRefresh@Command@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Command::isRefresh, COMDAT
; _this$ = ecx

; 87   : 		bool isRefresh() const { return (commandType == REFRESH_ALL); }

	xor	eax, eax
	cmp	DWORD PTR [ecx+80], 12			; 0000000cH
	sete	al
	ret	0
?isRefresh@Command@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Command::isRefresh
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isBasicPrecharge@Command@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isBasicPrecharge@Command@DRAMsimII@@QBE_NXZ PROC	; DRAMsimII::Command::isBasicPrecharge, COMDAT
; _this$ = ecx

; 86   : 		bool isBasicPrecharge() const { return commandType == PRECHARGE; }

	xor	eax, eax
	cmp	DWORD PTR [ecx+80], 6
	sete	al
	ret	0
?isBasicPrecharge@Command@DRAMsimII@@QBE_NXZ ENDP	; DRAMsimII::Command::isBasicPrecharge
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isPrecharge@Command@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isPrecharge@Command@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Command::isPrecharge, COMDAT
; _this$ = eax

; 85   : 		bool isPrecharge() const { return ((commandType == READ_AND_PRECHARGE) || (commandType == WRITE_AND_PRECHARGE) || (commandType == PRECHARGE)); }

	mov	eax, DWORD PTR [eax+80]
	cmp	eax, 2
	je	SHORT $LN3@isPrecharg
	cmp	eax, 4
	je	SHORT $LN3@isPrecharg
	cmp	eax, 6
	je	SHORT $LN3@isPrecharg
	xor	eax, eax
	ret	0
$LN3@isPrecharg:
	mov	eax, 1
	ret	0
?isPrecharge@Command@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Command::isPrecharge
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isWrite@Command@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isWrite@Command@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Command::isWrite, COMDAT
; _this$ = eax

; 84   : 		bool isWrite() const { return ((commandType == WRITE) || (commandType == WRITE_AND_PRECHARGE)); }

	mov	eax, DWORD PTR [eax+80]
	cmp	eax, 3
	je	SHORT $LN3@isWrite
	cmp	eax, 4
	je	SHORT $LN3@isWrite
	xor	eax, eax
	ret	0
$LN3@isWrite:
	mov	eax, 1
	ret	0
?isWrite@Command@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Command::isWrite
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isRead@Command@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isRead@Command@DRAMsimII@@QBE_NXZ PROC			; DRAMsimII::Command::isRead, COMDAT
; _this$ = eax

; 83   : 		bool isRead() const { return ((commandType == READ) || (commandType == READ_AND_PRECHARGE)); }

	mov	eax, DWORD PTR [eax+80]
	cmp	eax, 1
	je	SHORT $LN3@isRead@2
	cmp	eax, 2
	je	SHORT $LN3@isRead@2
	xor	eax, eax
	ret	0
$LN3@isRead@2:
	mov	eax, 1
	ret	0
?isRead@Command@DRAMsimII@@QBE_NXZ ENDP			; DRAMsimII::Command::isRead
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLength@Command@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getLength@Command@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Command::getLength, COMDAT
; _this$ = eax

; 81   : 		unsigned getLength() const { return length; }

	mov	eax, DWORD PTR [eax+88]
	ret	0
?getLength@Command@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Command::getLength
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ
_TEXT	SEGMENT
?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ PROC ; DRAMsimII::Command::getCommandType, COMDAT
; _this$ = eax

; 79   : 		CommandType getCommandType() const { return commandType; }

	mov	eax, DWORD PTR [eax+80]
	ret	0
?getCommandType@Command@DRAMsimII@@QBE?AW4CommandType@12@XZ ENDP ; DRAMsimII::Command::getCommandType
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\event.h
_TEXT	ENDS
;	COMDAT ?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ
_TEXT	SEGMENT
?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ PROC	; DRAMsimII::Event::getAddress, COMDAT
; _this$ = eax

; 89   : 		const Address &getAddress() const { return address; }

	add	eax, 40					; 00000028H
	ret	0
?getAddress@Event@DRAMsimII@@QBEABVAddress@2@XZ ENDP	; DRAMsimII::Event::getAddress
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Event::getEnqueueTime, COMDAT
; _this$ = ecx

; 86   : 		tick getEnqueueTime() const { return enqueueTime; }

	mov	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR [ecx+20]
	ret	0
?getEnqueueTime@Event@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Event::getEnqueueTime
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.h
_TEXT	ENDS
;	COMDAT ?getRow@Address@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getRow@Address@DRAMsimII@@QBEIXZ PROC			; DRAMsimII::Address::getRow, COMDAT
; _this$ = eax

; 89   : 		unsigned getRow() const { return row; }

	mov	eax, DWORD PTR [eax+28]
	ret	0
?getRow@Address@DRAMsimII@@QBEIXZ ENDP			; DRAMsimII::Address::getRow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getBank@Address@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getBank@Address@DRAMsimII@@QBEIXZ PROC			; DRAMsimII::Address::getBank, COMDAT
; _this$ = eax

; 88   : 		unsigned getBank() const { return bank; }

	mov	eax, DWORD PTR [eax+24]
	ret	0
?getBank@Address@DRAMsimII@@QBEIXZ ENDP			; DRAMsimII::Address::getBank
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 468  : 		return _Myaux != 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 469  : 		}

	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = ecx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Other$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 464  : 		}

	ret	4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
__Pcont$ = 8						; size = 4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = ecx

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	eax, DWORD PTR __Pcont$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 454  : 		}

	ret	4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = ecx

; 448  : 	_Iterator_base_aux()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
??1_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::~_Container_base_aux, COMDAT
; _this$ = ecx

; 403  : 		// Do nothing: ~_Container_base_aux_alloc_real() previously destroyed the aux object.
; 404  : 		}

	ret	0
??1_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::~_Container_base_aux
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::_Container_base_aux, COMDAT
; _this$ = ecx

; 379  : 	_Container_base_aux()

	mov	eax, ecx

; 380  : 		{
; 381  : 		// Do nothing: _Container_base_aux_alloc_real() will construct the aux object.
; 382  : 		}

	ret	0
??0_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::_Container_base_aux
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Aux_cont::_Getcont, COMDAT
; _this$ = ecx

; 369  : 		return _Mycontainer;

	mov	eax, DWORD PTR [ecx]

; 370  : 		}

	ret	0
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Aux_cont::_Getcont
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Pcont$ = 8						; size = 4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z PROC	; std::_Aux_cont::_Aux_cont, COMDAT
; _this$ = ecx

; 364  : 	explicit _Aux_cont(const _Container_base_aux * const _Pcont)

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pcont$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ENDP	; std::_Aux_cont::_Aux_cont
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAPAVCommand@DRAMsimII@@IPAV12@@std@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAPAVCommand@DRAMsimII@@IPAV12@@std@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@18
	push	esi
	npad	7
$LL9@Fill_n@18:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@18
	pop	esi
$LN7@Fill_n@18:

; 3255 : 	}

	ret	0
??$_Fill_n@PAPAVCommand@DRAMsimII@@IPAV12@@std@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<DRAMsimII::Command * *,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@38
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@38:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<DRAMsimII::Command * *,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAPAVCommand@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAPAVCommand@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@@Z PROC ; stdext::unchecked_fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@39
	push	esi
	npad	7
$LL13@unchecked_@39:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_@39
	pop	esi
$LN11@unchecked_@39:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPAVCommand@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@@Z ENDP ; stdext::unchecked_fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<DRAMsimII::Command * *,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Uninit_mov@5
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Uninit_mov@5:
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<DRAMsimII::Command * *,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAPAVCommand@DRAMsimII@@IPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAPAVCommand@DRAMsimII@@IPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil@11
	push	esi
	npad	7
$LL15@Uninit_fil@11:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil@11
	pop	esi
$LN13@Uninit_fil@11:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPAVCommand@DRAMsimII@@IPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@AAV?$allocator@PAVCommand@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAPAVCommand@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAPAVCommand@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<DRAMsimII::Command * *,DRAMsimII::Command * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@7
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@7:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAPAVCommand@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<DRAMsimII::Command * *,DRAMsimII::Command * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<DRAMsimII::Command * *,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN30@Unchecked_@12
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN30@Unchecked_@12:
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAPAVCommand@DRAMsimII@@PAPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVCommand@DRAMsimII@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<DRAMsimII::Command * *,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@PAPAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@2@@stdext@@YAPAPAVCommand@DRAMsimII@@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVCommand@DRAMsimII@@@4@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@PAPAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@2@@stdext@@YAPAPAVCommand@DRAMsimII@@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVCommand@DRAMsimII@@@4@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *> >, COMDAT
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN34@Unchecked_@13
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN34@Unchecked_@13:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@PAPAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@2@@stdext@@YAPAPAVCommand@DRAMsimII@@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVCommand@DRAMsimII@@@4@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >,DRAMsimII::Command * *,std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z
_TEXT	SEGMENT
$T346496 = -12						; size = 12
$T346500 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z PROC ; std::_Allocate<std::_Aux_cont>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@25

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@25:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@25:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@25

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T346500[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T346496[esp+16]
	mov	DWORD PTR $T346500[esp+12], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T346496[esp+16]
	push	ecx
	mov	DWORD PTR $T346496[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@25:
$LN8@Allocate@25:
	int	3
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVCommand@DRAMsimII@@IPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@stdext@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@AAV?$allocator@PAVCommand@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVCommand@DRAMsimII@@IPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@stdext@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@AAV?$allocator@PAVCommand@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@40
	push	esi
	npad	7
$LL19@unchecked_@40:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@40
	pop	esi
$LN17@unchecked_@40:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPAVCommand@DRAMsimII@@IPAV12@V?$allocator@PAVCommand@DRAMsimII@@@std@@@stdext@@YAXPAPAVCommand@DRAMsimII@@IABQAV12@AAV?$allocator@PAVCommand@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Command * *,unsigned int,DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAPAVCommand@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAPAVCommand@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00@Z PROC ; stdext::_Unchecked_move_backward<DRAMsimII::Command * *,DRAMsimII::Command * *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN22@Unchecked_@14
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Unchecked_@14:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAPAVCommand@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<DRAMsimII::Command * *,DRAMsimII::Command * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAPAVCommand@DRAMsimII@@@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@PAPAV23@00@Z
_TEXT	SEGMENT
??$_Umove@PAPAVCommand@DRAMsimII@@@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@PAPAV23@00@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Umove<DRAMsimII::Command * *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN32@Umove@6
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@Umove@6:
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	0
??$_Umove@PAPAVCommand@DRAMsimII@@@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@PAPAV23@00@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Umove<DRAMsimII::Command * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVCommand@DRAMsimII@@@std@@YAPAPAVCommand@DRAMsimII@@IPAPAV12@@Z
_TEXT	SEGMENT
$T346846 = -16						; size = 4
$T346838 = -12						; size = 12
??$_Allocate@PAVCommand@DRAMsimII@@@std@@YAPAPAVCommand@DRAMsimII@@IPAPAV12@@Z PROC ; std::_Allocate<DRAMsimII::Command *>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@26

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T346846[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T346838[esp+20]
	mov	DWORD PTR $T346846[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T346838[esp+20]
	push	ecx
	mov	DWORD PTR $T346838[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@26:
$LN1@Allocate@26:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@26:
??$_Allocate@PAVCommand@DRAMsimII@@@std@@YAPAPAVCommand@DRAMsimII@@IPAPAV12@@Z ENDP ; std::_Allocate<DRAMsimII::Command *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Umove@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Umove<std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> > >, COMDAT
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN36@Umove@7
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN36@Umove@7:

; 1149 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Umove@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@V?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Umove<std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVCommand@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVCommand@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Command *,int,DRAMsimII::Command * const *,DRAMsimII::Command * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Command *,int,DRAMsimII::Command * const *,DRAMsimII::Command * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVCommand@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Command *,int,DRAMsimII::Command * const *,DRAMsimII::Command * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Command *,int,DRAMsimII::Command * const *,DRAMsimII::Command * const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@PAVCommand@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@PAVCommand@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<DRAMsimII::Command *,int,DRAMsimII::Command * const *,DRAMsimII::Command * const &>::_Ranit<DRAMsimII::Command *,int,DRAMsimII::Command * const *,DRAMsimII::Command * const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@PAVCommand@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<DRAMsimII::Command *,int,DRAMsimII::Command * const *,DRAMsimII::Command * const &>::_Ranit<DRAMsimII::Command *,int,DRAMsimII::Command * const *,DRAMsimII::Command * const &>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@PAPAVCommand@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@PAPAVCommand@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@15
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@15
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@15
$LN1@Vector_con@15:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@15:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@PAPAVCommand@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVCommand@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVCommand@DRAMsimII@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Command *> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Command *> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVCommand@DRAMsimII@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Command *> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@PAPAV34@IABQAV34@@Z
_TEXT	SEGMENT
?_Ufill@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@PAPAV34@IABQAV34@@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill@8
	push	ebx
	npad	7
$LL21@Ufill@8:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL21@Ufill@8
	pop	ebx
$LN26@Ufill@8:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]

; 1256 : 		}

	ret	0
?_Ufill@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@PAPAV34@IABQAV34@@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@112
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@112
$LN1@operator@112:
	call	__invalid_parameter_noinfo
$LN2@operator@112:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@PAPAVCommand@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@PAPAVCommand@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@8
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@8
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@8
$LN3@Vector_ite@8:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@8:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@PAPAVCommand@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVCommand@DRAMsimII@@@std@@QAEPAPAVCommand@DRAMsimII@@I@Z
_TEXT	SEGMENT
$T347305 = -16						; size = 4
$T347307 = -12						; size = 12
?allocate@?$allocator@PAVCommand@DRAMsimII@@@std@@QAEPAPAVCommand@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::Command *>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@15
	xor	ecx, ecx
$LN3@allocate@15:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@15:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate@15
	lea	eax, DWORD PTR $T347305[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T347307[esp+20]
	mov	DWORD PTR $T347305[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T347307[esp+20]
	push	ecx
	mov	DWORD PTR $T347307[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@15:
$LN11@allocate@15:
	int	3
?allocate@?$allocator@PAVCommand@DRAMsimII@@@std@@QAEPAPAVCommand@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::Command *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Command *> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Command *> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Command *> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVCommand@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVCommand@DRAMsimII@@@1@@Z PROC ; std::_Vector_val<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Vector_val<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVCommand@DRAMsimII@@@1@@Z ENDP ; std::_Vector_val<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Vector_val<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEXXZ PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@Tidy@19

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@19:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEXXZ ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::~_Vector_val<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::~_Vector_val<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@113
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@113
$LN3@operator@113:
	call	__invalid_parameter_noinfo
$LN4@operator@113:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAPAVCommand@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAPAVCommand@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@114
	call	__invalid_parameter_noinfo
$LN1@operator@114:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 786  : 		}

	ret	0
??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAPAVCommand@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEABQAVCommand@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEABQAVCommand@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@115
	call	__invalid_parameter_noinfo
$LN1@operator@115:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 771  : 		}

	ret	0
??A?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBEABQAVCommand@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@17
	call	__invalid_parameter_noinfo
$LN6@end@17:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@20
	call	__invalid_parameter_noinfo
$LN6@begin@20:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::~vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >, COMDAT
; _this$ = esi

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@vector@17
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@17:

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::~vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?remove@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@H@Z
_TEXT	SEGMENT
_item$ = -4						; size = 4
?remove@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@H@Z PROC ; DRAMsimII::Queue<DRAMsimII::Command>::remove, COMDAT
; _this$ = esi
; _offset$ = eax

; 339  : 		{

	push	ecx

; 340  : 			assert(offset <= (int)count && offset >= 0);
; 341  : 
; 342  : 			// first get the item
; 343  : 			T *item = entry[(head + offset) % entry.size()];

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	push	ebx
	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR [esi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	ebx, edx
	jb	SHORT $LN8@remove@2
	call	__invalid_parameter_noinfo
$LN8@remove@2:
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [eax+ebx*4]

; 344  : 			count--;

	dec	DWORD PTR [esi]

; 345  : 
; 346  : 			tail = (head + count) % entry.size();

	mov	ebx, DWORD PTR [esi+28]
	sub	ebx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _item$[esp+12], ecx
	mov	ecx, DWORD PTR [esi]
	sar	ebx, 2
	add	eax, ecx
	xor	edx, edx
	div	ebx
	mov	DWORD PTR [esi+8], edx

; 347  : 
; 348  : 			// then shift the other items up
; 349  : 			for (unsigned i = (unsigned)offset; i < count; i++)

	cmp	edi, ecx
	jae	SHORT $LN1@remove@2
	push	ebp
$LL3@remove@2:

; 350  : 			{
; 351  : 				entry[(head + i) % entry.size()] = entry[(head + i + 1) % entry.size()];

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [edx+edi+1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	ebx, edx
	cmp	ebx, eax
	jb	SHORT $LN17@remove@2
	call	__invalid_parameter_noinfo
$LN17@remove@2:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	lea	ebp, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	ebx, edx
	jb	SHORT $LN24@remove@2
	call	__invalid_parameter_noinfo
$LN24@remove@2:
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ebp]
	inc	edi
	mov	DWORD PTR [eax+ebx*4], ecx
	cmp	edi, DWORD PTR [esi]
	jb	SHORT $LL3@remove@2
	pop	ebp
$LN1@remove@2:

; 352  : 			}
; 353  : 
; 354  : 
; 355  : 			entry[(head + count) % entry.size()] = NULL;

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	add	eax, DWORD PTR [esi]
	xor	edx, edx
	sar	ecx, 2
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN31@remove@2
	call	__invalid_parameter_noinfo
$LN31@remove@2:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], 0

; 356  : 
; 357  : 			return item;

	mov	eax, DWORD PTR _item$[esp+12]
	pop	edi
	pop	ebx

; 358  : 		}

	pop	ecx
	ret	0
?remove@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@H@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::remove
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?read@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPAVCommand@2@H@Z
_TEXT	SEGMENT
?read@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPAVCommand@2@H@Z PROC ; DRAMsimII::Queue<DRAMsimII::Command>::read, COMDAT
; _this$ = esi
; _offset$ = ecx

; 256  : 			if ((offset >= (int)count) || (offset < 0))

	cmp	ecx, DWORD PTR [esi]
	jge	SHORT $LN2@read@8
	test	ecx, ecx
	jl	SHORT $LN2@read@8

; 258  : 			else
; 259  : 				return entry[(head + offset) % entry.size()];

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi+28]
	sub	edi, DWORD PTR [esi+24]
	add	eax, ecx
	sar	edi, 2
	xor	edx, edx
	div	edi
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN8@read@8
	call	__invalid_parameter_noinfo
$LN8@read@8:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 260  : 		}

	ret	0
$LN2@read@8:

; 257  : 				return NULL;

	xor	eax, eax

; 260  : 		}

	ret	0
?read@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPAVCommand@2@H@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?back@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ
_TEXT	SEGMENT
?back@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ PROC ; DRAMsimII::Queue<DRAMsimII::Command>::back, COMDAT
; _this$ = esi

; 238  : 			return count ? entry[(head + count - 1) % entry.size()] : NULL;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@back@3
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [edx+eax-1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	push	edi
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN7@back@3
	call	__invalid_parameter_noinfo
$LN7@back@3:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 239  : 		}

	ret	0
$LN3@back@3:

; 238  : 			return count ? entry[(head + count - 1) % entry.size()] : NULL;

	xor	eax, eax

; 239  : 		}

	ret	0
?back@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ
_TEXT	SEGMENT
?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ PROC ; DRAMsimII::Queue<DRAMsimII::Command>::pop, COMDAT
; _this$ = esi

; 189  : 			if (count == 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN2@pop@4

; 202  : 			}
; 203  : 		}

	ret	0
$LN2@pop@4:

; 190  : 				return NULL;
; 191  : 			else
; 192  : 			{
; 193  : 				count--;

	dec	eax
	mov	DWORD PTR [esi], eax

; 194  : 
; 195  : 				T *item = entry[head];

	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	push	ebx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN5@pop@4
	call	__invalid_parameter_noinfo
$LN5@pop@4:
	mov	ecx, DWORD PTR [esi+24]

; 196  : 
; 197  : 				entry[head] = NULL; // ensure this item isn't rhs part of the queue anymore

	mov	edx, DWORD PTR [esi+28]
	mov	ebx, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR [esi+4]
	sub	edx, ecx
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN10@pop@4
	call	__invalid_parameter_noinfo
$LN10@pop@4:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], 0

; 198  : 
; 199  : 				head = (head + 1) % entry.size();	//advance head_ptr

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	inc	eax
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	pop	edi

; 200  : 
; 201  : 				return item;

	mov	eax, ebx
	pop	ebx
	mov	DWORD PTR [esi+4], edx

; 202  : 			}
; 203  : 		}

	ret	0
?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::pop
_TEXT	ENDS
PUBLIC	?resetToTime@Bank@DRAMsimII@@QAEX_J@Z		; DRAMsimII::Bank::resetToTime
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.cpp
_TEXT	SEGMENT
tv67 = -4						; size = 4
$T347752 = -4						; size = 4
tv220 = 8						; size = 4
tv64 = 8						; size = 4
$T347754 = 8						; size = 8
$T347753 = 8						; size = 8
$T347751 = 8						; size = 4
$T347750 = 8						; size = 8
_time$ = 8						; size = 8
?resetToTime@Bank@DRAMsimII@@QAEX_J@Z PROC		; DRAMsimII::Bank::resetToTime
; _this$ = esi

; 275  : {

	push	ecx

; 276  : 	lastRASTime = time - timing.tRC();

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+32]
	cdq
	push	ebx
	mov	ebx, DWORD PTR _time$[esp+8]
	push	ebp
	push	edi
	mov	edi, DWORD PTR _time$[esp+12]
	mov	ebp, edi
	sub	ebp, eax
	mov	DWORD PTR [esi+48], ebp
	mov	eax, ebx
	sbb	eax, edx
	mov	DWORD PTR [esi+52], eax

; 277  : 	lastPrechargeTime = time - timing.tRP();

	mov	eax, DWORD PTR [ecx+44]
	cdq
	mov	ebp, edi
	sub	ebp, eax
	mov	DWORD PTR [esi+72], ebp
	mov	eax, ebx
	sbb	eax, edx
	mov	DWORD PTR [esi+76], eax

; 278  : 	lastCASTime = time - timing.tCAS() - timing.tBurst();

	mov	eax, DWORD PTR [ecx+4]
	cdq
	mov	ebp, edi
	sub	ebp, eax
	mov	eax, DWORD PTR [ecx+8]
	sbb	ebx, edx
	cdq
	sub	ebp, eax
	sbb	ebx, edx
	mov	DWORD PTR [esi+60], ebx

; 279  : 	lastCASWTime = time - timing.tCWD() - timing.tWTR() - timing.tBurst();

	mov	ebx, DWORD PTR _time$[esp+16]
	mov	DWORD PTR [esi+56], ebp
	mov	eax, DWORD PTR [ecx+64]
	cdq
	sub	edi, eax
	mov	eax, DWORD PTR [ecx+20]
	sbb	ebx, edx
	cdq
	sub	edi, eax
	mov	eax, DWORD PTR [ecx+4]
	sbb	ebx, edx
	cdq
	sub	edi, eax
	sbb	ebx, edx
	mov	DWORD PTR [esi+68], ebx
	mov	DWORD PTR [esi+64], edi

; 280  : 
; 281  : 	nextPrechargeTime = lastCASWTime + timing.tAL() + timing.tCWD() + timing.tBurst() + timing.tWR();

	mov	eax, DWORD PTR [ecx+60]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [ecx+20]
	mov	ebp, edx
	cdq
	add	ebx, eax
	mov	eax, DWORD PTR [ecx+4]
	adc	ebp, edx
	cdq
	add	ebx, eax
	mov	eax, DWORD PTR [ecx]
	adc	ebp, edx
	cdq
	add	ebx, eax
	adc	ebp, edx
	add	ebx, DWORD PTR [esi+64]
	lea	edi, DWORD PTR [esi+112]
	adc	ebp, DWORD PTR [esi+68]
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], ebp

; 282  : 	nextPrechargeTime = max(nextPrechargeTime,lastCASTime + timing.tAL() + timing.tCAS() + timing.tBurst() + max(0,timing.tRTP() - timing.tCMD()));

	mov	eax, DWORD PTR [ecx+52]
	sub	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR $T347752[esp+16], 0
	mov	DWORD PTR $T347751[esp+12], eax
	test	eax, eax
	lea	eax, DWORD PTR $T347751[esp+12]
	jg	SHORT $LN38@resetToTim
	lea	eax, DWORD PTR $T347752[esp+16]
$LN38@resetToTim:
	mov	eax, DWORD PTR [eax]
	cdq
	mov	ebp, eax
	mov	eax, DWORD PTR [ecx+4]
	mov	ebx, edx
	cdq
	add	ebp, eax
	mov	eax, DWORD PTR [ecx+8]
	adc	ebx, edx
	cdq
	add	ebp, eax
	mov	eax, DWORD PTR [ecx]
	adc	ebx, edx
	cdq
	add	ebp, eax
	adc	ebx, edx
	add	ebp, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edi+4]
	adc	ebx, DWORD PTR [esi+60]
	mov	DWORD PTR $T347750[esp+12], ebp
	cmp	edx, ebx
	mov	DWORD PTR $T347750[esp+16], ebx
	jg	SHORT $LN41@resetToTim
	jl	SHORT $LN65@resetToTim
	mov	eax, DWORD PTR [edi]
	cmp	eax, ebp
	jae	SHORT $LN41@resetToTim
$LN65@resetToTim:
	lea	eax, DWORD PTR $T347750[esp+12]
	jmp	SHORT $LN42@resetToTim
$LN41@resetToTim:
	mov	eax, edi
$LN42@resetToTim:
	mov	edx, DWORD PTR [eax]

; 283  : 	nextActivateTime = lastPrechargeTime + timing.tRP();
; 284  : 
; 285  : 	nextActivateTime = max(nextActivateTime, lastRASTime + timing.tRC());

	mov	ebp, DWORD PTR [esi+48]
	mov	DWORD PTR [edi], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR [ecx+44]
	cdq
	add	eax, DWORD PTR [esi+72]
	lea	ebx, DWORD PTR [esi+88]
	adc	edx, DWORD PTR [esi+76]
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR [ebx+4], edx
	mov	eax, DWORD PTR [ecx+32]
	cdq
	add	eax, ebp
	adc	edx, DWORD PTR [esi+52]
	mov	ebp, DWORD PTR [ebx+4]
	cmp	ebp, edx
	mov	DWORD PTR $T347753[esp+12], eax
	mov	DWORD PTR $T347753[esp+16], edx
	jg	SHORT $LN49@resetToTim
	jl	SHORT $LN66@resetToTim
	mov	edx, DWORD PTR [ebx]
	cmp	edx, eax
	jae	SHORT $LN49@resetToTim
$LN66@resetToTim:
	lea	eax, DWORD PTR $T347753[esp+12]
	jmp	SHORT $LN50@resetToTim
$LN49@resetToTim:
	mov	eax, ebx
$LN50@resetToTim:
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ebx], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ebx+4], eax

; 286  : 	nextReadTime = lastRASTime + timing.tRCD() - timing.tAL();

	mov	eax, DWORD PTR [ecx+36]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [ecx]
	mov	ebp, edx
	cdq
	sub	ebx, eax
	sbb	ebp, edx
	add	ebx, DWORD PTR [esi+48]
	adc	ebp, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+96], ebx
	mov	DWORD PTR [esi+100], ebp

; 287  : 	nextWriteTime = lastRASTime + timing.tRCD() - timing.tAL();

	mov	eax, DWORD PTR [ecx+36]
	mov	ebp, DWORD PTR [esi+52]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR tv67[esp+16], edx
	cdq
	sub	ebx, eax
	mov	eax, DWORD PTR tv67[esp+16]
	sbb	eax, edx
	mov	edx, ebx
	mov	ebx, DWORD PTR [esi+48]
	add	edx, ebx
	adc	eax, ebp
	mov	DWORD PTR [esi+104], edx
	mov	DWORD PTR [esi+108], eax

; 288  : 	nextPrechargeTime = max(nextPrechargeTime, lastRASTime + timing.tRAS());

	mov	eax, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [edi+4]
	cdq
	add	eax, ebx
	adc	edx, ebp
	cmp	ecx, edx
	mov	DWORD PTR $T347754[esp+12], eax
	mov	DWORD PTR $T347754[esp+16], edx
	jg	SHORT $LN63@resetToTim
	jl	SHORT $LN67@resetToTim
	mov	edx, DWORD PTR [edi]
	cmp	edx, eax
	jae	SHORT $LN63@resetToTim
$LN67@resetToTim:
	lea	eax, DWORD PTR $T347754[esp+12]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edi], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+4], edx

; 289  : }

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8

; 288  : 	nextPrechargeTime = max(nextPrechargeTime, lastRASTime + timing.tRAS());

$LN63@resetToTim:
	mov	eax, edi
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edi], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+4], edx

; 289  : }

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
?resetToTime@Bank@DRAMsimII@@QAEX_J@Z ENDP		; DRAMsimII::Bank::resetToTime
_TEXT	ENDS
PUBLIC	?issueCASW@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Bank::issueCASW
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T347894 = -8						; size = 8
_currentTime$ = 8					; size = 8
?issueCASW@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z PROC	; DRAMsimII::Bank::issueCASW
; _this$ = ecx
; _currentCommand$ = edx

; 215  : {	

	sub	esp, 8

; 216  : 	//assert(activated);
; 217  : 	assert(openRowID == currentCommand->getAddress().getRow());
; 218  : 
; 219  : 	//lastCASWTime = currentTime + timing.tAL();
; 220  : 	lastCASWTime = currentTime;

	mov	eax, DWORD PTR _currentTime$[esp+8]
	mov	DWORD PTR [ecx+68], eax
	push	ebx

; 221  : 
; 222  : 	lastCASWLength = currentCommand->getLength();
; 223  : 
; 224  : 	CASWCount++;
; 225  : 
; 226  : 	// calculate when the next few commands can happen
; 227  : 	nextPrechargeTime = max(nextPrechargeTime, currentTime + timing.tAL() + timing.tCWD() + timing.tBurst() + timing.tWR());

	mov	ebx, DWORD PTR [ecx]
	push	ebp
	mov	ebp, DWORD PTR _currentTime$[esp+12]
	mov	DWORD PTR [ecx+64], ebp
	mov	eax, DWORD PTR [edx+88]
	inc	DWORD PTR [ecx+144]
	mov	DWORD PTR [ecx+84], eax
	mov	eax, DWORD PTR [ebx+60]
	cdq
	push	esi
	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR [ebx+20]
	mov	esi, edx
	cdq
	add	edi, eax
	mov	eax, DWORD PTR [ebx+4]
	adc	esi, edx
	cdq
	add	edi, eax
	mov	eax, DWORD PTR [ebx]
	adc	esi, edx
	cdq
	add	edi, eax
	adc	esi, edx
	add	edi, ebp
	adc	esi, DWORD PTR _currentTime$[esp+24]
	lea	eax, DWORD PTR [ecx+112]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, esi
	mov	DWORD PTR $T347894[esp+24], edi
	mov	DWORD PTR $T347894[esp+28], esi
	jg	SHORT $LN15@issueCASW
	jl	SHORT $LN17@issueCASW
	mov	edx, DWORD PTR [eax]
	cmp	edx, edi
	jae	SHORT $LN15@issueCASW
$LN17@issueCASW:
	lea	ecx, DWORD PTR $T347894[esp+24]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 228  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	8

; 221  : 
; 222  : 	lastCASWLength = currentCommand->getLength();
; 223  : 
; 224  : 	CASWCount++;
; 225  : 
; 226  : 	// calculate when the next few commands can happen
; 227  : 	nextPrechargeTime = max(nextPrechargeTime, currentTime + timing.tAL() + timing.tCWD() + timing.tBurst() + timing.tWR());

$LN15@issueCASW:
	mov	ecx, eax
	mov	edx, DWORD PTR [ecx]

; 228  : }

	pop	edi
	pop	esi
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	pop	ebp
	mov	DWORD PTR [eax+4], ecx
	pop	ebx
	add	esp, 8
	ret	8
?issueCASW@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ENDP	; DRAMsimII::Bank::issueCASW
_TEXT	ENDS
PUBLIC	?issueCAS@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z	; DRAMsimII::Bank::issueCAS
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T347929 = -16						; size = 4
$T347930 = -12						; size = 4
$T347951 = -8						; size = 4
$T347947 = -4						; size = 4
$T347961 = 8						; size = 4
$T347928 = 8						; size = 8
_currentTime$ = 8					; size = 8
?issueCAS@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z PROC	; DRAMsimII::Bank::issueCAS
; _this$ = esi
; _currentCommand$ = eax

; 194  : {

	sub	esp, 16					; 00000010H
	push	ebx

; 195  : 	//assert(activated);
; 196  : 	assert(openRowID == currentCommand->getAddress().getRow());
; 197  : 
; 198  : 	//lastCASTime = currentTime + timing.tAL();
; 199  : 	lastCASTime = currentTime;

	mov	ebx, DWORD PTR _currentTime$[esp+16]
	mov	DWORD PTR [esi+56], ebx
	push	ebp
	mov	ebp, DWORD PTR _currentTime$[esp+24]
	mov	DWORD PTR [esi+60], ebp

; 200  : 
; 201  : 	lastCASLength = currentCommand->getLength();

	mov	ecx, DWORD PTR [eax+88]

; 202  : 
; 203  : 	CASCount++;

	inc	DWORD PTR [esi+136]

; 204  : 
; 205  : 	// calculate when the next few commands can happen
; 206  : 	/// @todo which is correct?
; 207  : 	//nextPrechargeTime = max(nextPrechargeTime, currentTime + timing.tAL() + timing.tBurst() + timing.tRTP() - timing.tCCD());
; 208  : 	nextPrechargeTime = max(nextPrechargeTime, currentTime + timing.tAL() + timing.tCAS() + timing.tBurst() + max(0,timing.tRTP() - timing.tCMD()));

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+80], ecx
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [eax]
	sub	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T347947[esp+24], edx
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	push	edi
	mov	DWORD PTR $T347929[esp+28], ecx
	mov	DWORD PTR $T347930[esp+28], 0
	mov	DWORD PTR $T347951[esp+28], edx
	test	ecx, ecx
	jle	SHORT $LN17@issueCAS
	lea	ecx, DWORD PTR $T347929[esp+28]
	mov	DWORD PTR $T347961[esp+24], ecx
	jmp	SHORT $LN18@issueCAS
$LN17@issueCAS:
	lea	edx, DWORD PTR $T347930[esp+28]
	mov	DWORD PTR $T347961[esp+24], edx
$LN18@issueCAS:
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR $T347951[esp+28]
	mov	ecx, edx
	cdq
	add	edi, eax
	mov	eax, DWORD PTR $T347947[esp+28]
	adc	ecx, edx
	cdq
	add	edi, eax
	mov	eax, DWORD PTR $T347961[esp+24]
	mov	eax, DWORD PTR [eax]
	adc	ecx, edx
	cdq
	add	edi, eax
	adc	ecx, edx
	mov	edx, DWORD PTR [esi+116]
	add	edi, ebx
	lea	eax, DWORD PTR [esi+112]
	adc	ecx, ebp
	cmp	edx, ecx
	mov	DWORD PTR $T347928[esp+24], edi
	mov	DWORD PTR $T347928[esp+28], ecx
	jg	SHORT $LN21@issueCAS
	jl	SHORT $LN23@issueCAS
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, edi
	jae	SHORT $LN21@issueCAS
$LN23@issueCAS:
	lea	ecx, DWORD PTR $T347928[esp+24]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 209  : }

	pop	edi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8

; 204  : 
; 205  : 	// calculate when the next few commands can happen
; 206  : 	/// @todo which is correct?
; 207  : 	//nextPrechargeTime = max(nextPrechargeTime, currentTime + timing.tAL() + timing.tBurst() + timing.tRTP() - timing.tCCD());
; 208  : 	nextPrechargeTime = max(nextPrechargeTime, currentTime + timing.tAL() + timing.tCAS() + timing.tBurst() + max(0,timing.tRTP() - timing.tCMD()));

$LN21@issueCAS:
	mov	ecx, eax
	mov	edx, DWORD PTR [ecx]

; 209  : }

	pop	edi
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	pop	ebp
	mov	DWORD PTR [eax+4], ecx
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
?issueCAS@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ENDP	; DRAMsimII::Bank::issueCAS
_TEXT	ENDS
PUBLIC	?issueRAS@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z	; DRAMsimII::Bank::issueRAS
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T347980 = -8						; size = 8
$T347979 = -8						; size = 8
$T347978 = -8						; size = 8
$T347977 = -8						; size = 8
_currentTime$ = 8					; size = 8
?issueRAS@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z PROC	; DRAMsimII::Bank::issueRAS
; _this$ = ecx
; _currentCommand$ = edx

; 138  : {

	sub	esp, 8
	push	ebx
	push	ebp

; 139  : 	// make sure activates follow precharges
; 140  : 	assert(!activated);
; 141  : 	assert(currentTime >= lastPrechargeTime + timing.tRP());
; 142  : 
; 143  : 	activated = true;
; 144  : 
; 145  : 	lastRASTime = currentTime;

	mov	ebp, DWORD PTR _currentTime$[esp+12]
	push	esi

; 146  : 	openRowID = currentCommand->getAddress().getRow();
; 147  : 	RASCount++;
; 148  : 
; 149  : 	// calculate when the next few commands can happen
; 150  : 	nextActivateTime = max(nextActivateTime, currentTime + timing.tRC());

	mov	esi, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR _currentTime$[esp+24]
	mov	eax, 1
	mov	BYTE PTR [ecx+124], al
	mov	DWORD PTR [ecx+52], edi
	mov	DWORD PTR [ecx+48], ebp
	mov	edx, DWORD PTR [edx+68]
	add	DWORD PTR [ecx+128], eax
	mov	DWORD PTR [ecx+120], edx
	mov	eax, DWORD PTR [esi+32]
	mov	ebx, DWORD PTR [ecx+92]
	cdq
	add	eax, ebp
	adc	edx, edi
	cmp	ebx, edx
	lea	edi, DWORD PTR [ecx+88]
	mov	DWORD PTR $T347977[esp+24], eax
	mov	DWORD PTR $T347977[esp+28], edx
	jg	SHORT $LN11@issueRAS
	jl	SHORT $LN35@issueRAS
	mov	edx, DWORD PTR [edi]
	cmp	edx, eax
	jae	SHORT $LN11@issueRAS
$LN35@issueRAS:
	lea	eax, DWORD PTR $T347977[esp+24]
	jmp	SHORT $LN12@issueRAS
$LN11@issueRAS:
	mov	eax, edi
$LN12@issueRAS:
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [edi], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+4], eax

; 151  : 	nextReadTime = max(nextReadTime, currentTime + timing.tRCD() - timing.tAL());

	mov	eax, DWORD PTR [esi+36]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [esi]
	mov	edi, edx
	cdq
	sub	ebx, eax
	sbb	edi, edx
	mov	edx, DWORD PTR [ecx+100]
	add	ebx, ebp
	adc	edi, DWORD PTR _currentTime$[esp+24]
	lea	eax, DWORD PTR [ecx+96]
	cmp	edx, edi
	mov	DWORD PTR $T347978[esp+24], ebx
	mov	DWORD PTR $T347978[esp+28], edi
	jg	SHORT $LN19@issueRAS
	jl	SHORT $LN36@issueRAS
	mov	edx, DWORD PTR [eax]
	cmp	edx, ebx
	jae	SHORT $LN19@issueRAS
$LN36@issueRAS:
	lea	edx, DWORD PTR $T347978[esp+24]
	jmp	SHORT $LN20@issueRAS
$LN19@issueRAS:
	mov	edx, eax
$LN20@issueRAS:
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [eax], edi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], edx

; 152  : 	nextWriteTime = max(nextWriteTime, currentTime + timing.tRCD() - timing.tAL());

	mov	eax, DWORD PTR [esi+36]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [esi]
	mov	edi, edx
	cdq
	sub	ebx, eax
	sbb	edi, edx
	mov	edx, DWORD PTR [ecx+108]
	add	ebx, ebp
	adc	edi, DWORD PTR _currentTime$[esp+24]
	lea	eax, DWORD PTR [ecx+104]
	cmp	edx, edi
	mov	DWORD PTR $T347979[esp+24], ebx
	mov	DWORD PTR $T347979[esp+28], edi
	jg	SHORT $LN27@issueRAS
	jl	SHORT $LN37@issueRAS
	mov	edx, DWORD PTR [eax]
	cmp	edx, ebx
	jae	SHORT $LN27@issueRAS
$LN37@issueRAS:
	lea	edx, DWORD PTR $T347979[esp+24]
	jmp	SHORT $LN28@issueRAS
$LN27@issueRAS:
	mov	edx, eax
$LN28@issueRAS:
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [eax], edi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], edx

; 153  : 	nextPrechargeTime = max(nextPrechargeTime, currentTime + timing.tRAS());

	mov	eax, DWORD PTR [esi+28]
	mov	esi, DWORD PTR [ecx+116]
	cdq
	add	eax, ebp
	adc	edx, DWORD PTR _currentTime$[esp+24]
	add	ecx, 112				; 00000070H
	cmp	esi, edx
	mov	DWORD PTR $T347980[esp+24], eax
	mov	DWORD PTR $T347980[esp+28], edx
	jg	SHORT $LN33@issueRAS
	jl	SHORT $LN38@issueRAS
	mov	edx, DWORD PTR [ecx]
	cmp	edx, eax
	jae	SHORT $LN33@issueRAS
$LN38@issueRAS:
	lea	eax, DWORD PTR $T347980[esp+24]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax

; 154  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	8

; 153  : 	nextPrechargeTime = max(nextPrechargeTime, currentTime + timing.tRAS());

$LN33@issueRAS:
	mov	eax, ecx
	mov	edx, DWORD PTR [eax]

; 154  : }

	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	pop	ebp
	mov	DWORD PTR [ecx+4], eax
	pop	ebx
	add	esp, 8
	ret	8
?issueRAS@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ENDP	; DRAMsimII::Bank::issueRAS
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\command.h
_TEXT	ENDS
;	COMDAT ?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Command::isReadOrWrite, COMDAT
; _this$ = eax

; 88   : 		bool isReadOrWrite() const { return isRead() || isWrite(); }

	mov	eax, DWORD PTR [eax+80]
	cmp	eax, 1
	je	SHORT $LN3@isReadOrWr
	cmp	eax, 2
	je	SHORT $LN3@isReadOrWr
	cmp	eax, 3
	je	SHORT $LN3@isReadOrWr
	cmp	eax, 4
	je	SHORT $LN3@isReadOrWr
	xor	eax, eax
	ret	0
$LN3@isReadOrWr:
	mov	eax, 1
	ret	0
?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Command::isReadOrWrite
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
_TEXT	ENDS
;	COMDAT ?dec@std@@YAAAVios_base@1@AAV21@@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
?dec@std@@YAAAVios_base@1@AAV21@@Z PROC			; std::dec, COMDAT

; 179  : 	_Iosbase.setf(ios_base::dec, ios_base::basefield);

	mov	eax, DWORD PTR __Iosbase$[esp-4]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -3073				; fffff3ffH
	or	ecx, 512				; 00000200H
	mov	DWORD PTR [eax+16], ecx

; 180  : 	return (_Iosbase);
; 181  : 	}

	ret	0
?dec@std@@YAAAVios_base@1@AAV21@@Z ENDP			; std::dec
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	cmp	DWORD PTR [ecx+36], 16			; 00000010H
	jb	SHORT $LN7@what@2
	mov	eax, DWORD PTR [ecx+16]

; 36   : 		}

	ret	0

; 35   : 		return (_Str.c_str());

$LN7@what@2:
	lea	eax, DWORD PTR [ecx+16]

; 36   : 		}

	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Iterator_base_aux::_Getmycont, COMDAT
; _this$ = ecx

; 458  : 		return _Myaux ? _Myaux->_Getcont() : 0;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@Getmycont
	mov	eax, DWORD PTR [eax]

; 459  : 		}

	ret	0
$LN3@Getmycont:

; 458  : 		return _Myaux ? _Myaux->_Getcont() : 0;

	xor	eax, eax

; 459  : 		}

	ret	0
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN20@operator@231
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@operator@231
$LN20@operator@231:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@231
$LN10@operator@231:
	xor	edx, edx
$LN11@operator@231:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@231
	test	eax, eax
	je	SHORT $LN16@operator@231
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@231
$LN16@operator@231:
	xor	eax, eax
$LN17@operator@231:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@231
$LN1@operator@231:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@231:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [esi+4], edi

; 165  : 		return (*this);

	mov	eax, esi
	pop	edi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN22@operator@232
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN12@operator@232
$LN22@operator@232:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN13@operator@232
$LN12@operator@232:
	xor	edx, edx
$LN13@operator@232:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN3@operator@232
	test	eax, eax
	je	SHORT $LN18@operator@232
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@232
$LN18@operator@232:
	xor	eax, eax
$LN19@operator@232:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN23@operator@232
$LN3@operator@232:
	call	__invalid_parameter_noinfo
$LN23@operator@232:
	add	DWORD PTR [esi+4], edi

; 376  : 		return (*this);

	mov	eax, esi
	pop	edi

; 377  : 		}

	ret	4
??Y?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN5@Make_iter@16
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN5@Make_iter@16
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN6@Make_iter@16
$LN5@Make_iter@16:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN6@Make_iter@16:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Make_iter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@233
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@233
$LN13@operator@233:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@233
$LN9@operator@233:
	xor	eax, eax
$LN10@operator@233:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@233
	call	__invalid_parameter_noinfo
$LN14@operator@233:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 4

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator+, COMDAT
; _this$ = eax

; 380  : 		{	// return this + integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 381  : 		_Myt _Tmp = *this;

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN24@operator@234
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN15@operator@234:
	mov	ecx, DWORD PTR __Off$[esp+8]
	lea	edi, DWORD PTR [edi+ecx*4]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN5@operator@234
	test	esi, esi
	je	SHORT $LN20@operator@234
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN21@operator@234
$LN24@operator@234:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN15@operator@234
$LN20@operator@234:
	xor	eax, eax
$LN21@operator@234:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN6@operator@234
$LN5@operator@234:
	call	__invalid_parameter_noinfo
$LN6@operator@234:
	mov	DWORD PTR [ebx+4], edi

; 383  : 		}

	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	mov	eax, ebx
	pop	ebx
	ret	8
??H?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@0@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::erase, COMDAT
; _this$ = esi

; 1028 : 		{	// erase [_First, _Last)

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp
	push	edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	DWORD PTR [ebx], 0
	test	esi, esi
	je	SHORT $LN8@erase@8
	mov	eax, DWORD PTR __First_arg$[esp+12]
	cmp	DWORD PTR [esi+12], eax
	ja	SHORT $LN8@erase@8
	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN9@erase@8
$LN8@erase@8:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+12]
$LN9@erase@8:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	edi, DWORD PTR __Last_arg$[esp+12]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [esi+12], edi
	ja	SHORT $LN24@erase@8
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN25@erase@8
$LN24@erase@8:
	call	__invalid_parameter_noinfo
	mov	edi, DWORD PTR __Last_arg$[esp+12]
$LN25@erase@8:

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN38@erase@8
	cmp	eax, ecx
	je	SHORT $LN39@erase@8
$LN38@erase@8:
	call	__invalid_parameter_noinfo
$LN39@erase@8:
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, edi
	je	SHORT $LN63@erase@8

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [esi+16]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN60@erase@8
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN60@erase@8:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+16], ebp
$LN63@erase@8:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	pop	edi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	20					; 00000014H
?erase@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@0@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@235
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@235
$LN15@operator@235:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@235
$LN11@operator@235:
	xor	eax, eax
$LN12@operator@235:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@235
	call	__invalid_parameter_noinfo
$LN16@operator@235:
	add	DWORD PTR [esi+4], 4

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@236
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@236
$LN17@operator@236:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@236
$LN13@operator@236:
	xor	eax, eax
$LN14@operator@236:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@236
	call	__invalid_parameter_noinfo
$LN18@operator@236:
	add	DWORD PTR [esi+4], 4

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator++
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?at@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@I@Z
_TEXT	SEGMENT
?at@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@I@Z PROC ; DRAMsimII::Queue<DRAMsimII::Command>::at, COMDAT
; _this$ = esi
; _value$ = ecx

; 380  : 			assert(value < count);
; 381  : 			return read(value);

	cmp	ecx, DWORD PTR [esi]
	jge	SHORT $LN4@at@4
	test	ecx, ecx
	jl	SHORT $LN4@at@4
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi+28]
	sub	edi, DWORD PTR [esi+24]
	add	eax, ecx
	sar	edi, 2
	xor	edx, edx
	div	edi
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN10@at@4
	call	__invalid_parameter_noinfo
$LN10@at@4:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 382  : 		}

	ret	0

; 380  : 			assert(value < count);
; 381  : 			return read(value);

$LN4@at@4:
	xor	eax, eax

; 382  : 		}

	ret	0
?at@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@I@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::at
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
tv244 = 12						; size = 4
_rhs$ = 12						; size = 4
??8?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Command>::operator==, COMDAT

; 391  : 		{

	push	ebx
	mov	ebx, DWORD PTR _this$[esp]

; 392  : 			if (count == rhs.count && entry.size() == rhs.entry.size() &&
; 393  : 				head == rhs.head && tail == rhs.tail && pool == rhs.pool)

	mov	eax, DWORD PTR [ebx]
	push	ebp
	mov	ebp, DWORD PTR _rhs$[esp+4]
	cmp	eax, DWORD PTR [ebp]
	jne	$LN11@operator@237
	mov	ecx, DWORD PTR [ebp+28]
	mov	edx, DWORD PTR [ebx+28]
	sub	ecx, DWORD PTR [ebp+24]
	sub	edx, DWORD PTR [ebx+24]
	xor	ecx, edx
	test	ecx, -4					; fffffffcH
	jne	$LN11@operator@237
	mov	ecx, DWORD PTR [ebx+4]
	cmp	ecx, DWORD PTR [ebp+4]
	jne	$LN11@operator@237
	mov	edx, DWORD PTR [ebx+8]
	cmp	edx, DWORD PTR [ebp+8]
	jne	$LN11@operator@237
	mov	cl, BYTE PTR [ebx+36]
	cmp	cl, BYTE PTR [ebp+36]
	jne	$LN11@operator@237
	push	esi
	push	edi

; 394  : 			{
; 395  : 				for (unsigned i = 0; i < count; i++)

	xor	edi, edi
	test	eax, eax
	jbe	$LN8@operator@237
	npad	1
$LL10@operator@237:

; 396  : 				{
; 397  : 					if (at(i) && rhs.at(i))

	mov	ecx, edi
	mov	esi, ebx
	call	?at@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Command>::at
	test	eax, eax
	je	SHORT $LN7@operator@237
	mov	ecx, edi
	mov	esi, ebp
	call	?at@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Command>::at
	test	eax, eax
	je	SHORT $LN7@operator@237

; 398  : 					{
; 399  : 						if (!(*(at(i)) == *(rhs.at(i))))

	mov	ecx, edi
	call	?at@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Command>::at
	mov	ecx, edi
	mov	esi, ebx
	mov	DWORD PTR tv244[esp+12], eax
	call	?at@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Command>::at
	mov	ecx, eax
	mov	eax, DWORD PTR tv244[esp+12]
	call	??8Command@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Command::operator==
	test	al, al
	jne	SHORT $LN9@operator@237
$LN21@operator@237:
	pop	edi
	pop	esi
	pop	ebp

; 405  : 						return false;

	xor	al, al
	pop	ebx

; 411  : 		}

	ret	8
$LN7@operator@237:

; 400  : 							return false;
; 401  : 					}
; 402  : 					else if (at(i) != NULL && rhs.at(i) == NULL)

	mov	ecx, edi
	mov	esi, ebx
	call	?at@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Command>::at
	test	eax, eax
	je	SHORT $LN4@operator@237
	mov	ecx, edi
	mov	esi, ebp
	call	?at@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Command>::at
	test	eax, eax
	je	SHORT $LN21@operator@237
$LN4@operator@237:

; 403  : 						return false;
; 404  : 					else if (at(i) == NULL && rhs.at(i) != NULL)

	mov	ecx, edi
	mov	esi, ebx
	call	?at@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Command>::at
	test	eax, eax
	jne	SHORT $LN9@operator@237
	mov	ecx, edi
	mov	esi, ebp
	call	?at@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Command>::at
	test	eax, eax
	jne	SHORT $LN21@operator@237
$LN9@operator@237:

; 394  : 			{
; 395  : 				for (unsigned i = 0; i < count; i++)

	inc	edi
	cmp	edi, DWORD PTR [ebx]
	jb	SHORT $LL10@operator@237
$LN8@operator@237:
	pop	edi
	pop	esi
	pop	ebp

; 406  : 				}	
; 407  : 				return true;

	mov	al, 1
	pop	ebx

; 411  : 		}

	ret	8
$LN11@operator@237:
	pop	ebp

; 408  : 			}
; 409  : 			else
; 410  : 				return false;

	xor	al, al
	pop	ebx

; 411  : 		}

	ret	8
??8?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@1@I@Z
_TEXT	SEGMENT
??A?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@1@I@Z PROC ; DRAMsimII::Queue<DRAMsimII::Command>::operator[], COMDAT
; _this$ = esi
; _value$ = ecx

; 386  : 			return at(value);

	cmp	ecx, DWORD PTR [esi]
	jge	SHORT $LN6@operator@238
	test	ecx, ecx
	jl	SHORT $LN6@operator@238
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi+28]
	sub	edi, DWORD PTR [esi+24]
	add	eax, ecx
	sar	edi, 2
	xor	edx, edx
	div	edi
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN12@operator@238
	call	__invalid_parameter_noinfo
$LN12@operator@238:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 387  : 		}

	ret	0

; 386  : 			return at(value);

$LN6@operator@238:
	xor	eax, eax

; 387  : 		}

	ret	0
??A?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@1@I@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::operator[]
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ$0
__ehfuncinfo$??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
xdata$x	ENDS
;	COMDAT ??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ PROC	; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>, COMDAT

; 103  : 		{

	push	-1
	push	__ehhandler$??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+28]
	mov	DWORD PTR __$EHRec$[esp+40], 0
$LL7@Queue@3:

; 104  : 			while (T* value = pop())

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN107@Queue@3
	mov	edi, DWORD PTR [esi+4]
	dec	eax
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN19@Queue@3
	call	__invalid_parameter_noinfo
$LN19@Queue@3:
	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi+28]
	mov	ebp, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [ecx+edi*4]
	sub	edx, ecx
	sar	edx, 2
	cmp	ebp, edx
	jb	SHORT $LN24@Queue@3
	call	__invalid_parameter_noinfo
$LN24@Queue@3:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+ebp*4], 0
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	sar	ecx, 2
	inc	eax
	xor	edx, edx
	div	ecx
	mov	DWORD PTR [esi+4], edx
	test	edi, edi
	je	SHORT $LN107@Queue@3

; 105  : 			{
; 106  : 				if (pool)

	cmp	BYTE PTR [esi+36], 0

; 107  : 					::delete value;

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, edi
	je	SHORT $LN5@Queue@3
	push	0
	call	eax
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 108  : 				else

	jmp	SHORT $LL7@Queue@3
$LN5@Queue@3:

; 109  : 					delete value;			

	push	1
	call	eax

; 110  : 			}

	jmp	SHORT $LL7@Queue@3
$LN107@Queue@3:

; 111  : 			for (typename std::vector<T*>::iterator i = entry.begin(); i != entry.end(); i++)

	mov	ebp, DWORD PTR [esi+24]
	cmp	ebp, DWORD PTR [esi+28]
	jbe	SHORT $LN36@Queue@3
	call	__invalid_parameter_noinfo
$LN36@Queue@3:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, ebp
	npad	3
$LL53@Queue@3:
	mov	ebp, DWORD PTR [esi+28]
	cmp	DWORD PTR [esi+24], ebp
	jbe	SHORT $LN68@Queue@3
	call	__invalid_parameter_noinfo
$LN68@Queue@3:
	mov	eax, DWORD PTR [esi+12]
	test	edi, edi
	je	SHORT $LN81@Queue@3
	cmp	edi, eax
	je	SHORT $LN82@Queue@3
$LN81@Queue@3:
	call	__invalid_parameter_noinfo
$LN82@Queue@3:
	cmp	ebx, ebp
	je	SHORT $LN1@Queue@3
	test	edi, edi
	jne	SHORT $LN106@Queue@3
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN60@Queue@3:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN51@Queue@3
	call	__invalid_parameter_noinfo
$LN51@Queue@3:
	add	ebx, 4
	jmp	SHORT $LL53@Queue@3
$LN106@Queue@3:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN60@Queue@3
$LN1@Queue@3:

; 112  : 				assert(*i == NULL);
; 113  : 		}	

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN94@Queue@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN94@Queue@3:
	mov	ecx, DWORD PTR [esi+12]
	xor	eax, eax
	push	ecx
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 12					; 0000000cH
	jmp	??1?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::~vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
__ehhandler$??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ENDP	; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
PUBLIC	??8Bank@DRAMsimII@@QBE_NABV01@@Z		; DRAMsimII::Bank::operator==
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.cpp
_TEXT	SEGMENT
??8Bank@DRAMsimII@@QBE_NABV01@@Z PROC			; DRAMsimII::Bank::operator==
; _this$ = edi
; _rhs$ = esi

; 555  : 	return (timing == rhs.timing && systemConfig == rhs.systemConfig && perBankQueue == rhs.perBankQueue && lastRASTime == rhs.lastRASTime &&
; 556  : 		lastCASTime == rhs.lastCASTime && lastCASWTime == rhs.lastCASWTime && lastPrechargeTime == rhs.lastPrechargeTime &&
; 557  : 		lastCASLength == rhs.lastCASLength && lastCASWLength == rhs.lastCASWLength &&
; 558  : 		openRowID == rhs.openRowID && activated == rhs.activated && RASCount == rhs.RASCount && totalRASCount == rhs.totalRASCount &&
; 559  : 		CASCount == rhs.CASCount && totalCASCount == rhs.totalCASCount && CASWCount == rhs.CASWCount && totalCASWCount == rhs.totalCASWCount);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edi]
	call	??8TimingSpecification@DRAMsimII@@QBE_NABV01@@Z ; DRAMsimII::TimingSpecification::operator==
	test	al, al
	je	$LN3@operator@239
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [edi+4]
	call	??8SystemConfiguration@DRAMsimII@@QBE_NABV01@@Z ; DRAMsimII::SystemConfiguration::operator==
	test	al, al
	je	$LN3@operator@239
	lea	eax, DWORD PTR [esi+8]
	push	eax
	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	call	??8?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::operator==
	test	al, al
	je	$LN3@operator@239
	mov	edx, DWORD PTR [edi+48]
	cmp	edx, DWORD PTR [esi+48]
	jne	$LN3@operator@239
	mov	eax, DWORD PTR [edi+52]
	cmp	eax, DWORD PTR [esi+52]
	jne	$LN3@operator@239
	mov	ecx, DWORD PTR [edi+56]
	cmp	ecx, DWORD PTR [esi+56]
	jne	$LN3@operator@239
	mov	edx, DWORD PTR [edi+60]
	cmp	edx, DWORD PTR [esi+60]
	jne	$LN3@operator@239
	mov	eax, DWORD PTR [edi+64]
	cmp	eax, DWORD PTR [esi+64]
	jne	$LN3@operator@239
	mov	ecx, DWORD PTR [edi+68]
	cmp	ecx, DWORD PTR [esi+68]
	jne	$LN3@operator@239
	mov	edx, DWORD PTR [edi+72]
	cmp	edx, DWORD PTR [esi+72]
	jne	$LN3@operator@239
	mov	eax, DWORD PTR [edi+76]
	cmp	eax, DWORD PTR [esi+76]
	jne	SHORT $LN3@operator@239
	mov	ecx, DWORD PTR [edi+80]
	cmp	ecx, DWORD PTR [esi+80]
	jne	SHORT $LN3@operator@239
	mov	edx, DWORD PTR [edi+84]
	cmp	edx, DWORD PTR [esi+84]
	jne	SHORT $LN3@operator@239
	mov	eax, DWORD PTR [edi+120]
	cmp	eax, DWORD PTR [esi+120]
	jne	SHORT $LN3@operator@239
	mov	cl, BYTE PTR [edi+124]
	cmp	cl, BYTE PTR [esi+124]
	jne	SHORT $LN3@operator@239
	mov	edx, DWORD PTR [edi+128]
	cmp	edx, DWORD PTR [esi+128]
	jne	SHORT $LN3@operator@239
	mov	eax, DWORD PTR [edi+132]
	cmp	eax, DWORD PTR [esi+132]
	jne	SHORT $LN3@operator@239
	mov	ecx, DWORD PTR [edi+136]
	cmp	ecx, DWORD PTR [esi+136]
	jne	SHORT $LN3@operator@239
	mov	edx, DWORD PTR [edi+140]
	cmp	edx, DWORD PTR [esi+140]
	jne	SHORT $LN3@operator@239
	mov	eax, DWORD PTR [edi+144]
	cmp	eax, DWORD PTR [esi+144]
	jne	SHORT $LN3@operator@239
	mov	ecx, DWORD PTR [edi+148]
	cmp	ecx, DWORD PTR [esi+148]
	jne	SHORT $LN3@operator@239
	mov	eax, 1

; 560  : }

	ret	0
$LN3@operator@239:

; 555  : 	return (timing == rhs.timing && systemConfig == rhs.systemConfig && perBankQueue == rhs.perBankQueue && lastRASTime == rhs.lastRASTime &&
; 556  : 		lastCASTime == rhs.lastCASTime && lastCASWTime == rhs.lastCASWTime && lastPrechargeTime == rhs.lastPrechargeTime &&
; 557  : 		lastCASLength == rhs.lastCASLength && lastCASWLength == rhs.lastCASWLength &&
; 558  : 		openRowID == rhs.openRowID && activated == rhs.activated && RASCount == rhs.RASCount && totalRASCount == rhs.totalRASCount &&
; 559  : 		CASCount == rhs.CASCount && totalCASCount == rhs.totalCASCount && CASWCount == rhs.CASWCount && totalCASWCount == rhs.totalCASWCount);

	xor	eax, eax

; 560  : }

	ret	0
??8Bank@DRAMsimII@@QBE_NABV01@@Z ENDP			; DRAMsimII::Bank::operator==
_TEXT	ENDS
PUBLIC	?hasNoReadWrite@Bank@DRAMsimII@@QBE_NXZ		; DRAMsimII::Bank::hasNoReadWrite
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?hasNoReadWrite@Bank@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Bank::hasNoReadWrite
; _this$ = esi

; 514  : {

	push	ebx
	push	edi

; 515  : 	for (unsigned i = 0; i < perBankQueue.size(); i++)

	xor	edi, edi
	cmp	edi, DWORD PTR [esi+8]
	jae	SHORT $LN2@hasNoReadW
$LN32@hasNoReadW:

; 516  : 	{
; 517  : 		if (!perBankQueue[i]->isRefresh())

	jge	SHORT $LN31@hasNoReadW
	test	edi, edi
	jl	SHORT $LN31@hasNoReadW
	mov	ecx, DWORD PTR [esi+36]
	sub	ecx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [esi+12]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR [esi+36]
	sub	edx, DWORD PTR [esi+32]
	sar	edx, 2
	cmp	ebx, edx
	jb	SHORT $LN20@hasNoReadW
	call	__invalid_parameter_noinfo
$LN20@hasNoReadW:
	mov	eax, DWORD PTR [esi+32]
	mov	ebx, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN13@hasNoReadW
$LN31@hasNoReadW:
	xor	ebx, ebx
$LN13@hasNoReadW:
	cmp	DWORD PTR [ebx+80], 12			; 0000000cH
	jne	SHORT $LN28@hasNoReadW
	inc	edi
	cmp	edi, DWORD PTR [esi+8]
	jb	SHORT $LN32@hasNoReadW
$LN2@hasNoReadW:
	pop	edi

; 519  : 	}
; 520  : 	return true;

	mov	al, 1
	pop	ebx

; 521  : 
; 522  : }

	ret	0
$LN28@hasNoReadW:
	pop	edi

; 518  : 			return false;

	xor	al, al
	pop	ebx

; 521  : 
; 522  : }

	ret	0
?hasNoReadWrite@Bank@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Bank::hasNoReadWrite
_TEXT	ENDS
PUBLIC	?closePageAggressiveInsertCheck@Bank@DRAMsimII@@QBE_NPBVTransaction@2@_J@Z ; DRAMsimII::Bank::closePageAggressiveInsertCheck
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_currentRow$130606 = -4					; size = 4
_time$ = 8						; size = 8
?closePageAggressiveInsertCheck@Bank@DRAMsimII@@QBE_NPBVTransaction@2@_J@Z PROC ; DRAMsimII::Bank::closePageAggressiveInsertCheck
; _this$ = esi
; _incomingTransaction$ = ecx

; 467  : {

	push	ecx

; 468  : 	if (!perBankQueue.isFull())

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	push	ebx
	sar	eax, 2
	push	ebp
	push	edi
	cmp	eax, DWORD PTR [esi+8]
	je	$LN1@closePageA

; 469  : 	{
; 470  : 		const unsigned currentRow = incomingTransaction->getAddress().getRow();
; 471  : 		// go from the end to the beginning to ensure no starvation or RAW/WAR errors
; 472  : 		for (int currentIndex = perBankQueue.size() - 1; currentIndex >= 0; --currentIndex)

	mov	ebx, DWORD PTR [esi+8]
	sub	ebx, 1
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR _currentRow$130606[esp+16], edx
	js	$LN8@closePageA

; 473  : 		{	
; 474  : 			const Command *currentCommand = perBankQueue[currentIndex];

	mov	ebp, DWORD PTR _time$[esp+16]
	npad	3
$LL74@closePageA:
	cmp	ebx, DWORD PTR [esi+8]
	jge	SHORT $LN73@closePageA
	test	ebx, ebx
	jl	SHORT $LN73@closePageA
	mov	ecx, DWORD PTR [esi+36]
	sub	ecx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [esi+12]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebx
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+36]
	sub	edx, DWORD PTR [esi+32]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN35@closePageA
	call	__invalid_parameter_noinfo
$LN35@closePageA:
	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN28@closePageA
$LN73@closePageA:
	xor	edx, edx
$LN28@closePageA:

; 475  : 			// see if there is an available command to piggyback on
; 476  : 			if (currentCommand->isReadOrWrite() && currentCommand->getAddress().getRow() == currentRow)

	mov	eax, DWORD PTR [edx+80]
	cmp	eax, 1
	je	SHORT $LN42@closePageA
	cmp	eax, 2
	je	SHORT $LN42@closePageA
	cmp	eax, 3
	je	SHORT $LN42@closePageA
	cmp	eax, 4
	jne	SHORT $LN7@closePageA
$LN42@closePageA:
	mov	ecx, DWORD PTR _currentRow$130606[esp+16]
	cmp	DWORD PTR [edx+68], ecx
	je	SHORT $LN65@closePageA
$LN7@closePageA:

; 477  : 			{
; 478  : 				assert(currentCommand->getAddress().getChannel() == incomingTransaction->getAddress().getChannel());
; 479  : 				assert(currentCommand->getAddress().getRank() == incomingTransaction->getAddress().getRank());
; 480  : 				assert(currentCommand->getAddress().getBank() == incomingTransaction->getAddress().getBank());
; 481  : 				assert(currentCommand->getAddress().getRow() == incomingTransaction->getAddress().getRow());
; 482  : 
; 483  : 				if (!systemConfig.isAutoPrecharge())
; 484  : 				{
; 485  : 					// check that things are in order
; 486  : 					assert(perBankQueue[currentIndex + 1]->isPrecharge());
; 487  : 				}
; 488  : 				return true;
; 489  : 			}
; 490  : 			else if (systemConfig.getCommandOrderingAlgorithm() == STRICT_ORDER)

	mov	edi, DWORD PTR [esi+4]
	cmp	DWORD PTR [edi+288], 0
	je	SHORT $LN1@closePageA

; 491  : 			{
; 492  : 				return false;
; 493  : 			}
; 494  : 			// don't starve commands
; 495  : 			else if (time - currentCommand->getEnqueueTime() > systemConfig.getSeniorityAgeLimit())

	mov	ecx, DWORD PTR _time$[esp+12]
	sub	ecx, DWORD PTR [edx+16]
	mov	edi, DWORD PTR [edi+320]
	mov	eax, ebp
	sbb	eax, DWORD PTR [edx+20]
	xor	edx, edx
	cmp	eax, edx
	jg	SHORT $LN1@closePageA
	jl	SHORT $LN72@closePageA
	cmp	ecx, edi
	ja	SHORT $LN1@closePageA
$LN72@closePageA:

; 469  : 	{
; 470  : 		const unsigned currentRow = incomingTransaction->getAddress().getRow();
; 471  : 		// go from the end to the beginning to ensure no starvation or RAW/WAR errors
; 472  : 		for (int currentIndex = perBankQueue.size() - 1; currentIndex >= 0; --currentIndex)

	sub	ebx, 1
	jns	$LL74@closePageA
$LN8@closePageA:

; 496  : 			{
; 497  : 				return false;
; 498  : 			}
; 499  : 		}
; 500  : 		if (activated && openRowID == currentRow)

	cmp	BYTE PTR [esi+124], 0
	je	SHORT $LN1@closePageA
	mov	edx, DWORD PTR _currentRow$130606[esp+16]
	cmp	DWORD PTR [esi+120], edx
	jne	SHORT $LN1@closePageA
$LN65@closePageA:
	pop	edi
	pop	ebp

; 501  : 		{
; 502  : 			return true;

	mov	al, 1
	pop	ebx

; 506  : }

	pop	ecx
	ret	8
$LN1@closePageA:
	pop	edi
	pop	ebp

; 503  : 		}
; 504  : 	}
; 505  : 	return false;

	xor	al, al
	pop	ebx

; 506  : }

	pop	ecx
	ret	8
?closePageAggressiveInsertCheck@Bank@DRAMsimII@@QBE_NPBVTransaction@2@_J@Z ENDP ; DRAMsimII::Bank::closePageAggressiveInsertCheck
_TEXT	ENDS
PUBLIC	?collapse@Bank@DRAMsimII@@QAEXXZ		; DRAMsimII::Bank::collapse
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?collapse@Bank@DRAMsimII@@QAEXXZ PROC			; DRAMsimII::Bank::collapse
; _this$ = eax

; 377  : {

	push	ebx
	push	esi

; 378  : 	for (unsigned i = 0; i < perBankQueue.size() - 1; i++)

	mov	esi, eax
	mov	eax, DWORD PTR [esi+8]
	add	esi, 8
	xor	ebx, ebx
	sub	eax, 1
	je	$LN3@collapse
	push	ebp
	push	edi
$LL146@collapse:

; 379  : 	{
; 380  : 		if (perBankQueue[i]->isReadOrWrite() && perBankQueue[i+1] && perBankQueue[i+1]->isBasicPrecharge())

	cmp	ebx, DWORD PTR [esi]
	jge	SHORT $LN148@collapse
	test	ebx, ebx
	jl	SHORT $LN148@collapse
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebx
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN23@collapse
	call	__invalid_parameter_noinfo
$LN23@collapse:
	mov	eax, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN16@collapse
$LN148@collapse:
	xor	edi, edi
$LN16@collapse:
	mov	eax, DWORD PTR [edi+80]
	cmp	eax, 1
	je	SHORT $LN30@collapse
	cmp	eax, 2
	je	SHORT $LN30@collapse
	cmp	eax, 3
	je	SHORT $LN30@collapse
	cmp	eax, 4
	jne	$LN4@collapse
$LN30@collapse:
	lea	ebp, DWORD PTR [ebx+1]
	cmp	ebp, DWORD PTR [esi]
	jge	$LN4@collapse
	test	ebp, ebp
	jl	$LN4@collapse
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebp
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN51@collapse
	call	__invalid_parameter_noinfo
$LN51@collapse:
	mov	eax, DWORD PTR [esi+24]
	cmp	DWORD PTR [eax+edi*4], 0
	je	$LN4@collapse
	cmp	ebp, DWORD PTR [esi]
	jge	SHORT $LN61@collapse
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, eax
	mov	eax, DWORD PTR [esi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebp
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN67@collapse
	call	__invalid_parameter_noinfo
$LN67@collapse:
	mov	eax, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN60@collapse
$LN61@collapse:
	xor	edi, edi
$LN60@collapse:
	cmp	DWORD PTR [edi+80], 6
	jne	$LN4@collapse

; 381  : 		{
; 382  : 			if (perBankQueue[i]->getAddress().getBank() != perBankQueue[i+1]->getAddress().getBank())

	cmp	ebx, DWORD PTR [esi]
	jge	SHORT $LN144@collapse
	test	ebx, ebx
	jl	SHORT $LN144@collapse
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	add	eax, ebx
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	cmp	edx, eax
	jb	SHORT $LN144@collapse
	call	__invalid_parameter_noinfo
$LN144@collapse:
	cmp	ebp, DWORD PTR [esi]
	jge	SHORT $LN105@collapse
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	add	eax, ebp
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	cmp	edx, eax
	jb	SHORT $LN105@collapse
	call	__invalid_parameter_noinfo
$LN105@collapse:

; 383  : 				assert(false);
; 384  : 			assert(!perBankQueue[i]->isPrecharge());
; 385  : 			perBankQueue[i]->setAutoPrecharge(true);

	cmp	ebx, DWORD PTR [esi]
	jge	SHORT $LN147@collapse
	test	ebx, ebx
	jl	SHORT $LN147@collapse
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebx
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN125@collapse
	call	__invalid_parameter_noinfo
$LN125@collapse:
	mov	eax, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN118@collapse
$LN147@collapse:
	xor	eax, eax
$LN118@collapse:
	mov	ecx, DWORD PTR [eax+80]
	lea	edx, DWORD PTR [ecx-1]
	cmp	edx, 3
	ja	SHORT $LN131@collapse
	jmp	DWORD PTR $LN149@collapse[edx*4]
$LN132@collapse:
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	lea	edx, DWORD PTR [edx+edx+2]
	mov	DWORD PTR [eax+80], edx
$LN131@collapse:

; 386  : 			Command *toDelete = perBankQueue.remove(i+1);

	mov	eax, ebp
	call	?remove@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Command>::remove

; 387  : 			assert(!toDelete->isReadOrWrite() && toDelete->isBasicPrecharge());
; 388  : 			assert(!toDelete->getHost());
; 389  : 			//cerr << *toDelete << endl;
; 390  : 			delete toDelete;

	test	eax, eax
	je	SHORT $LN4@collapse
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx]
	push	1
	call	eax
$LN4@collapse:
	mov	ecx, DWORD PTR [esi]
	inc	ebx
	dec	ecx
	cmp	ebx, ecx
	jb	$LL146@collapse
	pop	edi
	pop	ebp
$LN3@collapse:
	pop	esi
	pop	ebx

; 391  : 		}
; 392  : 	}
; 393  : }

	ret	0
$LN149@collapse:
	DD	$LN132@collapse
	DD	$LN131@collapse
	DD	$LN132@collapse
	DD	$LN131@collapse
?collapse@Bank@DRAMsimII@@QAEXXZ ENDP			; DRAMsimII::Bank::collapse
_TEXT	ENDS
PUBLIC	?openPageAggressiveInsertCheck@Bank@DRAMsimII@@QBE_NPBVTransaction@2@_J@Z ; DRAMsimII::Bank::openPageAggressiveInsertCheck
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_currentRow$130537 = 8					; size = 4
_incomingTransaction$ = 8				; size = 4
_time$ = 12						; size = 8
?openPageAggressiveInsertCheck@Bank@DRAMsimII@@QBE_NPBVTransaction@2@_J@Z PROC ; DRAMsimII::Bank::openPageAggressiveInsertCheck
; _this$ = esi

; 304  : 	if (perBankQueue.freecount() >= 3)

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	sar	eax, 2
	sub	eax, DWORD PTR [esi+8]
	cmp	eax, 3
	jb	SHORT $LN19@openPageAg

; 305  : 	{
; 306  : 		return true;

	mov	al, 1

; 370  : 	}
; 371  : }

	ret	12					; 0000000cH
$LN19@openPageAg:

; 307  : 	}
; 308  : 	else 
; 309  : 	{
; 310  : 		unsigned availableSlots = perBankQueue.freecount();
; 311  : 
; 312  : 		// if the queue ends with a R/W(+P), then all that is needed is A, R/W
; 313  : 		if (perBankQueue.back()->isReadOrWrite())

	mov	eax, DWORD PTR [esi+8]
	push	ebp
	mov	ebp, DWORD PTR [esi+36]
	sub	ebp, DWORD PTR [esi+32]
	push	edi
	sar	ebp, 2
	sub	ebp, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN32@openPageAg
	mov	ecx, DWORD PTR [esi+36]
	sub	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [edx+eax-1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN36@openPageAg
	call	__invalid_parameter_noinfo
$LN36@openPageAg:
	mov	ecx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [ecx+edi*4]
	jmp	SHORT $LN33@openPageAg
$LN32@openPageAg:
	xor	eax, eax
$LN33@openPageAg:
	mov	eax, DWORD PTR [eax+80]
	cmp	eax, 1
	je	SHORT $LN175@openPageAg
	cmp	eax, 2
	je	SHORT $LN175@openPageAg
	cmp	eax, 3
	je	SHORT $LN175@openPageAg
	cmp	eax, 4
	jne	SHORT $LN181@openPageAg
$LN175@openPageAg:

; 314  : 		{
; 315  : 			if (availableSlots >= 2)

	cmp	ebp, 2
	jb	SHORT $LN181@openPageAg
	pop	edi

; 316  : 				return true;

	mov	al, 1
	pop	ebp

; 370  : 	}
; 371  : }

	ret	12					; 0000000cH
$LN181@openPageAg:

; 317  : 		}
; 318  : 
; 319  : 		for (unsigned i = 0; i < perBankQueue.size() - 1; i++)

	mov	edx, DWORD PTR [esi+8]
	sub	edx, 1
	push	ebx
	je	$LN13@openPageAg
	mov	ebx, 1
$LL15@openPageAg:

; 320  : 		{
; 321  : 			if (perBankQueue[i]->isReadOrWrite() && perBankQueue[i+1] && perBankQueue[i+1]->isBasicPrecharge())

	lea	eax, DWORD PTR [ebx-1]
	cmp	eax, DWORD PTR [esi+8]
	jge	SHORT $LN179@openPageAg
	test	eax, eax
	jl	SHORT $LN179@openPageAg
	mov	ecx, DWORD PTR [esi+36]
	sub	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [edx+ebx-1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN66@openPageAg
	call	__invalid_parameter_noinfo
$LN66@openPageAg:
	mov	ecx, DWORD PTR [esi+32]
	mov	edi, DWORD PTR [ecx+edi*4]
	jmp	SHORT $LN59@openPageAg
$LN179@openPageAg:
	xor	edi, edi
$LN59@openPageAg:
	mov	eax, DWORD PTR [edi+80]
	cmp	eax, 1
	je	SHORT $LN180@openPageAg
	cmp	eax, 2
	je	SHORT $LN180@openPageAg
	cmp	eax, 3
	je	SHORT $LN180@openPageAg
	cmp	eax, 4
	jne	SHORT $LN14@openPageAg
$LN180@openPageAg:
	cmp	ebx, DWORD PTR [esi+8]
	jge	SHORT $LN14@openPageAg
	test	ebx, ebx
	jl	SHORT $LN14@openPageAg
	mov	ecx, DWORD PTR [esi+36]
	sub	ecx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [esi+12]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebx
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+36]
	sub	edx, DWORD PTR [esi+32]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN94@openPageAg
	call	__invalid_parameter_noinfo
$LN94@openPageAg:
	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax+edi*4], 0
	je	SHORT $LN14@openPageAg
	cmp	ebx, DWORD PTR [esi+8]
	jge	SHORT $LN104@openPageAg
	mov	ecx, DWORD PTR [esi+36]
	sub	ecx, eax
	mov	eax, DWORD PTR [esi+12]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebx
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+36]
	sub	edx, DWORD PTR [esi+32]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN110@openPageAg
	call	__invalid_parameter_noinfo
$LN110@openPageAg:
	mov	eax, DWORD PTR [esi+32]
	mov	edi, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN103@openPageAg
$LN104@openPageAg:
	xor	edi, edi
$LN103@openPageAg:
	cmp	DWORD PTR [edi+80], 6
	jne	SHORT $LN14@openPageAg

; 322  : 			{
; 323  : 				availableSlots++;

	inc	ebp

; 324  : 				if (availableSlots >= 3)

	cmp	ebp, 3
	jae	$LN160@openPageAg
$LN14@openPageAg:

; 317  : 		}
; 318  : 
; 319  : 		for (unsigned i = 0; i < perBankQueue.size() - 1; i++)

	mov	edx, DWORD PTR [esi+8]
	inc	ebx
	lea	ecx, DWORD PTR [ebx-1]
	dec	edx
	cmp	ecx, edx
	jb	$LL15@openPageAg
$LN13@openPageAg:

; 325  : 					return true;
; 326  : 			}
; 327  : 		}
; 328  : 
; 329  : 		if (availableSlots == 0)

	test	ebp, ebp

; 330  : 			return false;

	je	$LN1@openPageAg

; 331  : 
; 332  : 		const unsigned currentRow = incomingTransaction->getAddress().getRow();

	mov	eax, DWORD PTR _incomingTransaction$[esp+8]

; 333  : 
; 334  : 		// look in the bank_q and see if there's a precharge for this row to insert before		
; 335  : 		// go from tail to head
; 336  : 		for (int currentIndex = perBankQueue.size() - 1; currentIndex >= 0; --currentIndex)

	mov	ebx, DWORD PTR [esi+8]
	sub	ebx, 1
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR _currentRow$130537[esp+8], ecx
	js	$LN7@openPageAg

; 337  : 		{	
; 338  : 			const Command *currentCommand = perBankQueue.read(currentIndex);

	mov	ebp, DWORD PTR _time$[esp+12]
$LL177@openPageAg:
	cmp	ebx, DWORD PTR [esi+8]
	jge	SHORT $LN178@openPageAg
	test	ebx, ebx
	jl	SHORT $LN178@openPageAg
	mov	ecx, DWORD PTR [esi+36]
	sub	ecx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [esi+12]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebx
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+36]
	sub	edx, DWORD PTR [esi+32]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN130@openPageAg
	call	__invalid_parameter_noinfo
$LN130@openPageAg:
	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN123@openPageAg
$LN178@openPageAg:
	xor	edx, edx
$LN123@openPageAg:

; 339  : 
; 340  : 			// channel, rank, bank, row all match, insert just before this precharge command
; 341  : 			if (currentCommand->isReadOrWrite() && (currentCommand->getAddress().getRow() == currentRow))

	mov	eax, DWORD PTR [edx+80]
	cmp	eax, 1
	je	SHORT $LN137@openPageAg
	cmp	eax, 2
	je	SHORT $LN137@openPageAg
	cmp	eax, 3
	je	SHORT $LN137@openPageAg
	cmp	eax, 4
	jne	SHORT $LN6@openPageAg
$LN137@openPageAg:
	mov	ecx, DWORD PTR _currentRow$130537[esp+8]
	cmp	DWORD PTR [edx+68], ecx
	je	SHORT $LN160@openPageAg
$LN6@openPageAg:

; 342  : 			{
; 343  : 				assert(currentCommand->getAddress().getChannel() == incomingTransaction->getAddress().getChannel());
; 344  : 				assert(currentCommand->getAddress().getRank() == incomingTransaction->getAddress().getRank());
; 345  : 				assert(currentCommand->getAddress().getBank() == incomingTransaction->getAddress().getBank());
; 346  : 				assert(currentCommand->getAddress().getRow() == incomingTransaction->getAddress().getRow());
; 347  : 
; 348  : 				return true;
; 349  : 			}
; 350  : 			// strict order may add to the end of the queue only
; 351  : 			// if this has not happened already then this method of insertion fails
; 352  : 			else if (systemConfig.getCommandOrderingAlgorithm() == STRICT_ORDER)

	mov	edi, DWORD PTR [esi+4]
	cmp	DWORD PTR [edi+288], 0
	je	SHORT $LN1@openPageAg

; 353  : 			{
; 354  : 				return false;
; 355  : 			}
; 356  : 			// then this command has been delayed by too many times and no more
; 357  : 			// commands can preempt it
; 358  : 			else if (time - currentCommand->getEnqueueTime() > systemConfig.getSeniorityAgeLimit())

	mov	ecx, DWORD PTR _time$[esp+8]
	sub	ecx, DWORD PTR [edx+16]
	mov	edi, DWORD PTR [edi+320]
	mov	eax, ebp
	sbb	eax, DWORD PTR [edx+20]
	xor	edx, edx
	cmp	eax, edx
	jg	SHORT $LN1@openPageAg
	jl	SHORT $LN174@openPageAg
	cmp	ecx, edi
	ja	SHORT $LN1@openPageAg
$LN174@openPageAg:

; 333  : 
; 334  : 		// look in the bank_q and see if there's a precharge for this row to insert before		
; 335  : 		// go from tail to head
; 336  : 		for (int currentIndex = perBankQueue.size() - 1; currentIndex >= 0; --currentIndex)

	sub	ebx, 1
	jns	$LL177@openPageAg
$LN7@openPageAg:

; 359  : 			{
; 360  : 				return false;
; 361  : 			}
; 362  : 		}
; 363  : 		// if the correct row is already open, just insert there
; 364  : 		// already guaranteed not to have RAW/WAR errors
; 365  : 		if (activated && openRowID == currentRow)

	cmp	BYTE PTR [esi+124], 0
	je	SHORT $LN1@openPageAg
	mov	edx, DWORD PTR _currentRow$130537[esp+8]
	cmp	DWORD PTR [esi+120], edx
	jne	SHORT $LN1@openPageAg
$LN160@openPageAg:
	pop	ebx
	pop	edi

; 366  : 		{	
; 367  : 			return true;

	mov	al, 1
	pop	ebp

; 370  : 	}
; 371  : }

	ret	12					; 0000000cH
$LN1@openPageAg:
	pop	ebx
	pop	edi

; 368  : 		}
; 369  : 		return false;

	xor	al, al
	pop	ebp

; 370  : 	}
; 371  : }

	ret	12					; 0000000cH
?openPageAggressiveInsertCheck@Bank@DRAMsimII@@QBE_NPBVTransaction@2@_J@Z ENDP ; DRAMsimII::Bank::openPageAggressiveInsertCheck
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@

; 31   : 		}

	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN19@logic_erro
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@logic_erro:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	mov	edi, DWORD PTR ___that$[esp+24]
	push	edi
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	xor	edx, edx
	mov	DWORD PTR __$EHRec$[esp+36], edx
	push	-1
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR [edi+12]
	push	edx
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	DWORD PTR [ecx+20], edx
	push	eax
	mov	BYTE PTR [ecx+4], dl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN21@length_err
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@length_err:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN22@scalar@67
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN22@scalar@67:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	ecx, esi
	mov	BYTE PTR [esi+16], al
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN32@scalar@67
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@scalar@67:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	??0exception@std@@QAE@XZ		; std::exception::exception
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+32], eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	push	-1
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	push	eax
	mov	BYTE PTR [ecx+4], al
	mov	eax, DWORD PTR __Message$[esp+28]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 27   : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN24@scalar@79
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@scalar@79:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	ecx, esi
	mov	BYTE PTR [esi+16], al
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN34@scalar@79
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@scalar@79:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T542821 = -84						; size = 28
$T542820 = -56						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T542821[esp+100]
	mov	DWORD PTR $T542821[esp+124], 15		; 0000000fH
	mov	DWORD PTR $T542821[esp+120], 0
	mov	BYTE PTR $T542821[esp+104], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T542821[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T542820[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T542820[esp+96]
	push	ecx
	mov	DWORD PTR $T542820[esp+100], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@17:
$LN44@Xlen@17:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T542821[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-76]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?reserve@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T543120 = -4						; size = 4
__Count$ = 8						; size = 4
?reserve@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXI@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::reserve, COMDAT
; _this$ = esi

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 603  : 		if (max_size() < _Count)

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	esp, 8
	push	ebx
	push	edi
	cmp	ecx, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@reserve@5

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Xlen
$LN97@reserve@5:
$LN5@reserve@5:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR [esi+12]
	test	edx, edx
	jne	SHORT $LN20@reserve@5
	xor	eax, eax
	jmp	SHORT $LN21@reserve@5
$LN20@reserve@5:
	mov	eax, DWORD PTR [esi+20]
	sub	eax, edx
	sar	eax, 2
$LN21@reserve@5:
	cmp	eax, ecx
	jae	SHORT $LN3@reserve@5

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	call	?allocate@?$allocator@PAVCommand@DRAMsimII@@@std@@QAEPAPAVCommand@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Command *>::allocate

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	edi, DWORD PTR [esi+16]
	mov	ebx, eax
	cmp	DWORD PTR [esi+12], edi
	jbe	SHORT $LN27@reserve@5
	call	__invalid_parameter_noinfo
$LN27@reserve@5:
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR $T543120[esp+16], ecx
	cmp	ecx, DWORD PTR [esi+16]
	jbe	SHORT $LN43@reserve@5
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR $T543120[esp+16]
$LN43@reserve@5:
	sub	edi, ecx
	sar	edi, 2
	test	edi, edi
	jbe	SHORT $LN86@reserve@5
	lea	eax, DWORD PTR [edi*4]
	push	eax
	push	ecx
	push	eax
	push	ebx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN86@reserve@5:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);
; 613  : 			_RERAISE;
; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+16]
	sub	edi, eax
	sar	edi, 2

; 617  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN93@reserve@5

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);
; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN93@reserve@5:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [ebx+eax*4]

; 628  : 			_Mylast = _Ptr + _Size;

	lea	edx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+16], edx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+12], ebx
$LN3@reserve@5:

; 630  : 			}
; 631  : 		}

	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN96@reserve@5:
?reserve@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXI@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::reserve
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@IABQAVCommand@DRAMsimII@@@Z
_TEXT	SEGMENT
__Newvec$134473 = -4					; size = 4
tv523 = 8						; size = 4
__Capacity$ = 8						; size = 4
_this$ = 8						; size = 4
__Tmp$134498 = 12					; size = 4
__Tmp$134488 = 12					; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?_Insert_n@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@IABQAVCommand@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Insert_n, COMDAT
; __Count$ = eax

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [ebx+12]
	push	ebp
	push	esi
	push	edi
	mov	esi, eax
	test	edx, edx
	jne	SHORT $LN29@Insert_n@8
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@8
$LN29@Insert_n@8:
	mov	eax, DWORD PTR [ebx+20]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@8:

; 1162 : 
; 1163 : 		if (_Count == 0)

	test	esi, esi
	je	$LN1@Insert_n@8

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebp, DWORD PTR [ebx+16]
	mov	eax, ebp
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, esi
	jae	SHORT $LN12@Insert_n@8

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Xlen
$LN124@Insert_n@8:
$LN12@Insert_n@8:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+esi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@8

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	edi, 1073741823				; 3fffffffH
	sub	edi, eax
	cmp	edi, ecx
	jae	SHORT $LN17@Insert_n@8
	mov	DWORD PTR __Capacity$[esp+16], 0
	mov	ecx, DWORD PTR __Capacity$[esp+16]
	jmp	SHORT $LN18@Insert_n@8
$LN17@Insert_n@8:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+16], ecx
$LN18@Insert_n@8:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@8

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+16], edx
	mov	ecx, edx
$LN9@Insert_n@8:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	call	?allocate@?$allocator@PAVCommand@DRAMsimII@@@std@@QAEPAPAVCommand@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Command *>::allocate

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebp, DWORD PTR __Where$[esp+20]
	sub	ebp, DWORD PTR [ebx+12]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[esp+16]
	sar	ebp, 2
	lea	edi, DWORD PTR [eax+ebp*4]
	mov	DWORD PTR __Newvec$134473[esp+20], eax
	call	?_Ufill@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@PAPAV34@IABQAV34@@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+20]
	mov	ecx, DWORD PTR [ebx+12]
	mov	edi, DWORD PTR __Newvec$134473[esp+20]
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN79@Insert_n@8
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edi
	call	_memmove_s
	mov	edx, DWORD PTR __Where$[esp+36]
	add	esp, 16					; 00000010H
$LN79@Insert_n@8:

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [ebx+16]
	sub	eax, edx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN110@Insert_n@8
	add	eax, eax
	add	eax, eax
	push	eax
	push	edx
	push	eax
	add	ebp, esi
	lea	eax, DWORD PTR [edi+ebp*4]
	push	eax
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN110@Insert_n@8:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [ebx+16]
	sub	ecx, eax
	sar	ecx, 2
	add	esi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN117@Insert_n@8

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN117@Insert_n@8:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+16]
	lea	eax, DWORD PTR [edi+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi+esi*4]
	mov	DWORD PTR [ebx+20], eax
	mov	DWORD PTR [ebx+16], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [ebx+12], edi

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	16					; 00000010H
$LN10@Insert_n@8:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edi, DWORD PTR __Where$[esp+20]
	mov	edx, ebp
	sub	edx, edi
	sar	edx, 2
	cmp	edx, esi
	jae	SHORT $LN3@Insert_n@8

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[esp+16]
	mov	ecx, DWORD PTR [eax]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR tv523[esp+16], eax
	lea	edx, DWORD PTR [eax+edi]
	mov	eax, ebp
	mov	DWORD PTR __Tmp$134488[esp+16], ecx
	call	??$_Umove@PAPAVCommand@DRAMsimII@@@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@PAPAV23@00@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Umove<DRAMsimII::Command * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edi, DWORD PTR [ebx+16]
	mov	edx, edi
	sub	edx, DWORD PTR __Where$[esp+20]
	sar	edx, 2
	sub	esi, edx
	lea	edx, DWORD PTR __Tmp$134488[esp+16]
	call	?_Ufill@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@PAPAV34@IABQAV34@@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv523[esp+16]
	add	DWORD PTR [ebx+16], eax
	mov	ebx, DWORD PTR [ebx+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	ecx, DWORD PTR __Tmp$134488[esp+16]
	push	ecx
	mov	ecx, ebx
	sub	ecx, eax
	mov	eax, DWORD PTR __Where$[esp+24]

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	call	??$fill@PAPAVCommand@DRAMsimII@@PAV12@@std@@YAXPAPAVCommand@DRAMsimII@@0ABQAV12@@Z ; std::fill<DRAMsimII::Command * *,DRAMsimII::Command *>
	add	esp, 4

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	16					; 00000010H
$LN3@Insert_n@8:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[esp+16]
	mov	eax, DWORD PTR [edx]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	add	esi, esi
	mov	DWORD PTR __Tmp$134498[esp+16], eax
	add	esi, esi
	mov	edi, ebp
	sub	edi, esi
	mov	edx, ebp
	mov	eax, ebp
	call	??$_Umove@PAPAVCommand@DRAMsimII@@@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEPAPAVCommand@DRAMsimII@@PAPAV23@00@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Umove<DRAMsimII::Command * *>
	mov	DWORD PTR [ebx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, edi
	mov	edi, DWORD PTR __Where$[esp+20]
	mov	ecx, ebp
	call	??$_Unchecked_move_backward@PAPAVCommand@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVCommand@DRAMsimII@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<DRAMsimII::Command * *,DRAMsimII::Command * *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+20]
	lea	ecx, DWORD PTR __Tmp$134498[esp+16]
	push	ecx
	lea	ecx, DWORD PTR [esi+eax]
	call	??$fill@PAPAVCommand@DRAMsimII@@PAV12@@std@@YAXPAPAVCommand@DRAMsimII@@0ABQAV12@@Z ; std::fill<DRAMsimII::Command * *,DRAMsimII::Command *>
	add	esp, 4
$LN1@Insert_n@8:

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	16					; 00000010H
$LN122@Insert_n@8:
?_Insert_n@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@IABQAVCommand@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Insert_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE_NI@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@16

; 1105 : 			return (false);

	xor	al, al

; 1115 : 		}

	ret	0
$LN4@Buy@16:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@16

; 1107 : 			_Xlen();	// result too long

	jmp	?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Xlen
$LN2@Buy@16:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@PAVCommand@DRAMsimII@@@std@@QAEPAPAVCommand@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Command *>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1

; 1115 : 		}

	ret	0
?_Buy@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXIPAVCommand@DRAMsimII@@@Z
_TEXT	SEGMENT
$T566233 = -24						; size = 8
$T566235 = -16						; size = 8
$T566231 = -16						; size = 8
$T566234 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 8						; size = 4
?resize@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXIPAVCommand@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::resize, COMDAT
; _this$ = eax

; 717  : 		{	// determine new length, padding with _Val elements as needed

	sub	esp, 24					; 00000018H
	push	ebx
	mov	ebx, DWORD PTR __Newsize$[esp+24]
	push	ebp
	push	esi
	mov	esi, eax

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR [esi+12]
	push	edi
	mov	edi, DWORD PTR [esi+16]
	mov	eax, edi
	sub	eax, ecx
	sar	eax, 2
	mov	DWORD PTR __Val$[esp+36], 0
	cmp	ebx, eax
	jbe	SHORT $LN60@resize@3

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	cmp	ecx, edi
	jbe	SHORT $LN13@resize@3
	call	__invalid_parameter_noinfo
$LN13@resize@3:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	push	edi
	push	eax
	lea	eax, DWORD PTR __Val$[esp+44]
	push	eax
	sar	ecx, 2
	mov	eax, ebx
	sub	eax, ecx
	push	esi
	call	?_Insert_n@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@IABQAVCommand@DRAMsimII@@@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Insert_n

; 722  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN60@resize@3:

; 720  : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize@3

; 721  : 			erase(begin() + _Newsize, end());

	cmp	ecx, edi
	jbe	SHORT $LN33@resize@3
	call	__invalid_parameter_noinfo
$LN33@resize@3:
	mov	ebp, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR $T566231[esp+40], edx
	cmp	ebp, DWORD PTR [esi+16]
	jbe	SHORT $LN49@resize@3
	call	__invalid_parameter_noinfo
$LN49@resize@3:
	mov	eax, DWORD PTR [esi]
	push	ebx
	lea	ecx, DWORD PTR $T566234[esp+44]
	mov	DWORD PTR $T566233[esp+44], eax
	push	ecx
	lea	eax, DWORD PTR $T566233[esp+48]
	mov	DWORD PTR $T566233[esp+52], ebp
	call	??H?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::operator+
	mov	edx, DWORD PTR $T566231[esp+40]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T566235[esp+56]
	push	eax
	call	?erase@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@2@0@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::erase
$LN1@resize@3:

; 722  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
?resize@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXIPAVCommand@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Construct_n@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXIABQAVCommand@DRAMsimII@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Construct_n@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXIABQAVCommand@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Construct_n, COMDAT
; _this$ = esi
; __Count$ = edi

; 545  : 		{	// construct from _Count * _Val

	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	push	ebp

; 546  : 		if (_Buy(_Count))

	xor	ebp, ebp
	mov	DWORD PTR [esi+12], ebp
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebp
	cmp	edi, ebp
	je	SHORT $LN5@Construct_@7
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN10@Construct_@7
	call	?_Xlen@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Xlen
$LN50@Construct_@7:
$LN10@Construct_@7:
	mov	ecx, edi
	call	?allocate@?$allocator@PAVCommand@DRAMsimII@@@std@@QAEPAPAVCommand@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Command *>::allocate
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	ecx, edi
	mov	edx, eax
	cmp	edi, ebp
	jbe	SHORT $LN40@Construct_@7
	npad	3
$LL42@Construct_@7:
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR [edx], ebp
	dec	ecx
	add	edx, 4
	test	ecx, ecx
	ja	SHORT $LL42@Construct_@7
$LN40@Construct_@7:
	lea	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+16], edx
$LN5@Construct_@7:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();
; 552  : 			_RERAISE;
; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	pop	ebp
	pop	ebx
	ret	4
$LN49@Construct_@7:
?_Construct_n@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXIABQAVCommand@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Construct_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?resize@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXI@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::resize, COMDAT
; __Newsize$ = eax

; 713  : 		resize(_Newsize, _Ty());

	push	eax
	mov	eax, DWORD PTR _this$[esp]
	call	?resize@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXIPAVCommand@DRAMsimII@@@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::resize

; 714  : 		}

	ret	4
?resize@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXI@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::resize
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
$T566656 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@I@Z PROC ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >, COMDAT
; __Count$ = edi

; 482  : 		{	// construct from _Count * _Ty()

	push	-1
	push	__ehhandler$??0?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@44
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@44
$LN13@vector@44:
	xor	eax, eax
$LN14@vector@44:
	mov	DWORD PTR [esi], eax

; 483  : 		_Construct_n(_Count, _Ty());

	lea	eax, DWORD PTR $T566656[esp+24]
	mov	DWORD PTR __$EHRec$[esp+32], ecx
	push	eax
	mov	DWORD PTR $T566656[esp+28], ecx
	call	?_Construct_n@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXIABQAVCommand@DRAMsimII@@@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::_Construct_n

; 484  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@I@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@I@Z ENDP ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z$11
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
_TEXT	SEGMENT
$T582604 = -48						; size = 8
$T582603 = -48						; size = 8
__Ok$ = -40						; size = 8
__Nput_fac$136929 = -32					; size = 4
$T582645 = -28						; size = 1
__Lock$582638 = -28					; size = 4
$T582600 = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Val$ = 12						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT

; 451  : 		{	// insert a void pointer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR _this$[ebp]

; 452  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 453  : 		const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __State$[ebp], edi
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], edi

; 454  : 
; 455  : 		if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	je	$LN13@operator@327

; 456  : 			{	// state okay, use facet to insert
; 457  : 			const _Nput& _Nput_fac = _USE(ios_base::getloc(), _Nput);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T582600[ebp]
	push	eax
	add	ecx, esi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	ebx, DWORD PTR $T582600[ebp]
	mov	DWORD PTR __Nput_fac$136929[ebp], eax
	test	ebx, ebx
	je	SHORT $LN19@operator@327
	push	0
	lea	ecx, DWORD PTR __Lock$582638[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jbe	SHORT $LN21@operator@327
	cmp	eax, -1
	jae	SHORT $LN21@operator@327
	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN21@operator@327:
	mov	edi, DWORD PTR [ebx+4]
	neg	edi
	sbb	edi, edi
	not	edi
	lea	ecx, DWORD PTR __Lock$582638[ebp]
	and	edi, ebx
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	edi, edi
	je	SHORT $LN19@operator@327
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, edi
	call	eax
$LN19@operator@327:

; 458  : 
; 459  : 			_TRY_IO_BEGIN
; 460  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 461  : 				_Myios::fill(), _Val).failed())

	mov	ebx, DWORD PTR __Val$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR [ecx+esi+48]
	add	ecx, esi
	mov	ecx, DWORD PTR [ecx+40]
	push	ebx
	mov	BYTE PTR $T582645[ebp], dl
	mov	ebx, DWORD PTR $T582645[ebp]
	mov	edx, DWORD PTR __Nput_fac$136929[ebp]
	mov	edi, DWORD PTR [edx]
	push	ebx
	add	eax, esi
	push	eax
	push	ecx
	mov	BYTE PTR $T582603[ebp], 0
	mov	eax, DWORD PTR $T582603[ebp]
	push	eax
	lea	ecx, DWORD PTR $T582604[ebp]
	push	ecx
	mov	ecx, edx
	mov	edx, DWORD PTR [edi+4]
	call	edx
	cmp	BYTE PTR $T582604[ebp], 0
	je	SHORT $LN1@operator@327

; 462  : 				_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4
$LN1@operator@327:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN13@operator@327
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z$0:

; 463  : 			_CATCH_IO_END

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	or	eax, 4
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN42@operator@327
	or	eax, 4
$LN42@operator@327:
	push	1
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN79@operator@327
	ret	0
$LN79@operator@327:
	mov	esi, DWORD PTR _this$[ebp]
$LN13@operator@327:

; 464  : 			}
; 465  : 
; 466  : 		_Myios::setstate(_State);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __State$[ebp]
	add	ecx, esi
	test	edx, edx
	je	SHORT $LN71@operator@327
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN73@operator@327
	or	eax, 4
$LN73@operator@327:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN71@operator@327:

; 467  : 		return (*this);

	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, esi

; 468  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z$3:
	lea	ecx, DWORD PTR $T582600[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$11
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
_TEXT	SEGMENT
$T582749 = -52						; size = 8
__Ok$ = -44						; size = 8
__Nput_fac$130952 = -36					; size = 4
$T582798 = -32						; size = 1
__Lock$582784 = -32					; size = 4
$T582746 = -28						; size = 4
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
$T582750 = 12						; size = 8
__Val$ = 12						; size = 8
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT

; 350  : 		{	// insert a long long

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR _this$[ebp]

; 351  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 352  : 		const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __State$[ebp], edi
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], edi

; 353  : 
; 354  : 		if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	je	$LN13@operator@328

; 355  : 			{	// state okay, use facet to insert
; 356  : 			const _Nput& _Nput_fac = _USE(ios_base::getloc(), _Nput);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T582746[ebp]
	push	eax
	add	ecx, esi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	ebx, DWORD PTR $T582746[ebp]
	mov	DWORD PTR __Nput_fac$130952[ebp], eax
	test	ebx, ebx
	je	SHORT $LN19@operator@328
	push	0
	lea	ecx, DWORD PTR __Lock$582784[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jbe	SHORT $LN21@operator@328
	cmp	eax, -1
	jae	SHORT $LN21@operator@328
	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN21@operator@328:
	mov	edi, DWORD PTR [ebx+4]
	neg	edi
	sbb	edi, edi
	not	edi
	lea	ecx, DWORD PTR __Lock$582784[ebp]
	and	edi, ebx
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	edi, edi
	je	SHORT $LN19@operator@328
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, edi
	call	eax
$LN19@operator@328:

; 357  : 
; 358  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 359  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 360  : 				_Myios::fill(), _Val).failed())

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+esi+40]
	mov	ebx, DWORD PTR __Val$[ebp+4]
	push	ebx
	mov	ebx, DWORD PTR __Val$[ebp]
	add	ecx, esi
	mov	cl, BYTE PTR [ecx+48]
	push	ebx
	mov	BYTE PTR $T582798[ebp], cl
	mov	ebx, DWORD PTR $T582798[ebp]
	mov	ecx, DWORD PTR __Nput_fac$130952[ebp]
	mov	edi, DWORD PTR [ecx]
	push	ebx
	add	eax, esi
	push	eax
	push	edx
	mov	BYTE PTR $T582749[ebp], 0
	mov	edx, DWORD PTR $T582749[ebp]
	push	edx
	mov	edx, DWORD PTR [edi+20]
	lea	eax, DWORD PTR $T582750[ebp]
	push	eax
	call	edx
	cmp	BYTE PTR $T582750[ebp], 0
	je	SHORT $LN1@operator@328

; 361  : 				_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4
$LN1@operator@328:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN13@operator@328
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$0:

; 362  : 			_CATCH_IO_END

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	or	eax, 4
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN42@operator@328
	or	eax, 4
$LN42@operator@328:
	push	1
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN79@operator@328
	ret	0
$LN79@operator@328:
	mov	esi, DWORD PTR _this$[ebp]
$LN13@operator@328:

; 363  : 			}
; 364  : 
; 365  : 		_Myios::setstate(_State);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __State$[ebp]
	add	ecx, esi
	test	edx, edx
	je	SHORT $LN71@operator@328
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN73@operator@328
	or	eax, 4
$LN73@operator@328:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN71@operator@328:

; 366  : 		return (*this);

	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, esi

; 367  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$3:
	lea	ecx, DWORD PTR $T582746[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$11
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z
_TEXT	SEGMENT
$T582896 = -48						; size = 8
$T582895 = -48						; size = 8
__Ok$ = -40						; size = 8
__Nput_fac$130730 = -32					; size = 4
$T582937 = -28						; size = 1
__Lock$582930 = -28					; size = 4
$T582892 = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Val$ = 12						; size = 1
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT

; 191  : 		{	// insert a boolean

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR _this$[ebp]

; 192  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 193  : 		const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __State$[ebp], edi
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], edi

; 194  : 
; 195  : 		if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	je	$LN13@operator@329

; 196  : 			{	// state okay, use facet to insert
; 197  : 			const _Nput& _Nput_fac = _USE(ios_base::getloc(), _Nput);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T582892[ebp]
	push	eax
	add	ecx, esi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	ebx, DWORD PTR $T582892[ebp]
	mov	DWORD PTR __Nput_fac$130730[ebp], eax
	test	ebx, ebx
	je	SHORT $LN19@operator@329
	push	0
	lea	ecx, DWORD PTR __Lock$582930[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jbe	SHORT $LN21@operator@329
	cmp	eax, -1
	jae	SHORT $LN21@operator@329
	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN21@operator@329:
	mov	edi, DWORD PTR [ebx+4]
	neg	edi
	sbb	edi, edi
	not	edi
	lea	ecx, DWORD PTR __Lock$582930[ebp]
	and	edi, ebx
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	edi, edi
	je	SHORT $LN19@operator@329
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, edi
	call	eax
$LN19@operator@329:

; 198  : 
; 199  : 			_TRY_IO_BEGIN
; 200  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 201  : 				_Myios::fill(), _Val).failed())

	mov	ebx, DWORD PTR __Val$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR [ecx+esi+48]
	add	ecx, esi
	mov	ecx, DWORD PTR [ecx+40]
	push	ebx
	mov	BYTE PTR $T582937[ebp], dl
	mov	ebx, DWORD PTR $T582937[ebp]
	mov	edx, DWORD PTR __Nput_fac$130730[ebp]
	mov	edi, DWORD PTR [edx]
	push	ebx
	add	eax, esi
	push	eax
	push	ecx
	mov	BYTE PTR $T582895[ebp], 0
	mov	eax, DWORD PTR $T582895[ebp]
	push	eax
	lea	ecx, DWORD PTR $T582896[ebp]
	push	ecx
	mov	ecx, edx
	mov	edx, DWORD PTR [edi+32]
	call	edx
	cmp	BYTE PTR $T582896[ebp], 0
	je	SHORT $LN1@operator@329

; 202  : 				_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4
$LN1@operator@329:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN13@operator@329
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$0:

; 203  : 			_CATCH_IO_END

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	or	eax, 4
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN42@operator@329
	or	eax, 4
$LN42@operator@329:
	push	1
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN79@operator@329
	ret	0
$LN79@operator@329:
	mov	esi, DWORD PTR _this$[ebp]
$LN13@operator@329:

; 204  : 			}
; 205  : 
; 206  : 		_Myios::setstate(_State);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __State$[ebp]
	add	ecx, esi
	test	edx, edx
	je	SHORT $LN71@operator@329
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN73@operator@329
	or	eax, 4
$LN73@operator@329:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN71@operator@329:

; 207  : 		return (*this);

	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, esi

; 208  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$3:
	lea	ecx, DWORD PTR $T582892[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
;	COMDAT ??$?6VCommand@DRAMsimII@@@DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABV?$Queue@VCommand@DRAMsimII@@@0@@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
??$?6VCommand@DRAMsimII@@@DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABV?$Queue@VCommand@DRAMsimII@@@0@@Z PROC ; DRAMsimII::operator<<<DRAMsimII::Command>, COMDAT
; _theQueue$ = edi

; 460  : 	{

	push	ebp

; 461  : 		in << "Queue S[" << std::dec << theQueue.entry.size() << "] C[" << std::dec << theQueue.count << "] H[" << std::dec << theQueue.head << "] T[" << std::dec << theQueue.tail << "] P[" << theQueue.pool << "]" << std::endl;

	mov	ebp, DWORD PTR _in$[esp]
	push	esi
	mov	esi, DWORD PTR [edi+28]
	sub	esi, DWORD PTR [edi+24]
	push	OFFSET ??_C@_08NMFLJNNF@Queue?5S?$FL?$AA@
	push	ebp
	sar	esi, 2
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@operator@353
	xor	ecx, ecx
	jmp	SHORT $LN12@operator@353
$LN11@operator@353:
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
$LN12@operator@353:
	mov	edx, DWORD PTR [ecx+16]
	push	OFFSET ??_C@_04HCPPBLKA@?$FN?5C?$FL?$AA@
	and	edx, -3073				; fffff3ffH
	push	esi
	or	edx, 512				; 00000200H
	push	eax
	mov	DWORD PTR [ecx+16], edx
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@operator@353
	xor	ecx, ecx
	jmp	SHORT $LN20@operator@353
$LN19@operator@353:
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
$LN20@operator@353:
	mov	edx, DWORD PTR [ecx+16]
	and	edx, -3073				; fffff3ffH
	or	edx, 512				; 00000200H
	mov	DWORD PTR [ecx+16], edx
	mov	ecx, DWORD PTR [edi]
	push	OFFSET ??_C@_04HOKKPEEB@?$FN?5H?$FL?$AA@
	push	ecx
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@operator@353
	xor	ecx, ecx
	jmp	SHORT $LN28@operator@353
$LN27@operator@353:
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, eax
$LN28@operator@353:
	mov	edx, DWORD PTR [ecx+16]
	and	edx, -3073				; fffff3ffH
	or	edx, 512				; 00000200H
	mov	DWORD PTR [ecx+16], edx
	mov	ecx, DWORD PTR [edi+4]
	push	OFFSET ??_C@_04GLJGKOFF@?$FN?5T?$FL?$AA@
	push	ecx
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN35@operator@353
	xor	ecx, ecx
	jmp	SHORT $LN36@operator@353
$LN35@operator@353:
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, eax
$LN36@operator@353:
	mov	edx, DWORD PTR [ecx+16]
	and	edx, -3073				; fffff3ffH
	or	edx, 512				; 00000200H
	mov	DWORD PTR [ecx+16], edx
	movzx	ecx, BYTE PTR [edi+36]
	mov	edx, DWORD PTR [edi+8]
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	push	ecx
	push	OFFSET ??_C@_04GMJPAGIJ@?$FN?5P?$FL?$AA@
	push	edx
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 462  : 		if (theQueue.entry.size())

	mov	eax, DWORD PTR [edi+28]
	sub	eax, DWORD PTR [edi+24]
	test	eax, -4					; fffffffcH
	je	$LN90@operator@353

; 463  : 		{
; 464  : 			for (unsigned i = 0; i < theQueue.count; i++)

	mov	eax, DWORD PTR [edi]
	push	ebx
	xor	ebx, ebx
	test	eax, eax
	ja	SHORT $LN3@operator@353
	pop	ebx
	pop	esi

; 467  : 			}
; 468  : 		}
; 469  : 		return in;

	mov	eax, ebp
	pop	ebp

; 470  : 	}

	ret	0
$LL91@operator@353:

; 463  : 		{
; 464  : 			for (unsigned i = 0; i < theQueue.count; i++)

	mov	ebp, DWORD PTR _in$[esp+8]
$LN3@operator@353:

; 465  : 			{
; 466  : 				in << "\t" << theQueue[i] << std::endl;

	cmp	ebx, eax
	jge	SHORT $LN93@operator@353
	test	ebx, ebx
	jl	SHORT $LN93@operator@353
	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [edi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebx
	div	ecx
	mov	esi, edx
	mov	edx, DWORD PTR [edi+28]
	sub	edx, DWORD PTR [edi+24]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN58@operator@353
	call	__invalid_parameter_noinfo
$LN58@operator@353:
	mov	eax, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN51@operator@353
$LN93@operator@353:
	xor	eax, eax
$LN51@operator@353:
	push	eax
	push	OFFSET ??_C@_01GPOEFGEJ@?7?$AA@
	push	ebp
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	xor	ebp, ebp
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN92@operator@353
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN92@operator@353
	mov	ebp, 4
$LN92@operator@353:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebp, ebp
	je	SHORT $LN2@operator@353
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebp
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN85@operator@353
	or	eax, 4
$LN85@operator@353:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN2@operator@353:
	mov	eax, DWORD PTR [edi]
	inc	ebx
	cmp	ebx, eax
	jb	$LL91@operator@353

; 467  : 			}
; 468  : 		}
; 469  : 		return in;

	mov	eax, DWORD PTR _in$[esp+8]
	pop	ebx
	pop	esi
	pop	ebp

; 470  : 	}

	ret	0
$LN90@operator@353:
	pop	esi

; 467  : 			}
; 468  : 		}
; 469  : 		return in;

	mov	eax, ebp
	pop	ebp

; 470  : 	}

	ret	0
??$?6VCommand@DRAMsimII@@@DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABV?$Queue@VCommand@DRAMsimII@@@0@@Z ENDP ; DRAMsimII::operator<<<DRAMsimII::Command>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@H@Z
_TEXT	SEGMENT
_item$ = 8						; size = 4
_offset$ = 12						; size = 4
?insert@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@H@Z PROC ; DRAMsimII::Queue<DRAMsimII::Command>::insert, COMDAT
; _this$ = eax

; 310  : 		{

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 311  : 			assert(offset <= (int)count);
; 312  : 
; 313  : 			if (count == entry.size())

	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	push	edi
	mov	edi, DWORD PTR [esi]
	sar	eax, 2
	cmp	edi, eax

; 314  : 				return false;

	je	SHORT $LN41@insert@18

; 315  : 
; 316  : 			else if (item == NULL)

	cmp	DWORD PTR _item$[esp+16], 0
	jne	SHORT $LN5@insert@18

; 317  : 			{
; 318  : 				std::cerr << "Attempting to insert NULL into queue" << std::endl;

	push	OFFSET ??_C@_0CF@LLADOICC@Attempting?5to?5insert?5NULL?5into?5q@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN41@insert@18:

; 319  : 				return false;

	xor	al, al

; 333  : 
; 334  : 				return true;
; 335  : 			}
; 336  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
$LN5@insert@18:

; 320  : 				//_exit(2);
; 321  : 			}
; 322  : 			else
; 323  : 			{
; 324  : 				// move everything back by one unit
; 325  : 				for (int i = count - 1 ; i >= offset ; --i)

	dec	edi
	cmp	edi, DWORD PTR _offset$[esp+16]
	jl	SHORT $LN1@insert@18
$LL3@insert@18:

; 326  : 					entry[(head + i + 1) % entry.size()] = entry[(head + i) % entry.size()];

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	ebx, edx
	jb	SHORT $LN18@insert@18
	call	__invalid_parameter_noinfo
$LN18@insert@18:
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [esi+4]
	sub	ecx, eax
	lea	ebp, DWORD PTR [eax+ebx*4]
	lea	eax, DWORD PTR [edx+edi+1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	ebx, edx
	cmp	ebx, eax
	jb	SHORT $LN25@insert@18
	call	__invalid_parameter_noinfo
$LN25@insert@18:
	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [ebp]
	dec	edi
	cmp	edi, DWORD PTR _offset$[esp+16]
	mov	DWORD PTR [ecx+ebx*4], edx
	jge	SHORT $LL3@insert@18
$LN1@insert@18:

; 327  : 
; 328  : 				count++;

	inc	DWORD PTR [esi]

; 329  : 
; 330  : 				entry[(head + offset) % entry.size()] = item;

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	add	eax, DWORD PTR _offset$[esp+16]
	xor	edx, edx
	sar	ecx, 2
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN32@insert@18
	call	__invalid_parameter_noinfo
$LN32@insert@18:
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR _item$[esp+16]
	mov	DWORD PTR [eax+edi*4], ecx

; 331  : 
; 332  : 				tail = (tail + 1) % entry.size();	// advance tail_ptr

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+8]
	inc	eax
	sar	ecx, 2
	xor	edx, edx
	div	ecx

; 333  : 
; 334  : 				return true;
; 335  : 			}
; 336  : 		}

	pop	edi
	mov	al, 1
	mov	DWORD PTR [esi+8], edx
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
?insert@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@H@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z
_TEXT	SEGMENT
_item$ = 8						; size = 4
?push_front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Command>::push_front, COMDAT
; _this$ = eax

; 167  : 		{

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _item$[esp+4]
	push	esi
	mov	esi, eax

; 168  : 			assert(item != NULL);
; 169  : 			if (count == entry.size())

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi]
	sar	ecx, 2
	push	edi
	cmp	eax, ecx

; 170  : 				return false;

	je	SHORT $LN22@push_front@3

; 171  : 			else if (item == NULL)

	test	ebx, ebx
	jne	SHORT $LN2@push_front@3

; 172  : 			{
; 173  : 				std::cerr << "Input pointer is NULL" << std::endl;

	push	OFFSET ??_C@_0BG@KEOIJAJD@Input?5pointer?5is?5NULL?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN22@push_front@3:

; 174  : 				return false;

	xor	al, al

; 181  : 				return true;
; 182  : 			}
; 183  : 		}

	pop	edi
	pop	esi
	pop	ebx
	pop	ecx
	ret	4
$LN2@push_front@3:

; 175  : 			}
; 176  : 			else
; 177  : 			{
; 178  : 				count++;

	inc	eax
	mov	DWORD PTR [esi], eax

; 179  : 				head = ((int)head > 0) ? head - 1 : entry.size() - 1;

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jle	SHORT $LN7@push_front@3
	lea	edi, DWORD PTR [eax-1]
	jmp	SHORT $LN8@push_front@3
$LN7@push_front@3:
	mov	edi, DWORD PTR [esi+28]
	sub	edi, DWORD PTR [esi+24]
	sar	edi, 2
	dec	edi
$LN8@push_front@3:
	mov	DWORD PTR [esi+4], edi

; 180  : 				entry[head] = item;

	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN17@push_front@3
	call	__invalid_parameter_noinfo
$LN17@push_front@3:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], ebx

; 181  : 				return true;
; 182  : 			}
; 183  : 		}

	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx
	pop	ecx
	ret	4
?push_front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::push_front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z
_TEXT	SEGMENT
_item$ = 8						; size = 4
?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Command>::push, COMDAT
; _this$ = eax

; 147  : 		{

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _item$[esp+4]
	push	esi
	mov	esi, eax

; 148  : 			assert(item != NULL);
; 149  : 			if (count == entry.size())

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi]
	sar	ecx, 2
	push	edi
	cmp	eax, ecx

; 150  : 				return false;

	je	SHORT $LN20@push@3

; 151  : 			else if (item == NULL)

	test	ebx, ebx
	jne	SHORT $LN2@push@3

; 152  : 			{
; 153  : 				std::cerr << "Input pointer is NULL" << std::endl;

	push	OFFSET ??_C@_0BG@KEOIJAJD@Input?5pointer?5is?5NULL?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN20@push@3:

; 154  : 				return false;

	xor	al, al

; 161  : 				return true;
; 162  : 			}
; 163  : 		}

	pop	edi
	pop	esi
	pop	ebx
	pop	ecx
	ret	4
$LN2@push@3:

; 155  : 			}
; 156  : 			else
; 157  : 			{
; 158  : 				count++;
; 159  : 				entry[tail] = item;

	mov	edi, DWORD PTR [esi+8]
	inc	eax
	mov	DWORD PTR [esi], eax
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN13@push@3
	call	__invalid_parameter_noinfo
$LN13@push@3:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], ebx

; 160  : 				tail = (tail + 1) % entry.size(); 	//advance tail_ptr

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+8]
	inc	eax
	sar	ecx, 2
	xor	edx, edx
	div	ecx

; 161  : 				return true;
; 162  : 			}
; 163  : 		}

	pop	edi
	mov	al, 1
	mov	DWORD PTR [esi+8], edx
	pop	esi
	pop	ebx
	pop	ecx
	ret	4
?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::push
_TEXT	ENDS
PUBLIC	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVBank@0@@Z ; DRAMsimII::operator<<
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.cpp
_TEXT	SEGMENT
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVBank@0@@Z PROC ; DRAMsimII::operator<<
; _in$ = eax
; _pc$ = ecx

; 566  : {

	push	ebx
	push	esi
	push	edi

; 567  : 	return in << "PBQ" << endl << pc.perBankQueue << "last RAS [" << pc.lastRASTime << "] act[" <<
; 568  : 		pc.activated << "] open row[" << pc.openRowID << "]" << endl;	

	push	OFFSET ??_C@_03MFAIBKPK@PBQ?$AA@
	push	eax
	mov	esi, ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	ecx, DWORD PTR [esi+120]
	movzx	edx, BYTE PTR [esi+124]
	mov	eax, DWORD PTR [esi+52]
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	push	ecx
	mov	ecx, DWORD PTR [esi+48]
	push	OFFSET ??_C@_0M@NMKFEDGM@?$FN?5open?5row?$FL?$AA@
	push	edx
	push	OFFSET ??_C@_06KAELOPMD@?$FN?5act?$FL?$AA@
	push	eax
	push	ecx
	push	OFFSET ??_C@_0L@ECHFMGHC@last?5RAS?5?$FL?$AA@
	lea	edi, DWORD PTR [esi+8]
	push	ebx
	call	??$?6VCommand@DRAMsimII@@@DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABV?$Queue@VCommand@DRAMsimII@@@0@@Z ; DRAMsimII::operator<<<DRAMsimII::Command>
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 569  : }

	ret	0
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVBank@0@@Z ENDP ; DRAMsimII::operator<<
_TEXT	ENDS
PUBLIC	?issuePRE@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z	; DRAMsimII::Bank::issuePRE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T612744 = -16						; size = 8
$T612743 = -16						; size = 8
$T612745 = -8						; size = 8
$T612742 = -8						; size = 8
$T612746 = 8						; size = 8
_currentTime$ = 8					; size = 8
?issuePRE@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z PROC	; DRAMsimII::Bank::issuePRE
; _this$ = ecx
; _currentCommand$ = eax

; 161  : 	switch (currentCommand->getCommandType())

	mov	eax, DWORD PTR [eax+80]
	sub	esp, 16					; 00000010H
	sub	eax, 2
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	je	$LN4@issuePRE@2
	sub	eax, 2
	je	SHORT $LN3@issuePRE@2
	sub	eax, 2
	je	SHORT $LN2@issuePRE@2

; 175  : 		break;
; 176  : 	default:
; 177  : 		cerr << "Unhandled CAS variant" << endl;

	push	OFFSET ??_C@_0BG@GJDAHMDK@Unhandled?5CAS?5variant?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	edi, eax
	push	10					; 0000000aH
	mov	ecx, edi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, edi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 178  : 		break;

	jmp	$LN5@issuePRE@2
$LN2@issuePRE@2:

; 172  : 		break;
; 173  : 	case Command::PRECHARGE:
; 174  : 		lastPrechargeTime = max(lastPrechargeTime, currentTime);

	mov	ecx, DWORD PTR [esi+76]
	cmp	ecx, DWORD PTR _currentTime$[esp+28]
	lea	eax, DWORD PTR [esi+72]
	jg	SHORT $LN27@issuePRE@2
	jl	SHORT $LN61@issuePRE@2
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR _currentTime$[esp+24]
	jae	SHORT $LN27@issuePRE@2
$LN61@issuePRE@2:
	lea	ecx, DWORD PTR _currentTime$[esp+24]
	jmp	SHORT $LN28@issuePRE@2
$LN3@issuePRE@2:

; 167  : 		break;
; 168  : 	case Command::WRITE_AND_PRECHARGE:
; 169  : 		// see figure 11.29 in Memory Systems: Cache, DRAM, Disk by Bruce Jacob, et al.
; 170  : 		// obeys minimum timing, but also supports tRAS lockout
; 171  : 		lastPrechargeTime = max(lastPrechargeTime, max(currentTime + (timing.tAL() + timing.tCWD() + timing.tBurst() + timing.tWR()), lastRASTime + timing.tRAS()));

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+28]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [ecx+60]
	mov	edi, edx
	adc	edi, DWORD PTR [esi+52]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR $T612744[esp+28], ebx
	add	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T612744[esp+32], edi
	add	eax, DWORD PTR [ecx]
	cdq
	add	eax, DWORD PTR _currentTime$[esp+24]
	adc	edx, DWORD PTR _currentTime$[esp+28]
	mov	DWORD PTR $T612745[esp+28], eax
	cmp	edx, edi
	mov	DWORD PTR $T612745[esp+32], edx
	jg	$LN64@issuePRE@2
	jl	SHORT $LN23@issuePRE@2
	cmp	eax, ebx
	jae	$LN64@issuePRE@2

; 162  : 	{
; 163  : 	case Command::READ_AND_PRECHARGE:
; 164  : 		//lastPrechargeTime = max(currentTime + timing.tAL() + timing.tCAS() + timing.tBurst() + timing.tRTP(), lastRASTime + timing.tRAS());
; 165  : 		// see figure 11.28 in Memory Systems: Cache, DRAM, Disk by Bruce Jacob, et al.
; 166  : 		lastPrechargeTime = max(lastPrechargeTime, max(currentTime + (timing.tAL() - timing.tCCD() + timing.tBurst() + timing.tRTP()), lastRASTime + timing.tRAS()));

$LN23@issuePRE@2:
	lea	ecx, DWORD PTR $T612743[esp+28]
$LN24@issuePRE@2:
	mov	edx, DWORD PTR [esi+76]
	cmp	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [esi+72]
	jg	SHORT $LN27@issuePRE@2
	jl	SHORT $LN28@issuePRE@2
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jb	SHORT $LN28@issuePRE@2
$LN27@issuePRE@2:
	mov	ecx, eax
$LN28@issuePRE@2:
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@issuePRE@2:

; 179  : 	}	
; 180  : 
; 181  : 	// make sure precharges follow activates
; 182  : 	// technically, you can pre after pre, but there's no good reason for this
; 183  : 	assert(activated == true);
; 184  : 	activated = false;
; 185  : 
; 186  : 	// calculate when the next few commands can happen
; 187  : 	nextActivateTime = max(nextActivateTime, lastPrechargeTime + timing.tRP());

	mov	edx, DWORD PTR [esi]
	mov	BYTE PTR [esi+124], 0
	mov	eax, DWORD PTR [edx+44]
	cdq
	add	eax, DWORD PTR [esi+72]
	lea	ecx, DWORD PTR [esi+88]
	adc	edx, DWORD PTR [esi+76]
	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, edx
	mov	DWORD PTR $T612746[esp+24], eax
	mov	DWORD PTR $T612746[esp+28], edx
	jg	SHORT $LN59@issuePRE@2
	jl	SHORT $LN66@issuePRE@2
	mov	edx, DWORD PTR [ecx]
	cmp	edx, eax
	jae	SHORT $LN59@issuePRE@2
$LN66@issuePRE@2:
	lea	eax, DWORD PTR $T612746[esp+24]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax

; 188  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
$LN4@issuePRE@2:

; 162  : 	{
; 163  : 	case Command::READ_AND_PRECHARGE:
; 164  : 		//lastPrechargeTime = max(currentTime + timing.tAL() + timing.tCAS() + timing.tBurst() + timing.tRTP(), lastRASTime + timing.tRAS());
; 165  : 		// see figure 11.28 in Memory Systems: Cache, DRAM, Disk by Bruce Jacob, et al.
; 166  : 		lastPrechargeTime = max(lastPrechargeTime, max(currentTime + (timing.tAL() - timing.tCCD() + timing.tBurst() + timing.tRTP()), lastRASTime + timing.tRAS()));

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+28]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [ecx+52]
	mov	edi, edx
	adc	edi, DWORD PTR [esi+52]
	sub	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR $T612742[esp+28], ebx
	add	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T612742[esp+32], edi
	add	eax, DWORD PTR [ecx]
	cdq
	add	eax, DWORD PTR _currentTime$[esp+24]
	adc	edx, DWORD PTR _currentTime$[esp+28]
	mov	DWORD PTR $T612743[esp+28], eax
	cmp	edx, edi
	mov	DWORD PTR $T612743[esp+32], edx
	jg	$LN23@issuePRE@2
	jl	SHORT $LN64@issuePRE@2
	cmp	eax, ebx
	jae	$LN23@issuePRE@2
$LN64@issuePRE@2:
	lea	ecx, DWORD PTR $T612742[esp+28]
	jmp	$LN24@issuePRE@2

; 179  : 	}	
; 180  : 
; 181  : 	// make sure precharges follow activates
; 182  : 	// technically, you can pre after pre, but there's no good reason for this
; 183  : 	assert(activated == true);
; 184  : 	activated = false;
; 185  : 
; 186  : 	// calculate when the next few commands can happen
; 187  : 	nextActivateTime = max(nextActivateTime, lastPrechargeTime + timing.tRP());

$LN59@issuePRE@2:
	mov	eax, ecx
	mov	edx, DWORD PTR [eax]

; 188  : }

	pop	edi
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	pop	esi
	mov	DWORD PTR [ecx+4], eax
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
?issuePRE@Bank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ENDP	; DRAMsimII::Bank::issuePRE
;	COMDAT xdata$x
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.cpp
xdata$x	SEGMENT
__unwindtable$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$1
__ehfuncinfo$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
xdata$x	ENDS
;	COMDAT ??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T626925 = 12						; size = 4
_preallocate$ = 12					; size = 1
??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z PROC ; DRAMsimII::Queue<DRAMsimII::Command>::Queue<DRAMsimII::Command>, COMDAT
; _size$ = ecx

; 88   : 		{

	push	-1
	push	__ehhandler$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ebp, DWORD PTR _this$[esp+32]
	xor	esi, esi
	lea	ebx, DWORD PTR [ebp+12]
	push	ebx
	mov	DWORD PTR [ebp], esi
	mov	DWORD PTR [ebp+4], esi
	mov	DWORD PTR [ebp+8], esi
	call	??0?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@I@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
	mov	DWORD PTR __$EHRec$[esp+44], esi
	mov	al, BYTE PTR _preallocate$[esp+32]

; 89   : 			entry.reserve(size);

	push	edi
	mov	esi, ebx
	mov	BYTE PTR [ebp+36], al
	call	?reserve@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::reserve

; 90   : 
; 91   : 			if (preallocate)

	cmp	BYTE PTR _preallocate$[esp+32], 0
	je	SHORT $LN24@Queue@6

; 92   : 			{
; 93   : 				while (!isFull())

	mov	ecx, DWORD PTR [ebx+16]
	sub	ecx, DWORD PTR [ebx+12]
	sar	ecx, 2
	cmp	ecx, DWORD PTR [ebp]
	je	SHORT $LN24@Queue@6
$LL2@Queue@6:

; 94   : 				{
; 95   : 					push(::new T());

	push	96					; 00000060H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T626925[esp+32], esi
	xor	edi, edi
	mov	BYTE PTR __$EHRec$[esp+44], 1
	cmp	esi, edi
	je	SHORT $LN6@Queue@6
	call	??0Event@DRAMsimII@@IAE@XZ		; DRAMsimII::Event::Event
	mov	DWORD PTR [esi], OFFSET ??_7Command@DRAMsimII@@6B@
	mov	DWORD PTR [esi+80], 5
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+88], edi
	jmp	SHORT $LN7@Queue@6
$LN6@Queue@6:
	xor	esi, esi
$LN7@Queue@6:
	push	esi
	mov	eax, ebp
	mov	BYTE PTR __$EHRec$[esp+48], 0
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push
	mov	edx, DWORD PTR [ebx+16]
	sub	edx, DWORD PTR [ebx+12]
	sar	edx, 2
	cmp	edx, DWORD PTR [ebp]
	jne	SHORT $LL2@Queue@6
$LN24@Queue@6:

; 96   : 				}
; 97   : 			}
; 98   : 		}

	mov	eax, ebp
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 12					; 0000000cH
	jmp	??1?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::~vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
__unwindfunclet$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$1:
	mov	eax, DWORD PTR $T626925[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::Queue<DRAMsimII::Command>
PUBLIC	??0Bank@DRAMsimII@@AAE@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ; DRAMsimII::Bank::Bank
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.cpp
_TEXT	SEGMENT
??0Bank@DRAMsimII@@AAE@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z PROC ; DRAMsimII::Bank::Bank
; _this$ = esi
; _timingVal$ = eax
; _systemConfigVal$ = ecx

; 132  : {}

	push	ebx
	xor	ebx, ebx
	push	ebx
	lea	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+4], ecx
	push	edx
	xor	ecx, ecx
	mov	DWORD PTR [esi], eax
	call	??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ; DRAMsimII::Queue<DRAMsimII::Command>::Queue<DRAMsimII::Command>
	mov	DWORD PTR [esi+48], ebx
	mov	DWORD PTR [esi+52], ebx
	mov	DWORD PTR [esi+56], ebx
	mov	DWORD PTR [esi+60], ebx
	mov	DWORD PTR [esi+64], ebx
	mov	DWORD PTR [esi+68], ebx
	mov	DWORD PTR [esi+72], ebx
	mov	DWORD PTR [esi+76], ebx
	mov	DWORD PTR [esi+80], ebx
	mov	DWORD PTR [esi+84], ebx
	mov	DWORD PTR [esi+88], ebx
	mov	DWORD PTR [esi+92], ebx
	mov	DWORD PTR [esi+96], ebx
	mov	DWORD PTR [esi+100], ebx
	mov	DWORD PTR [esi+104], ebx
	mov	DWORD PTR [esi+108], ebx
	mov	DWORD PTR [esi+112], ebx
	mov	DWORD PTR [esi+116], ebx
	mov	DWORD PTR [esi+120], ebx
	mov	BYTE PTR [esi+124], bl
	mov	DWORD PTR [esi+128], ebx
	mov	DWORD PTR [esi+132], ebx
	mov	DWORD PTR [esi+136], ebx
	mov	DWORD PTR [esi+140], ebx
	mov	DWORD PTR [esi+144], ebx
	mov	DWORD PTR [esi+148], ebx
	mov	eax, esi
	pop	ebx
	ret	0
??0Bank@DRAMsimII@@AAE@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ENDP ; DRAMsimII::Bank::Bank
_TEXT	ENDS
PUBLIC	??0Bank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ; DRAMsimII::Bank::Bank
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_settings$ = 8						; size = 4
??0Bank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z PROC ; DRAMsimII::Bank::Bank
; _this$ = esi
; _timingVal$ = eax
; _systemConfigVal$ = ecx

; 51   : {}

	push	ebx
	mov	ebx, DWORD PTR _settings$[esp]
	push	edi
	xor	edi, edi
	push	edi
	lea	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ecx
	mov	ecx, DWORD PTR [ebx+220]
	push	edx
	call	??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ; DRAMsimII::Queue<DRAMsimII::Command>::Queue<DRAMsimII::Command>
	or	eax, -1
	mov	ecx, -100				; ffffff9cH
	mov	DWORD PTR [esi+48], ecx
	mov	DWORD PTR [esi+56], ecx
	mov	DWORD PTR [esi+64], ecx
	mov	DWORD PTR [esi+52], eax
	mov	DWORD PTR [esi+60], eax
	mov	DWORD PTR [esi+68], eax
	mov	ecx, DWORD PTR [ebx+364]
	xor	edx, edx
	neg	ecx
	adc	edx, edi
	mov	DWORD PTR [esi+72], ecx
	mov	ecx, 8
	mov	DWORD PTR [esi+88], edi
	mov	DWORD PTR [esi+92], edi
	mov	DWORD PTR [esi+96], edi
	mov	DWORD PTR [esi+100], edi
	mov	DWORD PTR [esi+104], edi
	mov	DWORD PTR [esi+108], edi
	mov	DWORD PTR [esi+112], edi
	mov	DWORD PTR [esi+116], edi
	mov	DWORD PTR [esi+128], edi
	mov	DWORD PTR [esi+132], edi
	mov	DWORD PTR [esi+136], edi
	mov	DWORD PTR [esi+140], edi
	mov	DWORD PTR [esi+144], edi
	mov	DWORD PTR [esi+148], edi
	neg	edx
	pop	edi
	mov	DWORD PTR [esi+120], eax
	mov	DWORD PTR [esi+76], edx
	mov	DWORD PTR [esi+80], ecx
	mov	DWORD PTR [esi+84], ecx
	mov	BYTE PTR [esi+124], 1
	mov	eax, esi
	pop	ebx
	ret	4
??0Bank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ENDP ; DRAMsimII::Bank::Bank
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??4?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z$0
__ehfuncinfo$??4?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
xdata$x	ENDS
;	COMDAT ??4?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T638440 = -16						; size = 4
$T638439 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??4?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Command>::operator=, COMDAT
; _rhs$ = esi

; 416  : 		{

	push	-1
	push	__ehhandler$??4?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax

; 417  : 			if (&rhs == this)

	mov	ebp, DWORD PTR _this$[esp+28]
	cmp	esi, ebp

; 418  : 				return *this;

	je	$LN1@operator@359

; 419  : 
; 420  : 			count = rhs.count;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebp], eax

; 421  : 			head = rhs.head;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ebp+4], ecx

; 422  : 			tail = rhs.tail;

	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [ebp+8], edx

; 423  : 			const_cast<bool&>(pool) = rhs.pool;

	mov	al, BYTE PTR [esi+36]
	mov	BYTE PTR [ebp+36], al

; 424  : 
; 425  : 			entry.resize(rhs.entry.size());

	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	lea	ebx, DWORD PTR [ebp+12]
	sar	eax, 2
	push	eax
	mov	eax, ebx
	call	?resize@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXIPAVCommand@DRAMsimII@@@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::resize

; 426  : 
; 427  : 			for (unsigned i = 0; i < rhs.count; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi], edi
	jbe	$LN1@operator@359
$LL3@operator@359:

; 428  : 			{
; 429  : 				assert(rhs.at(i));
; 430  : 
; 431  : 				entry[(head + i) % entry.size()] = new T(*(rhs.at(i)));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T638440[esp+32], eax
	xor	ecx, ecx
	mov	DWORD PTR __$EHRec$[esp+40], ecx
	cmp	eax, ecx
	je	SHORT $LN7@operator@359
	cmp	edi, DWORD PTR [esi]
	jge	SHORT $LN19@operator@359
	cmp	edi, ecx
	jl	SHORT $LN19@operator@359
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	sar	ecx, 2
	add	eax, edi
	xor	edx, edx
	div	ecx
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	sar	ecx, 2
	mov	ebp, edx
	cmp	ebp, ecx
	jb	SHORT $LN25@operator@359
	call	__invalid_parameter_noinfo
$LN25@operator@359:
	mov	edx, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [edx+ebp*4]
	mov	ebp, DWORD PTR _this$[esp+28]
	mov	eax, DWORD PTR $T638440[esp+32]
$LN19@operator@359:
	push	ecx
	push	eax
	call	??0Command@DRAMsimII@@QAE@ABV01@@Z	; DRAMsimII::Command::Command
	mov	DWORD PTR $T638439[esp+32], eax
	jmp	SHORT $LN8@operator@359
$LN7@operator@359:
	mov	DWORD PTR $T638439[esp+32], ecx
$LN8@operator@359:
	mov	DWORD PTR __$EHRec$[esp+40], -1
	mov	ecx, DWORD PTR [ebx+16]
	sub	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebp+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebp, edx
	mov	edx, DWORD PTR [ebx+16]
	sub	edx, DWORD PTR [ebx+12]
	sar	edx, 2
	cmp	ebp, edx
	jb	SHORT $LN32@operator@359
	call	__invalid_parameter_noinfo
$LN32@operator@359:
	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR $T638439[esp+32]
	mov	DWORD PTR [eax+ebp*4], ecx
	mov	ebp, DWORD PTR _this$[esp+28]
	inc	edi
	cmp	edi, DWORD PTR [esi]
	jb	$LL3@operator@359
$LN1@operator@359:

; 432  : 			}
; 433  : 
; 434  : 			return *this;

	mov	eax, ebp

; 435  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z$0:
	mov	esi, DWORD PTR $T638440[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__ehhandler$??4?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::operator=
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z$1
__ehfuncinfo$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
xdata$x	ENDS
;	COMDAT ??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T638529 = 12						; size = 4
$T638528 = 12						; size = 4
_rhs$ = 12						; size = 4
??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Command>::Queue<DRAMsimII::Command>, COMDAT

; 64   : 		{

	push	-1
	push	__ehhandler$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _rhs$[esp+32]
	mov	eax, DWORD PTR [ebp]
	mov	ebx, DWORD PTR _this$[esp+32]
	mov	DWORD PTR [ebx], eax
	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebx+8], edx
	mov	edi, DWORD PTR [ebp+28]
	sub	edi, DWORD PTR [ebp+24]
	lea	esi, DWORD PTR [ebx+12]
	sar	edi, 2
	push	esi
	call	??0?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@I@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+44], edi
	mov	al, BYTE PTR [ebp+36]
	mov	BYTE PTR [ebx+36], al

; 65   : 			entry.reserve(rhs.entry.size());

	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	sar	ecx, 2
	push	ecx
	call	?reserve@?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::reserve

; 66   : 
; 67   : 			for (unsigned i = 0; i < rhs.count; i++)

	cmp	DWORD PTR [ebp], edi
	ja	SHORT $LN6@Queue@9

; 72   : 			}
; 73   : 
; 74   : 			for (unsigned i = 0; i < count; i++)
; 75   : 				assert(at(i) && rhs.at(i));
; 76   : 		}	

	mov	eax, ebx
$LN4@Queue@9:
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
	npad	8
$LL45@Queue@9:

; 66   : 
; 67   : 			for (unsigned i = 0; i < rhs.count; i++)

	mov	ebx, DWORD PTR _this$[esp+32]
$LN6@Queue@9:

; 68   : 			{
; 69   : 				assert(rhs.at(i) != NULL);
; 70   : 				// attempt to copy the contents of this queue
; 71   : 				entry[(head + i) % entry.size()] = new T(*rhs.at(i));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T638529[esp+32], eax
	xor	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+44], 1
	cmp	eax, ecx
	je	SHORT $LN9@Queue@9
	cmp	edi, DWORD PTR [ebp]
	jge	SHORT $LN22@Queue@9
	cmp	edi, ecx
	jl	SHORT $LN22@Queue@9
	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	mov	eax, DWORD PTR [ebp+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR [ebp+28]
	sub	edx, DWORD PTR [ebp+24]
	sar	edx, 2
	cmp	ebx, edx
	jb	SHORT $LN28@Queue@9
	call	__invalid_parameter_noinfo
$LN28@Queue@9:
	mov	eax, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	ebx, DWORD PTR _this$[esp+32]
	mov	eax, DWORD PTR $T638529[esp+32]
$LN22@Queue@9:
	push	ecx
	push	eax
	call	??0Command@DRAMsimII@@QAE@ABV01@@Z	; DRAMsimII::Command::Command
	mov	DWORD PTR $T638528[esp+32], eax
	jmp	SHORT $LN10@Queue@9
$LN9@Queue@9:
	mov	DWORD PTR $T638528[esp+32], ecx
$LN10@Queue@9:
	mov	BYTE PTR __$EHRec$[esp+44], 0
	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [ebx+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR [esi+16]
	sub	edx, DWORD PTR [esi+12]
	sar	edx, 2
	cmp	ebx, edx
	jb	SHORT $LN35@Queue@9
	call	__invalid_parameter_noinfo
$LN35@Queue@9:
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR $T638528[esp+32]
	inc	edi
	mov	DWORD PTR [eax+ebx*4], ecx
	cmp	edi, DWORD PTR [ebp]
	jb	$LL45@Queue@9

; 72   : 			}
; 73   : 
; 74   : 			for (unsigned i = 0; i < count; i++)
; 75   : 				assert(at(i) && rhs.at(i));
; 76   : 		}	

	mov	eax, DWORD PTR _this$[esp+32]
	jmp	$LN4@Queue@9
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 12					; 0000000cH
	jmp	??1?$vector@PAVCommand@DRAMsimII@@V?$allocator@PAVCommand@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >::~vector<DRAMsimII::Command *,std::allocator<DRAMsimII::Command *> >
__unwindfunclet$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z$1:
	mov	esi, DWORD PTR $T638529[ebp-4]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__ehhandler$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::Queue<DRAMsimII::Command>
PUBLIC	??4Bank@DRAMsimII@@QAEAAV01@ABV01@@Z		; DRAMsimII::Bank::operator=
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.cpp
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4Bank@DRAMsimII@@QAEAAV01@ABV01@@Z PROC		; DRAMsimII::Bank::operator=
; _this$ = edi

; 529  : {

	push	ebx
	mov	ebx, DWORD PTR _rhs$[esp]
	push	esi

; 530  : 	perBankQueue = rhs.perBankQueue;

	lea	eax, DWORD PTR [edi+8]
	lea	esi, DWORD PTR [ebx+8]
	push	eax
	call	??4?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::operator=

; 531  : 	lastRASTime = rhs.lastRASTime;

	mov	ecx, DWORD PTR [ebx+48]
	mov	DWORD PTR [edi+48], ecx
	mov	edx, DWORD PTR [ebx+52]
	mov	DWORD PTR [edi+52], edx

; 532  : 	lastCASTime = rhs.lastCASTime;

	mov	eax, DWORD PTR [ebx+56]
	mov	DWORD PTR [edi+56], eax
	mov	ecx, DWORD PTR [ebx+60]
	mov	DWORD PTR [edi+60], ecx

; 533  : 	lastCASWTime = rhs.lastCASWTime;

	mov	edx, DWORD PTR [ebx+64]
	mov	DWORD PTR [edi+64], edx
	mov	eax, DWORD PTR [ebx+68]
	mov	DWORD PTR [edi+68], eax

; 534  : 	lastPrechargeTime = rhs.lastPrechargeTime;

	mov	ecx, DWORD PTR [ebx+72]
	mov	DWORD PTR [edi+72], ecx
	mov	edx, DWORD PTR [ebx+76]
	mov	DWORD PTR [edi+76], edx

; 535  : 	lastCASLength = rhs.lastCASLength;		

	mov	eax, DWORD PTR [ebx+80]
	mov	DWORD PTR [edi+80], eax

; 536  : 	lastCASWLength = rhs.lastCASWLength;		

	mov	ecx, DWORD PTR [ebx+84]
	mov	DWORD PTR [edi+84], ecx

; 537  : 	openRowID = rhs.openRowID;			

	mov	edx, DWORD PTR [ebx+120]
	mov	DWORD PTR [edi+120], edx

; 538  : 	activated = rhs.activated;			

	mov	al, BYTE PTR [ebx+124]
	mov	BYTE PTR [edi+124], al

; 539  : 	RASCount = rhs.RASCount;			

	mov	ecx, DWORD PTR [ebx+128]
	mov	DWORD PTR [edi+128], ecx

; 540  : 	totalRASCount = rhs.totalRASCount;		

	mov	edx, DWORD PTR [ebx+132]
	mov	DWORD PTR [edi+132], edx

; 541  : 	CASCount = rhs.CASCount;			

	mov	eax, DWORD PTR [ebx+136]
	mov	DWORD PTR [edi+136], eax

; 542  : 	totalCASCount = rhs.totalCASCount;		

	mov	ecx, DWORD PTR [ebx+140]
	mov	DWORD PTR [edi+140], ecx

; 543  : 	CASWCount = rhs.CASWCount;			

	mov	edx, DWORD PTR [ebx+144]
	mov	DWORD PTR [edi+144], edx

; 544  : 	totalCASWCount = rhs.totalCASWCount;	

	mov	eax, DWORD PTR [ebx+148]

; 545  : 
; 546  : 	return *this;
; 547  : }

	pop	esi
	mov	DWORD PTR [edi+148], eax
	mov	eax, edi
	pop	ebx
	ret	4
??4Bank@DRAMsimII@@QAEAAV01@ABV01@@Z ENDP		; DRAMsimII::Bank::operator=
_TEXT	ENDS
PUBLIC	?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z ; DRAMsimII::Bank::aggressiveInsert
__unwindtable$?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z$1
__ehfuncinfo$?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_needsPrecharge$130582 = -16				; size = 1
_currentRow$130575 = -16				; size = 4
__$EHRec$ = -12						; size = 12
$T638628 = 8						; size = 4
$T638624 = 8						; size = 4
_this$ = 8						; size = 4
_incomingTransaction$ = 12				; size = 4
_time$ = 16						; size = 8
?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z PROC ; DRAMsimII::Bank::aggressiveInsert

; 402  : {

	push	-1
	push	__ehhandler$?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax

; 403  : 	if (!perBankQueue.isFull())

	mov	edi, DWORD PTR _this$[esp+32]
	mov	eax, DWORD PTR [edi+36]
	sub	eax, DWORD PTR [edi+32]
	lea	ebp, DWORD PTR [edi+8]
	sar	eax, 2
	cmp	eax, DWORD PTR [ebp]
	je	$LN1@aggressive

; 404  : 	{
; 405  : 		const unsigned currentRow = incomingTransaction->getAddress().getRow();
; 406  : 
; 407  : 		// go from the end to the beginning to ensure no starvation or RAW/WAR errors
; 408  : 		for (int currentIndex = perBankQueue.size() - 1; currentIndex >= 0; --currentIndex)

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR _incomingTransaction$[esp+32]
	mov	edx, DWORD PTR [ecx+68]
	lea	ebx, DWORD PTR [eax-1]
	mov	DWORD PTR _currentRow$130575[esp+36], edx
	test	ebx, ebx
	jl	$LN8@aggressive
$LL10@aggressive:

; 409  : 		{	
; 410  : 			const Command *currentCommand = perBankQueue.read(currentIndex);

	cmp	ebx, DWORD PTR [ebp]
	jge	SHORT $LN31@aggressive
	test	ebx, ebx
	jl	SHORT $LN31@aggressive
	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	mov	eax, DWORD PTR [ebp+4]
	add	eax, ebx
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [ebp+28]
	sub	eax, DWORD PTR [ebp+24]
	sar	eax, 2
	mov	esi, edx
	cmp	esi, eax
	jb	SHORT $LN37@aggressive
	call	__invalid_parameter_noinfo
$LN37@aggressive:
	mov	ecx, DWORD PTR [ebp+24]
	mov	eax, DWORD PTR [ecx+esi*4]
	jmp	SHORT $LN30@aggressive
$LN31@aggressive:
	xor	eax, eax
$LN30@aggressive:

; 411  : 
; 412  : 			// see if there is an available command to piggyback on
; 413  : 			if (currentCommand->isReadOrWrite() && currentCommand->getAddress().getRow() == currentRow)

	mov	ecx, DWORD PTR [eax+80]
	cmp	ecx, 1
	je	SHORT $LN44@aggressive
	cmp	ecx, 2
	je	SHORT $LN44@aggressive
	cmp	ecx, 3
	je	SHORT $LN44@aggressive
	cmp	ecx, 4
	jne	SHORT $LN7@aggressive
$LN44@aggressive:
	mov	edx, DWORD PTR _currentRow$130575[esp+36]
	cmp	DWORD PTR [eax+68], edx
	je	$LN86@aggressive
$LN7@aggressive:

; 427  : 				assert(perBankQueue[currentIndex + 1]->getAddress() == incomingTransaction->getAddress());
; 428  : 				assert(result);
; 429  : 				return true;
; 430  : 			}
; 431  : 			// strict order may add to the end of the queue only
; 432  : 			// if this has not happened already then this method of insertion fails
; 433  : 			else if (systemConfig.getCommandOrderingAlgorithm() == STRICT_ORDER)

	mov	ecx, DWORD PTR [edi+4]
	cmp	DWORD PTR [ecx+288], 0
	je	$LN1@aggressive

; 434  : 			{
; 435  : 				return false;
; 436  : 			}
; 437  : 			else if (time - currentCommand->getEnqueueTime() > systemConfig.getSeniorityAgeLimit())

	mov	edx, DWORD PTR [eax+16]
	mov	edi, DWORD PTR [ecx+320]
	mov	esi, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _time$[esp+32]
	mov	eax, DWORD PTR _time$[esp+36]
	sub	ecx, edx
	sbb	eax, esi
	xor	edx, edx
	cmp	eax, edx
	jg	$LN1@aggressive
	jl	SHORT $LN94@aggressive
	cmp	ecx, edi
	ja	$LN1@aggressive
$LN94@aggressive:

; 404  : 	{
; 405  : 		const unsigned currentRow = incomingTransaction->getAddress().getRow();
; 406  : 
; 407  : 		// go from the end to the beginning to ensure no starvation or RAW/WAR errors
; 408  : 		for (int currentIndex = perBankQueue.size() - 1; currentIndex >= 0; --currentIndex)

	sub	ebx, 1

; 434  : 			{
; 435  : 				return false;
; 436  : 			}
; 437  : 			else if (time - currentCommand->getEnqueueTime() > systemConfig.getSeniorityAgeLimit())

	mov	edi, DWORD PTR _this$[esp+32]
	jns	$LL10@aggressive
$LN8@aggressive:

; 438  : 			{
; 439  : 				return false;
; 440  : 			}
; 441  : 		}
; 442  : 
; 443  : 		// if the correct row is already open, just insert there
; 444  : 		// already guaranteed not to have RAW/WAR errors
; 445  : 		if (activated && openRowID == currentRow)

	cmp	BYTE PTR [edi+124], 0
	je	$LN1@aggressive
	mov	eax, DWORD PTR _currentRow$130575[esp+36]
	cmp	DWORD PTR [edi+120], eax
	jne	$LN1@aggressive

; 446  : 		{
; 447  : #ifndef NDEBUG
; 448  : 			bool result =
; 449  : #endif
; 450  : 				perBankQueue.push_front(new Command(incomingTransaction, time, false, timing.tBurst()));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T638628[esp+32], eax
	mov	edx, 1
	mov	DWORD PTR __$EHRec$[esp+44], edx
	test	eax, eax
	je	$LN16@aggressive
	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+4]
	push	ecx
	mov	ecx, DWORD PTR _time$[esp+40]
	push	0
	push	ecx
	mov	ecx, DWORD PTR _time$[esp+44]
	push	ecx
	mov	ecx, DWORD PTR _incomingTransaction$[esp+48]
	push	eax
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	jmp	$LN17@aggressive
$LN86@aggressive:

; 414  : 			{
; 415  : 				bool needsPrecharge = currentCommand->isPrecharge();

	cmp	ecx, 2
	je	SHORT $LN60@aggressive
	cmp	ecx, 4
	je	SHORT $LN60@aggressive
	cmp	ecx, 6
	je	SHORT $LN60@aggressive
	mov	BYTE PTR _needsPrecharge$130582[esp+36], 0
	jmp	SHORT $LN64@aggressive
$LN60@aggressive:

; 416  : 
; 417  : 				if (needsPrecharge)
; 418  : 				{
; 419  : 					currentCommand->setAutoPrecharge(false);

	lea	edx, DWORD PTR [ecx-1]
	mov	BYTE PTR _needsPrecharge$130582[esp+36], 1
	cmp	edx, 3
	ja	SHORT $LN64@aggressive
	jmp	DWORD PTR $LN102@aggressive[edx*4]
$LN66@aggressive:
	mov	edi, DWORD PTR _this$[esp+32]
	xor	edx, edx
	cmp	ecx, 4
	sete	dl
	lea	edx, DWORD PTR [edx+edx+1]
	mov	DWORD PTR [eax+80], edx
$LN64@aggressive:

; 420  : 				}			
; 421  : 
; 422  : 				// if the precharge was stripped from the n-1 command, add it to this one
; 423  : #ifndef NDEBUG
; 424  : 				bool result = 
; 425  : #endif
; 426  : 					perBankQueue.insert(new Command(incomingTransaction, time, needsPrecharge, timing.tBurst()), currentIndex + 1);

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T638624[esp+32], eax
	mov	DWORD PTR __$EHRec$[esp+44], 0
	test	eax, eax
	je	SHORT $LN14@aggressive
	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _needsPrecharge$130582[esp+36]
	push	ecx
	mov	ecx, DWORD PTR _time$[esp+40]
	push	edx
	mov	edx, DWORD PTR _time$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR _incomingTransaction$[esp+44]
	push	edx
	push	eax
	mov	edx, 1
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	jmp	SHORT $LN15@aggressive
$LN14@aggressive:
	xor	eax, eax
$LN15@aggressive:
	inc	ebx
	push	ebx
	push	eax
	mov	eax, ebp
	mov	DWORD PTR __$EHRec$[esp+52], -1
	call	?insert@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Command>::insert

; 451  : 			assert(result);
; 452  : 
; 453  : 			return true;

	mov	al, 1
	jmp	SHORT $LN12@aggressive
$LN16@aggressive:

; 446  : 		{
; 447  : #ifndef NDEBUG
; 448  : 			bool result =
; 449  : #endif
; 450  : 				perBankQueue.push_front(new Command(incomingTransaction, time, false, timing.tBurst()));

	xor	eax, eax
$LN17@aggressive:
	push	eax
	mov	eax, ebp
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	?push_front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push_front

; 451  : 			assert(result);
; 452  : 
; 453  : 			return true;

	mov	al, 1
	jmp	SHORT $LN12@aggressive
$LN1@aggressive:

; 454  : 		}
; 455  : 	}
; 456  : 
; 457  : 	return false;

	xor	al, al
$LN12@aggressive:

; 458  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	16					; 00000010H
	npad	3
$LN102@aggressive:
	DD	$LN64@aggressive
	DD	$LN66@aggressive
	DD	$LN64@aggressive
	DD	$LN66@aggressive
__unwindfunclet$?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z$1:
	mov	esi, DWORD PTR $T638628[ebp-4]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z$0:
	mov	esi, DWORD PTR $T638624[ebp-4]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__ehhandler$?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z
	jmp	___CxxFrameHandler3
?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z ENDP ; DRAMsimII::Bank::aggressiveInsert
PUBLIC	??0Bank@DRAMsimII@@QAE@ABV01@@Z			; DRAMsimII::Bank::Bank
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
??0Bank@DRAMsimII@@QAE@ABV01@@Z PROC			; DRAMsimII::Bank::Bank
; _this$ = esi
; _rhs$ = edi

; 105  : {}

	push	ecx
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [edi+8]
	push	edx
	lea	eax, DWORD PTR [esi+8]
	push	eax
	mov	DWORD PTR [esi+4], ecx
	call	??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::Queue<DRAMsimII::Command>
	mov	ecx, DWORD PTR [edi+48]
	mov	DWORD PTR [esi+48], ecx
	mov	edx, DWORD PTR [edi+52]
	mov	DWORD PTR [esi+52], edx
	mov	eax, DWORD PTR [edi+56]
	mov	DWORD PTR [esi+56], eax
	mov	ecx, DWORD PTR [edi+60]
	mov	DWORD PTR [esi+60], ecx
	mov	edx, DWORD PTR [edi+64]
	mov	DWORD PTR [esi+64], edx
	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR [esi+68], eax
	mov	ecx, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+72], ecx
	mov	edx, DWORD PTR [edi+76]
	mov	DWORD PTR [esi+76], edx
	mov	eax, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], eax
	mov	ecx, DWORD PTR [edi+84]
	mov	DWORD PTR [esi+84], ecx
	mov	edx, DWORD PTR [edi+88]
	mov	DWORD PTR [esi+88], edx
	mov	eax, DWORD PTR [edi+92]
	mov	DWORD PTR [esi+92], eax
	mov	ecx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], ecx
	mov	edx, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], edx
	mov	eax, DWORD PTR [edi+104]
	mov	DWORD PTR [esi+104], eax
	mov	ecx, DWORD PTR [edi+108]
	mov	DWORD PTR [esi+108], ecx
	mov	edx, DWORD PTR [edi+112]
	mov	DWORD PTR [esi+112], edx
	mov	eax, DWORD PTR [edi+116]
	mov	DWORD PTR [esi+116], eax
	mov	ecx, DWORD PTR [edi+120]
	mov	DWORD PTR [esi+120], ecx
	mov	dl, BYTE PTR [edi+124]
	mov	BYTE PTR [esi+124], dl
	mov	eax, DWORD PTR [edi+128]
	mov	DWORD PTR [esi+128], eax
	mov	ecx, DWORD PTR [edi+132]
	mov	DWORD PTR [esi+132], ecx
	mov	edx, DWORD PTR [edi+136]
	mov	DWORD PTR [esi+136], edx
	mov	eax, DWORD PTR [edi+140]
	mov	DWORD PTR [esi+140], eax
	mov	ecx, DWORD PTR [edi+144]
	mov	DWORD PTR [esi+144], ecx
	mov	edx, DWORD PTR [edi+148]
	mov	DWORD PTR [esi+148], edx
	mov	eax, esi
	pop	ecx
	ret	0
??0Bank@DRAMsimII@@QAE@ABV01@@Z ENDP			; DRAMsimII::Bank::Bank
_TEXT	ENDS
PUBLIC	??0Bank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ; DRAMsimII::Bank::Bank
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
??0Bank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z PROC ; DRAMsimII::Bank::Bank
; _this$ = esi
; _rhs$ = edi
; _timingVal$ = eax
; _systemConfigVal$ = ecx

; 78   : {}

	push	ecx
	lea	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi], eax
	push	edx
	lea	eax, DWORD PTR [esi+8]
	push	eax
	mov	DWORD PTR [esi+4], ecx
	call	??0?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::Queue<DRAMsimII::Command>
	mov	ecx, DWORD PTR [edi+48]
	mov	DWORD PTR [esi+48], ecx
	mov	edx, DWORD PTR [edi+52]
	mov	DWORD PTR [esi+52], edx
	mov	eax, DWORD PTR [edi+56]
	mov	DWORD PTR [esi+56], eax
	mov	ecx, DWORD PTR [edi+60]
	mov	DWORD PTR [esi+60], ecx
	mov	edx, DWORD PTR [edi+64]
	mov	DWORD PTR [esi+64], edx
	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR [esi+68], eax
	mov	ecx, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+72], ecx
	mov	edx, DWORD PTR [edi+76]
	mov	DWORD PTR [esi+76], edx
	mov	eax, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], eax
	mov	ecx, DWORD PTR [edi+84]
	mov	DWORD PTR [esi+84], ecx
	mov	edx, DWORD PTR [edi+88]
	mov	DWORD PTR [esi+88], edx
	mov	eax, DWORD PTR [edi+92]
	mov	DWORD PTR [esi+92], eax
	mov	ecx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], ecx
	mov	edx, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], edx
	mov	eax, DWORD PTR [edi+104]
	mov	DWORD PTR [esi+104], eax
	mov	ecx, DWORD PTR [edi+108]
	mov	DWORD PTR [esi+108], ecx
	mov	edx, DWORD PTR [edi+112]
	mov	DWORD PTR [esi+112], edx
	mov	eax, DWORD PTR [edi+116]
	mov	DWORD PTR [esi+116], eax
	mov	ecx, DWORD PTR [edi+120]
	mov	DWORD PTR [esi+120], ecx
	mov	dl, BYTE PTR [edi+124]
	mov	BYTE PTR [esi+124], dl
	mov	eax, DWORD PTR [edi+128]
	mov	DWORD PTR [esi+128], eax
	mov	ecx, DWORD PTR [edi+132]
	mov	DWORD PTR [esi+132], ecx
	mov	edx, DWORD PTR [edi+136]
	mov	DWORD PTR [esi+136], edx
	mov	eax, DWORD PTR [edi+140]
	mov	DWORD PTR [esi+140], eax
	mov	ecx, DWORD PTR [edi+144]
	mov	DWORD PTR [esi+144], ecx
	mov	edx, DWORD PTR [edi+148]
	mov	DWORD PTR [esi+148], edx
	mov	eax, esi
	pop	ecx
	ret	0
??0Bank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ENDP ; DRAMsimII::Bank::Bank
END
