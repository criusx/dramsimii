; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\CriuS\Documents\Visual Studio 2008\Projects\DRAMsimIIhg\src\Address.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?log2@DRAMsimII@@YAII@Z				; DRAMsimII::log2
PUBLIC	?getAddressMappingScheme@SystemConfiguration@DRAMsimII@@QBE?AW4AddressMappingScheme@Address@2@XZ ; DRAMsimII::SystemConfiguration::getAddressMappingScheme
PUBLIC	?getRankCount@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getRankCount
PUBLIC	?getBankCount@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getBankCount
PUBLIC	?getChannelCount@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getChannelCount
PUBLIC	?getRowCount@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getRowCount
PUBLIC	?getColumnCount@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getColumnCount
PUBLIC	?getColumnSize@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getColumnSize
PUBLIC	?getCachelineSize@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getCachelineSize
PUBLIC	?getDRAMType@SystemConfiguration@DRAMsimII@@QBE?AW4DRAMType@2@XZ ; DRAMsimII::SystemConfiguration::getDRAMType
PUBLIC	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
PUBLIC	?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?setf@ios_base@std@@QAEHHH@Z			; std::ios_base::setf
PUBLIC	?hex@std@@YAAAVios_base@1@AAV21@@Z		; std::hex
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
PUBLIC	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
PUBLIC	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?precision@ios_base@std@@QBEHXZ			; std::ios_base::precision
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$char_traits@D@std@@SAPADPADID@Z	; std::char_traits<char>::assign
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?decimal_point@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::decimal_point
PUBLIC	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
PUBLIC	?_Decref@facet@locale@std@@QAEPAV123@XZ		; std::locale::facet::_Decref
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
PUBLIC	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
PUBLIC	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
PUBLIC	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
PUBLIC	?_Incref@facet@locale@std@@QAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Register@facet@locale@std@@QAEXXZ		; std::locale::facet::_Register
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::locale::name
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
PUBLIC	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ	; std::_Locinfo::_Getcvt
PUBLIC	?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ	; std::_Locinfo::_Getlconv
PUBLIC	?_Getfalse@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Getfalse
PUBLIC	?_Gettrue@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Gettrue
PUBLIC	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z	; std::_Maklocchr<char>
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z	; std::numpunct<char>::_Init
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	?_Tidy@?$numpunct@D@std@@AAEXXZ			; std::numpunct<char>::_Tidy
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
PUBLIC	??_G?$numpunct@D@std@@MAEPAXI@Z			; std::numpunct<char>::`scalar deleting destructor'
PUBLIC	??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z	; std::numpunct<char>::numpunct<char>
PUBLIC	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	?thousands_sep@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::thousands_sep
PUBLIC	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	??_Gfacet@locale@std@@UAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??1facet@locale@std@@UAE@XZ			; std::locale::facet::~facet
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
PUBLIC	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?width@ios_base@std@@QBEHXZ			; std::ios_base::width
PUBLIC	?width@ios_base@std@@QAEHH@Z			; std::ios_base::width
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
PUBLIC	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
PUBLIC	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
PUBLIC	?fail@ios_base@std@@QBE_NXZ			; std::ios_base::fail
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??0failure@ios_base@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::ios_base::failure::failure
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Move_s
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ; std::_Char_traits_cat<std::char_traits<char> >
PUBLIC	?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Copy_s
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?what@runtime_error@std@@UBEPBDXZ		; std::runtime_error::what
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?mappingScheme@Address@DRAMsimII@@1W4AddressMappingScheme@12@A ; DRAMsimII::Address::mappingScheme
PUBLIC	?bankAddressDepth@Address@DRAMsimII@@1IA	; DRAMsimII::Address::bankAddressDepth
PUBLIC	?columnLowAddressDepth@Address@DRAMsimII@@1IA	; DRAMsimII::Address::columnLowAddressDepth
PUBLIC	?columnSizeDepth@Address@DRAMsimII@@1IA		; DRAMsimII::Address::columnSizeDepth
PUBLIC	?columnAddressDepth@Address@DRAMsimII@@1IA	; DRAMsimII::Address::columnAddressDepth
PUBLIC	?columnHighAddressDepth@Address@DRAMsimII@@1IA	; DRAMsimII::Address::columnHighAddressDepth
PUBLIC	?rowLowAddressDepth@Address@DRAMsimII@@1IA	; DRAMsimII::Address::rowLowAddressDepth
PUBLIC	?rankAddressDepth@Address@DRAMsimII@@1IA	; DRAMsimII::Address::rankAddressDepth
PUBLIC	?channelAddressDepth@Address@DRAMsimII@@1IA	; DRAMsimII::Address::channelAddressDepth
PUBLIC	?rowHighAddressDepth@Address@DRAMsimII@@1IA	; DRAMsimII::Address::rowHighAddressDepth
PUBLIC	?rowAddressDepth@Address@DRAMsimII@@1IA		; DRAMsimII::Address::rowAddressDepth
PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?value@integral_c_tag@mpl@boost@@2HB		; boost::mpl::integral_c_tag::value
PUBLIC	?value@?$bool_@$00@mpl@boost@@2_NB		; boost::mpl::bool_<1>::value
PUBLIC	?value@?$bool_@$0A@@mpl@boost@@2_NB		; boost::mpl::bool_<0>::value
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ ; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@	; `string'
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z40
PUBLIC	__CTA3?AVfailure@ios_base@std@@
PUBLIC	__TI3?AVfailure@ios_base@std@@
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?is_integral@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB ; boost::detail::integer_traits_base<bool,0,1>::is_integral
PUBLIC	?const_min@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB ; boost::detail::integer_traits_base<bool,0,1>::const_min
PUBLIC	?const_max@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB ; boost::detail::integer_traits_base<bool,0,1>::const_max
PUBLIC	?is_integral@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<char,-128,127>::is_integral
PUBLIC	?const_min@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2DB ; boost::detail::integer_traits_base<char,-128,127>::const_min
PUBLIC	?const_max@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2DB ; boost::detail::integer_traits_base<char,-128,127>::const_max
PUBLIC	?is_integral@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<signed char,-128,127>::is_integral
PUBLIC	?const_min@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2CB ; boost::detail::integer_traits_base<signed char,-128,127>::const_min
PUBLIC	?const_max@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2CB ; boost::detail::integer_traits_base<signed char,-128,127>::const_max
PUBLIC	?is_integral@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<unsigned char,0,255>::is_integral
PUBLIC	?const_min@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2EB ; boost::detail::integer_traits_base<unsigned char,0,255>::const_min
PUBLIC	?const_max@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2EB ; boost::detail::integer_traits_base<unsigned char,0,255>::const_max
PUBLIC	?is_integral@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<wchar_t,0,65535>::is_integral
PUBLIC	?const_min@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_WB ; boost::detail::integer_traits_base<wchar_t,0,65535>::const_min
PUBLIC	?const_max@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_WB ; boost::detail::integer_traits_base<wchar_t,0,65535>::const_max
PUBLIC	?is_integral@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<short,-32768,32767>::is_integral
PUBLIC	?const_min@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2FB ; boost::detail::integer_traits_base<short,-32768,32767>::const_min
PUBLIC	?const_max@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2FB ; boost::detail::integer_traits_base<short,-32768,32767>::const_max
PUBLIC	?is_integral@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<unsigned short,0,65535>::is_integral
PUBLIC	?const_min@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2GB ; boost::detail::integer_traits_base<unsigned short,0,65535>::const_min
PUBLIC	?const_max@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2GB ; boost::detail::integer_traits_base<unsigned short,0,65535>::const_max
PUBLIC	?is_integral@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<int,-2147483648,2147483647>::is_integral
PUBLIC	?const_min@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2HB ; boost::detail::integer_traits_base<int,-2147483648,2147483647>::const_min
PUBLIC	?const_max@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2HB ; boost::detail::integer_traits_base<int,-2147483648,2147483647>::const_max
PUBLIC	?is_integral@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<unsigned int,0,4294967295>::is_integral
PUBLIC	?const_min@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2IB ; boost::detail::integer_traits_base<unsigned int,0,4294967295>::const_min
PUBLIC	?const_max@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2IB ; boost::detail::integer_traits_base<unsigned int,0,4294967295>::const_max
PUBLIC	?is_integral@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<long,-2147483648,2147483647>::is_integral
PUBLIC	?const_min@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2JB ; boost::detail::integer_traits_base<long,-2147483648,2147483647>::const_min
PUBLIC	?const_max@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2JB ; boost::detail::integer_traits_base<long,-2147483648,2147483647>::const_max
PUBLIC	?is_integral@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<unsigned long,0,4294967295>::is_integral
PUBLIC	?const_min@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2KB ; boost::detail::integer_traits_base<unsigned long,0,4294967295>::const_min
PUBLIC	?const_max@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2KB ; boost::detail::integer_traits_base<unsigned long,0,4294967295>::const_max
PUBLIC	?is_integral@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_NB ; boost::detail::integer_traits_base<__int64,-9223372036854775808,9223372036854775807>::is_integral
PUBLIC	?const_min@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_JB ; boost::detail::integer_traits_base<__int64,-9223372036854775808,9223372036854775807>::const_min
PUBLIC	?const_max@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_JB ; boost::detail::integer_traits_base<__int64,-9223372036854775808,9223372036854775807>::const_max
PUBLIC	?is_integral@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_NB ; boost::detail::integer_traits_base<unsigned __int64,0,-1>::is_integral
PUBLIC	?const_min@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_KB ; boost::detail::integer_traits_base<unsigned __int64,0,-1>::const_min
PUBLIC	?const_max@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_KB ; boost::detail::integer_traits_base<unsigned __int64,0,-1>::const_max
PUBLIC	?value@?$ice_or@$0A@$0A@$0A@$0A@$0A@$0A@$0A@@type_traits@boost@@2_NB ; boost::type_traits::ice_or<0,0,0,0,0,0,0>::value
PUBLIC	?value@?$ice_and@$00$00$00$00$00$00$00@type_traits@boost@@2_NB ; boost::type_traits::ice_and<1,1,1,1,1,1,1>::value
PUBLIC	?value@?$ice_not@$00@type_traits@boost@@2_NB	; boost::type_traits::ice_not<1>::value
PUBLIC	?value@?$is_convertible_impl@XX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void,void>::value
PUBLIC	?value@?$is_convertible_impl@X$$CBX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void,void const >::value
PUBLIC	?value@?$is_convertible_impl@X$$CCX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void,void volatile >::value
PUBLIC	?value@?$is_convertible_impl@X$$CDX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void,void const volatile >::value
PUBLIC	?value@?$is_convertible_impl@$$CBXX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const ,void>::value
PUBLIC	?value@?$is_convertible_impl@$$CBX$$CBX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const ,void const >::value
PUBLIC	?value@?$is_convertible_impl@$$CBX$$CCX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const ,void volatile >::value
PUBLIC	?value@?$is_convertible_impl@$$CBX$$CDX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const ,void const volatile >::value
PUBLIC	?value@?$is_convertible_impl@$$CCXX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void volatile ,void>::value
PUBLIC	?value@?$is_convertible_impl@$$CCX$$CBX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void volatile ,void const >::value
PUBLIC	?value@?$is_convertible_impl@$$CCX$$CCX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void volatile ,void volatile >::value
PUBLIC	?value@?$is_convertible_impl@$$CCX$$CDX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void volatile ,void const volatile >::value
PUBLIC	?value@?$is_convertible_impl@$$CDXX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const volatile ,void>::value
PUBLIC	?value@?$is_convertible_impl@$$CDX$$CBX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const volatile ,void const >::value
PUBLIC	?value@?$is_convertible_impl@$$CDX$$CCX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const volatile ,void volatile >::value
PUBLIC	?value@?$is_convertible_impl@$$CDX$$CDX@detail@boost@@2_NB ; boost::detail::is_convertible_impl<void const volatile ,void const volatile >::value
PUBLIC	?value@type@?$select_by_size@$00@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<1>::type::value
PUBLIC	?value@?$select_by_size@$00@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<1>::value
PUBLIC	?value@type@?$select_by_size@$01@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<2>::type::value
PUBLIC	?value@?$select_by_size@$01@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<2>::value
PUBLIC	?value@type@?$select_by_size@$02@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<3>::type::value
PUBLIC	?value@?$select_by_size@$02@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<3>::value
PUBLIC	?value@type@?$select_by_size@$03@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<4>::type::value
PUBLIC	?value@?$select_by_size@$03@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<4>::value
PUBLIC	?value@type@?$select_by_size@$04@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<5>::type::value
PUBLIC	?value@?$select_by_size@$04@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<5>::value
PUBLIC	?value@type@?$select_by_size@$05@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<6>::type::value
PUBLIC	?value@?$select_by_size@$05@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<6>::value
PUBLIC	?value@type@?$select_by_size@$06@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<7>::type::value
PUBLIC	?value@?$select_by_size@$06@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<7>::value
PUBLIC	?value@type@?$select_by_size@$07@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<8>::type::value
PUBLIC	?value@?$select_by_size@$07@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<8>::value
PUBLIC	?value@type@?$select_by_size@$08@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<9>::type::value
PUBLIC	?value@?$select_by_size@$08@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<9>::value
PUBLIC	?value@type@?$select_by_size@$09@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<10>::type::value
PUBLIC	?value@?$select_by_size@$09@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<10>::value
PUBLIC	?value@type@?$select_by_size@$0L@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<11>::type::value
PUBLIC	?value@?$select_by_size@$0L@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<11>::value
PUBLIC	?value@type@?$select_by_size@$0M@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<12>::type::value
PUBLIC	?value@?$select_by_size@$0M@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<12>::value
PUBLIC	?value@type@?$select_by_size@$0N@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<13>::type::value
PUBLIC	?value@?$select_by_size@$0N@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<13>::value
PUBLIC	?value@type@?$select_by_size@$0O@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<14>::type::value
PUBLIC	?value@?$select_by_size@$0O@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<14>::value
PUBLIC	?value@type@?$select_by_size@$0P@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<15>::type::value
PUBLIC	?value@?$select_by_size@$0P@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<15>::value
PUBLIC	?value@type@?$select_by_size@$0BA@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<16>::type::value
PUBLIC	?value@?$select_by_size@$0BA@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<16>::value
PUBLIC	?value@type@?$select_by_size@$0BB@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<17>::type::value
PUBLIC	?value@?$select_by_size@$0BB@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<17>::value
PUBLIC	?value@type@?$select_by_size@$0BC@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<18>::type::value
PUBLIC	?value@?$select_by_size@$0BC@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<18>::value
PUBLIC	?value@type@?$select_by_size@$0BD@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<19>::type::value
PUBLIC	?value@?$select_by_size@$0BD@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<19>::value
PUBLIC	?value@type@?$select_by_size@$0BE@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<20>::type::value
PUBLIC	?value@?$select_by_size@$0BE@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<20>::value
PUBLIC	?value@type@?$select_by_size@$0BF@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<21>::type::value
PUBLIC	?value@?$select_by_size@$0BF@@detail@iostreams@boost@@2HB ; boost::iostreams::detail::select_by_size<21>::value
PUBLIC	?value@?$int_@$00@mpl@boost@@2HB		; boost::mpl::int_<1>::value
PUBLIC	?value@?$int_@$01@mpl@boost@@2HB		; boost::mpl::int_<2>::value
PUBLIC	?value@?$int_@$02@mpl@boost@@2HB		; boost::mpl::int_<3>::value
PUBLIC	?value@?$int_@$03@mpl@boost@@2HB		; boost::mpl::int_<4>::value
PUBLIC	?value@?$int_@$04@mpl@boost@@2HB		; boost::mpl::int_<5>::value
PUBLIC	?value@?$int_@$05@mpl@boost@@2HB		; boost::mpl::int_<6>::value
PUBLIC	?value@?$int_@$06@mpl@boost@@2HB		; boost::mpl::int_<7>::value
PUBLIC	?value@?$int_@$07@mpl@boost@@2HB		; boost::mpl::int_<8>::value
PUBLIC	?value@?$int_@$08@mpl@boost@@2HB		; boost::mpl::int_<9>::value
PUBLIC	?value@?$int_@$09@mpl@boost@@2HB		; boost::mpl::int_<10>::value
PUBLIC	?value@?$int_@$0L@@mpl@boost@@2HB		; boost::mpl::int_<11>::value
PUBLIC	?value@?$int_@$0M@@mpl@boost@@2HB		; boost::mpl::int_<12>::value
PUBLIC	?value@?$arg@$0?0@mpl@boost@@2HB		; boost::mpl::arg<-1>::value
PUBLIC	?value@?$arg@$00@mpl@boost@@2HB			; boost::mpl::arg<1>::value
PUBLIC	?value@?$arg@$01@mpl@boost@@2HB			; boost::mpl::arg<2>::value
PUBLIC	?value@?$arg@$02@mpl@boost@@2HB			; boost::mpl::arg<3>::value
PUBLIC	?value@?$arg@$03@mpl@boost@@2HB			; boost::mpl::arg<4>::value
PUBLIC	?value@?$arg@$04@mpl@boost@@2HB			; boost::mpl::arg<5>::value
PUBLIC	?value@?$is_member_function_pointer_impl@X@detail@boost@@2_NB ; boost::detail::is_member_function_pointer_impl<void>::value
PUBLIC	?value@?$is_member_function_pointer_impl@$$CBX@detail@boost@@2_NB ; boost::detail::is_member_function_pointer_impl<void const >::value
PUBLIC	?value@?$is_member_function_pointer_impl@$$CCX@detail@boost@@2_NB ; boost::detail::is_member_function_pointer_impl<void volatile >::value
PUBLIC	?value@?$is_member_function_pointer_impl@$$CDX@detail@boost@@2_NB ; boost::detail::is_member_function_pointer_impl<void const volatile >::value
PUBLIC	?value@?$is_scalar_impl@X@detail@boost@@2_NB	; boost::detail::is_scalar_impl<void>::value
PUBLIC	?value@?$is_scalar_impl@$$CBX@detail@boost@@2_NB ; boost::detail::is_scalar_impl<void const >::value
PUBLIC	?value@?$is_scalar_impl@$$CCX@detail@boost@@2_NB ; boost::detail::is_scalar_impl<void volatile >::value
PUBLIC	?value@?$is_scalar_impl@$$CDX@detail@boost@@2_NB ; boost::detail::is_scalar_impl<void const volatile >::value
PUBLIC	?value@?$is_pod_impl@X@detail@boost@@2_NB	; boost::detail::is_pod_impl<void>::value
PUBLIC	?value@?$is_pod_impl@$$CBX@detail@boost@@2_NB	; boost::detail::is_pod_impl<void const >::value
PUBLIC	?value@?$is_pod_impl@$$CCX@detail@boost@@2_NB	; boost::detail::is_pod_impl<void volatile >::value
PUBLIC	?value@?$is_pod_impl@$$CDX@detail@boost@@2_NB	; boost::detail::is_pod_impl<void const volatile >::value
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?value@?$integral_c@I$0A@@mpl@boost@@2IB	; boost::mpl::integral_c<unsigned int,0>::value
PUBLIC	?value@?$alignment_logic@$07$07@detail@boost@@2IB ; boost::detail::alignment_logic<8,8>::value
PUBLIC	?value@?$alignment_of_impl@Tmax_align@detail@boost@@@detail@boost@@2IB ; boost::detail::alignment_of_impl<boost::detail::max_align>::value
PUBLIC	?value@?$integral_c@I$07@mpl@boost@@2IB		; boost::mpl::integral_c<unsigned int,8>::value
PUBLIC	?value@?$alignment_logic@$00$00@detail@boost@@2IB ; boost::detail::alignment_logic<1,1>::value
PUBLIC	?value@?$alignment_of_impl@D@detail@boost@@2IB	; boost::detail::alignment_of_impl<char>::value
PUBLIC	?value@?$integral_c@I$00@mpl@boost@@2IB		; boost::mpl::integral_c<unsigned int,1>::value
PUBLIC	?value@?$alignment_logic@$01$01@detail@boost@@2IB ; boost::detail::alignment_logic<2,2>::value
PUBLIC	?value@?$alignment_of_impl@F@detail@boost@@2IB	; boost::detail::alignment_of_impl<short>::value
PUBLIC	?value@?$integral_c@I$01@mpl@boost@@2IB		; boost::mpl::integral_c<unsigned int,2>::value
PUBLIC	?value@?$alignment_logic@$03$03@detail@boost@@2IB ; boost::detail::alignment_logic<4,4>::value
PUBLIC	?value@?$alignment_of_impl@H@detail@boost@@2IB	; boost::detail::alignment_of_impl<int>::value
PUBLIC	?value@?$integral_c@I$03@mpl@boost@@2IB		; boost::mpl::integral_c<unsigned int,4>::value
PUBLIC	?value@?$alignment_of_impl@J@detail@boost@@2IB	; boost::detail::alignment_of_impl<long>::value
PUBLIC	?value@?$alignment_of_impl@_J@detail@boost@@2IB	; boost::detail::alignment_of_impl<__int64>::value
PUBLIC	?value@?$alignment_of_impl@T?$lower_alignment@$07@detail@boost@@@detail@boost@@2IB ; boost::detail::alignment_of_impl<boost::detail::lower_alignment<8> >::value
PUBLIC	?value@?$is_aligned@$07$07@detail@boost@@2_NB	; boost::detail::is_aligned<8,8>::value
PUBLIC	?found@?$type_with_alignment_imp@$07@detail@boost@@0IB ; boost::detail::type_with_alignment_imp<8>::found
PUBLIC	?value@?$is_pod_impl@Ua8@align@boost@@@detail@boost@@2_NB ; boost::detail::is_pod_impl<boost::align::a8>::value
PUBLIC	?value@?$is_pod_impl@Ua16@align@boost@@@detail@boost@@2_NB ; boost::detail::is_pod_impl<boost::align::a16>::value
PUBLIC	?value@?$is_pod_impl@Ua32@align@boost@@@detail@boost@@2_NB ; boost::detail::is_pod_impl<boost::align::a32>::value
PUBLIC	?value@?$is_pod_impl@Ua64@align@boost@@@detail@boost@@2_NB ; boost::detail::is_pod_impl<boost::align::a64>::value
PUBLIC	?value@?$is_pod_impl@Ua128@align@boost@@@detail@boost@@2_NB ; boost::detail::is_pod_impl<boost::align::a128>::value
PUBLIC	?has_fixed_range@rand48@boost@@2_NB		; boost::rand48::has_fixed_range
PUBLIC	?min_value@rand48@boost@@2JB			; boost::rand48::min_value
PUBLIC	?max_value@rand48@boost@@2JB			; boost::rand48::max_value
PUBLIC	?has_fixed_range@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_NB ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::has_fixed_range
PUBLIC	?min_value@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::min_value
PUBLIC	?max_value@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::max_value
PUBLIC	?multiplier@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::multiplier
PUBLIC	?increment@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::increment
PUBLIC	?modulus@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::modulus
PUBLIC	?has_fixed_range@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2_NB ; boost::random::linear_congruential<long,40014,0,2147483563,0>::has_fixed_range
PUBLIC	?min_value@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB ; boost::random::linear_congruential<long,40014,0,2147483563,0>::min_value
PUBLIC	?max_value@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB ; boost::random::linear_congruential<long,40014,0,2147483563,0>::max_value
PUBLIC	?multiplier@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB ; boost::random::linear_congruential<long,40014,0,2147483563,0>::multiplier
PUBLIC	?increment@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB ; boost::random::linear_congruential<long,40014,0,2147483563,0>::increment
PUBLIC	?modulus@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB ; boost::random::linear_congruential<long,40014,0,2147483563,0>::modulus
PUBLIC	?has_fixed_range@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2_NB ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::has_fixed_range
PUBLIC	?min_value@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::min_value
PUBLIC	?max_value@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::max_value
PUBLIC	?multiplier@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::multiplier
PUBLIC	?increment@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::increment
PUBLIC	?modulus@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::modulus
PUBLIC	?is_specialized@?$fibonacci_validation@N$0CFP@$0BBB@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,607,273>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0EPP@$0BKC@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,1279,418>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0IOJ@$0EOE@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,2281,1252>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0MJB@$0CEA@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,3217,576>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0BBEH@$0IDC@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,4423,2098>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0CFNJ@$0BFHO@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,9689,5502>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0ENOB@$0CGHC@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,19937,9842>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0FKKJ@$0DEJO@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,23209,13470>::is_specialized
PUBLIC	?is_specialized@?$fibonacci_validation@N$0KNNB@$0FCCK@@random@boost@@2_NB ; boost::random::fibonacci_validation<double,44497,21034>::is_specialized
PUBLIC	?has_fixed_range@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2_NB ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::has_fixed_range
PUBLIC	?word_size@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::word_size
PUBLIC	?exponent1@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::exponent1
PUBLIC	?exponent2@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::exponent2
PUBLIC	?step_size@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::step_size
PUBLIC	?has_fixed_range@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2_NB ; boost::random::xor_combine<boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>,0,boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>,0,0>::has_fixed_range
PUBLIC	?shift1@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2HB ; boost::random::xor_combine<boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>,0,boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>,0,0>::shift1
PUBLIC	?shift2@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2HB ; boost::random::xor_combine<boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>,0,boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>,0,0>::shift2
PUBLIC	?has_fixed_range@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2_NB ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::has_fixed_range
PUBLIC	?word_size@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::word_size
PUBLIC	?exponent1@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::exponent1
PUBLIC	?exponent2@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::exponent2
PUBLIC	?step_size@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::step_size
PUBLIC	?value@?$implementation_level@Ucollection_size_type@serialization@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::serialization::collection_size_type>::value
PUBLIC	?value@?$implementation_level@V?$vector@_NV?$allocator@_N@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<bool,std::allocator<bool> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@DV?$allocator@D@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<char,std::allocator<char> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@CV?$allocator@C@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<signed char,std::allocator<signed char> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@EV?$allocator@E@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<unsigned char,std::allocator<unsigned char> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@HV?$allocator@H@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<int,std::allocator<int> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@IV?$allocator@I@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<unsigned int,std::allocator<unsigned int> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@JV?$allocator@J@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<long,std::allocator<long> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@KV?$allocator@K@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<unsigned long,std::allocator<unsigned long> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@MV?$allocator@M@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<float,std::allocator<float> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@NV?$allocator@N@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<double,std::allocator<double> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@GV?$allocator@G@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<unsigned short,std::allocator<unsigned short> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@FV?$allocator@F@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<short,std::allocator<short> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@_JV?$allocator@_J@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<__int64,std::allocator<__int64> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@_KV?$allocator@_K@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<unsigned __int64,std::allocator<unsigned __int64> > >::value
PUBLIC	?value@?$implementation_level@V?$vector@_WV?$allocator@_W@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::vector<wchar_t,std::allocator<wchar_t> > >::value
PUBLIC	?value@?$is_arithmetic_impl@Uinput@iostreams@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::iostreams::input>::value
PUBLIC	?value@?$is_abstract_imp@Uinput@iostreams@boost@@@detail@boost@@2_NB ; boost::detail::is_abstract_imp<boost::iostreams::input>::value
PUBLIC	?value@?$is_convertible_basic_impl@AAUinput@iostreams@boost@@U123@@detail@boost@@2_NB ; boost::detail::is_convertible_basic_impl<boost::iostreams::input &,boost::iostreams::input>::value
PUBLIC	?value@?$ice_or@$00$0A@$0A@$0A@$0A@$0A@$0A@@type_traits@boost@@2_NB ; boost::type_traits::ice_or<1,0,0,0,0,0,0>::value
PUBLIC	?value@?$ice_not@$0A@@type_traits@boost@@2_NB	; boost::type_traits::ice_not<0>::value
PUBLIC	?value@?$is_convertible_impl@Uinput@iostreams@boost@@U123@@detail@boost@@2_NB ; boost::detail::is_convertible_impl<boost::iostreams::input,boost::iostreams::input>::value
PUBLIC	?value@?$is_arithmetic_impl@Uoutput@iostreams@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::iostreams::output>::value
PUBLIC	?value@?$is_abstract_imp@Uoutput@iostreams@boost@@@detail@boost@@2_NB ; boost::detail::is_abstract_imp<boost::iostreams::output>::value
PUBLIC	?value@?$is_convertible_basic_impl@AAUinput@iostreams@boost@@Uoutput@23@@detail@boost@@2_NB ; boost::detail::is_convertible_basic_impl<boost::iostreams::input &,boost::iostreams::output>::value
PUBLIC	?value@?$ice_and@$0A@$00$00$00$00$00$00@type_traits@boost@@2_NB ; boost::type_traits::ice_and<0,1,1,1,1,1,1>::value
PUBLIC	?value@?$is_convertible_impl@Uinput@iostreams@boost@@Uoutput@23@@detail@boost@@2_NB ; boost::detail::is_convertible_impl<boost::iostreams::input,boost::iostreams::output>::value
PUBLIC	?word_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::word_size
PUBLIC	?state_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::state_size
PUBLIC	?shift_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::shift_size
PUBLIC	?mask_bits@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::mask_bits
PUBLIC	?parameter_a@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::parameter_a
PUBLIC	?output_u@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_u
PUBLIC	?output_s@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_s
PUBLIC	?output_b@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_b
PUBLIC	?output_t@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_t
PUBLIC	?output_c@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_c
PUBLIC	?output_l@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_l
PUBLIC	?has_fixed_range@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2_NB ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::has_fixed_range
PUBLIC	?is_const@?$cv_traits_imp@PAH@detail@boost@@2_NB ; boost::detail::cv_traits_imp<int *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PAH@detail@boost@@2_NB ; boost::detail::cv_traits_imp<int *>::is_volatile
PUBLIC	?value@?$is_ununsigned_helper@H@detail@boost@@2_NB ; boost::detail::is_ununsigned_helper<int>::value
PUBLIC	?value@?$is_unsigned_imp@H@detail@boost@@2_NB	; boost::detail::is_unsigned_imp<int>::value
PUBLIC	?has_fixed_range@?$backward_compatible_uniform_01@V?$pass_through_engine@AAV?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@@detail@random@boost@@N@detail@boost@@2_NB ; boost::detail::backward_compatible_uniform_01<boost::random::detail::pass_through_engine<boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566> &>,double>::has_fixed_range
PUBLIC	?has_fixed_range@?$backward_compatible_uniform_01@V?$pass_through_engine@V?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@@detail@random@boost@@N@detail@boost@@2_NB ; boost::detail::backward_compatible_uniform_01<boost::random::detail::pass_through_engine<boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566> >,double>::has_fixed_range
PUBLIC	?value@?$implementation_level@V?$list@_NV?$allocator@_N@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<bool,std::allocator<bool> > >::value
PUBLIC	?value@?$implementation_level@V?$list@DV?$allocator@D@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<char,std::allocator<char> > >::value
PUBLIC	?value@?$implementation_level@V?$list@CV?$allocator@C@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<signed char,std::allocator<signed char> > >::value
PUBLIC	?value@?$implementation_level@V?$list@EV?$allocator@E@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<unsigned char,std::allocator<unsigned char> > >::value
PUBLIC	?value@?$implementation_level@V?$list@HV?$allocator@H@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<int,std::allocator<int> > >::value
PUBLIC	?value@?$implementation_level@V?$list@IV?$allocator@I@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<unsigned int,std::allocator<unsigned int> > >::value
PUBLIC	?value@?$implementation_level@V?$list@JV?$allocator@J@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<long,std::allocator<long> > >::value
PUBLIC	?value@?$implementation_level@V?$list@KV?$allocator@K@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<unsigned long,std::allocator<unsigned long> > >::value
PUBLIC	?value@?$implementation_level@V?$list@MV?$allocator@M@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<float,std::allocator<float> > >::value
PUBLIC	?value@?$implementation_level@V?$list@NV?$allocator@N@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<double,std::allocator<double> > >::value
PUBLIC	?value@?$implementation_level@V?$list@GV?$allocator@G@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<unsigned short,std::allocator<unsigned short> > >::value
PUBLIC	?value@?$implementation_level@V?$list@FV?$allocator@F@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<short,std::allocator<short> > >::value
PUBLIC	?value@?$implementation_level@V?$list@_JV?$allocator@_J@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<__int64,std::allocator<__int64> > >::value
PUBLIC	?value@?$implementation_level@V?$list@_KV?$allocator@_K@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<unsigned __int64,std::allocator<unsigned __int64> > >::value
PUBLIC	?value@?$implementation_level@V?$list@_WV?$allocator@_W@std@@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::list<wchar_t,std::allocator<wchar_t> > >::value
PUBLIC	?value@?$implementation_level@Uversion_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::version_type>::value
PUBLIC	?value@?$implementation_level@Uclass_id_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::class_id_type>::value
PUBLIC	?value@?$implementation_level@Uclass_id_reference_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::class_id_reference_type>::value
PUBLIC	?value@?$implementation_level@Uclass_id_optional_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::class_id_optional_type>::value
PUBLIC	?value@?$implementation_level@Uclass_name_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::class_name_type>::value
PUBLIC	?value@?$implementation_level@Uobject_id_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::object_id_type>::value
PUBLIC	?value@?$implementation_level@Uobject_reference_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::object_reference_type>::value
PUBLIC	?value@?$implementation_level@Utracking_type@archive@boost@@@serialization@boost@@2HB ; boost::serialization::implementation_level<boost::archive::tracking_type>::value
PUBLIC	?value@?$implementation_level@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
PUBLIC	?value@?$implementation_level@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@serialization@boost@@2HB ; boost::serialization::implementation_level<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::value
PUBLIC	?value@?$int_@$0A@@mpl@boost@@2HB		; boost::mpl::int_<0>::value
PUBLIC	?value@?$is_convertible_basic_impl@AAUoutput@iostreams@boost@@Uinput@23@@detail@boost@@2_NB ; boost::detail::is_convertible_basic_impl<boost::iostreams::output &,boost::iostreams::input>::value
PUBLIC	?value@?$is_convertible_impl@Uoutput@iostreams@boost@@Uinput@23@@detail@boost@@2_NB ; boost::detail::is_convertible_impl<boost::iostreams::output,boost::iostreams::input>::value
PUBLIC	??_C@_0ED@OGNDED@Unknown?5address?5mapping?5scheme?0?5@ ; `string'
PUBLIC	??_C@_01PKGAHCOL@?$CJ?$AA@			; `string'
PUBLIC	??_C@_0DC@CJFGPHKC@?$CJ?5out?5of?5range?5of?5available?5phys@ ; `string'
PUBLIC	??_C@_0BB@FBHDFKBD@Memory?5address?5?$CI?$AA@	; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN?$AA@			; `string'
PUBLIC	??_C@_06ICGIPBND@?$FN?5col?$FL?$AA@		; `string'
PUBLIC	??_C@_06MPJLADHA@?$FN?5row?$FL?$AA@		; `string'
PUBLIC	??_C@_07LMBJCPNP@?$FN?5bank?$FL?$AA@		; `string'
PUBLIC	??_C@_07LPMPCNEE@?$FN?5rank?$FL?$AA@		; `string'
PUBLIC	??_C@_07CEPNEMLG@?$FN?5chan?$FL?$AA@		; `string'
PUBLIC	??_C@_07DGJDIIGL@addr?$FL0x?$AA@		; `string'
PUBLIC	??_C@_03NJGPNILD@BBM?$AA@			; `string'
PUBLIC	??_C@_06KAGHFJNN@SDHIPF?$AA@			; `string'
PUBLIC	??_C@_05LIIHKDFK@SDBAS?$AA@			; `string'
PUBLIC	??_C@_05CODBJAID@CPBAS?$AA@			; `string'
PUBLIC	??_C@_06EINBLCDA@CPBOPT?$AA@			; `string'
PUBLIC	??_C@_04EKFNGKOK@845G?$AA@			; `string'
PUBLIC	??_C@_05JNFEGKGN@LOLOC?$AA@			; `string'
PUBLIC	??_C@_05IJIFNNNL@HILOC?$AA@			; `string'
PUBLIC	??_C@_05LOKBKELC@UNKWN?$AA@			; `string'
PUBLIC	??_C@_02EAOCLKAK@ld?$AA@			; `string'
PUBLIC	??_C@_02BDDLJJBK@lu?$AA@			; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld?$AA@			; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu?$AA@			; `string'
PUBLIC	??_C@_02BBAHNLBA@?$CFp?$AA@			; `string'
PUBLIC	??_C@_01DDCIFGEA@E?$AA@				; `string'
PUBLIC	??_C@_01KGKMHCOC@e?$AA@				; `string'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	?is_const@?$cv_traits_imp@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>::is_volatile
PUBLIC	?is_const@?$cv_traits_imp@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::is_volatile
PUBLIC	?value@?$is_abstract_imp@D@detail@boost@@2_NB	; boost::detail::is_abstract_imp<char>::value
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?is_const@?$cv_traits_imp@PBV?$iterator_range@V?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::iterator_range<std::_String_iterator<char,std::char_traits<char>,std::allocator<char> > > const *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PBV?$iterator_range@V?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::iterator_range<std::_String_iterator<char,std::char_traits<char>,std::allocator<char> > > const *>::is_volatile
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	?is_const@?$cv_traits_imp@PAUtracking_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::tracking_type *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PAUtracking_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::tracking_type *>::is_volatile
PUBLIC	?value@?$is_pointer_helper@Utracking_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_helper<boost::archive::tracking_type>::value
PUBLIC	?value@?$result_@Utracking_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::tracking_type>::value
PUBLIC	?value@?$is_pointer_impl@Utracking_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_impl<boost::archive::tracking_type>::value
PUBLIC	?is_const@?$cv_traits_imp@PAUversion_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::version_type *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PAUversion_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::version_type *>::is_volatile
PUBLIC	?value@?$is_pointer_helper@Uversion_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_helper<boost::archive::version_type>::value
PUBLIC	?value@?$result_@Uversion_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::version_type>::value
PUBLIC	?value@?$is_pointer_impl@Uversion_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_impl<boost::archive::version_type>::value
PUBLIC	?is_const@?$cv_traits_imp@PAUobject_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::object_id_type *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PAUobject_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::object_id_type *>::is_volatile
PUBLIC	?value@?$is_pointer_helper@Uobject_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_helper<boost::archive::object_id_type>::value
PUBLIC	?value@?$result_@Uobject_id_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::object_id_type>::value
PUBLIC	?value@?$is_pointer_impl@Uobject_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_impl<boost::archive::object_id_type>::value
PUBLIC	?is_const@?$cv_traits_imp@PAUclass_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::class_id_type *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PAUclass_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::cv_traits_imp<boost::archive::class_id_type *>::is_volatile
PUBLIC	?value@?$is_pointer_helper@Uclass_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_helper<boost::archive::class_id_type>::value
PUBLIC	?value@?$result_@Uclass_id_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::class_id_type>::value
PUBLIC	?value@?$is_pointer_impl@Uclass_id_type@archive@boost@@@detail@boost@@2_NB ; boost::detail::is_pointer_impl<boost::archive::class_id_type>::value
PUBLIC	?is_const@?$cv_traits_imp@PAI@detail@boost@@2_NB ; boost::detail::cv_traits_imp<unsigned int *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PAI@detail@boost@@2_NB ; boost::detail::cv_traits_imp<unsigned int *>::is_volatile
PUBLIC	?value@?$is_pointer_helper@I@detail@boost@@2_NB	; boost::detail::is_pointer_helper<unsigned int>::value
PUBLIC	?value@?$result_@I@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<unsigned int>::value
PUBLIC	?value@?$is_pointer_impl@I@detail@boost@@2_NB	; boost::detail::is_pointer_impl<unsigned int>::value
PUBLIC	?value@?$is_base_and_derived_impl@Ubasic_traits@serialization@boost@@I@detail@boost@@2_NB ; boost::detail::is_base_and_derived_impl<boost::serialization::basic_traits,unsigned int>::value
PUBLIC	?value@?$is_arithmetic_impl@I@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<unsigned int>::value
PUBLIC	?value@?$implementation_level@I@serialization@boost@@2HB ; boost::serialization::implementation_level<unsigned int>::value
PUBLIC	?value@?$is_pointer_helper@H@detail@boost@@2_NB	; boost::detail::is_pointer_helper<int>::value
PUBLIC	?value@?$result_@H@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<int>::value
PUBLIC	?value@?$is_pointer_impl@H@detail@boost@@2_NB	; boost::detail::is_pointer_impl<int>::value
PUBLIC	?value@?$is_base_and_derived_impl@Ubasic_traits@serialization@boost@@H@detail@boost@@2_NB ; boost::detail::is_base_and_derived_impl<boost::serialization::basic_traits,int>::value
PUBLIC	?value@?$is_arithmetic_impl@H@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<int>::value
PUBLIC	?value@?$implementation_level@H@serialization@boost@@2HB ; boost::serialization::implementation_level<int>::value
PUBLIC	?value@?$is_pointer_helper@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB ; boost::detail::is_pointer_helper<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
PUBLIC	?value@?$result_@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
PUBLIC	?value@?$is_pointer_impl@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB ; boost::detail::is_pointer_impl<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cerr
EXTRN	_strcspn:PROC
EXTRN	__invalid_parameter_noinfo:PROC
EXTRN	_sprintf_s:PROC
EXTRN	_memchr:PROC
EXTRN	??0bad_cast@std@@QAE@PBD@Z:PROC			; std::bad_cast::bad_cast
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?facet_Register@facet@locale@std@@CAXPAV123@@Z:PROC ; std::locale::facet::facet_Register
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	__Getcvt:PROC
EXTRN	_localeconv:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
EXTRN	??_Efacet@locale@std@@UAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??1bad_cast@std@@UAE@XZ:PROC			; std::bad_cast::~bad_cast
EXTRN	??0bad_cast@std@@QAE@ABV01@@Z:PROC		; std::bad_cast::bad_cast
EXTRN	?setbase@std@@YA?AU?$_Smanip@H@1@H@Z:PROC	; std::setbase
EXTRN	?_Lock@_Mutex@std@@QAEXXZ:PROC			; std::_Mutex::_Lock
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	??0exception@std@@QAE@XZ:PROC			; std::exception::exception
EXTRN	?_Xran@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xran
EXTRN	_memmove_s:PROC
EXTRN	?_Xlen@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xlen
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
EXTRN	_memcpy_s:PROC
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Unlock@_Mutex@std@@QAEXXZ:PROC		; std::_Mutex::_Unlock
?mappingScheme@Address@DRAMsimII@@1W4AddressMappingScheme@12@A DD 01H DUP (?) ; DRAMsimII::Address::mappingScheme
?bankAddressDepth@Address@DRAMsimII@@1IA DD 01H DUP (?)	; DRAMsimII::Address::bankAddressDepth
?columnLowAddressDepth@Address@DRAMsimII@@1IA DD 01H DUP (?) ; DRAMsimII::Address::columnLowAddressDepth
?columnSizeDepth@Address@DRAMsimII@@1IA DD 01H DUP (?)	; DRAMsimII::Address::columnSizeDepth
?columnAddressDepth@Address@DRAMsimII@@1IA DD 01H DUP (?) ; DRAMsimII::Address::columnAddressDepth
?columnHighAddressDepth@Address@DRAMsimII@@1IA DD 01H DUP (?) ; DRAMsimII::Address::columnHighAddressDepth
?rowLowAddressDepth@Address@DRAMsimII@@1IA DD 01H DUP (?) ; DRAMsimII::Address::rowLowAddressDepth
?rankAddressDepth@Address@DRAMsimII@@1IA DD 01H DUP (?)	; DRAMsimII::Address::rankAddressDepth
?channelAddressDepth@Address@DRAMsimII@@1IA DD 01H DUP (?) ; DRAMsimII::Address::channelAddressDepth
?rowHighAddressDepth@Address@DRAMsimII@@1IA DD 01H DUP (?) ; DRAMsimII::Address::rowHighAddressDepth
?rowAddressDepth@Address@DRAMsimII@@1IA DD 01H DUP (?)	; DRAMsimII::Address::rowAddressDepth
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@runtime_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@runtime_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ?value@?$is_pointer_impl@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_impl<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
CONST	ENDS
;	COMDAT ?value@?$result_@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_helper<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@H@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@H@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<int>::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@H@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@H@detail@boost@@2_NB DB 01H	; boost::detail::is_arithmetic_impl<int>::value
CONST	ENDS
;	COMDAT ?value@?$is_base_and_derived_impl@Ubasic_traits@serialization@boost@@H@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_base_and_derived_impl@Ubasic_traits@serialization@boost@@H@detail@boost@@2_NB DB 00H ; boost::detail::is_base_and_derived_impl<boost::serialization::basic_traits,int>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@H@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@H@detail@boost@@2_NB DB 00H	; boost::detail::is_pointer_impl<int>::value
CONST	ENDS
;	COMDAT ?value@?$result_@H@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@H@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<int>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@H@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@H@detail@boost@@2_NB DB 00H	; boost::detail::is_pointer_helper<int>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@I@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@I@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<unsigned int>::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@I@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@I@detail@boost@@2_NB DB 01H	; boost::detail::is_arithmetic_impl<unsigned int>::value
CONST	ENDS
;	COMDAT ?value@?$is_base_and_derived_impl@Ubasic_traits@serialization@boost@@I@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_base_and_derived_impl@Ubasic_traits@serialization@boost@@I@detail@boost@@2_NB DB 00H ; boost::detail::is_base_and_derived_impl<boost::serialization::basic_traits,unsigned int>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@I@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@I@detail@boost@@2_NB DB 00H	; boost::detail::is_pointer_impl<unsigned int>::value
CONST	ENDS
;	COMDAT ?value@?$result_@I@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@I@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<unsigned int>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@I@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@I@detail@boost@@2_NB DB 00H	; boost::detail::is_pointer_helper<unsigned int>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PAI@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PAI@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<unsigned int *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PAI@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PAI@detail@boost@@2_NB DB 00H	; boost::detail::cv_traits_imp<unsigned int *>::is_const
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@Uclass_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@Uclass_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_impl<boost::archive::class_id_type>::value
CONST	ENDS
;	COMDAT ?value@?$result_@Uclass_id_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@Uclass_id_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::class_id_type>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@Uclass_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@Uclass_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_helper<boost::archive::class_id_type>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PAUclass_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PAUclass_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::class_id_type *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PAUclass_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PAUclass_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::class_id_type *>::is_const
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@Uobject_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@Uobject_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_impl<boost::archive::object_id_type>::value
CONST	ENDS
;	COMDAT ?value@?$result_@Uobject_id_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@Uobject_id_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::object_id_type>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@Uobject_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@Uobject_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_helper<boost::archive::object_id_type>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PAUobject_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PAUobject_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::object_id_type *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PAUobject_id_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PAUobject_id_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::object_id_type *>::is_const
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@Uversion_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@Uversion_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_impl<boost::archive::version_type>::value
CONST	ENDS
;	COMDAT ?value@?$result_@Uversion_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@Uversion_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::version_type>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@Uversion_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@Uversion_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_helper<boost::archive::version_type>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PAUversion_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PAUversion_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::version_type *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PAUversion_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PAUversion_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::version_type *>::is_const
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@Utracking_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@Utracking_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_impl<boost::archive::tracking_type>::value
CONST	ENDS
;	COMDAT ?value@?$result_@Utracking_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@Utracking_type@archive@boost@@@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<boost::archive::tracking_type>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@Utracking_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@Utracking_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_pointer_helper<boost::archive::tracking_type>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PAUtracking_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PAUtracking_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::tracking_type *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PAUtracking_type@archive@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PAUtracking_type@archive@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::archive::tracking_type *>::is_const
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PBV?$iterator_range@V?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PBV?$iterator_range@V?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<boost::iterator_range<std::_String_iterator<char,std::char_traits<char>,std::allocator<char> > > const *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PBV?$iterator_range@V?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PBV?$iterator_range@V?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::cv_traits_imp<boost::iterator_range<std::_String_iterator<char,std::char_traits<char>,std::allocator<char> > > const *>::is_const
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ?value@?$is_abstract_imp@D@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_abstract_imp@D@detail@boost@@2_NB DB 00H	; boost::detail::is_abstract_imp<char>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::is_const
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@detail@boost@@2_NB DB 01H ; boost::detail::cv_traits_imp<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>::is_const
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT
??_C@_01KGKMHCOC@e?$AA@ DB 'e', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT
??_C@_01DDCIFGEA@E?$AA@ DB 'E', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp?$AA@ DB '%p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu?$AA@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld?$AA@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu?$AA@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld?$AA@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LOKBKELC@UNKWN?$AA@
CONST	SEGMENT
??_C@_05LOKBKELC@UNKWN?$AA@ DB 'UNKWN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IJIFNNNL@HILOC?$AA@
CONST	SEGMENT
??_C@_05IJIFNNNL@HILOC?$AA@ DB 'HILOC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JNFEGKGN@LOLOC?$AA@
CONST	SEGMENT
??_C@_05JNFEGKGN@LOLOC?$AA@ DB 'LOLOC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EKFNGKOK@845G?$AA@
CONST	SEGMENT
??_C@_04EKFNGKOK@845G?$AA@ DB '845G', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EINBLCDA@CPBOPT?$AA@
CONST	SEGMENT
??_C@_06EINBLCDA@CPBOPT?$AA@ DB 'CPBOPT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CODBJAID@CPBAS?$AA@
CONST	SEGMENT
??_C@_05CODBJAID@CPBAS?$AA@ DB 'CPBAS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LIIHKDFK@SDBAS?$AA@
CONST	SEGMENT
??_C@_05LIIHKDFK@SDBAS?$AA@ DB 'SDBAS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KAGHFJNN@SDHIPF?$AA@
CONST	SEGMENT
??_C@_06KAGHFJNN@SDHIPF?$AA@ DB 'SDHIPF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJGPNILD@BBM?$AA@
CONST	SEGMENT
??_C@_03NJGPNILD@BBM?$AA@ DB 'BBM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGJDIIGL@addr?$FL0x?$AA@
CONST	SEGMENT
??_C@_07DGJDIIGL@addr?$FL0x?$AA@ DB 'addr[0x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CEPNEMLG@?$FN?5chan?$FL?$AA@
CONST	SEGMENT
??_C@_07CEPNEMLG@?$FN?5chan?$FL?$AA@ DB '] chan[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LPMPCNEE@?$FN?5rank?$FL?$AA@
CONST	SEGMENT
??_C@_07LPMPCNEE@?$FN?5rank?$FL?$AA@ DB '] rank[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LMBJCPNP@?$FN?5bank?$FL?$AA@
CONST	SEGMENT
??_C@_07LMBJCPNP@?$FN?5bank?$FL?$AA@ DB '] bank[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MPJLADHA@?$FN?5row?$FL?$AA@
CONST	SEGMENT
??_C@_06MPJLADHA@?$FN?5row?$FL?$AA@ DB '] row[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGIPBND@?$FN?5col?$FL?$AA@
CONST	SEGMENT
??_C@_06ICGIPBND@?$FN?5col?$FL?$AA@ DB '] col[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN?$AA@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FBHDFKBD@Memory?5address?5?$CI?$AA@
CONST	SEGMENT
??_C@_0BB@FBHDFKBD@Memory?5address?5?$CI?$AA@ DB 'Memory address (', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@CJFGPHKC@?$CJ?5out?5of?5range?5of?5available?5phys@
CONST	SEGMENT
??_C@_0DC@CJFGPHKC@?$CJ?5out?5of?5range?5of?5available?5phys@ DB ') out o'
	DB	'f range of available physical memory, max(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ?$AA@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ?$AA@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@OGNDED@Unknown?5address?5mapping?5scheme?0?5@
CONST	SEGMENT
??_C@_0ED@OGNDED@Unknown?5address?5mapping?5scheme?0?5@ DB 'Unknown addre'
	DB	'ss mapping scheme, mapping chan, rank, bank to zero: ', 00H ; `string'
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@Uoutput@iostreams@boost@@Uinput@23@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@Uoutput@iostreams@boost@@Uinput@23@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_impl<boost::iostreams::output,boost::iostreams::input>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_basic_impl@AAUoutput@iostreams@boost@@Uinput@23@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_basic_impl@AAUoutput@iostreams@boost@@Uinput@23@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_basic_impl<boost::iostreams::output &,boost::iostreams::input>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$0A@@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$0A@@mpl@boost@@2HB DD 00H		; boost::mpl::int_<0>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Utracking_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Utracking_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::tracking_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Uobject_reference_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Uobject_reference_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::object_reference_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Uobject_id_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Uobject_id_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::object_id_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Uclass_name_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Uclass_name_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::class_name_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Uclass_id_optional_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Uclass_id_optional_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::class_id_optional_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Uclass_id_reference_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Uclass_id_reference_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::class_id_reference_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Uclass_id_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Uclass_id_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::class_id_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Uversion_type@archive@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Uversion_type@archive@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::archive::version_type>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@_WV?$allocator@_W@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@_WV?$allocator@_W@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<wchar_t,std::allocator<wchar_t> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@_KV?$allocator@_K@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@_KV?$allocator@_K@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<unsigned __int64,std::allocator<unsigned __int64> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@_JV?$allocator@_J@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@_JV?$allocator@_J@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<__int64,std::allocator<__int64> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@FV?$allocator@F@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@FV?$allocator@F@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<short,std::allocator<short> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@GV?$allocator@G@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@GV?$allocator@G@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<unsigned short,std::allocator<unsigned short> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@NV?$allocator@N@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@NV?$allocator@N@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<double,std::allocator<double> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@MV?$allocator@M@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@MV?$allocator@M@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<float,std::allocator<float> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@KV?$allocator@K@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@KV?$allocator@K@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<unsigned long,std::allocator<unsigned long> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@JV?$allocator@J@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@JV?$allocator@J@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<long,std::allocator<long> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@IV?$allocator@I@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@IV?$allocator@I@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<unsigned int,std::allocator<unsigned int> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@HV?$allocator@H@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@HV?$allocator@H@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<int,std::allocator<int> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@EV?$allocator@E@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@EV?$allocator@E@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<unsigned char,std::allocator<unsigned char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@CV?$allocator@C@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@CV?$allocator@C@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<signed char,std::allocator<signed char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@DV?$allocator@D@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@DV?$allocator@D@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<char,std::allocator<char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$list@_NV?$allocator@_N@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$list@_NV?$allocator@_N@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::list<bool,std::allocator<bool> > >::value
CONST	ENDS
;	COMDAT ?has_fixed_range@?$backward_compatible_uniform_01@V?$pass_through_engine@V?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@@detail@random@boost@@N@detail@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$backward_compatible_uniform_01@V?$pass_through_engine@V?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@@detail@random@boost@@N@detail@boost@@2_NB DB 00H ; boost::detail::backward_compatible_uniform_01<boost::random::detail::pass_through_engine<boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566> >,double>::has_fixed_range
CONST	ENDS
;	COMDAT ?has_fixed_range@?$backward_compatible_uniform_01@V?$pass_through_engine@AAV?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@@detail@random@boost@@N@detail@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$backward_compatible_uniform_01@V?$pass_through_engine@AAV?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@@detail@random@boost@@N@detail@boost@@2_NB DB 00H ; boost::detail::backward_compatible_uniform_01<boost::random::detail::pass_through_engine<boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566> &>,double>::has_fixed_range
CONST	ENDS
;	COMDAT ?value@?$is_unsigned_imp@H@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_unsigned_imp@H@detail@boost@@2_NB DB 00H	; boost::detail::is_unsigned_imp<int>::value
CONST	ENDS
;	COMDAT ?value@?$is_ununsigned_helper@H@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_ununsigned_helper@H@detail@boost@@2_NB DB 00H ; boost::detail::is_ununsigned_helper<int>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PAH@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PAH@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<int *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PAH@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PAH@detail@boost@@2_NB DB 00H	; boost::detail::cv_traits_imp<int *>::is_const
CONST	ENDS
;	COMDAT ?has_fixed_range@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2_NB DB 00H ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::has_fixed_range
CONST	ENDS
;	COMDAT ?output_l@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?output_l@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 012H ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_l
CONST	ENDS
;	COMDAT ?output_c@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB
CONST	SEGMENT
?output_c@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB DD 0efc60000H ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_c
CONST	ENDS
;	COMDAT ?output_t@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?output_t@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 0fH ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_t
CONST	ENDS
;	COMDAT ?output_b@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB
CONST	SEGMENT
?output_b@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB DD 09d2c5680H ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_b
CONST	ENDS
;	COMDAT ?output_s@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?output_s@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 07H ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_s
CONST	ENDS
;	COMDAT ?output_u@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?output_u@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 0bH ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::output_u
CONST	ENDS
;	COMDAT ?parameter_a@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB
CONST	SEGMENT
?parameter_a@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2KB DD 09908b0dfH ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::parameter_a
CONST	ENDS
;	COMDAT ?mask_bits@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?mask_bits@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 01fH ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::mask_bits
CONST	ENDS
;	COMDAT ?shift_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?shift_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 018dH ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::shift_size
CONST	ENDS
;	COMDAT ?state_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?state_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 0270H ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::state_size
CONST	ENDS
;	COMDAT ?word_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB
CONST	SEGMENT
?word_size@?$mersenne_twister@K$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0MHHGGGNO@@random@boost@@2HB DD 020H ; boost::random::mersenne_twister<unsigned long,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18,3346425566>::word_size
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@Uinput@iostreams@boost@@Uoutput@23@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@Uinput@iostreams@boost@@Uoutput@23@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_impl<boost::iostreams::input,boost::iostreams::output>::value
CONST	ENDS
;	COMDAT ?value@?$ice_and@$0A@$00$00$00$00$00$00@type_traits@boost@@2_NB
CONST	SEGMENT
?value@?$ice_and@$0A@$00$00$00$00$00$00@type_traits@boost@@2_NB DB 00H ; boost::type_traits::ice_and<0,1,1,1,1,1,1>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_basic_impl@AAUinput@iostreams@boost@@Uoutput@23@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_basic_impl@AAUinput@iostreams@boost@@Uoutput@23@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_basic_impl<boost::iostreams::input &,boost::iostreams::output>::value
CONST	ENDS
;	COMDAT ?value@?$is_abstract_imp@Uoutput@iostreams@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_abstract_imp@Uoutput@iostreams@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_abstract_imp<boost::iostreams::output>::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@Uoutput@iostreams@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@Uoutput@iostreams@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::iostreams::output>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@Uinput@iostreams@boost@@U123@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@Uinput@iostreams@boost@@U123@@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<boost::iostreams::input,boost::iostreams::input>::value
CONST	ENDS
;	COMDAT ?value@?$ice_not@$0A@@type_traits@boost@@2_NB
CONST	SEGMENT
?value@?$ice_not@$0A@@type_traits@boost@@2_NB DB 01H	; boost::type_traits::ice_not<0>::value
CONST	ENDS
;	COMDAT ?value@?$ice_or@$00$0A@$0A@$0A@$0A@$0A@$0A@@type_traits@boost@@2_NB
CONST	SEGMENT
?value@?$ice_or@$00$0A@$0A@$0A@$0A@$0A@$0A@@type_traits@boost@@2_NB DB 01H ; boost::type_traits::ice_or<1,0,0,0,0,0,0>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_basic_impl@AAUinput@iostreams@boost@@U123@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_basic_impl@AAUinput@iostreams@boost@@U123@@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_basic_impl<boost::iostreams::input &,boost::iostreams::input>::value
CONST	ENDS
;	COMDAT ?value@?$is_abstract_imp@Uinput@iostreams@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_abstract_imp@Uinput@iostreams@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_abstract_imp<boost::iostreams::input>::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@Uinput@iostreams@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@Uinput@iostreams@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::iostreams::input>::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@_WV?$allocator@_W@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@_WV?$allocator@_W@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<wchar_t,std::allocator<wchar_t> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@_KV?$allocator@_K@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@_KV?$allocator@_K@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<unsigned __int64,std::allocator<unsigned __int64> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@_JV?$allocator@_J@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@_JV?$allocator@_J@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<__int64,std::allocator<__int64> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@FV?$allocator@F@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@FV?$allocator@F@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<short,std::allocator<short> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@GV?$allocator@G@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@GV?$allocator@G@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<unsigned short,std::allocator<unsigned short> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@NV?$allocator@N@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@NV?$allocator@N@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<double,std::allocator<double> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@MV?$allocator@M@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@MV?$allocator@M@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<float,std::allocator<float> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@KV?$allocator@K@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@KV?$allocator@K@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<unsigned long,std::allocator<unsigned long> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@JV?$allocator@J@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@JV?$allocator@J@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<long,std::allocator<long> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@IV?$allocator@I@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@IV?$allocator@I@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<unsigned int,std::allocator<unsigned int> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@HV?$allocator@H@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@HV?$allocator@H@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<int,std::allocator<int> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@EV?$allocator@E@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@EV?$allocator@E@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<unsigned char,std::allocator<unsigned char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@CV?$allocator@C@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@CV?$allocator@C@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<signed char,std::allocator<signed char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@DV?$allocator@D@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@DV?$allocator@D@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<char,std::allocator<char> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@V?$vector@_NV?$allocator@_N@std@@@std@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@V?$vector@_NV?$allocator@_N@std@@@std@@@serialization@boost@@2HB DD 02H ; boost::serialization::implementation_level<std::vector<bool,std::allocator<bool> > >::value
CONST	ENDS
;	COMDAT ?value@?$implementation_level@Ucollection_size_type@serialization@boost@@@serialization@boost@@2HB
CONST	SEGMENT
?value@?$implementation_level@Ucollection_size_type@serialization@boost@@@serialization@boost@@2HB DD 01H ; boost::serialization::implementation_level<boost::serialization::collection_size_type>::value
CONST	ENDS
;	COMDAT ?step_size@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB
CONST	SEGMENT
?step_size@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB DD 04H ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::step_size
CONST	ENDS
;	COMDAT ?exponent2@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB
CONST	SEGMENT
?exponent2@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB DD 02H ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::exponent2
CONST	ENDS
;	COMDAT ?exponent1@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB
CONST	SEGMENT
?exponent1@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB DD 01dH ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::exponent1
CONST	ENDS
;	COMDAT ?word_size@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB
CONST	SEGMENT
?word_size@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2HB DD 020H ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::word_size
CONST	ENDS
;	COMDAT ?has_fixed_range@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@random@boost@@2_NB DB 00H ; boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>::has_fixed_range
CONST	ENDS
;	COMDAT ?shift2@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2HB
CONST	SEGMENT
?shift2@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2HB DD 00H ; boost::random::xor_combine<boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>,0,boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>,0,0>::shift2
CONST	ENDS
;	COMDAT ?shift1@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2HB
CONST	SEGMENT
?shift1@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2HB DD 00H ; boost::random::xor_combine<boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>,0,boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>,0,0>::shift1
CONST	ENDS
;	COMDAT ?has_fixed_range@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$xor_combine@V?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@$0A@V?$linear_feedback_shift@K$0CA@$0BN@$01$03$0A@@23@$0A@$0A@@random@boost@@2_NB DB 00H ; boost::random::xor_combine<boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>,0,boost::random::linear_feedback_shift<unsigned long,32,29,2,4,0>,0,0>::has_fixed_range
CONST	ENDS
;	COMDAT ?step_size@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB
CONST	SEGMENT
?step_size@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB DD 0cH ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::step_size
CONST	ENDS
;	COMDAT ?exponent2@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB
CONST	SEGMENT
?exponent2@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB DD 0dH ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::exponent2
CONST	ENDS
;	COMDAT ?exponent1@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB
CONST	SEGMENT
?exponent1@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB DD 01fH ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::exponent1
CONST	ENDS
;	COMDAT ?word_size@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB
CONST	SEGMENT
?word_size@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2HB DD 020H ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::word_size
CONST	ENDS
;	COMDAT ?has_fixed_range@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$linear_feedback_shift@K$0CA@$0BP@$0N@$0M@$0A@@random@boost@@2_NB DB 00H ; boost::random::linear_feedback_shift<unsigned long,32,31,13,12,0>::has_fixed_range
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0KNNB@$0FCCK@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0KNNB@$0FCCK@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,44497,21034>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0FKKJ@$0DEJO@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0FKKJ@$0DEJO@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,23209,13470>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0ENOB@$0CGHC@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0ENOB@$0CGHC@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,19937,9842>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0CFNJ@$0BFHO@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0CFNJ@$0BFHO@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,9689,5502>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0BBEH@$0IDC@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0BBEH@$0IDC@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,4423,2098>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0MJB@$0CEA@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0MJB@$0CEA@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,3217,576>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0IOJ@$0EOE@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0IOJ@$0EOE@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,2281,1252>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0EPP@$0BKC@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0EPP@$0BKC@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,1279,418>::is_specialized
CONST	ENDS
;	COMDAT ?is_specialized@?$fibonacci_validation@N$0CFP@$0BBB@@random@boost@@2_NB
CONST	SEGMENT
?is_specialized@?$fibonacci_validation@N$0CFP@$0BBB@@random@boost@@2_NB DB 01H ; boost::random::fibonacci_validation<double,607,273>::is_specialized
CONST	ENDS
;	COMDAT ?modulus@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB
CONST	SEGMENT
?modulus@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB DD 0ae529H ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::modulus
CONST	ENDS
;	COMDAT ?increment@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB
CONST	SEGMENT
?increment@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB DD 024d69H ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::increment
CONST	ENDS
;	COMDAT ?multiplier@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB
CONST	SEGMENT
?multiplier@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB DD 0556H ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::multiplier
CONST	ENDS
;	COMDAT ?max_value@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB
CONST	SEGMENT
?max_value@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB DD 0ae528H ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::max_value
CONST	ENDS
;	COMDAT ?min_value@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB
CONST	SEGMENT
?min_value@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2KB DD 00H ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::min_value
CONST	ENDS
;	COMDAT ?has_fixed_range@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$linear_congruential@K$0FFG@$0CENGJ@$0KOFCJ@$0A@@random@boost@@2_NB DB 01H ; boost::random::linear_congruential<unsigned long,1366,150889,714025,0>::has_fixed_range
CONST	ENDS
;	COMDAT ?modulus@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB
CONST	SEGMENT
?modulus@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB DD 07fffffabH ; boost::random::linear_congruential<long,40014,0,2147483563,0>::modulus
CONST	ENDS
;	COMDAT ?increment@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB
CONST	SEGMENT
?increment@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB DD 00H ; boost::random::linear_congruential<long,40014,0,2147483563,0>::increment
CONST	ENDS
;	COMDAT ?multiplier@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB
CONST	SEGMENT
?multiplier@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB DD 09c4eH ; boost::random::linear_congruential<long,40014,0,2147483563,0>::multiplier
CONST	ENDS
;	COMDAT ?max_value@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB
CONST	SEGMENT
?max_value@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB DD 07fffffaaH ; boost::random::linear_congruential<long,40014,0,2147483563,0>::max_value
CONST	ENDS
;	COMDAT ?min_value@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB
CONST	SEGMENT
?min_value@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2JB DD 01H ; boost::random::linear_congruential<long,40014,0,2147483563,0>::min_value
CONST	ENDS
;	COMDAT ?has_fixed_range@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$linear_congruential@J$0JMEO@$0A@$0HPPPPPKL@$0A@@random@boost@@2_NB DB 01H ; boost::random::linear_congruential<long,40014,0,2147483563,0>::has_fixed_range
CONST	ENDS
;	COMDAT ?modulus@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB
CONST	SEGMENT
?modulus@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB DQ 0001000000000000H ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::modulus
CONST	ENDS
;	COMDAT ?increment@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB
CONST	SEGMENT
?increment@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB DQ 000000000000000bH ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::increment
CONST	ENDS
;	COMDAT ?multiplier@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB
CONST	SEGMENT
?multiplier@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB DQ 00000005deece66dH ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::multiplier
CONST	ENDS
;	COMDAT ?max_value@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB
CONST	SEGMENT
?max_value@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB DQ 0000ffffffffffffH ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::max_value
CONST	ENDS
;	COMDAT ?min_value@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB
CONST	SEGMENT
?min_value@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_KB DQ 0000000000000000H ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::min_value
CONST	ENDS
;	COMDAT ?has_fixed_range@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@?$linear_congruential@_K$0FNOOMOGGN@$0L@$0BAAAAAAAAAAAA@$0A@@random@boost@@2_NB DB 01H ; boost::random::linear_congruential<unsigned __int64,25214903917,11,281474976710656,0>::has_fixed_range
CONST	ENDS
;	COMDAT ?max_value@rand48@boost@@2JB
CONST	SEGMENT
?max_value@rand48@boost@@2JB DD 07fffffffH		; boost::rand48::max_value
CONST	ENDS
;	COMDAT ?min_value@rand48@boost@@2JB
CONST	SEGMENT
?min_value@rand48@boost@@2JB DD 00H			; boost::rand48::min_value
CONST	ENDS
;	COMDAT ?has_fixed_range@rand48@boost@@2_NB
CONST	SEGMENT
?has_fixed_range@rand48@boost@@2_NB DB 01H		; boost::rand48::has_fixed_range
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@Ua128@align@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@Ua128@align@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_pod_impl<boost::align::a128>::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@Ua64@align@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@Ua64@align@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_pod_impl<boost::align::a64>::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@Ua32@align@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@Ua32@align@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_pod_impl<boost::align::a32>::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@Ua16@align@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@Ua16@align@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_pod_impl<boost::align::a16>::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@Ua8@align@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@Ua8@align@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_pod_impl<boost::align::a8>::value
CONST	ENDS
;	COMDAT ?found@?$type_with_alignment_imp@$07@detail@boost@@0IB
CONST	SEGMENT
?found@?$type_with_alignment_imp@$07@detail@boost@@0IB DD 08H ; boost::detail::type_with_alignment_imp<8>::found
CONST	ENDS
;	COMDAT ?value@?$is_aligned@$07$07@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_aligned@$07$07@detail@boost@@2_NB DB 01H	; boost::detail::is_aligned<8,8>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_of_impl@T?$lower_alignment@$07@detail@boost@@@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_of_impl@T?$lower_alignment@$07@detail@boost@@@detail@boost@@2IB DD 08H ; boost::detail::alignment_of_impl<boost::detail::lower_alignment<8> >::value
CONST	ENDS
;	COMDAT ?value@?$alignment_of_impl@_J@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_of_impl@_J@detail@boost@@2IB DD 08H	; boost::detail::alignment_of_impl<__int64>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_of_impl@J@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_of_impl@J@detail@boost@@2IB DD 04H	; boost::detail::alignment_of_impl<long>::value
CONST	ENDS
;	COMDAT ?value@?$integral_c@I$03@mpl@boost@@2IB
CONST	SEGMENT
?value@?$integral_c@I$03@mpl@boost@@2IB DD 04H		; boost::mpl::integral_c<unsigned int,4>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_of_impl@H@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_of_impl@H@detail@boost@@2IB DD 04H	; boost::detail::alignment_of_impl<int>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_logic@$03$03@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_logic@$03$03@detail@boost@@2IB DD 04H ; boost::detail::alignment_logic<4,4>::value
CONST	ENDS
;	COMDAT ?value@?$integral_c@I$01@mpl@boost@@2IB
CONST	SEGMENT
?value@?$integral_c@I$01@mpl@boost@@2IB DD 02H		; boost::mpl::integral_c<unsigned int,2>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_of_impl@F@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_of_impl@F@detail@boost@@2IB DD 02H	; boost::detail::alignment_of_impl<short>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_logic@$01$01@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_logic@$01$01@detail@boost@@2IB DD 02H ; boost::detail::alignment_logic<2,2>::value
CONST	ENDS
;	COMDAT ?value@?$integral_c@I$00@mpl@boost@@2IB
CONST	SEGMENT
?value@?$integral_c@I$00@mpl@boost@@2IB DD 01H		; boost::mpl::integral_c<unsigned int,1>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_of_impl@D@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_of_impl@D@detail@boost@@2IB DD 01H	; boost::detail::alignment_of_impl<char>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_logic@$00$00@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_logic@$00$00@detail@boost@@2IB DD 01H ; boost::detail::alignment_logic<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_c@I$07@mpl@boost@@2IB
CONST	SEGMENT
?value@?$integral_c@I$07@mpl@boost@@2IB DD 08H		; boost::mpl::integral_c<unsigned int,8>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_of_impl@Tmax_align@detail@boost@@@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_of_impl@Tmax_align@detail@boost@@@detail@boost@@2IB DD 08H ; boost::detail::alignment_of_impl<boost::detail::max_align>::value
CONST	ENDS
;	COMDAT ?value@?$alignment_logic@$07$07@detail@boost@@2IB
CONST	SEGMENT
?value@?$alignment_logic@$07$07@detail@boost@@2IB DD 08H ; boost::detail::alignment_logic<8,8>::value
CONST	ENDS
;	COMDAT ?value@?$integral_c@I$0A@@mpl@boost@@2IB
CONST	SEGMENT
?value@?$integral_c@I$0A@@mpl@boost@@2IB DD 00H		; boost::mpl::integral_c<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@$$CDX@detail@boost@@2_NB DB 01H	; boost::detail::is_pod_impl<void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@$$CCX@detail@boost@@2_NB DB 01H	; boost::detail::is_pod_impl<void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@$$CBX@detail@boost@@2_NB DB 01H	; boost::detail::is_pod_impl<void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_pod_impl@X@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pod_impl@X@detail@boost@@2_NB DB 01H	; boost::detail::is_pod_impl<void>::value
CONST	ENDS
;	COMDAT ?value@?$is_scalar_impl@$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_scalar_impl@$$CDX@detail@boost@@2_NB DB 00H	; boost::detail::is_scalar_impl<void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_scalar_impl@$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_scalar_impl@$$CCX@detail@boost@@2_NB DB 00H	; boost::detail::is_scalar_impl<void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_scalar_impl@$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_scalar_impl@$$CBX@detail@boost@@2_NB DB 00H	; boost::detail::is_scalar_impl<void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_scalar_impl@X@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_scalar_impl@X@detail@boost@@2_NB DB 00H	; boost::detail::is_scalar_impl<void>::value
CONST	ENDS
;	COMDAT ?value@?$is_member_function_pointer_impl@$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_member_function_pointer_impl@$$CDX@detail@boost@@2_NB DB 00H ; boost::detail::is_member_function_pointer_impl<void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_member_function_pointer_impl@$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_member_function_pointer_impl@$$CCX@detail@boost@@2_NB DB 00H ; boost::detail::is_member_function_pointer_impl<void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_member_function_pointer_impl@$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_member_function_pointer_impl@$$CBX@detail@boost@@2_NB DB 00H ; boost::detail::is_member_function_pointer_impl<void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_member_function_pointer_impl@X@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_member_function_pointer_impl@X@detail@boost@@2_NB DB 00H ; boost::detail::is_member_function_pointer_impl<void>::value
CONST	ENDS
;	COMDAT ?value@?$arg@$04@mpl@boost@@2HB
CONST	SEGMENT
?value@?$arg@$04@mpl@boost@@2HB DD 05H			; boost::mpl::arg<5>::value
CONST	ENDS
;	COMDAT ?value@?$arg@$03@mpl@boost@@2HB
CONST	SEGMENT
?value@?$arg@$03@mpl@boost@@2HB DD 04H			; boost::mpl::arg<4>::value
CONST	ENDS
;	COMDAT ?value@?$arg@$02@mpl@boost@@2HB
CONST	SEGMENT
?value@?$arg@$02@mpl@boost@@2HB DD 03H			; boost::mpl::arg<3>::value
CONST	ENDS
;	COMDAT ?value@?$arg@$01@mpl@boost@@2HB
CONST	SEGMENT
?value@?$arg@$01@mpl@boost@@2HB DD 02H			; boost::mpl::arg<2>::value
CONST	ENDS
;	COMDAT ?value@?$arg@$00@mpl@boost@@2HB
CONST	SEGMENT
?value@?$arg@$00@mpl@boost@@2HB DD 01H			; boost::mpl::arg<1>::value
CONST	ENDS
;	COMDAT ?value@?$arg@$0?0@mpl@boost@@2HB
CONST	SEGMENT
?value@?$arg@$0?0@mpl@boost@@2HB DD 0ffffffffH		; boost::mpl::arg<-1>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$0M@@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$0M@@mpl@boost@@2HB DD 0cH		; boost::mpl::int_<12>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$0L@@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$0L@@mpl@boost@@2HB DD 0bH		; boost::mpl::int_<11>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$09@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$09@mpl@boost@@2HB DD 0aH			; boost::mpl::int_<10>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$08@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$08@mpl@boost@@2HB DD 09H			; boost::mpl::int_<9>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$07@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$07@mpl@boost@@2HB DD 08H			; boost::mpl::int_<8>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$06@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$06@mpl@boost@@2HB DD 07H			; boost::mpl::int_<7>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$05@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$05@mpl@boost@@2HB DD 06H			; boost::mpl::int_<6>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$04@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$04@mpl@boost@@2HB DD 05H			; boost::mpl::int_<5>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$03@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$03@mpl@boost@@2HB DD 04H			; boost::mpl::int_<4>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$02@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$02@mpl@boost@@2HB DD 03H			; boost::mpl::int_<3>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$01@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$01@mpl@boost@@2HB DD 02H			; boost::mpl::int_<2>::value
CONST	ENDS
;	COMDAT ?value@?$int_@$00@mpl@boost@@2HB
CONST	SEGMENT
?value@?$int_@$00@mpl@boost@@2HB DD 01H			; boost::mpl::int_<1>::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0BF@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0BF@@detail@iostreams@boost@@2HB DD 013H ; boost::iostreams::detail::select_by_size<21>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0BF@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0BF@@detail@iostreams@boost@@2HB DD 013H ; boost::iostreams::detail::select_by_size<21>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0BE@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0BE@@detail@iostreams@boost@@2HB DD 012H ; boost::iostreams::detail::select_by_size<20>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0BE@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0BE@@detail@iostreams@boost@@2HB DD 012H ; boost::iostreams::detail::select_by_size<20>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0BD@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0BD@@detail@iostreams@boost@@2HB DD 011H ; boost::iostreams::detail::select_by_size<19>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0BD@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0BD@@detail@iostreams@boost@@2HB DD 011H ; boost::iostreams::detail::select_by_size<19>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0BC@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0BC@@detail@iostreams@boost@@2HB DD 010H ; boost::iostreams::detail::select_by_size<18>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0BC@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0BC@@detail@iostreams@boost@@2HB DD 010H ; boost::iostreams::detail::select_by_size<18>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0BB@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0BB@@detail@iostreams@boost@@2HB DD 0fH ; boost::iostreams::detail::select_by_size<17>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0BB@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0BB@@detail@iostreams@boost@@2HB DD 0fH ; boost::iostreams::detail::select_by_size<17>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0BA@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0BA@@detail@iostreams@boost@@2HB DD 0eH ; boost::iostreams::detail::select_by_size<16>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0BA@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0BA@@detail@iostreams@boost@@2HB DD 0eH ; boost::iostreams::detail::select_by_size<16>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0P@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0P@@detail@iostreams@boost@@2HB DD 0dH ; boost::iostreams::detail::select_by_size<15>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0P@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0P@@detail@iostreams@boost@@2HB DD 0dH ; boost::iostreams::detail::select_by_size<15>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0O@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0O@@detail@iostreams@boost@@2HB DD 0cH ; boost::iostreams::detail::select_by_size<14>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0O@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0O@@detail@iostreams@boost@@2HB DD 0cH ; boost::iostreams::detail::select_by_size<14>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0N@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0N@@detail@iostreams@boost@@2HB DD 0bH ; boost::iostreams::detail::select_by_size<13>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0N@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0N@@detail@iostreams@boost@@2HB DD 0bH ; boost::iostreams::detail::select_by_size<13>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0M@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0M@@detail@iostreams@boost@@2HB DD 0aH ; boost::iostreams::detail::select_by_size<12>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0M@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0M@@detail@iostreams@boost@@2HB DD 0aH ; boost::iostreams::detail::select_by_size<12>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$0L@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$0L@@detail@iostreams@boost@@2HB DD 09H ; boost::iostreams::detail::select_by_size<11>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$0L@@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$0L@@detail@iostreams@boost@@2HB DD 09H ; boost::iostreams::detail::select_by_size<11>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$09@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$09@detail@iostreams@boost@@2HB DD 08H ; boost::iostreams::detail::select_by_size<10>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$09@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$09@detail@iostreams@boost@@2HB DD 08H ; boost::iostreams::detail::select_by_size<10>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$08@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$08@detail@iostreams@boost@@2HB DD 07H ; boost::iostreams::detail::select_by_size<9>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$08@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$08@detail@iostreams@boost@@2HB DD 07H ; boost::iostreams::detail::select_by_size<9>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$07@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$07@detail@iostreams@boost@@2HB DD 06H ; boost::iostreams::detail::select_by_size<8>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$07@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$07@detail@iostreams@boost@@2HB DD 06H ; boost::iostreams::detail::select_by_size<8>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$06@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$06@detail@iostreams@boost@@2HB DD 05H ; boost::iostreams::detail::select_by_size<7>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$06@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$06@detail@iostreams@boost@@2HB DD 05H ; boost::iostreams::detail::select_by_size<7>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$05@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$05@detail@iostreams@boost@@2HB DD 04H ; boost::iostreams::detail::select_by_size<6>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$05@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$05@detail@iostreams@boost@@2HB DD 04H ; boost::iostreams::detail::select_by_size<6>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$04@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$04@detail@iostreams@boost@@2HB DD 03H ; boost::iostreams::detail::select_by_size<5>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$04@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$04@detail@iostreams@boost@@2HB DD 03H ; boost::iostreams::detail::select_by_size<5>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$03@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$03@detail@iostreams@boost@@2HB DD 02H ; boost::iostreams::detail::select_by_size<4>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$03@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$03@detail@iostreams@boost@@2HB DD 02H ; boost::iostreams::detail::select_by_size<4>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$02@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$02@detail@iostreams@boost@@2HB DD 01H ; boost::iostreams::detail::select_by_size<3>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$02@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$02@detail@iostreams@boost@@2HB DD 01H ; boost::iostreams::detail::select_by_size<3>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$01@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$01@detail@iostreams@boost@@2HB DD 00H ; boost::iostreams::detail::select_by_size<2>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$01@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$01@detail@iostreams@boost@@2HB DD 00H ; boost::iostreams::detail::select_by_size<2>::type::value
CONST	ENDS
;	COMDAT ?value@?$select_by_size@$00@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@?$select_by_size@$00@detail@iostreams@boost@@2HB DD 0ffffffffH ; boost::iostreams::detail::select_by_size<1>::value
CONST	ENDS
;	COMDAT ?value@type@?$select_by_size@$00@detail@iostreams@boost@@2HB
CONST	SEGMENT
?value@type@?$select_by_size@$00@detail@iostreams@boost@@2HB DD 0ffffffffH ; boost::iostreams::detail::select_by_size<1>::type::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CDX$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CDX$$CDX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const volatile ,void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CDX$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CDX$$CCX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const volatile ,void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CDX$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CDX$$CBX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const volatile ,void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CDXX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CDXX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const volatile ,void>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CCX$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CCX$$CDX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void volatile ,void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CCX$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CCX$$CCX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void volatile ,void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CCX$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CCX$$CBX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void volatile ,void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CCXX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CCXX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void volatile ,void>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CBX$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CBX$$CDX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const ,void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CBX$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CBX$$CCX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const ,void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CBX$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CBX$$CBX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const ,void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@$$CBXX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@$$CBXX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void const ,void>::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@X$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@X$$CDX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void,void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@X$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@X$$CCX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void,void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@X$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@X$$CBX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void,void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@XX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@XX@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<void,void>::value
CONST	ENDS
;	COMDAT ?value@?$ice_not@$00@type_traits@boost@@2_NB
CONST	SEGMENT
?value@?$ice_not@$00@type_traits@boost@@2_NB DB 00H	; boost::type_traits::ice_not<1>::value
CONST	ENDS
;	COMDAT ?value@?$ice_and@$00$00$00$00$00$00$00@type_traits@boost@@2_NB
CONST	SEGMENT
?value@?$ice_and@$00$00$00$00$00$00$00@type_traits@boost@@2_NB DB 01H ; boost::type_traits::ice_and<1,1,1,1,1,1,1>::value
CONST	ENDS
;	COMDAT ?value@?$ice_or@$0A@$0A@$0A@$0A@$0A@$0A@$0A@@type_traits@boost@@2_NB
CONST	SEGMENT
?value@?$ice_or@$0A@$0A@$0A@$0A@$0A@$0A@$0A@@type_traits@boost@@2_NB DB 00H ; boost::type_traits::ice_or<0,0,0,0,0,0,0>::value
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_KB
CONST	SEGMENT
?const_max@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_KB DQ ffffffffffffffffH ; boost::detail::integer_traits_base<unsigned __int64,0,-1>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_KB
CONST	SEGMENT
?const_min@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_KB DQ 0000000000000000H ; boost::detail::integer_traits_base<unsigned __int64,0,-1>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@_K$0A@$0?0@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<unsigned __int64,0,-1>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_JB
CONST	SEGMENT
?const_max@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_JB DQ 7fffffffffffffffH ; boost::detail::integer_traits_base<__int64,-9223372036854775808,9223372036854775807>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_JB
CONST	SEGMENT
?const_min@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_JB DQ 8000000000000000H ; boost::detail::integer_traits_base<__int64,-9223372036854775808,9223372036854775807>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@_J$0?IAAAAAAAAAAAAAAA@$0HPPPPPPPPPPPPPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<__int64,-9223372036854775808,9223372036854775807>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2KB
CONST	SEGMENT
?const_max@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2KB DD 0ffffffffH ; boost::detail::integer_traits_base<unsigned long,0,4294967295>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2KB
CONST	SEGMENT
?const_min@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2KB DD 00H ; boost::detail::integer_traits_base<unsigned long,0,4294967295>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@K$0A@$0PPPPPPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<unsigned long,0,4294967295>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2JB
CONST	SEGMENT
?const_max@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2JB DD 07fffffffH ; boost::detail::integer_traits_base<long,-2147483648,2147483647>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2JB
CONST	SEGMENT
?const_min@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2JB DD 080000000H ; boost::detail::integer_traits_base<long,-2147483648,2147483647>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@J$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<long,-2147483648,2147483647>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2IB
CONST	SEGMENT
?const_max@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2IB DD 0ffffffffH ; boost::detail::integer_traits_base<unsigned int,0,4294967295>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2IB
CONST	SEGMENT
?const_min@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2IB DD 00H ; boost::detail::integer_traits_base<unsigned int,0,4294967295>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@I$0A@$0PPPPPPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<unsigned int,0,4294967295>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2HB
CONST	SEGMENT
?const_max@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2HB DD 07fffffffH ; boost::detail::integer_traits_base<int,-2147483648,2147483647>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2HB
CONST	SEGMENT
?const_min@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2HB DD 080000000H ; boost::detail::integer_traits_base<int,-2147483648,2147483647>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@H$0?IAAAAAAA@$0HPPPPPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<int,-2147483648,2147483647>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2GB
CONST	SEGMENT
?const_max@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2GB DW 0ffffH ; boost::detail::integer_traits_base<unsigned short,0,65535>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2GB
CONST	SEGMENT
?const_min@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2GB DW 00H ; boost::detail::integer_traits_base<unsigned short,0,65535>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@G$0A@$0PPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<unsigned short,0,65535>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2FB
CONST	SEGMENT
?const_max@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2FB DW 07fffH ; boost::detail::integer_traits_base<short,-32768,32767>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2FB
CONST	SEGMENT
?const_min@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2FB DW 08000H ; boost::detail::integer_traits_base<short,-32768,32767>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@F$0?IAAA@$0HPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<short,-32768,32767>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_WB
CONST	SEGMENT
?const_max@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_WB DW 0ffffH ; boost::detail::integer_traits_base<wchar_t,0,65535>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_WB
CONST	SEGMENT
?const_min@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_WB DW 00H ; boost::detail::integer_traits_base<wchar_t,0,65535>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@_W$0A@$0PPPP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<wchar_t,0,65535>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2EB
CONST	SEGMENT
?const_max@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2EB DB 0ffH ; boost::detail::integer_traits_base<unsigned char,0,255>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2EB
CONST	SEGMENT
?const_min@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2EB DB 00H ; boost::detail::integer_traits_base<unsigned char,0,255>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@E$0A@$0PP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<unsigned char,0,255>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2CB
CONST	SEGMENT
?const_max@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2CB DB 07fH ; boost::detail::integer_traits_base<signed char,-128,127>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2CB
CONST	SEGMENT
?const_min@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2CB DB 080H ; boost::detail::integer_traits_base<signed char,-128,127>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@C$0?IA@$0HP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<signed char,-128,127>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2DB
CONST	SEGMENT
?const_max@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2DB DB 07fH ; boost::detail::integer_traits_base<char,-128,127>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2DB
CONST	SEGMENT
?const_min@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2DB DB 080H ; boost::detail::integer_traits_base<char,-128,127>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@D$0?IA@$0HP@@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<char,-128,127>::is_integral
CONST	ENDS
;	COMDAT ?const_max@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB
CONST	SEGMENT
?const_max@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<bool,0,1>::const_max
CONST	ENDS
;	COMDAT ?const_min@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB
CONST	SEGMENT
?const_min@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB DB 00H ; boost::detail::integer_traits_base<bool,0,1>::const_min
CONST	ENDS
;	COMDAT ?is_integral@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB
CONST	SEGMENT
?is_integral@?$integer_traits_base@_N$0A@$00@detail@boost@@2_NB DB 01H ; boost::detail::integer_traits_base<bool,0,1>::is_integral
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 01H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT __TI3?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI3?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA3?AVfailure@ios_base@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z40
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z40
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z40 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ DB 'ios_base::failbit se'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
_DATA	ENDS
;	COMDAT ?value@?$bool_@$0A@@mpl@boost@@2_NB
CONST	SEGMENT
?value@?$bool_@$0A@@mpl@boost@@2_NB DB 00H		; boost::mpl::bool_<0>::value
CONST	ENDS
;	COMDAT ?value@?$bool_@$00@mpl@boost@@2_NB
CONST	SEGMENT
?value@?$bool_@$00@mpl@boost@@2_NB DB 01H		; boost::mpl::bool_<1>::value
CONST	ENDS
;	COMDAT ?value@integral_c_tag@mpl@boost@@2HB
CONST	SEGMENT
?value@integral_c_tag@mpl@boost@@2HB DD 00H		; boost::mpl::integral_c_tag::value
CONST	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT
; __Ptr$ = eax

; 624  : 	{	// convert C string to _Elem sequence using _Cvtvec

	push	esi
	push	edi
	mov	edi, eax

; 625  : 	size_t _Count = ::strlen(_Ptr) + 1;

	lea	edx, DWORD PTR [eax+1]
$LL8@Maklocstr:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL8@Maklocstr
	sub	eax, edx
	lea	esi, DWORD PTR [eax+1]

; 626  : 	_Elem *_Ptrdest = _NEW_CRT _Elem[_Count];

	push	esi
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 627  : 
; 628  : #pragma warning(push)
; 629  : #pragma warning(disable: 6011)
; 630  : 	/* prefast noise */
; 631  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

	mov	ecx, eax
	test	esi, esi
	jbe	SHORT $LN1@Maklocstr
$LL3@Maklocstr:

; 632  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	mov	dl, BYTE PTR [edi]
	mov	BYTE PTR [ecx], dl
	dec	esi
	inc	ecx
	inc	edi
	test	esi, esi
	ja	SHORT $LL3@Maklocstr
$LN1@Maklocstr:
	pop	edi
	pop	esi

; 633  : 	return (_Ptrdest);
; 634  : #pragma warning(pop)
; 635  : 	}

	ret	0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ
_TEXT	SEGMENT
__Secure$ = -1						; size = 1
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ PROC ; std::_Char_traits_cat<std::char_traits<char> >, COMDAT

; 575  : 	{

	push	ecx

; 576  : 		typename _Char_traits_category<_Traits>::_Secure_char_traits _Secure;
; 577  : 		return (_Secure);

	mov	al, BYTE PTR __Secure$[esp+4]

; 578  : 	}

	pop	ecx
	ret	0
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ENDP ; std::_Char_traits_cat<std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 168  : 		return (xsputn(_Ptr, _Count));

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+32]
	jmp	eax
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC		; std::_Maklocchr<char>, COMDAT
; __Byte$ = eax

; 603  : 	return ((_Elem)(unsigned char)_Byte);
; 604  : 	}

	ret	0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\iomanip
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z
_TEXT	SEGMENT
??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,int>, COMDAT
; __Ostr$ = esi
; __Manip$ = ecx

; 82   : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	test	esi, esi
	jne	SHORT $LN3@operator@32
	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 83   : 	return (_Ostr);

	mov	eax, esi

; 84   : 	}

	ret	0
$LN3@operator@32:

; 82   : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	add	eax, esi
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 83   : 	return (_Ostr);

	mov	eax, esi

; 84   : 	}

	ret	0
??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	or	eax, -1

; 167  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$numpunct@D@std@@AAEXXZ PROC			; std::numpunct<char>::_Tidy, COMDAT
; _this$ = esi

; 191  : 		_DELETE_CRT_VEC((void *)_Grouping);

	mov	eax, DWORD PTR [esi+8]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]

; 192  : 		_DELETE_CRT_VEC((void *)_Falsename);

	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]

; 193  : 		_DELETE_CRT_VEC((void *)_Truename);

	mov	edx, DWORD PTR [esi+20]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH

; 194  : 		}

	ret	0
?_Tidy@?$numpunct@D@std@@AAEXXZ ENDP			; std::numpunct<char>::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?thousands_sep@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::thousands_sep, COMDAT
; _this$ = ecx

; 75   : 		return (do_thousands_sep());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	jmp	edx
?thousands_sep@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::thousands_sep
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?decimal_point@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::decimal_point, COMDAT
; _this$ = ecx

; 70   : 		return (do_decimal_point());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	jmp	edx
?decimal_point@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::decimal_point
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = eax

; 607  : 		return (*this);
; 608  : 		}

	ret	0
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = eax

; 602  : 		return (*this);
; 603  : 		}

	ret	0
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1671 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1672 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1673 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 170  : 		return (_Kseparator);

	mov	al, BYTE PTR [ecx+13]

; 171  : 		}

	ret	0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 165  : 		return (_Dp);

	mov	al, BYTE PTR [ecx+12]

; 166  : 		}

	ret	0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt, COMDAT
; __Fmt$ = eax
; __Spec$ = edi
; __Flags$ = edx

; 1432 : 		char *_Ptr = _Fmt;
; 1433 : 		*_Ptr++ = '%';

	mov	BYTE PTR [eax], 37			; 00000025H
	lea	ecx, DWORD PTR [eax+1]

; 1434 : 
; 1435 : 		if (_Flags & ios_base::showpos)

	test	dl, 32					; 00000020H
	je	SHORT $LN4@Ifmt

; 1436 : 			*_Ptr++ = '+';

	mov	BYTE PTR [ecx], 43			; 0000002bH
	inc	ecx
$LN4@Ifmt:

; 1437 : 		if (_Flags & ios_base::showbase)

	test	dl, 8
	je	SHORT $LN3@Ifmt

; 1438 : 			*_Ptr++ = '#';

	mov	BYTE PTR [ecx], 35			; 00000023H
	inc	ecx
$LN3@Ifmt:
	push	ebx

; 1439 : 		if (_Spec[0] != 'L')

	mov	bl, BYTE PTR [edi]
	push	esi
	cmp	bl, 76					; 0000004cH
	je	SHORT $LN2@Ifmt

; 1440 : 			*_Ptr++ = _Spec[0];	// qualifier

	mov	BYTE PTR [ecx], bl

; 1441 : 		else

	jmp	SHORT $LN11@Ifmt
$LN2@Ifmt:

; 1442 : 			{	/* change L to I64 */
; 1443 : 			*_Ptr++ = 'I';

	mov	BYTE PTR [ecx], 73			; 00000049H
	inc	ecx

; 1444 : 			*_Ptr++ = '6';

	mov	BYTE PTR [ecx], 54			; 00000036H
	inc	ecx

; 1445 : 			*_Ptr++ = '4';

	mov	BYTE PTR [ecx], 52			; 00000034H
$LN11@Ifmt:

; 1446 : 			}
; 1447 : 
; 1448 : 		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

	mov	esi, edx
	and	esi, 3584				; 00000e00H
	inc	ecx

; 1449 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
; 1450 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1451 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';

	cmp	esi, 1024				; 00000400H
	jne	SHORT $LN9@Ifmt
	mov	dl, 111					; 0000006fH
	pop	esi
	mov	BYTE PTR [ecx], dl

; 1452 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0
	pop	ebx

; 1453 : 		return (_Fmt);
; 1454 : 		}

	ret	0
$LN9@Ifmt:

; 1449 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
; 1450 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1451 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';

	cmp	esi, 2048				; 00000800H
	je	SHORT $LN7@Ifmt
	mov	dl, BYTE PTR [edi+1]
	pop	esi
	mov	BYTE PTR [ecx], dl

; 1452 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0
	pop	ebx

; 1453 : 		return (_Fmt);
; 1454 : 		}

	ret	0
$LN7@Ifmt:

; 1449 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
; 1450 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1451 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';

	add	dl, dl
	add	dl, dl
	add	dl, dl
	not	dl
	and	dl, 32					; 00000020H
	or	dl, 88					; 00000058H
	pop	esi
	mov	BYTE PTR [ecx], dl

; 1452 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0
	pop	ebx

; 1453 : 		return (_Fmt);
; 1454 : 		}

	ret	0
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
__Spec$ = 8						; size = 1
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT
; __Fmt$ = eax
; __Flags$ = edx

; 1288 : 		{	// generate sprintf format for floating-point

	push	ebx
	mov	bl, BYTE PTR __Spec$[esp]

; 1289 : 		char *_Ptr = _Fmt;
; 1290 : 		*_Ptr++ = '%';

	mov	BYTE PTR [eax], 37			; 00000025H
	lea	ecx, DWORD PTR [eax+1]

; 1291 : 
; 1292 : 		if (_Flags & ios_base::showpos)

	test	dl, 32					; 00000020H
	je	SHORT $LN3@Ffmt

; 1293 : 			*_Ptr++ = '+';

	mov	BYTE PTR [ecx], 43			; 0000002bH
	inc	ecx
$LN3@Ffmt:

; 1294 : 		if (_Flags & ios_base::showpoint)

	test	dl, 16					; 00000010H
	je	SHORT $LN2@Ffmt

; 1295 : 			*_Ptr++ = '#';

	mov	BYTE PTR [ecx], 35			; 00000023H
	inc	ecx
$LN2@Ffmt:

; 1296 : 		*_Ptr++ = '.';

	mov	BYTE PTR [ecx], 46			; 0000002eH
	inc	ecx

; 1297 : 		*_Ptr++ = '*';	// for precision argument

	mov	BYTE PTR [ecx], 42			; 0000002aH
	inc	ecx

; 1298 : 		if (_Spec != '\0')

	test	bl, bl
	je	SHORT $LN1@Ffmt

; 1299 : 			*_Ptr++ = _Spec;	// 'L' qualifier for long double only

	mov	BYTE PTR [ecx], bl
	inc	ecx
$LN1@Ffmt:

; 1300 : 
; 1301 : 		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

	and	edx, 12288				; 00003000H
	pop	ebx

; 1302 : 		*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1303 : 			: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1304 : 			: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

	cmp	edx, 8192				; 00002000H
	jne	SHORT $LN8@Ffmt
	mov	dl, 102					; 00000066H
	mov	BYTE PTR [ecx], dl

; 1305 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0

; 1306 : 		return (_Fmt);
; 1307 : 		}

	ret	0
$LN8@Ffmt:

; 1302 : 		*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1303 : 			: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1304 : 			: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

	cmp	edx, 12288				; 00003000H
	jne	SHORT $LN6@Ffmt
	mov	dl, 97					; 00000061H
	mov	BYTE PTR [ecx], dl

; 1305 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0

; 1306 : 		return (_Fmt);
; 1307 : 		}

	ret	0
$LN6@Ffmt:

; 1302 : 		*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1303 : 			: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1304 : 			: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

	cmp	edx, 4096				; 00001000H
	setne	dl
	lea	edx, DWORD PTR [edx+edx+101]
	mov	BYTE PTR [ecx], dl

; 1305 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0

; 1306 : 		return (_Fmt);
; 1307 : 		}

	ret	0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 271  : 		--*_IPcount;

	mov	eax, DWORD PTR [ecx+52]
	dec	DWORD PTR [eax]

; 272  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx

; 273  : 		}

	ret	0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 173  : 		_Mylock._Lock();

	add	ecx, 4
	jmp	?_Lock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Lock
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 73   : 		return (_Tiestr);

	mov	eax, DWORD PTR [ecx+44]

; 74   : 		}

	ret	0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2170 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx+4]

; 2171 : 		}

	ret	0
$LN3@Myptr:

; 2170 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	lea	eax, DWORD PTR [ecx+4]

; 2171 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed, COMDAT
; _this$ = eax

; 617  : 		return (_Failed);

	mov	al, BYTE PTR [eax]

; 618  : 		}

	ret	0
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = eax
; __Sb$ = ecx

; 583  : 		{	// construct from stream buffer _Sb

	mov	BYTE PTR [eax], 0
	mov	DWORD PTR [eax+4], ecx

; 584  : 		}

	ret	0
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
__Fill$ = 12						; size = 1
__Val$ = 16						; size = 8
__Dest$ = 24						; size = 8
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi

; 1098 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	mov	edx, DWORD PTR __Val$[esp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	mov	edx, DWORD PTR __Val$[esp]
	push	edx
	mov	edx, DWORD PTR __Fill$[esp+4]
	push	edx
	mov	edx, DWORD PTR __Iosbase$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	edx
	push	esi
	call	eax
	mov	eax, esi

; 1099 : 		}

	ret	24					; 00000018H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
__Fill$ = 12						; size = 1
__Dest$ = 16						; size = 8
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi
; __Val$ = edx

; 1085 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+24]
	push	edx
	mov	edx, DWORD PTR __Fill$[esp]
	push	edx
	mov	edx, DWORD PTR __Iosbase$[esp+4]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+12]
	push	edx
	push	esi
	call	eax
	mov	eax, esi

; 1086 : 		}

	ret	16					; 00000010H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 116  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 117  : 			}

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = ecx

; 277  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+36]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Pnavail
	mov	ecx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [ecx]

; 278  : 		}

	ret	0
$LN3@Pnavail:

; 277  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	xor	eax, eax

; 278  : 		}

	ret	0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 178  : 		_Mylock._Unlock();

	add	ecx, 4
	jmp	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 100  : 		return (sync());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+48]
	jmp	edx
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
_TEXT	ENDS
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx

; 106  : 		return (_Fillch);

	mov	al, BYTE PTR [ecx+48]

; 107  : 		}

	ret	0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 478  : 		{	// copy constructor

	mov	eax, ecx

; 479  : #if defined(_DEBUG)
; 480  : 		if (_Right._Myfirstiter == _IGNORE_MYITERLIST)
; 481  : 			{
; 482  : 			this->_Myfirstiter = _IGNORE_MYITERLIST;
; 483  : 			}
; 484  : #endif
; 485  : 		}

	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 472  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 473  : 		}

	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2175 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr@2
	mov	eax, DWORD PTR [ecx+4]

; 2176 : 		}

	ret	0
$LN3@Myptr@2:

; 2175 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	lea	eax, DWORD PTR [ecx+4]

; 2176 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 85   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ecx+40]

; 86   : 		}

	ret	0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
_TEXT	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z
_TEXT	SEGMENT
__Pfn$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = esi

; 185  : 		_DEBUG_POINTER(_Pfn);
; 186  : 		(*_Pfn)(*(ios_base *)this);

	test	esi, esi
	jne	SHORT $LN3@operator@33
	xor	eax, eax
	push	eax
	call	DWORD PTR __Pfn$[esp]
	add	esp, 4

; 187  : 		return (*this);

	mov	eax, esi

; 188  : 		}

	ret	4
$LN3@operator@33:

; 185  : 		_DEBUG_POINTER(_Pfn);
; 186  : 		(*_Pfn)(*(ios_base *)this);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	add	eax, esi
	push	eax
	call	DWORD PTR __Pfn$[esp]
	add	esp, 4

; 187  : 		return (*this);

	mov	eax, esi

; 188  : 		}

	ret	4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
_TEXT	SEGMENT
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = esi

; 172  : 		_DEBUG_POINTER(_Pfn);
; 173  : 		return ((*_Pfn)(*this));

	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	eax, esi

; 174  : 		}

	ret	0
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1666 : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+20]

; 1667 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1651 : 		return (_Myptr());

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN5@c_str
	mov	eax, DWORD PTR [ecx+4]

; 1652 : 		}

	ret	0

; 1651 : 		return (_Myptr());

$LN5@c_str:
	lea	eax, DWORD PTR [ecx+4]

; 1652 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	??8Address@DRAMsimII@@QBE_NABV01@@Z		; DRAMsimII::Address::operator==
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.cpp
_TEXT	SEGMENT
??8Address@DRAMsimII@@QBE_NABV01@@Z PROC		; DRAMsimII::Address::operator==
; _this$ = ecx
; _right$ = eax

; 843  : 	return channel == right.channel && rank == right.rank && bank == right.bank && row == right.row && column == right.column;

	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR [eax+16]
	jne	SHORT $LN3@operator@34
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN3@operator@34
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR [eax+24]
	jne	SHORT $LN3@operator@34
	mov	edx, DWORD PTR [ecx+28]
	cmp	edx, DWORD PTR [eax+28]
	jne	SHORT $LN3@operator@34
	mov	ecx, DWORD PTR [ecx+32]
	cmp	ecx, DWORD PTR [eax+32]
	jne	SHORT $LN3@operator@34
	mov	eax, 1

; 844  : }

	ret	0
$LN3@operator@34:

; 843  : 	return channel == right.channel && rank == right.rank && bank == right.bank && row == right.row && column == right.column;

	xor	eax, eax

; 844  : }

	ret	0
??8Address@DRAMsimII@@QBE_NABV01@@Z ENDP		; DRAMsimII::Address::operator==
_TEXT	ENDS
PUBLIC	?setAddress@Address@DRAMsimII@@QAEXABV12@@Z	; DRAMsimII::Address::setAddress
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?setAddress@Address@DRAMsimII@@QAEXABV12@@Z PROC	; DRAMsimII::Address::setAddress
; _this$ = ecx
; _rhs$ = eax

; 789  : 	channel = rhs.channel;

	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx

; 790  : 	rank = rhs.rank;

	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], edx

; 791  : 	bank = rhs.bank;

	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+24], edx

; 792  : 	column = rhs.column;

	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR [ecx+32], edx

; 793  : 	row = rhs.row;

	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+28], eax

; 794  : }

	ret	0
?setAddress@Address@DRAMsimII@@QAEXABV12@@Z ENDP	; DRAMsimII::Address::setAddress
_TEXT	ENDS
PUBLIC	?highestAddress@Address@DRAMsimII@@SA_KXZ	; DRAMsimII::Address::highestAddress
EXTRN	__allshl:PROC
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?highestAddress@Address@DRAMsimII@@SA_KXZ PROC		; DRAMsimII::Address::highestAddress

; 765  : 	return ((PhysicalAddress)1 << (columnLowAddressDepth + columnHighAddressDepth + channelAddressDepth + rankAddressDepth + bankAddressDepth + rowAddressDepth + columnSizeDepth)) - 1;

	mov	eax, DWORD PTR ?rowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::rowAddressDepth
	mov	ecx, DWORD PTR ?columnSizeDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnSizeDepth
	add	ecx, eax
	add	ecx, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::bankAddressDepth
	mov	eax, 1
	add	ecx, DWORD PTR ?rankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::rankAddressDepth
	xor	edx, edx
	add	ecx, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::channelAddressDepth
	add	ecx, DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnHighAddressDepth
	add	ecx, DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnLowAddressDepth
	call	__allshl
	add	eax, -1
	adc	edx, -1

; 766  : }

	ret	0
?highestAddress@Address@DRAMsimII@@SA_KXZ ENDP		; DRAMsimII::Address::highestAddress
_TEXT	ENDS
PUBLIC	?reverseAddressTranslation@Address@DRAMsimII@@IAE_NXZ ; DRAMsimII::Address::reverseAddressTranslation
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_columnLow$ = -8					; size = 4
_shift$ = -4						; size = 4
?reverseAddressTranslation@Address@DRAMsimII@@IAE_NXZ PROC ; DRAMsimII::Address::reverseAddressTranslation
; _this$ = esi

; 144  : {

	sub	esp, 8

; 145  : 	unsigned columnLow = column & ((1 << columnLowAddressDepth) - 1);

	mov	eax, DWORD PTR [esi+32]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnLowAddressDepth
	mov	ecx, ebp
	mov	edx, 1
	shl	edx, cl

; 146  : 	unsigned columnHigh = column >> columnLowAddressDepth;

	mov	ebx, eax
	shr	ebx, cl

; 147  : 	unsigned shift = columnSizeDepth;
; 148  : 
; 149  : 	switch (mappingScheme)

	mov	ecx, DWORD PTR ?mappingScheme@Address@DRAMsimII@@1W4AddressMappingScheme@12@A ; DRAMsimII::Address::mappingScheme
	dec	edx
	push	edi
	mov	edi, DWORD PTR ?columnSizeDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnSizeDepth
	and	edx, eax
	mov	DWORD PTR _columnLow$[esp+20], edx
	mov	DWORD PTR _shift$[esp+20], edi
	cmp	ecx, 6
	ja	$LN1@reverseAdd
	jmp	DWORD PTR $LN16@reverseAdd[ecx*4]
$LN9@reverseAdd:

; 150  : 	{
; 151  : 	case SDRAM_HIPERF_MAP:
; 152  : 
; 153  : 		physicalAddress = (PhysicalAddress)columnLow << shift;

	movd	xmm0, DWORD PTR _columnLow$[esp+20]
	movd	xmm1, DWORD PTR _shift$[esp+20]

; 154  : 		shift += columnLowAddressDepth;
; 155  : 		physicalAddress |= (PhysicalAddress)channel << shift;

	mov	eax, DWORD PTR [esi+16]
	add	edi, ebp
	psllq	xmm0, xmm1
	xor	edx, edx
	mov	ecx, edi
	movq	QWORD PTR [esi+8], xmm0
	call	__allshl

; 156  : 		shift += channelAddressDepth;

	add	edi, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::channelAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 157  : 		physicalAddress |= (PhysicalAddress)columnHigh << shift;

	mov	eax, ebx
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 158  : 		shift += columnHighAddressDepth;

	add	edi, DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnHighAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 159  : 		physicalAddress |= (PhysicalAddress)bank << shift;

	mov	eax, DWORD PTR [esi+24]
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 160  : 		shift += bankAddressDepth;

	add	edi, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::bankAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 161  : 		physicalAddress |= (PhysicalAddress)rank << shift;

	mov	eax, DWORD PTR [esi+20]
	xor	edx, edx
	mov	ecx, edi
	call	__allshl
	or	DWORD PTR [esi+8], eax

; 162  : 		shift += rankAddressDepth;

	mov	eax, DWORD PTR ?rankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::rankAddressDepth
	or	DWORD PTR [esi+12], edx
	lea	ecx, DWORD PTR [eax+edi]

; 163  : 		physicalAddress |= (PhysicalAddress)row << shift;

	mov	eax, DWORD PTR [esi+28]

; 164  : 
; 165  : 		break;

	jmp	$LN14@reverseAdd
$LN8@reverseAdd:

; 166  : 	case SDRAM_BASE_MAP:
; 167  : 
; 168  : 		physicalAddress = (PhysicalAddress)columnLow << shift;

	movd	xmm0, DWORD PTR _columnLow$[esp+20]
	movd	xmm1, DWORD PTR _shift$[esp+20]

; 169  : 		shift += columnLowAddressDepth;
; 170  : 		physicalAddress |= (PhysicalAddress)channel << shift;

	mov	eax, DWORD PTR [esi+16]
	add	edi, ebp
	psllq	xmm0, xmm1
	xor	edx, edx
	mov	ecx, edi
	movq	QWORD PTR [esi+8], xmm0
	call	__allshl

; 171  : 		shift += channelAddressDepth;

	add	edi, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::channelAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 172  : 		physicalAddress |= (PhysicalAddress)columnHigh << shift;

	mov	eax, ebx
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 173  : 		shift += columnHighAddressDepth;

	add	edi, DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnHighAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 174  : 		physicalAddress |= (PhysicalAddress)bank << shift;

	mov	eax, DWORD PTR [esi+24]
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 175  : 		shift += bankAddressDepth;

	add	edi, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::bankAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 176  : 		physicalAddress |= (PhysicalAddress)row << shift;

	mov	eax, DWORD PTR [esi+28]
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 177  : 		shift += rowAddressDepth;

	mov	ecx, DWORD PTR ?rowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::rowAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx
	add	ecx, edi

; 178  : 		physicalAddress |= (PhysicalAddress)rank << shift;
; 179  : 
; 180  : 		break;

	jmp	$LN15@reverseAdd
$LN7@reverseAdd:

; 181  : 	case CLOSE_PAGE_BASELINE:
; 182  : 
; 183  : 		physicalAddress = (PhysicalAddress)columnLow << shift;

	movd	xmm0, DWORD PTR _columnLow$[esp+20]
	movd	xmm1, DWORD PTR _shift$[esp+20]

; 184  : 		shift += columnLowAddressDepth;
; 185  : 		physicalAddress |= (PhysicalAddress)channel << shift;

	mov	eax, DWORD PTR [esi+16]
	add	edi, ebp
	psllq	xmm0, xmm1
	xor	edx, edx
	mov	ecx, edi
	movq	QWORD PTR [esi+8], xmm0
	call	__allshl

; 186  : 		shift += channelAddressDepth;

	add	edi, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::channelAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 187  : 		physicalAddress |= (PhysicalAddress)bank << shift;

	mov	eax, DWORD PTR [esi+24]
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 188  : 		shift += bankAddressDepth;

	add	edi, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::bankAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 189  : 		physicalAddress |= (PhysicalAddress)rank << shift;

	mov	eax, DWORD PTR [esi+20]
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 190  : 		shift += rankAddressDepth;

	add	edi, DWORD PTR ?rankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::rankAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 191  : 		physicalAddress |= (PhysicalAddress)columnHigh << shift;

	mov	eax, ebx
	xor	edx, edx
	mov	ecx, edi
	call	__allshl
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 192  : 		shift += columnHighAddressDepth;

	mov	edx, DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnHighAddressDepth

; 193  : 		physicalAddress |= (PhysicalAddress)row << shift;

	mov	eax, DWORD PTR [esi+28]
	lea	ecx, DWORD PTR [edx+edi]

; 194  : 
; 195  : 		break;

	jmp	$LN14@reverseAdd
$LN6@reverseAdd:

; 196  : 
; 197  : 	case CLOSE_PAGE_BASELINE_OPT:
; 198  : 		{
; 199  : 			unsigned rowLow = row & 0x07;
; 200  : 			unsigned rowHigh = row >> 3;
; 201  : 			physicalAddress = (PhysicalAddress)columnLow << shift;

	movd	xmm0, DWORD PTR _columnLow$[esp+20]
	movd	xmm1, DWORD PTR _shift$[esp+20]

; 202  : 			shift += columnLowAddressDepth;
; 203  : 			physicalAddress |= (PhysicalAddress)channel << shift;

	mov	eax, DWORD PTR [esi+16]
	add	edi, ebp
	psllq	xmm0, xmm1
	xor	edx, edx
	mov	ecx, edi
	movq	QWORD PTR [esi+8], xmm0
	call	__allshl

; 204  : 			shift += channelAddressDepth;

	add	edi, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::channelAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 205  : 			physicalAddress |= (PhysicalAddress)bank << shift;

	mov	eax, DWORD PTR [esi+24]
	xor	edx, edx
	mov	ecx, edi
	call	__allshl
	or	DWORD PTR [esi+8], eax
	mov	ebp, DWORD PTR [esi+28]

; 206  : 			shift += bankAddressDepth;

	add	edi, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::bankAddressDepth
	or	DWORD PTR [esi+12], edx
	mov	eax, ebp
	and	eax, 7

; 207  : 			physicalAddress |= (PhysicalAddress)rowLow << shift;

	xor	edx, edx
	mov	ecx, edi
	call	__allshl
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 208  : 			shift += 3;
; 209  : 			physicalAddress |= (PhysicalAddress)rank << shift;

	mov	eax, DWORD PTR [esi+20]
	add	edi, 3
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 210  : 			shift += rankAddressDepth;

	add	edi, DWORD PTR ?rankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::rankAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 211  : 			physicalAddress |= (PhysicalAddress)columnHigh << shift;

	mov	eax, ebx
	xor	edx, edx
	mov	ecx, edi
	call	__allshl
	or	DWORD PTR [esi+8], eax

; 212  : 			shift += columnHighAddressDepth;

	mov	ecx, DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnHighAddressDepth
	or	DWORD PTR [esi+12], edx
	mov	eax, ebp
	shr	eax, 3
	add	ecx, edi

; 213  : 			physicalAddress |= (PhysicalAddress)rowHigh << shift;
; 214  : 
; 215  : 			break;

	jmp	$LN14@reverseAdd
$LN5@reverseAdd:

; 216  : 		}
; 217  : 	case CLOSE_PAGE_LOW_LOCALITY:
; 218  : 
; 219  : 		physicalAddress = (PhysicalAddress)channel << shift;

	mov	eax, DWORD PTR [esi+16]
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 220  : 		shift += channelAddressDepth;

	add	edi, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::channelAddressDepth
	mov	DWORD PTR [esi+8], eax

; 221  : 		physicalAddress |= (PhysicalAddress)rank << shift;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+12], edx
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 222  : 		shift += rankAddressDepth;

	add	edi, DWORD PTR ?rankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::rankAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 223  : 		physicalAddress |= (PhysicalAddress)bank << shift;

	mov	eax, DWORD PTR [esi+24]
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 224  : 		shift += bankAddressDepth;

	add	edi, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::bankAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 225  : 		physicalAddress |= (PhysicalAddress)columnLow << shift;

	mov	eax, DWORD PTR _columnLow$[esp+20]
	xor	edx, edx
	mov	ecx, edi
	call	__allshl
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 226  : 		shift += columnLowAddressDepth;
; 227  : 		physicalAddress |= (PhysicalAddress)row << shift;

	mov	eax, DWORD PTR [esi+28]
	add	edi, ebp
	xor	edx, edx
	mov	ecx, edi
	call	__allshl
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 228  : 		shift += rowAddressDepth;

	mov	edx, DWORD PTR ?rowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::rowAddressDepth
	lea	ecx, DWORD PTR [edx+edi]

; 229  : 		physicalAddress |= (PhysicalAddress)columnHigh << shift;

	mov	eax, ebx

; 230  : 
; 231  : 		break;

	jmp	$LN14@reverseAdd
$LN4@reverseAdd:

; 232  : 
; 233  : 	case CLOSE_PAGE_HIGH_LOCALITY:
; 234  : 
; 235  : 		physicalAddress = (PhysicalAddress)columnLow << shift;

	movd	xmm0, DWORD PTR _columnLow$[esp+20]
	movd	xmm1, DWORD PTR _shift$[esp+20]

; 236  : 		shift += columnLowAddressDepth;
; 237  : 		physicalAddress |= (PhysicalAddress)row << shift;

	mov	eax, DWORD PTR [esi+28]
	add	edi, ebp
	psllq	xmm0, xmm1
	xor	edx, edx
	mov	ecx, edi
	movq	QWORD PTR [esi+8], xmm0
	call	__allshl

; 238  : 		shift += rowAddressDepth;

	add	edi, DWORD PTR ?rowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::rowAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 239  : 		physicalAddress |= (PhysicalAddress)columnHigh << shift;

	mov	eax, ebx
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 240  : 		shift += columnHighAddressDepth;

	add	edi, DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnHighAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 241  : 		physicalAddress |= (PhysicalAddress)channel << shift;

	mov	eax, DWORD PTR [esi+16]
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 242  : 		shift += channelAddressDepth;

	add	edi, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::channelAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 243  : 		physicalAddress |= (PhysicalAddress)bank << shift;

	mov	eax, DWORD PTR [esi+24]
	xor	edx, edx
	mov	ecx, edi
	call	__allshl
	or	DWORD PTR [esi+8], eax

; 244  : 		shift += bankAddressDepth;

	mov	eax, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::bankAddressDepth
	or	DWORD PTR [esi+12], edx
	lea	ecx, DWORD PTR [eax+edi]

; 245  : 		physicalAddress |= (PhysicalAddress)rank << shift;
; 246  : 
; 247  : 		break;

	jmp	SHORT $LN15@reverseAdd
$LN3@reverseAdd:

; 248  : 
; 249  : 	case INTEL845G_MAP:
; 250  : 
; 251  : 		physicalAddress = (PhysicalAddress)column << 10;

	xor	ecx, ecx
	shld	ecx, eax, 10
	shl	eax, 10					; 0000000aH

; 252  : 		shift += columnLowAddressDepth;

	add	edi, ebp

; 253  : 		physicalAddress |= (PhysicalAddress)bank << shift;

	mov	ebp, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], ecx
	xor	edx, edx
	mov	eax, ebp
	mov	ecx, edi
	call	__allshl

; 254  : 		shift += rowAddressDepth;

	add	edi, DWORD PTR ?rowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::rowAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 255  : 		physicalAddress |= (PhysicalAddress)columnHigh << shift;

	mov	eax, ebx
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 256  : 		shift += columnHighAddressDepth;

	add	edi, DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnHighAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 257  : 		physicalAddress |= (PhysicalAddress)channel << shift;

	mov	eax, DWORD PTR [esi+16]
	xor	edx, edx
	mov	ecx, edi
	call	__allshl

; 258  : 		shift += channelAddressDepth;

	add	edi, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::channelAddressDepth
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 259  : 		physicalAddress |= (PhysicalAddress)bank << shift;

	mov	eax, ebp
	xor	edx, edx
	mov	ecx, edi
	call	__allshl
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx

; 260  : 		shift += bankAddressDepth;

	mov	edx, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::bankAddressDepth
	lea	ecx, DWORD PTR [edx+edi]
$LN15@reverseAdd:

; 261  : 		physicalAddress |= (PhysicalAddress)rank << shift;

	mov	eax, DWORD PTR [esi+20]
$LN14@reverseAdd:
	xor	edx, edx
	call	__allshl
	or	DWORD PTR [esi+8], eax
	or	DWORD PTR [esi+12], edx
$LN1@reverseAdd:
	pop	edi
	pop	ebp

; 262  : 
; 263  : 		break;
; 264  : 
; 265  : 	case BURGER_BASE_MAP:
; 266  : 		break;
; 267  : 
; 268  : 	default:
; 269  : 		break;
; 270  : 	}
; 271  : 
; 272  : 	return true;

	mov	al, 1
	pop	ebx

; 273  : }

	add	esp, 8
	ret	0
	npad	1
$LN16@reverseAdd:
	DD	$LN7@reverseAdd
	DD	$LN8@reverseAdd
	DD	$LN9@reverseAdd
	DD	$LN6@reverseAdd
	DD	$LN5@reverseAdd
	DD	$LN4@reverseAdd
	DD	$LN3@reverseAdd
?reverseAddressTranslation@Address@DRAMsimII@@IAE_NXZ ENDP ; DRAMsimII::Address::reverseAddressTranslation
_TEXT	ENDS
PUBLIC	?maxAddress@Address@DRAMsimII@@SA_KXZ		; DRAMsimII::Address::maxAddress
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?maxAddress@Address@DRAMsimII@@SA_KXZ PROC		; DRAMsimII::Address::maxAddress

; 101  : 	return (1LL << (channelAddressDepth + rankAddressDepth + bankAddressDepth + rowAddressDepth +
; 102  : 		columnAddressDepth + columnSizeDepth)) - 1;

	mov	eax, DWORD PTR ?columnAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnAddressDepth
	mov	ecx, DWORD PTR ?columnSizeDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnSizeDepth
	add	ecx, eax
	add	ecx, DWORD PTR ?rowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::rowAddressDepth
	mov	eax, 1
	add	ecx, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::bankAddressDepth
	xor	edx, edx
	add	ecx, DWORD PTR ?rankAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::rankAddressDepth
	add	ecx, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::channelAddressDepth
	call	__allshl
	sub	eax, 1
	sbb	edx, 0

; 103  : }

	ret	0
?maxAddress@Address@DRAMsimII@@SA_KXZ ENDP		; DRAMsimII::Address::maxAddress
_TEXT	ENDS
PUBLIC	??0Address@DRAMsimII@@QAE@IIIII@Z		; DRAMsimII::Address::Address
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_this$ = 8						; size = 4
_channel$ = 12						; size = 4
_row$ = 16						; size = 4
_column$ = 20						; size = 4
??0Address@DRAMsimII@@QAE@IIIII@Z PROC			; DRAMsimII::Address::Address
; _rank$ = ecx
; _bank$ = edx

; 88   : {

	xor	eax, eax
	push	esi
	mov	esi, DWORD PTR _this$[esp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR _channel$[esp]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR _row$[esp]
	mov	DWORD PTR [esi+20], ecx
	mov	ecx, DWORD PTR _column$[esp]
	mov	DWORD PTR [esi+24], edx
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], ecx

; 89   : 	reverseAddressTranslation();

	call	?reverseAddressTranslation@Address@DRAMsimII@@IAE_NXZ ; DRAMsimII::Address::reverseAddressTranslation

; 90   : 
; 91   : #ifdef DEBUG
; 92   : 	PhysicalAddress pA = physicalAddress;
; 93   : 	addressTranslation();
; 94   : 	assert((physicalAddress >> columnSizeDepth) == (pA >> columnSizeDepth));
; 95   : 	assert(this->channel == channel && this->rank == rank && this->bank == bank && this->row == row && this->column == column);
; 96   : #endif
; 97   : }

	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??0Address@DRAMsimII@@QAE@IIIII@Z ENDP			; DRAMsimII::Address::Address
_TEXT	ENDS
PUBLIC	??0Address@DRAMsimII@@QAE@XZ			; DRAMsimII::Address::Address
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
??0Address@DRAMsimII@@QAE@XZ PROC			; DRAMsimII::Address::Address
; _this$ = eax

; 56   : {}

	or	ecx, -1
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	ret	0
??0Address@DRAMsimII@@QAE@XZ ENDP			; DRAMsimII::Address::Address
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\systemconfiguration.h
_TEXT	ENDS
;	COMDAT ?getDRAMType@SystemConfiguration@DRAMsimII@@QBE?AW4DRAMType@2@XZ
_TEXT	SEGMENT
?getDRAMType@SystemConfiguration@DRAMsimII@@QBE?AW4DRAMType@2@XZ PROC ; DRAMsimII::SystemConfiguration::getDRAMType, COMDAT
; _this$ = eax

; 105  : 		DRAMType getDRAMType() const { return dramType; }

	mov	eax, DWORD PTR [eax+324]
	ret	0
?getDRAMType@SystemConfiguration@DRAMsimII@@QBE?AW4DRAMType@2@XZ ENDP ; DRAMsimII::SystemConfiguration::getDRAMType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCachelineSize@SystemConfiguration@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getCachelineSize@SystemConfiguration@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::SystemConfiguration::getCachelineSize, COMDAT
; _this$ = eax

; 99   : 		unsigned getCachelineSize() const { return cachelineSize; }

	mov	eax, DWORD PTR [eax+316]
	ret	0
?getCachelineSize@SystemConfiguration@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::SystemConfiguration::getCachelineSize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getColumnSize@SystemConfiguration@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getColumnSize@SystemConfiguration@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::SystemConfiguration::getColumnSize, COMDAT
; _this$ = eax

; 98   : 		unsigned getColumnSize() const { return columnSize; }

	mov	eax, DWORD PTR [eax+308]
	ret	0
?getColumnSize@SystemConfiguration@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::SystemConfiguration::getColumnSize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getColumnCount@SystemConfiguration@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getColumnCount@SystemConfiguration@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::SystemConfiguration::getColumnCount, COMDAT
; _this$ = eax

; 97   : 		unsigned getColumnCount() const { return columnCount; }

	mov	eax, DWORD PTR [eax+372]
	ret	0
?getColumnCount@SystemConfiguration@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::SystemConfiguration::getColumnCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getRowCount@SystemConfiguration@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getRowCount@SystemConfiguration@DRAMsimII@@QBEIXZ PROC	; DRAMsimII::SystemConfiguration::getRowCount, COMDAT
; _this$ = eax

; 96   : 		unsigned getRowCount() const { return rowCount; }

	mov	eax, DWORD PTR [eax+368]
	ret	0
?getRowCount@SystemConfiguration@DRAMsimII@@QBEIXZ ENDP	; DRAMsimII::SystemConfiguration::getRowCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getChannelCount@SystemConfiguration@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getChannelCount@SystemConfiguration@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::SystemConfiguration::getChannelCount, COMDAT
; _this$ = eax

; 95   : 		unsigned getChannelCount() const { return channelCount; }

	mov	eax, DWORD PTR [eax+356]
	ret	0
?getChannelCount@SystemConfiguration@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::SystemConfiguration::getChannelCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getBankCount@SystemConfiguration@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getBankCount@SystemConfiguration@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::SystemConfiguration::getBankCount, COMDAT
; _this$ = eax

; 94   : 		unsigned getBankCount() const { return bankCount; }

	mov	eax, DWORD PTR [eax+364]
	ret	0
?getBankCount@SystemConfiguration@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::SystemConfiguration::getBankCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getRankCount@SystemConfiguration@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getRankCount@SystemConfiguration@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::SystemConfiguration::getRankCount, COMDAT
; _this$ = eax

; 93   : 		unsigned getRankCount() const { return rankCount; }

	mov	eax, DWORD PTR [eax+360]
	ret	0
?getRankCount@SystemConfiguration@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::SystemConfiguration::getRankCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getAddressMappingScheme@SystemConfiguration@DRAMsimII@@QBE?AW4AddressMappingScheme@Address@2@XZ
_TEXT	SEGMENT
?getAddressMappingScheme@SystemConfiguration@DRAMsimII@@QBE?AW4AddressMappingScheme@Address@2@XZ PROC ; DRAMsimII::SystemConfiguration::getAddressMappingScheme, COMDAT
; _this$ = eax

; 89   : 		Address::AddressMappingScheme getAddressMappingScheme() const { return addressMappingScheme; }

	mov	eax, DWORD PTR [eax+332]
	ret	0
?getAddressMappingScheme@SystemConfiguration@DRAMsimII@@QBE?AW4AddressMappingScheme@Address@2@XZ ENDP ; DRAMsimII::SystemConfiguration::getAddressMappingScheme
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\globals.h
_TEXT	ENDS
;	COMDAT ?log2@DRAMsimII@@YAII@Z
_TEXT	SEGMENT
?log2@DRAMsimII@@YAII@Z PROC				; DRAMsimII::log2, COMDAT
; _input$ = ecx

; 74   : 		unsigned l2 = 0;

	xor	eax, eax

; 75   : 		for (input >>= 1; input > 0; input >>= 1)

	shr	ecx, 1
	je	SHORT $LN1@log2
$LL3@log2:

; 76   : 		{
; 77   : 			l2++;

	inc	eax
	shr	ecx, 1
	jne	SHORT $LL3@log2
$LN1@log2:

; 78   : 		}
; 79   : 		return l2;
; 80   : 	}

	ret	0
?log2@DRAMsimII@@YAII@Z ENDP				; DRAMsimII::log2
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT
__Newwidth$ = 8						; size = 4
?width@ios_base@std@@QAEHH@Z PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 424  : 		streamsize _Oldwidth = _Wide;
; 425  : 		_Wide = _Newwidth;

	mov	edx, DWORD PTR __Newwidth$[esp-4]
	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+24], edx

; 426  : 		return (_Oldwidth);
; 427  : 		}

	ret	4
?width@ios_base@std@@QAEHH@Z ENDP			; std::ios_base::width
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?width@ios_base@std@@QBEHXZ PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 419  : 		return (_Wide);

	mov	eax, DWORD PTR [ecx+24]

; 420  : 		}

	ret	0
?width@ios_base@std@@QBEHXZ ENDP			; std::ios_base::width
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?precision@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?precision@ios_base@std@@QBEHXZ PROC			; std::ios_base::precision, COMDAT
; _this$ = eax

; 407  : 		return (_Prec);

	mov	eax, DWORD PTR [eax+20]

; 408  : 		}

	ret	0
?precision@ios_base@std@@QBEHXZ ENDP			; std::ios_base::precision
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHHH@Z
_TEXT	SEGMENT
__Newfmtflags$ = 8					; size = 4
__Mask$ = 12						; size = 4
?setf@ios_base@std@@QAEHHH@Z PROC			; std::ios_base::setf, COMDAT
; _this$ = ecx

; 394  : 		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
; 395  : 		_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
; 396  : 			| ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));

	mov	edx, DWORD PTR __Mask$[esp-4]
	mov	eax, DWORD PTR [ecx+16]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newfmtflags$[esp+4]
	mov	esi, edx
	not	esi
	and	edi, edx
	and	esi, eax
	and	edi, 65535				; 0000ffffH
	or	esi, edi
	pop	edi
	mov	DWORD PTR [ecx+16], esi
	pop	esi

; 397  : 		return (_Oldfmtflags);
; 398  : 		}

	ret	8
?setf@ios_base@std@@QAEHHH@Z ENDP			; std::ios_base::setf
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 374  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [ecx+16]

; 375  : 		}

	ret	0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 311  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx+8]

; 312  : 		}

	ret	0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 413  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 414  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	mov	ecx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR __Id$[esp]
	cmp	esi, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Getfacet
	mov	eax, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+esi*4]

; 415  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	eax, eax
	jne	SHORT $LN1@Getfacet
$LN10@Getfacet:
	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN1@Getfacet

; 416  : 			return (_Facptr);	// found facet or not transparent, return pointer
; 417  : 		else
; 418  : 			{	// look in current locale
; 419  : 			locale::_Locimp *_Ptr = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 420  : 			return (_Id < _Ptr->_Facetcount
; 421  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 422  : 				: 0);	// no entry in current locale

	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN8@Getfacet
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+esi*4]
	pop	esi

; 423  : 			}
; 424  : 		}

	ret	4
$LN6@Getfacet:

; 413  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 414  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	xor	eax, eax

; 415  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	jmp	SHORT $LN10@Getfacet
$LN8@Getfacet:

; 420  : 			return (_Id < _Ptr->_Facetcount
; 421  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 422  : 				: 0);	// no entry in current locale

	xor	eax, eax
$LN1@Getfacet:
	pop	esi

; 423  : 			}
; 424  : 		}

	ret	4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 176  : 			{	// construct with initial reference count

	mov	eax, ecx
	mov	ecx, DWORD PTR __Initrefs$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
	mov	DWORD PTR [eax+4], ecx

; 177  : 			}

	ret	4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@UAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 170  : 			{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@

; 171  : 			}

	ret	0
??1facet@locale@std@@UAE@XZ ENDP			; std::locale::facet::~facet
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Register@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
?_Register@facet@locale@std@@QAEXXZ PROC		; std::locale::facet::_Register, COMDAT
; _this$ = ecx

; 135  : #if defined(_M_CEE)
; 136  : 			facet_Register_m(this);
; 137  : #else
; 138  : 			facet_Register(this);

	push	ecx
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	pop	ecx

; 139  : #endif
; 140  : 			}

	ret	0
?_Register@facet@locale@std@@QAEXXZ ENDP		; std::locale::facet::_Register
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT
__Lock$14063 = -4					; size = 4
?_Decref@facet@locale@std@@QAEPAV123@XZ PROC		; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 125  : 			{	// safely decrement the reference count, return this when dead

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 126  : 			_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$14063[esp+16]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 127  : 				if (0 < _Refs && _Refs < (size_t)(-1))

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN1@Decref
	cmp	eax, -1
	jae	SHORT $LN1@Decref

; 128  : 					--_Refs;

	dec	eax
	mov	DWORD PTR [edi+4], eax
$LN1@Decref:

; 129  : 				return (_Refs == 0 ? this : 0);

	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$14063[esp+12]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	edi
	mov	eax, esi
	pop	esi

; 130  : 			_END_LOCK()
; 131  : 			}

	pop	ecx
	ret	0
?_Decref@facet@locale@std@@QAEPAV123@XZ ENDP		; std::locale::facet::_Decref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
__Lock$14058 = -4					; size = 4
?_Incref@facet@locale@std@@QAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 117  : 			{	// safely increment the reference count

	push	ecx
	push	esi
	mov	esi, ecx

; 118  : 			_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$14058[esp+12]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 119  : 				if (_Refs < (size_t)(-1))

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN1@Incref

; 120  : 					++_Refs;

	inc	eax
	mov	DWORD PTR [esi+4], eax
$LN1@Incref:

; 121  : 			_END_LOCK()

	lea	ecx, DWORD PTR __Lock$14058[esp+8]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	esi

; 122  : 			}

	pop	ecx
	ret	0
?_Incref@facet@locale@std@@QAEXXZ ENDP			; std::locale::facet::_Incref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$14052 = -4					; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 77   : 			{	// get stamp, with lazy allocation

	push	ecx
	push	esi
	mov	esi, ecx

; 78   : 			if (_Id == 0)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN6@operator@35

; 79   : 				{	// still zero, allocate stamp
; 80   : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$14052[esp+12]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 81   : 					if (_Id == 0)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN1@operator@35

; 82   : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR [esi], eax
$LN1@operator@35:

; 83   : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$14052[esp+8]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN6@operator@35:

; 84   : 				}
; 85   : 			return (_Id);

	mov	eax, DWORD PTR [esi]
	pop	esi

; 86   : 			}

	pop	ecx
	ret	0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 73   : 			{	// construct with specified stamp value

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax], ecx

; 74   : 			}

	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocinfo
_TEXT	ENDS
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Gettrue@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Gettrue, COMDAT

; 177  : 		return ("true");

	mov	eax, OFFSET ??_C@_04LOAJBDKD@true?$AA@

; 178  : 		}

	ret	0
?_Gettrue@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Gettrue
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Getfalse@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Getfalse, COMDAT

; 172  : 		return ("false");

	mov	eax, OFFSET ??_C@_05LAPONLG@false?$AA@

; 173  : 		}

	ret	0
?_Getfalse@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Getfalse
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ PROC		; std::_Locinfo::_Getlconv, COMDAT

; 134  : 		return (localeconv());

	jmp	_localeconv
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ PROC		; std::_Locinfo::_Getcvt, COMDAT
; _this$ = ecx

; 129  : 		return (::_Getcvt());

	call	__Getcvt
	mov	ecx, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 130  : 		}

	ret	4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@runtime_error@std@@UBEPBDXZ PROC			; std::runtime_error::what, COMDAT
; _this$ = ecx

; 162  : 		return (_Str.c_str());

	cmp	DWORD PTR [ecx+36], 16			; 00000010H
	jb	SHORT $LN7@what
	mov	eax, DWORD PTR [ecx+16]

; 163  : 		}

	ret	0

; 162  : 		return (_Str.c_str());

$LN7@what:
	lea	eax, DWORD PTR [ecx+16]

; 163  : 		}

	ret	0
?what@runtime_error@std@@UBEPBDXZ ENDP			; std::runtime_error::what
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 517  : 		return (EOF);

	or	eax, -1

; 518  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 512  : 		return (_Left == _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 513  : 		}

	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 506  : 		return ((unsigned char)_Ch);

	mov	eax, DWORD PTR __Ch$[esp-4]
	movzx	eax, BYTE PTR [eax]

; 507  : 		}

	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 495  : //		_DEBUG_POINTER(_First);
; 496  : 		return ((_Elem *)::memset(_First, _Ch, _Count));

	mov	eax, DWORD PTR __Count$[esp-4]
	movsx	ecx, BYTE PTR __Ch$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	eax
	push	ecx
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 497  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Move_s, COMDAT

; 487  : //		_DEBUG_POINTER(_First1);
; 488  : //		_DEBUG_POINTER(_First2);
; 489  : 		_CRT_SECURE_MEMMOVE(_First1, _Size_in_bytes, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size_in_bytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H

; 490  : 		return _First1;

	mov	eax, esi
	pop	esi

; 491  : 		}

	ret	0
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Move_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Copy_s, COMDAT

; 463  : //		_DEBUG_POINTER(_First1);
; 464  : //		_DEBUG_POINTER(_First2);
; 465  : 		_CRT_SECURE_MEMCPY(_First1, _Size_in_bytes, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size_in_bytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 466  : 		return _First1;

	mov	eax, esi
	pop	esi

; 467  : 		}

	ret	0
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Copy_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 448  : //		_DEBUG_POINTER(_First);
; 449  : 		return (::strlen(_First));

	mov	eax, DWORD PTR __First$[esp-4]
	lea	edx, DWORD PTR [eax+1]
$LL3@length@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@length@2
	sub	eax, edx

; 450  : 		}

	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 425  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	cl, BYTE PTR [eax]
	mov	edx, DWORD PTR __Left$[esp-4]
	mov	BYTE PTR [edx], cl

; 426  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Ogtpy
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 624  : 		return _Traits::_Move_s(_First1, _Size, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 625  : 	}

	ret	0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 597  : 		return _Traits::_Copy_s(_First1, _Size, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 598  : 	}

	ret	0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0
__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$2
__ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z PROC	; std::numpunct<char>::_Init, COMDAT

; 135  : 		{	// initialize from _Lobj

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR _this$[ebp]

; 136  : 		const lconv *_Ptr = _Lobj._Getlconv();

	call	_localeconv
	mov	esi, eax

; 137  : 
; 138  : 		_Grouping = 0;

	xor	eax, eax
	mov	DWORD PTR __Ptr$[ebp], esi
	mov	DWORD PTR [ebx+8], eax

; 139  : 		_Falsename = 0;

	mov	DWORD PTR [ebx+16], eax

; 140  : 		_Truename = 0;

	mov	DWORD PTR [ebx+20], eax

; 141  : 
; 142  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], eax

; 143  : 		_Grouping = _MAKLOCSTR(char, _Ptr->grouping, _Lobj._Getcvt());

	call	__Getcvt
	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
$LL65@Init@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL65@Init@2
	sub	eax, edx
	lea	esi, DWORD PTR [eax+1]
	push	esi
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	ecx, eax
	npad	6
$LL15@Init@2:
	test	esi, esi
	jbe	SHORT $LN13@Init@2
	mov	dl, BYTE PTR [edi]
	mov	BYTE PTR [ecx], dl
	dec	esi
	inc	ecx
	inc	edi
	jmp	SHORT $LL15@Init@2
$LN13@Init@2:
	mov	DWORD PTR [ebx+8], eax

; 144  : 		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Lobj._Getcvt());

	call	__Getcvt
	mov	edi, OFFSET ??_C@_05LAPONLG@false?$AA@
	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL66@Init@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL66@Init@2
	sub	eax, edx
	lea	esi, DWORD PTR [eax+1]
	push	esi
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	ecx, eax
$LL24@Init@2:
	test	esi, esi
	jbe	SHORT $LN22@Init@2
	mov	dl, BYTE PTR [edi]
	mov	BYTE PTR [ecx], dl
	dec	esi
	inc	ecx
	inc	edi
	jmp	SHORT $LL24@Init@2
$LN22@Init@2:
	mov	DWORD PTR [ebx+16], eax

; 145  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Lobj._Getcvt());

	call	__Getcvt
	mov	edi, OFFSET ??_C@_04LOAJBDKD@true?$AA@
	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
$LL67@Init@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL67@Init@2
	sub	eax, edx
	lea	esi, DWORD PTR [eax+1]
	push	esi
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	ecx, eax
	npad	3
$LL33@Init@2:
	test	esi, esi
	jbe	SHORT $LN31@Init@2
	mov	dl, BYTE PTR [edi]
	mov	BYTE PTR [ecx], dl
	dec	esi
	inc	ecx
	inc	edi
	jmp	SHORT $LL33@Init@2
$LN31@Init@2:
	mov	DWORD PTR [ebx+20], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 149  : 		_CATCH_END
; 150  : 
; 151  : 		_Dp = _MAKLOCCHR(_Elem, _Ptr->decimal_point[0], _Lobj._Getcvt());

	call	__Getcvt
	mov	esi, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [ebx+12], cl

; 152  : 		_Kseparator =
; 153  : 			_MAKLOCCHR(_Elem, _Ptr->thousands_sep[0], _Lobj._Getcvt());

	call	__Getcvt
	mov	edx, DWORD PTR [esi+4]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ebx+13], al

; 154  : 
; 155  : 		if (_Isdef)

	mov	al, 1
	test	al, al
	je	SHORT $LN1@Init@2

; 156  : 			{	// apply defaults for required facets
; 157  : 			_Grouping = _MAKLOCSTR(char, "", _Lobj._Getcvt());

	call	__Getcvt
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
$LL68@Init@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL68@Init@2
	sub	eax, edx
	lea	esi, DWORD PTR [eax+1]
	push	esi
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	ecx, eax
	test	esi, esi
	jbe	SHORT $LN46@Init@2
$LL48@Init@2:
	mov	dl, BYTE PTR [edi]
	mov	BYTE PTR [ecx], dl
	dec	esi
	inc	ecx
	inc	edi
	test	esi, esi
	ja	SHORT $LL48@Init@2
$LN46@Init@2:
	mov	DWORD PTR [ebx+8], eax

; 158  : 			_Dp = _MAKLOCCHR(_Elem, '.', _Lobj._Getcvt());

	call	__Getcvt
	mov	BYTE PTR [ebx+12], 46			; 0000002eH

; 159  : 			_Kseparator = _MAKLOCCHR(_Elem, ',', _Lobj._Getcvt());

	call	__Getcvt
	mov	BYTE PTR [ebx+13], 44			; 0000002cH
$LN1@Init@2:

; 160  : 			}
; 161  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0:

; 146  : 		_CATCH_ALL
; 147  : 		_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$numpunct@D@std@@AAEXXZ		; std::numpunct<char>::_Tidy

; 148  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN71@Init@2:
$LN70@Init@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ENDP	; std::numpunct<char>::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = esi

; 1047 : 		_Cvt = _Lobj._Getcvt();

	call	__Getcvt
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edx

; 1048 : 		}

	ret	0
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0
__ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z PROC	; std::numpunct<char>::numpunct<char>, COMDAT

; 106  : 		{	// construct from specified locale

	push	-1
	push	__ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR __$EHRec$[esp+32], eax

; 107  : 		_Init(_Lobj, _Isdef);

	push	esi
	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
	call	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init

; 108  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
__ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z ENDP	; std::numpunct<char>::numpunct<char>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = esi

; 1063 : 		{	// construct from specified locale

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 1064 : 		_Init(_Lobj);

	call	__Getcvt
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edx

; 1065 : 		}

	mov	eax, esi
	ret	0
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T364282 = -12						; size = 12
$T364286 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@38

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@38:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@38:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 1
	jae	SHORT $LN1@Allocate@38

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T364286[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T364282[esp+16]
	mov	DWORD PTR $T364286[esp+12], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T364282[esp+16]
	push	ecx
	mov	DWORD PTR $T364282[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@38:
$LN8@Allocate@38:
	int	3
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 616  : 		return move_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 617  : 	}

	ret	0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 589  : 		return copy_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 590  : 	}

	ret	0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
$T364335 = -12						; size = 12
$T364329 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN5@allocate@25
	xor	ecx, ecx
$LN3@allocate@25:
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 12					; 0000000cH
	ret	4

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@25:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 1
	jae	SHORT $LN3@allocate@25
	lea	eax, DWORD PTR $T364329[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T364335[esp+16]
	mov	DWORD PTR $T364329[esp+12], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T364335[esp+16]
	push	ecx
	mov	DWORD PTR $T364335[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@25:
$LN11@allocate@25:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 2076 : 		if (_Count == 1)

	mov	eax, DWORD PTR __Count$[esp-4]
	cmp	eax, 1
	jne	SHORT $LN2@Chassign

; 2077 : 			_Traits::assign(*(_Myptr() + _Off), _Ch);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN7@Chassign
	mov	ecx, DWORD PTR [ecx+4]
	mov	al, BYTE PTR __Ch$[esp-4]
	mov	edx, DWORD PTR __Off$[esp-4]
	mov	BYTE PTR [ecx+edx], al

; 2080 : 		}

	ret	12					; 0000000cH

; 2077 : 			_Traits::assign(*(_Myptr() + _Off), _Ch);

$LN7@Chassign:
	mov	al, BYTE PTR __Ch$[esp-4]
	mov	edx, DWORD PTR __Off$[esp-4]
	add	ecx, 4
	mov	BYTE PTR [ecx+edx], al

; 2080 : 		}

	ret	12					; 0000000cH
$LN2@Chassign:

; 2078 : 		else
; 2079 : 			_Traits::assign(_Myptr() + _Off, _Count, _Ch);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN13@Chassign
	mov	ecx, DWORD PTR [ecx+4]
	jmp	SHORT $LN14@Chassign
$LN13@Chassign:
	add	ecx, 4
$LN14@Chassign:
	mov	edx, DWORD PTR __Off$[esp-4]
	push	eax
	movsx	eax, BYTE PTR __Ch$[esp]
	push	eax
	add	ecx, edx
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2080 : 		}

	ret	12					; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2133 : 		{	// test if _Ptr points inside string

	push	esi
	push	edi

; 2134 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

	mov	edi, DWORD PTR __Ptr$[esp+4]
	test	edi, edi
	je	SHORT $LN2@Inside
	mov	esi, DWORD PTR [ecx+24]
	lea	eax, DWORD PTR [ecx+4]
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN8@Inside
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN9@Inside
$LN8@Inside:
	mov	edx, eax
$LN9@Inside:
	cmp	edi, edx
	jb	SHORT $LN2@Inside
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN12@Inside
	mov	eax, DWORD PTR [eax]
$LN12@Inside:
	mov	ecx, DWORD PTR [ecx+20]
	add	ecx, eax
	cmp	ecx, edi
	jbe	SHORT $LN2@Inside
	pop	edi

; 2136 : 		else
; 2137 : 			return (true);

	mov	al, 1
	pop	esi

; 2138 : 		}

	ret	4
$LN2@Inside:
	pop	edi

; 2135 : 			return (false);	// don't ask

	xor	al, al
	pop	esi

; 2138 : 		}

	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1557 : 		{	// subscript mutable sequence

	push	esi
	push	edi

; 1558 : 
; 1559 :  #if _HAS_ITERATOR_DEBUGGING
; 1560 : 		// skip debug checks if the container is initizialed with _IGNORE_MYITERLIST
; 1561 : 		if (this->_Myfirstiter != _IGNORE_MYITERLIST)
; 1562 : 			{
; 1563 : 			if (_Mysize < _Off)
; 1564 : 				{
; 1565 : 				_DEBUG_ERROR("string subscript out of range");
; 1566 : 				_SCL_SECURE_OUT_OF_RANGE;
; 1567 : 				}
; 1568 : 			}
; 1569 :  #else
; 1570 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= _Mysize);

	mov	edi, DWORD PTR __Off$[esp+4]
	mov	esi, ecx
	cmp	edi, DWORD PTR [esi+20]
	jbe	SHORT $LN1@operator@143
	call	__invalid_parameter_noinfo
$LN1@operator@143:

; 1571 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1572 : 
; 1573 : 		return (_Myptr()[_Off]);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN6@operator@143
	mov	esi, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+edi]
	pop	edi
	pop	esi

; 1574 : 		}

	ret	4

; 1571 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1572 : 
; 1573 : 		return (_Myptr()[_Off]);

$LN6@operator@143:
	lea	eax, DWORD PTR [esi+edi+4]
	pop	edi
	pop	esi

; 1574 : 		}

	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$numpunct@D@std@@MAE@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 121  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 122  : 		_Tidy();

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	edx, DWORD PTR [esi+20]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH

; 123  : 		}

	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	pop	esi
	ret	0
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 82   : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN8@Sentry_bas@3

; 83   : 				_Myostr.rdbuf()->_Unlock();

	lea	ecx, DWORD PTR [eax+4]
	jmp	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
$LN8@Sentry_bas@3:

; 84   : 			}

	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 75   : 			{	// lock the stream buffer, if there

	mov	eax, DWORD PTR __Ostr$[esp-4]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], eax

; 76   : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN10@Sentry_bas@4

; 77   : 				_Myostr.rdbuf()->_Lock();

	lea	ecx, DWORD PTR [eax+4]
	call	?_Lock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Lock
$LN10@Sentry_bas@4:

; 78   : 			}

	mov	eax, esi
	pop	esi
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2114 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	mov	eax, DWORD PTR __Newsize$[esp-4]
	mov	DWORD PTR [ecx+20], eax
	jb	SHORT $LN5@Eos
	mov	ecx, DWORD PTR [ecx+4]
	mov	BYTE PTR [ecx+eax], 0

; 2115 : 		}

	ret	4

; 2114 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$LN5@Eos:
	mov	BYTE PTR [ecx+eax+4], 0

; 2115 : 		}

	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
tv130 = 8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1262 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebx

; 1263 : 		if (_Mysize < _Off)

	mov	ebx, DWORD PTR __Off$[esp]
	push	esi
	mov	esi, ecx
	push	edi
	cmp	DWORD PTR [esi+20], ebx
	jae	SHORT $LN3@erase@4

; 1264 : 			_String_base::_Xran();	// _Off off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN3@erase@4:

; 1265 : 		if (_Mysize - _Off < _Count)

	mov	eax, DWORD PTR [esi+20]
	mov	edi, DWORD PTR __Count$[esp+8]
	sub	eax, ebx
	cmp	eax, edi

; 1266 : 			_Count = _Mysize - _Off;	// trim _Count

	cmovb	edi, eax

; 1267 : 		if (0 < _Count)

	test	edi, edi
	jbe	SHORT $LN30@erase@4

; 1268 : 			{	// move elements down
; 1269 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Myptr() + _Off + _Count,
; 1270 : 				_Mysize - _Off - _Count);

	mov	ecx, DWORD PTR [esi+24]
	push	ebp
	lea	ebp, DWORD PTR [esi+4]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN8@erase@4
	mov	edx, DWORD PTR [ebp]
	mov	DWORD PTR tv130[esp+12], edx
	jmp	SHORT $LN9@erase@4
$LN8@erase@4:
	mov	DWORD PTR tv130[esp+12], ebp
$LN9@erase@4:
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN12@erase@4
	mov	edx, DWORD PTR [ebp]
	jmp	SHORT $LN13@erase@4
$LN12@erase@4:
	mov	edx, ebp
$LN13@erase@4:
	sub	eax, edi
	push	eax
	mov	eax, DWORD PTR tv130[esp+16]
	add	eax, ebx
	add	eax, edi
	push	eax
	sub	ecx, ebx
	push	ecx
	add	edx, ebx
	push	edx
	call	_memmove_s

; 1271 : 			size_type _Newsize = _Mysize - _Count;

	mov	eax, DWORD PTR [esi+20]
	sub	eax, edi
	add	esp, 16					; 00000010H

; 1272 : 			_Eos(_Newsize);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], eax
	jb	SHORT $LN26@erase@4
	mov	ebp, DWORD PTR [ebp]
$LN26@erase@4:
	mov	BYTE PTR [eax+ebp], 0
	pop	ebp
$LN30@erase@4:
	pop	edi

; 1273 : 			}
; 1274 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1275 : 		}

	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 1042 : 		}

	mov	DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
	ret	0
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 161  : 		return (0 < _Pnavail()
; 162  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 163  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	eax, DWORD PTR [ecx+36]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@sputc
	mov	edx, DWORD PTR [ecx+52]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN3@sputc
	mov	eax, edx
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	mov	cl, BYTE PTR __Ch$[esp-4]
	mov	BYTE PTR [eax], cl
	movzx	eax, cl

; 164  : 		}

	ret	4
$LN3@sputc:

; 161  : 		return (0 < _Pnavail()
; 162  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 163  : 			: overflow(_Traits::to_int_type(_Ch)));

	movzx	edx, BYTE PTR __Ch$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Ch$[esp-4], edx
	jmp	eax
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2149 : 		if (!_Built)

	cmp	BYTE PTR __Built$[esp-4], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[esp+4]
	mov	esi, ecx
	je	SHORT $LN15@Tidy@28

; 2150 : 			;
; 2151 : 		else if (_BUF_SIZE <= _Myres)

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN15@Tidy@28

; 2152 : 			{	// copy any leftovers to small buffer and deallocate
; 2153 : 			_Elem *_Ptr = _Bx._Ptr;

	lea	eax, DWORD PTR [esi+4]
	push	ebx
	mov	ebx, DWORD PTR [eax]

; 2154 : 			if (0 < _Newsize)

	test	edi, edi
	jbe	SHORT $LN13@Tidy@28

; 2155 : 				_Traits_helper::copy_s<_Traits>(_Bx._Buf, _BUF_SIZE, _Ptr, _Newsize);

	push	edi
	push	ebx
	push	16					; 00000010H
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN13@Tidy@28:

; 2156 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	ebx
$LN15@Tidy@28:

; 2157 : 			}
; 2158 : 		_Myres = _BUF_SIZE - 1;
; 2159 : 		_Eos(_Newsize);

	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	BYTE PTR [esi+edi+4], 0
	pop	edi
	pop	esi

; 2160 : 		}

	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 905  : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 906  : 		_Tidy(true);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN17@basic_stri
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@basic_stri:
	xor	eax, eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], eax
	mov	BYTE PTR [esi+4], al
	pop	esi

; 907  : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 565  : 		{	// construct empty string

	mov	eax, ecx

; 566  : 		_Tidy();

	xor	ecx, ecx
	mov	DWORD PTR [eax+24], 15			; 0000000fH
	mov	DWORD PTR [eax+20], ecx
	mov	BYTE PTR [eax+4], cl

; 567  : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??9Address@DRAMsimII@@QBE_NABV01@@Z		; DRAMsimII::Address::operator!=
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.cpp
_TEXT	SEGMENT
??9Address@DRAMsimII@@QBE_NABV01@@Z PROC		; DRAMsimII::Address::operator!=
; _this$ = ecx
; _right$ = eax

; 848  : 	return !(*this == right);

	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR [eax+16]
	jne	SHORT $LN5@operator@144
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN5@operator@144
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR [eax+24]
	jne	SHORT $LN5@operator@144
	mov	edx, DWORD PTR [ecx+28]
	cmp	edx, DWORD PTR [eax+28]
	jne	SHORT $LN5@operator@144
	mov	ecx, DWORD PTR [ecx+32]
	cmp	ecx, DWORD PTR [eax+32]
	jne	SHORT $LN5@operator@144
	mov	eax, 1
	xor	edx, edx
	test	al, al
	sete	dl
	mov	al, dl

; 849  : }

	ret	0

; 848  : 	return !(*this == right);

$LN5@operator@144:
	xor	eax, eax
	xor	edx, edx
	test	al, al
	sete	dl
	mov	al, dl

; 849  : }

	ret	0
??9Address@DRAMsimII@@QBE_NABV01@@Z ENDP		; DRAMsimII::Address::operator!=
_TEXT	ENDS
PUBLIC	?setAddress@Address@DRAMsimII@@QAEXIIIII@Z	; DRAMsimII::Address::setAddress
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_this$ = 8						; size = 4
_bank$ = 12						; size = 4
_row$ = 16						; size = 4
_column$ = 20						; size = 4
?setAddress@Address@DRAMsimII@@QAEXIIIII@Z PROC		; DRAMsimII::Address::setAddress
; _channel$ = eax
; _rank$ = ecx

; 770  : 	this->channel = channel;
; 771  : 	this->rank = rank;
; 772  : 	this->bank = bank;

	mov	edx, DWORD PTR _bank$[esp-4]
	push	esi
	mov	esi, DWORD PTR _this$[esp]
	mov	DWORD PTR [esi+16], eax

; 773  : 	this->column = column;

	mov	eax, DWORD PTR _column$[esp]
	mov	DWORD PTR [esi+20], ecx

; 774  : 	this->row = row;

	mov	ecx, DWORD PTR _row$[esp]
	mov	DWORD PTR [esi+24], edx
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+28], ecx

; 775  : 
; 776  : 	reverseAddressTranslation();

	call	?reverseAddressTranslation@Address@DRAMsimII@@IAE_NXZ ; DRAMsimII::Address::reverseAddressTranslation
	pop	esi

; 777  : 
; 778  : #ifdef DEBUG
; 779  : 	PhysicalAddress oldPA = physicalAddress;
; 780  : 	addressTranslation();
; 781  : 	assert((physicalAddress >> columnSizeDepth) == (oldPA >> columnSizeDepth));
; 782  : 	assert(this->channel == channel && this->rank == rank && this->bank == bank && this->row == row && this->column == column);
; 783  : #endif
; 784  : 
; 785  : }

	ret	16					; 00000010H
?setAddress@Address@DRAMsimII@@QAEXIIIII@Z ENDP		; DRAMsimII::Address::setAddress
_TEXT	ENDS
PUBLIC	?initialize@Address@DRAMsimII@@SAXABVSystemConfiguration@2@@Z ; DRAMsimII::Address::initialize
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?initialize@Address@DRAMsimII@@SAXABVSystemConfiguration@2@@Z PROC ; DRAMsimII::Address::initialize
; _systemConfig$ = ecx

; 126  : 	channelAddressDepth = log2(systemConfig.getChannelCount());

	mov	eax, DWORD PTR [ecx+356]
	xor	edx, edx
	shr	eax, 1
	je	SHORT $LN7@initialize
	npad	4
$LL9@initialize:
	inc	edx
	shr	eax, 1
	jne	SHORT $LL9@initialize
$LN7@initialize:

; 127  : 	rankAddressDepth = log2(systemConfig.getRankCount());

	mov	eax, DWORD PTR [ecx+360]
	mov	DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA, edx ; DRAMsimII::Address::channelAddressDepth
	xor	edx, edx
	shr	eax, 1
	je	SHORT $LN14@initialize
$LL16@initialize:
	inc	edx
	shr	eax, 1
	jne	SHORT $LL16@initialize
$LN14@initialize:

; 128  : 	bankAddressDepth = log2(systemConfig.getBankCount());

	mov	eax, DWORD PTR [ecx+364]
	mov	DWORD PTR ?rankAddressDepth@Address@DRAMsimII@@1IA, edx ; DRAMsimII::Address::rankAddressDepth
	xor	edx, edx
	shr	eax, 1
	je	SHORT $LN21@initialize
	npad	2
$LL23@initialize:
	inc	edx
	shr	eax, 1
	jne	SHORT $LL23@initialize
$LN21@initialize:

; 129  : 	rowAddressDepth  = log2(systemConfig.getRowCount());

	mov	eax, DWORD PTR [ecx+368]
	push	esi
	push	edi
	xor	edi, edi
	shr	eax, 1
	mov	DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA, edx ; DRAMsimII::Address::bankAddressDepth
	je	SHORT $LN28@initialize
	npad	7
$LL30@initialize:
	inc	edi
	shr	eax, 1
	jne	SHORT $LL30@initialize
$LN28@initialize:

; 130  : 	columnAddressDepth  = log2(systemConfig.getColumnCount());

	mov	eax, DWORD PTR [ecx+372]
	xor	edx, edx
	shr	eax, 1
	mov	DWORD PTR ?rowAddressDepth@Address@DRAMsimII@@1IA, edi ; DRAMsimII::Address::rowAddressDepth
	je	SHORT $LN35@initialize
$LL37@initialize:
	inc	edx
	shr	eax, 1
	jne	SHORT $LL37@initialize
$LN35@initialize:

; 131  : 	//FIXME: shouldn't this already be set appropriately?
; 132  : 	columnSizeDepth	= log2(systemConfig.getDRAMType() == DRDRAM ? 16 : systemConfig.getColumnSize());

	cmp	DWORD PTR [ecx+324], 3
	mov	DWORD PTR ?columnAddressDepth@Address@DRAMsimII@@1IA, edx ; DRAMsimII::Address::columnAddressDepth
	mov	eax, 16					; 00000010H
	je	SHORT $LN42@initialize
	mov	eax, DWORD PTR [ecx+308]
$LN42@initialize:
	xor	esi, esi
	shr	eax, 1
	je	SHORT $LN44@initialize
	npad	4
$LL46@initialize:
	inc	esi
	shr	eax, 1
	jne	SHORT $LL46@initialize
$LN44@initialize:

; 133  : 	mappingScheme = systemConfig.getAddressMappingScheme();

	mov	eax, DWORD PTR [ecx+332]
	mov	DWORD PTR ?mappingScheme@Address@DRAMsimII@@1W4AddressMappingScheme@12@A, eax ; DRAMsimII::Address::mappingScheme

; 134  : 	unsigned cachelineDepth = log2(systemConfig.getCachelineSize());

	mov	ecx, DWORD PTR [ecx+316]
	xor	eax, eax
	shr	ecx, 1
	mov	DWORD PTR ?columnSizeDepth@Address@DRAMsimII@@1IA, esi ; DRAMsimII::Address::columnSizeDepth
	je	SHORT $LN53@initialize
$LL55@initialize:
	inc	eax
	shr	ecx, 1
	jne	SHORT $LL55@initialize
$LN53@initialize:

; 135  : 	assert(cachelineDepth > columnSizeDepth);
; 136  : 	columnLowAddressDepth = cachelineDepth - columnSizeDepth;

	sub	eax, esi

; 137  : 	columnHighAddressDepth = columnAddressDepth - columnLowAddressDepth;
; 138  : 	assert(rowAddressDepth > 3);
; 139  : 	rowLowAddressDepth = 3;
; 140  : 	rowHighAddressDepth = rowAddressDepth - 3;

	add	edi, -3					; fffffffdH
	mov	DWORD PTR ?rowHighAddressDepth@Address@DRAMsimII@@1IA, edi ; DRAMsimII::Address::rowHighAddressDepth
	sub	edx, eax
	pop	edi
	mov	DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA, eax ; DRAMsimII::Address::columnLowAddressDepth
	mov	DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA, edx ; DRAMsimII::Address::columnHighAddressDepth
	mov	DWORD PTR ?rowLowAddressDepth@Address@DRAMsimII@@1IA, 3 ; DRAMsimII::Address::rowLowAddressDepth
	pop	esi

; 141  : }

	ret	0
?initialize@Address@DRAMsimII@@SAXABVSystemConfiguration@2@@Z ENDP ; DRAMsimII::Address::initialize
_TEXT	ENDS
PUBLIC	?initialize@Address@DRAMsimII@@SAXABVSettings@2@@Z ; DRAMsimII::Address::initialize
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?initialize@Address@DRAMsimII@@SAXABVSettings@2@@Z PROC	; DRAMsimII::Address::initialize
; _dramSettings$ = ecx

; 107  : 	channelAddressDepth = log2(dramSettings.channelCount);

	mov	eax, DWORD PTR [ecx+300]
	xor	edx, edx
	shr	eax, 1
	je	SHORT $LN5@initialize@2
	npad	4
$LL7@initialize@2:
	inc	edx
	shr	eax, 1
	jne	SHORT $LL7@initialize@2
$LN5@initialize@2:

; 108  : 	rankAddressDepth = log2(dramSettings.rankCount);

	mov	eax, DWORD PTR [ecx+304]
	mov	DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA, edx ; DRAMsimII::Address::channelAddressDepth
	xor	edx, edx
	shr	eax, 1
	je	SHORT $LN10@initialize@2
$LL12@initialize@2:
	inc	edx
	shr	eax, 1
	jne	SHORT $LL12@initialize@2
$LN10@initialize@2:

; 109  : 	bankAddressDepth = log2(dramSettings.bankCount);

	mov	eax, DWORD PTR [ecx+308]
	mov	DWORD PTR ?rankAddressDepth@Address@DRAMsimII@@1IA, edx ; DRAMsimII::Address::rankAddressDepth
	xor	edx, edx
	shr	eax, 1
	je	SHORT $LN15@initialize@2
	npad	2
$LL17@initialize@2:
	inc	edx
	shr	eax, 1
	jne	SHORT $LL17@initialize@2
$LN15@initialize@2:

; 110  : 	rowAddressDepth  = log2(dramSettings.rowCount);

	mov	eax, DWORD PTR [ecx+240]
	push	esi
	push	edi
	xor	edi, edi
	shr	eax, 1
	mov	DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA, edx ; DRAMsimII::Address::bankAddressDepth
	je	SHORT $LN20@initialize@2
	npad	7
$LL22@initialize@2:
	inc	edi
	shr	eax, 1
	jne	SHORT $LL22@initialize@2
$LN20@initialize@2:

; 111  : 	columnAddressDepth  = log2(dramSettings.columnCount);

	mov	eax, DWORD PTR [ecx+236]
	xor	edx, edx
	shr	eax, 1
	mov	DWORD PTR ?rowAddressDepth@Address@DRAMsimII@@1IA, edi ; DRAMsimII::Address::rowAddressDepth
	je	SHORT $LN25@initialize@2
$LL27@initialize@2:
	inc	edx
	shr	eax, 1
	jne	SHORT $LL27@initialize@2
$LN25@initialize@2:

; 112  : 	//FIXME: shouldn't this already be set appropriately?
; 113  : 	columnSizeDepth	= log2(dramSettings.dramType == DRDRAM ? 16 : dramSettings.columnSize);

	cmp	DWORD PTR [ecx+200], 3
	mov	DWORD PTR ?columnAddressDepth@Address@DRAMsimII@@1IA, edx ; DRAMsimII::Address::columnAddressDepth
	mov	eax, 16					; 00000010H
	je	SHORT $LN4@initialize@2
	mov	eax, DWORD PTR [ecx+224]
$LN4@initialize@2:
	xor	esi, esi
	shr	eax, 1
	je	SHORT $LN30@initialize@2
	npad	4
$LL32@initialize@2:
	inc	esi
	shr	eax, 1
	jne	SHORT $LL32@initialize@2
$LN30@initialize@2:

; 114  : 	mappingScheme = dramSettings.addressMappingScheme;

	mov	eax, DWORD PTR [ecx+284]
	mov	DWORD PTR ?mappingScheme@Address@DRAMsimII@@1W4AddressMappingScheme@12@A, eax ; DRAMsimII::Address::mappingScheme

; 115  : 	unsigned cachelineDepth = log2(dramSettings.cacheLineSize);

	mov	ecx, DWORD PTR [ecx+244]
	xor	eax, eax
	shr	ecx, 1
	mov	DWORD PTR ?columnSizeDepth@Address@DRAMsimII@@1IA, esi ; DRAMsimII::Address::columnSizeDepth
	je	SHORT $LN35@initialize@2
$LL37@initialize@2:
	inc	eax
	shr	ecx, 1
	jne	SHORT $LL37@initialize@2
$LN35@initialize@2:

; 116  : 	assert(cachelineDepth > columnSizeDepth);
; 117  : 	columnLowAddressDepth = cachelineDepth - columnSizeDepth;

	sub	eax, esi

; 118  : 	columnHighAddressDepth = columnAddressDepth - columnLowAddressDepth;
; 119  : 	assert(rowAddressDepth > 3);
; 120  : 	rowLowAddressDepth = 3;
; 121  : 	rowHighAddressDepth = rowAddressDepth - 3;

	add	edi, -3					; fffffffdH
	mov	DWORD PTR ?rowHighAddressDepth@Address@DRAMsimII@@1IA, edi ; DRAMsimII::Address::rowHighAddressDepth
	sub	edx, eax
	pop	edi
	mov	DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA, eax ; DRAMsimII::Address::columnLowAddressDepth
	mov	DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA, edx ; DRAMsimII::Address::columnHighAddressDepth
	mov	DWORD PTR ?rowLowAddressDepth@Address@DRAMsimII@@1IA, 3 ; DRAMsimII::Address::rowLowAddressDepth
	pop	esi

; 122  : }

	ret	0
?initialize@Address@DRAMsimII@@SAXABVSettings@2@@Z ENDP	; DRAMsimII::Address::initialize
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
_TEXT	ENDS
;	COMDAT ?hex@std@@YAAAVios_base@1@AAV21@@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
?hex@std@@YAAAVios_base@1@AAV21@@Z PROC			; std::hex, COMDAT

; 191  : 	_Iosbase.setf(ios_base::hex, ios_base::basefield);

	mov	eax, DWORD PTR __Iosbase$[esp-4]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -1537				; fffff9ffH
	or	ecx, 2048				; 00000800H
	mov	DWORD PTR [eax+16], ecx

; 192  : 	return (_Iosbase);
; 193  : 	}

	ret	0
?hex@std@@YAAAVios_base@1@AAV21@@Z ENDP			; std::hex
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?fail@ios_base@std@@QBE_NXZ PROC			; std::ios_base::fail, COMDAT
; _this$ = ecx

; 344  : 		return (((int)rdstate()
; 345  : 			& ((int)badbit | (int)failbit)) != 0);

	test	BYTE PTR [ecx+8], 6
	mov	eax, 0
	setne	al

; 346  : 		}

	ret	0
?fail@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::fail
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 334  : 		return (rdstate() == goodbit);

	xor	eax, eax
	cmp	DWORD PTR [ecx+8], eax
	sete	al

; 335  : 		}

	ret	0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@UAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN6@scalar@23
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@23:
	mov	eax, esi
	pop	esi
	ret	4
??_Gfacet@locale@std@@UAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$365010 = -4					; size = 4
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 390  : 		{	// destroy the object

	push	ecx
	push	edi

; 391  : 		if (_Ptr != 0)

	mov	edi, DWORD PTR [ecx]
	test	edi, edi
	je	SHORT $LN4@locale@2

; 392  : 			_DELETE_CRT(_Ptr->_Decref());

	push	0
	lea	ecx, DWORD PTR __Lock$365010[esp+12]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN6@locale@2
	cmp	eax, -1
	jae	SHORT $LN6@locale@2
	dec	eax
	mov	DWORD PTR [edi+4], eax
$LN6@locale@2:
	push	esi
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$365010[esp+12]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN9@locale@2
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN9@locale@2:
	pop	esi
$LN4@locale@2:
	pop	edi

; 393  : 		}

	pop	ecx
	ret	0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Lock$365020 = 8					; size = 4
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 334  : 		{	// construct by copying

	mov	eax, DWORD PTR __Right$[esp-4]
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, ecx

; 335  : 		_Ptr->_Incref();

	push	0
	lea	ecx, DWORD PTR __Lock$365020[esp+8]
	mov	DWORD PTR [edi], esi
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN3@locale@3
	inc	eax
	mov	DWORD PTR [esi+4], eax
$LN3@locale@3:
	lea	ecx, DWORD PTR __Lock$365020[esp+4]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 336  : 		}

	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??1_Locinfo@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1_Locinfo@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocinfo
xdata$x	ENDS
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 101  :         {

	push	-1
	push	__ehhandler$??1_Locinfo@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+36], esi

; 102  :         _Locinfo_dtor(this);

	push	esi
	mov	DWORD PTR __$EHRec$[esp+48], 4
	call	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor

; 103  :         }

	mov	ebp, 16					; 00000010H
	add	esp, 4
	cmp	DWORD PTR [esi+112], ebp
	jb	SHORT $LN24@Locinfo
	mov	eax, DWORD PTR [esi+92]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Locinfo:
	xor	ebx, ebx
	mov	edi, 15					; 0000000fH
	mov	DWORD PTR [esi+112], edi
	mov	DWORD PTR [esi+108], ebx
	mov	BYTE PTR [esi+92], bl
	cmp	DWORD PTR [esi+84], ebp
	jb	SHORT $LN50@Locinfo
	mov	eax, DWORD PTR [esi+64]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN50@Locinfo:
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+80], ebx
	mov	BYTE PTR [esi+64], bl
	cmp	DWORD PTR [esi+56], ebp
	jb	SHORT $LN76@Locinfo
	mov	eax, DWORD PTR [esi+36]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN76@Locinfo:
	mov	DWORD PTR [esi+56], edi
	mov	DWORD PTR [esi+52], ebx
	mov	BYTE PTR [esi+36], bl
	cmp	DWORD PTR [esi+28], ebp
	jb	SHORT $LN102@Locinfo
	mov	eax, DWORD PTR [esi+8]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN102@Locinfo:
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+24], ebx
	mov	ecx, esi
	mov	BYTE PTR [esi+8], bl
	mov	DWORD PTR __$EHRec$[esp+44], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??1_Locinfo@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$4
__ehfuncinfo$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocinfo
xdata$x	ENDS
;	COMDAT ??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_locstr$ = 8						; size = 4
??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 96   : 		{

	push	-1
	push	__ehhandler$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	xor	ebx, ebx
	push	ebx
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	mov	eax, 15					; 0000000fH
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+24], ebx
	mov	BYTE PTR [esi+8], bl
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+52], ebx
	mov	BYTE PTR [esi+36], bl
	mov	DWORD PTR [esi+84], eax
	mov	DWORD PTR [esi+80], ebx
	mov	BYTE PTR [esi+64], bl
	mov	DWORD PTR [esi+112], eax
	mov	DWORD PTR [esi+108], ebx
	mov	BYTE PTR [esi+92], bl

; 97   :         _Locinfo_ctor(this, locstr);

	mov	eax, DWORD PTR _locstr$[esp+24]
	push	eax
	push	esi
	mov	BYTE PTR __$EHRec$[esp+44], 4
	call	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Locinfo::_Locinfo_ctor
	add	esp, 8

; 98   : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Locinfo::_Locinfo
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx

; 157  : 		{	// destroy the object

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 158  : 		}

	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN19@runtime_er
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@runtime_er:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@24
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@24:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T422091 = -4						; size = 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::grouping, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi

; 79   : 		{	// return grouping string

	push	ecx

; 80   : 		return (do_grouping());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	esi
	mov	DWORD PTR $T422091[esp+8], 0
	call	edx
	mov	eax, esi

; 81   : 		}

	pop	ecx
	ret	0
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=, COMDAT
; _this$ = esi
; __Right$ = edx

; 593  : 		if (_Strbuf == 0
; 594  : 			|| traits_type::eq_int_type(_Traits::eof(),
; 595  : 				_Strbuf->sputc(_Right)))

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN1@operator@297
	mov	eax, DWORD PTR [ecx+36]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@operator@297
	mov	eax, DWORD PTR [ecx+52]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN7@operator@297
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx]
	push	edi
	lea	edi, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edi
	mov	BYTE PTR [eax], dl
	movzx	eax, dl
	pop	edi
	jmp	SHORT $LN8@operator@297
$LN7@operator@297:
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	movzx	edx, dl
	push	edx
	call	eax
$LN8@operator@297:
	cmp	eax, -1
	jne	SHORT $LN23@operator@297
$LN1@operator@297:

; 596  : 			_Failed = true;

	mov	BYTE PTR [esi], 1
$LN23@operator@297:

; 597  : 		return (*this);

	mov	eax, esi

; 598  : 		}

	ret	0
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Count$ = 20						; size = 4
?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc, COMDAT
; __Ptr$ = eax

; 1518 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	mov	ecx, DWORD PTR __Dest$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, eax
	test	ebp, ebp
	jbe	SHORT $LN1@Putc
	push	esi
$LL3@Putc:

; 1519 : 			*_Dest = _MAKLOCCHR(_Elem, *_Ptr, _Cvt);

	test	ecx, ecx
	je	SHORT $LN12@Putc
	mov	eax, DWORD PTR [ecx+36]
	cmp	DWORD PTR [eax], 0
	mov	dl, BYTE PTR [edi]
	lea	esi, DWORD PTR [ecx+36]
	je	SHORT $LN18@Putc
	mov	eax, DWORD PTR [ecx+52]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN18@Putc
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	lea	esi, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [ecx], dl
	movzx	eax, dl
	jmp	SHORT $LN19@Putc
$LN18@Putc:
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	movzx	edx, dl
	push	edx
	call	eax
$LN19@Putc:
	mov	ecx, DWORD PTR __Dest$[esp+12]
	cmp	eax, -1
	jne	SHORT $LN2@Putc
$LN12@Putc:
	mov	BYTE PTR __Dest$[esp+8], 1
$LN2@Putc:

; 1518 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	dec	ebp
	inc	edi
	test	ebp, ebp
	ja	SHORT $LL3@Putc
	pop	esi
$LN1@Putc:

; 1520 : 		return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	edx, DWORD PTR __Dest$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebp

; 1521 : 		}

	ret	0
?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2083 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 2084 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	esi, eax
	or	esi, 15					; 0000000fH

; 2085 : 		if (max_size() < _Newres)

	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN6@Copy@5

; 2086 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	esi, eax

; 2087 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $LN4@Copy@5
$LN6@Copy@5:

; 2088 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	ebx, DWORD PTR [edi+24]
	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	edx, ecx
	jae	SHORT $LN4@Copy@5
	mov	eax, -2					; fffffffeH
	sub	eax, ecx
	cmp	ebx, eax
	ja	SHORT $LN4@Copy@5

; 2089 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	lea	esi, DWORD PTR [ecx+ebx]
$LN4@Copy@5:

; 2090 : 		_Elem *_Ptr = 0;
; 2091 : 
; 2092 : 		_TRY_BEGIN
; 2093 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	lea	ecx, DWORD PTR [esi+1]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $LN16@Copy@5
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0:

; 2094 : 		_CATCH_ALL
; 2095 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 2096 : 			_TRY_BEGIN
; 2097 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	inc	eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 2101 : 			_CATCH_END
; 2102 : 		_CATCH_END

	mov	eax, $LN102@Copy@5
	ret	0
$LN102@Copy@5:
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __Newres$[ebp]
$LN16@Copy@5:

; 2103 : 
; 2104 : 		if (0 < _Oldlen)

	mov	ebx, DWORD PTR __Oldlen$[ebp]
	test	ebx, ebx
	jbe	SHORT $LN67@Copy@5

; 2105 : 			_Traits_helper::copy_s<_Traits>(_Ptr, _Newres + 1, _Myptr(), _Oldlen);	// copy existing elements

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $LN59@Copy@5
	mov	eax, DWORD PTR [edi+4]
	jmp	SHORT $LN60@Copy@5
$LN59@Copy@5:
	lea	eax, DWORD PTR [edi+4]
$LN60@Copy@5:
	push	ebx
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [esi+1]
	push	edx
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN67@Copy@5:

; 2106 : 		_Tidy(true);

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $LN83@Copy@5
	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN83@Copy@5:

; 2107 : 		_Bx._Ptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edi+4]
	mov	BYTE PTR [eax], 0
	mov	DWORD PTR [eax], ecx

; 2108 : 		_Myres = _Newres;

	mov	DWORD PTR [edi+24], esi

; 2109 : 		_Eos(_Oldlen);

	mov	DWORD PTR [edi+20], ebx
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN97@Copy@5
	mov	eax, ecx
$LN97@Copy@5:
	mov	BYTE PTR [eax+ebx], 0

; 2110 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1:

; 2098 : 			_CATCH_ALL
; 2099 : 			_Tidy(true);	// failed again, discard storage and reraise

	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN47@Copy@5
	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN47@Copy@5:

; 2100 : 			_RERAISE;

	push	0
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	push	0
	mov	BYTE PTR [esi+4], 0
	call	__CxxThrowException@8
$LN106@Copy@5:
$LN105@Copy@5:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	edx, DWORD PTR [esi+20]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH
	test	BYTE PTR ___flags$[esp], 1
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN10@scalar@52
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@52:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T422539 = -4						; size = 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::truename, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi

; 89   : 		{	// return name for true

	push	ecx

; 90   : 		return (do_truename());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+20]
	push	esi
	mov	DWORD PTR $T422539[esp+8], 0
	call	edx
	mov	eax, esi

; 91   : 		}

	pop	ecx
	ret	0
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::truename
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T422545 = -4						; size = 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::falsename, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi

; 84   : 		{	// return name for false

	push	ecx

; 85   : 		return (do_falsename());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	esi
	mov	DWORD PTR $T422545[esp+8], 0
	call	edx
	mov	eax, esi

; 86   : 		}

	pop	ecx
	ret	0
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::falsename
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 8
__Ch$ = 16						; size = 1
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT
; ___$ReturnUdt$ = edi
; __Count$ = eax

; 1545 : 		for (; 0 < _Count; --_Count, ++_Dest)

	mov	ecx, DWORD PTR __Dest$[esp]
	push	ebx
	mov	bl, BYTE PTR __Ch$[esp]
	push	esi
	mov	esi, eax
	test	esi, esi
	jbe	SHORT $LN1@Rep
$LL6@Rep:

; 1546 : 			*_Dest = _Ch;

	test	ecx, ecx
	je	SHORT $LN10@Rep
	mov	eax, DWORD PTR [ecx+36]
	cmp	DWORD PTR [eax], 0
	lea	edx, DWORD PTR [ecx+36]
	je	SHORT $LN16@Rep
	mov	eax, DWORD PTR [ecx+52]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN16@Rep
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], edx
	mov	BYTE PTR [ecx], bl
	movzx	eax, bl
	jmp	SHORT $LN17@Rep
$LN16@Rep:
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	movzx	edx, bl
	push	edx
	call	eax
$LN17@Rep:
	mov	ecx, DWORD PTR __Dest$[esp+8]
	cmp	eax, -1
	jne	SHORT $LN2@Rep
$LN10@Rep:
	mov	BYTE PTR __Dest$[esp+4], 1
$LN2@Rep:

; 1545 : 		for (; 0 < _Count; --_Count, ++_Dest)

	sub	esi, 1
	jne	SHORT $LL6@Rep
$LN1@Rep:

; 1547 : 		return (_Dest);

	mov	edx, DWORD PTR __Dest$[esp+4]
	pop	esi
	mov	DWORD PTR [edi], edx
	mov	DWORD PTR [edi+4], ecx
	mov	eax, edi
	pop	ebx

; 1548 : 		}

	ret	0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Count$ = 20						; size = 4
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT
; __Ptr$ = eax

; 1510 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	mov	ecx, DWORD PTR __Dest$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, eax
	test	ebp, ebp
	jbe	SHORT $LN1@Put
	push	esi
$LL3@Put:

; 1511 : 			*_Dest = *_Ptr;

	test	ecx, ecx
	je	SHORT $LN10@Put
	mov	eax, DWORD PTR [ecx+36]
	cmp	DWORD PTR [eax], 0
	mov	dl, BYTE PTR [edi]
	lea	esi, DWORD PTR [ecx+36]
	je	SHORT $LN16@Put
	mov	eax, DWORD PTR [ecx+52]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN16@Put
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	lea	esi, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [ecx], dl
	movzx	eax, dl
	jmp	SHORT $LN17@Put
$LN16@Put:
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	movzx	edx, dl
	push	edx
	call	eax
$LN17@Put:
	mov	ecx, DWORD PTR __Dest$[esp+12]
	cmp	eax, -1
	jne	SHORT $LN2@Put
$LN10@Put:
	mov	BYTE PTR __Dest$[esp+8], 1
$LN2@Put:

; 1510 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	dec	ebp
	inc	edi
	test	ebp, ebp
	ja	SHORT $LL3@Put
	pop	esi
$LN1@Put:

; 1512 : 		return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	edx, DWORD PTR __Dest$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebp

; 1513 : 		}

	ret	0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2119 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebx

; 2120 : 			if (max_size() < _Newsize)

	mov	ebx, DWORD PTR __Newsize$[esp]
	push	esi
	mov	esi, ecx
	cmp	ebx, -2					; fffffffeH
	jbe	SHORT $LN6@Grow

; 2121 : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN6@Grow:

; 2122 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	jae	SHORT $LN5@Grow

; 2123 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2130 : 		}

	ret	8
$LN5@Grow:

; 2124 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	cmp	BYTE PTR __Trim$[esp+4], 0
	je	SHORT $LN3@Grow
	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN3@Grow
	push	edi

; 2125 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2126 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	edi, DWORD PTR [esi+20]
	cmp	ebx, edi
	jae	SHORT $LN9@Grow
	mov	edi, ebx
$LN9@Grow:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN33@Grow
	lea	eax, DWORD PTR [esi+4]
	push	ebp
	mov	ebp, DWORD PTR [eax]
	test	edi, edi
	jbe	SHORT $LN31@Grow
	push	edi
	push	ebp
	push	16					; 00000010H
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN31@Grow:
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	ebp
$LN33@Grow:
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	mov	BYTE PTR [esi+edi+4], 0
	cmp	ecx, ebx
	pop	edi
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2130 : 		}

	ret	8
$LN3@Grow:

; 2127 : 		else if (_Newsize == 0)

	test	ebx, ebx
	jne	SHORT $LN49@Grow

; 2128 : 			_Eos(0);	// new size is zero, just null terminate

	mov	DWORD PTR [esi+20], ebx
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN47@Grow
	mov	esi, DWORD PTR [esi+4]

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	mov	BYTE PTR [esi], bl
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2130 : 		}

	ret	8

; 2128 : 			_Eos(0);	// new size is zero, just null terminate

$LN47@Grow:
	add	esi, 4
	mov	BYTE PTR [esi], 0
$LN49@Grow:

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2130 : 		}

	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN8@scalar@53
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@53:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1046 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebx

; 1047 : 		if (_Right.size() < _Roff)

	mov	ebx, DWORD PTR __Right$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Roff$[esp+4]
	push	esi
	push	edi
	mov	esi, ecx
	cmp	DWORD PTR [ebx+20], ebp
	jae	SHORT $LN5@assign

; 1048 : 			_String_base::_Xran();	// _Roff off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN5@assign:

; 1049 : 		size_type _Num = _Right.size() - _Roff;

	mov	edi, DWORD PTR [ebx+20]

; 1050 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[esp+12]
	sub	edi, ebp
	cmp	eax, edi

; 1051 : 			_Num = _Count;	// trim _Num to size

	cmovb	edi, eax

; 1052 : 
; 1053 : 		if (this == &_Right)

	cmp	esi, ebx
	jne	SHORT $LN3@assign

; 1054 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	push	-1
	add	edi, ebp
	push	edi
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	push	ebp
	push	0
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1059 : 			}
; 1060 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1061 : 		}

	ret	12					; 0000000cH
$LN3@assign:

; 1055 : 		else if (_Grow(_Num))

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN17@assign
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN17@assign:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN16@assign
	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN87@assign:
	jbe	SHORT $LN86@assign

; 1056 : 			{	// make room and assign new stuff
; 1057 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

	cmp	DWORD PTR [ebx+24], 16			; 00000010H
	jb	SHORT $LN64@assign
	mov	edx, DWORD PTR [ebx+4]
	jmp	SHORT $LN65@assign

; 1055 : 		else if (_Grow(_Num))

$LN16@assign:
	test	edi, edi
	jne	SHORT $LN87@assign
	mov	DWORD PTR [esi+20], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN58@assign
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1059 : 			}
; 1060 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1061 : 		}

	ret	12					; 0000000cH

; 1055 : 		else if (_Grow(_Num))

$LN58@assign:
	lea	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1059 : 			}
; 1060 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1061 : 		}

	ret	12					; 0000000cH

; 1056 : 			{	// make room and assign new stuff
; 1057 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

$LN64@assign:
	lea	edx, DWORD PTR [ebx+4]
$LN65@assign:
	mov	ecx, DWORD PTR [esi+24]
	lea	ebx, DWORD PTR [esi+4]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN68@assign
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN69@assign
$LN68@assign:
	mov	eax, ebx
$LN69@assign:
	push	edi
	add	edx, ebp
	push	edx
	push	ecx
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 1058 : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN82@assign
	mov	ebx, DWORD PTR [ebx]
$LN82@assign:
	mov	BYTE PTR [ebx+edi], 0
$LN86@assign:
	pop	edi

; 1059 : 			}
; 1060 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1061 : 		}

	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1041 : 		return (assign(_Right, 0, npos));

	mov	eax, DWORD PTR __Right$[esp-4]
	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1042 : 		}

	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 721  : 		{	// construct by copying _Right

	push	esi

; 722  : 		_Tidy();

	xor	eax, eax
	mov	esi, ecx

; 723  : 		assign(_Right, 0, npos);

	push	-1
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	push	eax
	mov	BYTE PTR [esi+4], al
	mov	eax, DWORD PTR __Right$[esp+8]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 724  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
__Lock$423211 = 8					; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 431  : 		return (*_Ploc);

	mov	eax, DWORD PTR [ecx+36]
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	0
	lea	ecx, DWORD PTR __Lock$423211[esp+8]
	mov	DWORD PTR [edi], esi
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN5@getloc@2
	inc	eax
	mov	DWORD PTR [esi+4], eax
$LN5@getloc@2:
	lea	ecx, DWORD PTR __Lock$423211[esp+4]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, edi
	pop	edi
	pop	esi

; 432  : 		}

	ret	4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx

; 224  : 			{	// destroy the object

	push	esi
	mov	esi, ecx

; 225  : 			}

	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN21@failure
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@failure:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T423368 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::locale::name, COMDAT
; _this$ = ecx

; 407  : 		{	// return locale name

	push	ecx

; 408  : 		return (_Ptr->_Name);

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	xor	edx, edx
	push	-1
	add	eax, 24					; 00000018H
	push	edx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], edx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T423368[esp+20], edx
	mov	BYTE PTR [esi+4], dl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, esi
	pop	esi

; 409  : 		}

	pop	ecx
	ret	4
?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::locale::name
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0runtime_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	mov	edi, DWORD PTR ___that$[esp+24]
	push	edi
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	xor	edx, edx
	mov	DWORD PTR __$EHRec$[esp+36], edx
	push	-1
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	lea	eax, DWORD PTR [edi+12]
	push	edx
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	DWORD PTR [ecx+20], edx
	push	eax
	mov	BYTE PTR [ecx+4], dl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
__ehhandler$??0runtime_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
; Function compile flags: /Ogtpy
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN22@scalar@54
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN22@scalar@54:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	ecx, esi
	mov	BYTE PTR [esi+16], al
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN32@scalar@54
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@scalar@54:
	mov	eax, esi
	pop	esi
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 153  : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	??0exception@std@@QAE@XZ		; std::exception::exception
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+32], eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	push	-1
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	push	eax
	mov	BYTE PTR [ecx+4], al
	mov	eax, DWORD PTR __Message$[esp+28]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 154  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
__ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	03H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
__ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T453703 = -164						; size = 4
$T453697 = -160						; size = 4
$T453699 = -156						; size = 28
$T453698 = -128						; size = 116
__$EHRec$ = -12						; size = 12
__Ploc$ = 8						; size = 4
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::numpunct<char>::_Getcat, COMDAT
; __Ppf$ = edi

; 112  : 		{	// return locale category mask and construct standard facet

	push	-1
	push	__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+176]
	mov	DWORD PTR fs:0, eax

; 114  : 			*_Ppf = _NEW_CRT numpunct<_Elem>(
; 115  : 				_Locinfo(_Ploc->name()), 0, true);

	xor	ebx, ebx
	mov	DWORD PTR $T453703[esp+176], ebx
	cmp	edi, ebx
	je	$LN42@Getcat@6

; 113  : 		if (_Ppf != 0 && *_Ppf == 0)

	cmp	DWORD PTR [edi], ebx
	jne	$LN42@Getcat@6

; 114  : 			*_Ppf = _NEW_CRT numpunct<_Elem>(
; 115  : 				_Locinfo(_Ploc->name()), 0, true);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T453697[esp+176], esi
	mov	DWORD PTR __$EHRec$[esp+184], ebx
	cmp	esi, ebx
	je	SHORT $LN4@Getcat@6
	mov	ecx, DWORD PTR __Ploc$[esp+172]
	lea	eax, DWORD PTR $T453699[esp+176]
	push	eax
	call	?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::locale::name
	mov	BYTE PTR __$EHRec$[esp+184], 1
	push	eax
	lea	ecx, DWORD PTR $T453698[esp+180]
	mov	DWORD PTR $T453703[esp+180], 1
	call	??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Locinfo::_Locinfo
	mov	DWORD PTR __$EHRec$[esp+184], 2
	mov	ebx, 3
	push	esi
	mov	DWORD PTR $T453703[esp+180], ebx
	call	??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z ; std::numpunct<char>::numpunct<char>
	jmp	SHORT $LN5@Getcat@6
$LN4@Getcat@6:
	xor	eax, eax
$LN5@Getcat@6:
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR __$EHRec$[esp+184], 3
	test	bl, 2
	je	SHORT $LN11@Getcat@6
	and	ebx, -3					; fffffffdH
	lea	ecx, DWORD PTR $T453698[esp+176]
	mov	DWORD PTR $T453703[esp+176], ebx
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN11@Getcat@6:
	test	bl, 1
	je	SHORT $LN42@Getcat@6
	cmp	DWORD PTR $T453699[esp+200], 16		; 00000010H
	jb	SHORT $LN42@Getcat@6
	mov	ecx, DWORD PTR $T453699[esp+180]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN42@Getcat@6:

; 116  : 		return (_X_NUMERIC);

	mov	eax, 4

; 117  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+176]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	add	esp, 164				; 000000a4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T453697[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
	mov	eax, DWORD PTR $T453703[ebp]
	and	eax, 1
	je	$LN8@Getcat@6
	and	DWORD PTR $T453703[ebp], -2		; fffffffeH
	lea	ecx, DWORD PTR $T453699[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@Getcat@6:
	ret	0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2:
	mov	eax, DWORD PTR $T453703[ebp]
	and	eax, 2
	je	$LN10@Getcat@6
	and	DWORD PTR $T453703[ebp], -3		; fffffffdH
	lea	ecx, DWORD PTR $T453698[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN10@Getcat@6:
	ret	0
__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-160]
	mov	ecx, DWORD PTR [edx-164]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::numpunct<char>::_Getcat
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T453840 = -164						; size = 4
$T453834 = -160						; size = 4
$T453836 = -156						; size = 28
$T453835 = -128						; size = 116
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 1030 : 		{	// return locale category mask and construct standard facet

	push	-1
	push	__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 152				; 00000098H
	push	ebx
	push	ebp
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+180]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR __Ppf$[esp+176]
	xor	ebx, ebx

; 1031 : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	DWORD PTR $T453840[esp+180], ebx
	test	ebp, ebp
	je	$LN50@Getcat@7
	cmp	DWORD PTR [ebp], ebx
	jne	$LN50@Getcat@7

; 1032 : 			*_Ppf = _NEW_CRT num_put<_Elem, _OutIt>(
; 1033 : 				_Locinfo(_Ploc->name()));

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T453834[esp+180], esi
	mov	DWORD PTR __$EHRec$[esp+188], ebx
	test	esi, esi
	je	SHORT $LN4@Getcat@7
	mov	ecx, DWORD PTR __Ploc$[esp+176]
	lea	eax, DWORD PTR $T453836[esp+180]
	push	eax
	call	?name@locale@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::locale::name
	mov	BYTE PTR __$EHRec$[esp+188], 1
	push	eax
	lea	ecx, DWORD PTR $T453835[esp+184]
	mov	DWORD PTR $T453840[esp+184], 1
	call	??0_Locinfo@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Locinfo::_Locinfo
	mov	ebx, 3
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
	call	__Getcvt
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edx
	jmp	SHORT $LN5@Getcat@7
$LN4@Getcat@7:
	xor	esi, esi
$LN5@Getcat@7:
	mov	DWORD PTR __$EHRec$[esp+188], 2
	mov	DWORD PTR [ebp], esi
	test	bl, 2
	je	SHORT $LN11@Getcat@7
	and	ebx, -3					; fffffffdH
	lea	ecx, DWORD PTR $T453835[esp+180]
	mov	DWORD PTR $T453840[esp+180], ebx
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN11@Getcat@7:
	test	bl, 1
	je	SHORT $LN50@Getcat@7
	cmp	DWORD PTR $T453836[esp+204], 16		; 00000010H
	jb	SHORT $LN50@Getcat@7
	mov	ecx, DWORD PTR $T453836[esp+184]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN50@Getcat@7:

; 1034 : 		return (_X_NUMERIC);

	mov	eax, 4

; 1035 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+180]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 164				; 000000a4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T453834[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
	mov	eax, DWORD PTR $T453840[ebp]
	and	eax, 1
	je	$LN8@Getcat@7
	and	DWORD PTR $T453840[ebp], -2		; fffffffeH
	lea	ecx, DWORD PTR $T453836[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@Getcat@7:
	ret	0
__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-164]
	mov	ecx, DWORD PTR [edx-168]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$134448 = -36					; size = 4
__Lock$454005 = -32					; size = 4
__Lock$454027 = -32					; size = 4
__Lock$134447 = -28					; size = 4
$T453997 = -24						; size = 12
__$EHRec$ = -12						; size = 12
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT
; __Loc$ = ecx

; 486  : {	// get facet reference from locale

	push	-1
	push	__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 487  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$134447[esp+56]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[esp+60], 0

; 488  : 		const locale::facet *_Psave =
; 489  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 490  : 
; 491  : 		size_t _Id = _Facet::id;

	cmp	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, 0 ; std::numpunct<char>::id
	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
	mov	DWORD PTR __Psave$134448[esp+52], ebx
	jne	SHORT $LN11@use_facet@3
	push	0
	lea	ecx, DWORD PTR __Lock$454005[esp+56]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	cmp	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, 0 ; std::numpunct<char>::id
	jne	SHORT $LN10@use_facet@3
	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, eax ; std::numpunct<char>::id
$LN10@use_facet@3:
	lea	ecx, DWORD PTR __Lock$454005[esp+52]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN11@use_facet@3:
	mov	esi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id

; 492  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	eax, DWORD PTR [edi]
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN20@use_facet@3
	mov	ecx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+esi*4]
	test	ecx, ecx
	jne	SHORT $LN16@use_facet@3
$LN30@use_facet@3:
	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN16@use_facet@3
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN31@use_facet@3
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN15@use_facet@3
$LN20@use_facet@3:
	xor	ecx, ecx
	jmp	SHORT $LN30@use_facet@3
$LN16@use_facet@3:
	mov	esi, ecx
$LN15@use_facet@3:

; 493  : 
; 494  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN28@use_facet@3
$LN31@use_facet@3:

; 495  : 			;	// got facet from locale
; 496  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet@3

; 497  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx
	jmp	SHORT $LN28@use_facet@3
$LN4@use_facet@3:

; 498  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	push	edi
	lea	edi, DWORD PTR __Psave$134448[esp+56]
	call	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN2@use_facet@3

; 499  : 
; 500  :  #if _HAS_EXCEPTIONS
; 501  : 		_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T453997[esp+56]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	eax, DWORD PTR $T453997[esp+56]
	push	eax
	call	__CxxThrowException@8
$LN34@use_facet@3:
$LN2@use_facet@3:

; 502  : 
; 503  : 	#else /* _HAS_EXCEPTIONS */
; 504  : 			abort();	// lazy disallowed
; 505  : 	#endif /* _HAS_EXCEPTIONS */
; 506  : 
; 507  : 		else
; 508  : 			{	// queue up lazy facet for destruction
; 509  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$134448[esp+52]

; 510  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 511  : 
; 512  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 513  : 			_Pfmod->_Incref();

	push	0
	lea	ecx, DWORD PTR __Lock$454027[esp+56]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::numpunct<char> >::_Psave
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN24@use_facet@3
	inc	eax
	mov	DWORD PTR [esi+4], eax
$LN24@use_facet@3:
	lea	ecx, DWORD PTR __Lock$454027[esp+52]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 514  : 			_Pfmod->_Register();

	push	esi
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	add	esp, 4
$LN28@use_facet@3:

; 515  : 			}
; 516  : 
; 517  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$134447[esp+52]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 518  : 	_END_LOCK()
; 519  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
$LN33@use_facet@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$134447[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-36]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$134149 = -36					; size = 4
__Lock$454053 = -32					; size = 4
__Lock$454075 = -32					; size = 4
__Lock$134148 = -28					; size = 4
$T454045 = -24						; size = 12
__$EHRec$ = -12						; size = 12
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT
; __Loc$ = edi

; 486  : {	// get facet reference from locale

	push	-1
	push	__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, eax

; 487  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$134148[esp+52]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[esp+56], 0

; 488  : 		const locale::facet *_Psave =
; 489  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 490  : 
; 491  : 		size_t _Id = _Facet::id;

	cmp	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, 0 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	DWORD PTR __Psave$134149[esp+48], ebx
	jne	SHORT $LN11@use_facet@4
	push	0
	lea	ecx, DWORD PTR __Lock$454053[esp+52]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	cmp	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, 0 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	jne	SHORT $LN10@use_facet@4
	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN10@use_facet@4:
	lea	ecx, DWORD PTR __Lock$454053[esp+48]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN11@use_facet@4:
	mov	esi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id

; 492  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	eax, DWORD PTR [edi]
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN20@use_facet@4
	mov	ecx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+esi*4]
	test	ecx, ecx
	jne	SHORT $LN16@use_facet@4
$LN30@use_facet@4:
	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN16@use_facet@4
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN31@use_facet@4
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN15@use_facet@4
$LN20@use_facet@4:
	xor	ecx, ecx
	jmp	SHORT $LN30@use_facet@4
$LN16@use_facet@4:
	mov	esi, ecx
$LN15@use_facet@4:

; 493  : 
; 494  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN28@use_facet@4
$LN31@use_facet@4:

; 495  : 			;	// got facet from locale
; 496  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet@4

; 497  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx
	jmp	SHORT $LN28@use_facet@4
$LN4@use_facet@4:

; 498  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	lea	eax, DWORD PTR __Psave$134149[esp+48]
	push	edi
	push	eax
	call	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN2@use_facet@4

; 499  : 
; 500  :  #if _HAS_EXCEPTIONS
; 501  : 		_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T454045[esp+52]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	ecx, DWORD PTR $T454045[esp+52]
	push	ecx
	call	__CxxThrowException@8
$LN34@use_facet@4:
$LN2@use_facet@4:

; 502  : 
; 503  : 	#else /* _HAS_EXCEPTIONS */
; 504  : 			abort();	// lazy disallowed
; 505  : 	#endif /* _HAS_EXCEPTIONS */
; 506  : 
; 507  : 		else
; 508  : 			{	// queue up lazy facet for destruction
; 509  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$134149[esp+48]

; 510  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 511  : 
; 512  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 513  : 			_Pfmod->_Incref();

	push	0
	lea	ecx, DWORD PTR __Lock$454075[esp+52]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN24@use_facet@4
	inc	eax
	mov	DWORD PTR [esi+4], eax
$LN24@use_facet@4:
	lea	ecx, DWORD PTR __Lock$454075[esp+48]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 514  : 			_Pfmod->_Register();

	push	esi
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	add	esp, 4
$LN28@use_facet@4:

; 515  : 			}
; 516  : 
; 517  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$134148[esp+48]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 518  : 	_END_LOCK()
; 519  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
$LN33@use_facet@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$134148[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-32]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 951  : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebx
	push	ebp

; 952  : 		if (_Right.size() < _Roff)

	mov	ebp, DWORD PTR __Right$[esp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Roff$[esp+12]
	mov	esi, ecx
	cmp	DWORD PTR [ebp+20], edi
	jae	SHORT $LN5@append

; 953  : 			_String_base::_Xran();	// _Roff off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN5@append:

; 954  : 		size_type _Num = _Right.size() - _Roff;

	mov	eax, DWORD PTR [ebp+20]

; 955  : 		if (_Num < _Count)

	mov	ebx, DWORD PTR __Count$[esp+12]
	sub	eax, edi
	cmp	eax, ebx

; 956  : 			_Count = _Num;	// trim _Count to size

	cmovb	ebx, eax

; 957  : 		if (npos - _Mysize <= _Count || _Mysize + _Count < _Mysize)

	mov	eax, DWORD PTR [esi+20]
	or	ecx, -1
	sub	ecx, eax
	cmp	ecx, ebx
	jbe	SHORT $LN2@append
	lea	edx, DWORD PTR [eax+ebx]
	cmp	edx, eax
	jae	SHORT $LN3@append
$LN2@append:

; 958  : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN3@append:

; 959  : 
; 960  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	ebx, ebx
	jbe	$LN87@append
	mov	edi, DWORD PTR [esi+20]
	add	edi, ebx
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN17@append
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN17@append:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN16@append
	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN88@append:
	jbe	$LN87@append

; 961  : 			{	// make room and append new stuff
; 962  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize,
; 963  : 				_Right._Myptr() + _Roff, _Count);

	cmp	DWORD PTR [ebp+24], 16			; 00000010H
	jb	SHORT $LN64@append
	mov	ebp, DWORD PTR [ebp+4]
	jmp	SHORT $LN65@append

; 959  : 
; 960  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN16@append:
	test	edi, edi
	jne	SHORT $LN88@append
	mov	DWORD PTR [esi+20], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN58@append
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 965  : 			}
; 966  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 967  : 		}

	ret	12					; 0000000cH

; 959  : 
; 960  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN58@append:
	lea	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 965  : 			}
; 966  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 967  : 		}

	ret	12					; 0000000cH

; 961  : 			{	// make room and append new stuff
; 962  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize,
; 963  : 				_Right._Myptr() + _Roff, _Count);

$LN64@append:
	add	ebp, 4
$LN65@append:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN68@append
	mov	edx, DWORD PTR [esi+4]
	jmp	SHORT $LN69@append
$LN68@append:
	lea	edx, DWORD PTR [esi+4]
$LN69@append:
	mov	ecx, DWORD PTR [esi+20]
	push	ebx
	mov	ebx, DWORD PTR __Roff$[esp+16]
	add	ebp, ebx
	sub	eax, ecx
	push	ebp
	push	eax
	add	ecx, edx
	push	ecx
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 964  : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN82@append
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+edi], 0
	pop	edi

; 965  : 			}
; 966  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 967  : 		}

	ret	12					; 0000000cH

; 964  : 			_Eos(_Num);

$LN82@append:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+edi], 0
$LN87@append:
	pop	edi

; 965  : 			}
; 966  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 967  : 		}

	ret	12					; 0000000cH
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z
_TEXT	SEGMENT
$T454352 = -20						; size = 8
$T454353 = -12						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
__Kseparator$ = 20					; size = 1
__Dest$ = 24						; size = 8
?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped, COMDAT

; 1525 : 		{	// put char sequence [_Ptr, _Ptr + _Count) to _Dest with commas

	sub	esp, 20					; 00000014H
	push	ebx
	mov	ebx, DWORD PTR __Count$[esp+20]
	push	ebp
	mov	ebp, DWORD PTR __Ptr$[esp+24]
	push	esi
	push	edi
	npad	1
$LL5@Putgrouped:

; 1526 : 		for (; ; ++_Ptr, --_Count)
; 1527 : 			{	// put field with thousands separators for NULs
; 1528 : 			const char *_Pend =
; 1529 : 				(const char *)::memchr(_Ptr, '\0', _Count);

	push	ebx
	push	0
	push	ebp
	call	_memchr
	add	esp, 12					; 0000000cH

; 1530 : 			size_t _Groupsize = _Pend != 0 ? _Pend - _Ptr : _Count;

	test	eax, eax
	je	SHORT $LN8@Putgrouped
	sub	eax, ebp
	mov	esi, eax
	jmp	SHORT $LN9@Putgrouped
$LN8@Putgrouped:
	mov	esi, ebx
$LN9@Putgrouped:

; 1531 : 
; 1532 : 			_Dest = _Putc(_Dest, _Ptr, _Groupsize);

	mov	eax, DWORD PTR __Dest$[esp+36]
	mov	ecx, DWORD PTR __Dest$[esp+32]
	push	esi
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T454352[esp+48]
	push	edx
	mov	eax, ebp
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+48], ecx
	mov	edx, DWORD PTR [eax+4]
	add	esp, 16					; 00000010H

; 1533 : 			_Ptr += _Groupsize, _Count -= _Groupsize;

	add	ebp, esi
	sub	ebx, esi
	mov	DWORD PTR __Dest$[esp+36], edx

; 1534 : 			if (_Count == 0)

	je	SHORT $LN12@Putgrouped

; 1535 : 				break;
; 1536 : 			if (_Kseparator != (_Elem)0)

	mov	ecx, DWORD PTR __Kseparator$[esp+32]
	test	cl, cl
	je	SHORT $LN4@Putgrouped

; 1537 : 				_Dest = _Rep(_Dest, _Kseparator, 1);

	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	edx
	mov	eax, 1
	lea	edi, DWORD PTR $T454353[esp+48]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+44], ecx
	mov	edx, DWORD PTR [eax+4]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Dest$[esp+36], edx
$LN4@Putgrouped:
	inc	ebp
	dec	ebx
	jmp	SHORT $LL5@Putgrouped
$LN12@Putgrouped:

; 1538 : 			}
; 1539 : 		return (_Dest);

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+32]
	mov	eax, DWORD PTR [eax+4]

; 1540 : 		}

	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx], edx
	mov	eax, ecx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT
tv188 = 8						; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = esi
; __Off$ = edi

; 1196 : 		{	// insert _Count * _Ch at _Off

	push	ebp
	mov	ebp, DWORD PTR __Count$[esp]

; 1197 : 		if (_Mysize < _Off)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN3@insert

; 1198 : 			_String_base::_Xran();	// _Off off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN3@insert:

; 1199 : 		if (npos - _Mysize <= _Count)

	or	eax, -1
	sub	eax, DWORD PTR [esi+20]
	cmp	eax, ebp
	ja	SHORT $LN2@insert

; 1200 : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN2@insert:

; 1201 : 		size_type _Num;
; 1202 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	ebp, ebp
	jbe	$LN80@insert
	push	ebx
	mov	ebx, DWORD PTR [esi+20]
	add	ebx, ebp
	cmp	ebx, -2					; fffffffeH
	jbe	SHORT $LN11@insert
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN11@insert:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	jae	SHORT $LN10@insert
	mov	ecx, DWORD PTR [esi+20]
	push	ecx
	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	ebx, ebx
$LN83@insert:
	jbe	$LN81@insert

; 1203 : 			{	// make room and insert new stuff
; 1204 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
; 1205 : 				_Myptr() + _Off, _Mysize - _Off);	// empty out hole

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN58@insert
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR tv188[esp+4], edx
	jmp	SHORT $LN59@insert

; 1201 : 		size_type _Num;
; 1202 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN10@insert:
	test	ebx, ebx
	jne	SHORT $LN83@insert
	mov	DWORD PTR [esi+20], ebx
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN52@insert
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax], bl
	pop	ebx

; 1208 : 			}
; 1209 : 		return (*this);

	mov	eax, esi
	pop	ebp

; 1210 : 		}

	ret	8

; 1201 : 		size_type _Num;
; 1202 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN52@insert:
	lea	eax, DWORD PTR [esi+4]
	pop	ebx
	mov	BYTE PTR [eax], 0

; 1208 : 			}
; 1209 : 		return (*this);

	mov	eax, esi
	pop	ebp

; 1210 : 		}

	ret	8

; 1203 : 			{	// make room and insert new stuff
; 1204 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
; 1205 : 				_Myptr() + _Off, _Mysize - _Off);	// empty out hole

$LN58@insert:
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR tv188[esp+4], ecx
$LN59@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN62@insert
	mov	ecx, DWORD PTR [esi+4]
	jmp	SHORT $LN63@insert
$LN62@insert:
	lea	ecx, DWORD PTR [esi+4]
$LN63@insert:
	mov	edx, DWORD PTR [esi+20]
	sub	edx, edi
	push	edx
	mov	edx, DWORD PTR tv188[esp+8]
	add	edx, edi
	sub	eax, edi
	push	edx
	sub	eax, ebp
	add	ecx, edi
	push	eax
	add	ecx, ebp
	push	ecx
	call	_memmove_s

; 1206 : 			_Chassign(_Off, _Count, _Ch);	// fill hole

	mov	eax, DWORD PTR __Ch$[esp+20]
	add	esp, 16					; 00000010H
	push	eax
	push	ebp
	push	edi
	mov	ecx, esi
	call	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 1207 : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], ebx
	jb	SHORT $LN76@insert
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+ebx], 0
	pop	ebx

; 1208 : 			}
; 1209 : 		return (*this);

	mov	eax, esi
	pop	ebp

; 1210 : 		}

	ret	8

; 1207 : 			_Eos(_Num);

$LN76@insert:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+ebx], 0
$LN81@insert:
	pop	ebx
$LN80@insert:

; 1208 : 			}
; 1209 : 		return (*this);

	mov	eax, esi
	pop	ebp

; 1210 : 		}

	ret	8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 998  : 		{	// append _Count * _Ch

	push	ebx

; 999  : 			if (npos - _Mysize <= _Count)

	mov	ebx, DWORD PTR __Count$[esp]
	push	esi
	or	eax, -1
	mov	esi, ecx
	sub	eax, DWORD PTR [esi+20]
	cmp	eax, ebx
	ja	SHORT $LN2@append@2

; 1000 : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN2@append@2:

; 1001 : 
; 1002 : 		size_type _Num;
; 1003 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	ebx, ebx
	jbe	$LN63@append@2
	push	edi
	mov	edi, DWORD PTR [esi+20]
	add	edi, ebx
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN10@append@2
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN10@append@2:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN9@append@2
	mov	ecx, DWORD PTR [esi+20]
	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN66@append@2:
	jbe	SHORT $LN64@append@2

; 1004 : 			{	// make room and append new stuff using assign
; 1005 : 			_Chassign(_Mysize, _Count, _Ch);

	mov	edx, DWORD PTR __Ch$[esp+8]
	mov	eax, DWORD PTR [esi+20]
	push	edx
	push	ebx
	push	eax
	mov	ecx, esi
	call	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 1006 : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN59@append@2
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+edi], 0
	pop	edi

; 1007 : 			}
; 1008 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1009 : 		}

	ret	8

; 1001 : 
; 1002 : 		size_type _Num;
; 1003 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN9@append@2:
	test	edi, edi
	jne	SHORT $LN66@append@2
	mov	DWORD PTR [esi+20], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN51@append@2
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1007 : 			}
; 1008 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1009 : 		}

	ret	8

; 1001 : 
; 1002 : 		size_type _Num;
; 1003 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN51@append@2:
	lea	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1007 : 			}
; 1008 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1009 : 		}

	ret	8

; 1006 : 			_Eos(_Num);

$LN59@append@2:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+edi], 0
$LN64@append@2:
	pop	edi
$LN63@append@2:

; 1007 : 			}
; 1008 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1009 : 		}

	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 971  : 
; 972  :  #if _HAS_ITERATOR_DEBUGGING
; 973  : 		if (_Count != 0)
; 974  : 			_DEBUG_POINTER(_Ptr);
; 975  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 976  : 
; 977  : 		if (_Inside(_Ptr))

	mov	edx, DWORD PTR __Ptr$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	test	edx, edx
	je	SHORT $LN4@append@3
	mov	edi, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [esi+4]
	cmp	edi, 16					; 00000010H
	jb	SHORT $LN14@append@3
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN15@append@3
$LN14@append@3:
	mov	ecx, eax
$LN15@append@3:
	cmp	edx, ecx
	jb	SHORT $LN4@append@3
	cmp	edi, 16					; 00000010H
	jb	SHORT $LN18@append@3
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN19@append@3
$LN18@append@3:
	mov	ecx, eax
$LN19@append@3:
	mov	ebx, DWORD PTR [esi+20]
	add	ebx, ecx
	cmp	ebx, edx
	jbe	SHORT $LN4@append@3

; 978  : 			return (append(*this, _Ptr - _Myptr(), _Count));	// substring

	cmp	edi, 16					; 00000010H
	jb	SHORT $LN22@append@3
	mov	eax, DWORD PTR [eax]
$LN22@append@3:
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	ecx
	sub	edx, eax
	push	edx
	push	esi
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	edi
	pop	esi
	pop	ebx

; 989  : 		}

	ret	8
$LN4@append@3:

; 979  : 		if (npos - _Mysize <= _Count || _Mysize + _Count < _Mysize)

	mov	eax, DWORD PTR [esi+20]
	or	edx, -1
	push	ebp
	mov	ebp, DWORD PTR __Count$[esp+12]
	sub	edx, eax
	cmp	edx, ebp
	jbe	SHORT $LN2@append@3
	lea	ecx, DWORD PTR [eax+ebp]
	cmp	ecx, eax
	jae	SHORT $LN3@append@3
$LN2@append@3:

; 980  : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN3@append@3:

; 981  : 
; 982  : 		size_type _Num;
; 983  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	ebp, ebp
	jbe	$LN92@append@3
	mov	edi, DWORD PTR [esi+20]
	add	edi, ebp
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN29@append@3
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN29@append@3:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN28@append@3
	mov	edx, DWORD PTR [esi+20]
	push	edx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN95@append@3:
	jbe	SHORT $LN92@append@3

; 984  : 			{	// make room and append new stuff
; 985  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize, _Ptr, _Count);

	mov	eax, DWORD PTR [esi+24]
	lea	ebx, DWORD PTR [esi+4]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN76@append@3
	mov	edx, DWORD PTR [ebx]
	jmp	SHORT $LN77@append@3

; 981  : 
; 982  : 		size_type _Num;
; 983  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN28@append@3:
	test	edi, edi
	jne	SHORT $LN95@append@3
	mov	DWORD PTR [esi+20], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN70@append@3
	mov	eax, DWORD PTR [esi+4]
	pop	ebp
	pop	edi
	mov	BYTE PTR [eax], 0

; 987  : 			}
; 988  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 989  : 		}

	ret	8

; 981  : 
; 982  : 		size_type _Num;
; 983  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN70@append@3:
	lea	eax, DWORD PTR [esi+4]
	pop	ebp
	pop	edi
	mov	BYTE PTR [eax], 0

; 987  : 			}
; 988  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 989  : 		}

	ret	8

; 984  : 			{	// make room and append new stuff
; 985  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize, _Ptr, _Count);

$LN76@append@3:
	mov	edx, ebx
$LN77@append@3:
	mov	ecx, DWORD PTR [esi+20]
	push	ebp
	mov	ebp, DWORD PTR __Ptr$[esp+16]
	sub	eax, ecx
	push	ebp
	push	eax
	add	ecx, edx
	push	ecx
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 986  : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN90@append@3
	mov	ebx, DWORD PTR [ebx]
$LN90@append@3:
	mov	BYTE PTR [ebx+edi], 0
$LN92@append@3:
	pop	ebp
	pop	edi

; 987  : 			}
; 988  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 989  : 		}

	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	__Iosbase$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1
__ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT
__Lock$455136 = -64					; size = 4
__Prefix$ = -64						; size = 4
$T455201 = -60						; size = 1
$T455100 = -60						; size = 4
$T455111 = -56						; size = 8
$T455110 = -56						; size = 8
$T455109 = -56						; size = 8
$T455108 = -56						; size = 8
__Punct_fac$ = -56					; size = 4
__Iosbase$GSCopy$ = -48					; size = 4
__Grouping$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Fill$ = 12						; size = 1
__Buf$ = 16						; size = 4
__Count$ = 20						; size = 4
__Dest$ = 24						; size = 8
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT
; __Iosbase$ = ecx

; 1458 : 		{	// put formatted integer to _Dest

	push	-1
	push	__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+64], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR __Buf$[esp+80]

; 1459 : 		_DEBUG_POINTER(_Dest);
; 1460 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	eax, DWORD PTR $T455100[esp+84]
	push	eax
	mov	DWORD PTR __Iosbase$GSCopy$[esp+88], ecx
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	ebx, eax
	mov	DWORD PTR __$EHRec$[esp+92], -1
	mov	eax, DWORD PTR $T455100[esp+84]
	mov	DWORD PTR __Punct_fac$[esp+84], ebx
	test	eax, eax
	je	SHORT $LN22@Iput
	push	0
	lea	ecx, DWORD PTR __Lock$455136[esp+88]
	mov	edi, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN24@Iput
	cmp	eax, -1
	jae	SHORT $LN24@Iput
	dec	eax
	mov	DWORD PTR [edi+4], eax
$LN24@Iput:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$455136[esp+84]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN22@Iput
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax
$LN22@Iput:

; 1461 : 		const string _Grouping = _Punct_fac.grouping();

	lea	esi, DWORD PTR __Grouping$[esp+84]
	mov	ecx, ebx
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	ecx, 1
	mov	DWORD PTR __$EHRec$[esp+92], ecx

; 1462 : 		const size_t _Prefix = *_Buf == '+' || *_Buf == '-' ? 1
; 1463 : 			: *_Buf == '0' && (_Buf[1] == 'x' || _Buf[1] == 'X') ? 2
; 1464 : 			: 0;

	mov	al, BYTE PTR [ebp]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN10@Iput
	cmp	al, 45					; 0000002dH
	je	SHORT $LN10@Iput
	cmp	al, 48					; 00000030H
	jne	SHORT $LN12@Iput
	mov	al, BYTE PTR [ebp+1]
	cmp	al, 120					; 00000078H
	je	SHORT $LN11@Iput
	cmp	al, 88					; 00000058H
	jne	SHORT $LN12@Iput
$LN11@Iput:
	mov	DWORD PTR __Prefix$[esp+84], 2
	jmp	SHORT $LN14@Iput
$LN12@Iput:
	mov	DWORD PTR __Prefix$[esp+84], 0
	jmp	SHORT $LN14@Iput
$LN10@Iput:
	mov	DWORD PTR __Prefix$[esp+84], ecx
$LN14@Iput:

; 1465 : 
; 1466 : 		if (*_Grouping.c_str() != CHAR_MAX && '\0' < *_Grouping.c_str())

	mov	ecx, DWORD PTR __Grouping$[esp+108]
	mov	edx, DWORD PTR __Grouping$[esp+88]
	mov	eax, edx
	cmp	ecx, 16					; 00000010H
	jae	SHORT $LN33@Iput
	lea	eax, DWORD PTR __Grouping$[esp+88]
$LN33@Iput:
	cmp	BYTE PTR [eax], 127			; 0000007fH
	je	SHORT $LN5@Iput
	mov	eax, edx
	cmp	ecx, 16					; 00000010H
	jae	SHORT $LN39@Iput
	lea	eax, DWORD PTR __Grouping$[esp+88]
$LN39@Iput:
	cmp	BYTE PTR [eax], 0
	jle	SHORT $LN5@Iput

; 1467 : 			{	// grouping specified, add thousands separators
; 1468 : 			const char *_Pg = _Grouping.c_str();

	mov	ebx, edx
	cmp	ecx, 16					; 00000010H
	jae	SHORT $LN45@Iput
	lea	ebx, DWORD PTR __Grouping$[esp+88]
$LN45@Iput:

; 1469 : 			size_t _Off = _Count;
; 1470 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1471 : 				&& (size_t)*_Pg < _Off - _Prefix)

	mov	al, BYTE PTR [ebx]
	mov	esi, DWORD PTR __Count$[esp+80]
	cmp	al, 127					; 0000007fH
	je	SHORT $LN91@Iput
$LN6@Iput:
	test	al, al
	jle	SHORT $LN91@Iput
	mov	ecx, esi
	sub	ecx, DWORD PTR __Prefix$[esp+84]
	movsx	eax, al
	cmp	eax, ecx
	jae	SHORT $LN91@Iput

; 1472 : 				{	// add a NUL to mark thousands separator
; 1473 : 				_Off -= *_Pg;

	sub	esi, eax

; 1474 : 				_CRT_SECURE_MEMMOVE(&_Buf[_Off + 1], _Count + 1 - _Off,

	mov	eax, DWORD PTR __Count$[esp+80]
	sub	eax, esi
	inc	eax
	push	eax
	lea	edi, DWORD PTR [esi+ebp]
	push	edi
	push	eax
	lea	edx, DWORD PTR [esi+ebp+1]
	push	edx
	call	_memmove_s

; 1475 : 					&_Buf[_Off],	 _Count + 1 - _Off);
; 1476 : 				_Buf[_Off] = '\0', ++_Count;

	inc	DWORD PTR __Count$[esp+96]
	add	esp, 16					; 00000010H
	mov	BYTE PTR [edi], 0

; 1477 : 				if ('\0' < _Pg[1])

	cmp	BYTE PTR [ebx+1], 0
	jle	SHORT $LN4@Iput

; 1469 : 			size_t _Off = _Count;
; 1470 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1471 : 				&& (size_t)*_Pg < _Off - _Prefix)

	inc	ebx
$LN4@Iput:
	mov	al, BYTE PTR [ebx]
	cmp	al, 127					; 0000007fH
	jne	SHORT $LN6@Iput
$LN91@Iput:
	mov	ebx, DWORD PTR __Punct_fac$[esp+84]
$LN5@Iput:

; 1478 : 					++_Pg;	// not last group, advance
; 1479 : 				}
; 1480 : 			}
; 1481 : 
; 1482 : 		size_t _Fillcount = _Iosbase.width() <= 0
; 1483 : 			|| (size_t)_Iosbase.width() <= _Count
; 1484 : 				? 0 : (size_t)_Iosbase.width() - _Count;

	mov	ecx, DWORD PTR __Iosbase$GSCopy$[esp+84]
	mov	esi, DWORD PTR [ecx+24]
	test	esi, esi
	jle	SHORT $LN15@Iput
	mov	eax, DWORD PTR __Count$[esp+80]
	cmp	esi, eax
	jbe	SHORT $LN15@Iput
	sub	esi, eax
	jmp	SHORT $LN16@Iput
$LN15@Iput:
	xor	esi, esi
$LN16@Iput:

; 1485 : 
; 1486 : 		ios_base::fmtflags _Adjustfield =
; 1487 : 			_Iosbase.flags() & ios_base::adjustfield;

	mov	eax, DWORD PTR [ecx+16]
	and	eax, 448				; 000001c0H

; 1488 : 		if (_Adjustfield != ios_base::left
; 1489 : 			&& _Adjustfield != ios_base::internal)

	cmp	eax, 64					; 00000040H
	je	SHORT $LN1@Iput
	cmp	eax, 256				; 00000100H
	je	SHORT $LN85@Iput

; 1490 : 			{	// put leading fill
; 1491 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	eax, DWORD PTR __Fill$[esp+80]
	mov	ecx, DWORD PTR __Dest$[esp+84]
	mov	edx, DWORD PTR __Dest$[esp+80]
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	lea	edi, DWORD PTR $T455108[esp+96]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 12					; 0000000cH

; 1492 : 			_Fillcount = 0;

	jmp	SHORT $LN95@Iput
$LN85@Iput:

; 1493 : 			}
; 1494 : 		else if (_Adjustfield == ios_base::internal)
; 1495 : 			{	// put internal fill
; 1496 : 			_Dest = _Putc(_Dest, _Buf, _Prefix);	// put prefix

	mov	edi, DWORD PTR __Prefix$[esp+84]
	mov	eax, DWORD PTR __Dest$[esp+84]
	mov	ecx, DWORD PTR __Dest$[esp+80]
	push	edi
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T455109[esp+96]
	push	edx
	mov	eax, ebp
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
	mov	ecx, DWORD PTR [eax]

; 1497 : 			_Buf += _Prefix, _Count -= _Prefix;

	sub	DWORD PTR __Count$[esp+96], edi
	mov	DWORD PTR __Dest$[esp+96], ecx
	mov	edx, DWORD PTR [eax+4]

; 1498 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount), _Fillcount = 0;

	mov	ecx, DWORD PTR __Fill$[esp+96]
	mov	DWORD PTR __Dest$[esp+100], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	push	ecx
	push	edx
	push	eax
	add	ebp, edi
	mov	eax, esi
	lea	edi, DWORD PTR $T455110[esp+112]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 28					; 0000001cH
$LN95@Iput:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+80], ecx
	mov	edx, DWORD PTR [eax+4]
	xor	esi, esi
	mov	DWORD PTR __Dest$[esp+84], edx
$LN1@Iput:

; 1499 : 			}
; 1500 : 
; 1501 : 		_Dest = _Putgrouped(_Dest, _Buf, _Count,
; 1502 : 			_Punct_fac.thousands_sep());	// put field

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+8]
	mov	ecx, ebx
	call	edx
	mov	ecx, DWORD PTR __Dest$[esp+80]
	mov	BYTE PTR $T455201[esp+84], al
	mov	eax, DWORD PTR __Dest$[esp+84]
	mov	edx, DWORD PTR $T455201[esp+84]
	push	eax
	mov	eax, DWORD PTR __Count$[esp+84]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T455111[esp+100]
	push	ebp
	push	ecx
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
	mov	ecx, DWORD PTR [eax]

; 1503 : 		_Iosbase.width(0);

	mov	edx, DWORD PTR __Iosbase$GSCopy$[esp+108]

; 1504 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+104]
	mov	DWORD PTR __Dest$[esp+104], ecx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+24], 0
	mov	edx, DWORD PTR __Fill$[esp+104]
	push	edx
	push	eax
	mov	DWORD PTR __Dest$[esp+116], eax
	push	ecx
	mov	eax, esi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 36					; 00000024H
	cmp	DWORD PTR __Grouping$[esp+108], 16	; 00000010H
	jb	SHORT $LN86@Iput
	mov	eax, DWORD PTR __Grouping$[esp+88]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN86@Iput:
	mov	eax, edi

; 1505 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+64]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 64					; 00000040H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0:
	lea	ecx, DWORD PTR $T455100[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	__Iosbase$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$2
__ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
_TEXT	SEGMENT
__Enders$ = -112					; size = 3
__Fillcount$ = -108					; size = 4
__Pointptr$ = -108					; size = 4
__Lock$455384 = -104					; size = 4
$T455350 = -104						; size = 8
$T455349 = -104						; size = 8
$T455348 = -104						; size = 8
$T455347 = -104						; size = 8
$T455346 = -104						; size = 8
$T455345 = -104						; size = 8
__Prefix$ = -104					; size = 4
__Kseparator$ = -96					; size = 1
$T455375 = -96						; size = 4
$T455619 = -92						; size = 1
$T455358 = -92						; size = 8
$T455357 = -92						; size = 8
$T455356 = -92						; size = 8
$T455353 = -92						; size = 8
$T455352 = -92						; size = 8
$T455351 = -92						; size = 8
__Punct_fac$ = -92					; size = 4
__Iosbase$GSCopy$ = -84					; size = 4
$T455340 = -80						; size = 4
__Groupstring$ = -76					; size = 28
__Grouping$ = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Fill$ = 12						; size = 1
__Buf$ = 16						; size = 4
__Beforepoint$ = 20					; size = 4
__Afterpoint$ = 24					; size = 4
__Trailing$ = 28					; size = 4
__Count$ = 32						; size = 4
__Dest$ = 36						; size = 8
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput, COMDAT
; __Iosbase$ = ecx

; 1313 : 		{	// put formatted floating-point to _Dest

	push	-1
	push	__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+116], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+136]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR __Count$[esp+132]
	mov	ebp, DWORD PTR __Buf$[esp+132]

; 1314 : 		_DEBUG_POINTER(_Dest);
; 1315 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	eax, DWORD PTR $T455340[esp+136]
	push	eax
	mov	DWORD PTR __Iosbase$GSCopy$[esp+140], ecx
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+144], 0
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	edi, eax
	mov	DWORD PTR __$EHRec$[esp+144], -1
	mov	eax, DWORD PTR $T455340[esp+136]
	mov	DWORD PTR __Punct_fac$[esp+136], edi
	test	eax, eax
	je	SHORT $LN31@Fput
	mov	esi, eax
	push	0
	lea	ecx, DWORD PTR __Lock$455384[esp+140]
	mov	DWORD PTR $T455375[esp+140], esi
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jbe	SHORT $LN33@Fput
	cmp	eax, -1
	jae	SHORT $LN33@Fput
	dec	eax
	mov	DWORD PTR [esi+4], eax
$LN33@Fput:
	mov	esi, DWORD PTR [esi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	and	esi, DWORD PTR $T455375[esp+136]
	lea	ecx, DWORD PTR __Lock$455384[esp+136]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN31@Fput
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax
$LN31@Fput:

; 1316 : 		const string _Grouping = _Punct_fac.grouping();

	lea	esi, DWORD PTR __Grouping$[esp+136]
	mov	ecx, edi
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	esi, 1
	mov	DWORD PTR __$EHRec$[esp+144], esi

; 1317 : 		const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, edi
	call	eax

; 1318 : 		string _Groupstring;

	xor	ecx, ecx
	mov	BYTE PTR __Kseparator$[esp+136], al
	mov	DWORD PTR __Groupstring$[esp+160], 15	; 0000000fH
	mov	DWORD PTR __Groupstring$[esp+156], ecx
	mov	BYTE PTR __Groupstring$[esp+140], cl
	mov	BYTE PTR __$EHRec$[esp+144], 2

; 1319 : 		const _Elem _E0 = _MAKLOCCHR(_Elem, '0', _Cvt);
; 1320 : 		size_t _Prefix = _Buf[0] == '+' || _Buf[0] == '-' ? 1 : 0;

	mov	al, BYTE PTR [ebp]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN19@Fput
	mov	DWORD PTR __Prefix$[esp+136], ecx
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN20@Fput
$LN19@Fput:
	mov	DWORD PTR __Prefix$[esp+136], esi
$LN20@Fput:

; 1321 : 
; 1322 : 		char _Enders[3];
; 1323 : 		_Enders[0] = ::localeconv()->decimal_point[0];

	call	_localeconv
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx]

; 1324 : 		_Enders[1] = 'e';
; 1325 : 		_Enders[2] = '\0';
; 1326 : 
; 1327 : 		const char *_Eptr = (const char *)::memchr(_Buf,
; 1328 : 			'e', _Count);	// find exponent

	push	ebx
	push	101					; 00000065H
	push	ebp
	mov	BYTE PTR __Enders$[esp+148], dl
	mov	BYTE PTR __Enders$[esp+149], 101	; 00000065H
	mov	BYTE PTR __Enders$[esp+150], 0
	call	_memchr
	add	esp, 12					; 0000000cH
	mov	edi, eax

; 1329 : 		const char *_Pointptr = (const char *)::memchr(_Buf,
; 1330 : 			_Enders[0], _Count);	// find decimal point

	movsx	eax, BYTE PTR __Enders$[esp+136]
	push	ebx
	push	eax
	push	ebp
	call	_memchr
	mov	esi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Pointptr$[esp+136], esi

; 1331 : 		if (_Pointptr == 0)

	test	esi, esi
	jne	SHORT $LN16@Fput

; 1332 : 			_Trailing = 0;

	mov	DWORD PTR __Trailing$[esp+132], eax
$LN16@Fput:

; 1333 : 
; 1334 : 		if (*_Grouping.c_str() != CHAR_MAX && '\0' < *_Grouping.c_str())

	mov	ecx, DWORD PTR __Grouping$[esp+160]
	mov	edx, DWORD PTR __Grouping$[esp+140]
	mov	eax, edx
	cmp	ecx, 16					; 00000010H
	jae	SHORT $LN78@Fput
	lea	eax, DWORD PTR __Grouping$[esp+140]
$LN78@Fput:
	cmp	BYTE PTR [eax], 127			; 0000007fH
	je	$LN105@Fput
	mov	eax, edx
	cmp	ecx, 16					; 00000010H
	jae	SHORT $LN84@Fput
	lea	eax, DWORD PTR __Grouping$[esp+140]
$LN84@Fput:
	cmp	BYTE PTR [eax], 0
	jle	$LN105@Fput

; 1335 : 			{	// grouping specified, add thousands separators
; 1336 : 			_Groupstring.append(_Buf, _Count);	// assemble field into string

	push	ebx
	push	ebp
	lea	ecx, DWORD PTR __Groupstring$[esp+144]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1337 : 			if (_Eptr == 0)

	test	edi, edi
	jne	SHORT $LN14@Fput

; 1338 : 				_Groupstring.append(_Trailing, '0');

	mov	ecx, DWORD PTR __Trailing$[esp+132]
	push	48					; 00000030H
	push	ecx
	lea	ecx, DWORD PTR __Groupstring$[esp+144]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1339 : 			else

	jmp	SHORT $LN13@Fput
$LN14@Fput:

; 1340 : 				{	/* dispose of any zeros before exponent */
; 1341 : 				if (_Pointptr == 0)

	test	esi, esi
	jne	SHORT $LN12@Fput

; 1342 : 					{	/* no point but exponent, put scaling zeros */
; 1343 : 					_Groupstring.append(_Beforepoint, '0');

	mov	edx, DWORD PTR __Beforepoint$[esp+132]
	push	48					; 00000030H
	push	edx
	lea	ecx, DWORD PTR __Groupstring$[esp+144]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1344 : 					_Beforepoint = 0;

	mov	DWORD PTR __Beforepoint$[esp+132], esi
$LN12@Fput:

; 1345 : 					}
; 1346 : 				_Groupstring.insert(_Eptr - _Buf, _Trailing, '0');

	mov	eax, DWORD PTR __Trailing$[esp+132]
	push	48					; 00000030H
	push	eax
	sub	edi, ebp
	lea	esi, DWORD PTR __Groupstring$[esp+144]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	mov	esi, DWORD PTR __Pointptr$[esp+136]
$LN13@Fput:

; 1347 : 				}
; 1348 : 			_Trailing = 0;
; 1349 : 
; 1350 : 			if (_Pointptr == 0)
; 1351 : 				_Groupstring.append(_Beforepoint, '0');

	push	48					; 00000030H
	test	esi, esi
	jne	SHORT $LN11@Fput
	mov	ecx, DWORD PTR __Beforepoint$[esp+136]
	push	ecx
	lea	ecx, DWORD PTR __Groupstring$[esp+144]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1352 : 			else

	jmp	SHORT $LN10@Fput
$LN11@Fput:

; 1353 : 				{	// fill in zeros around decimal point
; 1354 : 				_Groupstring.insert(_Pointptr - _Buf + 1, _Afterpoint, '0');

	mov	edx, DWORD PTR __Afterpoint$[esp+136]
	mov	ebx, esi
	sub	ebx, ebp
	push	edx
	lea	edi, DWORD PTR [ebx+1]
	lea	esi, DWORD PTR __Groupstring$[esp+144]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1355 : 				_Groupstring.insert(_Pointptr - _Buf, _Beforepoint, '0');

	mov	eax, DWORD PTR __Beforepoint$[esp+132]
	push	48					; 00000030H
	push	eax
	mov	edi, ebx
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1356 : 				_Afterpoint = 0;

	mov	DWORD PTR __Afterpoint$[esp+132], 0
$LN10@Fput:

; 1357 : 				}
; 1358 : 			_Beforepoint = 0;
; 1359 : 
; 1360 : 			const char *_Pg = _Grouping.c_str();

	mov	ebx, DWORD PTR __Grouping$[esp+140]
	mov	eax, 16					; 00000010H
	mov	DWORD PTR __Beforepoint$[esp+132], 0
	cmp	DWORD PTR __Grouping$[esp+160], eax
	jae	SHORT $LN90@Fput
	lea	ebx, DWORD PTR __Grouping$[esp+140]
$LN90@Fput:

; 1361 : 			size_t _Off = ::strcspn(&_Groupstring[0], &_Enders[0]);

	cmp	DWORD PTR __Groupstring$[esp+160], eax
	mov	eax, DWORD PTR __Groupstring$[esp+140]
	jae	SHORT $LN97@Fput
	lea	eax, DWORD PTR __Groupstring$[esp+140]
$LN97@Fput:
	lea	ecx, DWORD PTR __Enders$[esp+136]
	push	ecx
	push	eax
	call	_strcspn
	mov	edi, eax

; 1362 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1363 : 				&& (size_t)*_Pg < _Off - _Prefix)

	mov	al, BYTE PTR [ebx]
	add	esp, 8
	cmp	al, 127					; 0000007fH
	je	SHORT $LN8@Fput
$LN9@Fput:
	test	al, al
	jle	SHORT $LN8@Fput
	mov	edx, edi
	sub	edx, DWORD PTR __Prefix$[esp+136]
	movsx	eax, al
	cmp	eax, edx
	jae	SHORT $LN8@Fput

; 1364 : 				{	// add a NUL to mark thousands separator
; 1365 : 				_Groupstring.insert(_Off -= *_Pg, (size_t)1, '\0');

	push	0
	sub	edi, eax
	push	1
	lea	esi, DWORD PTR __Groupstring$[esp+144]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1366 : 				if ('\0' < _Pg[1])

	cmp	BYTE PTR [ebx+1], 0
	jle	SHORT $LN7@Fput

; 1362 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1363 : 				&& (size_t)*_Pg < _Off - _Prefix)

	inc	ebx
$LN7@Fput:
	mov	al, BYTE PTR [ebx]
	cmp	al, 127					; 0000007fH
	jne	SHORT $LN9@Fput
$LN8@Fput:

; 1367 : 					++_Pg;	// not last group, advance
; 1368 : 				}
; 1369 : 
; 1370 : 			_Buf = &_Groupstring[0];

	cmp	DWORD PTR __Groupstring$[esp+160], 16	; 00000010H
	mov	ebp, DWORD PTR __Groupstring$[esp+140]
	jae	SHORT $LN104@Fput
	lea	ebp, DWORD PTR __Groupstring$[esp+140]
$LN104@Fput:

; 1371 : 			_Trailing = 0;
; 1372 : 			_Count = _Groupstring.size();

	mov	ebx, DWORD PTR __Groupstring$[esp+156]
	mov	DWORD PTR __Trailing$[esp+132], 0
$LN105@Fput:

; 1373 : 			}
; 1374 : 
; 1375 : 		size_t _Fillcount = _Beforepoint + _Afterpoint + _Trailing + _Count;

	mov	ecx, DWORD PTR __Afterpoint$[esp+132]
	mov	eax, DWORD PTR __Beforepoint$[esp+132]

; 1376 : 		_Fillcount = _Iosbase.width() <= 0
; 1377 : 			|| (size_t)_Iosbase.width() <= _Fillcount
; 1378 : 				? 0 : (size_t)_Iosbase.width() - _Fillcount;

	mov	edx, DWORD PTR __Iosbase$GSCopy$[esp+136]
	add	eax, ecx
	add	eax, DWORD PTR __Trailing$[esp+132]
	mov	ecx, DWORD PTR [edx+24]
	add	eax, ebx
	test	ecx, ecx
	jle	SHORT $LN21@Fput
	cmp	ecx, eax
	jbe	SHORT $LN21@Fput
	sub	ecx, eax
	mov	esi, ecx
	mov	DWORD PTR __Fillcount$[esp+136], esi
	jmp	SHORT $LN22@Fput
$LN21@Fput:
	mov	DWORD PTR __Fillcount$[esp+136], 0
	mov	esi, DWORD PTR __Fillcount$[esp+136]
$LN22@Fput:

; 1379 : 		ios_base::fmtflags _Adjustfield =
; 1380 : 			_Iosbase.flags() & ios_base::adjustfield;

	mov	eax, DWORD PTR [edx+16]
	and	eax, 448				; 000001c0H

; 1381 : 		if (_Adjustfield != ios_base::left
; 1382 : 			&& _Adjustfield != ios_base::internal)

	cmp	eax, 64					; 00000040H
	je	$LN4@Fput
	cmp	eax, 256				; 00000100H
	je	SHORT $LN174@Fput

; 1383 : 			{	// put leading fill
; 1384 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	edx, DWORD PTR __Fill$[esp+132]
	mov	eax, DWORD PTR __Dest$[esp+136]
	mov	ecx, DWORD PTR __Dest$[esp+132]
	push	edx
	push	eax
	push	ecx
	mov	eax, esi
	lea	edi, DWORD PTR $T455345[esp+148]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+144], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[esp+148], eax

; 1385 : 			_Fillcount = 0;

	jmp	SHORT $LN185@Fput
$LN174@Fput:

; 1386 : 			}
; 1387 : 		else if (_Adjustfield == ios_base::internal)
; 1388 : 			{	// put internal fill
; 1389 : 			if (0 < _Prefix)

	cmp	DWORD PTR __Prefix$[esp+136], 0
	jbe	SHORT $LN3@Fput

; 1390 : 				{	// but first put sign
; 1391 : 				_Dest = _Putc(_Dest, _Buf, 1);

	mov	ecx, DWORD PTR __Dest$[esp+136]
	mov	edx, DWORD PTR __Dest$[esp+132]
	push	1
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T455346[esp+148]
	push	eax
	mov	eax, ebp
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+148], ecx
	mov	edx, DWORD PTR [eax+4]
	add	esp, 16					; 00000010H

; 1392 : 				++_Buf, --_Count;

	inc	ebp
	mov	DWORD PTR __Dest$[esp+136], edx
	dec	ebx
$LN3@Fput:

; 1393 : 				}
; 1394 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	eax, DWORD PTR __Fill$[esp+132]
	mov	ecx, DWORD PTR __Dest$[esp+136]
	mov	edx, DWORD PTR __Dest$[esp+132]
	push	eax
	push	ecx
	push	edx
	mov	eax, esi
	lea	edi, DWORD PTR $T455347[esp+148]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+144], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[esp+148], edx
$LN185@Fput:

; 1395 : 			_Fillcount = 0;

	mov	DWORD PTR __Fillcount$[esp+148], 0
	add	esp, 12					; 0000000cH
$LN4@Fput:

; 1396 : 			}
; 1397 : 
; 1398 : 		_Pointptr = (const char *)::memchr(_Buf,
; 1399 : 			_Enders[0], _Count);	// find decimal point again

	movsx	eax, BYTE PTR __Enders$[esp+136]
	push	ebx
	push	eax
	push	ebp
	call	_memchr
	add	esp, 12					; 0000000cH

; 1400 : 		if (_Pointptr != 0)

	test	eax, eax
	je	$LN2@Fput

; 1401 : 			{	// has decimal point, put pieces and zero fills
; 1402 : 			size_t _Fracoffset = _Pointptr - _Buf + 1;
; 1403 : 			_Dest = _Putgrouped(_Dest, _Buf, _Fracoffset - 1, _Kseparator);

	mov	ecx, DWORD PTR __Dest$[esp+136]
	mov	edx, DWORD PTR __Dest$[esp+132]
	push	ecx
	sub	eax, ebp
	inc	eax
	push	edx
	mov	esi, eax
	mov	eax, DWORD PTR __Kseparator$[esp+144]
	push	eax
	lea	ecx, DWORD PTR [esi-1]
	push	ecx
	lea	edx, DWORD PTR $T455348[esp+152]
	push	ebp
	push	edx
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+156], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[esp+160], edx

; 1404 : 			_Dest = _Rep(_Dest, _E0, _Beforepoint);

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Beforepoint$[esp+156]
	push	48					; 00000030H
	push	ecx
	push	edx
	lea	edi, DWORD PTR $T455349[esp+172]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+168], ecx
	mov	edx, DWORD PTR [eax+4]

; 1405 : 			_Dest = _Rep(_Dest, _Punct_fac.decimal_point(), 1);

	mov	ecx, DWORD PTR __Punct_fac$[esp+172]
	mov	DWORD PTR __Dest$[esp+172], edx
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	add	esp, 36					; 00000024H
	call	edx
	mov	ecx, DWORD PTR __Dest$[esp+136]
	mov	edx, DWORD PTR __Dest$[esp+132]
	mov	BYTE PTR $T455619[esp+136], al
	mov	eax, DWORD PTR $T455619[esp+136]
	push	eax
	push	ecx
	push	edx
	mov	eax, 1
	lea	edi, DWORD PTR $T455350[esp+148]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+144], ecx
	mov	edx, DWORD PTR [eax+4]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Dest$[esp+136], edx

; 1406 : 			_Dest = _Rep(_Dest, _E0, _Afterpoint);

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Afterpoint$[esp+132]
	push	48					; 00000030H
	push	ecx
	push	edx
	lea	edi, DWORD PTR $T455351[esp+148]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+144], ecx
	mov	edx, DWORD PTR [eax+4]
	add	esp, 12					; 0000000cH

; 1407 : 			_Buf += _Fracoffset, _Count -= _Fracoffset;

	add	ebp, esi
	mov	DWORD PTR __Dest$[esp+136], edx
	sub	ebx, esi
$LN2@Fput:

; 1408 : 			}
; 1409 : 
; 1410 : 		_Eptr = (const char *)::memchr(_Buf,
; 1411 : 			'e', _Count);	// find exponent again

	push	ebx
	push	101					; 00000065H
	push	ebp
	call	_memchr
	add	esp, 12					; 0000000cH

; 1412 : 		if (_Eptr != 0)

	test	eax, eax
	je	$LN1@Fput

; 1413 : 			{	// has exponent field, put it out
; 1414 : 			size_t _Expoffset = _Eptr - _Buf + 1;
; 1415 : 			_Dest = _Putgrouped(_Dest, _Buf, _Expoffset - 1, _Kseparator);

	mov	ecx, DWORD PTR __Dest$[esp+132]
	mov	edx, DWORD PTR __Kseparator$[esp+136]
	sub	eax, ebp
	inc	eax
	mov	esi, eax
	mov	eax, DWORD PTR __Dest$[esp+136]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR [esi-1]
	push	eax
	lea	ecx, DWORD PTR $T455352[esp+152]
	push	ebp
	push	ecx
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+156], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[esp+160], ecx

; 1416 : 			_Dest = _Rep(_Dest, _E0, _Trailing), _Trailing = 0;

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	push	48					; 00000030H
	push	edx
	push	eax
	mov	eax, DWORD PTR __Trailing$[esp+168]
	lea	edi, DWORD PTR $T455353[esp+172]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+168], ecx

; 1417 : 			_Dest = _Putc(_Dest, _Iosbase.flags() & ios_base::uppercase
; 1418 : 				? "E" : "e", 1);

	mov	ecx, DWORD PTR __Iosbase$GSCopy$[esp+172]
	mov	edx, DWORD PTR [eax+4]
	add	esp, 36					; 00000024H
	test	BYTE PTR [ecx+16], 4
	mov	DWORD PTR __Dest$[esp+136], edx
	mov	DWORD PTR __Trailing$[esp+132], 0
	mov	ecx, OFFSET ??_C@_01DDCIFGEA@E?$AA@
	jne	SHORT $LN24@Fput
	mov	ecx, OFFSET ??_C@_01KGKMHCOC@e?$AA@
$LN24@Fput:
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	push	1
	push	edx
	push	eax
	lea	edx, DWORD PTR $T455356[esp+148]
	push	edx
	mov	eax, ecx
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+148], ecx
	mov	edx, DWORD PTR [eax+4]
	add	esp, 16					; 00000010H

; 1419 : 			_Buf += _Expoffset, _Count -= _Expoffset;

	add	ebp, esi
	mov	DWORD PTR __Dest$[esp+136], edx
	sub	ebx, esi
$LN1@Fput:

; 1420 : 			}
; 1421 : 
; 1422 : 		_Dest = _Putgrouped(_Dest, _Buf, _Count,
; 1423 : 			_Kseparator);	// put leftover field

	mov	eax, DWORD PTR __Dest$[esp+136]
	mov	ecx, DWORD PTR __Dest$[esp+132]
	mov	edx, DWORD PTR __Kseparator$[esp+136]
	push	eax
	push	ecx
	push	edx
	push	ebx
	lea	eax, DWORD PTR $T455357[esp+152]
	push	ebp
	push	eax
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+156], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[esp+160], edx

; 1424 : 		_Dest = _Rep(_Dest, _E0, _Trailing);	// put trailing zeros

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Trailing$[esp+156]
	push	48					; 00000030H
	push	ecx
	push	edx
	lea	edi, DWORD PTR $T455358[esp+172]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ecx, DWORD PTR [eax]

; 1425 : 		_Iosbase.width(0);

	mov	edx, DWORD PTR __Iosbase$GSCopy$[esp+172]

; 1426 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+168]
	mov	DWORD PTR __Dest$[esp+168], ecx
	mov	eax, DWORD PTR [eax+4]
	xor	esi, esi
	add	esp, 36					; 00000024H
	mov	DWORD PTR [edx+24], esi
	mov	edx, DWORD PTR __Fill$[esp+132]
	push	edx
	push	eax
	mov	DWORD PTR __Dest$[esp+144], eax
	mov	eax, DWORD PTR __Fillcount$[esp+144]
	push	ecx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ebx, 16					; 00000010H
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR __Groupstring$[esp+160], ebx
	jb	SHORT $LN137@Fput
	mov	eax, DWORD PTR __Groupstring$[esp+140]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN137@Fput:
	mov	DWORD PTR __Groupstring$[esp+160], 15	; 0000000fH
	mov	DWORD PTR __Groupstring$[esp+156], esi
	mov	BYTE PTR __Groupstring$[esp+140], 0
	cmp	DWORD PTR __Grouping$[esp+160], ebx
	jb	SHORT $LN175@Fput
	mov	ecx, DWORD PTR __Grouping$[esp+140]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN175@Fput:
	mov	eax, edi

; 1427 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+136]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+116]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 116				; 00000074H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$0:
	lea	ecx, DWORD PTR $T455340[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$1:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$2:
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-120]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1064 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp

; 1065 : 
; 1066 :  #if _HAS_ITERATOR_DEBUGGING
; 1067 : 		if (_Count != 0)
; 1068 : 			_DEBUG_POINTER(_Ptr);
; 1069 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1070 : 
; 1071 : 		if (_Inside(_Ptr))

	mov	ebp, DWORD PTR __Ptr$[esp]
	push	esi
	push	edi
	mov	esi, ecx
	test	ebp, ebp
	je	SHORT $LN93@assign@3
	mov	edx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [esi+4]
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN12@assign@3
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN13@assign@3
$LN12@assign@3:
	mov	ecx, eax
$LN13@assign@3:
	cmp	ebp, ecx
	jb	SHORT $LN93@assign@3
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN16@assign@3
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN17@assign@3
$LN16@assign@3:
	mov	ecx, eax
$LN17@assign@3:
	mov	edi, DWORD PTR [esi+20]
	add	edi, ecx
	cmp	edi, ebp
	jbe	SHORT $LN93@assign@3

; 1072 : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

	cmp	edx, 16					; 00000010H
	jb	SHORT $LN20@assign@3
	mov	eax, DWORD PTR [eax]
$LN20@assign@3:
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	ecx
	sub	ebp, eax
	push	ebp
	push	esi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi
	pop	ebp

; 1080 : 		}

	ret	8
$LN93@assign@3:

; 1073 : 
; 1074 : 		if (_Grow(_Count))

	mov	edi, DWORD PTR __Count$[esp+8]
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN27@assign@3
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN27@assign@3:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN26@assign@3
	mov	edx, DWORD PTR [esi+20]
	push	edx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN94@assign@3:
	jbe	SHORT $LN90@assign@3

; 1075 : 			{	// make room and assign new stuff
; 1076 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Count);

	mov	ecx, DWORD PTR [esi+24]
	push	ebx
	lea	ebx, DWORD PTR [esi+4]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN74@assign@3
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN75@assign@3

; 1073 : 
; 1074 : 		if (_Grow(_Count))

$LN26@assign@3:
	test	edi, edi
	jne	SHORT $LN94@assign@3
	mov	DWORD PTR [esi+20], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN68@assign@3
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1078 : 			}
; 1079 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 1080 : 		}

	ret	8

; 1073 : 
; 1074 : 		if (_Grow(_Count))

$LN68@assign@3:
	lea	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1078 : 			}
; 1079 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 1080 : 		}

	ret	8

; 1075 : 			{	// make room and assign new stuff
; 1076 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Count);

$LN74@assign@3:
	mov	eax, ebx
$LN75@assign@3:
	push	edi
	push	ebp
	push	ecx
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 1077 : 			_Eos(_Count);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN88@assign@3
	mov	ebx, DWORD PTR [ebx]
$LN88@assign@3:
	mov	BYTE PTR [ebx+edi], 0
	pop	ebx
$LN90@assign@3:
	pop	edi

; 1078 : 			}
; 1079 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 1080 : 		}

	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
__Buf$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1278 : 		{	// put formatted void pointer to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax

; 1279 : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 1280 : 		char _Buf[_Buf_size];
; 1281 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 1282 : 			::sprintf_s(_Buf, _Buf_size, "%p", _Val)));

	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	push	edx
	push	eax
	push	OFFSET ??_C@_02BBAHNLBA@?$CFp?$AA@
	lea	eax, DWORD PTR __Buf$[esp+96]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	mov	edx, DWORD PTR __Fill$[ebp]
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[esp+92]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	edx
	push	esi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1283 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+104]
	add	esp, 24					; 00000018H
	mov	eax, esi
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__real@38aa95a5b7f87a0f
PUBLIC	__real@4202a05f20000000
PUBLIC	__real@4733426172c74d82
PUBLIC	__mask@@NegDouble@
PUBLIC	__Iosbase$GSCopy$
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT __real@38aa95a5b7f87a0f
CONST	SEGMENT
__real@38aa95a5b7f87a0f DQ 038aa95a5b7f87a0fr	; 1e-035
CONST	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+010
CONST	ENDS
;	COMDAT __real@4733426172c74d82
CONST	SEGMENT
__real@4733426172c74d82 DQ 04733426172c74d82r	; 1e+035
CONST	ENDS
;	COMDAT __mask@@NegDouble@
CONST	SEGMENT
__mask@@NegDouble@ DB 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 080H
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT
__Iosbase$GSCopy$ = -136				; size = 4
___$ReturnUdt$GSCopy$ = -132				; size = 4
__Fmt$ = -128						; size = 8
__Buf$ = -120						; size = 108
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1237 : 		{	// put formatted long double to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+180], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ebx

; 1268 : 			}
; 1269 : 
; 1270 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1271 : 			_Beforepoint, _Afterpoint, _Precision,
; 1272 : 				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 'L', _Iosbase.flags()),
; 1273 : 					_Significance, _Val)));	// convert and put

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+184], eax
	mov	eax, DWORD PTR [ecx+20]
	push	esi
	push	edi
	mov	DWORD PTR __Iosbase$GSCopy$[esp+192], ecx
	test	eax, eax
	jg	SHORT $LN13@do_put

; 1238 : 		const size_t _Buf_size = _MAX_EXP_DIG + _MAX_SIG_DIG + 64;
; 1239 : 		char _Buf[_Buf_size], _Fmt[8];
; 1240 : 		streamsize _Precision = _Iosbase.precision() <= 0
; 1241 : 			&& !(_Iosbase.flags() & ios_base::fixed)
; 1242 : 				? 6 : _Iosbase.precision();	// desired precision

	test	DWORD PTR [ecx+16], 8192		; 00002000H
	jne	SHORT $LN13@do_put
	mov	eax, 6
$LN13@do_put:
	mov	esi, eax

; 1243 : 		int _Significance = _MAX_SIG_DIG < _Precision
; 1244 : 			? _MAX_SIG_DIG : (int)_Precision;	// actual sprintf precision

	cmp	esi, 36					; 00000024H
	mov	edx, 36					; 00000024H
	jg	SHORT $LN16@do_put
	mov	edx, esi
$LN16@do_put:

; 1245 : 		_Precision -= _Significance;
; 1246 : 		size_t _Beforepoint = 0;	// zeros to add before decimal point
; 1247 : 		size_t _Afterpoint = 0;	// zeros to add after decimal point
; 1248 : 
; 1249 : 		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)

	mov	ecx, DWORD PTR [ecx+16]
	mov	eax, ecx
	and	eax, 12288				; 00003000H
	sub	esi, edx
	xor	ebx, ebx
	xor	edi, edi
	cmp	eax, 8192				; 00002000H
	jne	$LN1@do_put

; 1250 : 			{	// scale silly fixed-point value
; 1251 : 			bool _Signed = _Val < 0;

	xorps	xmm3, xmm3
	movsd	xmm0, QWORD PTR __Val$[ebp]
	comisd	xmm3, xmm0
	movsd	xmm4, QWORD PTR __mask@@NegDouble@
	jbe	$LN17@do_put

; 1253 : 				_Val = -_Val;

	xorpd	xmm0, xmm4
	mov	al, 1
	movsd	QWORD PTR __Val$[ebp], xmm0
$LN9@do_put:

; 1254 : 
; 1255 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	movsd	xmm1, QWORD PTR __real@4733426172c74d82
	comisd	xmm0, xmm1
	movsd	xmm2, QWORD PTR __real@4202a05f20000000
	jb	SHORT $LN6@do_put
$LL8@do_put:
	cmp	ebx, 5000				; 00001388H
	jae	SHORT $LN43@do_put

; 1256 : 				_Val /= 1e10;	// drop 10 zeros before decimal point

	divsd	xmm0, xmm2
	add	ebx, 10					; 0000000aH
	comisd	xmm0, xmm1
	jae	SHORT $LL8@do_put
$LN43@do_put:
	movsd	QWORD PTR __Val$[ebp], xmm0
$LN6@do_put:

; 1257 : 
; 1258 : 			if (0 < _Val)

	comisd	xmm0, xmm3
	jbe	SHORT $LN2@do_put

; 1259 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1260 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	cmp	esi, 10					; 0000000aH
	jl	SHORT $LN2@do_put
	movsd	xmm1, QWORD PTR __real@38aa95a5b7f87a0f
$LL4@do_put:
	comisd	xmm1, xmm0
	jb	SHORT $LN45@do_put
	cmp	edi, 5000				; 00001388H
	jae	SHORT $LN45@do_put

; 1263 : 					_Precision -= 10;

	sub	esi, 10					; 0000000aH
	add	edi, 10					; 0000000aH
	cmp	esi, 10					; 0000000aH
	mulsd	xmm0, xmm2
	jge	SHORT $LL4@do_put
$LN45@do_put:

; 1261 : 					{	// drop 10 zeros after decimal point
; 1262 : 					_Val *= 1e10;

	movsd	QWORD PTR __Val$[ebp], xmm0
$LN2@do_put:

; 1264 : 					}
; 1265 : 
; 1266 : 			if (_Signed)

	test	al, al
	je	SHORT $LN1@do_put

; 1267 : 				_Val = -_Val;

	xorpd	xmm0, xmm4
	movsd	QWORD PTR __Val$[ebp], xmm0
$LN1@do_put:

; 1268 : 			}
; 1269 : 
; 1270 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1271 : 			_Beforepoint, _Afterpoint, _Precision,
; 1272 : 				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 'L', _Iosbase.flags()),
; 1273 : 					_Significance, _Val)));	// convert and put

	mov	BYTE PTR __Fmt$[esp+192], 37		; 00000025H
	lea	eax, DWORD PTR __Fmt$[esp+193]
	test	cl, 32					; 00000020H
	je	SHORT $LN31@do_put
	mov	BYTE PTR __Fmt$[esp+193], 43		; 0000002bH
	lea	eax, DWORD PTR __Fmt$[esp+194]
$LN31@do_put:
	test	cl, 16					; 00000010H
	je	SHORT $LN30@do_put
	mov	BYTE PTR [eax], 35			; 00000023H
	inc	eax
$LN30@do_put:
	mov	BYTE PTR [eax], 46			; 0000002eH
	inc	eax
	mov	BYTE PTR [eax], 42			; 0000002aH
	inc	eax
	mov	BYTE PTR [eax], 76			; 0000004cH
	and	ecx, 12288				; 00003000H
	inc	eax
	cmp	ecx, 8192				; 00002000H
	jne	SHORT $LN36@do_put
	mov	cl, 102					; 00000066H
	jmp	SHORT $LN35@do_put
$LN17@do_put:

; 1250 : 			{	// scale silly fixed-point value
; 1251 : 			bool _Signed = _Val < 0;

	xor	al, al

; 1252 : 			if (_Signed)

	jmp	$LN9@do_put

; 1268 : 			}
; 1269 : 
; 1270 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1271 : 			_Beforepoint, _Afterpoint, _Precision,
; 1272 : 				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 'L', _Iosbase.flags()),
; 1273 : 					_Significance, _Val)));	// convert and put

$LN36@do_put:
	cmp	ecx, 12288				; 00003000H
	jne	SHORT $LN34@do_put
	mov	cl, 97					; 00000061H
	jmp	SHORT $LN35@do_put
$LN34@do_put:
	cmp	ecx, 4096				; 00001000H
	setne	cl
	lea	ecx, DWORD PTR [ecx+ecx+101]
$LN35@do_put:
	fld	QWORD PTR __Val$[ebp]
	mov	BYTE PTR [eax], cl
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	BYTE PTR [eax+1], 0
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	lea	ecx, DWORD PTR __Fmt$[esp+212]
	push	ecx
	lea	edx, DWORD PTR __Buf$[esp+216]
	push	108					; 0000006cH
	push	edx
	call	_sprintf_s
	mov	ecx, DWORD PTR __Fill$[ebp]
	add	esp, 24					; 00000018H
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$[esp+208]
	push	edi
	push	ebx
	lea	eax, DWORD PTR __Buf$[esp+216]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$GSCopy$[esp+224]
	push	esi
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput

; 1274 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+228]
	add	esp, 36					; 00000024H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__Iosbase$GSCopy$
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
__Iosbase$GSCopy$ = -136				; size = 4
___$ReturnUdt$GSCopy$ = -132				; size = 4
__Fmt$ = -128						; size = 8
__Buf$ = -120						; size = 108
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1195 : 		{	// put formatted double to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+180], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ebx

; 1227 : 			}
; 1228 : 
; 1229 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1230 : 			_Beforepoint, _Afterpoint, _Precision,
; 1231 : 				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 0, _Iosbase.flags()),
; 1232 : 					_Significance, _Val)));	// convert and put

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+184], eax
	mov	eax, DWORD PTR [ecx+20]
	push	esi
	push	edi
	mov	DWORD PTR __Iosbase$GSCopy$[esp+192], ecx
	test	eax, eax
	jg	SHORT $LN13@do_put@2

; 1196 : 		const size_t _Buf_size = _MAX_EXP_DIG + _MAX_SIG_DIG + 64;
; 1197 : 		char _Buf[_Buf_size], _Fmt[8];
; 1198 : 		streamsize _Precision = _Iosbase.precision() <= 0
; 1199 : 			&& !(_Iosbase.flags() & ios_base::fixed)
; 1200 : 				? 6 : _Iosbase.precision();	// desired precision

	test	DWORD PTR [ecx+16], 8192		; 00002000H
	jne	SHORT $LN13@do_put@2
	mov	eax, 6
$LN13@do_put@2:
	mov	esi, eax

; 1201 : 		int _Significance = _MAX_SIG_DIG < _Precision
; 1202 : 			? _MAX_SIG_DIG : (int)_Precision;	// actual sprintf precision

	cmp	esi, 36					; 00000024H
	mov	edx, 36					; 00000024H
	jg	SHORT $LN16@do_put@2
	mov	edx, esi
$LN16@do_put@2:

; 1203 : 		_Precision -= _Significance;
; 1204 : 		size_t _Beforepoint = 0;	// zeros to add before decimal point
; 1205 : 		size_t _Afterpoint = 0;	// zeros to add after decimal point
; 1206 : 
; 1207 : 		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed
; 1208 : 			&& _Val * 0.5 != _Val)	// skip -Inf, 0, Inf

	mov	ecx, DWORD PTR [ecx+16]
	mov	eax, ecx
	and	eax, 12288				; 00003000H
	sub	esi, edx
	xor	ebx, ebx
	xor	edi, edi
	cmp	eax, 8192				; 00002000H
	jne	$LN1@do_put@2
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movapd	xmm1, xmm0
	mulsd	xmm1, QWORD PTR __real@3fe0000000000000
	ucomisd	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN1@do_put@2

; 1209 : 			{	// scale silly fixed-point value
; 1210 : 			bool _Signed = _Val < 0;

	xorps	xmm3, xmm3
	comisd	xmm3, xmm0
	movsd	xmm4, QWORD PTR __mask@@NegDouble@
	jbe	$LN17@do_put@2

; 1212 : 				_Val = -_Val;

	xorpd	xmm0, xmm4
	mov	al, 1
	movsd	QWORD PTR __Val$[ebp], xmm0
$LN9@do_put@2:

; 1213 : 
; 1214 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	movsd	xmm1, QWORD PTR __real@4733426172c74d82
	comisd	xmm0, xmm1
	movsd	xmm2, QWORD PTR __real@4202a05f20000000
	jb	SHORT $LN6@do_put@2
	npad	2
$LL8@do_put@2:
	cmp	ebx, 5000				; 00001388H
	jae	SHORT $LN43@do_put@2

; 1215 : 				_Val /= 1e10;	// drop 10 zeros before decimal point

	divsd	xmm0, xmm2
	add	ebx, 10					; 0000000aH
	comisd	xmm0, xmm1
	jae	SHORT $LL8@do_put@2
$LN43@do_put@2:
	movsd	QWORD PTR __Val$[ebp], xmm0
$LN6@do_put@2:

; 1216 : 
; 1217 : 			if (0 < _Val)

	comisd	xmm0, xmm3
	jbe	SHORT $LN2@do_put@2

; 1218 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1219 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	cmp	esi, 10					; 0000000aH
	jl	SHORT $LN2@do_put@2
	movsd	xmm1, QWORD PTR __real@38aa95a5b7f87a0f
	npad	3
$LL4@do_put@2:
	comisd	xmm1, xmm0
	jb	SHORT $LN45@do_put@2
	cmp	edi, 5000				; 00001388H
	jae	SHORT $LN45@do_put@2

; 1222 : 					_Precision -= 10;

	sub	esi, 10					; 0000000aH
	add	edi, 10					; 0000000aH
	cmp	esi, 10					; 0000000aH
	mulsd	xmm0, xmm2
	jge	SHORT $LL4@do_put@2
$LN45@do_put@2:

; 1220 : 					{	// drop 10 zeros after decimal point
; 1221 : 					_Val *= 1e10;

	movsd	QWORD PTR __Val$[ebp], xmm0
$LN2@do_put@2:

; 1223 : 					}
; 1224 : 
; 1225 : 			if (_Signed)

	test	al, al
	je	SHORT $LN1@do_put@2

; 1226 : 				_Val = -_Val;

	xorpd	xmm0, xmm4
	movsd	QWORD PTR __Val$[ebp], xmm0
$LN1@do_put@2:

; 1227 : 			}
; 1228 : 
; 1229 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1230 : 			_Beforepoint, _Afterpoint, _Precision,
; 1231 : 				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 0, _Iosbase.flags()),
; 1232 : 					_Significance, _Val)));	// convert and put

	mov	BYTE PTR __Fmt$[esp+192], 37		; 00000025H
	lea	eax, DWORD PTR __Fmt$[esp+193]
	test	cl, 32					; 00000020H
	je	SHORT $LN31@do_put@2
	mov	BYTE PTR __Fmt$[esp+193], 43		; 0000002bH
	lea	eax, DWORD PTR __Fmt$[esp+194]
$LN31@do_put@2:
	test	cl, 16					; 00000010H
	je	SHORT $LN30@do_put@2
	mov	BYTE PTR [eax], 35			; 00000023H
	inc	eax
$LN30@do_put@2:
	mov	BYTE PTR [eax], 46			; 0000002eH
	inc	eax
	mov	BYTE PTR [eax], 42			; 0000002aH
	and	ecx, 12288				; 00003000H
	inc	eax
	cmp	ecx, 8192				; 00002000H
	jne	SHORT $LN36@do_put@2
	mov	cl, 102					; 00000066H
	jmp	SHORT $LN35@do_put@2
$LN17@do_put@2:

; 1209 : 			{	// scale silly fixed-point value
; 1210 : 			bool _Signed = _Val < 0;

	xor	al, al

; 1211 : 			if (_Signed)

	jmp	$LN9@do_put@2

; 1227 : 			}
; 1228 : 
; 1229 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1230 : 			_Beforepoint, _Afterpoint, _Precision,
; 1231 : 				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 0, _Iosbase.flags()),
; 1232 : 					_Significance, _Val)));	// convert and put

$LN36@do_put@2:
	cmp	ecx, 12288				; 00003000H
	jne	SHORT $LN34@do_put@2
	mov	cl, 97					; 00000061H
	jmp	SHORT $LN35@do_put@2
$LN34@do_put@2:
	cmp	ecx, 4096				; 00001000H
	setne	cl
	lea	ecx, DWORD PTR [ecx+ecx+101]
$LN35@do_put@2:
	fld	QWORD PTR __Val$[ebp]
	mov	BYTE PTR [eax], cl
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	BYTE PTR [eax+1], 0
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	lea	ecx, DWORD PTR __Fmt$[esp+212]
	push	ecx
	lea	edx, DWORD PTR __Buf$[esp+216]
	push	108					; 0000006cH
	push	edx
	call	_sprintf_s
	mov	ecx, DWORD PTR __Fill$[ebp]
	add	esp, 24					; 00000018H
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$[esp+208]
	push	edi
	push	ebx
	lea	eax, DWORD PTR __Buf$[esp+216]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$GSCopy$[esp+224]
	push	esi
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput

; 1233 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+228]
	add	esp, 36					; 00000024H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
__Fmt$ = -80						; size = 8
__Buf$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1184 : 		{	// put formatted unsigned long long to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+84], eax

; 1185 : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 1186 : 		char _Buf[_Buf_size], _Fmt[8];
; 1187 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 1188 : 			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "Lu",
; 1189 : 				_Iosbase.flags()), _Val)));

	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Iosbase$[ebp]
	mov	edx, DWORD PTR [ebx+16]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi
	push	eax
	mov	eax, DWORD PTR __Val$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR __Val$[ebp]
	push	eax
	push	ecx
	mov	edi, OFFSET ??_C@_02CLHGNPPK@Lu?$AA@
	lea	eax, DWORD PTR __Fmt$[esp+112]
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	push	eax
	lea	edx, DWORD PTR __Buf$[esp+116]
	push	64					; 00000040H
	push	edx
	call	_sprintf_s
	mov	ecx, DWORD PTR __Fill$[ebp]
	add	esp, 20					; 00000014H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+108]
	push	eax
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1190 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+120]
	add	esp, 24					; 00000018H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
__Fmt$ = -80						; size = 8
__Buf$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1174 : 		{	// put formatted long long to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+84], eax

; 1175 : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 1176 : 		char _Buf[_Buf_size], _Fmt[8];
; 1177 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 1178 : 			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "Ld",
; 1179 : 				_Iosbase.flags()), _Val)));

	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Iosbase$[ebp]
	mov	edx, DWORD PTR [ebx+16]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi
	push	eax
	mov	eax, DWORD PTR __Val$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR __Val$[ebp]
	push	eax
	push	ecx
	mov	edi, OFFSET ??_C@_02HIKPPMOK@Ld?$AA@
	lea	eax, DWORD PTR __Fmt$[esp+112]
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	push	eax
	lea	edx, DWORD PTR __Buf$[esp+116]
	push	64					; 00000040H
	push	edx
	call	_sprintf_s
	mov	ecx, DWORD PTR __Fill$[ebp]
	add	esp, 20					; 00000014H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+108]
	push	eax
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1180 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+120]
	add	esp, 24					; 00000018H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
__Fmt$ = -80						; size = 6
__Buf$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1163 : 		{	// put formatted unsigned long to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+84], eax

; 1164 : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 1165 : 		char _Buf[_Buf_size], _Fmt[6];
; 1166 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 1167 : 			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "lu",
; 1168 : 				_Iosbase.flags()), _Val)));

	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Iosbase$[ebp]
	mov	edx, DWORD PTR [ebx+16]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi
	push	eax
	mov	eax, DWORD PTR __Val$[ebp]
	push	ecx
	push	eax
	mov	edi, OFFSET ??_C@_02BDDLJJBK@lu?$AA@
	lea	eax, DWORD PTR __Fmt$[esp+108]
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	push	eax
	lea	ecx, DWORD PTR __Buf$[esp+112]
	push	64					; 00000040H
	push	ecx
	call	_sprintf_s
	add	esp, 16					; 00000010H
	push	eax
	mov	eax, DWORD PTR __Fill$[ebp]
	lea	edx, DWORD PTR __Buf$[esp+108]
	push	edx
	push	eax
	push	esi
	mov	ecx, ebx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1169 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+120]
	add	esp, 24					; 00000018H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
__Fmt$ = -80						; size = 6
__Buf$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1153 : 		{	// put formatted long to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+84], eax

; 1154 : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 1155 : 		char _Buf[_Buf_size], _Fmt[6];
; 1156 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 1157 : 			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "ld",
; 1158 : 				_Iosbase.flags()), _Val)));

	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Iosbase$[ebp]
	mov	edx, DWORD PTR [ebx+16]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi
	push	eax
	mov	eax, DWORD PTR __Val$[ebp]
	push	ecx
	push	eax
	mov	edi, OFFSET ??_C@_02EAOCLKAK@ld?$AA@
	lea	eax, DWORD PTR __Fmt$[esp+108]
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	push	eax
	lea	ecx, DWORD PTR __Buf$[esp+112]
	push	64					; 00000040H
	push	ecx
	call	_sprintf_s
	add	esp, 16					; 00000010H
	push	eax
	mov	eax, DWORD PTR __Fill$[ebp]
	lea	edx, DWORD PTR __Buf$[esp+108]
	push	edx
	push	eax
	push	esi
	mov	ecx, ebx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1159 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+120]
	add	esp, 24					; 00000018H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__Iosbase$GSCopy$
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$3
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -104				; size = 4
__Punct_fac$131184 = -100				; size = 4
$T456318 = -96						; size = 4
__Lock$456355 = -92					; size = 4
$T456323 = -92						; size = 8
__Iosbase$GSCopy$ = -84					; size = 4
$T456324 = -84						; size = 8
$T456320 = -76						; size = 28
$T456319 = -76						; size = 28
__Str$131191 = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 1
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1123 : 		{	// put formatted bool to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+108], eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, eax
	mov	edi, DWORD PTR __Iosbase$[ebp]

; 1124 : 		_DEBUG_POINTER(_Dest);
; 1125 : 		if (!(_Iosbase.flags() & ios_base::boolalpha))

	test	DWORD PTR [edi+16], 16384		; 00004000H
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 1144 : 				}
; 1145 : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+124], esi
	mov	DWORD PTR __Iosbase$GSCopy$[esp+124], edi
	jne	SHORT $LN5@do_put@3
	movzx	edx, BYTE PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+28]
	push	edx
	mov	edx, DWORD PTR __Fill$[ebp]
	push	edx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edi
	push	edx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	push	esi
	call	eax
	mov	eax, esi
	jmp	$LN4@do_put@3
$LN5@do_put@3:

; 1126 : 			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
; 1127 : 		else
; 1128 : 			{	// put "false" or "true"
; 1129 : 			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	ecx, DWORD PTR $T456318[esp+124]
	push	ecx
	mov	ecx, edi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+132], 0
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	DWORD PTR __$EHRec$[esp+132], -1
	mov	ebx, DWORD PTR $T456318[esp+124]
	mov	DWORD PTR __Punct_fac$131184[esp+124], eax
	test	ebx, ebx
	je	SHORT $LN19@do_put@3
	push	0
	lea	ecx, DWORD PTR __Lock$456355[esp+128]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jbe	SHORT $LN21@do_put@3
	cmp	eax, -1
	jae	SHORT $LN21@do_put@3
	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN21@do_put@3:
	mov	esi, DWORD PTR [ebx+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$456355[esp+124]
	and	esi, ebx
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN19@do_put@3
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax
$LN19@do_put@3:

; 1130 : 			_Mystr _Str;

	mov	DWORD PTR __Str$131191[esp+148], 15	; 0000000fH
	mov	DWORD PTR __Str$131191[esp+144], 0
	mov	BYTE PTR __Str$131191[esp+128], 0

; 1131 : 			if (_Val)

	cmp	BYTE PTR __Val$[ebp], 0

; 1132 : 				_Str.assign(_Punct_fac.truename());

	mov	ecx, DWORD PTR __Punct_fac$131184[esp+124]
	mov	DWORD PTR __$EHRec$[esp+132], 1
	lea	esi, DWORD PTR $T456319[esp+124]
	je	SHORT $LN3@do_put@3
	call	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR __Str$131191[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 2
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	BYTE PTR __$EHRec$[esp+132], 1
	cmp	DWORD PTR $T456319[esp+148], 16		; 00000010H
	jb	SHORT $LN103@do_put@3
	mov	ecx, DWORD PTR $T456319[esp+128]
	push	ecx

; 1133 : 			else

	jmp	SHORT $LN166@do_put@3
$LN3@do_put@3:

; 1134 : 				_Str.assign(_Punct_fac.falsename());

	call	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR __Str$131191[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 3
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	BYTE PTR __$EHRec$[esp+132], 1
	cmp	DWORD PTR $T456320[esp+148], 16		; 00000010H
	jb	SHORT $LN103@do_put@3
	mov	edx, DWORD PTR $T456320[esp+128]
	push	edx
$LN166@do_put@3:
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN103@do_put@3:

; 1135 : 
; 1136 : 			size_t _Fillcount = _Iosbase.width() <= 0
; 1137 : 				|| (size_t)_Iosbase.width() <= _Str.size()
; 1138 : 					? 0 : (size_t)_Iosbase.width() - _Str.size();

	mov	esi, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR __Str$131191[esp+144]
	test	esi, esi
	jle	SHORT $LN8@do_put@3
	cmp	esi, ecx
	jbe	SHORT $LN8@do_put@3
	sub	esi, ecx
	jmp	SHORT $LN9@do_put@3
$LN8@do_put@3:
	xor	esi, esi
$LN9@do_put@3:

; 1139 : 
; 1140 : 			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)

	mov	eax, DWORD PTR [edi+16]
	mov	ebx, DWORD PTR __Fill$[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN1@do_put@3

; 1141 : 				{	// put leading fill
; 1142 : 				_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	edx, DWORD PTR __Dest$[ebp]
	push	ebx
	push	ecx
	push	edx
	mov	eax, esi
	lea	edi, DWORD PTR $T456323[esp+136]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ecx, DWORD PTR [eax]

; 1143 : 				_Fillcount = 0;

	mov	edi, DWORD PTR __Iosbase$GSCopy$[esp+136]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __Str$131191[esp+156]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp+4], edx
	xor	esi, esi
$LN1@do_put@3:

; 1144 : 				}
; 1145 : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

	cmp	DWORD PTR __Str$131191[esp+148], 16	; 00000010H
	mov	eax, DWORD PTR __Str$131191[esp+128]
	jae	SHORT $LN132@do_put@3
	lea	eax, DWORD PTR __Str$131191[esp+128]
$LN132@do_put@3:
	mov	edx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T456324[esp+136]
	push	ecx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	eax, DWORD PTR [eax+4]

; 1146 : 			_Iosbase.width(0);
; 1147 : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	push	ebx
	push	eax
	mov	DWORD PTR __Dest$[ebp+4], eax
	mov	DWORD PTR [edi+24], 0
	mov	edi, DWORD PTR ___$ReturnUdt$GSCopy$[esp+148]
	push	ecx
	mov	eax, esi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 28					; 0000001cH
	cmp	DWORD PTR __Str$131191[esp+148], 16	; 00000010H
	jb	SHORT $LN151@do_put@3
	mov	edx, DWORD PTR __Str$131191[esp+128]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN151@do_put@3:
	mov	eax, edi
$LN4@do_put@3:

; 1148 : 			}
; 1149 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+108]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0:
	lea	ecx, DWORD PTR $T456318[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1:
	lea	ecx, DWORD PTR __Str$131191[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$2:
	lea	ecx, DWORD PTR $T456319[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$3:
	lea	ecx, DWORD PTR $T456320[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-108]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1083 : 		{	// assign [_Ptr, <null>)

	push	esi

; 1084 : 		_DEBUG_POINTER(_Ptr);
; 1085 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, esi
	push	edi
	lea	edi, DWORD PTR [eax+1]
	npad	5
$LL5@assign@4:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL5@assign@4
	sub	eax, edi
	push	eax
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 1086 : 		}

	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 652  : 		_Tidy();
; 653  : 		assign(_Ptr);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	push	esi
	mov	esi, ecx
	mov	eax, edx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	1
$LL37@basic_stri@3:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL37@basic_stri@3
	sub	eax, edi
	push	eax
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi

; 654  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0runtime_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN24@scalar@72
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@scalar@72:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	ecx, esi
	mov	BYTE PTR [esi+16], al
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN34@scalar@72
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@scalar@72:
	mov	eax, esi
	pop	esi
	ret	4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xiosbase
_TEXT	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 220  : 			{	// construct with message

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	mov	DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@

; 221  : 			}

	mov	eax, esi
	pop	esi
	ret	4
??0failure@ios_base@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::ios_base::failure::failure
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T497186 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 184  : 		{	// return name for true

	push	ecx

; 185  : 		return (string_type(_Truename));

	mov	ecx, DWORD PTR [ecx+20]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	eax, ecx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR $T497186[esp+12], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	7
$LL41@do_truenam:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL41@do_truenam
	sub	eax, edi
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	mov	eax, esi
	pop	esi

; 186  : 		}

	pop	ecx
	ret	4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T497337 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 179  : 		{	// return name for false

	push	ecx

; 180  : 		return (string_type(_Falsename));

	mov	ecx, DWORD PTR [ecx+16]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	eax, ecx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR $T497337[esp+12], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	7
$LL41@do_falsena:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL41@do_falsena
	sub	eax, edi
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	mov	eax, esi
	pop	esi

; 181  : 		}

	pop	ecx
	ret	4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T497488 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 174  : 		{	// return grouping string

	push	ecx

; 175  : 		return (string(_Grouping));

	mov	ecx, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	eax, ecx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR $T497488[esp+12], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	7
$LL41@do_groupin:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL41@do_groupin
	sub	eax, edi
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	mov	eax, esi
	pop	esi

; 176  : 		}

	pop	ecx
	ret	4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$?clear@ios_base@std@@QAEXH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$2
__ehfuncinfo$?clear@ios_base@std@@QAEXH_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?clear@ios_base@std@@QAEXH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T497640 = -152						; size = 40
$T497638 = -152						; size = 40
$T497641 = -112						; size = 28
$T497639 = -112						; size = 28
$T497642 = -84						; size = 40
$T497643 = -44						; size = 28
__$EHRec$ = -12						; size = 12
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 285  :         {	// set state, possibly reraise exception

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?clear@ios_base@std@@QAEXH_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+156]
	mov	DWORD PTR fs:0, eax

; 286  :         _Mystate = (iostate)(_State & _Statmask);

	mov	eax, DWORD PTR __State$[ebp]
	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+8], eax

; 287  :         if ((_Mystate & _Except) == 0)

	mov	ecx, DWORD PTR [ecx+12]
	and	ecx, eax
	je	$LN1@clear@17

; 288  :             ;
; 289  :         else if (_Reraise)

	cmp	BYTE PTR __Reraise$[ebp], 0
	je	SHORT $LN6@clear@17

; 290  :             _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN25@clear@17:
$LN6@clear@17:

; 291  :         else if (_Mystate & _Except & badbit)

	test	cl, 4
	je	SHORT $LN4@clear@17

; 292  :             _THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	lea	ecx, DWORD PTR $T497639[esp+160]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T497639[esp+156]
	push	eax
	lea	ecx, DWORD PTR $T497638[esp+160]
	mov	DWORD PTR __$EHRec$[esp+168], 0
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI3?AVfailure@ios_base@std@@
	lea	ecx, DWORD PTR $T497638[esp+160]
	push	ecx
	mov	DWORD PTR $T497638[esp+164], OFFSET ??_7failure@ios_base@std@@6B@
	call	__CxxThrowException@8
$LN26@clear@17:
$LN4@clear@17:

; 293  :         else if (_Mystate & _Except & failbit)

	test	cl, 2
	je	SHORT $LN2@clear@17

; 294  :             _THROW_NCEE(failure, "ios_base::failbit set");

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
	lea	ecx, DWORD PTR $T497641[esp+160]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	edx, DWORD PTR $T497641[esp+156]
	push	edx
	lea	ecx, DWORD PTR $T497640[esp+160]
	mov	DWORD PTR __$EHRec$[esp+168], 1
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI3?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T497640[esp+160]
	push	eax
	mov	DWORD PTR $T497640[esp+164], OFFSET ??_7failure@ios_base@std@@6B@
	call	__CxxThrowException@8
$LN27@clear@17:
$LN2@clear@17:

; 295  :         else
; 296  :             _THROW_NCEE(failure, "ios_base::eofbit set");

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
	lea	ecx, DWORD PTR $T497643[esp+160]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR $T497643[esp+156]
	push	ecx
	lea	ecx, DWORD PTR $T497642[esp+160]
	mov	DWORD PTR __$EHRec$[esp+168], 2
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI3?AVfailure@ios_base@std@@
	lea	edx, DWORD PTR $T497642[esp+160]
	push	edx
	mov	DWORD PTR $T497642[esp+164], OFFSET ??_7failure@ios_base@std@@6B@
	call	__CxxThrowException@8
$LN28@clear@17:
$LN1@clear@17:

; 297  :         }

	mov	ecx, DWORD PTR __$EHRec$[esp+156]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN24@clear@17:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$0:
	lea	ecx, DWORD PTR $T497639[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$1:
	lea	ecx, DWORD PTR $T497641[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$2:
	lea	ecx, DWORD PTR $T497643[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?clear@ios_base@std@@QAEXH_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-140]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?clear@ios_base@std@@QAEXH_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 43   : 		ios_base::clear((iostate)(_Mystrbuf == 0
; 44   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [ecx+40], 0
	mov	eax, DWORD PTR __State$[esp-4]
	jne	SHORT $LN4@clear@18
	or	eax, 4
$LN4@clear@18:
	mov	DWORD PTR __State$[esp-4], eax
	jmp	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 53   : 		{	// merge _State into state, possible reraise exception

	push	ecx

; 54   : 		if (_State != goodbit)

	mov	edx, DWORD PTR __State$[esp]
	test	edx, edx
	je	SHORT $LN6@setstate@2

; 55   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN8@setstate@2
	or	eax, 4
$LN8@setstate@2:
	mov	edx, DWORD PTR __Reraise$[esp]
	push	edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN6@setstate@2:
	pop	ecx

; 56   : 		}

	ret	8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 550  : 		{	// flush output stream

	push	ecx
	push	esi
	mov	esi, ecx

; 551  : 		ios_base::iostate _State = ios_base::goodbit;
; 552  : 		if (!ios_base::fail() && _Myios::rdbuf()->pubsync() == -1)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	lea	eax, DWORD PTR [ecx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN1@flush@7
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1@flush@7

; 553  : 			_State |= ios_base::badbit;	// sync failed

	mov	edi, 4
$LN1@flush@7:

; 554  : 		_Myios::setstate(_State);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN21@flush@7
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN19@flush@7
	or	eax, 4
$LN19@flush@7:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN21@flush@7:

; 555  : 		return (*this);
; 556  : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ecx
	ret	0
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 139  : 		{	// perform any wrapup

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 140  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 141  : 		if (ios_base::flags() & ios_base::unitbuf)

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	test	BYTE PTR [edx+ecx+16], 2
	je	SHORT $LN8@Osfx

; 142  : 			flush();	// flush stream as needed

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN8@Osfx:

; 145  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:

; 143  : 		_CATCH_ALL
; 144  : 		_CATCH_END

	mov	eax, $LN8@Osfx
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 102  : 			{	// destroy the object

	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR __$EHRec$[esp+36], 0

; 103  : 
; 104  :  #if _HAS_EXCEPTIONS
; 105  : 			if (!_XSTD uncaught_exception())

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN1@sentry@3

; 106  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN1@sentry@3:

; 107  : 			}

	mov	DWORD PTR __$EHRec$[esp+36], -1
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN12@sentry@3
	lea	ecx, DWORD PTR [eax+4]
	call	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
$LN12@sentry@3:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// construct locking and testing stream

	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+32], edi
	mov	esi, DWORD PTR __Ostr$[esp+28]
	mov	DWORD PTR [edi], esi
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi+40]
	test	eax, eax
	je	SHORT $LN12@sentry@4
	lea	ecx, DWORD PTR [eax+4]
	call	?_Lock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Lock
$LN12@sentry@4:
	mov	DWORD PTR __$EHRec$[esp+40], 0

; 96   : 			if (_Ostr.good() && _Ostr.tie() != 0)

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN1@sentry@4
	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN1@sentry@4

; 97   : 				_Ostr.tie()->flush();

	mov	ecx, eax
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN1@sentry@4:

; 98   : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+esi+8], 0
	sete	al
	mov	BYTE PTR [edi+4], al

; 99   : 			}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$9 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$0
__tryblocktable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$9
__ehfuncinfo$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT
__Ok$ = -36						; size = 8
__State$ = -28						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Ch$ = 8						; size = 1
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::put, COMDAT
; _this$ = ecx

; 508  : 		{	// insert a character

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 509  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	esi, esi

; 510  : 		const sentry _Ok(*this);

	push	edi
	lea	ecx, DWORD PTR __Ok$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __State$[ebp], esi
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], ebx

; 511  : 
; 512  : 		if (!_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], bl
	jne	SHORT $LN4@put

; 513  : 			_State |= ios_base::badbit;

	lea	esi, DWORD PTR [ebx+4]

; 514  : 		else

	jmp	SHORT $LN11@put
$LN4@put:

; 515  : 			{	// state okay, insert character
; 516  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 517  : 			if (_Traits::eq_int_type(_Traits::eof(),
; 518  : 				_Myios::rdbuf()->sputc(_Ch)))

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+edi+40]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx], ebx
	je	SHORT $LN18@put
	mov	eax, DWORD PTR [ecx+52]
	cmp	DWORD PTR [eax], ebx
	jle	SHORT $LN18@put
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	mov	cl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [eax], cl
	movzx	eax, cl
	jmp	SHORT $LN19@put
$LN18@put:
	movzx	eax, BYTE PTR __Ch$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN19@put:
	cmp	eax, -1
	jne	SHORT $LN1@put

; 519  : 				_State |= ios_base::badbit;

	lea	esi, DWORD PTR [eax+5]
$LN1@put:
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	jmp	SHORT $LN11@put
__catch$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$0:

; 520  : 			_CATCH_IO_END

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	or	eax, 4
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN41@put
	or	eax, 4
$LN41@put:
	push	1
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN76@put
	ret	0
$LN76@put:
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __State$[ebp]
$LN11@put:

; 521  : 			}
; 522  : 
; 523  : 		_Myios::setstate(_State);

	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, edi
	test	esi, esi
	je	SHORT $LN70@put
	mov	eax, DWORD PTR [ecx+8]
	or	eax, esi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN72@put
	or	eax, 4
$LN72@put:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN70@put:

; 524  : 		return (*this);

	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, edi

; 525  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::put
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z$11
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z
_TEXT	SEGMENT
$T602754 = -52						; size = 8
__Ok$ = -44						; size = 8
__Nput_fac$129554 = -36					; size = 4
$T602803 = -32						; size = 1
__Lock$602789 = -32					; size = 4
$T602751 = -28						; size = 4
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
$T602755 = 12						; size = 8
__Val$ = 12						; size = 8
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT

; 370  : 		{	// insert an unsigned long long

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR _this$[ebp]

; 371  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 372  : 		const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __State$[ebp], edi
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], edi

; 373  : 
; 374  : 		if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	je	$LN13@operator@389

; 375  : 			{	// state okay, use facet to insert
; 376  : 			const _Nput& _Nput_fac = _USE(ios_base::getloc(), _Nput);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T602751[ebp]
	push	eax
	add	ecx, esi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	ebx, DWORD PTR $T602751[ebp]
	mov	DWORD PTR __Nput_fac$129554[ebp], eax
	test	ebx, ebx
	je	SHORT $LN19@operator@389
	push	0
	lea	ecx, DWORD PTR __Lock$602789[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jbe	SHORT $LN21@operator@389
	cmp	eax, -1
	jae	SHORT $LN21@operator@389
	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN21@operator@389:
	mov	edi, DWORD PTR [ebx+4]
	neg	edi
	sbb	edi, edi
	not	edi
	lea	ecx, DWORD PTR __Lock$602789[ebp]
	and	edi, ebx
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	edi, edi
	je	SHORT $LN19@operator@389
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, edi
	call	eax
$LN19@operator@389:

; 377  : 
; 378  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 379  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 380  : 				_Myios::fill(), _Val).failed())

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+esi+40]
	mov	ebx, DWORD PTR __Val$[ebp+4]
	push	ebx
	mov	ebx, DWORD PTR __Val$[ebp]
	add	ecx, esi
	mov	cl, BYTE PTR [ecx+48]
	push	ebx
	mov	BYTE PTR $T602803[ebp], cl
	mov	ebx, DWORD PTR $T602803[ebp]
	mov	ecx, DWORD PTR __Nput_fac$129554[ebp]
	mov	edi, DWORD PTR [ecx]
	push	ebx
	add	eax, esi
	push	eax
	push	edx
	mov	BYTE PTR $T602754[ebp], 0
	mov	edx, DWORD PTR $T602754[ebp]
	push	edx
	mov	edx, DWORD PTR [edi+16]
	lea	eax, DWORD PTR $T602755[ebp]
	push	eax
	call	edx
	cmp	BYTE PTR $T602755[ebp], 0
	je	SHORT $LN1@operator@389

; 381  : 				_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4
$LN1@operator@389:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN13@operator@389
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z$0:

; 382  : 			_CATCH_IO_END

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	or	eax, 4
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN42@operator@389
	or	eax, 4
$LN42@operator@389:
	push	1
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN79@operator@389
	ret	0
$LN79@operator@389:
	mov	esi, DWORD PTR _this$[ebp]
$LN13@operator@389:

; 383  : 			}
; 384  : 
; 385  : 		_Myios::setstate(_State);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __State$[ebp]
	add	ecx, esi
	test	edx, edx
	je	SHORT $LN71@operator@389
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN73@operator@389
	or	eax, 4
$LN73@operator@389:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN71@operator@389:

; 386  : 		return (*this);

	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, esi

; 387  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z$3:
	lea	ecx, DWORD PTR $T602751[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$11
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
_TEXT	SEGMENT
$T602901 = -48						; size = 8
$T602900 = -48						; size = 8
__Ok$ = -40						; size = 8
__Nput_fac$129345 = -32					; size = 4
$T602949 = -28						; size = 1
__Lock$602933 = -28					; size = 4
$T602897 = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Val$ = 12						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT

; 289  : 		{	// insert an unsigned int

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR _this$[ebp]

; 290  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 291  : 		const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __State$[ebp], edi
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], edi

; 292  : 
; 293  : 		if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	je	$LN13@operator@390

; 294  : 			{	// state okay, use facet to insert
; 295  : 			const _Nput& _Nput_fac = _USE(ios_base::getloc(), _Nput);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T602897[ebp]
	push	eax
	add	ecx, esi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	ebx, DWORD PTR $T602897[ebp]
	mov	DWORD PTR __Nput_fac$129345[ebp], eax
	test	ebx, ebx
	je	SHORT $LN19@operator@390
	push	0
	lea	ecx, DWORD PTR __Lock$602933[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jbe	SHORT $LN21@operator@390
	cmp	eax, -1
	jae	SHORT $LN21@operator@390
	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN21@operator@390:
	mov	edi, DWORD PTR [ebx+4]
	neg	edi
	sbb	edi, edi
	not	edi
	lea	ecx, DWORD PTR __Lock$602933[ebp]
	and	edi, ebx
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	edi, edi
	je	SHORT $LN19@operator@390
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, edi
	call	eax
$LN19@operator@390:

; 296  : 
; 297  : 			_TRY_IO_BEGIN
; 298  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 299  : 				_Myios::fill(), (unsigned long)_Val).failed())

	mov	ebx, DWORD PTR __Val$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+esi+40]
	add	ecx, esi
	push	ebx
	mov	BYTE PTR $T602900[ebp], 0
	mov	cl, BYTE PTR [ecx+48]
	mov	BYTE PTR $T602949[ebp], cl
	mov	ebx, DWORD PTR $T602949[ebp]
	mov	ecx, DWORD PTR __Nput_fac$129345[ebp]
	mov	edi, DWORD PTR [ecx]
	push	ebx
	add	eax, esi
	push	eax
	push	edx
	mov	edx, DWORD PTR $T602900[ebp]
	push	edx
	mov	edx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR $T602901[ebp]
	push	eax
	call	edx
	cmp	BYTE PTR $T602901[ebp], 0
	je	SHORT $LN1@operator@390

; 300  : 				_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4
$LN1@operator@390:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN13@operator@390
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$0:

; 301  : 			_CATCH_IO_END

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	or	eax, 4
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN42@operator@390
	or	eax, 4
$LN42@operator@390:
	push	1
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN79@operator@390
	ret	0
$LN79@operator@390:
	mov	esi, DWORD PTR _this$[ebp]
$LN13@operator@390:

; 302  : 			}
; 303  : 
; 304  : 		_Myios::setstate(_State);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __State$[ebp]
	add	ecx, esi
	test	edx, edx
	je	SHORT $LN71@operator@390
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN73@operator@390
	or	eax, 4
$LN73@operator@390:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN71@operator@390:

; 305  : 		return (*this);

	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, esi

; 306  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$3:
	lea	ecx, DWORD PTR $T602897[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtpy
;	COMDAT ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z PROC ; std::endl, COMDAT

; 967  : 	{	// insert newline and flush byte stream

	push	ecx
	push	esi

; 968  : 	_Ostr.put('\n');

	mov	esi, DWORD PTR __Ostr$[esp+4]
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put

; 969  : 	_Ostr.flush();

	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 970  : 	return (_Ostr);

	mov	eax, esi

; 971  : 	}

	pop	esi
	pop	ecx
	ret	0
?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ENDP ; std::endl
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$9
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$10
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -32						; size = 8
__Pad$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 741  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 742  : 	typedef char _Elem;
; 743  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 744  : 	ios_base::iostate _State = ios_base::goodbit;
; 745  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

	mov	eax, DWORD PTR __Val$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __State$[ebp], ebx
	lea	edx, DWORD PTR [eax+1]
$LL144@operator@404:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL144@operator@404

; 746  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
; 747  : 		? 0 : _Ostr.width() - _Count;

	mov	esi, DWORD PTR __Ostr$[ebp]
	sub	eax, edx
	mov	edi, eax
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi+24]
	cmp	eax, ebx
	jle	SHORT $LN17@operator@404
	cmp	eax, edi
	jle	SHORT $LN17@operator@404
	sub	eax, edi
	mov	ebx, eax
	mov	DWORD PTR __Pad$[ebp], eax
	jmp	SHORT $LN18@operator@404
$LN17@operator@404:
	mov	DWORD PTR __Pad$[ebp], ebx
$LN18@operator@404:

; 748  : 	const typename _Myos::sentry _Ok(_Ostr);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 749  : 
; 750  : 	if (!_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	jne	SHORT $LN14@operator@404

; 751  : 		_State |= ios_base::badbit;

	mov	edx, 4

; 752  : 	else

	jmp	$LN22@operator@404
$LN14@operator@404:

; 753  : 		{	// state okay, insert
; 754  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 755  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN142@operator@404
$LL10@operator@404:

; 756  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	ebx, ebx
	jle	SHORT $LN8@operator@404

; 757  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 758  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	mov	al, BYTE PTR [edx+esi+48]
	lea	ecx, DWORD PTR [edx+esi]
	mov	ecx, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN42@operator@404
	mov	edx, DWORD PTR [ecx+52]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN42@operator@404
	dec	DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [ecx]
	lea	ebx, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], ebx
	mov	ebx, DWORD PTR __Pad$[ebp]
	mov	BYTE PTR [edx], al
	movzx	eax, al
	jmp	SHORT $LN43@operator@404
$LN42@operator@404:
	mov	edx, DWORD PTR [ecx]
	movzx	eax, al
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN43@operator@404:
	cmp	eax, -1
	jne	$LN9@operator@404

; 759  : 					{	// insertion failed, quit
; 760  : 					_State |= ios_base::badbit;

	or	DWORD PTR __State$[ebp], 4
$LN8@operator@404:

; 761  : 					break;
; 762  : 					}
; 763  : 
; 764  : 		if (_State == ios_base::goodbit
; 765  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN2@operator@404
$LN142@operator@404:
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+esi+40]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+32]
	push	edi
	push	DWORD PTR __Val$[ebp]
	call	edx
	cmp	eax, edi
	je	$LL143@operator@404

; 766  : 			_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4
$LN2@operator@404:

; 775  : 					}
; 776  : 		_Ostr.width(0);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	xor	ecx, ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], ecx
$LN151@operator@404:
	mov	edx, DWORD PTR __State$[ebp]
$LN22@operator@404:

; 778  : 		}
; 779  : 
; 780  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	test	edx, edx
	je	SHORT $LN122@operator@404
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN124@operator@404
	or	eax, 4
$LN124@operator@404:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN122@operator@404:

; 781  : 	return (_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 3
	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN126@operator@404
	mov	ecx, DWORD PTR __Ok$[ebp]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN126@operator@404:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR __Ok$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN146@operator@404
	lea	ecx, DWORD PTR [eax+4]
	call	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
$LN146@operator@404:
	mov	eax, esi

; 782  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@operator@404:

; 756  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	dec	ebx
	mov	DWORD PTR __Pad$[ebp], ebx
	jmp	$LL10@operator@404
	npad	7
$LL143@operator@404:

; 767  : 
; 768  : 		if (_State == ios_base::goodbit)
; 769  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	ebx, ebx
	jle	$LN2@operator@404

; 770  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 771  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+esi+48]
	add	ecx, esi
	mov	ecx, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN68@operator@404
	mov	edx, DWORD PTR [ecx+52]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN68@operator@404
	dec	DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [ecx]
	lea	edi, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], edi
	mov	BYTE PTR [edx], al
	movzx	eax, al
	jmp	SHORT $LN69@operator@404
$LN68@operator@404:
	mov	edx, DWORD PTR [ecx]
	movzx	eax, al
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN69@operator@404:
	cmp	eax, -1
	jne	SHORT $LN3@operator@404

; 772  : 					{	// insertion failed, quit
; 773  : 					_State |= ios_base::badbit;

	or	DWORD PTR __State$[ebp], 4

; 774  : 					break;

	jmp	$LN2@operator@404
$LN3@operator@404:

; 767  : 
; 768  : 		if (_State == ios_base::goodbit)
; 769  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	dec	ebx
	jmp	SHORT $LL143@operator@404
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 777  : 		_CATCH_IO_(_Ostr)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	or	eax, 4
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN93@operator@404
	or	eax, 4
$LN93@operator@404:
	push	1
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN23@operator@404
	ret	0
$LN23@operator@404:
	mov	esi, DWORD PTR __Ostr$[ebp]
	jmp	$LN151@operator@404
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$9:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
PUBLIC	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABW4AddressMappingScheme@Address@0@@Z ; DRAMsimII::operator<<
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.cpp
_TEXT	SEGMENT
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABW4AddressMappingScheme@Address@0@@Z PROC ; DRAMsimII::operator<<
; _os$ = esi
; $T622269 = eax

; 806  : {	

	push	ecx

; 807  : 	switch (mappingScheme)

	jmp	DWORD PTR $LN20@operator@405[eax*4]
$LN9@operator@405:

; 808  : 	{
; 809  : 	case Address::BURGER_BASE_MAP:
; 810  : 		os << "BBM";

	push	OFFSET ??_C@_03NJGPNILD@BBM?$AA@

; 832  : 		break;
; 833  : 	default:
; 834  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 835  : 		break;
; 836  : 	}
; 837  : 	return os;

	mov	eax, esi
	pop	ecx

; 838  : }

	ret	0
$LN8@operator@405:

; 811  : 		break;
; 812  : 	case Address::SDRAM_HIPERF_MAP:
; 813  : 		os << "SDHIPF";

	push	OFFSET ??_C@_06KAGHFJNN@SDHIPF?$AA@

; 832  : 		break;
; 833  : 	default:
; 834  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 835  : 		break;
; 836  : 	}
; 837  : 	return os;

	mov	eax, esi
	pop	ecx

; 838  : }

	ret	0
$LN7@operator@405:

; 814  : 		break;
; 815  : 	case Address::SDRAM_BASE_MAP:
; 816  : 		os << "SDBAS";

	push	OFFSET ??_C@_05LIIHKDFK@SDBAS?$AA@

; 832  : 		break;
; 833  : 	default:
; 834  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 835  : 		break;
; 836  : 	}
; 837  : 	return os;

	mov	eax, esi
	pop	ecx

; 838  : }

	ret	0
$LN6@operator@405:

; 817  : 		break;
; 818  : 	case Address::CLOSE_PAGE_BASELINE:
; 819  : 		os << "CPBAS";

	push	OFFSET ??_C@_05CODBJAID@CPBAS?$AA@

; 832  : 		break;
; 833  : 	default:
; 834  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 835  : 		break;
; 836  : 	}
; 837  : 	return os;

	mov	eax, esi
	pop	ecx

; 838  : }

	ret	0
$LN5@operator@405:

; 820  : 		break;
; 821  : 	case Address::CLOSE_PAGE_BASELINE_OPT:
; 822  : 		os << "CPBOPT";

	push	OFFSET ??_C@_06EINBLCDA@CPBOPT?$AA@

; 832  : 		break;
; 833  : 	default:
; 834  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 835  : 		break;
; 836  : 	}
; 837  : 	return os;

	mov	eax, esi
	pop	ecx

; 838  : }

	ret	0
$LN4@operator@405:

; 823  : 		break;
; 824  : 	case Address::INTEL845G_MAP:
; 825  : 		os << "845G";

	push	OFFSET ??_C@_04EKFNGKOK@845G?$AA@

; 832  : 		break;
; 833  : 	default:
; 834  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 835  : 		break;
; 836  : 	}
; 837  : 	return os;

	mov	eax, esi
	pop	ecx

; 838  : }

	ret	0
$LN3@operator@405:

; 826  : 		break;
; 827  : 	case Address::CLOSE_PAGE_LOW_LOCALITY:
; 828  : 		os << "LOLOC";

	push	OFFSET ??_C@_05JNFEGKGN@LOLOC?$AA@

; 832  : 		break;
; 833  : 	default:
; 834  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 835  : 		break;
; 836  : 	}
; 837  : 	return os;

	mov	eax, esi
	pop	ecx

; 838  : }

	ret	0
$LN2@operator@405:

; 829  : 		break;
; 830  : 	case Address::CLOSE_PAGE_HIGH_LOCALITY:
; 831  : 		os << "HILOC";

	push	OFFSET ??_C@_05IJIFNNNL@HILOC?$AA@

; 832  : 		break;
; 833  : 	default:
; 834  : 		os << "UNKWN";

	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 835  : 		break;
; 836  : 	}
; 837  : 	return os;

	mov	eax, esi
	pop	ecx

; 838  : }

	ret	0
$LN20@operator@405:
	DD	$LN6@operator@405
	DD	$LN7@operator@405
	DD	$LN8@operator@405
	DD	$LN5@operator@405
	DD	$LN3@operator@405
	DD	$LN2@operator@405
	DD	$LN4@operator@405
	DD	$LN9@operator@405
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABW4AddressMappingScheme@Address@0@@Z ENDP ; DRAMsimII::operator<<
_TEXT	ENDS
PUBLIC	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVAddress@0@@Z ; DRAMsimII::operator<<
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T622277 = -32						; size = 8
$T622276 = -24						; size = 8
$T622275 = -16						; size = 8
$T622274 = -8						; size = 8
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVAddress@0@@Z PROC ; DRAMsimII::operator<<
; _os$ = eax
; _thisAddress$ = esi

; 797  : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	edi

; 798  : 	return os << "addr[0x" << hex << thisAddress.physicalAddress <<
; 799  : 		"] chan[" << setbase(16) << thisAddress.channel << "] rank[" <<
; 800  : 		thisAddress.rank << "] bank[" << setbase(16) << thisAddress.bank <<
; 801  : 		"] row[" << setbase(16) << thisAddress.row << "] col[" <<
; 802  : 		setbase(16) << thisAddress.column << "]";

	push	OFFSET ??_C@_07DGJDIIGL@addr?$FL0x?$AA@
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN6@operator@406
$LN5@operator@406:
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, edi
$LN6@operator@406:
	mov	edx, DWORD PTR [eax+16]
	and	edx, -1537				; fffff9ffH
	or	edx, 2048				; 00000800H
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T622277[esp+40]
	push	16					; 00000010H
	push	eax
	call	?setbase@std@@YA?AU?$_Smanip@H@1@H@Z	; std::setbase
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+8]
	add	esp, 8
	push	OFFSET ??_C@_07CEPNEMLG@?$FN?5chan?$FL?$AA@
	push	ecx
	push	edx
	push	edi
	mov	ebx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN14@operator@406
$LN13@operator@406:
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	add	eax, edi
$LN14@operator@406:
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	eax
	call	edx
	lea	eax, DWORD PTR $T622276[esp+48]
	push	16					; 00000010H
	push	eax
	call	?setbase@std@@YA?AU?$_Smanip@H@1@H@Z	; std::setbase
	mov	ecx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi+16]
	add	esp, 16					; 00000010H
	push	OFFSET ??_C@_07LMBJCPNP@?$FN?5bank?$FL?$AA@
	push	ecx
	push	OFFSET ??_C@_07LPMPCNEE@?$FN?5rank?$FL?$AA@
	push	edx
	push	edi
	mov	ebx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN18@operator@406
$LN17@operator@406:
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	add	eax, edi
$LN18@operator@406:
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	eax
	call	edx
	lea	eax, DWORD PTR $T622275[esp+48]
	push	16					; 00000010H
	push	eax
	call	?setbase@std@@YA?AU?$_Smanip@H@1@H@Z	; std::setbase
	mov	ecx, DWORD PTR [esi+24]
	add	esp, 16					; 00000010H
	push	OFFSET ??_C@_06MPJLADHA@?$FN?5row?$FL?$AA@
	push	ecx
	push	edi
	mov	ebx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN22@operator@406
$LN21@operator@406:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, edi
$LN22@operator@406:
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	eax
	call	edx
	lea	eax, DWORD PTR $T622274[esp+48]
	push	16					; 00000010H
	push	eax
	call	?setbase@std@@YA?AU?$_Smanip@H@1@H@Z	; std::setbase
	mov	ecx, DWORD PTR [esi+28]
	add	esp, 16					; 00000010H
	push	OFFSET ??_C@_06ICGIPBND@?$FN?5col?$FL?$AA@
	push	ecx
	push	edi
	mov	ebx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN26@operator@406
$LN25@operator@406:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, edi
$LN26@operator@406:
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	eax
	call	edx
	mov	eax, DWORD PTR [esi+32]
	add	esp, 8
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	push	eax
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	pop	edi
	pop	ebx

; 803  : }

	add	esp, 32					; 00000020H
	ret	0
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVAddress@0@@Z ENDP ; DRAMsimII::operator<<
_TEXT	ENDS
PUBLIC	?addressTranslation@Address@DRAMsimII@@IAE_NXZ	; DRAMsimII::Address::addressTranslation
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tempAddress$ = -20					; size = 8
_buffer$129166 = -12					; size = 8
_buffer$129161 = -12					; size = 8
_buffer$129157 = -12					; size = 8
_buffer$129153 = -12					; size = 8
_buffer$129147 = -12					; size = 8
_buffer$129143 = -12					; size = 8
_buffer$129139 = -12					; size = 8
_buffer$129135 = -12					; size = 8
?addressTranslation@Address@DRAMsimII@@IAE_NXZ PROC	; DRAMsimII::Address::addressTranslation
; _this$ = edi

; 283  : {

	sub	esp, 24					; 00000018H
	push	ebx

; 284  : 
; 285  : 	if (!physicalAddress)

	mov	ebx, DWORD PTR [edi+8]
	push	ebp
	push	esi
	mov	esi, DWORD PTR [edi+12]
	mov	eax, ebx
	or	eax, esi

; 286  : 		return false;

	je	$LN70@addressTra

; 287  : 
; 288  : 	// strip away the byte address portion
; 289  : 	PhysicalAddress tempAddress = physicalAddress >> columnSizeDepth;

	mov	ecx, DWORD PTR ?columnSizeDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnSizeDepth
	mov	eax, ebx
	mov	edx, esi
	call	__aullshr

; 290  : 
; 291  : 
; 292  : 	switch (mappingScheme)

	mov	ecx, DWORD PTR ?mappingScheme@Address@DRAMsimII@@1W4AddressMappingScheme@12@A ; DRAMsimII::Address::mappingScheme
	mov	DWORD PTR _tempAddress$[esp+36], eax
	mov	DWORD PTR _tempAddress$[esp+40], edx
	cmp	ecx, 7
	ja	$LN2@addressTra
	jmp	DWORD PTR $LN78@addressTra[ecx*4]
$LN10@addressTra:

; 293  : 	{
; 294  : 	case SDRAM_HIPERF_MAP:
; 295  : 		/*
; 296  : 		*               High performance SDRAM Mapping scheme
; 297  : 		*                                                                    5
; 298  : 		* |<-------------------->| |<->| |<->|  |<--------------->| |<---->| |<---------------->|  |<------------------->|
; 299  : 		*                row id    rank  bank       col_id(high)     chan_id   col_id(low)        	column size
; 300  : 		*                							intlog2(cacheline_size)	intlog2(channel_width)
; 301  : 		*									- intlog2(channel_width)	
; 302  : 		*  Rationale is as follows: From LSB to MSB
; 303  : 		*  min column size is the channel width, and individual byes within that "unit" is not addressable, so strip it out and throw it away.
; 304  : 		*  Then strip out a few bits of phys_addr address for the low order bits of col_id.  We basically want consecutive cachelines to
; 305  : 		*  map to different channels.
; 306  : 		*  Then strip out the bits for channel id.
; 307  : 		*  Then strip out the bits for the high order bits of the column id.
; 308  : 		*  Then strip out the bank_id.
; 309  : 		*  Then strip out the rank_id.
; 310  : 		*  What remains must be the row_id
; 311  : 		*
; 312  : 		*  As applied to system (1 dram channel, 64 bit wide. 4 ranks of 256 Mbit chips, each x16. 512 MB system)
; 313  : 		*
; 314  : 		*    31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
; 315  : 		*             |<------------------------------->| |<->| |<->|  |<------------------------>|  |<--->|
; 316  : 		*                       row id                    rank  bank       Column id                  (8B wide)
; 317  : 		*                                                  id    id        2KB * 4 / 8B               Byte Addr
; 318  : 		*
; 319  : 		*  As applied to system (2 dram channel, 64 bit wide each. 1 GB system)
; 320  : 		*    31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
; 321  : 		*          |<------------------------------->| |<->| |<->| |<---------------->|  ^  |<--->|  |<--->|
; 322  : 		*                    row id                    rank  bank      Column id high   chan col_id  (8B wide)
; 323  : 		*                                               id    id        2KB * 4 / 8B     id    low    Byte Addr
; 324  : 		*
; 325  : 		*  As applied to system (1 dram channel, 128 bit wide. 1 GB system)
; 326  : 		*    31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
; 327  : 		*          |<------------------------------->| |<->| |<->| |<------------------------->|  |<------>|
; 328  : 		*                       row id                  rank  bank       Column id                (16B wide)
; 329  : 		*                                               id    id        2KB * 4 / 8B               Byte Addr
; 330  : 		*
; 331  : 		*  As applied to system (2 dram channel, 128 bit wide each. 2 GB system)
; 332  : 		*    31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
; 333  : 		*       |<------------------------------->| |<->| |<->| |<------------------->|  ^  |<>|  |<------>|
; 334  : 		*                    row id                 rank  bank      Column id high     chan  col  (16B wide)
; 335  : 		*                                            id    id        2KB * 4 / 8B       id   idlo  Byte Addr
; 336  : 		*
; 337  : 		*/
; 338  : 		{
; 339  : 			PhysicalAddress buffer = tempAddress;				
; 340  : 			tempAddress >>= columnLowAddressDepth;

	movq	xmm0, QWORD PTR _tempAddress$[esp+36]
	movd	xmm1, DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2

; 341  : 			unsigned columnLow = tempAddress << columnLowAddressDepth ^ buffer;     	

	movq	xmm1, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0

; 342  : 
; 343  : 			buffer = tempAddress;				

	mov	ecx, DWORD PTR _tempAddress$[esp+40]
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 344  : 			tempAddress >>= channelAddressDepth;

	movd	xmm1, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA
	mov	DWORD PTR _buffer$129135[esp+40], edx
	movd	edx, xmm2
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2
	mov	DWORD PTR _buffer$129135[esp+40], ecx
	xor	edx, eax
	mov	eax, DWORD PTR _tempAddress$[esp+36]

; 345  : 			channel = (tempAddress << channelAddressDepth) ^ buffer;     	

	movq	xmm1, xmm1
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 346  : 
; 347  : 			buffer = tempAddress;				
; 348  : 			tempAddress >>= columnHighAddressDepth;

	movd	xmm1, DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA
	movd	ecx, xmm2
	xor	ecx, eax
	movq	xmm2, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	psrlq	xmm0, xmm2
	mov	DWORD PTR [edi+16], ecx
	mov	ecx, DWORD PTR _tempAddress$[esp+40]

; 349  : 			unsigned columnHigh = (tempAddress << columnHighAddressDepth) ^ buffer;

	movq	xmm1, xmm1
	mov	DWORD PTR _buffer$129135[esp+40], ecx

; 350  : 
; 351  : 			column = (columnHigh << columnLowAddressDepth) | columnLow;

	mov	ecx, DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnLowAddressDepth
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 352  : 
; 353  : 			buffer = tempAddress;			
; 354  : 			tempAddress >>= bankAddressDepth;

	movd	xmm1, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA
	movd	esi, xmm2
	xor	esi, eax
	shl	esi, cl
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2

; 355  : 			bank = (tempAddress << bankAddressDepth) ^ buffer;     	

	movq	xmm1, xmm1
	or	esi, edx
	mov	edx, DWORD PTR _tempAddress$[esp+40]
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 356  : 
; 357  : 			buffer = tempAddress;			
; 358  : 			tempAddress >>= rankAddressDepth;

	movd	xmm1, DWORD PTR ?rankAddressDepth@Address@DRAMsimII@@1IA
	movd	ecx, xmm2
	xor	ecx, eax
	movq	xmm2, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	psrlq	xmm0, xmm2
	mov	DWORD PTR [edi+24], ecx

; 359  : 			rank = (tempAddress << rankAddressDepth) ^ buffer;     	

	movq	xmm2, xmm0
	movq	xmm1, xmm1
	psllq	xmm2, xmm1
	movd	ecx, xmm2
	xor	ecx, eax
	mov	DWORD PTR [edi+32], esi
	mov	DWORD PTR [edi+20], ecx

; 360  : 
; 361  : 			buffer = tempAddress;			
; 362  : 			tempAddress >>= rowAddressDepth;
; 363  : 			row = (tempAddress << rowAddressDepth) ^ buffer;	
; 364  : 		}
; 365  : 		break;

	jmp	$LN72@addressTra
$LN9@addressTra:

; 366  : 
; 367  : 	case SDRAM_BASE_MAP:		
; 368  : 		/*
; 369  : 		*               Basic SDRAM Mapping scheme (As found on user-upgradeable memory systems)
; 370  : 		*                                                                    5
; 371  : 		* |<---->| |<------------------->| |<->|  |<--------------->| |<---->| |<---------------->|  |<------------------->|
; 372  : 		*   rank             row id         bank       col_id(high)   chan_id   col_id(low)        	column size
; 373  : 		*                							intlog2(cacheline_size)	intlog2(channel_width)
; 374  : 		*									- intlog2(channel_width)	
; 375  : 		*  Rationale is as follows: From LSB to MSB
; 376  : 		*  min column size is the channel width, and individual byes within that "unit" is not addressable, so strip it out and throw it away.
; 377  : 		*  Then strip out a few bits of phys_addr address for the low order bits of col_id.  We basically want consecutive cachelines to
; 378  : 		*  map to different channels.
; 379  : 		*  Then strip out the bits for channel id.
; 380  : 		*  Then strip out the bits for the high order bits of the column id.
; 381  : 		*  Then strip out the bank_id.
; 382  : 		*  Then strip out the row_id
; 383  : 		*  What remains must be the rankid
; 384  : 		*
; 385  : 		*  As applied to system (2 dram channel, 64 bit wide each. 1 GB system)
; 386  : 		*    31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
; 387  : 		*          |<->| |<------------------------------->| |<->| |<---------------->|  ^  |<--->|  |<--->|
; 388  : 		*           rank         row id                       bank     Column id high   chan col_id  (8B wide)
; 389  : 		*           id                                        id       2KB * 4 / 8B     id    low    Byte Addr
; 390  : 		*
; 391  : 		*  As applied to system (1 dram channel, 128 bit wide. 1 GB system)
; 392  : 		*    31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
; 393  : 		*          |<->| |<------------------------------->| |<->| |<------------------------->|  |<------>|
; 394  : 		*           rank         row id                       bank     Column id                   (16B wide)
; 395  : 		*           id                                        id       2KB * 4 / 8B     id    low   Byte Addr
; 396  : 		*
; 397  : 		*/
; 398  : 		{
; 399  : 			PhysicalAddress buffer = tempAddress;
; 400  : 			tempAddress >>= columnLowAddressDepth;

	movq	xmm0, QWORD PTR _tempAddress$[esp+36]
	movd	xmm1, DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2

; 401  : 			unsigned columnLow = (tempAddress << columnLowAddressDepth) ^ buffer;

	movq	xmm1, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0

; 402  : 
; 403  : 			buffer = tempAddress;				

	mov	ecx, DWORD PTR _tempAddress$[esp+40]
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 404  : 			tempAddress >>= channelAddressDepth;

	movd	xmm1, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA
	mov	DWORD PTR _buffer$129139[esp+40], edx
	movd	edx, xmm2
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2
	mov	DWORD PTR _buffer$129139[esp+40], ecx
	xor	edx, eax
	mov	eax, DWORD PTR _tempAddress$[esp+36]

; 405  : 			channel = (tempAddress << channelAddressDepth) ^ buffer;     	

	movq	xmm1, xmm1
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 406  : 
; 407  : 			buffer = tempAddress;				
; 408  : 			tempAddress >>= columnHighAddressDepth;

	movd	xmm1, DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA
	movd	ecx, xmm2
	xor	ecx, eax
	movq	xmm2, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	psrlq	xmm0, xmm2
	mov	DWORD PTR [edi+16], ecx
	mov	ecx, DWORD PTR _tempAddress$[esp+40]

; 409  : 			unsigned columnHigh = (tempAddress << columnHighAddressDepth) ^ buffer;     		

	movq	xmm1, xmm1
	mov	DWORD PTR _buffer$129139[esp+40], ecx

; 410  : 
; 411  : 			column = (columnHigh << columnLowAddressDepth) | columnLow;

	mov	ecx, DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnLowAddressDepth
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 412  : 
; 413  : 			buffer = tempAddress;				
; 414  : 			tempAddress >>= bankAddressDepth;

	movd	xmm1, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA
	movd	esi, xmm2
	xor	esi, eax
	shl	esi, cl
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2

; 415  : 			bank = (tempAddress << bankAddressDepth) ^ buffer;     		

	movq	xmm1, xmm1
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 416  : 
; 417  : 			buffer = tempAddress;				
; 418  : 			tempAddress >>= rowAddressDepth;

	movd	xmm1, DWORD PTR ?rowAddressDepth@Address@DRAMsimII@@1IA
	movd	ecx, xmm2
	or	esi, edx
	mov	edx, DWORD PTR _tempAddress$[esp+40]
	xor	ecx, eax
	movq	xmm2, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	psrlq	xmm0, xmm2
	mov	DWORD PTR [edi+24], ecx

; 419  : 			row = (tempAddress << rowAddressDepth) ^ buffer;		

	movq	xmm2, xmm0
	movq	xmm1, xmm1
	psllq	xmm2, xmm1
	movd	ecx, xmm2
	xor	ecx, eax
	mov	DWORD PTR [edi+28], ecx
$LN77@addressTra:

; 420  : 
; 421  : 			buffer = tempAddress;				
; 422  : 			tempAddress >>= rankAddressDepth;

	movd	xmm1, DWORD PTR ?rankAddressDepth@Address@DRAMsimII@@1IA
	mov	DWORD PTR _buffer$129139[esp+40], edx
	mov	edx, DWORD PTR _tempAddress$[esp+40]
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	movq	xmm2, xmm1
	mov	DWORD PTR _buffer$129139[esp+40], edx
	mov	edx, DWORD PTR _tempAddress$[esp+40]
	psrlq	xmm0, xmm2
	movq	QWORD PTR _tempAddress$[esp+36], xmm0

; 423  : 			rank = (tempAddress << rankAddressDepth) ^ buffer;     		

	movq	xmm1, xmm1
	psllq	xmm0, xmm1
	movd	ecx, xmm0
	xor	ecx, eax
	mov	DWORD PTR [edi+32], esi
	mov	DWORD PTR [edi+20], ecx

; 424  : 		}
; 425  : 		break;

	jmp	$LN73@addressTra
$LN8@addressTra:

; 426  : 
; 427  : 	case CLOSE_PAGE_BASELINE:
; 428  : 		/*
; 429  : 		*               High performance closed page SDRAM Mapping scheme
; 430  : 		*                                                                    5
; 431  : 		* |<------------------>| |<------------>| |<---->|  |<---->| |<---->| |<----------------->| |<------------------->|
; 432  : 		*                row id    col_id(high)     rank      bank     chan      col_id(low)        	column size
; 433  : 		*                							intlog2(cacheline_size)	intlog2(channel_width)
; 434  : 		*									- intlog2(channel_width)	
; 435  : 		*									
; 436  : 		*  Rationale is as follows: From LSB to MSB
; 437  : 		*  min column size is the channel width, and individual byes within that "unit" is not addressable, so strip it out and throw it away.
; 438  : 		*  Then strip out a few bits of phys_addr address for the low order bits of col_id.  We basically want consecutive cachelines to
; 439  : 		*  map to different channels.
; 440  : 		*  Then strip out the bits for channel id.
; 441  : 		*  Then strip out the bank_id.
; 442  : 		*  Then strip out the rank_id.
; 443  : 		*  Then strip out the bits for the high order bits of the column id.
; 444  : 		*  What remains must be the row_id
; 445  : 		*
; 446  : 		*  As applied to system (1 dram channel, 64 bit wide each. 2 GB system)
; 447  : 		*    31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
; 448  : 		*       |<------------------------------------->| |<---------------->|  ^  |<--->|  |<--->|  |<--->|
; 449  : 		*                    row id                         Column id high     rank  bank    col_id  (8B wide)
; 450  : 		*                                                   1KB     / 8B        id    id      low    Byte Addr
; 451  : 		*/		
; 452  : 		{
; 453  : 			PhysicalAddress buffer = tempAddress;
; 454  : 			tempAddress >>= columnLowAddressDepth;

	movq	xmm0, QWORD PTR _tempAddress$[esp+36]
	movd	xmm1, DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2

; 455  : 
; 456  : 			// strip out the column low address
; 457  : 			unsigned columnLow = buffer ^ (tempAddress << columnLowAddressDepth);

	movq	xmm1, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0

; 458  : 
; 459  : 			buffer = tempAddress;				/* save away original address */

	mov	ecx, DWORD PTR _tempAddress$[esp+40]
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 460  : 			tempAddress >>= channelAddressDepth;

	movd	xmm1, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA
	mov	DWORD PTR _buffer$129143[esp+40], edx
	movd	edx, xmm2
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2
	mov	DWORD PTR _buffer$129143[esp+40], ecx

; 461  : 			// strip out the channel address
; 462  : 			channel = buffer ^ (tempAddress << channelAddressDepth);

	movq	xmm1, xmm1
	xor	edx, eax
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 463  : 
; 464  : 			buffer = tempAddress;				
; 465  : 			tempAddress >>= bankAddressDepth;

	movd	xmm1, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA
	movd	ecx, xmm2
	xor	ecx, eax
	mov	DWORD PTR [edi+16], ecx
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	ecx, DWORD PTR _tempAddress$[esp+40]
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2
	mov	DWORD PTR _buffer$129143[esp+40], ecx

; 466  : 			// strip out the bank address
; 467  : 			bank = buffer ^ (tempAddress << bankAddressDepth);

	movq	xmm1, xmm1
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 468  : 
; 469  : 			buffer = tempAddress;				
; 470  : 			tempAddress >>= rankAddressDepth;

	movd	xmm1, DWORD PTR ?rankAddressDepth@Address@DRAMsimII@@1IA
	movd	ecx, xmm2
	xor	ecx, eax
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	mov	DWORD PTR [edi+24], ecx
	mov	ecx, DWORD PTR _tempAddress$[esp+40]
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2
	mov	DWORD PTR _buffer$129143[esp+40], ecx

; 471  : 			// strip out the rank address
; 472  : 			rank = buffer ^ (tempAddress << rankAddressDepth);		

	movq	xmm1, xmm1
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 473  : 
; 474  : 			buffer = tempAddress;				
; 475  : 			tempAddress >>= columnHighAddressDepth;

	movd	xmm1, DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA
	movd	ecx, xmm2
	xor	ecx, eax
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	movq	xmm2, xmm1
	mov	DWORD PTR [edi+20], ecx
	mov	ecx, DWORD PTR _tempAddress$[esp+40]
	psrlq	xmm0, xmm2

; 476  : 			// strip out the column hi address
; 477  : 			unsigned columnHigh = buffer ^ (tempAddress << columnHighAddressDepth);

	movq	xmm2, xmm0
	movq	xmm1, xmm1
	psllq	xmm2, xmm1
	mov	DWORD PTR _buffer$129143[esp+40], ecx

; 478  : 
; 479  : 			column = (columnHigh << columnLowAddressDepth) | columnLow;

	mov	ecx, DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnLowAddressDepth
	movd	esi, xmm2
	xor	esi, eax
	shl	esi, cl
	or	esi, edx
	mov	DWORD PTR [edi+32], esi

; 480  : 
; 481  : 			buffer = tempAddress;				
; 482  : 			tempAddress >>= rowAddressDepth;
; 483  : 			// strip out the row address
; 484  : 			row = buffer ^ (tempAddress << rowAddressDepth);
; 485  : 		}
; 486  : 		break;

	jmp	$LN74@addressTra
$LN7@addressTra:

; 487  : 
; 488  : 	case CLOSE_PAGE_BASELINE_OPT:
; 489  : 		{
; 490  : 			/*
; 491  : 			*               High performance closed page SDRAM Mapping scheme
; 492  : 			*                                                                    5
; 493  : 			* |<----------->||<------------>||<------>||<----->||<---->||<---->||<----------------->||<------------------->|
; 494  : 			*     row_high     col_id(high)     rank     row_lo   bank    chan       col_id(low)           column size
; 495  : 			*
; 496  : 			*                							intlog2(cacheline_size)	intlog2(channel_width)
; 497  : 			*									- intlog2(channel_width)	
; 498  : 			*									
; 499  : 			*  Rationale is as follows: From LSB to MSB
; 500  : 			*  min column size is the channel width, and individual byes within that "unit" is not addressable, so strip it out and throw it away.
; 501  : 			*  Then strip out a few bits of phys_addr address for the low order bits of col_id.  We basically want consecutive cachelines to
; 502  : 			*  map to different channels.
; 503  : 			*  Then strip out the bits for channel id.
; 504  : 			*  Then strip out the bank_id.
; 505  : 			*  Then strip out the rank_id.
; 506  : 			*  Then strip out the bits for the high order bits of the column id.
; 507  : 			*  What remains must be the row_id
; 508  : 			*
; 509  : 			*  As applied to system (1 dram channel, 64 bit wide each. 2 GB system)
; 510  : 			*    31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
; 511  : 			*       |<------------------------------------->| |<---------------->|  ^  |<--->|  |<--->|  |<--->|
; 512  : 			*                    row id                         Column id high     rank  bank    col_id  (8B wide)
; 513  : 			*                                                   1KB     / 8B        id    id      low    Byte Addr
; 514  : 			*/		
; 515  : 			PhysicalAddress buffer = tempAddress;
; 516  : 			tempAddress >>= columnLowAddressDepth;

	movq	xmm0, QWORD PTR _tempAddress$[esp+36]
	movd	xmm1, DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2

; 517  : 
; 518  : 			// strip out the column low address
; 519  : 			unsigned columnLow = buffer ^ (tempAddress << columnLowAddressDepth);

	movq	xmm1, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0

; 520  : 
; 521  : 			buffer = tempAddress;			

	mov	ecx, DWORD PTR _tempAddress$[esp+40]
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 522  : 			tempAddress >>= channelAddressDepth;

	movd	xmm1, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA
	mov	DWORD PTR _buffer$129147[esp+40], edx
	movd	edx, xmm2
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2
	xor	edx, eax
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	mov	DWORD PTR _buffer$129147[esp+40], ecx

; 523  : 			// strip out the channel address
; 524  : 			channel = buffer ^ (tempAddress << channelAddressDepth);

	movq	xmm2, xmm0
	movq	xmm1, xmm1
	psllq	xmm2, xmm1

; 525  : 
; 526  : 			buffer = tempAddress;				
; 527  : 			tempAddress >>= bankAddressDepth;

	movd	xmm1, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	movd	ecx, xmm2
	xor	ecx, eax
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	mov	DWORD PTR [edi+16], ecx
	mov	ecx, DWORD PTR _tempAddress$[esp+40]
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	DWORD PTR _buffer$129147[esp+40], ecx

; 528  : 			// strip out the bank address
; 529  : 			bank = buffer ^ (tempAddress << bankAddressDepth);

	movq	xmm1, xmm1
	psllq	xmm0, xmm1

; 530  : 
; 531  : 			buffer = tempAddress;
; 532  : 			tempAddress >>= 3;
; 533  : 			unsigned rowLow = buffer ^ (tempAddress << 3);
; 534  : 
; 535  : 			buffer = tempAddress;				
; 536  : 			tempAddress >>= rankAddressDepth;

	movd	xmm1, DWORD PTR ?rankAddressDepth@Address@DRAMsimII@@1IA
	movd	ecx, xmm0
	xor	ecx, eax
	mov	eax, DWORD PTR _tempAddress$[esp+40]
	mov	DWORD PTR [edi+24], ecx
	mov	ecx, DWORD PTR _tempAddress$[esp+36]

; 537  : 			// strip out the rank address
; 538  : 			rank = buffer ^ (tempAddress << rankAddressDepth);		
; 539  : 
; 540  : 			buffer = tempAddress;				
; 541  : 			tempAddress >>= columnHighAddressDepth;
; 542  : 			// strip out the column hi address
; 543  : 			unsigned columnHigh = buffer ^ (tempAddress << columnHighAddressDepth);
; 544  : 
; 545  : 			column = (columnHigh << columnLowAddressDepth) | columnLow;
; 546  : 
; 547  : 			buffer = tempAddress;				
; 548  : 			tempAddress >>= (rowAddressDepth - 3);

	mov	ebp, DWORD PTR ?rowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::rowAddressDepth
	mov	esi, ecx
	shrd	ecx, eax, 3
	mov	DWORD PTR _buffer$129147[esp+40], eax
	shr	eax, 3
	mov	DWORD PTR _tempAddress$[esp+40], eax
	mov	DWORD PTR _tempAddress$[esp+36], ecx
	movq	xmm0, QWORD PTR _tempAddress$[esp+36]
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2
	mov	DWORD PTR _buffer$129147[esp+40], eax
	movq	xmm2, xmm0
	movq	xmm1, xmm1
	psllq	xmm2, xmm1
	movd	xmm1, DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	movd	eax, xmm2
	xor	eax, ecx
	lea	ebx, DWORD PTR [ecx*8]
	mov	ecx, DWORD PTR _tempAddress$[esp+40]
	mov	DWORD PTR [edi+20], eax
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	movq	xmm2, xmm1
	xor	ebx, esi
	psrlq	xmm0, xmm2
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	DWORD PTR _buffer$129147[esp+40], ecx
	mov	ecx, DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnLowAddressDepth
	movq	xmm1, xmm1
	psllq	xmm0, xmm1
	movd	esi, xmm0
	xor	esi, eax
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	shl	esi, cl
	add	ebp, -3					; fffffffdH
	mov	ecx, ebp
	mov	DWORD PTR _buffer$129147[esp+36], eax
	or	esi, edx
	mov	edx, DWORD PTR _tempAddress$[esp+40]
	mov	DWORD PTR [edi+32], esi
	mov	DWORD PTR _buffer$129147[esp+40], edx
	call	__aullshr

; 549  : 			// strip out the row address
; 550  : 			unsigned rowHigh = buffer ^ (tempAddress << (rowAddressDepth - 3));

	mov	ecx, ebp
	mov	esi, eax
	mov	DWORD PTR _tempAddress$[esp+40], edx
	call	__allshl

; 551  : 
; 552  : 			row = (rowHigh << 3) | rowLow;

	xor	eax, DWORD PTR _buffer$129147[esp+36]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	or	eax, ebx
	mov	DWORD PTR [edi+28], eax

; 553  : 
; 554  : 			break;

	jmp	$LN11@addressTra
$LN6@addressTra:

; 555  : 		}
; 556  : 
; 557  : 	case CLOSE_PAGE_LOW_LOCALITY:
; 558  : 		/*
; 559  : 		*               High performance closed page SDRAM Mapping scheme for streams with low locality
; 560  : 		*                                                                    5
; 561  : 		* |<------------------>| |<------------>| |<---------->|  |<----->| |<----->| |<------>| |<------------------->|
; 562  : 		*       col_id(high)          row           col_id(low)      bank      rank      chan         column size
; 563  : 		*                							intlog2(cacheline_size)	intlog2(channel_width)
; 564  : 		*									- intlog2(channel_width)	
; 565  : 		*/
; 566  : 		{
; 567  : 
; 568  : 			PhysicalAddress buffer = tempAddress;				
; 569  : 			tempAddress >>= channelAddressDepth;

	movq	xmm0, QWORD PTR _tempAddress$[esp+36]
	movd	xmm1, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2
	mov	DWORD PTR _buffer$129153[esp+40], edx

; 570  : 			// strip out the channel address
; 571  : 			channel = buffer ^ (tempAddress << channelAddressDepth);

	movq	xmm1, xmm1
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 572  : 
; 573  : 			buffer = tempAddress;				
; 574  : 			tempAddress >>= rankAddressDepth;

	movd	xmm1, DWORD PTR ?rankAddressDepth@Address@DRAMsimII@@1IA
	movd	edx, xmm2
	xor	edx, eax
	movq	xmm2, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	mov	ecx, DWORD PTR _tempAddress$[esp+40]
	psrlq	xmm0, xmm2
	mov	DWORD PTR [edi+16], edx

; 575  : 			// strip out the rank address
; 576  : 			rank = buffer ^ (tempAddress << rankAddressDepth);	

	movq	xmm1, xmm1
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 577  : 
; 578  : 			buffer = tempAddress;				
; 579  : 			tempAddress >>= bankAddressDepth;

	movd	xmm1, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA
	movd	edx, xmm2
	xor	edx, eax
	movq	xmm2, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	psrlq	xmm0, xmm2
	mov	DWORD PTR [edi+20], edx

; 580  : 			// strip out the bank address
; 581  : 			bank = buffer ^ (tempAddress << bankAddressDepth);

	movq	xmm1, xmm1
	mov	DWORD PTR _buffer$129153[esp+40], ecx
	mov	ecx, DWORD PTR _tempAddress$[esp+40]
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 582  : 
; 583  : 			buffer = tempAddress;				
; 584  : 			tempAddress >>= columnLowAddressDepth;

	movd	xmm1, DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA
	movd	edx, xmm2
	xor	edx, eax
	mov	eax, DWORD PTR _tempAddress$[esp+40]
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2
	mov	DWORD PTR _buffer$129153[esp+40], ecx
	mov	ecx, DWORD PTR _tempAddress$[esp+36]
	mov	DWORD PTR [edi+24], edx

; 585  : 			// strip out the column low address
; 586  : 			unsigned columnLow = buffer ^ (tempAddress << columnLowAddressDepth);

	movq	xmm1, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0

; 587  : 
; 588  : 			buffer = tempAddress;				

	mov	edx, DWORD PTR _tempAddress$[esp+40]
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 589  : 			tempAddress >>= rowAddressDepth;

	movd	xmm1, DWORD PTR ?rowAddressDepth@Address@DRAMsimII@@1IA
	mov	DWORD PTR _buffer$129153[esp+40], eax
	movd	eax, xmm2
	mov	DWORD PTR _buffer$129153[esp+40], edx
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2
	xor	eax, ecx
	mov	ecx, DWORD PTR _tempAddress$[esp+36]

; 590  : 			// strip out the row address
; 591  : 			row = buffer ^ (tempAddress << rowAddressDepth);

	movq	xmm2, xmm0
	movq	xmm1, xmm1
	psllq	xmm2, xmm1

; 592  : 
; 593  : 			buffer = tempAddress;				
; 594  : 			tempAddress >>= columnHighAddressDepth;

	movd	xmm1, DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	movd	edx, xmm2
	xor	edx, ecx
	mov	ecx, DWORD PTR _tempAddress$[esp+36]
	mov	DWORD PTR [edi+28], edx
	mov	edx, DWORD PTR _tempAddress$[esp+40]
	movq	xmm2, xmm1
	mov	DWORD PTR _buffer$129153[esp+40], edx
	psrlq	xmm0, xmm2
	movq	QWORD PTR _tempAddress$[esp+36], xmm0

; 595  : 			// strip out the column hi address
; 596  : 			unsigned columnHigh = buffer ^ (tempAddress << columnHighAddressDepth);

	movq	xmm1, xmm1
	psllq	xmm0, xmm1

; 597  : 
; 598  : 			column = (columnHigh << columnLowAddressDepth) | columnLow;

	movd	edx, xmm0
	xor	edx, ecx
	mov	ecx, DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnLowAddressDepth
	shl	edx, cl
	or	edx, eax
	mov	DWORD PTR [edi+32], edx

; 599  : 		}
; 600  : 		break;

	jmp	$LN75@addressTra
$LN5@addressTra:

; 601  : 
; 602  : 	case CLOSE_PAGE_HIGH_LOCALITY:		
; 603  : 		/*
; 604  : 		*               High performance closed page SDRAM Mapping scheme for streams with low locality
; 605  : 		*                                                                    5
; 606  : 		* |<------->| |<------->| |<----->|  |<-------------->| |<----->| |<--------------->| |<----------------->|
; 607  : 		*    rank        bank       chan         col_id(high)      row        col_id(low)          column size
; 608  : 		*                							intlog2(cacheline_size)	intlog2(channel_width)
; 609  : 		*									- intlog2(channel_width)	
; 610  : 		*/
; 611  : 		{
; 612  : 			PhysicalAddress buffer = tempAddress;				
; 613  : 			tempAddress >>= columnLowAddressDepth;

	movq	xmm0, QWORD PTR _tempAddress$[esp+36]
	movd	xmm1, DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2

; 614  : 			// strip out the column low address
; 615  : 			unsigned columnLow = buffer ^ (tempAddress << columnLowAddressDepth);

	movq	xmm1, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0

; 616  : 
; 617  : 			buffer = tempAddress;				

	mov	ecx, DWORD PTR _tempAddress$[esp+40]
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 618  : 			tempAddress >>= rowAddressDepth;

	movd	xmm1, DWORD PTR ?rowAddressDepth@Address@DRAMsimII@@1IA
	mov	DWORD PTR _buffer$129157[esp+40], edx
	movd	edx, xmm2
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2
	mov	DWORD PTR _buffer$129157[esp+40], ecx
	xor	edx, eax
	mov	eax, DWORD PTR _tempAddress$[esp+36]

; 619  : 			// strip out the row address
; 620  : 			row = buffer ^ (tempAddress << rowAddressDepth);

	movq	xmm1, xmm1
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 621  : 
; 622  : 			buffer = tempAddress;				
; 623  : 			tempAddress >>= columnHighAddressDepth;

	movd	xmm1, DWORD PTR ?columnHighAddressDepth@Address@DRAMsimII@@1IA
	movd	ecx, xmm2
	xor	ecx, eax
	movq	xmm2, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	psrlq	xmm0, xmm2
	mov	DWORD PTR [edi+28], ecx
	mov	ecx, DWORD PTR _tempAddress$[esp+40]

; 624  : 			// strip out the column hi address
; 625  : 			unsigned columnHigh = buffer ^ (tempAddress << columnHighAddressDepth);

	movq	xmm1, xmm1
	mov	DWORD PTR _buffer$129157[esp+40], ecx

; 626  : 
; 627  : 			column = (columnHigh << columnLowAddressDepth) | columnLow;	

	mov	ecx, DWORD PTR ?columnLowAddressDepth@Address@DRAMsimII@@1IA ; DRAMsimII::Address::columnLowAddressDepth
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 628  : 
; 629  : 			buffer = tempAddress;				
; 630  : 			tempAddress >>= channelAddressDepth;

	movd	xmm1, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA
	movd	esi, xmm2
	xor	esi, eax
	shl	esi, cl
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2

; 631  : 			// strip out the channel address
; 632  : 			channel = buffer ^ (tempAddress << channelAddressDepth);

	movq	xmm1, xmm1
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 633  : 
; 634  : 			buffer = tempAddress;				
; 635  : 			tempAddress >>= bankAddressDepth;

	movd	xmm1, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA
	movd	ecx, xmm2
	or	esi, edx
	mov	edx, DWORD PTR _tempAddress$[esp+40]
	xor	ecx, eax
	movq	xmm2, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	psrlq	xmm0, xmm2
	mov	DWORD PTR [edi+16], ecx

; 636  : 			// strip out the bank address
; 637  : 			bank = buffer ^ (tempAddress << bankAddressDepth);

	movq	xmm2, xmm0
	movq	xmm1, xmm1
	psllq	xmm2, xmm1
	movd	ecx, xmm2
	xor	ecx, eax
	mov	DWORD PTR [edi+24], ecx

; 638  : 
; 639  : 			buffer = tempAddress;				
; 640  : 			tempAddress >>= rankAddressDepth;
; 641  : 			// strip out the rank address
; 642  : 			rank = buffer ^ (tempAddress << rankAddressDepth);	
; 643  : 		}
; 644  : 
; 645  : 		break;

	jmp	$LN77@addressTra
$LN4@addressTra:

; 646  : 
; 647  : 	case INTEL845G_MAP:
; 648  : 		{
; 649  : 
; 650  : 			/*  Data comes from Intel's 845G Datasheets.  Table 5-5
; 651  : 			*  DDR SDRAM mapping only.
; 652  : 			*
; 653  : 			*    31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
; 654  : 			*          |<->| |<---------------------------------->| |<->| |<------------------------->|  |<--->|
; 655  : 			*          rank               row id                    bank             Column id           (64 bit wide bus)
; 656  : 			*           id                                           id             2KB * 4 / 8B          Byte addr
; 657  : 			*     row id goes like this: addr[27:15:26-16]
; 658  : 			*     rank_id is addr[29:28]  This means that no device switching unless memory usage goes above 256MB grainularity
; 659  : 			*     No need to remap address with variable number of ranks.  Address just goes up to rank id, if there is more than XXX MB of memory.
; 660  : 			*     Drawback to this scheme is that we're not effectively using banks.
; 661  : 			*/
; 662  : 			//tempAddress = physicalAddress >> 3;
; 663  : 			tempAddress = physicalAddress;

	mov	eax, esi
	mov	ecx, ebx

; 664  : 
; 665  : 			PhysicalAddress buffer = tempAddress;			

	mov	edx, ecx

; 666  : 			tempAddress >>= 10;

	shrd	ecx, eax, 10
	mov	DWORD PTR _buffer$129161[esp+40], eax
	shr	eax, 10					; 0000000aH

; 667  : 			// 11-3
; 668  : 			column = (tempAddress << 10) ^ buffer;

	mov	ebp, ecx
	shl	ebp, 10					; 0000000aH
	xor	ebp, edx

; 669  : 
; 670  : 			buffer = tempAddress;			
; 671  : 			tempAddress >>= 2;

	mov	edx, ecx
	shrd	edx, eax, 2

; 672  : 			// 14:13
; 673  : 			bank = (tempAddress << 2) ^ buffer;		

	add	edx, edx
	shr	eax, 2
	add	edx, edx
	xor	edx, ecx
	mov	DWORD PTR [edi+24], edx

; 674  : 
; 675  : 			buffer = physicalAddress >> 15;

	mov	eax, esi
	mov	edx, ebx
	shrd	edx, eax, 15
	shr	eax, 15					; 0000000fH
	mov	DWORD PTR [edi+32], ebp

; 676  : 			tempAddress =  buffer >> 1;

	mov	ecx, edx
	shrd	ecx, eax, 1
	shr	eax, 1

; 677  : 			// 15
; 678  : 			unsigned bit_15 = (tempAddress << 1) ^ buffer;
; 679  : 
; 680  : 			buffer = physicalAddress >> 16;

	mov	eax, esi
	mov	ebp, ebx
	shrd	ebp, eax, 16
	shr	eax, 16					; 00000010H
	add	ecx, ecx
	xor	ecx, edx

; 681  : 			tempAddress =  buffer >> 11;

	mov	edx, ebp
	shrd	edx, eax, 11
	shr	eax, 11					; 0000000bH

; 682  : 			// 26:16
; 683  : 			unsigned bits_26_to_16 = (tempAddress << 11) ^ buffer;		

	shl	edx, 11					; 0000000bH
	xor	edx, ebp

; 684  : 
; 685  : 			buffer = physicalAddress >> 27;

	mov	eax, esi
	mov	ebp, ebx
	shrd	ebp, eax, 27
	mov	DWORD PTR _buffer$129161[esp+36], ebp
	shr	eax, 27					; 0000001bH

; 686  : 			tempAddress =  buffer >> 1;

	shrd	ebp, eax, 1

; 687  : 			// 27
; 688  : 			unsigned bit_27 = (tempAddress << 1) ^ buffer;			
; 689  : 
; 690  : 			row = (bit_27 << 13) | (bit_15 << 12) | bits_26_to_16;

	add	ebp, ebp
	xor	ebp, DWORD PTR _buffer$129161[esp+36]

; 691  : 
; 692  : 			buffer = physicalAddress >> 28;

	shrd	ebx, esi, 28
	shr	esi, 28					; 0000001cH
	shr	eax, 1
	mov	eax, esi
	add	ebp, ebp

; 693  : 			tempAddress = buffer >> 2;

	mov	esi, ebx
	shrd	esi, eax, 2
	or	ebp, ecx
	shr	eax, 2
	shl	ebp, 12					; 0000000cH
	mov	DWORD PTR _tempAddress$[esp+40], eax
	or	ebp, edx

; 694  : 			// 29:28
; 695  : 			rank = (tempAddress << 2) ^ buffer;

	lea	eax, DWORD PTR [esi*4]
	xor	eax, ebx
	mov	DWORD PTR [edi+28], ebp
	mov	DWORD PTR [edi+20], eax

; 696  : 
; 697  : 			// Intel 845G has only a single channel dram controller
; 698  : 			channel = 0;				

	mov	DWORD PTR [edi+16], 0

; 699  : 
; 700  : 		}
; 701  : 		break;

	jmp	$LN11@addressTra
$LN3@addressTra:

; 702  : 
; 703  : 	case BURGER_BASE_MAP:		// Good for only Rambus memory really
; 704  : 
; 705  : 		// BURGER BASE :
; 706  : 		// |<-------------------------------->|<------>|<------>|<---------------->|<----------------->|<----------->|
; 707  : 		//                          row id     bank id   Rank id   Column id         Channel id          Byte Address
; 708  : 		//                                                         DRAM page size/   intlog2(chan. count)   within packet
; 709  : 		//                                                         Bus Width         used if chan. > 1
; 710  : 		//
; 711  : 		//               As applied to system (1 chan) using 256 Mbit RDRAM chips:
; 712  : 		//               512 rows X 32 banks X 128 columns X 16 bytes per column.
; 713  : 		//		 16 ranks gets us to 512 MByte.	
; 714  : 		//
; 715  : 		//    31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
; 716  : 		//             |<---------------------->| |<---------->| |<------->| |<---------------->|  |<------>|
; 717  : 		//                      row id                 bank         rank          Col id            16 byte
; 718  : 		//                      (512 rows)              id           id           2KB/16B            packet
; 719  : 		{
; 720  : 			PhysicalAddress buffer = tempAddress;				
; 721  : 			tempAddress >>= channelAddressDepth;

	movq	xmm0, QWORD PTR _tempAddress$[esp+36]
	movd	xmm1, DWORD PTR ?channelAddressDepth@Address@DRAMsimII@@1IA
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2

; 722  : 			channel = (tempAddress << channelAddressDepth) ^ buffer;     	

	movq	xmm1, xmm1
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 723  : 
; 724  : 			buffer = tempAddress;				
; 725  : 			tempAddress >>= columnAddressDepth;

	movd	xmm1, DWORD PTR ?columnAddressDepth@Address@DRAMsimII@@1IA
	movd	ecx, xmm2
	xor	ecx, eax
	movq	xmm2, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	psrlq	xmm0, xmm2
	mov	DWORD PTR [edi+16], ecx

; 726  : 			column = (tempAddress << columnAddressDepth) ^ buffer;     	

	movq	xmm1, xmm1
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 727  : 
; 728  : 			buffer = tempAddress;				
; 729  : 			tempAddress >>= rankAddressDepth;

	movd	xmm1, DWORD PTR ?rankAddressDepth@Address@DRAMsimII@@1IA
	movd	ecx, xmm2
	xor	ecx, eax
	mov	DWORD PTR _buffer$129166[esp+40], edx
	mov	edx, DWORD PTR _tempAddress$[esp+40]
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2
	mov	DWORD PTR [edi+32], ecx

; 730  : 			rank = (tempAddress << rankAddressDepth) ^ buffer;		

	movq	xmm1, xmm1
	movq	xmm2, xmm0
	psllq	xmm2, xmm1

; 731  : 
; 732  : 			buffer = tempAddress;			
; 733  : 			tempAddress >>= bankAddressDepth;

	movd	xmm1, DWORD PTR ?bankAddressDepth@Address@DRAMsimII@@1IA
	movd	ecx, xmm2
	mov	DWORD PTR _buffer$129166[esp+40], edx
	mov	edx, DWORD PTR _tempAddress$[esp+40]
	xor	ecx, eax
	movq	xmm2, xmm1
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	psrlq	xmm0, xmm2
	mov	DWORD PTR [edi+20], ecx

; 734  : 			bank = (tempAddress << bankAddressDepth) ^ buffer;		

	movq	xmm2, xmm0
	movq	xmm1, xmm1
	psllq	xmm2, xmm1
	movd	ecx, xmm2
	xor	ecx, eax
	mov	DWORD PTR [edi+24], ecx
$LN72@addressTra:
	mov	DWORD PTR _buffer$129166[esp+40], edx
	mov	edx, DWORD PTR _tempAddress$[esp+40]
	mov	DWORD PTR _buffer$129166[esp+40], edx
$LN74@addressTra:

; 737  : 			tempAddress >>= rowAddressDepth;

	movd	xmm1, DWORD PTR ?rowAddressDepth@Address@DRAMsimII@@1IA
	movq	QWORD PTR _tempAddress$[esp+36], xmm0
	mov	eax, DWORD PTR _tempAddress$[esp+36]
	mov	edx, DWORD PTR _tempAddress$[esp+40]
	movq	xmm2, xmm1
	psrlq	xmm0, xmm2
	movq	QWORD PTR _tempAddress$[esp+36], xmm0

; 738  : 			row = (tempAddress << rowAddressDepth) ^ buffer;		

	movq	xmm1, xmm1
	psllq	xmm0, xmm1
	movd	ecx, xmm0
	xor	ecx, eax
	mov	DWORD PTR [edi+28], ecx
$LN73@addressTra:

; 735  : 
; 736  : 			buffer = tempAddress;			

	mov	DWORD PTR _buffer$129166[esp+40], edx
$LN75@addressTra:

; 738  : 			row = (tempAddress << rowAddressDepth) ^ buffer;		

	mov	esi, DWORD PTR _tempAddress$[esp+36]
$LN11@addressTra:

; 749  : 		return false;
; 750  : 		break;
; 751  : 	}
; 752  : 
; 753  : 	// If there is still "stuff" left, the input address is out of range
; 754  : 	if (tempAddress)

	or	esi, DWORD PTR _tempAddress$[esp+40]
	je	$LN1@addressTra

; 755  : 	{
; 756  : 		cerr << "Memory address (" << std::hex << physicalAddress << ") out of range of available physical memory, max(" << highestAddress() << ")" << endl;

	push	OFFSET ??_C@_0BB@FBHDFKBD@Memory?5address?5?$CI?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	je	SHORT $LN60@addressTra
$LN59@addressTra:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
$LN60@addressTra:
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -1537				; fffff9ffH
	or	ecx, 2048				; 00000800H
	push	OFFSET ??_C@_01PKGAHCOL@?$CJ?$AA@
	push	ecx
	mov	DWORD PTR [eax+16], ecx
	call	?highestAddress@Address@DRAMsimII@@SA_KXZ ; DRAMsimII::Address::highestAddress
	push	edx
	mov	edx, DWORD PTR [edi+12]
	push	eax
	mov	eax, DWORD PTR [edi+8]
	push	OFFSET ??_C@_0DC@CJFGPHKC@?$CJ?5out?5of?5range?5of?5available?5phys@
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	xor	al, al

; 761  : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN1@addressTra:

; 757  : 		return false;
; 758  : 	}
; 759  : 
; 760  : 	return true;

	mov	al, 1

; 761  : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN2@addressTra:

; 739  : 
; 740  : 		}
; 741  : 		break;
; 742  : 
; 743  : 		// don't know what this policy is.. Map everything to 0
; 744  : 	default:
; 745  : 		cerr << "Unknown address mapping scheme, mapping chan, rank, bank to zero: ";

	push	OFFSET ??_C@_0ED@OGNDED@Unknown?5address?5mapping?5scheme?0?5@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 746  : 		cerr << mappingScheme;

	mov	eax, DWORD PTR ?mappingScheme@Address@DRAMsimII@@1W4AddressMappingScheme@12@A ; DRAMsimII::Address::mappingScheme
	add	esp, 8
	cmp	eax, 7
	ja	SHORT $LN16@addressTra
	mov	esi, OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABW4AddressMappingScheme@Address@0@@Z ; DRAMsimII::operator<<
	jmp	SHORT $LN25@addressTra
$LN16@addressTra:
	push	OFFSET ??_C@_05LOKBKELC@UNKWN?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
$LN25@addressTra:

; 747  : 		cerr << endl;

	push	10					; 0000000aH
	mov	ecx, OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	eax, DWORD PTR [ecx+4]
	xor	ebx, ebx
	xor	esi, esi
	test	BYTE PTR ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A[eax+8], 6
	jne	SHORT $LN37@addressTra
	mov	eax, DWORD PTR ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A[eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN37@addressTra
	mov	esi, 4
$LN37@addressTra:
	mov	ecx, DWORD PTR ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	cmp	esi, ebx
	je	SHORT $LN53@addressTra
	mov	eax, DWORD PTR [ecx+8]
	or	eax, esi
	cmp	DWORD PTR [ecx+40], ebx
	jne	SHORT $LN55@addressTra
	or	eax, 4
$LN55@addressTra:
	push	ebx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN53@addressTra:

; 748  : 		channel = rank = bank = row = column = 0;				

	mov	DWORD PTR [edi+32], ebx
	mov	DWORD PTR [edi+28], ebx
	mov	DWORD PTR [edi+24], ebx
	mov	DWORD PTR [edi+20], ebx
	mov	DWORD PTR [edi+16], ebx
$LN70@addressTra:

; 761  : }

	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
	npad	1
$LN78@addressTra:
	DD	$LN8@addressTra
	DD	$LN9@addressTra
	DD	$LN10@addressTra
	DD	$LN7@addressTra
	DD	$LN6@addressTra
	DD	$LN5@addressTra
	DD	$LN4@addressTra
	DD	$LN3@addressTra
?addressTranslation@Address@DRAMsimII@@IAE_NXZ ENDP	; DRAMsimII::Address::addressTranslation
_TEXT	ENDS
PUBLIC	??0Address@DRAMsimII@@QAE@_K@Z			; DRAMsimII::Address::Address
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_pA$ = 8						; size = 8
??0Address@DRAMsimII@@QAE@_K@Z PROC			; DRAMsimII::Address::Address
; _this$ = eax

; 66   : {

	mov	ecx, DWORD PTR _pA$[esp-4]
	mov	edx, DWORD PTR _pA$[esp]
	push	edi
	mov	edi, eax
	xor	eax, eax
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+8], ecx
	mov	DWORD PTR [edi+12], edx
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], eax
	mov	DWORD PTR [edi+24], eax
	mov	DWORD PTR [edi+28], eax
	mov	DWORD PTR [edi+32], eax

; 67   : 	bool result = addressTranslation();

	call	?addressTranslation@Address@DRAMsimII@@IAE_NXZ ; DRAMsimII::Address::addressTranslation

; 68   : 
; 69   : #ifdef DEBUG
; 70   : 	unsigned oldCh = channel, oldRk = rank, oldBk = bank, oldRow = row, oldCol = column;
; 71   : 	reverseAddressTranslation();
; 72   : 	assert(oldCh == channel && oldRk == rank && oldBk == bank && oldRow == row && oldCol == column);
; 73   : 	if (result)
; 74   : 	{
; 75   : 		assert((physicalAddress >> columnSizeDepth) == (pA >> columnSizeDepth));
; 76   : 	}	
; 77   : #endif
; 78   : }

	mov	eax, edi
	pop	edi
	ret	8
??0Address@DRAMsimII@@QAE@_K@Z ENDP			; DRAMsimII::Address::Address
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
CRT$XCU	ENDS
END
