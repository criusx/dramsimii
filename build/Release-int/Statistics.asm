; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\CriuS\Documents\Visual Studio 2008\Projects\DRAMsimIIhg\src\Statistics.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
PUBLIC	??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
PUBLIC	?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
PUBLIC	?_Checked_iterator_base@?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEPAIXZ ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@@Z ; std::_Checked_base<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ; std::_Move_cat<unsigned int *>
PUBLIC	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$_Umove@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_iterator@IV?$allocator@I@std@@@1@0PAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::reserve
PUBLIC	?_Checked_iterator_base@?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEPA_JXZ ; std::_Vector_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<__int64,std::allocator<__int64> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@@Z ; std::_Checked_base<std::_Vector_iterator<__int64,std::allocator<__int64> > >
PUBLIC	??$_Move_cat@PA_J@std@@YA?AU_Undefined_move_tag@0@ABQA_J@Z ; std::_Move_cat<__int64 *>
PUBLIC	??$_Uninit_move@PA_JPA_JV?$allocator@_J@std@@U_Undefined_move_tag@2@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<__int64 *,__int64 *,std::allocator<__int64>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<__int64,std::allocator<__int64> >,__int64 *,std::allocator<__int64> >
PUBLIC	??$_Umove@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z ; std::vector<__int64,std::allocator<__int64> >::_Umove<std::_Vector_iterator<__int64,std::allocator<__int64> > >
PUBLIC	?reserve@?$vector@_JV?$allocator@_J@std@@@std@@QAEXI@Z ; std::vector<__int64,std::allocator<__int64> >::reserve
PUBLIC	??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@XZ	; std::allocator<std::pair<unsigned int const ,unsigned int> >::allocator<std::pair<unsigned int const ,unsigned int> >
PUBLIC	??0?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QAE@XZ ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >
PUBLIC	??0?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@@Z ; std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>
PUBLIC	??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,unsigned int> >::allocator<std::pair<unsigned int const ,unsigned int> >
PUBLIC	??$?0U?$pair@$$CBII@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,unsigned int> >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBII@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,unsigned int> > >
PUBLIC	??$?0U?$pair@$$CBII@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node><std::pair<unsigned int const ,unsigned int> >
PUBLIC	??0?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
PUBLIC	??$?0U?$pair@$$CBII@std@@@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *><std::pair<unsigned int const ,unsigned int> >
PUBLIC	??0?$_List_ptr@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::_List_ptr<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_ptr<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
PUBLIC	??0?$_List_val@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_val<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
PUBLIC	?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode
PUBLIC	??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
PUBLIC	??$?0U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Container_base_aux_alloc_real<std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	??0?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV01@@Z ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
PUBLIC	??0?$_Vector_val@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ; std::_Vector_val<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_val<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	?_Buy@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE_NI@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Buy
PUBLIC	??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	??$?0U?$pair@$$CBII@std@@@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position><std::pair<unsigned int const ,unsigned int> >
PUBLIC	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
PUBLIC	??0?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
PUBLIC	??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
PUBLIC	??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >
PUBLIC	??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
PUBLIC	??0?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>
PUBLIC	??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
PUBLIC	??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_val<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>::construct
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Init
PUBLIC	??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
PUBLIC	??0?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAE@XZ ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >
PUBLIC	??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::allocator<std::pair<unsigned __int64 const ,unsigned int> >
PUBLIC	??$?0U?$pair@$$CB_KI@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64 const ,unsigned int> >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >
PUBLIC	??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::allocator<std::pair<unsigned __int64 const ,unsigned int> >
PUBLIC	??0?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>
PUBLIC	??$?0U?$pair@$$CB_KI@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node><std::pair<unsigned __int64 const ,unsigned int> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
PUBLIC	??$?0U?$pair@$$CB_KI@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *><std::pair<unsigned __int64 const ,unsigned int> >
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>::construct
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Init
PUBLIC	??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
PUBLIC	??0?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAE@XZ ; std::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >
PUBLIC	??0?$allocator@I@std@@QAE@XZ			; std::allocator<unsigned int>::allocator<unsigned int>
PUBLIC	??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned int>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::_Container_base_aux_alloc_real<std::allocator<unsigned int> >
PUBLIC	??0?$allocator@I@std@@QAE@ABV01@@Z		; std::allocator<unsigned int>::allocator<unsigned int>
PUBLIC	??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
PUBLIC	??$_Allocate@I@std@@YAPAIIPAI@Z			; std::_Allocate<unsigned int>
PUBLIC	?allocate@?$allocator@I@std@@QAEPAII@Z		; std::allocator<unsigned int>::allocate
PUBLIC	?max_size@?$allocator@I@std@@QBEIXZ		; std::allocator<unsigned int>::max_size
PUBLIC	?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
PUBLIC	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
PUBLIC	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
PUBLIC	??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ; std::_Iter_cat<unsigned int *>
PUBLIC	??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<unsigned int *>
PUBLIC	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z		; std::_Checked_base<unsigned int *>
PUBLIC	??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
PUBLIC	??$_Fill_n@PAIII@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
PUBLIC	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
PUBLIC	??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
PUBLIC	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
PUBLIC	?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	?getPhysicalAddress@Address@DRAMsimII@@QBE_KXZ	; DRAMsimII::Address::getPhysicalAddress
PUBLIC	?getChannel@Address@DRAMsimII@@QBEIXZ		; DRAMsimII::Address::getChannel
PUBLIC	?getDecodeDelay@Transaction@DRAMsimII@@QBE_JXZ	; DRAMsimII::Transaction::getDecodeDelay
PUBLIC	?getProgramCounter@Transaction@DRAMsimII@@QBE_KXZ ; DRAMsimII::Transaction::getProgramCounter
PUBLIC	?getLength@Transaction@DRAMsimII@@QBEIXZ	; DRAMsimII::Transaction::getLength
PUBLIC	?isWrite@Transaction@DRAMsimII@@QBE_NXZ		; DRAMsimII::Transaction::isWrite
PUBLIC	?countUp@DelayCounter@Statistics@DRAMsimII@@QAEXXZ ; DRAMsimII::Statistics::DelayCounter::countUp
PUBLIC	?delay@DelayCounter@Statistics@DRAMsimII@@QAEXI@Z ; DRAMsimII::Statistics::DelayCounter::delay
PUBLIC	??0DelayCounter@Statistics@DRAMsimII@@QAE@XZ	; DRAMsimII::Statistics::DelayCounter::DelayCounter
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator::operator--
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator,bool>
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert
PUBLIC	?max_size@?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::max_size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::max_size
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>::allocate
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node::_Node
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::const_iterator
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Dec
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::operator--
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert
PUBLIC	?_Kfn@?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@SAAB_KABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>::_Kfn
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Key
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@AB_K@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Lbound
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::lower_bound
PUBLIC	??0?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@QAE@AB_KABVDelayCounter@Statistics@DRAMsimII@@@Z ; std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator::operator*
PUBLIC	??A?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAEAAVDelayCounter@Statistics@DRAMsimII@@AB_K@Z ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::operator[]
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator::operator--
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator,bool>
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert
PUBLIC	?max_size@?$allocator@U?$pair@$$CB_KI@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::max_size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::max_size
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>::allocate
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KI@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node::_Node
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KI@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::const_iterator
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Dec
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::operator--
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert
PUBLIC	??R?$less@_K@std@@QBE_NAB_K0@Z			; std::less<unsigned __int64>::operator()
PUBLIC	?_Kfn@?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@SAAB_KABU?$pair@$$CB_KI@2@@Z ; std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>::_Kfn
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Key
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@AB_K@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Lbound
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::lower_bound
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KI@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator::operator*
PUBLIC	??0?$pair@$$CB_KI@std@@QAE@AB_KABI@Z		; std::pair<unsigned __int64 const ,unsigned int>::pair<unsigned __int64 const ,unsigned int>
PUBLIC	??A?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAEAAIAB_K@Z ; std::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::operator[]
PUBLIC	?getDelayTime@Event@DRAMsimII@@QBE_JXZ		; DRAMsimII::Event::getDelayTime
PUBLIC	?insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::insert
PUBLIC	?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@0@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase
PUBLIC	??$?8U?$pair@$$CBII@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBII@std@@@0@0@Z ; std::operator==<std::pair<unsigned int const ,unsigned int>,std::pair<unsigned int const ,unsigned int> >
PUBLIC	??$_Iter_cat@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@@Z ; std::_Iter_cat<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >
PUBLIC	??$_Construct@U?$pair@$$CBII@std@@U12@@std@@YAXPAU?$pair@$$CBII@0@ABU10@@Z ; std::_Construct<std::pair<unsigned int const ,unsigned int>,std::pair<unsigned int const ,unsigned int> >
PUBLIC	?construct@?$allocator@U?$pair@$$CBII@std@@@std@@QAEXPAU?$pair@$$CBII@2@ABU32@@Z ; std::allocator<std::pair<unsigned int const ,unsigned int> >::construct
PUBLIC	??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@I@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>::allocate
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *,std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>::construct
PUBLIC	?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PAU342@0ABU?$pair@$$CBII@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode
PUBLIC	?max_size@?$allocator@U?$pair@$$CBII@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int const ,unsigned int> >::max_size
PUBLIC	?max_size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::max_size
PUBLIC	?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Incsize
PUBLIC	?_Insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Insert
PUBLIC	?_Make_iter@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Make_iter
PUBLIC	?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase
PUBLIC	??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Insert<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >
PUBLIC	??$insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::insert<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >
PUBLIC	?_Splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@00I_N@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Splice
PUBLIC	?splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@0@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::splice
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::bucket_count
PUBLIC	?load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::load_factor
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::max_load_factor
PUBLIC	?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::begin
PUBLIC	?_Reinsert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Reinsert
PUBLIC	??F?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator--
PUBLIC	??F?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator--
PUBLIC	??0?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@QAE@ABV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@1@AB_N@Z ; std::pair<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>,bool>::pair<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>,bool>
PUBLIC	?_Insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@4@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Insert
PUBLIC	?insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::insert
PUBLIC	??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEAAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator[]
PUBLIC	??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::_Iterator<1>
PUBLIC	??E?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator++
PUBLIC	?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound
PUBLIC	??0?$pair@$$CBII@std@@QAE@ABI0@Z		; std::pair<unsigned int const ,unsigned int>::pair<unsigned int const ,unsigned int>
PUBLIC	??D?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEAAU?$pair@$$CBII@2@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator*
PUBLIC	??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[]
PUBLIC	?noshowpoint@std@@YAAAVios_base@1@AAV21@@Z	; std::noshowpoint
PUBLIC	?getAccumulatedLatency@DelayCounter@Statistics@DRAMsimII@@QBE_JXZ ; DRAMsimII::Statistics::DelayCounter::getAccumulatedLatency
PUBLIC	?getCount@DelayCounter@Statistics@DRAMsimII@@QBEIXZ ; DRAMsimII::Statistics::DelayCounter::getCount
PUBLIC	??A?$vector@IV?$allocator@I@std@@@std@@QBEABII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
PUBLIC	?getHitCount@Statistics@DRAMsimII@@QBEIXZ	; DRAMsimII::Statistics::getHitCount
PUBLIC	?getMissCount@Statistics@DRAMsimII@@QBEIXZ	; DRAMsimII::Statistics::getMissCount
PUBLIC	?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::end
PUBLIC	?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::end
PUBLIC	?begin@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::begin
PUBLIC	?end@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::end
PUBLIC	??$_Allocate@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IPAU123@@Z ; std::_Allocate<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
PUBLIC	?allocate@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocate
PUBLIC	?capacity@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::capacity
PUBLIC	?max_size@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QBEIXZ ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::max_size
PUBLIC	?max_size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::max_size
PUBLIC	??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@IABU120@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	?_Ufill@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU345@IABU345@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Ufill
PUBLIC	?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Xlen
PUBLIC	??$_Construct@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU123@@Z ; std::_Construct<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
PUBLIC	?construct@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU345@@Z ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::construct
PUBLIC	??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	??$unchecked_uninitialized_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z ; stdext::unchecked_uninitialized_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	??$_Uninit_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	??$_Umove@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU234@00@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Umove<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	??$_Fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z ; std::_Fill<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
PUBLIC	??$fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z ; std::fill<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
PUBLIC	??$_Move_cat@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::_Move_cat<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::forward_iterator_tag>
PUBLIC	??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	??$_Move_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z ; stdext::_Unchecked_move_backward<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Insert_n
PUBLIC	?insert@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::insert
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &>::_Ranit<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &>
PUBLIC	??0?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	??0?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	?_Make_iter@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator==
PUBLIC	??9?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator!=
PUBLIC	??$_Iter_random@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0@Z ; std::_Iter_random<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@@Z ; std::_Checked_base<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::forward_iterator_tag>
PUBLIC	??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	??$unchecked_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z ; stdext::unchecked_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	?erase@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@0@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::erase
PUBLIC	?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Assign_n
PUBLIC	?assign@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::assign
PUBLIC	??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<0>::_Const_iterator<0>
PUBLIC	??0?$_Iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<0>::_Iterator<0>
PUBLIC	??0_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::_List_position
PUBLIC	?_Init@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Init
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear
PUBLIC	??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
PUBLIC	?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::begin
PUBLIC	?begin@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::begin
PUBLIC	?size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::size
PUBLIC	?size@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::size
PUBLIC	?_Kfn@?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@SAABIABU?$pair@$$CBII@3@@Z ; std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>::_Kfn
PUBLIC	??R?$equal_to@I@std@@QBE_NABI0@Z		; std::equal_to<unsigned int>::operator()
PUBLIC	??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBE_NABI0@Z ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::operator()
PUBLIC	??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::_Iterator<1>
PUBLIC	?_Get_iter@_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABV56@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::_Get_iter
PUBLIC	?_Get_iter_from_vec@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABU_List_position@12@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Get_iter_from_vec
PUBLIC	??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Const_iterator<1>
PUBLIC	?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::end
PUBLIC	?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::end
PUBLIC	??R?$hash@I@tr1@std@@QBEIABI@Z			; std::tr1::hash<unsigned int>::operator()
PUBLIC	??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBEIABI@Z ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::operator()
PUBLIC	?_Hashval@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IBEIABI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hashval
PUBLIC	?size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::size
PUBLIC	??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator[]
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBII@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Bidit@U?$pair@$$CBII@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &>::_Bidit<std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &>
PUBLIC	??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Const_iterator<1>
PUBLIC	?_Mynode@?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Mynode
PUBLIC	?_Mynode@?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<0>::_Mynode
PUBLIC	??8_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::operator==
PUBLIC	??9_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::operator!=
PUBLIC	?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound
PUBLIC	?find@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::find
PUBLIC	?_Myval@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@KAAAU?$pair@$$CBII@2@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Myval
PUBLIC	??D?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEABU?$pair@$$CBII@2@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator*
PUBLIC	??C?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPBU?$pair@$$CBII@2@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator->
PUBLIC	??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator++
PUBLIC	??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV012@H@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator++
PUBLIC	??8?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator==
PUBLIC	??9?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator!=
PUBLIC	??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z ; DRAMsimII::operator==<unsigned int,unsigned int>
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@IHPBIABI@std@@QAE@XZ		; std::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>
PUBLIC	??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
PUBLIC	?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
PUBLIC	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
PUBLIC	??$_Iter_random@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@0@Z ; std::_Iter_random<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
PUBLIC	??H?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEPBIXZ ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$_Equal@PBIPBIUforward_iterator_tag@std@@@std@@YA_NPBI00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<unsigned int const *,unsigned int const *,std::forward_iterator_tag>
PUBLIC	??$_Equal@PBIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YA_NPBI0V?$_Vector_const_iterator@IV?$allocator@I@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<unsigned int const *,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$equal@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@00@Z ; std::equal<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$?8IV?$allocator@I@std@@@std@@YA_NABV?$vector@IV?$allocator@I@std@@@0@0@Z ; std::operator==<unsigned int,std::allocator<unsigned int> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::end
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::size
PUBLIC	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
PUBLIC	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
PUBLIC	??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z ; std::_Iter_random<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Myval
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::operator*
PUBLIC	??8DelayCounter@Statistics@DRAMsimII@@QBE_NABV012@@Z ; DRAMsimII::Statistics::DelayCounter::operator==
PUBLIC	??$?8$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@YA_NABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@0@0@Z ; std::operator==<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>
PUBLIC	??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::forward_iterator_tag>
PUBLIC	??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00@Z ; std::equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
PUBLIC	??$?8V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z ; std::operator==<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::end
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::size
PUBLIC	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
PUBLIC	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
PUBLIC	??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z ; std::_Iter_random<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CB_KI@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Myval
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CB_KI@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::operator*
PUBLIC	??$?8$$CB_KI@std@@YA_NABU?$pair@$$CB_KI@0@0@Z	; std::operator==<unsigned __int64 const ,unsigned int>
PUBLIC	??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::forward_iterator_tag>
PUBLIC	??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00@Z ; std::equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
PUBLIC	??$?8V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z ; std::operator==<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
PUBLIC	??_C@_04ECGLBLOI@?9?9?9?9?$AA@			; `string'
PUBLIC	??_C@_0BH@GGHGAMGD@?9?9?9?9Transaction?5Delay?5?$AA@ ; `string'
PUBLIC	??_C@_0BI@OFHLBMPE@?9?9?9?9Command?5Turnaround?5?$AA@ ; `string'
PUBLIC	??_C@_0BD@BJDMIPKA@?9?9?9?9Command?5Delay?5?$AA@ ; `string'
PUBLIC	??_C@_0BI@FKLHOOHD@?9?9?9?9CMD?5Execution?5Time?5?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CCJBOFFI@?9?9?9?9Transaction?5Latency?5?$AA@ ; `string'
PUBLIC	??_C@_0BE@PBEECLAB@?9?9?9?9Working?5Set?9?9?9?9?$AA@ ; `string'
PUBLIC	??_C@_0BC@FLEKEEG@?9?9?9?9Bandwidth?9?9?9?9?$AA@ ; `string'
PUBLIC	??_C@_0CO@FAIAOJGB@?9?9?9?9Average?5Transaction?5Latency?5@ ; `string'
PUBLIC	??_C@_0BM@FMOJPDMJ@?9?9?9?9Row?5Hit?1Miss?5Counts?9?9?9?9?$AA@ ; `string'
PUBLIC	??_C@_0BE@JGDENAHI@?9?9?9?9Utilization?9?9?9?9?$AA@ ; `string'
PUBLIC	??_C@_02KCKGHPCA@?$CJ?5?$AA@			; `string'
PUBLIC	??_C@_01ODHLEDKK@?$CI?$AA@			; `string'
PUBLIC	??_C@_0BK@JBNJPPAB@?9?9?9?9Latency?5Breakdown?9?9?9?9?$AA@ ; `string'
PUBLIC	??_C@_0BO@EIIIOAJG@?9?9?9?9tFAW?5Limited?5Commands?9?9?9?9?$AA@ ; `string'
EXTRN	_ldiv:PROC
;	COMDAT ??_C@_0BO@EIIIOAJG@?9?9?9?9tFAW?5Limited?5Commands?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0BO@EIIIOAJG@?9?9?9?9tFAW?5Limited?5Commands?9?9?9?9?$AA@ DB '----t'
	DB	'FAW Limited Commands----', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JBNJPPAB@?9?9?9?9Latency?5Breakdown?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0BK@JBNJPPAB@?9?9?9?9Latency?5Breakdown?9?9?9?9?$AA@ DB '----Latenc'
	DB	'y Breakdown----', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI?$AA@
CONST	SEGMENT
??_C@_01ODHLEDKK@?$CI?$AA@ DB '(', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KCKGHPCA@?$CJ?5?$AA@
CONST	SEGMENT
??_C@_02KCKGHPCA@?$CJ?5?$AA@ DB ') ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JGDENAHI@?9?9?9?9Utilization?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0BE@JGDENAHI@?9?9?9?9Utilization?9?9?9?9?$AA@ DB '----Utilization--'
	DB	'--', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FMOJPDMJ@?9?9?9?9Row?5Hit?1Miss?5Counts?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0BM@FMOJPDMJ@?9?9?9?9Row?5Hit?1Miss?5Counts?9?9?9?9?$AA@ DB '----Ro'
	DB	'w Hit/Miss Counts----', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FAIAOJGB@?9?9?9?9Average?5Transaction?5Latency?5@
CONST	SEGMENT
??_C@_0CO@FAIAOJGB@?9?9?9?9Average?5Transaction?5Latency?5@ DB '----Avera'
	DB	'ge Transaction Latency Per PC Value ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FLEKEEG@?9?9?9?9Bandwidth?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0BC@FLEKEEG@?9?9?9?9Bandwidth?9?9?9?9?$AA@ DB '----Bandwidth----', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PBEECLAB@?9?9?9?9Working?5Set?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0BE@PBEECLAB@?9?9?9?9Working?5Set?9?9?9?9?$AA@ DB '----Working Set-'
	DB	'---', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CCJBOFFI@?9?9?9?9Transaction?5Latency?5?$AA@
CONST	SEGMENT
??_C@_0BJ@CCJBOFFI@?9?9?9?9Transaction?5Latency?5?$AA@ DB '----Transactio'
	DB	'n Latency ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FKLHOOHD@?9?9?9?9CMD?5Execution?5Time?5?$AA@
CONST	SEGMENT
??_C@_0BI@FKLHOOHD@?9?9?9?9CMD?5Execution?5Time?5?$AA@ DB '----CMD Execut'
	DB	'ion Time ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BJDMIPKA@?9?9?9?9Command?5Delay?5?$AA@
CONST	SEGMENT
??_C@_0BD@BJDMIPKA@?9?9?9?9Command?5Delay?5?$AA@ DB '----Command Delay ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OFHLBMPE@?9?9?9?9Command?5Turnaround?5?$AA@
CONST	SEGMENT
??_C@_0BI@OFHLBMPE@?9?9?9?9Command?5Turnaround?5?$AA@ DB '----Command Tur'
	DB	'naround ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GGHGAMGD@?9?9?9?9Transaction?5Delay?5?$AA@
CONST	SEGMENT
??_C@_0BH@GGHGAMGD@?9?9?9?9Transaction?5Delay?5?$AA@ DB '----Transaction '
	DB	'Delay ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04ECGLBLOI@?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_04ECGLBLOI@?9?9?9?9?$AA@ DB '----', 00H		; `string'
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<unsigned int *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<unsigned int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	push	esi
	npad	7
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAI@std@@YAPAIAAPAI@Z
_TEXT	SEGMENT
??$_Checked_base@PAI@std@@YAPAIAAPAI@Z PROC		; std::_Checked_base<unsigned int *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAI@std@@YAPAIAAPAI@Z ENDP		; std::_Checked_base<unsigned int *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEPA_JXZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEPA_JXZ PROC ; std::_Vector_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 305  : 		return (this->_Myptr);

	mov	eax, DWORD PTR [eax+4]

; 306  : 		}

	ret	0
?_Checked_iterator_base@?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEPA_JXZ ENDP ; std::_Vector_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEPBIXZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEPBIXZ PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEPBIXZ ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEPAIXZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEPAIXZ PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 305  : 		return (this->_Myptr);

	mov	eax, DWORD PTR [eax+4]

; 306  : 		}

	ret	0
?_Checked_iterator_base@?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEPAIXZ ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::forward_iterator_tag>, COMDAT
; __Last$ = ecx
; __Dest$ = eax

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	mov	edx, DWORD PTR __First$[esp-4]

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@2
	push	esi
	npad	7
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@2
	pop	esi
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAIII@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAIII@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@2
	push	esi
	npad	7
$LL9@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@2
	pop	esi
$LN7@Fill_n@2:

; 3255 : 	}

	ret	0
??$_Fill_n@PAIII@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z
_TEXT	SEGMENT
??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z PROC ; std::_Iter_cat<unsigned int *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ENDP ; std::_Iter_cat<unsigned int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<__int64,std::allocator<__int64> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<__int64,std::allocator<__int64> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?8$$CB_KI@std@@YA_NABU?$pair@$$CB_KI@0@0@Z
_TEXT	SEGMENT
??$?8$$CB_KI@std@@YA_NABU?$pair@$$CB_KI@0@0@Z PROC	; std::operator==<unsigned __int64 const ,unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 86   : 	return (_Left.first == _Right.first && _Left.second == _Right.second);

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@operator@3
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator@3
	mov	ecx, DWORD PTR [ecx+8]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator@3
	mov	eax, 1

; 87   : 	}

	ret	0
$LN3@operator@3:

; 86   : 	return (_Left.first == _Right.first && _Left.second == _Right.second);

	xor	eax, eax

; 87   : 	}

	ret	0
??$?8$$CB_KI@std@@YA_NABU?$pair@$$CB_KI@0@0@Z ENDP	; std::operator==<unsigned __int64 const ,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax
; __It$ = ecx

; 1147 : 		return _It;

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1148 : 	}

	ret	0
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax
; __It$ = ecx

; 1147 : 		return _It;

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1148 : 	}

	ret	0
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Equal@PBIPBIUforward_iterator_tag@std@@@std@@YA_NPBI00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Equal@PBIPBIUforward_iterator_tag@std@@@std@@YA_NPBI00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<unsigned int const *,unsigned int const *,std::forward_iterator_tag>, COMDAT
; __Last1$ = edx
; __First2$ = ecx

; 2991 : 	{	// compare [_First1, _Last1) to [First2, ...)

	mov	eax, DWORD PTR __First1$[esp-4]
	push	esi

; 2992 : 	for (; _First1 != _Last1; ++_First1, ++_First2)

	cmp	eax, edx
	je	SHORT $LN2@Equal
	npad	7
$LL4@Equal:

; 2993 : 		if (!(*_First1 == *_First2))

	mov	esi, DWORD PTR [eax]
	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN8@Equal
	add	eax, 4
	add	ecx, 4
	cmp	eax, edx
	jne	SHORT $LL4@Equal
$LN2@Equal:

; 2995 : 	return (true);

	mov	al, 1
	pop	esi

; 2996 : 	}

	ret	0
$LN8@Equal:

; 2994 : 			return (false);

	xor	al, al
	pop	esi

; 2996 : 	}

	ret	0
??$_Equal@PBIPBIUforward_iterator_tag@std@@@std@@YA_NPBI00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<unsigned int const *,unsigned int const *,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::forward_iterator_tag>, COMDAT
; __Last$ = edx
; __Dest$ = eax

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	mov	ecx, DWORD PTR __First$[esp-4]

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@2
	push	esi
	npad	7
$LL3@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@2
	pop	esi
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z PROC	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_
	push	esi
	npad	7
$LL13@unchecked_:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_
	pop	esi
$LN11@unchecked_:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ENDP	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PA_J@std@@YA?AU_Undefined_move_tag@0@ABQA_J@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PA_J@std@@YA?AU_Undefined_move_tag@0@ABQA_J@Z PROC ; std::_Move_cat<__int64 *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PA_J@std@@YA?AU_Undefined_move_tag@0@ABQA_J@Z ENDP ; std::_Move_cat<__int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<__int64,std::allocator<__int64> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z PROC ; std::_Move_cat<unsigned int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ENDP ; std::_Move_cat<unsigned int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@@Z
_TEXT	SEGMENT
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@@Z PROC ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax
; __It$ = ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1166 : 	}

	ret	0
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@@Z ENDP ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@@Z
_TEXT	SEGMENT
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@@Z PROC ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax
; __It$ = ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1166 : 	}

	ret	0
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@@Z ENDP ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@0@Z
_TEXT	SEGMENT
??$_Iter_random@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z PROC ; std::_Move_cat<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ENDP ; std::_Move_cat<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$_Fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z PROC ; std::_Fill<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>, COMDAT
; __Last$ = edx
; __Val$ = ecx

; 3156 : 	{	// copy _Val through [_First, _Last)

	mov	eax, DWORD PTR __First$[esp-4]

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	cmp	eax, edx
	je	SHORT $LN1@Fill@3
	push	esi
	npad	7
$LL3@Fill@3:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL3@Fill@3
	pop	esi
$LN1@Fill@3:

; 3160 : 	}

	ret	0
??$_Fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z ENDP ; std::_Fill<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0@Z
_TEXT	SEGMENT
??$_Iter_random@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0@Z PROC ; std::_Iter_random<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0@Z ENDP ; std::_Iter_random<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@@Z
_TEXT	SEGMENT
??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@@Z PROC ; std::_Checked_base<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@@Z ENDP ; std::_Checked_base<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@@Z PROC ; std::_Iter_cat<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@@Z ENDP ; std::_Iter_cat<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil
	push	esi
	npad	7
$LL15@Uninit_fil:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil
	pop	esi
$LN13@Uninit_fil:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CB_KI@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CB_KI@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64 const ,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CB_KI@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64 const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBII@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBII@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CBII@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z PROC ; std::fill<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>, COMDAT
; __Last$ = edx
; __Val$ = ecx

; 3186 : 	{	// copy _Val through [_First, _Last)

	mov	eax, DWORD PTR __First$[esp-4]

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	cmp	eax, edx
	je	SHORT $LN11@fill@2
	push	esi
	npad	7
$LL13@fill@2:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL13@fill@2
	pop	esi
$LN11@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z ENDP ; std::fill<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBII@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBII@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node><std::pair<unsigned int const ,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CBII@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node><std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CB_KI@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CB_KI@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node><std::pair<unsigned __int64 const ,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CB_KI@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node><std::pair<unsigned __int64 const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z
_TEXT	SEGMENT
??$?0U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBII@std@@@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBII@std@@@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *><std::pair<unsigned int const ,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CBII@std@@@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *><std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?8U?$pair@$$CBII@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBII@std@@@0@0@Z
_TEXT	SEGMENT
??$?8U?$pair@$$CBII@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBII@std@@@0@0@Z PROC ; std::operator==<std::pair<unsigned int const ,unsigned int>,std::pair<unsigned int const ,unsigned int> >, COMDAT

; 175  : 	return (true);

	mov	al, 1

; 176  : 	}

	ret	0
??$?8U?$pair@$$CBII@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBII@std@@@0@0@Z ENDP ; std::operator==<std::pair<unsigned int const ,unsigned int>,std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CB_KI@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CB_KI@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *><std::pair<unsigned __int64 const ,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CB_KI@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *><std::pair<unsigned __int64 const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT
??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned int>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBII@std@@@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBII@std@@@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position><std::pair<unsigned int const ,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CBII@std@@@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position><std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBII@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBII@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned int const ,unsigned int> >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBII@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int const ,unsigned int> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@3
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@3:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?max_size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::max_size, COMDAT

; 625  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 626  : 		}

	ret	0
?max_size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KI@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Carg$ = 20						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KI@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node::_Node, COMDAT
; _this$ = eax
; __Val$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], edx
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	mov	cl, BYTE PTR __Carg$[esp-4]
	movq	QWORD PTR [eax+24], xmm0
	mov	BYTE PTR [eax+32], cl
	mov	BYTE PTR [eax+33], 0

; 39   : 			}

	ret	16					; 00000010H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KI@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Carg$ = 20						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node::_Node, COMDAT
; _this$ = eax
; __Val$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], edx
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR [eax+24], xmm0
	movq	xmm0, QWORD PTR [ecx+16]
	mov	cl, BYTE PTR __Carg$[esp-4]
	movq	QWORD PTR [eax+32], xmm0
	mov	BYTE PTR [eax+40], cl
	mov	BYTE PTR [eax+41], 0

; 39   : 			}

	ret	16					; 00000010H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ
_TEXT	SEGMENT
?_Mynode@?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<0>::_Mynode, COMDAT
; _this$ = eax

; 308  : 			return (_Ptr);

	mov	eax, DWORD PTR [eax+4]

; 309  : 			}

	ret	0
?_Mynode@?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<0>::_Mynode
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CB_KI@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CB_KI@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 268435455				; 0fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CB_KI@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 178956970				; 0aaaaaaaH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QBEIXZ PROC ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QBEIXZ ENDP ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\functional
_TEXT	ENDS
;	COMDAT ??R?$hash@I@tr1@std@@QBEIABI@Z
_TEXT	SEGMENT
??R?$hash@I@tr1@std@@QBEIABI@Z PROC			; std::tr1::hash<unsigned int>::operator(), COMDAT
; __Keyval$ = eax

; 1265 : 		ldiv_t _Qrem = ldiv((long)(size_t)_Keyval, 127773);

	mov	ecx, DWORD PTR [eax]
	push	127773					; 0001f31dH
	push	ecx
	call	_ldiv

; 1266 : 
; 1267 : 		_Qrem.rem = 16807 * _Qrem.rem - 2836 * _Qrem.quot;

	imul	eax, 2836				; 00000b14H
	imul	edx, 16807				; 000041a7H
	add	esp, 8
	sub	edx, eax
	mov	eax, edx

; 1268 : 		if (_Qrem.rem < 0)

	jns	SHORT $LN1@operator@4

; 1269 : 			_Qrem.rem += 2147483647;

	add	eax, 2147483647				; 7fffffffH
$LN1@operator@4:

; 1270 : 		return ((size_t)_Qrem.rem);
; 1271 : 		}

	ret	0
??R?$hash@I@tr1@std@@QBEIABI@Z ENDP			; std::tr1::hash<unsigned int>::operator()
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 50   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax+8], cl

; 51   : 		}

	ret	4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 50   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax+8], cl

; 51   : 		}

	ret	4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@QAE@ABV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@QAE@ABV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@1@AB_N@Z PROC ; std::pair<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>,bool>::pair<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 50   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax+8], cl

; 51   : 		}

	ret	4
??0?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@QAE@ABV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@1@AB_N@Z ENDP ; std::pair<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>,bool>::pair<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>,bool>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ
_TEXT	SEGMENT
?_Mynode@?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Mynode, COMDAT
; _this$ = eax

; 308  : 			return (_Ptr);

	mov	eax, DWORD PTR [eax+4]

; 309  : 			}

	ret	0
?_Mynode@?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Mynode
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::max_size, COMDAT

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 268435455				; 0fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::max_size, COMDAT

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 178956970				; 0aaaaaaaH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV01@@Z PROC ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\functional
_TEXT	ENDS
;	COMDAT ??R?$equal_to@I@std@@QBE_NABI0@Z
_TEXT	SEGMENT
??R?$equal_to@I@std@@QBE_NABI0@Z PROC			; std::equal_to<unsigned int>::operator(), COMDAT
; __Left$ = eax
; __Right$ = edx

; 110  : 		return (_Left == _Right);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 111  : 		}

	ret	0
??R?$equal_to@I@std@@QBE_NABI0@Z ENDP			; std::equal_to<unsigned int>::operator()
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBEIABI@Z
_TEXT	SEGMENT
??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBEIABI@Z PROC ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::operator(), COMDAT
; __Keyval$ = eax

; 174  : 		{	// hash _Keyval to size_t value

	push	ecx

; 175  : 		return ((size_t)_Hashobj(_Keyval));

	mov	ecx, DWORD PTR [eax]
	push	127773					; 0001f31dH
	push	ecx
	call	_ldiv
	imul	eax, 2836				; 00000b14H
	imul	edx, 16807				; 000041a7H
	add	esp, 8
	sub	edx, eax
	mov	eax, edx
	jns	SHORT $LN3@operator@5
	add	eax, 2147483647				; 7fffffffH
$LN3@operator@5:
	pop	ecx

; 176  : 		}

	ret	0
??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBEIABI@Z ENDP ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::operator()
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int const ,unsigned int> >::allocator<std::pair<unsigned int const ,unsigned int> >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int const ,unsigned int> >::allocator<std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ
_TEXT	SEGMENT
?max_load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::max_load_factor, COMDAT
; _this$ = eax

; 513  : 		return (_Max_bucket_size);

	movss	xmm0, DWORD PTR [eax+68]

; 514  : 		}

	ret	0
?max_load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::max_load_factor
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ
_TEXT	SEGMENT
?bucket_count@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::bucket_count, COMDAT
; _this$ = eax

; 451  : 		return (_Maxidx);

	mov	eax, DWORD PTR [eax+64]

; 452  : 		}

	ret	0
?bucket_count@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::bucket_count
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@I@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@I@std@@QBEIXZ PROC		; std::allocator<unsigned int>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@I@std@@QBEIXZ ENDP		; std::allocator<unsigned int>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@I@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@I@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@I@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::allocator<std::pair<unsigned __int64 const ,unsigned int> >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::allocator<std::pair<unsigned __int64 const ,unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@SAAB_KABU?$pair@$$CB_KI@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@SAAB_KABU?$pair@$$CB_KI@2@@Z PROC ; std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 65   : 		return (_Val.first);
; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@SAAB_KABU?$pair@$$CB_KI@2@@Z ENDP ; std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CB_KI@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CB_KI@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	add	eax, 16					; 00000010H

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CB_KI@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Myval
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@SAAB_KABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@SAAB_KABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z PROC ; std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 65   : 		return (_Val.first);
; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@SAAB_KABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ENDP ; std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEAAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z
_TEXT	SEGMENT
??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEAAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 3
	cmp	edi, eax
	jb	SHORT $LN1@operator@6
	call	__invalid_parameter_noinfo
$LN1@operator@6:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*8]

; 786  : 		}

	ret	0
??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEAAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBE_NABI0@Z
_TEXT	SEGMENT
??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBE_NABI0@Z PROC ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::operator(), COMDAT
; __Keyval1$ = eax
; __Keyval2$ = edx

; 180  : 		return (!_Keyeqobj(_Keyval1, _Keyval2));

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al

; 181  : 		}

	ret	0
??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBE_NABI0@Z ENDP ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::operator()
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@SAABIABU?$pair@$$CBII@3@@Z
_TEXT	SEGMENT
?_Kfn@?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@SAABIABU?$pair@$$CBII@3@@Z PROC ; std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 71   : 		return (_Val.first);
; 72   : 		}

	ret	0
?_Kfn@?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@SAABIABU?$pair@$$CBII@3@@Z ENDP ; std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Hashval@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IBEIABI@Z
_TEXT	SEGMENT
?_Hashval@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IBEIABI@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hashval, COMDAT
; _this$ = esi
; __Keyval$ = eax

; 821  : 		{	// return hash value, masked and wrapped to current table size

	push	ecx

; 822  : 		size_type _Num = this->comp(_Keyval) & _Mask;

	mov	ecx, DWORD PTR [eax]
	push	127773					; 0001f31dH
	push	ecx
	call	_ldiv
	imul	edx, 16807				; 000041a7H
	imul	eax, 2836				; 00000b14H
	add	esp, 8
	sub	edx, eax
	jns	SHORT $LN6@Hashval
	add	edx, 2147483647				; 7fffffffH
$LN6@Hashval:
	mov	ecx, DWORD PTR [esi+60]
	mov	eax, ecx
	and	eax, edx

; 823  : 		if (_Maxidx <= _Num)

	cmp	DWORD PTR [esi+64], eax
	ja	SHORT $LN1@Hashval

; 824  : 			_Num -= (_Mask >> 1) + 1;

	shr	ecx, 1
	or	edx, -1
	sub	edx, ecx
	add	eax, edx
$LN1@Hashval:
	pop	ecx

; 825  : 		return (_Num);
; 826  : 		}

	ret	0
?_Hashval@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IBEIABI@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hashval
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CB_KI@std@@QAE@AB_KABI@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CB_KI@std@@QAE@AB_KABI@Z PROC		; std::pair<unsigned __int64 const ,unsigned int>::pair<unsigned __int64 const ,unsigned int>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 50   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax+8], ecx

; 51   : 		}

	ret	4
??0?$pair@$$CB_KI@std@@QAE@AB_KABI@Z ENDP		; std::pair<unsigned __int64 const ,unsigned int>::pair<unsigned __int64 const ,unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@QAE@AB_KABVDelayCounter@Statistics@DRAMsimII@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??0?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@QAE@AB_KABVDelayCounter@Statistics@DRAMsimII@@@Z PROC ; std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>, COMDAT
; __Val1$ = edx
; __Val2$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, DWORD PTR _this$[esp-4]
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], edx
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax+8], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR [eax+16], xmm0
	pop	esi

; 51   : 		}

	ret	4
??0?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@QAE@AB_KABVDelayCounter@Statistics@DRAMsimII@@@Z ENDP ; std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBII@std@@QAE@ABI0@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBII@std@@QAE@ABI0@Z PROC			; std::pair<unsigned int const ,unsigned int>::pair<unsigned int const ,unsigned int>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 50   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	4
??0?$pair@$$CBII@std@@QAE@ABI0@Z ENDP			; std::pair<unsigned int const ,unsigned int>::pair<unsigned int const ,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@I@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@I@std@@QAE@XZ PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@I@std@@QAE@XZ ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@4
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@4:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::allocator<std::pair<unsigned __int64 const ,unsigned int> >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::allocator<std::pair<unsigned __int64 const ,unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	add	eax, 16					; 00000010H

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\functional
_TEXT	ENDS
;	COMDAT ??R?$less@_K@std@@QBE_NAB_K0@Z
_TEXT	SEGMENT
??R?$less@_K@std@@QBE_NAB_K0@Z PROC			; std::less<unsigned __int64>::operator(), COMDAT
; __Left$ = ecx
; __Right$ = eax

; 143  : 		return (_Left < _Right);

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]
	ja	SHORT $LN3@operator@7
	jb	SHORT $LN5@operator@7
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN3@operator@7
$LN5@operator@7:
	mov	eax, 1

; 144  : 		}

	ret	0
$LN3@operator@7:

; 143  : 		return (_Left < _Right);

	xor	eax, eax

; 144  : 		}

	ret	0
??R?$less@_K@std@@QBE_NAB_K0@Z ENDP			; std::less<unsigned __int64>::operator()
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	add	eax, 16					; 00000010H

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Myval
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	add	eax, 16					; 00000010H

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::size, COMDAT
; _this$ = eax

; 620  : 		return (_Mysize);

	mov	eax, DWORD PTR [eax+24]

; 621  : 		}

	ret	0
?size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@KAAAU?$pair@$$CBII@2@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@@Z
_TEXT	SEGMENT
?_Myval@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@KAAAU?$pair@$$CBII@2@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Myval, COMDAT
; __Pnode$ = eax

; 125  : 		return ((_Vref)(*_Pnode)._Myval);

	add	eax, 8

; 126  : 		}

	ret	0
?_Myval@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@KAAAU?$pair@$$CBII@2@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Myval
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??0?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QAE@XZ
_TEXT	SEGMENT
??0?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QAE@XZ PROC ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >, COMDAT
; _this$ = eax

; 160  : 		{	// construct with default hasher and equality comparator
; 161  : 		}

	ret	0
??0?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QAE@XZ ENDP ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<unsigned int const ,unsigned int> >::allocator<std::pair<unsigned int const ,unsigned int> >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<unsigned int const ,unsigned int> >::allocator<std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::size, COMDAT
; _this$ = eax

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [eax+28]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::size, COMDAT
; _this$ = eax

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [eax+28]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?size@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::size, COMDAT
; _this$ = eax

; 417  : 		return (_List.size());

	mov	eax, DWORD PTR [eax+32]

; 418  : 		}

	ret	0
?size@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::size
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.h
_TEXT	ENDS
;	COMDAT ?getMissCount@Statistics@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getMissCount@Statistics@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Statistics::getMissCount, COMDAT
; _this$ = eax

; 162  : 		unsigned getMissCount() const { return rowMisses; }

	mov	eax, DWORD PTR [eax+60]
	ret	0
?getMissCount@Statistics@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Statistics::getMissCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getHitCount@Statistics@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getHitCount@Statistics@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Statistics::getHitCount, COMDAT
; _this$ = eax

; 156  : 		unsigned getHitCount() const { return rowHits;}

	mov	eax, DWORD PTR [eax+56]
	ret	0
?getHitCount@Statistics@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Statistics::getHitCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8DelayCounter@Statistics@DRAMsimII@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8DelayCounter@Statistics@DRAMsimII@@QBE_NABV012@@Z PROC ; DRAMsimII::Statistics::DelayCounter::operator==, COMDAT
; _this$ = ecx
; _right$ = eax

; 91   : 				  return accumulatedLatency == right.accumulatedLatency &&
; 92   : 					  count == right.count;

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@operator@8
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator@8
	mov	ecx, DWORD PTR [ecx+8]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator@8
	mov	eax, 1

; 93   : 			  }

	ret	0
$LN3@operator@8:

; 91   : 				  return accumulatedLatency == right.accumulatedLatency &&
; 92   : 					  count == right.count;

	xor	eax, eax

; 93   : 			  }

	ret	0
??8DelayCounter@Statistics@DRAMsimII@@QBE_NABV012@@Z ENDP ; DRAMsimII::Statistics::DelayCounter::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCount@DelayCounter@Statistics@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getCount@DelayCounter@Statistics@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::Statistics::DelayCounter::getCount, COMDAT
; _this$ = eax

; 87   : 			  unsigned getCount() const { return count; }

	mov	eax, DWORD PTR [eax+8]
	ret	0
?getCount@DelayCounter@Statistics@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::Statistics::DelayCounter::getCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getAccumulatedLatency@DelayCounter@Statistics@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getAccumulatedLatency@DelayCounter@Statistics@DRAMsimII@@QBE_JXZ PROC ; DRAMsimII::Statistics::DelayCounter::getAccumulatedLatency, COMDAT
; _this$ = ecx

; 86   : 			  tick getAccumulatedLatency() const { return accumulatedLatency; }

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]
	ret	0
?getAccumulatedLatency@DelayCounter@Statistics@DRAMsimII@@QBE_JXZ ENDP ; DRAMsimII::Statistics::DelayCounter::getAccumulatedLatency
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?delay@DelayCounter@Statistics@DRAMsimII@@QAEXI@Z
_TEXT	SEGMENT
?delay@DelayCounter@Statistics@DRAMsimII@@QAEXI@Z PROC	; DRAMsimII::Statistics::DelayCounter::delay, COMDAT
; _this$ = eax
; _value$ = ecx

; 83   : 				  accumulatedLatency += value;

	add	DWORD PTR [eax], ecx
	adc	DWORD PTR [eax+4], 0

; 84   : 			  }

	ret	0
?delay@DelayCounter@Statistics@DRAMsimII@@QAEXI@Z ENDP	; DRAMsimII::Statistics::DelayCounter::delay
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?countUp@DelayCounter@Statistics@DRAMsimII@@QAEXXZ
_TEXT	SEGMENT
?countUp@DelayCounter@Statistics@DRAMsimII@@QAEXXZ PROC	; DRAMsimII::Statistics::DelayCounter::countUp, COMDAT
; _this$ = eax

; 78   : 				  count++;

	inc	DWORD PTR [eax+8]

; 79   : 			  }

	ret	0
?countUp@DelayCounter@Statistics@DRAMsimII@@QAEXXZ ENDP	; DRAMsimII::Statistics::DelayCounter::countUp
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0DelayCounter@Statistics@DRAMsimII@@QAE@XZ
_TEXT	SEGMENT
??0DelayCounter@Statistics@DRAMsimII@@QAE@XZ PROC	; DRAMsimII::Statistics::DelayCounter::DelayCounter, COMDAT
; _this$ = eax

; 74   : 				  count(0) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0DelayCounter@Statistics@DRAMsimII@@QAE@XZ ENDP	; DRAMsimII::Statistics::DelayCounter::DelayCounter
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\transaction.h
_TEXT	ENDS
;	COMDAT ?isWrite@Transaction@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isWrite@Transaction@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Transaction::isWrite, COMDAT
; _this$ = ecx

; 67   : 		bool isWrite() const { return (type == WRITE_TRANSACTION); }

	xor	eax, eax
	cmp	DWORD PTR [ecx+80], 1
	sete	al
	ret	0
?isWrite@Transaction@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Transaction::isWrite
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLength@Transaction@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getLength@Transaction@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Transaction::getLength, COMDAT
; _this$ = eax

; 63   : 		unsigned getLength() const { return length; }								///< get the number of bytes requested

	mov	eax, DWORD PTR [eax+84]
	ret	0
?getLength@Transaction@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Transaction::getLength
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getProgramCounter@Transaction@DRAMsimII@@QBE_KXZ
_TEXT	SEGMENT
?getProgramCounter@Transaction@DRAMsimII@@QBE_KXZ PROC	; DRAMsimII::Transaction::getProgramCounter, COMDAT
; _this$ = ecx

; 62   : 		PhysicalAddress getProgramCounter() const { return PC; }					///< get the program counter for this transaction

	mov	eax, DWORD PTR [ecx+96]
	mov	edx, DWORD PTR [ecx+100]
	ret	0
?getProgramCounter@Transaction@DRAMsimII@@QBE_KXZ ENDP	; DRAMsimII::Transaction::getProgramCounter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getDecodeDelay@Transaction@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getDecodeDelay@Transaction@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Transaction::getDecodeDelay, COMDAT
; _this$ = ecx

; 61   : 		tick getDecodeDelay() const { return decodeTime - enqueueTime; }			///< get the time it took before this transaction was decoded

	mov	eax, DWORD PTR [ecx+88]
	sub	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR [ecx+92]
	sbb	edx, DWORD PTR [ecx+20]
	ret	0
?getDecodeDelay@Transaction@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Transaction::getDecodeDelay
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\event.h
_TEXT	ENDS
;	COMDAT ?getDelayTime@Event@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getDelayTime@Event@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Event::getDelayTime, COMDAT
; _this$ = ecx

; 93   : 		tick getDelayTime() const { return startTime - enqueueTime; }

	mov	eax, DWORD PTR [ecx+24]
	sub	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR [ecx+28]
	sbb	edx, DWORD PTR [ecx+20]
	ret	0
?getDelayTime@Event@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Event::getDelayTime
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.h
_TEXT	ENDS
;	COMDAT ?getChannel@Address@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getChannel@Address@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Address::getChannel, COMDAT
; _this$ = eax

; 86   : 		unsigned getChannel() const { return channel; }

	mov	eax, DWORD PTR [eax+16]
	ret	0
?getChannel@Address@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Address::getChannel
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getPhysicalAddress@Address@DRAMsimII@@QBE_KXZ
_TEXT	SEGMENT
?getPhysicalAddress@Address@DRAMsimII@@QBE_KXZ PROC	; DRAMsimII::Address::getPhysicalAddress, COMDAT
; _this$ = ecx

; 85   : 		PhysicalAddress getPhysicalAddress() const { return physicalAddress; }

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	ret	0
?getPhysicalAddress@Address@DRAMsimII@@QBE_KXZ ENDP	; DRAMsimII::Address::getPhysicalAddress
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@15
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@15:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?8$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@YA_NABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@0@0@Z
_TEXT	SEGMENT
??$?8$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@YA_NABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@0@0@Z PROC ; std::operator==<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 86   : 	return (_Left.first == _Right.first && _Left.second == _Right.second);

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@operator@34
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator@34
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator@34
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR [eax+12]
	jne	SHORT $LN3@operator@34
	mov	ecx, DWORD PTR [ecx+16]
	cmp	ecx, DWORD PTR [eax+16]
	jne	SHORT $LN3@operator@34
	mov	eax, 1

; 87   : 	}

	ret	0
$LN3@operator@34:

; 86   : 	return (_Left.first == _Right.first && _Left.second == _Right.second);

	xor	eax, eax

; 87   : 	}

	ret	0
??$?8$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@YA_NABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@0@0@Z ENDP ; std::operator==<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU123@@Z
_TEXT	SEGMENT
??$_Construct@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU123@@Z PROC ; std::_Construct<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@4
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct@4:

; 53   : 	}

	ret	0
??$_Construct@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU123@@Z ENDP ; std::_Construct<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; __First$ = esi
; __Last$ = ecx
; __Dest$ = edx

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, ecx
	sub	eax, esi
	sar	eax, 3
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	edi
	mov	edi, eax
	mov	eax, edx
	sub	eax, edi

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	cmp	esi, ecx
	je	SHORT $LN7@Copy_backw@5
	sub	edx, ecx
	npad	6
$LL8@Copy_backw@5:
	mov	edi, DWORD PTR [ecx-8]
	sub	ecx, 8
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	cmp	ecx, esi
	jne	SHORT $LL8@Copy_backw@5
$LN7@Copy_backw@5:
	pop	edi

; 2690 : 	return _Result;
; 2691 : 	}

	ret	0
??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Uninit_mov
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Uninit_mov:
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU345@@Z
_TEXT	SEGMENT
?construct@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU345@@Z PROC ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@4
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct@4:

; 156  : 		}

	ret	0
?construct@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU345@@Z ENDP ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::construct
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	mov	eax, DWORD PTR __First$[esp-4]

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@4
	push	esi
	npad	7
$LL6@Uninit_fil@4:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@4
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_fil@4:
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@4
	pop	esi
$LN4@Uninit_fil@4:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = esi
; __Last$ = ecx
; __Dest$ = edx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, ecx
	sub	eax, esi
	sar	eax, 3
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	edi
	mov	edi, eax
	mov	eax, edx
	sub	eax, edi
	cmp	esi, ecx
	je	SHORT $LN11@Move_backw@3
	sub	edx, ecx
	npad	6
$LL12@Move_backw@3:
	mov	edi, DWORD PTR [ecx-8]
	sub	ecx, 8
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	cmp	ecx, esi
	jne	SHORT $LL12@Move_backw@3
$LN11@Move_backw@3:
	pop	edi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; __First$ = ecx
; __Last$ = esi
; __Dest$ = edx

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	lea	eax, DWORD PTR [edx+eax*8]

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	cmp	ecx, esi
	je	SHORT $LN7@Copy_opt@5
	sub	edx, ecx
	push	edi
$LL9@Copy_opt@5:
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	add	ecx, 8
	cmp	ecx, esi
	jne	SHORT $LL9@Copy_opt@5
	pop	edi
$LN7@Copy_opt@5:

; 2486 : 	return _Result;
; 2487 : 	}

	ret	0
??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >, COMDAT
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN34@Unchecked_@3
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN34@Unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z
_TEXT	SEGMENT
??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 3
	cmp	edi, eax
	jb	SHORT $LN1@operator@35
	call	__invalid_parameter_noinfo
$LN1@operator@35:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*8]

; 771  : 		}

	ret	0
??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@IABU120@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z
_TEXT	SEGMENT
$T323110 = -4						; size = 1
__Cat$323114 = -4					; size = 1
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
??$unchecked_uninitialized_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@IABU120@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; __First$ = edx

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	BYTE PTR $T323110[esp+4], 0
	mov	eax, DWORD PTR $T323110[esp+4]
	mov	ecx, DWORD PTR __Cat$323114[esp+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Val$[esp+12]
	call	??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 943  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$unchecked_uninitialized_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@IABU120@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@U?$pair@$$CBII@std@@U12@@std@@YAXPAU?$pair@$$CBII@0@ABU10@@Z
_TEXT	SEGMENT
??$_Construct@U?$pair@$$CBII@std@@U12@@std@@YAXPAU?$pair@$$CBII@0@ABU10@@Z PROC ; std::_Construct<std::pair<unsigned int const ,unsigned int>,std::pair<unsigned int const ,unsigned int> >, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@5
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct@5:

; 53   : 	}

	ret	0
??$_Construct@U?$pair@$$CBII@std@@U12@@std@@YAXPAU?$pair@$$CBII@0@ABU10@@Z ENDP ; std::_Construct<std::pair<unsigned int const ,unsigned int>,std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z PROC ; stdext::_Unchecked_move_backward<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; __First$ = esi
; __Last$ = ecx
; __Dest$ = edx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, ecx
	sub	eax, esi
	sar	eax, 3
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	edi
	mov	edi, eax
	mov	eax, edx
	sub	eax, edi
	cmp	esi, ecx
	je	SHORT $LN25@Unchecked_@4
	sub	edx, ecx
	npad	6
$LL26@Unchecked_@4:
	mov	edi, DWORD PTR [ecx-8]
	sub	ecx, 8
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	cmp	ecx, esi
	jne	SHORT $LL26@Unchecked_@4
$LN25@Unchecked_@4:
	pop	edi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z ENDP ; stdext::_Unchecked_move_backward<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@6
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@6:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T323255 = -16						; size = 4
$T323247 = -12						; size = 12
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 40					; 00000028H
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T323255[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T323247[esp+20]
	mov	DWORD PTR $T323255[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T323247[esp+20]
	push	ecx
	mov	DWORD PTR $T323247[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@4:
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*4]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@4:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@7
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@7:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T323278 = -16						; size = 4
$T323270 = -12						; size = 12
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 48					; 00000030H
	jae	SHORT $LN1@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T323278[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T323270[esp+20]
	mov	DWORD PTR $T323278[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T323270[esp+20]
	push	ecx
	mov	DWORD PTR $T323270[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@5:
$LN1@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	shl	edx, 4
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@5:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IPAU123@@Z
_TEXT	SEGMENT
$T323292 = -16						; size = 4
$T323284 = -12						; size = 12
??$_Allocate@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IPAU123@@Z PROC ; std::_Allocate<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 8
	jae	SHORT $LN1@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T323292[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T323284[esp+20]
	mov	DWORD PTR $T323292[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T323284[esp+20]
	push	ecx
	mov	DWORD PTR $T323284[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@6:
$LN1@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@6:
??$_Allocate@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IPAU123@@Z ENDP ; std::_Allocate<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z PROC ; stdext::unchecked_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; __First$ = ecx
; __Last$ = esi
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	lea	eax, DWORD PTR [edx+eax*8]
	cmp	ecx, esi
	je	SHORT $LN21@unchecked_@16
	sub	edx, ecx
	push	edi
$LL23@unchecked_@16:
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	add	ecx, 8
	cmp	ecx, esi
	jne	SHORT $LL23@unchecked_@16
	pop	edi
$LN21@unchecked_@16:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z ENDP ; stdext::unchecked_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@ABQAU120@@Z PROC ; std::_Construct<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *,std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@8
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@8:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *,std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@IPAU120@@Z
_TEXT	SEGMENT
$T323394 = -16						; size = 4
$T323386 = -12						; size = 12
??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@IPAU120@@Z PROC ; std::_Allocate<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN1@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T323394[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T323386[esp+20]
	mov	DWORD PTR $T323394[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T323386[esp+20]
	push	ecx
	mov	DWORD PTR $T323386[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@7:
$LN1@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@7:
??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@17
	push	esi
	npad	7
$LL19@unchecked_@17:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@17
	pop	esi
$LN17@unchecked_@17:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@I@std@@YAPAIIPAI@Z
_TEXT	SEGMENT
$T323511 = -16						; size = 4
$T323503 = -12						; size = 12
??$_Allocate@I@std@@YAPAIIPAI@Z PROC			; std::_Allocate<unsigned int>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@8

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T323511[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T323503[esp+20]
	mov	DWORD PTR $T323511[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T323503[esp+20]
	push	ecx
	mov	DWORD PTR $T323503[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@8:
$LN1@Allocate@8:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@8:
??$_Allocate@I@std@@YAPAIIPAI@Z ENDP			; std::_Allocate<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_iterator@IV?$allocator@I@std@@@1@0PAI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Umove@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_iterator@IV?$allocator@I@std@@@1@0PAI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN36@Umove
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN36@Umove:

; 1149 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Umove@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_iterator@IV?$allocator@I@std@@@1@0PAI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &>::_Ranit<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &>::_Ranit<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@36
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@36
$LN1@operator@36:
	call	__invalid_parameter_noinfo
$LN2@operator@36:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@2
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@2
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@2
$LN1@Vector_con@2:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@2:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU345@IABU345@@Z
_TEXT	SEGMENT
$T323752 = -4						; size = 1
__Cat$323755 = -4					; size = 1
?_Ufill@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU345@IABU345@@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	BYTE PTR $T323752[esp+4], 0
	mov	eax, DWORD PTR $T323752[esp+4]
	mov	ecx, DWORD PTR __Cat$323755[esp+4]
	push	eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]

; 1256 : 		}

	add	esp, 16					; 00000010H
	ret	0
?_Ufill@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU345@IABU345@@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@$$CBII@std@@@std@@QAEXPAU?$pair@$$CBII@2@ABU32@@Z
_TEXT	SEGMENT
?construct@?$allocator@U?$pair@$$CBII@std@@@std@@QAEXPAU?$pair@$$CBII@2@ABU32@@Z PROC ; std::allocator<std::pair<unsigned int const ,unsigned int> >::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@5
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct@5:

; 156  : 		}

	ret	0
?construct@?$allocator@U?$pair@$$CBII@std@@@std@@QAEXPAU?$pair@$$CBII@2@ABU32@@Z ENDP ; std::allocator<std::pair<unsigned int const ,unsigned int> >::construct
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@37
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@37
$LN3@operator@37:
	call	__invalid_parameter_noinfo
$LN4@operator@37:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@2
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@2
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@2
$LN3@Vector_ite@2:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@2:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN5@Make_iter@3
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN5@Make_iter@3
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN6@Make_iter@3
$LN5@Make_iter@3:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN6@Make_iter@3:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@6
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@6:

; 156  : 		}

	ret	0
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>::allocate, COMDAT

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	ecx, 1
	jmp	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@7
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@7:

; 156  : 		}

	ret	0
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>::allocate, COMDAT

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	ret	0
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z
_TEXT	SEGMENT
$T323962 = -16						; size = 4
$T323964 = -12						; size = 12
?allocate@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z PROC ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@3
	xor	ecx, ecx
$LN3@allocate@3:
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@3:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN3@allocate@3
	lea	eax, DWORD PTR $T323962[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T323964[esp+20]
	mov	DWORD PTR $T323962[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T323964[esp+20]
	push	ecx
	mov	DWORD PTR $T323964[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@3:
$LN11@allocate@3:
	int	3
?allocate@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ENDP ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@0@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::erase, COMDAT
; _this$ = edi

; 1028 : 		{	// erase [_First, _Last)

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp
	push	esi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	DWORD PTR [ebx], 0
	test	edi, edi
	je	SHORT $LN8@erase@2
	mov	eax, DWORD PTR __First_arg$[esp+12]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN8@erase@2
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN9@erase@2
$LN8@erase@2:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+12]
$LN9@erase@2:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	esi, DWORD PTR __Last_arg$[esp+12]
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [edi+12], esi
	ja	SHORT $LN24@erase@2
	cmp	esi, DWORD PTR [edi+16]
	jbe	SHORT $LN25@erase@2
$LN24@erase@2:
	call	__invalid_parameter_noinfo
	mov	esi, DWORD PTR __Last_arg$[esp+12]
$LN25@erase@2:

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN38@erase@2
	cmp	eax, ecx
	je	SHORT $LN39@erase@2
$LN38@erase@2:
	call	__invalid_parameter_noinfo
$LN39@erase@2:
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, esi
	je	SHORT $LN73@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ecx, DWORD PTR [edi+16]
	mov	eax, ecx
	sub	eax, esi
	sar	eax, 3
	lea	ebp, DWORD PTR [edx+eax*8]
	mov	eax, esi
	cmp	esi, ecx
	je	SHORT $LN66@erase@2
	sub	edx, esi
$LL68@erase@2:
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+eax+4], esi
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL68@erase@2
$LN66@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+16], ebp
$LN73@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	20					; 00000014H
?erase@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@0@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@2
	call	__invalid_parameter_noinfo
$LN6@end@2:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@2
	call	__invalid_parameter_noinfo
$LN6@begin@2:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@ABQAU342@@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@8
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@8:

; 156  : 		}

	ret	0
?construct@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>::construct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@I@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>::allocate, COMDAT

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	ret	0
?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@I@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@IHPBIABI@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@IHPBIABI@std@@QAE@XZ PROC			; std::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@IHPBIABI@std@@QAE@XZ ENDP			; std::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??8_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z
_TEXT	SEGMENT
??8_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 297  : 			return (_Mypos._Mynode() == _Right._Mynode());

	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx+4]
	sete	al

; 298  : 			}

	ret	0
??8_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::operator==
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@3
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@3
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@3
$LN1@Vector_con@3:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@3:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KI@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Carg$ = 20						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KI@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode, COMDAT
; __Val$ = esi

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	mov	ecx, 1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode@2
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [esi+8]
	movq	QWORD PTR [eax+24], xmm0
	mov	BYTE PTR [eax+32], dl
	mov	BYTE PTR [eax+33], 0
$LN4@Buynode@2:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	16					; 00000010H
?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KI@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode, COMDAT

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	mov	ecx, 1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode@3
	mov	DWORD PTR [eax], 0
$LN27@Buynode@3:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@3
	mov	DWORD PTR [ecx], 0
$LN37@Buynode@3:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@3
	mov	DWORD PTR [ecx], 0
$LN47@Buynode@3:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+32], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+33], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Carg$ = 20						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode, COMDAT
; __Val$ = esi

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode@4
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [esi+8]
	movq	QWORD PTR [eax+24], xmm0
	movq	xmm0, QWORD PTR [esi+16]
	movq	QWORD PTR [eax+32], xmm0
	mov	BYTE PTR [eax+40], dl
	mov	BYTE PTR [eax+41], 0
$LN4@Buynode@4:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	16					; 00000010H
?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode, COMDAT

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode@5
	mov	DWORD PTR [eax], 0
$LN27@Buynode@5:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@5
	mov	DWORD PTR [ecx], 0
$LN37@Buynode@5:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@5
	mov	DWORD PTR [ecx], 0
$LN47@Buynode@5:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+40], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+41], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode, COMDAT

; 1172 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1173 : 		int _Linkcnt = 0;
; 1174 : 
; 1175 : 		_TRY_BEGIN
; 1176 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

	test	eax, eax
	je	SHORT $LN26@Buynode@6
	mov	DWORD PTR [eax], eax
$LN26@Buynode@6:

; 1177 : 		++_Linkcnt;
; 1178 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN36@Buynode@6
	mov	DWORD PTR [ecx], eax
$LN36@Buynode@6:

; 1179 : 		_CATCH_ALL
; 1180 : 		if (0 < _Linkcnt)
; 1181 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1182 : 		this->_Alnod.deallocate(_Pnode, 1);
; 1183 : 		_RERAISE;
; 1184 : 		_CATCH_END
; 1185 : 		return (_Pnode);
; 1186 : 		}

	ret	0
?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ
_TEXT	SEGMENT
tv139 = -4						; size = 4
tv132 = -4						; size = 4
tv129 = -4						; size = 4
?load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::load_factor, COMDAT
; _this$ = eax

; 507  : 		{	// return elements per bucket

	push	ecx

; 508  : 		return ((float)size() / (float)bucket_count());

	mov	ecx, DWORD PTR [eax+32]
	fild	DWORD PTR [eax+32]
	test	ecx, ecx
	jge	SHORT $LN9@load_facto@2
	fadd	DWORD PTR __real@4f800000
$LN9@load_facto@2:
	mov	edx, DWORD PTR [eax+64]
	fild	DWORD PTR [eax+64]
	test	edx, edx
	jge	SHORT $LN10@load_facto@2
	fadd	DWORD PTR __real@4f800000
$LN10@load_facto@2:
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR tv129[esp+4]
	fld	DWORD PTR tv129[esp+4]

; 509  : 		}

	pop	ecx
	ret	0
?load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::load_factor
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBII@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBII@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBII@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Bidit@U?$pair@$$CBII@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Bidit@U?$pair@$$CBII@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &>::_Bidit<std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Bidit@U?$pair@$$CBII@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &>::_Bidit<std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z
_TEXT	SEGMENT
??9_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 302  : 			return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx+4]
	setne	al

; 303  : 			}

	ret	0
??9_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::operator!=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@3
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@3
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@3
$LN3@Vector_ite@3:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@3:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z
_TEXT	SEGMENT
??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Const_iterator<1>, COMDAT
; _this$ = esi
; __Pnode$ = eax
; __Plist$ = edi

; 176  : 			{	// construct with node pointer _Pnode

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax

; 177  : 			_SCL_SECURE_TRAITS_VALIDATE(_Plist != NULL);

	test	edi, edi
	jne	SHORT $LN1@Const_iter@3
	call	__invalid_parameter_noinfo
$LN1@Const_iter@3:

; 178  : 			this->_Set_container(_Plist);

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 179  : 			}

	mov	eax, esi
	ret	0
??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Const_iterator<1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z
_TEXT	SEGMENT
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill@2
	push	ebx
	npad	7
$LL21@Ufill@2:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL21@Ufill@2
	pop	ebx
$LN26@Ufill@2:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]

; 1256 : 		}

	ret	0
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ??0?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@@Z
_TEXT	SEGMENT
??0?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@@Z PROC ; std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>, COMDAT
; _this$ = eax
; __Traits$ = ecx

; 45   : 		{	// construct with specified comparator

	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax+4], dx

; 46   : 		}

	ret	0
??0?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@@Z ENDP ; std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??8?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 291  : 
; 292  :  #if _HAS_ITERATOR_DEBUGGING
; 293  : 			_Compat(_Right);
; 294  :  #else
; 295  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@38
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@38
$LN1@operator@38:
	call	__invalid_parameter_noinfo
$LN2@operator@38:

; 296  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 297  : 
; 298  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 299  : 			}

	ret	0
??8?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator==
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@I@std@@QAEPAII@Z
_TEXT	SEGMENT
$T325193 = -16						; size = 4
$T325199 = -12						; size = 12
?allocate@?$allocator@I@std@@QAEPAII@Z PROC		; std::allocator<unsigned int>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@4
	xor	ecx, ecx
$LN3@allocate@4:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@4:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate@4
	lea	eax, DWORD PTR $T325193[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T325199[esp+20]
	mov	DWORD PTR $T325193[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T325199[esp+20]
	push	ecx
	mov	DWORD PTR $T325199[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@4:
$LN11@allocate@4:
	int	3
?allocate@?$allocator@I@std@@QAEPAII@Z ENDP		; std::allocator<unsigned int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@3
	call	__invalid_parameter_noinfo
$LN6@end@3:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@3
	call	__invalid_parameter_noinfo
$LN6@begin@3:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ
_TEXT	SEGMENT
?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 549  : 		return (const_iterator(_Myhead, this));

	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 550  : 		}

	ret	0
?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ
_TEXT	SEGMENT
?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 539  : 		return (const_iterator(_Nextnode(_Myhead), this));

	mov	edx, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 540  : 		}

	ret	0
?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 303  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@39
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@39
$LN3@operator@39:
	call	__invalid_parameter_noinfo
$LN4@operator@39:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 304  : 			}

	ret	0
??9?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator!=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z
_TEXT	SEGMENT
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@40
	call	__invalid_parameter_noinfo
$LN1@operator@40:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 786  : 		}

	ret	0
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@IV?$allocator@I@std@@@std@@QBEABII@Z
_TEXT	SEGMENT
??A?$vector@IV?$allocator@I@std@@@std@@QBEABII@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@41
	call	__invalid_parameter_noinfo
$LN1@operator@41:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 771  : 		}

	ret	0
??A?$vector@IV?$allocator@I@std@@@std@@QBEABII@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ
_TEXT	SEGMENT
?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 392  : 		return (_List.end());

	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 393  : 		}

	ret	0
?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ
_TEXT	SEGMENT
?begin@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 382  : 		return (_List.begin());

	mov	edx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 383  : 		}

	ret	0
?begin@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
_TEXT	ENDS
;	COMDAT ?noshowpoint@std@@YAAAVios_base@1@AAV21@@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
?noshowpoint@std@@YAAAVios_base@1@AAV21@@Z PROC		; std::noshowpoint, COMDAT

; 230  : 	_Iosbase.unsetf(ios_base::showpoint);

	mov	eax, DWORD PTR __Iosbase$[esp-4]
	and	DWORD PTR [eax+16], -17			; ffffffefH

; 231  : 	return (_Iosbase);
; 232  : 	}

	ret	0
?noshowpoint@std@@YAAAVios_base@1@AAV21@@Z ENDP		; std::noshowpoint
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; __Last$ = edx
; __Dest$ = eax

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	mov	ecx, DWORD PTR __First$[esp-4]

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
	npad	7
$LL6@Uninit_cop@2:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_cop@2:
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z
_TEXT	SEGMENT
$T362765 = -4						; size = 1
__Cat$362769 = 8					; size = 1
__Last$ = 8						; size = 4
__Dest$ = 12						; size = 4
??$unchecked_uninitialized_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; __First$ = edx

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$362769[esp]
	mov	BYTE PTR $T362765[esp+4], 0
	mov	eax, DWORD PTR $T362765[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	call	??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 823  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$unchecked_uninitialized_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN20@operator@142
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@operator@142
$LN20@operator@142:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@142
$LN10@operator@142:
	xor	edx, edx
$LN11@operator@142:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@142
	test	eax, eax
	je	SHORT $LN16@operator@142
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@142
$LN16@operator@142:
	xor	eax, eax
$LN17@operator@142:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@142
$LN1@operator@142:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@142:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [esi+4], edi

; 165  : 		return (*this);

	mov	eax, esi
	pop	edi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+, COMDAT
; _this$ = eax

; 169  : 		{	// return this + integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 170  : 		_Myt _Tmp = *this;

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 171  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN22@operator@143
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN13@operator@143:
	mov	ecx, DWORD PTR __Off$[esp+8]
	lea	edi, DWORD PTR [edi+ecx*4]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN3@operator@143
	test	esi, esi
	je	SHORT $LN18@operator@143
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN19@operator@143
$LN22@operator@143:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN13@operator@143
$LN18@operator@143:
	xor	eax, eax
$LN19@operator@143:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN4@operator@143
$LN3@operator@143:
	call	__invalid_parameter_noinfo
$LN4@operator@143:
	mov	DWORD PTR [ebx+4], edi
	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 172  : 		}

	ret	8
??H?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T362911 = -4						; size = 1
__Last$ = 8						; size = 4
__Cat$362914 = 12					; size = 1
__Dest$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>,std::_Undefined_move_tag>, COMDAT
; __First$ = edx

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$362914[esp]
	mov	BYTE PTR $T362911[esp+4], 0
	mov	eax, DWORD PTR $T362911[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	call	??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 208  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Uninit_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PA_JPA_JV?$allocator@_J@std@@U_Undefined_move_tag@2@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PA_JPA_JV?$allocator@_J@std@@U_Undefined_move_tag@2@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<__int64 *,__int64 *,std::allocator<__int64>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Uninit_mov@7
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Uninit_mov@7:
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PA_JPA_JV?$allocator@_J@std@@U_Undefined_move_tag@2@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<__int64 *,__int64 *,std::allocator<__int64>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Equal@PBIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YA_NPBI0V?$_Vector_const_iterator@IV?$allocator@I@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 8
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Equal@PBIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YA_NPBI0V?$_Vector_const_iterator@IV?$allocator@I@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<unsigned int const *,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT

; 3043 : 	// for range checked iterators, this will make sure there is enough space
; 3044 : 	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);

	mov	edx, DWORD PTR __Last1$[esp-4]
	mov	eax, DWORD PTR __First2$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First1$[esp]
	push	ebp
	push	esi
	mov	esi, edx
	sub	esi, ebx
	sar	esi, 2
	push	edi
	mov	edi, DWORD PTR __First2$[esp+16]
	mov	ebp, eax
	test	eax, eax
	jne	SHORT $LN39@Equal@5
	call	__invalid_parameter_noinfo
	mov	edx, DWORD PTR __Last1$[esp+12]
	xor	eax, eax
$LN15@Equal@5:
	lea	esi, DWORD PTR [edi+esi*4]
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN5@Equal@5
	test	ebp, ebp
	je	SHORT $LN20@Equal@5
	mov	ebp, DWORD PTR [ebp]
	jmp	SHORT $LN21@Equal@5
$LN39@Equal@5:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN15@Equal@5
$LN20@Equal@5:
	xor	ebp, ebp
$LN21@Equal@5:
	cmp	esi, DWORD PTR [ebp+12]
	jae	SHORT $LN6@Equal@5
$LN5@Equal@5:
	call	__invalid_parameter_noinfo
	mov	edx, DWORD PTR __Last1$[esp+12]
$LN6@Equal@5:

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	mov	eax, ebx
	cmp	ebx, edx
	je	SHORT $LN31@Equal@5
	mov	ecx, DWORD PTR __First2$[esp+16]
	sub	ecx, ebx
	npad	3
$LL33@Equal@5:
	mov	esi, DWORD PTR [eax]
	cmp	esi, DWORD PTR [ecx+eax]
	jne	SHORT $LN37@Equal@5
	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL33@Equal@5
$LN31@Equal@5:
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx

; 3047 : 	}

	ret	0
$LN37@Equal@5:
	pop	edi
	pop	esi
	pop	ebp

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	xor	al, al
	pop	ebx

; 3047 : 	}

	ret	0
??$_Equal@PBIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YA_NPBI0V?$_Vector_const_iterator@IV?$allocator@I@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<unsigned int const *,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z
_TEXT	SEGMENT
$T363183 = -4						; size = 1
__Last$ = 8						; size = 4
__Cat$363186 = 12					; size = 1
__Dest$ = 12						; size = 4
??$_Unchecked_uninitialized_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; __First$ = edx

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$363186[esp]
	mov	BYTE PTR $T363183[esp+4], 0
	mov	eax, DWORD PTR $T363183[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	call	??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 865  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Unchecked_uninitialized_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<__int64,std::allocator<__int64> >,__int64 *,std::allocator<__int64> >, COMDAT
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN34@Unchecked_@16
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN34@Unchecked_@16:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<__int64,std::allocator<__int64> >,__int64 *,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$equal@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@00@Z
_TEXT	SEGMENT
$T363335 = -4						; size = 1
__First1$ = 8						; size = 8
$T363336 = 16						; size = 1
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
??$equal@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@00@Z PROC ; std::equal<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT

; 3055 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ecx

; 3056 : 	return _Equal(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _First2,
; 3057 : 		_Iter_random(_First1, _First2), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T363336[esp]
	mov	edx, DWORD PTR __First2$[esp+4]
	mov	BYTE PTR $T363335[esp+4], 0
	mov	eax, DWORD PTR $T363335[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+16]
	push	eax
	push	ecx
	push	edx
	call	??$_Equal@PBIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YA_NPBI0V?$_Vector_const_iterator@IV?$allocator@I@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<unsigned int const *,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >

; 3058 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$equal@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@00@Z ENDP ; std::equal<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@20
	call	__invalid_parameter_noinfo
$LN4@end@20:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@23
	call	__invalid_parameter_noinfo
$LN4@begin@23:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 571  : 		return (_TREE_CONST_ITERATOR(_Myhead));

	mov	edx, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 572  : 		}

	ret	0
?end@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 561  : 		return (_TREE_CONST_ITERATOR(_Lmost()));

	mov	edx, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 562  : 		}

	ret	0
?begin@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU234@00@Z
_TEXT	SEGMENT
$T363639 = -4						; size = 1
__Last$ = 8						; size = 4
__Cat$363643 = 12					; size = 1
__Ptr$ = 12						; size = 4
??$_Umove@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU234@00@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Umove<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; __First$ = edx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	ecx, DWORD PTR __Cat$363643[esp]
	mov	BYTE PTR $T363639[esp+4], 0
	mov	eax, DWORD PTR $T363639[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	call	??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 1149 : 		}

	add	esp, 16					; 00000010H
	ret	8
??$_Umove@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU234@00@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Umove<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Umove@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Umove@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Umove<std::_Vector_iterator<__int64,std::allocator<__int64> > >, COMDAT
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN36@Umove@9
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN36@Umove@9:

; 1149 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Umove@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Umove<std::_Vector_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?8IV?$allocator@I@std@@@std@@YA_NABV?$vector@IV?$allocator@I@std@@@0@0@Z
_TEXT	SEGMENT
$T363843 = -8						; size = 8
$T364038 = 8						; size = 1
$T364039 = 8						; size = 1
__Right$ = 8						; size = 4
??$?8IV?$allocator@I@std@@@std@@YA_NABV?$vector@IV?$allocator@I@std@@@0@0@Z PROC ; std::operator==<unsigned int,std::allocator<unsigned int> >, COMDAT
; __Left$ = esi

; 1308 : 	return (_Left.size() == _Right.size()
; 1309 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	mov	edx, DWORD PTR [esi+16]
	sub	edx, DWORD PTR [esi+12]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Right$[esp+8]
	mov	eax, DWORD PTR [ebx+16]
	push	edi
	mov	edi, DWORD PTR [ebx+12]
	mov	ecx, eax
	sub	ecx, edi
	xor	ecx, edx
	test	ecx, -4					; fffffffcH
	jne	SHORT $LN3@operator@144
	cmp	edi, eax
	jbe	SHORT $LN12@operator@144
	call	__invalid_parameter_noinfo
$LN12@operator@144:
	mov	eax, DWORD PTR [ebx]
	push	ebp
	mov	ebp, DWORD PTR [esi+16]
	mov	DWORD PTR $T363843[esp+20], eax
	cmp	DWORD PTR [esi+12], ebp
	jbe	SHORT $LN26@operator@144
	call	__invalid_parameter_noinfo
$LN26@operator@144:
	mov	ebx, DWORD PTR [esi+12]
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN40@operator@144
	call	__invalid_parameter_noinfo
$LN40@operator@144:
	mov	eax, DWORD PTR $T363843[esp+20]
	mov	BYTE PTR $T364038[esp+16], 0
	mov	ecx, DWORD PTR $T364038[esp+16]
	mov	edx, DWORD PTR $T364039[esp+16]
	push	ecx
	push	edx
	push	edi
	push	eax
	push	ebp
	push	ebx
	call	??$_Equal@PBIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YA_NPBI0V?$_Vector_const_iterator@IV?$allocator@I@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<unsigned int const *,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
	add	esp, 24					; 00000018H
	pop	ebp
	test	al, al
	je	SHORT $LN3@operator@144
	pop	edi
	mov	eax, 1
	pop	ebx

; 1310 : 	}

	add	esp, 8
	ret	0
$LN3@operator@144:
	pop	edi

; 1308 : 	return (_Left.size() == _Right.size()
; 1309 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	xor	eax, eax
	pop	ebx

; 1310 : 	}

	add	esp, 8
	ret	0
??$?8IV?$allocator@I@std@@@std@@YA_NABV?$vector@IV?$allocator@I@std@@@0@0@Z ENDP ; std::operator==<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@5
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@5:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@6
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@6:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBII@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBII@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,unsigned int> > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@7
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@7:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBII@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,unsigned int> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>, COMDAT
; _this$ = esi

; 39   : 		{	// construct with specified comparator

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Tmap_trait
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 40   : 		}

	mov	eax, esi
	ret	8

; 39   : 		{	// construct with specified comparator

$LN8@Tmap_trait:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 40   : 		}

	mov	eax, esi
	ret	8
??0?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>, COMDAT
; _this$ = esi

; 39   : 		{	// construct with specified comparator

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Tmap_trait@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 40   : 		}

	mov	eax, esi
	ret	8

; 39   : 		{	// construct with specified comparator

$LN8@Tmap_trait@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 40   : 		}

	mov	eax, esi
	ret	8
??0?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >, COMDAT
; _this$ = esi

; 47   : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@List_nod@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 48   : 		}

	mov	eax, esi
	ret	4

; 47   : 		{	// construct allocator from _Al

$LN8@List_nod@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 48   : 		}

	mov	eax, esi
	ret	4
??0?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PAU342@0ABU?$pair@$$CBII@2@@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PAU342@0ABU?$pair@$$CBII@2@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode, COMDAT
; __Val$ = esi

; 1191 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1192 : 		int _Linkcnt = 0;
; 1193 : 
; 1194 : 		_TRY_BEGIN
; 1195 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Next);

	test	eax, eax
	je	SHORT $LN27@Buynode@11
	mov	ecx, DWORD PTR __Next$[esp-4]
	mov	DWORD PTR [eax], ecx
$LN27@Buynode@11:

; 1196 : 		++_Linkcnt;
; 1197 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Prev);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@11
	mov	edx, DWORD PTR __Prev$[esp-4]
	mov	DWORD PTR [ecx], edx
$LN37@Buynode@11:

; 1198 : 		++_Linkcnt;
; 1199 : 		this->_Alval.construct(&_Myval(_Pnode), _Val);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@11
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], edx
$LN47@Buynode@11:

; 1200 : 		_CATCH_ALL
; 1201 : 		if (1 < _Linkcnt)
; 1202 : 			this->_Alptr.destroy(&_Prevnode(_Pnode));
; 1203 : 		if (0 < _Linkcnt)
; 1204 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1205 : 		this->_Alnod.deallocate(_Pnode, 1);
; 1206 : 		_RERAISE;
; 1207 : 		_CATCH_END
; 1208 : 		return (_Pnode);
; 1209 : 		}

	ret	8
?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PAU342@0ABU?$pair@$$CBII@2@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z
_TEXT	SEGMENT
__Plist$ = 8						; size = 4
??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<0>::_Const_iterator<0>, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 177  : 			_SCL_SECURE_TRAITS_VALIDATE(_Plist != NULL);
; 178  : 			this->_Set_container(_Plist);

	mov	edx, DWORD PTR __Plist$[esp-4]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 179  : 			}

	ret	4
??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<0>::_Const_iterator<0>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??F?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??F?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator--, COMDAT
; _this$ = esi

; 263  : 
; 264  :  #if _HAS_ITERATOR_DEBUGGING
; 265  : 			if (this->_Mycont == 0
; 266  : 				|| _Ptr == 0
; 267  : 				|| (_Ptr = _Prevnode(_Ptr))
; 268  : 					== ((_Myt *)this->_Mycont)->_Myhead)
; 269  : 				{
; 270  : 				_DEBUG_ERROR("list iterator not decrementable");
; 271  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 272  : 				}
; 273  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 274  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN3@operator@145
	call	__invalid_parameter_noinfo
$LN3@operator@145:

; 275  : 			_Ptr = _Prevnode(_Ptr);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 276  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], ecx
	test	eax, eax
	je	SHORT $LN13@operator@145
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@145
$LN13@operator@145:
	xor	eax, eax
$LN14@operator@145:
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN17@operator@145
	call	__invalid_parameter_noinfo
$LN17@operator@145:

; 277  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 278  : 
; 279  : 			return (*this);

	mov	eax, esi

; 280  : 			}

	ret	0
??F?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator--
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >, COMDAT
; _this$ = esi

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@Tree_nod
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 53   : 		}

	mov	eax, esi
	ret	4

; 52   : 		{	// construct traits from _Parg and allocator from _Al

$LN13@Tree_nod:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 53   : 		}

	mov	eax, esi
	ret	4
??0?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >, COMDAT
; _this$ = esi

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@Tree_nod@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 53   : 		}

	mov	eax, esi
	ret	4

; 52   : 		{	// construct traits from _Parg and allocator from _Al

$LN13@Tree_nod@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 53   : 		}

	mov	eax, esi
	ret	4
??0?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Container_base_aux_alloc_real<std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@8
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@8:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Container_base_aux_alloc_real<std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_ptr@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::_List_ptr<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_ptr<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >, COMDAT
; _this$ = esi

; 67   : 		{	// construct base, and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@List_ptr@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 68   : 		}

	mov	eax, esi
	ret	4

; 67   : 		{	// construct base, and allocator from _Al

$LN13@List_ptr@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 68   : 		}

	mov	eax, esi
	ret	4
??0?$_List_ptr@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::_List_ptr<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_ptr<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z
_TEXT	SEGMENT
__Plist$ = 8						; size = 4
??0?$_Iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<0>::_Iterator<0>, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 361  : 			{	// construct with node pointer _Pnode

	mov	edx, DWORD PTR __Plist$[esp-4]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 362  : 			}

	ret	4
??0?$_Iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<0>::_Iterator<0>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = esi

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN10@Dec
	call	__invalid_parameter_noinfo
$LN10@Dec:

; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], eax

; 336  :    				if (_Isnil(_Ptr))

	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LN1@Dec

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;

	jmp	__invalid_parameter_noinfo
$LN9@Dec:

; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN46@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN27@Dec
$LL28@Dec:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL28@Dec
$LN27@Dec:
	mov	DWORD PTR [esi+4], ecx

; 373  : 				}
; 374  : 			}

	ret	0
$LN46@Dec:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN3@Dec
	npad	3
$LL4@Dec:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [esi+4], eax
	mov	edx, eax
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LN2@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;

	jmp	__invalid_parameter_noinfo
$LN2@Dec:

; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [esi+4], eax
$LN1@Dec:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??F?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??F?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator--, COMDAT
; _this$ = esi

; 417  : 			--(*(_Mybase_iter *)this);

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN5@operator@146
	call	__invalid_parameter_noinfo
$LN5@operator@146:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], ecx
	test	eax, eax
	je	SHORT $LN15@operator@146
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN16@operator@146
$LN15@operator@146:
	xor	eax, eax
$LN16@operator@146:
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN19@operator@146
	call	__invalid_parameter_noinfo
$LN19@operator@146:

; 418  : 			return (*this);

	mov	eax, esi

; 419  : 			}

	ret	0
??F?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator--
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z
_TEXT	SEGMENT
??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::_Iterator<1>, COMDAT
; _this$ = esi
; __Pnode$ = eax
; __Plist$ = edi

; 361  : 			{	// construct with node pointer _Pnode

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	test	edi, edi
	jne	SHORT $LN3@Iterator@3
	call	__invalid_parameter_noinfo
$LN3@Iterator@3:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 362  : 			}

	mov	eax, esi
	ret	0
??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::_Iterator<1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = esi

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN10@Dec@2
	call	__invalid_parameter_noinfo
$LN10@Dec@2:

; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+41], 0
	je	SHORT $LN9@Dec@2

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], eax

; 336  :    				if (_Isnil(_Ptr))

	cmp	BYTE PTR [eax+41], 0
	je	SHORT $LN1@Dec@2

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;

	jmp	__invalid_parameter_noinfo
$LN9@Dec@2:

; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+41], 0
	jne	SHORT $LN46@Dec@2

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+41], 0
	jne	SHORT $LN27@Dec@2
$LL28@Dec@2:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+41], 0
	je	SHORT $LL28@Dec@2
$LN27@Dec@2:
	mov	DWORD PTR [esi+4], ecx

; 373  : 				}
; 374  : 			}

	ret	0
$LN46@Dec@2:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+41], 0
	jne	SHORT $LN3@Dec@2
	npad	3
$LL4@Dec@2:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec@2

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [esi+4], eax
	mov	edx, eax
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+41], 0
	je	SHORT $LL4@Dec@2
$LN3@Dec@2:

; 358  : 				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+41], 0
	je	SHORT $LN2@Dec@2

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;

	jmp	__invalid_parameter_noinfo
$LN2@Dec@2:

; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [esi+4], eax
$LN1@Dec@2:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Const_iterator<1>, COMDAT
; _this$ = eax

; 163  : 			{	// construct with null node pointer

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 164  : 			}

	ret	0
??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Const_iterator<1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >, COMDAT
; _this$ = esi

; 78   : 		{	// construct base, and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@Tree_ptr
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 79   : 		}

	mov	eax, esi
	ret	4

; 78   : 		{	// construct base, and allocator from _Al

$LN18@Tree_ptr:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 79   : 		}

	mov	eax, esi
	ret	4
??0?$_Tree_ptr@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >, COMDAT
; _this$ = esi

; 78   : 		{	// construct base, and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@Tree_ptr@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 79   : 		}

	mov	eax, esi
	ret	4

; 78   : 		{	// construct base, and allocator from _Al

$LN18@Tree_ptr@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 79   : 		}

	mov	eax, esi
	ret	4
??0?$_Tree_ptr@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z PROC ; std::_Vector_val<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_val<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@4
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@4:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ENDP ; std::_Vector_val<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_val<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_val@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_val@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::_List_val<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_val<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >, COMDAT
; _this$ = esi

; 85   : 		{	// construct base, and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@List_val@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 86   : 		}

	mov	eax, esi
	ret	4

; 85   : 		{	// construct base, and allocator from _Al

$LN18@List_val@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 86   : 		}

	mov	eax, esi
	ret	4
??0?$_List_val@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::_List_val<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_val<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??0_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 8
??0_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::_List_position, COMDAT
; _this$ = eax

; 269  : 			{

	mov	ecx, DWORD PTR __Iter$[esp-4]
	test	ecx, ecx
	je	SHORT $LN5@List_posit@2
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Iter$[esp]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 270  : 			}

	ret	8

; 269  : 			{

$LN5@List_posit@2:
	mov	edx, DWORD PTR __Iter$[esp]
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 270  : 			}

	ret	8
??0_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::_List_position
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::operator--, COMDAT
; _this$ = eax

; 286  : 			{	// predecrement

	push	esi
	mov	esi, eax

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CB_KI@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CB_KI@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::operator*, COMDAT
; _this$ = esi

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@147
	call	__invalid_parameter_noinfo

; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@147
$LN15@operator@147:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@147
$LN9@operator@147:
	xor	eax, eax
$LN10@operator@147:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN1@operator@147
	call	__invalid_parameter_noinfo
$LN1@operator@147:

; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [esi+4]
	add	eax, 16					; 00000010H

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CB_KI@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 217  : 			{	// construct with null node pointer

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 218  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::_Iterator<1>, COMDAT
; _this$ = eax

; 348  : 		_Iterator()

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 349  : 			{	// construct with null node
; 350  : 			}

	ret	0
??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::_Iterator<1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::operator--, COMDAT
; _this$ = eax

; 286  : 			{	// predecrement

	push	esi
	mov	esi, eax

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 217  : 			{	// construct with null node pointer

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 218  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::_Container_base_aux_alloc_real<std::allocator<unsigned int> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@9
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@9:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::_Container_base_aux_alloc_real<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >, COMDAT
; _this$ = esi

; 97   : 		{	// construct base, and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@Tree_val
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 98   : 		}

	mov	eax, esi
	ret	4

; 97   : 		{	// construct base, and allocator from _Al

$LN23@Tree_val:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 98   : 		}

	mov	eax, esi
	ret	4
??0?$_Tree_val@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@AB_K@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@AB_K@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN3@Lbound@2
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	push	edi
$LL4@Lbound@2:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	edi, DWORD PTR [ecx+20]
	cmp	edi, edx
	ja	SHORT $LN2@Lbound@2
	jb	SHORT $LN29@Lbound@2
	mov	edi, DWORD PTR [ecx+16]
	cmp	edi, esi
	jae	SHORT $LN2@Lbound@2
$LN29@Lbound@2:

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound@2
$LN2@Lbound@2:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound@2:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL4@Lbound@2
	pop	edi
	pop	esi
$LN3@Lbound@2:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	0
?_Lbound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@AB_K@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Lbound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Init, COMDAT
; _this$ = esi

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode
	mov	DWORD PTR [esi+24], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+33], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+28], 0

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_val<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >, COMDAT
; _this$ = esi

; 97   : 		{	// construct base, and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@Tree_val@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 98   : 		}

	mov	eax, esi
	ret	4

; 97   : 		{	// construct base, and allocator from _Al

$LN23@Tree_val@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 98   : 		}

	mov	eax, esi
	ret	4
??0?$_Tree_val@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_val<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@AB_K@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@AB_K@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+41], 0
	jne	SHORT $LN3@Lbound@3
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	push	edi
$LL4@Lbound@3:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	edi, DWORD PTR [ecx+20]
	cmp	edi, edx
	ja	SHORT $LN2@Lbound@3
	jb	SHORT $LN29@Lbound@3
	mov	edi, DWORD PTR [ecx+16]
	cmp	edi, esi
	jae	SHORT $LN2@Lbound@3
$LN29@Lbound@3:

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound@3
$LN2@Lbound@3:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound@3:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+41], 0
	je	SHORT $LL4@Lbound@3
	pop	edi
	pop	esi
$LN3@Lbound@3:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	0
?_Lbound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@AB_K@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Lbound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Init, COMDAT
; _this$ = esi

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode
	mov	DWORD PTR [esi+24], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+41], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+28], 0

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Init
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ
_TEXT	SEGMENT
?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 544  : 		return (iterator(_Myhead, this));

	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 545  : 		}

	ret	0
?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::end
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z$0
__ehfuncinfo$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
xdata$x	ENDS
;	COMDAT ??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >, COMDAT

; 441  : 		{	// construct empty list, allocator

	push	-1
	push	__ehhandler$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+16]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@list@2
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN24@list@2
$LN23@list@2:
	xor	eax, eax
$LN24@list@2:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+28], 0
	call	?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], 0

; 442  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_List_val@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KI@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KI@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator::operator*, COMDAT
; _this$ = esi

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@148
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@148
$LN17@operator@148:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@148
$LN11@operator@148:
	xor	eax, eax
$LN12@operator@148:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN3@operator@148
	call	__invalid_parameter_noinfo
$LN3@operator@148:
	mov	eax, DWORD PTR [esi+4]
	add	eax, 16					; 00000010H

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KI@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator++, COMDAT
; _this$ = esi

; 236  : 
; 237  :  #if _HAS_ITERATOR_DEBUGGING
; 238  : 			if (this->_Mycont == 0
; 239  : 				|| _Ptr == 0
; 240  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 241  : 				{
; 242  : 				_DEBUG_ERROR("list iterator not incrementable");
; 243  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 244  : 				}
; 245  :  #else
; 246  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@149
	call	__invalid_parameter_noinfo

; 247  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@149
$LN17@operator@149:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@149
$LN11@operator@149:
	xor	eax, eax
$LN12@operator@149:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN1@operator@149
	call	__invalid_parameter_noinfo
$LN1@operator@149:

; 248  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 249  : 
; 250  : 			_Ptr = _Nextnode(_Ptr);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+4], eax

; 251  : 			return (*this);

	mov	eax, esi

; 252  : 			}

	ret	0
??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator++
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@5
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@5:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::lower_bound, COMDAT
; ___$ReturnUdt$ = eax
; __Keyval$ = ecx

; 1003 : 		{	// find leftmost node not less than _Keyval in mutable tree

	push	ebx
	mov	ebx, DWORD PTR _this$[esp]

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	edx, DWORD PTR [ebx+24]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [edx+4]
	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN5@lower_boun@3
	push	ebp
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	npad	5
$LL6@lower_boun@3:
	mov	ebp, DWORD PTR [ecx+20]
	cmp	ebp, esi
	ja	SHORT $LN4@lower_boun@3
	jb	SHORT $LN44@lower_boun@3
	mov	ebp, DWORD PTR [ecx+16]
	cmp	ebp, edi
	jae	SHORT $LN4@lower_boun@3
$LN44@lower_boun@3:
	mov	ecx, DWORD PTR [ecx+8]
	jmp	SHORT $LN3@lower_boun@3
$LN4@lower_boun@3:
	mov	edx, ecx
	mov	ecx, DWORD PTR [ecx]
$LN3@lower_boun@3:
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL6@lower_boun@3
	pop	edi
	pop	ebp
$LN5@lower_boun@3:
	mov	ecx, DWORD PTR [ebx]
	pop	esi
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 1005 : 		}

	ret	4
?lower_bound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::lower_bound
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >, COMDAT

; 509  : 		{	// construct empty tree

	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+16]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN28@Tree
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN29@Tree
$LN28@Tree:
	xor	eax, eax
$LN29@Tree:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+28], 0

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode
	mov	DWORD PTR [esi+24], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+28], 0

; 511  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::lower_bound, COMDAT
; ___$ReturnUdt$ = eax
; __Keyval$ = ecx

; 1003 : 		{	// find leftmost node not less than _Keyval in mutable tree

	push	ebx
	mov	ebx, DWORD PTR _this$[esp]

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	edx, DWORD PTR [ebx+24]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [edx+4]
	cmp	BYTE PTR [ecx+41], 0
	jne	SHORT $LN5@lower_boun@4
	push	ebp
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	npad	5
$LL6@lower_boun@4:
	mov	ebp, DWORD PTR [ecx+20]
	cmp	ebp, esi
	ja	SHORT $LN4@lower_boun@4
	jb	SHORT $LN44@lower_boun@4
	mov	ebp, DWORD PTR [ecx+16]
	cmp	ebp, edi
	jae	SHORT $LN4@lower_boun@4
$LN44@lower_boun@4:
	mov	ecx, DWORD PTR [ecx+8]
	jmp	SHORT $LN3@lower_boun@4
$LN4@lower_boun@4:
	mov	edx, ecx
	mov	ecx, DWORD PTR [ecx]
$LN3@lower_boun@4:
	cmp	BYTE PTR [ecx+41], 0
	je	SHORT $LL6@lower_boun@4
	pop	edi
	pop	ebp
$LN5@lower_boun@4:
	mov	ecx, DWORD PTR [ebx]
	pop	esi
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 1005 : 		}

	ret	4
?lower_bound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::lower_bound
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >, COMDAT

; 509  : 		{	// construct empty tree

	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+16]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN28@Tree@2
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN29@Tree@2
$LN28@Tree@2:
	xor	eax, eax
$LN29@Tree@2:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+28], 0

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode
	mov	DWORD PTR [esi+24], eax
	mov	BYTE PTR [eax+41], 1
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+28], 0

; 511  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ
_TEXT	SEGMENT
?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 387  : 		return (_List.end());

	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 388  : 		}

	ret	0
?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::end
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::operator*, COMDAT
; _this$ = esi

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@150
	call	__invalid_parameter_noinfo

; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@150
$LN15@operator@150:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@150
$LN9@operator@150:
	xor	eax, eax
$LN10@operator@150:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN1@operator@150
	call	__invalid_parameter_noinfo
$LN1@operator@150:

; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [esi+4]
	add	eax, 16					; 00000010H

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV012@H@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 256  : 			_Myt_iter _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 257  : 			++*this;

	test	eax, eax
	jne	SHORT $LN19@operator@151
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@151
$LN19@operator@151:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@151
$LN13@operator@151:
	xor	eax, eax
$LN14@operator@151:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN3@operator@151
	call	__invalid_parameter_noinfo
$LN3@operator@151:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+4], ecx

; 258  : 			return (_Tmp);

	mov	eax, edi

; 259  : 			}

	ret	0
??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV012@H@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEABU?$pair@$$CBII@2@XZ
_TEXT	SEGMENT
??D?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEABU?$pair@$$CBII@2@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator*, COMDAT
; _this$ = esi

; 212  : 
; 213  :  #if _HAS_ITERATOR_DEBUGGING
; 214  : 			if (this->_Mycont == 0
; 215  : 				|| _Ptr == 0
; 216  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 217  : 				{
; 218  : 				_DEBUG_ERROR("list iterator not dereferencable");
; 219  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 220  : 				}
; 221  :  #else
; 222  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@152
	call	__invalid_parameter_noinfo

; 223  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@152
$LN17@operator@152:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@152
$LN11@operator@152:
	xor	eax, eax
$LN12@operator@152:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN1@operator@152
	call	__invalid_parameter_noinfo
$LN1@operator@152:

; 224  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 225  : 
; 226  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [esi+4]
	add	eax, 8

; 227  : 			}

	ret	0
??D?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEABU?$pair@$$CBII@2@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 571  : 		return (_TREE_CONST_ITERATOR(_Myhead));

	mov	edx, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 572  : 		}

	ret	0
?end@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 561  : 		return (_TREE_CONST_ITERATOR(_Lmost()));

	mov	edx, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 562  : 		}

	ret	0
?begin@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 8
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::forward_iterator_tag>, COMDAT

; 2991 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	esi

; 2992 : 	for (; _First1 != _Last1; ++_First1, ++_First2)

$LL9@Equal@8:
	mov	eax, DWORD PTR __First1$[esp]
	test	eax, eax
	je	SHORT $LN13@Equal@8
	cmp	eax, DWORD PTR __Last1$[esp]
	je	SHORT $LN14@Equal@8
$LN13@Equal@8:
	call	__invalid_parameter_noinfo
$LN14@Equal@8:
	mov	eax, DWORD PTR __First1$[esp+4]
	cmp	eax, DWORD PTR __Last1$[esp+4]
	je	$LN2@Equal@8

; 2993 : 		if (!(*_First1 == *_First2))

	mov	eax, DWORD PTR __First2$[esp]
	test	eax, eax
	jne	SHORT $LN56@Equal@8
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First2$[esp]
	test	eax, eax
	je	SHORT $LN29@Equal@8
$LN56@Equal@8:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN30@Equal@8
$LN29@Equal@8:
	xor	eax, eax
$LN30@Equal@8:
	mov	ecx, DWORD PTR __First2$[esp+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN21@Equal@8
	call	__invalid_parameter_noinfo
$LN21@Equal@8:
	mov	esi, DWORD PTR __First2$[esp+4]
	mov	eax, DWORD PTR __First1$[esp]
	add	esi, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN55@Equal@8
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First1$[esp]
	test	eax, eax
	je	SHORT $LN43@Equal@8
$LN55@Equal@8:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN44@Equal@8
$LN43@Equal@8:
	xor	eax, eax
$LN44@Equal@8:
	mov	edx, DWORD PTR __First1$[esp+4]
	cmp	edx, DWORD PTR [eax+24]
	jne	SHORT $LN35@Equal@8
	call	__invalid_parameter_noinfo
$LN35@Equal@8:
	mov	eax, DWORD PTR __First1$[esp+4]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN51@Equal@8
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [esi+4]
	jne	SHORT $LN51@Equal@8
	mov	eax, DWORD PTR [eax+24]
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN51@Equal@8
	lea	esi, DWORD PTR __First1$[esp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Inc
	lea	esi, DWORD PTR __First2$[esp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Inc
	jmp	$LL9@Equal@8
$LN51@Equal@8:

; 2994 : 			return (false);

	xor	al, al
	pop	esi

; 2996 : 	}

	ret	0
$LN2@Equal@8:

; 2995 : 	return (true);

	mov	al, 1
	pop	esi

; 2996 : 	}

	ret	0
??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 8
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::forward_iterator_tag>, COMDAT

; 2991 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	esi

; 2992 : 	for (; _First1 != _Last1; ++_First1, ++_First2)

$LL9@Equal@9:
	mov	eax, DWORD PTR __First1$[esp]
	test	eax, eax
	je	SHORT $LN13@Equal@9
	cmp	eax, DWORD PTR __Last1$[esp]
	je	SHORT $LN14@Equal@9
$LN13@Equal@9:
	call	__invalid_parameter_noinfo
$LN14@Equal@9:
	mov	eax, DWORD PTR __First1$[esp+4]
	cmp	eax, DWORD PTR __Last1$[esp+4]
	je	$LN2@Equal@9

; 2993 : 		if (!(*_First1 == *_First2))

	mov	eax, DWORD PTR __First2$[esp]
	test	eax, eax
	jne	SHORT $LN60@Equal@9
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First2$[esp]
	test	eax, eax
	je	SHORT $LN29@Equal@9
$LN60@Equal@9:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN30@Equal@9
$LN29@Equal@9:
	xor	eax, eax
$LN30@Equal@9:
	mov	ecx, DWORD PTR __First2$[esp+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN21@Equal@9
	call	__invalid_parameter_noinfo
$LN21@Equal@9:
	mov	esi, DWORD PTR __First2$[esp+4]
	mov	eax, DWORD PTR __First1$[esp]
	add	esi, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN59@Equal@9
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First1$[esp]
	test	eax, eax
	je	SHORT $LN43@Equal@9
$LN59@Equal@9:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN44@Equal@9
$LN43@Equal@9:
	xor	eax, eax
$LN44@Equal@9:
	mov	edx, DWORD PTR __First1$[esp+4]
	cmp	edx, DWORD PTR [eax+24]
	jne	SHORT $LN35@Equal@9
	call	__invalid_parameter_noinfo
$LN35@Equal@9:
	mov	eax, DWORD PTR __First1$[esp+4]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN55@Equal@9
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [esi+4]
	jne	SHORT $LN55@Equal@9
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR [esi+8]
	jne	SHORT $LN55@Equal@9
	mov	edx, DWORD PTR [eax+28]
	cmp	edx, DWORD PTR [esi+12]
	jne	SHORT $LN55@Equal@9
	mov	eax, DWORD PTR [eax+32]
	cmp	eax, DWORD PTR [esi+16]
	jne	SHORT $LN55@Equal@9
	lea	esi, DWORD PTR __First1$[esp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Inc
	lea	esi, DWORD PTR __First2$[esp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Inc
	jmp	$LL9@Equal@9
$LN55@Equal@9:

; 2994 : 			return (false);

	xor	al, al
	pop	esi

; 2996 : 	}

	ret	0
$LN2@Equal@9:

; 2995 : 	return (true);

	mov	al, 1
	pop	esi

; 2996 : 	}

	ret	0
??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00@Z
_TEXT	SEGMENT
$T407483 = -4						; size = 1
__First1$ = 8						; size = 8
$T407484 = 16						; size = 1
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00@Z PROC ; std::equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>, COMDAT

; 3055 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ecx

; 3056 : 	return _Equal(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _First2,
; 3057 : 		_Iter_random(_First1, _First2), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T407484[esp]
	mov	edx, DWORD PTR __First2$[esp+4]
	mov	BYTE PTR $T407483[esp+4], 0
	mov	eax, DWORD PTR $T407483[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+20]
	push	edx
	push	eax
	push	ecx
	call	??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::forward_iterator_tag>

; 3058 : 	}

	add	esp, 36					; 00000024H
	ret	0
??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00@Z ENDP ; std::equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00@Z
_TEXT	SEGMENT
$T407512 = -4						; size = 1
__First1$ = 8						; size = 8
$T407513 = 16						; size = 1
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00@Z PROC ; std::equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>, COMDAT

; 3055 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ecx

; 3056 : 	return _Equal(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _First2,
; 3057 : 		_Iter_random(_First1, _First2), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T407513[esp]
	mov	edx, DWORD PTR __First2$[esp+4]
	mov	BYTE PTR $T407512[esp+4], 0
	mov	eax, DWORD PTR $T407512[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+20]
	push	edx
	push	eax
	push	ecx
	call	??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::forward_iterator_tag>

; 3058 : 	}

	add	esp, 36					; 00000024H
	ret	0
??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00@Z ENDP ; std::equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??C?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPBU?$pair@$$CBII@2@XZ
_TEXT	SEGMENT
??C?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPBU?$pair@$$CBII@2@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator->, COMDAT
; _this$ = esi

; 231  : 			return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN19@operator@247
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@247
$LN19@operator@247:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@247
$LN13@operator@247:
	xor	eax, eax
$LN14@operator@247:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN3@operator@247
	call	__invalid_parameter_noinfo
$LN3@operator@247:
	mov	eax, DWORD PTR [esi+4]
	add	eax, 8

; 232  : 			}

	ret	0
??C?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPBU?$pair@$$CBII@2@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator->
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??$?8V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
$T407784 = -4						; size = 1
$T407785 = -4						; size = 1
??$?8V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z PROC ; std::operator==<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 1454 : 	{	// test for _Tree equality

	push	ecx

; 1455 : 	return (_Left.size() == _Right.size()
; 1456 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	mov	edx, DWORD PTR [ecx+28]
	cmp	edx, DWORD PTR [eax+28]
	jne	SHORT $LN3@operator@248
	mov	edx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [edx]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	BYTE PTR $T407784[esp+16], 0
	mov	ebx, DWORD PTR $T407784[esp+16]
	push	ebx
	mov	ebx, DWORD PTR $T407785[esp+20]
	push	ebx
	push	edx
	push	esi
	push	eax
	push	ecx
	push	edi
	push	ecx
	call	??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::forward_iterator_tag>
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebx
	test	al, al
	je	SHORT $LN3@operator@248
	mov	eax, 1

; 1457 : 	}

	pop	ecx
	ret	0
$LN3@operator@248:

; 1455 : 	return (_Left.size() == _Right.size()
; 1456 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	xor	eax, eax

; 1457 : 	}

	pop	ecx
	ret	0
??$?8V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z ENDP ; std::operator==<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?8V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
$T408011 = -4						; size = 1
$T408012 = -4						; size = 1
??$?8V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z PROC ; std::operator==<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 1454 : 	{	// test for _Tree equality

	push	ecx

; 1455 : 	return (_Left.size() == _Right.size()
; 1456 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	mov	edx, DWORD PTR [ecx+28]
	cmp	edx, DWORD PTR [eax+28]
	jne	SHORT $LN3@operator@249
	mov	edx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [edx]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	BYTE PTR $T408011[esp+16], 0
	mov	ebx, DWORD PTR $T408011[esp+16]
	push	ebx
	mov	ebx, DWORD PTR $T408012[esp+20]
	push	ebx
	push	edx
	push	esi
	push	eax
	push	ecx
	push	edi
	push	ecx
	call	??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::forward_iterator_tag>
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebx
	test	al, al
	je	SHORT $LN3@operator@249
	mov	eax, 1

; 1457 : 	}

	pop	ecx
	ret	0
$LN3@operator@249:

; 1455 : 	return (_Left.size() == _Right.size()
; 1456 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	xor	eax, eax

; 1457 : 	}

	pop	ecx
	ret	0
??$?8V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z ENDP ; std::operator==<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 554  : 		return (iterator(_Where._Ptr, this));

	mov	eax, DWORD PTR __Where$[esp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	test	edi, edi
	jne	SHORT $LN5@Make_iter@18
	call	__invalid_parameter_noinfo
$LN5@Make_iter@18:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 555  : 		}

	ret	8
?_Make_iter@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Make_iter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ
_TEXT	SEGMENT
?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 534  : 		return (iterator(_Nextnode(_Myhead), this));

	mov	edx, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 535  : 		}

	ret	0
?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Get_iter@_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABV56@@Z
_TEXT	SEGMENT
?_Get_iter@_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABV56@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::_Get_iter, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __List$ = edi

; 281  : 			// reparent the iterator
; 282  : 			return (_Myiterator(_Mypos._Mynode(), &_List));

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], ecx
	test	edi, edi
	jne	SHORT $LN7@Get_iter@2
	call	__invalid_parameter_noinfo
$LN7@Get_iter@2:
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [esi], edx
	mov	eax, esi

; 283  : 			}

	ret	0
?_Get_iter@_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABV56@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::_Get_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator::operator--, COMDAT
; _this$ = eax

; 487  : 			{	// predecrement

	push	esi
	mov	esi, eax

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator::operator--, COMDAT
; _this$ = eax

; 487  : 			{	// predecrement

	push	esi
	mov	esi, eax

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z
_TEXT	SEGMENT
$T408202 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase, COMDAT
; _this$ = edi

; 786  : 		{	// erase element at _Where

	sub	esp, 8

; 787  : 
; 788  :  #if _HAS_ITERATOR_DEBUGGING
; 789  : 		if (_Where._Mycont != this || _Where._Ptr == _Myhead)
; 790  : 			_DEBUG_ERROR("list erase iterator outside range");
; 791  : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 792  : 		_Orphan_ptr(*this, _Pnode);
; 793  : 
; 794  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 795  : 		_Nodeptr _Pnode = (_Where++)._Mynode();

	mov	eax, DWORD PTR __Where$[esp+4]
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+8]
	push	esi
	mov	esi, DWORD PTR __Where$[esp+16]
	mov	DWORD PTR $T408202[esp+16], eax
	test	eax, eax
	jne	SHORT $LN54@erase@11
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp+12]
	test	eax, eax
	je	SHORT $LN16@erase@11
$LN54@erase@11:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@erase@11
$LN16@erase@11:
	xor	eax, eax
$LN17@erase@11:
	mov	ecx, DWORD PTR __Where$[esp+16]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN6@erase@11
	call	__invalid_parameter_noinfo
$LN6@erase@11:
	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Where$[esp+16], eax

; 796  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 797  : 
; 798  : 		if (_Pnode != _Myhead)

	cmp	esi, DWORD PTR [edi+20]
	je	SHORT $LN1@erase@11

; 799  : 			{	// not list head, safe to erase
; 800  : 			_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], edx

; 801  : 			_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]

; 802  : 			this->_Alnod.destroy(_Pnode);
; 803  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	esi
	mov	DWORD PTR [eax+4], ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 804  : 			--_Mysize;

	dec	DWORD PTR [edi+24]
$LN1@erase@11:

; 805  : 			}
; 806  : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR __Where$[esp+16]
	mov	DWORD PTR [ebx], eax

; 807  : 		}

	pop	esi
	mov	DWORD PTR [ebx+4], edx
	mov	eax, ebx
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH
?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator++, COMDAT
; _this$ = esi

; 404  : 			++(*(_Mybase_iter *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN19@operator@250
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@250
$LN19@operator@250:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@250
$LN13@operator@250:
	xor	eax, eax
$LN14@operator@250:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN3@operator@250
	call	__invalid_parameter_noinfo
$LN3@operator@250:
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+4], eax

; 405  : 			return (*this);

	mov	eax, esi

; 406  : 			}

	ret	0
??E?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator++
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Get_iter_from_vec@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABU_List_position@12@@Z
_TEXT	SEGMENT
?_Get_iter_from_vec@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABU_List_position@12@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Get_iter_from_vec, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi
; __Pos$ = eax

; 312  : 	{

	push	edi

; 313  : 	return (_Pos._Get_iter(_List));

	mov	edi, ecx
	add	edi, 8
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], ecx
	jne	SHORT $LN9@Get_iter_f@2
	call	__invalid_parameter_noinfo
$LN9@Get_iter_f@2:
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [esi], edx
	mov	eax, esi
	pop	edi

; 314  : 	}

	ret	0
?_Get_iter_from_vec@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABU_List_position@12@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Get_iter_from_vec
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator::operator*, COMDAT
; _this$ = esi

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@251
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@251
$LN17@operator@251:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@251
$LN11@operator@251:
	xor	eax, eax
$LN12@operator@251:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN3@operator@251
	call	__invalid_parameter_noinfo
$LN3@operator@251:
	mov	eax, DWORD PTR [esi+4]
	add	eax, 16					; 00000010H

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??D?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEAAU?$pair@$$CBII@2@XZ
_TEXT	SEGMENT
??D?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEAAU?$pair@$$CBII@2@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator*, COMDAT
; _this$ = esi

; 394  : 			return ((reference)**(_Mybase_iter *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN19@operator@252
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@252
$LN19@operator@252:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@252
$LN13@operator@252:
	xor	eax, eax
$LN14@operator@252:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN3@operator@252
	call	__invalid_parameter_noinfo
$LN3@operator@252:
	mov	eax, DWORD PTR [esi+4]
	add	eax, 8

; 395  : 			}

	ret	0
??D?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEAAU?$pair@$$CBII@2@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z
_TEXT	SEGMENT
$T408783 = -16						; size = 4
$T408550 = -16						; size = 8
__Where$ = -8						; size = 8
tv540 = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Keyval$ = 16						; size = 4
?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound, COMDAT

; 638  : 		size_type _Bucket = _Hashval(_Keyval);

	mov	eax, DWORD PTR __Keyval$[esp-4]
	mov	ecx, DWORD PTR [eax]
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+16]
	push	ebp
	push	esi
	push	edi
	push	127773					; 0001f31dH
	push	ecx
	call	_ldiv
	imul	edx, 16807				; 000041a7H
	imul	eax, 2836				; 00000b14H
	add	esp, 8
	sub	edx, eax
	jns	SHORT $LN14@lower_boun@5
	add	edx, 2147483647				; 7fffffffH
$LN14@lower_boun@5:
	mov	eax, DWORD PTR [ebx+60]
	mov	esi, eax
	and	esi, edx
	cmp	DWORD PTR [ebx+64], esi
	ja	SHORT $LN9@lower_boun@5
	shr	eax, 1
	or	edx, -1
	sub	edx, eax
	add	esi, edx
$LN9@lower_boun@5:

; 639  : 		iterator _Where;
; 640  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	mov	eax, DWORD PTR [ebx+52]
	sub	eax, DWORD PTR [ebx+48]
	sar	eax, 3
	cmp	esi, eax
	jb	SHORT $LN27@lower_boun@5
	call	__invalid_parameter_noinfo
$LN27@lower_boun@5:
	mov	ecx, DWORD PTR [ebx+48]
	mov	edi, DWORD PTR [ecx+esi*8+4]
	lea	ebp, DWORD PTR [ebx+8]
	mov	DWORD PTR tv540[esp+28], ebp
	test	ebp, ebp
	jne	SHORT $LN40@lower_boun@5
	call	__invalid_parameter_noinfo
$LN40@lower_boun@5:
	mov	ebp, DWORD PTR [ebp]
	inc	esi
	mov	DWORD PTR __Where$[esp+32], ebp
	mov	DWORD PTR __Where$[esp+36], edi

; 642  : 				return (this->comp(_Keyval,
; 643  : 					this->_Kfn(*_Where)) ? end() : _Where);

	mov	DWORD PTR $T408783[esp+32], esi
$LL58@lower_boun@5:
	mov	edx, DWORD PTR [ebx+52]
	sub	edx, DWORD PTR [ebx+48]
	sar	edx, 3
	cmp	esi, edx
	jb	SHORT $LN70@lower_boun@5

; 639  : 		iterator _Where;
; 640  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	call	__invalid_parameter_noinfo
$LN70@lower_boun@5:
	mov	eax, DWORD PTR [ebx+48]
	cmp	DWORD PTR [eax+esi*8+4], edi
	je	$LN2@lower_boun@5

; 641  : 			if (!this->comp(this->_Kfn(*_Where), _Keyval))

	test	ebp, ebp
	jne	SHORT $LN171@lower_boun@5
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN96@lower_boun@5:
	cmp	edi, DWORD PTR [eax+20]
	jne	SHORT $LN85@lower_boun@5
	call	__invalid_parameter_noinfo
$LN85@lower_boun@5:
	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR __Keyval$[esp+28]
	cmp	ecx, DWORD PTR [esi]
	je	SHORT $LN168@lower_boun@5

; 639  : 		iterator _Where;
; 640  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	test	ebp, ebp
	jne	SHORT $LN170@lower_boun@5
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN65@lower_boun@5:
	cmp	edi, DWORD PTR [eax+20]
	jne	SHORT $LN54@lower_boun@5
	call	__invalid_parameter_noinfo
$LN54@lower_boun@5:
	mov	edi, DWORD PTR [edi]
	mov	esi, DWORD PTR $T408783[esp+32]
	jmp	SHORT $LL58@lower_boun@5
$LN171@lower_boun@5:

; 641  : 			if (!this->comp(this->_Kfn(*_Where), _Keyval))

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN96@lower_boun@5
$LN170@lower_boun@5:

; 639  : 		iterator _Where;
; 640  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN65@lower_boun@5
$LN168@lower_boun@5:
	mov	DWORD PTR __Where$[esp+36], edi

; 642  : 				return (this->comp(_Keyval,
; 643  : 					this->_Kfn(*_Where)) ? end() : _Where);

	test	ebp, ebp
	jne	SHORT $LN169@lower_boun@5
	call	__invalid_parameter_noinfo
$LN120@lower_boun@5:
	cmp	edi, DWORD PTR [ebp+20]
	jne	SHORT $LN109@lower_boun@5
	call	__invalid_parameter_noinfo
$LN109@lower_boun@5:
	mov	edx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [edi+8]
	je	SHORT $LN7@lower_boun@5
	mov	eax, DWORD PTR tv540[esp+28]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	DWORD PTR $T408550[esp+36], ecx
	lea	ecx, DWORD PTR $T408550[esp+32]
	mov	DWORD PTR $T408550[esp+32], edx
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 645  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN169@lower_boun@5:

; 642  : 				return (this->comp(_Keyval,
; 643  : 					this->_Kfn(*_Where)) ? end() : _Where);

	mov	ebp, DWORD PTR [ebp]
	jmp	SHORT $LN120@lower_boun@5
$LN7@lower_boun@5:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	lea	ecx, DWORD PTR __Where$[esp+32]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 645  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN2@lower_boun@5:

; 644  : 		return (end());

	mov	ecx, DWORD PTR tv540[esp+28]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR __Where$[esp+36], edi

; 645  : 		}

	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx
	pop	ebx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z
_TEXT	SEGMENT
$T445167 = -16						; size = 4
$T444964 = -16						; size = 8
__Where$ = -8						; size = 8
tv508 = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Keyval$ = 16						; size = 4
?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound, COMDAT

; 649  : 		size_type _Bucket = _Hashval(_Keyval);

	mov	eax, DWORD PTR __Keyval$[esp-4]
	mov	ecx, DWORD PTR [eax]
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+16]
	push	ebp
	push	esi
	push	edi
	push	127773					; 0001f31dH
	push	ecx
	call	_ldiv
	imul	edx, 16807				; 000041a7H
	imul	eax, 2836				; 00000b14H
	add	esp, 8
	sub	edx, eax
	jns	SHORT $LN14@lower_boun@6
	add	edx, 2147483647				; 7fffffffH
$LN14@lower_boun@6:
	mov	eax, DWORD PTR [ebx+60]
	mov	esi, eax
	and	esi, edx
	cmp	DWORD PTR [ebx+64], esi
	ja	SHORT $LN9@lower_boun@6
	shr	eax, 1
	or	edx, -1
	sub	edx, eax
	add	esi, edx
$LN9@lower_boun@6:

; 650  : 		const_iterator _Where;
; 651  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	mov	eax, DWORD PTR [ebx+52]
	sub	eax, DWORD PTR [ebx+48]
	sar	eax, 3
	cmp	esi, eax
	jb	SHORT $LN25@lower_boun@6
	call	__invalid_parameter_noinfo
$LN25@lower_boun@6:
	mov	ecx, DWORD PTR [ebx+48]
	mov	edi, DWORD PTR [ecx+esi*8+4]
	lea	ebp, DWORD PTR [ebx+8]
	mov	DWORD PTR tv508[esp+28], ebp
	test	ebp, ebp
	jne	SHORT $LN38@lower_boun@6
	call	__invalid_parameter_noinfo
$LN38@lower_boun@6:
	mov	ebp, DWORD PTR [ebp]
	inc	esi
	mov	DWORD PTR __Where$[esp+32], ebp
	mov	DWORD PTR __Where$[esp+36], edi

; 653  : 				return (this->comp(_Keyval,
; 654  : 					this->_Kfn(*_Where)) ? end() : _Where);

	mov	DWORD PTR $T445167[esp+32], esi
$LL54@lower_boun@6:
	mov	edx, DWORD PTR [ebx+52]
	sub	edx, DWORD PTR [ebx+48]
	sar	edx, 3
	cmp	esi, edx
	jb	SHORT $LN66@lower_boun@6

; 650  : 		const_iterator _Where;
; 651  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	call	__invalid_parameter_noinfo
$LN66@lower_boun@6:
	mov	eax, DWORD PTR [ebx+48]
	cmp	DWORD PTR [eax+esi*8+4], edi
	je	$LN2@lower_boun@6

; 652  : 			if (!this->comp(this->_Kfn(*_Where), _Keyval))

	test	ebp, ebp
	jne	SHORT $LN159@lower_boun@6
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN90@lower_boun@6:
	cmp	edi, DWORD PTR [eax+20]
	jne	SHORT $LN79@lower_boun@6
	call	__invalid_parameter_noinfo
$LN79@lower_boun@6:
	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR __Keyval$[esp+28]
	cmp	ecx, DWORD PTR [esi]
	je	SHORT $LN156@lower_boun@6

; 650  : 		const_iterator _Where;
; 651  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	test	ebp, ebp
	jne	SHORT $LN158@lower_boun@6
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN61@lower_boun@6:
	cmp	edi, DWORD PTR [eax+20]
	jne	SHORT $LN50@lower_boun@6
	call	__invalid_parameter_noinfo
$LN50@lower_boun@6:
	mov	edi, DWORD PTR [edi]
	mov	esi, DWORD PTR $T445167[esp+32]
	jmp	SHORT $LL54@lower_boun@6
$LN159@lower_boun@6:

; 652  : 			if (!this->comp(this->_Kfn(*_Where), _Keyval))

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN90@lower_boun@6
$LN158@lower_boun@6:

; 650  : 		const_iterator _Where;
; 651  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN61@lower_boun@6
$LN156@lower_boun@6:
	mov	DWORD PTR __Where$[esp+36], edi

; 653  : 				return (this->comp(_Keyval,
; 654  : 					this->_Kfn(*_Where)) ? end() : _Where);

	test	ebp, ebp
	jne	SHORT $LN157@lower_boun@6
	call	__invalid_parameter_noinfo
$LN112@lower_boun@6:
	cmp	edi, DWORD PTR [ebp+20]
	jne	SHORT $LN101@lower_boun@6
	call	__invalid_parameter_noinfo
$LN101@lower_boun@6:
	mov	edx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [edi+8]
	je	SHORT $LN7@lower_boun@6
	mov	eax, DWORD PTR tv508[esp+28]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	DWORD PTR $T444964[esp+36], ecx
	pop	edi
	lea	ecx, DWORD PTR $T444964[esp+28]
	mov	DWORD PTR $T444964[esp+28], edx
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebx

; 656  : 		}

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN157@lower_boun@6:

; 653  : 				return (this->comp(_Keyval,
; 654  : 					this->_Kfn(*_Where)) ? end() : _Where);

	mov	ebp, DWORD PTR [ebp]
	jmp	SHORT $LN112@lower_boun@6
$LN7@lower_boun@6:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	pop	edi
	lea	ecx, DWORD PTR __Where$[esp+28]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebx

; 656  : 		}

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN2@lower_boun@6:

; 655  : 		return (end());

	mov	ecx, DWORD PTR tv508[esp+28]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR __Where$[esp+36], edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 656  : 		}

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?find@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z
_TEXT	SEGMENT
?find@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::find, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi
; __Keyval$ = eax

; 625  : 		return (lower_bound(_Keyval));

	push	eax
	push	esi
	push	ecx
	call	?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound
	mov	eax, esi

; 626  : 		}

	ret	0
?find@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::find
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.h
_TEXT	ENDS
;	COMDAT ??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z
_TEXT	SEGMENT
_it2$131049 = -24					; size = 8
_firstEnd$ = -16					; size = 8
_secondEnd$ = -8					; size = 8
_second$ = 8						; size = 4
??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z PROC ; DRAMsimII::operator==<unsigned int,unsigned int>, COMDAT
; _first$ = eax

; 46   : 		if (first.size() != second.size()) return false;

	mov	ecx, DWORD PTR [eax+32]
	sub	esp, 24					; 00000018H
	push	esi
	mov	esi, DWORD PTR _second$[esp+24]
	cmp	ecx, DWORD PTR [esi+32]
	je	SHORT $LN6@operator@272
	xor	al, al
	pop	esi

; 58   : 	}

	add	esp, 24					; 00000018H
	ret	0
$LN6@operator@272:

; 47   : 
; 48   : 		typename std::tr1::unordered_map<A, B>::const_iterator firstEnd = first.end();

	mov	edx, DWORD PTR [eax+28]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _firstEnd$[esp+32], edx

; 49   : 		typename std::tr1::unordered_map<A, B>::const_iterator secondEnd = second.end();

	mov	edx, DWORD PTR [esi+28]
	push	ebp
	push	edi

; 50   : 		for (typename std::tr1::unordered_map<A, B>::const_iterator it1 = first.begin();it1 != firstEnd; it1++) 

	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR _firstEnd$[esp+36], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR _secondEnd$[esp+40], edx
	mov	edx, DWORD PTR [eax+28]
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR _secondEnd$[esp+36], ecx
	push	ebx
	npad	2
$LL73@operator@272:
	test	edi, edi
	je	SHORT $LN87@operator@272
	cmp	edi, DWORD PTR _firstEnd$[esp+40]
	je	SHORT $LN88@operator@272
$LN87@operator@272:
	call	__invalid_parameter_noinfo
$LN88@operator@272:
	cmp	ebp, DWORD PTR _firstEnd$[esp+44]
	je	$LN3@operator@272

; 51   : 		{
; 52   : 			typename std::tr1::unordered_map<A, B>::const_iterator it2 = second.find(it1->first);

	test	edi, edi
	jne	$LN166@operator@272
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN109@operator@272:
	cmp	ebp, DWORD PTR [eax+20]
	jne	SHORT $LN98@operator@272
	call	__invalid_parameter_noinfo
$LN98@operator@272:
	lea	ebx, DWORD PTR [ebp+8]
	push	ebx
	lea	eax, DWORD PTR _it2$131049[esp+44]
	push	eax
	push	esi
	call	?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound

; 53   : 
; 54   : 			if(it2 == secondEnd || (it1->second != it2->second)) 

	mov	esi, DWORD PTR _it2$131049[esp+40]
	test	esi, esi
	je	SHORT $LN116@operator@272
	cmp	esi, DWORD PTR _secondEnd$[esp+40]
	je	SHORT $LN117@operator@272
$LN116@operator@272:
	call	__invalid_parameter_noinfo
$LN117@operator@272:
	mov	ecx, DWORD PTR _it2$131049[esp+44]
	cmp	ecx, DWORD PTR _secondEnd$[esp+44]
	je	SHORT $LN162@operator@272
	test	edi, edi
	jne	SHORT $LN165@operator@272
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN138@operator@272:
	cmp	ebp, DWORD PTR [eax+20]
	jne	SHORT $LN127@operator@272
	call	__invalid_parameter_noinfo
$LN127@operator@272:
	test	esi, esi
	jne	SHORT $LN164@operator@272
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN156@operator@272:
	mov	edx, DWORD PTR _it2$131049[esp+44]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN145@operator@272
	call	__invalid_parameter_noinfo
$LN145@operator@272:
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR _it2$131049[esp+44]
	cmp	eax, DWORD PTR [ecx+12]
	jne	SHORT $LN162@operator@272

; 50   : 		for (typename std::tr1::unordered_map<A, B>::const_iterator it1 = first.begin();it1 != firstEnd; it1++) 

	test	edi, edi
	jne	SHORT $LN163@operator@272
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN80@operator@272:
	cmp	ebp, DWORD PTR [eax+20]
	jne	SHORT $LN69@operator@272
	call	__invalid_parameter_noinfo
$LN69@operator@272:
	mov	ebp, DWORD PTR [ebp]
	mov	esi, DWORD PTR _second$[esp+36]
	jmp	$LL73@operator@272
$LN166@operator@272:

; 51   : 		{
; 52   : 			typename std::tr1::unordered_map<A, B>::const_iterator it2 = second.find(it1->first);

	mov	eax, DWORD PTR [edi]
	jmp	$LN109@operator@272
$LN165@operator@272:

; 53   : 
; 54   : 			if(it2 == secondEnd || (it1->second != it2->second)) 

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN138@operator@272
$LN164@operator@272:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN156@operator@272
$LN163@operator@272:

; 50   : 		for (typename std::tr1::unordered_map<A, B>::const_iterator it1 = first.begin();it1 != firstEnd; it1++) 

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN80@operator@272
$LN162@operator@272:
	pop	ebx
	pop	edi
	pop	ebp

; 55   : 				return false;

	xor	al, al
	pop	esi

; 58   : 	}

	add	esp, 24					; 00000018H
	ret	0
$LN3@operator@272:
	pop	ebx
	pop	edi
	pop	ebp

; 56   : 		} 
; 57   : 		return true;

	mov	al, 1
	pop	esi

; 58   : 	}

	add	esp, 24					; 00000018H
	ret	0
??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z ENDP ; DRAMsimII::operator==<unsigned int,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@0@Z
_TEXT	SEGMENT
$T445934 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@0@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase, COMDAT
; _this$ = eax

; 811  : 		if (_First == begin() && _Last == end())

	mov	ecx, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+8]
	push	ebp
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR [esi+20]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN25@erase@15
	cmp	ecx, eax
	je	SHORT $LN26@erase@15
$LN25@erase@15:
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR __First$[esp+20]
$LN26@erase@15:
	mov	eax, DWORD PTR __First$[esp+24]
	cmp	eax, edi
	jne	SHORT $LL2@erase@15
	mov	ebp, DWORD PTR __Last$[esp+20]
	mov	edi, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi]
	test	ebp, ebp
	je	SHORT $LN50@erase@15
	cmp	ebp, edx
	je	SHORT $LN51@erase@15
$LN50@erase@15:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+24]
	mov	ecx, DWORD PTR __First$[esp+20]
$LN51@erase@15:
	cmp	DWORD PTR __Last$[esp+24], edi
	jne	SHORT $LL2@erase@15

; 812  : 			{	// erase all and return fresh iterator
; 813  : 			clear();

	call	?clear@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXXZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::clear

; 814  : 			return (end());

	mov	ecx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ebx+4], ecx
	mov	DWORD PTR [ebx], edx

; 820  : 			return (_Make_iter(_Last));

	mov	eax, ebx

; 821  : 			}
; 822  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	20					; 00000014H
$LL2@erase@15:

; 815  : 			}
; 816  : 		else
; 817  : 			{	// erase subrange
; 818  : 			while (_First != _Last)

	test	ecx, ecx
	je	SHORT $LN77@erase@15
	cmp	ecx, DWORD PTR __Last$[esp+20]
	je	SHORT $LN78@erase@15
$LN77@erase@15:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+24]
	mov	ecx, DWORD PTR __First$[esp+20]
$LN78@erase@15:
	mov	edx, DWORD PTR __Last$[esp+24]
	cmp	eax, edx
	je	SHORT $LN1@erase@15

; 819  : 				_First = erase(_First);

	push	eax
	push	ecx
	lea	eax, DWORD PTR $T445934[esp+32]
	push	eax
	mov	edi, esi
	call	?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __First$[esp+20], ecx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __First$[esp+24], eax
	jmp	SHORT $LL2@erase@15
$LN1@erase@15:

; 820  : 			return (_Make_iter(_Last));

	mov	ecx, DWORD PTR [esi]

; 821  : 			}
; 822  : 		}

	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ebx+4], edx
	mov	DWORD PTR [ebx], ecx
	mov	eax, ebx
	pop	ebx
	add	esp, 8
	ret	20					; 00000014H
?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@0@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase
_TEXT	ENDS
PUBLIC	??8Statistics@DRAMsimII@@QBE_NABV01@@Z		; DRAMsimII::Statistics::operator==
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
??8Statistics@DRAMsimII@@QBE_NABV01@@Z PROC		; DRAMsimII::Statistics::operator==
; _rhs$ = edi

; 338  : {

	push	ebx
	mov	ebx, DWORD PTR _this$[esp]

; 339  : 	return (validTransactionCount == rhs.validTransactionCount && startNumber == rhs.startNumber && endNumber == rhs.endNumber &&
; 340  : 		burstOf8Count == rhs.burstOf8Count && burstOf4Count == rhs.burstOf4Count && columnDepth == rhs.columnDepth &&
; 341  : 		/// @todo restore comparisons once tr1 implementations support this
; 342  : 		commandDelay ==  rhs.commandDelay && commandExecution == rhs.commandExecution && commandTurnaround == rhs.commandTurnaround &&
; 343  : 		transactionDecodeDelay == rhs.transactionDecodeDelay && transactionExecution == rhs.transactionExecution &&
; 344  : 		channels == rhs.channels && ranks == rhs.ranks && banks == rhs.banks && aggregateBankUtilization == rhs.aggregateBankUtilization &&
; 345  : 		pcOccurrence == rhs.pcOccurrence && workingSet == rhs.workingSet && readCount == rhs.readCount && writeCount == rhs.writeCount &&
; 346  : 		readBytesTransferred == rhs.readBytesTransferred && writeBytesTransferred == rhs.writeBytesTransferred && issuedAtTFAW == rhs.issuedAtTFAW);

	mov	eax, DWORD PTR [ebx+12]
	cmp	eax, DWORD PTR [edi+12]
	jne	$LN3@operator@273
	mov	ecx, DWORD PTR [ebx+16]
	cmp	ecx, DWORD PTR [edi+16]
	jne	$LN3@operator@273
	mov	edx, DWORD PTR [ebx+20]
	cmp	edx, DWORD PTR [edi+20]
	jne	$LN3@operator@273
	mov	eax, DWORD PTR [ebx+24]
	cmp	eax, DWORD PTR [edi+24]
	jne	$LN3@operator@273
	mov	ecx, DWORD PTR [ebx+28]
	cmp	ecx, DWORD PTR [edi+28]
	jne	$LN3@operator@273
	mov	edx, DWORD PTR [ebx+32]
	cmp	edx, DWORD PTR [edi+32]
	jne	$LN3@operator@273
	lea	eax, DWORD PTR [edi+68]
	push	eax
	lea	eax, DWORD PTR [ebx+68]
	call	??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z ; DRAMsimII::operator==<unsigned int,unsigned int>
	add	esp, 4
	test	al, al
	je	$LN3@operator@273
	lea	ecx, DWORD PTR [edi+140]
	push	ecx
	lea	eax, DWORD PTR [ebx+140]
	call	??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z ; DRAMsimII::operator==<unsigned int,unsigned int>
	add	esp, 4
	test	al, al
	je	$LN3@operator@273
	lea	edx, DWORD PTR [edi+212]
	push	edx
	lea	eax, DWORD PTR [ebx+212]
	call	??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z ; DRAMsimII::operator==<unsigned int,unsigned int>
	add	esp, 4
	test	al, al
	je	$LN3@operator@273
	lea	eax, DWORD PTR [edi+284]
	push	eax
	lea	eax, DWORD PTR [ebx+284]
	call	??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z ; DRAMsimII::operator==<unsigned int,unsigned int>
	add	esp, 4
	test	al, al
	je	$LN3@operator@273
	lea	ecx, DWORD PTR [edi+356]
	push	ecx
	lea	eax, DWORD PTR [ebx+356]
	call	??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z ; DRAMsimII::operator==<unsigned int,unsigned int>
	add	esp, 4
	test	al, al
	je	$LN3@operator@273
	mov	edx, DWORD PTR [ebx]
	cmp	edx, DWORD PTR [edi]
	jne	$LN3@operator@273
	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN3@operator@273
	mov	ecx, DWORD PTR [ebx+8]
	cmp	ecx, DWORD PTR [edi+8]
	jne	SHORT $LN3@operator@273
	push	esi
	lea	edx, DWORD PTR [edi+492]
	push	edx
	lea	esi, DWORD PTR [ebx+492]
	call	??$?8IV?$allocator@I@std@@@std@@YA_NABV?$vector@IV?$allocator@I@std@@@0@0@Z ; std::operator==<unsigned int,std::allocator<unsigned int> >
	add	esp, 4
	pop	esi
	test	al, al
	je	SHORT $LN3@operator@273
	lea	eax, DWORD PTR [edi+428]
	lea	ecx, DWORD PTR [ebx+428]
	call	??$?8V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z ; std::operator==<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
	test	al, al
	je	SHORT $LN3@operator@273
	lea	eax, DWORD PTR [edi+460]
	lea	ecx, DWORD PTR [ebx+460]
	call	??$?8V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z ; std::operator==<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
	test	al, al
	je	SHORT $LN3@operator@273
	mov	eax, DWORD PTR [ebx+36]
	cmp	eax, DWORD PTR [edi+36]
	jne	SHORT $LN3@operator@273
	mov	ecx, DWORD PTR [ebx+40]
	cmp	ecx, DWORD PTR [edi+40]
	jne	SHORT $LN3@operator@273
	mov	edx, DWORD PTR [ebx+44]
	cmp	edx, DWORD PTR [edi+44]
	jne	SHORT $LN3@operator@273
	mov	eax, DWORD PTR [ebx+48]
	cmp	eax, DWORD PTR [edi+48]
	jne	SHORT $LN3@operator@273
	mov	ecx, DWORD PTR [ebx+64]
	cmp	ecx, DWORD PTR [edi+64]
	jne	SHORT $LN3@operator@273
	mov	eax, 1
	pop	ebx

; 347  : }

	ret	4
$LN3@operator@273:

; 339  : 	return (validTransactionCount == rhs.validTransactionCount && startNumber == rhs.startNumber && endNumber == rhs.endNumber &&
; 340  : 		burstOf8Count == rhs.burstOf8Count && burstOf4Count == rhs.burstOf4Count && columnDepth == rhs.columnDepth &&
; 341  : 		/// @todo restore comparisons once tr1 implementations support this
; 342  : 		commandDelay ==  rhs.commandDelay && commandExecution == rhs.commandExecution && commandTurnaround == rhs.commandTurnaround &&
; 343  : 		transactionDecodeDelay == rhs.transactionDecodeDelay && transactionExecution == rhs.transactionExecution &&
; 344  : 		channels == rhs.channels && ranks == rhs.ranks && banks == rhs.banks && aggregateBankUtilization == rhs.aggregateBankUtilization &&
; 345  : 		pcOccurrence == rhs.pcOccurrence && workingSet == rhs.workingSet && readCount == rhs.readCount && writeCount == rhs.writeCount &&
; 346  : 		readBytesTransferred == rhs.readBytesTransferred && writeBytesTransferred == rhs.writeBytesTransferred && issuedAtTFAW == rhs.issuedAtTFAW);

	xor	eax, eax
	pop	ebx

; 347  : }

	ret	4
??8Statistics@DRAMsimII@@QBE_NABV01@@Z ENDP		; DRAMsimII::Statistics::operator==
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z$0
__ehfuncinfo$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
xdata$x	ENDS
;	COMDAT ?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
$T482247 = -80						; size = 28
$T482246 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Incsize, COMDAT
; _this$ = ecx

; 1239 : 		{	// alter element count, with checking

	push	-1
	push	__ehhandler$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1240 : 		if (max_size() - _Mysize < _Count)

	mov	eax, DWORD PTR [ecx+24]
	mov	edx, 536870911				; 1fffffffH
	sub	edx, eax
	cmp	edx, 1
	jae	SHORT $LN1@Incsize@2

; 1241 : 			_THROW(length_error, "list<T> too long");

	push	16					; 00000010H
	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T482247[esp+92]
	mov	DWORD PTR $T482247[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T482247[esp+112], 0
	mov	BYTE PTR $T482247[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T482247[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T482246[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T482246[esp+88]
	push	ecx
	mov	DWORD PTR $T482246[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN52@Incsize@2:
$LN1@Incsize@2:

; 1242 : 		_Mysize += _Count;

	inc	eax
	mov	DWORD PTR [ecx+24], eax

; 1243 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 80					; 00000050H
	ret	0
$LN51@Incsize@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z$0:
	lea	ecx, DWORD PTR $T482247[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Incsize
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T482424 = -80						; size = 28
$T482423 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T482424[esp+92]
	mov	DWORD PTR $T482424[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T482424[esp+112], 0
	mov	BYTE PTR $T482424[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T482424[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T482423[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T482423[esp+88]
	push	ecx
	mov	DWORD PTR $T482423[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@3:
$LN44@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T482424[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Xlen
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Where$ = 12						; size = 8
?_Insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Insert, COMDAT
; __Val$ = edx

; 711  : 
; 712  :  #if _HAS_ITERATOR_DEBUGGING
; 713  : 		if (_Where._Mycont != this)
; 714  : 			_DEBUG_ERROR("list insert iterator outside range");
; 715  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 716  : 
; 717  : 		_Nodeptr _Pnode = _Where._Mynode();
; 718  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

	mov	eax, DWORD PTR __Where$[esp]
	mov	ecx, DWORD PTR [eax+4]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax+4]
	push	ecx
	push	eax
	mov	esi, edx
	call	?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PAU342@0ABU?$pair@$$CBII@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode

; 719  : 		_Incsize(1);

	mov	ecx, DWORD PTR _this$[esp+4]
	mov	esi, eax
	call	?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Incsize

; 720  : 		_Prevnode(_Pnode) = _Newnode;

	mov	DWORD PTR [edi], esi

; 721  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

	mov	edx, DWORD PTR [esi+4]

; 722  : 		}

	pop	edi
	mov	DWORD PTR [edx], esi
	pop	esi
	ret	12					; 0000000cH
?_Insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Insert
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE_NI@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1102 : 		{	// allocate array with _Capacity elements

	push	ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Xlen
$LN18@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	ecx

; 1115 : 		}

	ret	0
$LN17@Buy@3:
?_Buy@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 8
?insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::insert, COMDAT
; __Val$ = edx

; 703  : 		{	// insert _Val at _Where

	push	ecx

; 704  : 		_Insert(_Where, _Val);

	mov	eax, DWORD PTR __Where$[esp+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+8]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax+4]
	push	ecx
	push	eax
	mov	esi, edx
	call	?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PAU342@0ABU?$pair@$$CBII@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode
	mov	ecx, ebx
	mov	esi, eax
	call	?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Incsize
	mov	DWORD PTR [edi], esi
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [edx], esi

; 705  : 		return (_Make_iter(--_Where));

	mov	eax, DWORD PTR __Where$[esp+16]
	test	eax, eax
	jne	SHORT $LN17@insert@3
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp+16]
$LN17@insert@3:
	mov	ecx, DWORD PTR __Where$[esp+20]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Where$[esp+20], ecx
	test	eax, eax
	je	SHORT $LN27@insert@3
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN28@insert@3
$LN27@insert@3:
	xor	eax, eax
$LN28@insert@3:
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN15@insert@3
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR __Where$[esp+20]
$LN15@insert@3:
	mov	DWORD PTR [ebp], 0
	mov	DWORD PTR [ebp+4], ecx
	test	ebx, ebx
	jne	SHORT $LN35@insert@3
	call	__invalid_parameter_noinfo
$LN35@insert@3:
	mov	edx, DWORD PTR [ebx]

; 706  : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [ebp], edx
	mov	eax, ebp
	pop	ebp
	pop	ebx
	pop	ecx
	ret	16					; 00000010H
?insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::insert
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z
_TEXT	SEGMENT
$T482764 = -80						; size = 28
$T482763 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Newnode$ = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Addleft$ = 16						; size = 1
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert, COMDAT
; __Wherenode$ = edi

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	push	ebx
	push	ebp
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _this$[esp+96]

; 1188 : 		if (max_size() - 1 <= _Mysize)
; 1189 : 			_THROW(length_error, "map/set<T> too long");

	xor	ebx, ebx
	cmp	DWORD PTR [ebp+28], 268435454		; 0ffffffeH
	jb	SHORT $LN17@Insert
	push	19					; 00000013H
	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T482764[esp+108]
	mov	DWORD PTR $T482764[esp+132], 15		; 0000000fH
	mov	DWORD PTR $T482764[esp+128], ebx
	mov	BYTE PTR $T482764[esp+112], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T482764[esp+100]
	push	eax
	lea	ecx, DWORD PTR $T482763[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], ebx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T482763[esp+104]
	push	ecx
	mov	DWORD PTR $T482763[esp+108], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN370@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	eax, DWORD PTR [ebp+24]
	mov	esi, DWORD PTR __Val$[esp+96]
	push	ebx
	push	eax
	push	edi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KI@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode

; 1192 : 
; 1193 : 		++_Mysize;

	inc	DWORD PTR [ebp+28]
	mov	esi, eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [ebp+24]
	mov	DWORD PTR __Newnode$[esp+96], esi
	cmp	edi, eax
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], esi

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	edx, DWORD PTR [ebp+24]
	mov	DWORD PTR [edx], esi
	mov	eax, DWORD PTR [ebp+24]
	jmp	SHORT $LN367@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+96], bl
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [edi], esi

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [ebp+24]
	cmp	edi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], esi

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [edi+8], esi

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [ebp+24]
	cmp	edi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert
$LN367@Insert:

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], esi
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	ecx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+32], bl
	jne	$LN9@Insert
	npad	5
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	$LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+32], bl

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;
; 1219 : 					_Color(_Wherenode) = _Black;
; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));
; 1222 : 					}
; 1223 : 				else

	je	$LN369@Insert

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN145@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+33], bl
	jne	SHORT $LN144@Insert
	mov	DWORD PTR [eax+4], esi
$LN144@Insert:
	mov	edx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [ebp+24]
	cmp	esi, DWORD PTR [edx+4]
	jne	SHORT $LN143@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN140@Insert
$LN143@Insert:
	mov	edx, DWORD PTR [eax]
	cmp	esi, DWORD PTR [edx]
	jne	SHORT $LN141@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN140@Insert
$LN141@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN140@Insert:
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], ecx
$LN145@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+32], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+32], bl

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+33], bl
	jne	SHORT $LN207@Insert
	mov	DWORD PTR [edx+4], eax
$LN207@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [ebp+24]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN206@Insert
	mov	DWORD PTR [edx+4], ecx
	mov	DWORD PTR [ecx+8], eax

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN368@Insert

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

$LN206@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN204@Insert
	mov	DWORD PTR [edx+8], ecx
	mov	DWORD PTR [ecx+8], eax

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN368@Insert

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

$LN204@Insert:
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [ecx+8], eax

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN368@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+32], bl
	jne	SHORT $LN3@Insert
$LN369@Insert:

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+32], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+32], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+32], bl

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN301@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);
; 1250 : 						_Rrotate(_Pnode);

	push	ebp
	mov	esi, ecx
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+32], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+32], bl

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+33], bl
	jne	SHORT $LN300@Insert
	mov	DWORD PTR [edx+4], eax
$LN300@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [ebp+24]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN299@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN296@Insert
$LN299@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN297@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN296@Insert
$LN297@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN296@Insert:
	mov	DWORD PTR [ecx], eax
$LN368@Insert:
	mov	DWORD PTR [eax+4], ecx
$LN301@Insert:
	mov	ecx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+32], bl
	je	$LL10@Insert

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	esi, DWORD PTR __Newnode$[esp+96]
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [ebp+24]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+32], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+96]
	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 84					; 00000054H
	ret	16					; 00000010H
$LN366@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z$0:
	lea	ecx, DWORD PTR $T482764[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-84]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KI@2@@Z
_TEXT	SEGMENT
$T483586 = -8						; size = 8
$T483584 = -8						; size = 8
__Where$128202 = -8					; size = 8
_this$ = 8						; size = 4
__Addleft$ = 12						; size = 1
___$ReturnUdt$ = 12					; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KI@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert, COMDAT

; 630  : 		{	// try to insert node with value _Val

	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+8]

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	ecx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ecx+4]

; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+33], 0
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+12]
	push	esi
	mov	esi, DWORD PTR __Val$[esp+16]
	push	edi
	mov	edi, ecx
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+20], cl
	jne	SHORT $LN9@insert@4
	mov	edx, DWORD PTR [esi+4]
	npad	6
$LL10@insert@4:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	edi, eax

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+20]
	ja	SHORT $LN31@insert@4
	jb	SHORT $LN107@insert@4
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN31@insert@4
$LN107@insert@4:

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	mov	eax, DWORD PTR [eax]
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+20], cl
	jmp	SHORT $LN14@insert@4

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

$LN31@insert@4:

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	mov	eax, DWORD PTR [eax+8]
	xor	cl, cl
	mov	BYTE PTR __Addleft$[esp+20], cl
$LN14@insert@4:

; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL10@insert@4
$LN9@insert@4:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, DWORD PTR [ebx]
	mov	eax, edi
	mov	DWORD PTR __Where$128202[esp+28], eax
	mov	DWORD PTR __Where$128202[esp+24], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN83@insert@4

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN71@insert@4
	cmp	edx, edx
	je	SHORT $LN72@insert@4
$LN71@insert@4:
	call	__invalid_parameter_noinfo
$LN72@insert@4:
	cmp	edi, esi
	jne	SHORT $LN4@insert@4

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Val$[esp+20]
	push	ecx
	push	1
	lea	edx, DWORD PTR $T483584[esp+32]
	push	edx
$LN111@insert@4:
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ebp], ecx
	mov	DWORD PTR [ebp+4], edx
	mov	BYTE PTR [ebp+8], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, ebp

; 659  : 			}
; 660  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH
$LN4@insert@4:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	lea	esi, DWORD PTR __Where$128202[esp+24]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Where$128202[esp+28]
	mov	edx, DWORD PTR __Where$128202[esp+24]
	mov	esi, DWORD PTR __Val$[esp+20]
$LN83@insert@4:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR [esi+4]
	ja	SHORT $LN2@insert@4
	jb	SHORT $LN108@insert@4
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [esi]
	jae	SHORT $LN2@insert@4
$LN108@insert@4:

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	edx, DWORD PTR __Addleft$[esp+20]
	push	esi
	push	edx
	lea	eax, DWORD PTR $T483586[esp+32]
	push	eax
	jmp	SHORT $LN111@insert@4
$LN2@insert@4:

; 659  : 			}
; 660  : 		}

	pop	edi
	mov	DWORD PTR [ebp+4], eax
	pop	esi
	mov	DWORD PTR [ebp], edx
	mov	BYTE PTR [ebp+8], 0
	mov	eax, ebp
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KI@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z
_TEXT	SEGMENT
$T483824 = -80						; size = 28
$T483823 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Newnode$ = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Addleft$ = 16						; size = 1
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert, COMDAT
; __Wherenode$ = edi

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	push	ebx
	push	ebp
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _this$[esp+96]

; 1188 : 		if (max_size() - 1 <= _Mysize)
; 1189 : 			_THROW(length_error, "map/set<T> too long");

	xor	ebx, ebx
	cmp	DWORD PTR [ebp+28], 178956969		; 0aaaaaa9H
	jb	SHORT $LN17@Insert@2
	push	19					; 00000013H
	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T483824[esp+108]
	mov	DWORD PTR $T483824[esp+132], 15		; 0000000fH
	mov	DWORD PTR $T483824[esp+128], ebx
	mov	BYTE PTR $T483824[esp+112], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T483824[esp+100]
	push	eax
	lea	ecx, DWORD PTR $T483823[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], ebx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T483823[esp+104]
	push	ecx
	mov	DWORD PTR $T483823[esp+108], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN370@Insert@2:
$LN17@Insert@2:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	eax, DWORD PTR [ebp+24]
	mov	esi, DWORD PTR __Val$[esp+96]
	push	ebx
	push	eax
	push	edi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode

; 1192 : 
; 1193 : 		++_Mysize;

	inc	DWORD PTR [ebp+28]
	mov	esi, eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [ebp+24]
	mov	DWORD PTR __Newnode$[esp+96], esi
	cmp	edi, eax
	jne	SHORT $LN16@Insert@2

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], esi

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	edx, DWORD PTR [ebp+24]
	mov	DWORD PTR [edx], esi
	mov	eax, DWORD PTR [ebp+24]
	jmp	SHORT $LN367@Insert@2
$LN16@Insert@2:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+96], bl
	je	SHORT $LN14@Insert@2

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [edi], esi

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [ebp+24]
	cmp	edi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert@2

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], esi

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert@2
$LN14@Insert@2:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [edi+8], esi

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [ebp+24]
	cmp	edi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert@2
$LN367@Insert@2:

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], esi
$LN11@Insert@2:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	ecx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+40], bl
	jne	$LN9@Insert@2
	npad	5
$LL10@Insert@2:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	$LN8@Insert@2

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+40], bl

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;
; 1219 : 					_Color(_Wherenode) = _Black;
; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));
; 1222 : 					}
; 1223 : 				else

	je	$LN369@Insert@2

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN145@Insert@2

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+41], bl
	jne	SHORT $LN144@Insert@2
	mov	DWORD PTR [eax+4], esi
$LN144@Insert@2:
	mov	edx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [ebp+24]
	cmp	esi, DWORD PTR [edx+4]
	jne	SHORT $LN143@Insert@2
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN140@Insert@2
$LN143@Insert@2:
	mov	edx, DWORD PTR [eax]
	cmp	esi, DWORD PTR [edx]
	jne	SHORT $LN141@Insert@2
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN140@Insert@2
$LN141@Insert@2:
	mov	DWORD PTR [edx+8], ecx
$LN140@Insert@2:
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], ecx
$LN145@Insert@2:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+40], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+40], bl

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+41], bl
	jne	SHORT $LN207@Insert@2
	mov	DWORD PTR [edx+4], eax
$LN207@Insert@2:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [ebp+24]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN206@Insert@2
	mov	DWORD PTR [edx+4], ecx
	mov	DWORD PTR [ecx+8], eax

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN368@Insert@2

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

$LN206@Insert@2:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN204@Insert@2
	mov	DWORD PTR [edx+8], ecx
	mov	DWORD PTR [ecx+8], eax

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN368@Insert@2

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

$LN204@Insert@2:
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [ecx+8], eax

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN368@Insert@2
$LN8@Insert@2:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+40], bl
	jne	SHORT $LN3@Insert@2
$LN369@Insert@2:

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+40], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+40], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+40], bl

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN301@Insert@2
$LN3@Insert@2:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert@2

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);
; 1250 : 						_Rrotate(_Pnode);

	push	ebp
	mov	esi, ecx
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Rrotate
$LN1@Insert@2:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+40], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+40], bl

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+41], bl
	jne	SHORT $LN300@Insert@2
	mov	DWORD PTR [edx+4], eax
$LN300@Insert@2:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [ebp+24]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN299@Insert@2
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN296@Insert@2
$LN299@Insert@2:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN297@Insert@2
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN296@Insert@2
$LN297@Insert@2:
	mov	DWORD PTR [edx+8], ecx
$LN296@Insert@2:
	mov	DWORD PTR [ecx], eax
$LN368@Insert@2:
	mov	DWORD PTR [eax+4], ecx
$LN301@Insert@2:
	mov	ecx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+40], bl
	je	$LL10@Insert@2

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	esi, DWORD PTR __Newnode$[esp+96]
$LN9@Insert@2:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [ebp+24]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+40], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+96]
	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 84					; 00000054H
	ret	16					; 00000010H
$LN366@Insert@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z$0:
	lea	ecx, DWORD PTR $T483824[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-84]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z
_TEXT	SEGMENT
$T484646 = -8						; size = 8
$T484644 = -8						; size = 8
__Where$128061 = -8					; size = 8
_this$ = 8						; size = 4
__Addleft$ = 12						; size = 1
___$ReturnUdt$ = 12					; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert, COMDAT

; 630  : 		{	// try to insert node with value _Val

	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+8]

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	ecx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ecx+4]

; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+41], 0
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+12]
	push	esi
	mov	esi, DWORD PTR __Val$[esp+16]
	push	edi
	mov	edi, ecx
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+20], cl
	jne	SHORT $LN9@insert@5
	mov	edx, DWORD PTR [esi+4]
	npad	6
$LL10@insert@5:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	edi, eax

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+20]
	ja	SHORT $LN31@insert@5
	jb	SHORT $LN107@insert@5
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN31@insert@5
$LN107@insert@5:

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	mov	eax, DWORD PTR [eax]
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+20], cl
	jmp	SHORT $LN14@insert@5

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

$LN31@insert@5:

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	mov	eax, DWORD PTR [eax+8]
	xor	cl, cl
	mov	BYTE PTR __Addleft$[esp+20], cl
$LN14@insert@5:

; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+41], 0
	je	SHORT $LL10@insert@5
$LN9@insert@5:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, DWORD PTR [ebx]
	mov	eax, edi
	mov	DWORD PTR __Where$128061[esp+28], eax
	mov	DWORD PTR __Where$128061[esp+24], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN83@insert@5

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN71@insert@5
	cmp	edx, edx
	je	SHORT $LN72@insert@5
$LN71@insert@5:
	call	__invalid_parameter_noinfo
$LN72@insert@5:
	cmp	edi, esi
	jne	SHORT $LN4@insert@5

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Val$[esp+20]
	push	ecx
	push	1
	lea	edx, DWORD PTR $T484644[esp+32]
	push	edx
$LN111@insert@5:
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ebp], ecx
	mov	DWORD PTR [ebp+4], edx
	mov	BYTE PTR [ebp+8], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, ebp

; 659  : 			}
; 660  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH
$LN4@insert@5:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	lea	esi, DWORD PTR __Where$128061[esp+24]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Where$128061[esp+28]
	mov	edx, DWORD PTR __Where$128061[esp+24]
	mov	esi, DWORD PTR __Val$[esp+20]
$LN83@insert@5:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR [esi+4]
	ja	SHORT $LN2@insert@5
	jb	SHORT $LN108@insert@5
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [esi]
	jae	SHORT $LN2@insert@5
$LN108@insert@5:

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	edx, DWORD PTR __Addleft$[esp+20]
	push	esi
	push	edx
	lea	eax, DWORD PTR $T484646[esp+32]
	push	eax
	jmp	SHORT $LN111@insert@5
$LN2@insert@5:

; 659  : 			}
; 660  : 		}

	pop	edi
	mov	DWORD PTR [ebp+4], eax
	pop	esi
	mov	DWORD PTR [ebp], edx
	mov	BYTE PTR [ebp+8], 0
	mov	eax, ebp
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z$0
__ehfuncinfo$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT

; 476  : 		{	// construct empty vector with allocator

	push	-1
	push	__ehhandler$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@28
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@28
$LN13@vector@28:
	xor	eax, eax
$LN14@vector@28:
	mov	DWORD PTR [esi], eax

; 477  : 		_Buy(0);

	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx

; 478  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T485081 = -80						; size = 28
$T485080 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T485081[esp+92]
	mov	DWORD PTR $T485081[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T485081[esp+112], 0
	mov	BYTE PTR $T485081[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T485081[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T485080[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T485080[esp+88]
	push	ecx
	mov	DWORD PTR $T485080[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@4:
$LN44@Xlen@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T485081[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KI@2@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 8
$T485247 = -12						; size = 12
$T485246 = -12						; size = 8
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Val$ = 16						; size = 4
__Where$ = 20						; size = 8
?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KI@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert, COMDAT

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	sub	esp, 24					; 00000018H
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+24]

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;
; 672  : 
; 673  : 		if (size() == 0)

	cmp	DWORD PTR [ebx+28], 0
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+28]
	push	esi
	push	edi
	jne	SHORT $LN32@insert@6

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[esp+36]
	mov	edi, DWORD PTR [ebx+24]
	push	eax
	push	1
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN32@insert@6:

; 675  : 		else if (this->_Multi)
; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())
; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,
; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 682  : 				}
; 683  : 			else if (_Where == end())
; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,
; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));
; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,
; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))
; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 696  : 				else
; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,
; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))
; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 707  : 				else
; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 709  : 				}
; 710  : 			}
; 711  : 		else
; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	ecx, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Where$[esp+36]
	mov	eax, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN237@insert@6
	cmp	ecx, eax
	je	SHORT $LN238@insert@6
$LN237@insert@6:
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR __Where$[esp+36]
$LN238@insert@6:
	mov	eax, DWORD PTR __Where$[esp+40]
	cmp	eax, esi
	jne	SHORT $LN14@insert@6

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Val$[esp+36]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+20]
	ja	$LN1@insert@6
	jb	SHORT $LN395@insert@6
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+16]
	jae	$LN1@insert@6
$LN395@insert@6:

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	ecx
	push	1
	push	ebp
	push	ebx
	mov	edi, eax
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN14@insert@6:

; 718  : 				}
; 719  : 			else if (_Where == end())

	mov	esi, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN276@insert@6
	cmp	ecx, edx
	je	SHORT $LN277@insert@6
$LN276@insert@6:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp+40]
	mov	ecx, DWORD PTR __Where$[esp+36]
$LN277@insert@6:
	cmp	eax, esi
	jne	SHORT $LN11@insert@6

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [ebx+24]
	mov	edi, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [edi+20]
	mov	edx, DWORD PTR __Val$[esp+36]
	cmp	ecx, DWORD PTR [edx+4]
	ja	$LN400@insert@6
	jb	SHORT $LN396@insert@6
	mov	eax, DWORD PTR [edi+16]
	mov	ecx, edx
	cmp	eax, DWORD PTR [ecx]
	jae	$LN400@insert@6
$LN396@insert@6:

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	push	edx
	push	0
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN11@insert@6:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,
; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	edi, DWORD PTR __Val$[esp+36]
	mov	edx, DWORD PTR [edi+4]
	cmp	edx, DWORD PTR [eax+20]
	ja	SHORT $LN8@insert@6
	jb	SHORT $LN397@insert@6
	mov	edx, DWORD PTR [edi]
	cmp	edx, DWORD PTR [eax+16]
	jae	SHORT $LN8@insert@6
$LN397@insert@6:
	lea	esi, DWORD PTR __Next$[esp+40]
	mov	DWORD PTR __Next$[esp+40], ecx
	mov	DWORD PTR __Next$[esp+44], eax
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Dec
	mov	esi, DWORD PTR __Next$[esp+44]
	lea	ecx, DWORD PTR [esi+16]
	mov	eax, edi
	call	??R?$less@_K@std@@QBE_NAB_K0@Z		; std::less<unsigned __int64>::operator()
	test	al, al
	je	SHORT $LN399@insert@6

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+33], 0

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	push	edi
	je	SHORT $LN7@insert@6
	push	0
	push	ebp
	push	ebx
	mov	edi, esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN7@insert@6:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	edi, DWORD PTR __Where$[esp+44]
	push	1
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN399@insert@6:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Where$[esp+40]
	mov	ecx, DWORD PTR __Where$[esp+36]
$LN8@insert@6:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,
; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [edi+4]
	ja	$LN400@insert@6
	jb	SHORT $LN398@insert@6
	mov	edx, DWORD PTR [eax+16]
	mov	esi, edi
	cmp	edx, DWORD PTR [esi]
	jae	$LN400@insert@6
$LN398@insert@6:
	mov	DWORD PTR __Next$[esp+40], ecx
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR __Next$[esp+44], eax
	mov	eax, DWORD PTR [ebx+24]
	lea	esi, DWORD PTR __Next$[esp+40]
	mov	DWORD PTR $T485246[esp+44], eax
	mov	DWORD PTR $T485246[esp+40], ecx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Inc
	lea	esi, DWORD PTR $T485246[esp+40]
	lea	edi, DWORD PTR __Next$[esp+40]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::operator==
	mov	edi, DWORD PTR __Next$[esp+44]
	test	al, al
	jne	SHORT $LN3@insert@6
	mov	ecx, DWORD PTR __Val$[esp+36]
	lea	eax, DWORD PTR [edi+16]
	call	??R?$less@_K@std@@QBE_NAB_K0@Z		; std::less<unsigned __int64>::operator()
	test	al, al
	je	SHORT $LN400@insert@6
$LN3@insert@6:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	eax, DWORD PTR __Where$[esp+40]
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+33], 0
	je	SHORT $LN2@insert@6

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[esp+36]
	push	ecx
	push	0
	push	ebp
	push	ebx
	mov	edi, eax
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN2@insert@6:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[esp+36]
	push	edx
	push	1
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN400@insert@6:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[esp+36]
$LN1@insert@6:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	push	ecx
	lea	eax, DWORD PTR $T485247[esp+44]
	push	eax
	push	ebx
	call	?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert
	mov	ecx, DWORD PTR [eax]

; 749  : 		}

	pop	edi
	mov	DWORD PTR [ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	pop	esi
	mov	DWORD PTR [ebp+4], edx
	mov	eax, ebp
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KI@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 8
$T486160 = -12						; size = 12
$T486159 = -12						; size = 8
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Val$ = 16						; size = 4
__Where$ = 20						; size = 8
?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert, COMDAT

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	sub	esp, 24					; 00000018H
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+24]

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;
; 672  : 
; 673  : 		if (size() == 0)

	cmp	DWORD PTR [ebx+28], 0
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+28]
	push	esi
	push	edi
	jne	SHORT $LN32@insert@7

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[esp+36]
	mov	edi, DWORD PTR [ebx+24]
	push	eax
	push	1
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN32@insert@7:

; 675  : 		else if (this->_Multi)
; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())
; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,
; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 682  : 				}
; 683  : 			else if (_Where == end())
; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,
; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));
; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,
; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))
; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 696  : 				else
; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,
; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))
; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 707  : 				else
; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 709  : 				}
; 710  : 			}
; 711  : 		else
; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	ecx, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Where$[esp+36]
	mov	eax, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN237@insert@7
	cmp	ecx, eax
	je	SHORT $LN238@insert@7
$LN237@insert@7:
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR __Where$[esp+36]
$LN238@insert@7:
	mov	eax, DWORD PTR __Where$[esp+40]
	cmp	eax, esi
	jne	SHORT $LN14@insert@7

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Val$[esp+36]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+20]
	ja	$LN1@insert@7
	jb	SHORT $LN395@insert@7
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+16]
	jae	$LN1@insert@7
$LN395@insert@7:

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	ecx
	push	1
	push	ebp
	push	ebx
	mov	edi, eax
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN14@insert@7:

; 718  : 				}
; 719  : 			else if (_Where == end())

	mov	esi, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN276@insert@7
	cmp	ecx, edx
	je	SHORT $LN277@insert@7
$LN276@insert@7:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp+40]
	mov	ecx, DWORD PTR __Where$[esp+36]
$LN277@insert@7:
	cmp	eax, esi
	jne	SHORT $LN11@insert@7

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [ebx+24]
	mov	edi, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [edi+20]
	mov	edx, DWORD PTR __Val$[esp+36]
	cmp	ecx, DWORD PTR [edx+4]
	ja	$LN400@insert@7
	jb	SHORT $LN396@insert@7
	mov	eax, DWORD PTR [edi+16]
	mov	ecx, edx
	cmp	eax, DWORD PTR [ecx]
	jae	$LN400@insert@7
$LN396@insert@7:

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	push	edx
	push	0
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN11@insert@7:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,
; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	edi, DWORD PTR __Val$[esp+36]
	mov	edx, DWORD PTR [edi+4]
	cmp	edx, DWORD PTR [eax+20]
	ja	SHORT $LN8@insert@7
	jb	SHORT $LN397@insert@7
	mov	edx, DWORD PTR [edi]
	cmp	edx, DWORD PTR [eax+16]
	jae	SHORT $LN8@insert@7
$LN397@insert@7:
	lea	esi, DWORD PTR __Next$[esp+40]
	mov	DWORD PTR __Next$[esp+40], ecx
	mov	DWORD PTR __Next$[esp+44], eax
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Dec
	mov	esi, DWORD PTR __Next$[esp+44]
	lea	ecx, DWORD PTR [esi+16]
	mov	eax, edi
	call	??R?$less@_K@std@@QBE_NAB_K0@Z		; std::less<unsigned __int64>::operator()
	test	al, al
	je	SHORT $LN399@insert@7

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+41], 0

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	push	edi
	je	SHORT $LN7@insert@7
	push	0
	push	ebp
	push	ebx
	mov	edi, esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN7@insert@7:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	edi, DWORD PTR __Where$[esp+44]
	push	1
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN399@insert@7:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Where$[esp+40]
	mov	ecx, DWORD PTR __Where$[esp+36]
$LN8@insert@7:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,
; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [edi+4]
	ja	$LN400@insert@7
	jb	SHORT $LN398@insert@7
	mov	edx, DWORD PTR [eax+16]
	mov	esi, edi
	cmp	edx, DWORD PTR [esi]
	jae	$LN400@insert@7
$LN398@insert@7:
	mov	DWORD PTR __Next$[esp+40], ecx
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR __Next$[esp+44], eax
	mov	eax, DWORD PTR [ebx+24]
	lea	esi, DWORD PTR __Next$[esp+40]
	mov	DWORD PTR $T486159[esp+44], eax
	mov	DWORD PTR $T486159[esp+40], ecx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Inc
	lea	esi, DWORD PTR $T486159[esp+40]
	lea	edi, DWORD PTR __Next$[esp+40]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::operator==
	mov	edi, DWORD PTR __Next$[esp+44]
	test	al, al
	jne	SHORT $LN3@insert@7
	mov	ecx, DWORD PTR __Val$[esp+36]
	lea	eax, DWORD PTR [edi+16]
	call	??R?$less@_K@std@@QBE_NAB_K0@Z		; std::less<unsigned __int64>::operator()
	test	al, al
	je	SHORT $LN400@insert@7
$LN3@insert@7:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	eax, DWORD PTR __Where$[esp+40]
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+41], 0
	je	SHORT $LN2@insert@7

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[esp+36]
	push	ecx
	push	0
	push	ebp
	push	ebx
	mov	edi, eax
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN2@insert@7:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[esp+36]
	push	edx
	push	1
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN400@insert@7:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[esp+36]
$LN1@insert@7:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	push	ecx
	lea	eax, DWORD PTR $T486160[esp+44]
	push	eax
	push	ebx
	call	?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert
	mov	ecx, DWORD PTR [eax]

; 749  : 		}

	pop	edi
	mov	DWORD PTR [ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	pop	esi
	mov	DWORD PTR [ebp+4], edx
	mov	eax, ebp
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::reserve, COMDAT
; _this$ = esi

; 602  : 		{	// determine new minimum length of allocated storage

	push	ecx

; 603  : 		if (max_size() < _Count)

	mov	ecx, DWORD PTR __Count$[esp]
	push	ebx
	push	ebp
	push	edi
	cmp	ecx, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@reserve@2

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN97@reserve@2:
$LN5@reserve@2:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR [esi+12]
	test	edx, edx
	jne	SHORT $LN20@reserve@2
	xor	eax, eax
	jmp	SHORT $LN21@reserve@2
$LN20@reserve@2:
	mov	eax, DWORD PTR [esi+20]
	sub	eax, edx
	sar	eax, 2
$LN21@reserve@2:
	cmp	eax, ecx
	jae	SHORT $LN3@reserve@2

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	call	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	edi, DWORD PTR [esi+16]
	mov	ebx, eax
	cmp	DWORD PTR [esi+12], edi
	jbe	SHORT $LN27@reserve@2
	call	__invalid_parameter_noinfo
$LN27@reserve@2:
	mov	ebp, DWORD PTR [esi+12]
	cmp	ebp, DWORD PTR [esi+16]
	jbe	SHORT $LN43@reserve@2
	call	__invalid_parameter_noinfo
$LN43@reserve@2:
	sub	edi, ebp
	sar	edi, 2
	test	edi, edi
	jbe	SHORT $LN86@reserve@2
	lea	eax, DWORD PTR [edi*4]
	push	eax
	push	ebp
	push	eax
	push	ebx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN86@reserve@2:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);
; 613  : 			_RERAISE;
; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+16]
	sub	edi, eax
	sar	edi, 2

; 617  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN93@reserve@2

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);
; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN93@reserve@2:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[esp+12]
	lea	ecx, DWORD PTR [ebx+eax*4]

; 628  : 			_Mylast = _Ptr + _Size;

	lea	edx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+16], edx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+12], ebx
$LN3@reserve@2:

; 630  : 			}
; 631  : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN96@reserve@2:
?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::reserve
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??A?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAEAAIAB_K@Z
_TEXT	SEGMENT
$T487470 = -24						; size = 16
__Where$ = -24						; size = 8
$T487473 = -8						; size = 8
$T487469 = -8						; size = 8
_this$ = 8						; size = 4
??A?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAEAAIAB_K@Z PROC ; std::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::operator[], COMDAT
; __Keyval$ = edi

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	sub	esp, 28					; 0000001cH
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+28]
	push	ebp
	push	esi

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	push	ebx
	mov	ecx, edi
	lea	eax, DWORD PTR __Where$[esp+44]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::lower_bound

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	mov	eax, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR __Where$[esp+40]
	mov	DWORD PTR $T487469[esp+44], eax
	mov	eax, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN20@operator@289
	cmp	esi, eax
	je	SHORT $LN21@operator@289
$LN20@operator@289:
	call	__invalid_parameter_noinfo
$LN21@operator@289:
	mov	ebp, DWORD PTR __Where$[esp+44]
	cmp	ebp, DWORD PTR $T487469[esp+44]
	je	SHORT $LN59@operator@289
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [ebp+20]
	ja	SHORT $LN2@operator@289
	jb	SHORT $LN59@operator@289
	mov	edx, DWORD PTR [edi]
	cmp	edx, DWORD PTR [ebp+16]
	jae	SHORT $LN2@operator@289
$LN59@operator@289:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+4]
	push	ebp
	push	esi
	lea	edx, DWORD PTR $T487470[esp+48]
	mov	DWORD PTR $T487470[esp+48], eax
	push	edx
	lea	eax, DWORD PTR $T487473[esp+52]
	push	eax
	push	ebx
	mov	DWORD PTR $T487470[esp+64], ecx
	mov	DWORD PTR $T487470[esp+68], 0
	call	?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert
	mov	esi, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
$LN2@operator@289:

; 174  : 		return ((*_Where).second);

	test	esi, esi
	jne	SHORT $LN58@operator@289
	call	__invalid_parameter_noinfo
$LN53@operator@289:
	cmp	ebp, DWORD PTR [esi+24]
	jne	SHORT $LN60@operator@289
	call	__invalid_parameter_noinfo
$LN60@operator@289:

; 175  : 		}

	pop	esi
	lea	eax, DWORD PTR [ebp+24]
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	4
$LN58@operator@289:

; 174  : 		return ((*_Where).second);

	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN53@operator@289
??A?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAEAAIAB_K@Z ENDP ; std::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAEAAVDelayCounter@Statistics@DRAMsimII@@AB_K@Z
_TEXT	SEGMENT
__Where$ = -48						; size = 8
$T487639 = -40						; size = 8
$T487637 = -40						; size = 16
$T487635 = -40						; size = 8
$T487636 = -24						; size = 24
_this$ = 8						; size = 4
??A?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAEAAVDelayCounter@Statistics@DRAMsimII@@AB_K@Z PROC ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::operator[], COMDAT
; __Keyval$ = edi

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	sub	esp, 52					; 00000034H
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+52]
	push	ebp
	push	esi

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	push	ebx
	mov	ecx, edi
	lea	eax, DWORD PTR __Where$[esp+68]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::lower_bound

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	mov	eax, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR __Where$[esp+64]
	mov	DWORD PTR $T487635[esp+68], eax
	mov	eax, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN20@operator@290
	cmp	esi, eax
	je	SHORT $LN21@operator@290
$LN20@operator@290:
	call	__invalid_parameter_noinfo
$LN21@operator@290:
	mov	ebp, DWORD PTR __Where$[esp+68]
	cmp	ebp, DWORD PTR $T487635[esp+68]
	je	SHORT $LN61@operator@290
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [ebp+20]
	ja	SHORT $LN2@operator@290
	jb	SHORT $LN61@operator@290
	mov	edx, DWORD PTR [edi]
	cmp	edx, DWORD PTR [ebp+16]
	jae	SHORT $LN2@operator@290
$LN61@operator@290:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	ecx, DWORD PTR [edi+4]
	xor	eax, eax
	push	ebp
	mov	DWORD PTR $T487637[esp+68], eax
	mov	DWORD PTR $T487637[esp+72], eax
	movq	xmm0, QWORD PTR $T487637[esp+68]
	mov	DWORD PTR $T487637[esp+76], eax
	mov	eax, DWORD PTR [edi]
	push	esi
	lea	edx, DWORD PTR $T487636[esp+72]
	mov	DWORD PTR $T487636[esp+72], eax
	push	edx
	lea	eax, DWORD PTR $T487639[esp+76]
	push	eax
	movq	QWORD PTR $T487636[esp+88], xmm0
	movq	xmm0, QWORD PTR $T487637[esp+88]
	push	ebx
	mov	DWORD PTR $T487636[esp+88], ecx
	movq	QWORD PTR $T487636[esp+100], xmm0
	call	?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert
	mov	esi, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
$LN2@operator@290:

; 174  : 		return ((*_Where).second);

	test	esi, esi
	jne	SHORT $LN60@operator@290
	call	__invalid_parameter_noinfo
$LN55@operator@290:
	cmp	ebp, DWORD PTR [esi+24]
	jne	SHORT $LN62@operator@290
	call	__invalid_parameter_noinfo
$LN62@operator@290:

; 175  : 		}

	pop	esi
	lea	eax, DWORD PTR [ebp+24]
	pop	ebp
	pop	ebx
	add	esp, 52					; 00000034H
	ret	4
$LN60@operator@290:

; 174  : 		return ((*_Where).second);

	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN55@operator@290
??A?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAEAAVDelayCounter@Statistics@DRAMsimII@@AB_K@Z ENDP ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::operator[]
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\list
xdata$x	SEGMENT
__unwindtable$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z$0
__tryblocktable$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z$2
__ehfuncinfo$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
$T552943 = -40						; size = 8
__Before$133006 = -32					; size = 8
__Next$ = -24						; size = 8
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
___formal$ = 12						; size = 1
__Where$ = 16						; size = 8
__First$ = 24						; size = 8
__Last$ = 32						; size = 8
??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Insert<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >, COMDAT

; 762  : 		void _Insert(const_iterator _Where,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR _this$[ebp]

; 763  : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 764  : 		{	// insert [_First, _Last) at _Where, forward iterators
; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		_DEBUG_RANGE(_First, _Last);
; 768  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 769  : 
; 770  : 		_Iter _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR __Next$[ebp], eax
	mov	DWORD PTR __Next$[ebp+4], ecx

; 771  : 
; 772  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 773  : 		for (; _First != _Last; ++_First)

$LL18@Insert@6:
	test	eax, eax
	je	SHORT $LN32@Insert@6
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN33@Insert@6
$LN32@Insert@6:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[ebp]
$LN33@Insert@6:
	mov	edx, DWORD PTR __First$[ebp+4]
	cmp	edx, DWORD PTR __Last$[ebp+4]
	je	$LN4@Insert@6

; 774  : 			_Insert(_Where, *_First);

	test	eax, eax
	jne	SHORT $LN74@Insert@6
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN51@Insert@6
$LN74@Insert@6:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN52@Insert@6
$LN51@Insert@6:
	xor	eax, eax
$LN52@Insert@6:
	mov	ecx, DWORD PTR __First$[ebp+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN41@Insert@6
	call	__invalid_parameter_noinfo
$LN41@Insert@6:
	mov	eax, DWORD PTR __Where$[ebp+4]
	mov	edx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR __First$[ebp+4]
	lea	edi, DWORD PTR [eax+4]
	push	edx
	add	esi, 8
	push	eax
	call	?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PAU342@0ABU?$pair@$$CBII@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode
	mov	ecx, ebx
	mov	esi, eax
	call	?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Incsize
	mov	DWORD PTR [edi], esi
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], esi
	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	jne	SHORT $LN73@Insert@6
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN24@Insert@6
$LN73@Insert@6:

; 773  : 		for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN25@Insert@6
$LN24@Insert@6:
	xor	ecx, ecx
$LN25@Insert@6:
	mov	edx, DWORD PTR __First$[ebp+4]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN14@Insert@6
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[ebp]
$LN14@Insert@6:
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __First$[ebp+4], edx
	jmp	$LL18@Insert@6
__catch$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z$0:

; 775  : 		_CATCH_ALL
; 776  : 		for (; _Next != _First; ++_Next)

	lea	esi, DWORD PTR __First$[ebp]
	lea	edi, DWORD PTR __Next$[ebp]
	call	??9?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator!=
	test	al, al
	je	SHORT $LN1@Insert@6
	mov	ebx, DWORD PTR _this$[ebp]
	npad	1
$LL3@Insert@6:

; 777  : 			{	// undo inserts
; 778  : 			const_iterator _Before = _Where;

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]

; 779  : 			erase(--_Before);

	lea	esi, DWORD PTR __Before$133006[ebp]
	mov	DWORD PTR __Before$133006[ebp], eax
	mov	DWORD PTR __Before$133006[ebp+4], ecx
	call	??F?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator--
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T552943[ebp]
	push	ecx
	mov	edi, ebx
	call	?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase
	lea	esi, DWORD PTR __Next$[ebp]
	call	??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator++
	lea	esi, DWORD PTR __First$[ebp]
	lea	edi, DWORD PTR __Next$[ebp]
	call	??9?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator!=
	test	al, al
	jne	SHORT $LL3@Insert@6
$LN1@Insert@6:

; 780  : 			}
; 781  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN77@Insert@6:
$LN4@Insert@6:

; 782  : 		_CATCH_END
; 783  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN76@Insert@6:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Insert<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >
; Function compile flags: /Ogtpy
;	COMDAT ??$insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00@Z
_TEXT	SEGMENT
$T553101 = 8						; size = 1
_this$ = 8						; size = 4
__Where$ = 12						; size = 8
__First$ = 20						; size = 8
__Last$ = 28						; size = 8
??$insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::insert<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >, COMDAT

; 731  : 		{	// insert [_First, _Last) at _Where
; 732  : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp]
	push	eax
	mov	eax, DWORD PTR __First$[esp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Where$[esp+8]
	push	eax
	mov	eax, DWORD PTR $T553101[esp+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+16]
	push	edx
	push	eax
	push	ecx
	call	??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Insert<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >

; 733  : 		}

	ret	28					; 0000001cH
??$insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::insert<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$0
__catchsym$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$2
__tryblocktable$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$5
__ehfuncinfo$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
_TEXT	SEGMENT
__Tmp$130037 = -40					; size = 8
$T553576 = -36						; size = 1
$T553189 = -36						; size = 1
__Tmp$130027 = -32					; size = 8
__Newvec$130012 = -28					; size = 4
__Capacity$ = -24					; size = 4
__$EHRec$ = -16						; size = 16
tv515 = 8						; size = 4
__Cat$553579 = 8					; size = 1
$T553526 = 8						; size = 1
__Cat$553529 = 8					; size = 1
$T553351 = 8						; size = 1
__Cat$553354 = 8					; size = 1
__Cat$553192 = 8					; size = 1
__Val$ = 8						; size = 4
__Where$ = 12						; size = 8
?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Insert_n, COMDAT
; _this$ = edx
; __Count$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	esi, edx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+12]
	test	edx, edx
	jne	SHORT $LN29@Insert_n@5
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@5
$LN29@Insert_n@5:
	mov	eax, DWORD PTR [esi+20]
	sub	eax, edx
	sar	eax, 3
	mov	ecx, eax
$LN30@Insert_n@5:

; 1162 : 
; 1163 : 		if (_Count == 0)

	test	edi, edi
	je	$LN1@Insert_n@5

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+16]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 3
	mov	edx, 536870911				; 1fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Xlen
$LN130@Insert_n@5:
$LN12@Insert_n@5:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 536870911				; 1fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@5
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@5:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@5:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	call	?allocate@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocate

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp+4]
	sub	ebx, DWORD PTR [esi+12]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Cat$553192[ebp]
	mov	BYTE PTR $T553189[ebp], 0
	mov	ecx, DWORD PTR $T553189[ebp]
	push	ecx
	mov	DWORD PTR __Newvec$130012[ebp], eax
	sar	ebx, 3
	push	edx
	mov	edx, DWORD PTR __Val$[ebp]
	lea	eax, DWORD PTR [eax+ebx*8]
	push	eax
	mov	ecx, edi
	call	??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR [esi+12]
	add	esp, 12					; 0000000cH
	mov	BYTE PTR $T553351[ebp], 0
	mov	ecx, DWORD PTR $T553351[ebp]
	mov	edx, DWORD PTR __Cat$553354[ebp]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	eax, DWORD PTR __Newvec$130012[ebp]
	call	??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	mov	BYTE PTR $T553526[ebp], 0
	mov	ecx, DWORD PTR $T553526[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Cat$553529[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$130012[ebp]
	lea	eax, DWORD PTR [ebx+eax*8]
	push	ecx
	call	??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+16]
	sub	edx, eax
	sar	edx, 3
	add	esp, 12					; 0000000cH
	add	edi, edx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN117@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN117@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	ecx, DWORD PTR [ebx+eax*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [ebx+edi*8]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+16], edx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+12], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$130012[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN131@Insert_n@5:
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR __Where$[ebp+4]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, ebx
	sub	ecx, edx
	sar	ecx, 3
	cmp	ecx, edi
	mov	ecx, DWORD PTR [eax]
	jae	SHORT $LN3@Insert_n@5
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$130027[ebp+4], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [edi*8]
	mov	DWORD PTR tv515[ebp], eax
	add	eax, edx
	push	eax
	push	ebx
	mov	DWORD PTR __Tmp$130027[ebp], ecx
	call	??$_Umove@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU234@00@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Umove<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp+4]
	mov	BYTE PTR $T553576[ebp], 0
	mov	edx, DWORD PTR $T553576[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$553579[ebp]
	sar	ecx, 3
	push	edx
	sub	edi, ecx
	mov	ecx, edi
	push	eax
	lea	edx, DWORD PTR __Tmp$130027[ebp]
	call	??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	sub	edx, eax
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR __Tmp$130027[ebp]

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN129@Insert_n@5
$LN3@Insert_n@5:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR [eax+4]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [edi*8]
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	mov	DWORD PTR __Tmp$130037[ebp+4], edx
	push	ebx
	mov	edx, edi
	mov	DWORD PTR __Tmp$130037[ebp], ecx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU234@00@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Umove<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
	mov	DWORD PTR [esi+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	esi, DWORD PTR __Where$[ebp+4]
	mov	edx, ebx
	mov	ecx, edi
	call	??$_Unchecked_move_backward@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z ; stdext::_Unchecked_move_backward<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR tv515[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax]
	lea	ecx, DWORD PTR __Tmp$130037[ebp]
$LN129@Insert_n@5:
	push	eax
	call	??$fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z ; std::fill<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
	add	esp, 4
$LN1@Insert_n@5:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN128@Insert_n@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Count$ = 12						; size = 4
__Where$ = 16						; size = 8
?insert@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::insert, COMDAT
; __Val$ = edx

; 882  : 		{	// insert _Count * _Val at _Where

	push	ecx

; 883  : 		_Insert_n(_Where, _Count, _Val);

	mov	eax, DWORD PTR __Where$[esp+4]
	mov	ecx, DWORD PTR __Where$[esp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR _this$[esp+12]
	call	?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Insert_n
	pop	ecx

; 884  : 		}

	ret	16					; 00000010H
?insert@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::insert
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@00I_N@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
__First$ = 16						; size = 8
__Last$ = 24						; size = 8
?_Splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@00I_N@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Splice, COMDAT
; _this$ = ecx
; __Right$ = esi

; 1126 : 		{	// splice _Right [_First, _Last) before _Where

	push	ecx

; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 		if (_Where._Mycont != this)
; 1129 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1130 : 		if (this->_Alval == _Right._Alval)
; 1131 : 			{	// same allocator, just relink
; 1132 : 			if (!_Keep && this != &_Right)
; 1133 : 				for (const_iterator _Next = _First; _Next != _Last; )
; 1134 : 					_Orphan_ptr(_Right, (_Next++)._Ptr);
; 1135 : 
; 1136 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1137 :         _Keep;                  // unused in this branch
; 1138 : 		if (this->_Alval == _Right._Alval)
; 1139 : 			{	// same allocator, just relink
; 1140 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1141 : 
; 1142 : 			if (this != &_Right)

	cmp	ecx, esi
	je	SHORT $LN2@Splice@2

; 1143 : 				{	// splicing from another list, adjust counts
; 1144 : 				_Incsize(_Count);

	call	?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Incsize

; 1145 : 				_Right._Mysize -= _Count;

	dec	DWORD PTR [esi+24]
$LN2@Splice@2:

; 1146 : 				}
; 1147 : 			_Nextnode(_Prevnode(_First._Mynode())) = _Last._Mynode();

	mov	eax, DWORD PTR __First$[esp+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Last$[esp+4]
	mov	DWORD PTR [ecx], edx

; 1148 : 			_Nextnode(_Prevnode(_Last._Mynode())) = _Where._Mynode();

	mov	eax, DWORD PTR __Last$[esp+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Where$[esp+4]
	mov	DWORD PTR [ecx], edx

; 1149 : 			_Nextnode(_Prevnode(_Where._Mynode())) = _First._Mynode();

	mov	eax, DWORD PTR __Where$[esp+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __First$[esp+4]
	mov	DWORD PTR [ecx], edx

; 1150 : 			_Nodeptr _Pnode = _Prevnode(_Where._Mynode());

	mov	eax, DWORD PTR __Where$[esp+4]

; 1151 : 			_Prevnode(_Where._Mynode()) = _Prevnode(_Last._Mynode());

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+4], edx

; 1152 : 			_Prevnode(_Last._Mynode()) = _Prevnode(_First._Mynode());

	mov	eax, DWORD PTR __First$[esp+4]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[esp+4]
	mov	DWORD PTR [eax+4], edx

; 1153 : 			_Prevnode(_First._Mynode()) = _Pnode;

	mov	edx, DWORD PTR __First$[esp+4]
	mov	DWORD PTR [edx+4], ecx
	pop	ecx

; 1154 : 			}
; 1155 : 		else
; 1156 : 			{	// different allocator, copy nodes then erase source
; 1157 : 			insert(_Where, _First, _Last);
; 1158 : 			_Right.erase(_First, _Last);
; 1159 : 			}
; 1160 :         }

	ret	24					; 00000018H
?_Splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@00I_N@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Splice
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
_TEXT	SEGMENT
__Tmp$ = -16						; size = 8
$T553719 = -8						; size = 8
__Count$ = 8						; size = 4
?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Assign_n, COMDAT
; _this$ = ecx
; __Val$ = eax

; 1095 : 		{	// assign _Count * _Val

	sub	esp, 16					; 00000010H

; 1096 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR [eax+4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 1097 : 		erase(begin(), end());

	mov	esi, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[esp+32], ecx
	mov	DWORD PTR __Tmp$[esp+36], edx
	cmp	DWORD PTR [edi+12], esi
	jbe	SHORT $LN8@Assign_n@2
	call	__invalid_parameter_noinfo
$LN8@Assign_n@2:
	mov	ebx, DWORD PTR [edi+12]
	mov	ebp, DWORD PTR [edi]
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN24@Assign_n@2
	call	__invalid_parameter_noinfo
$LN24@Assign_n@2:
	mov	eax, DWORD PTR [edi]
	push	esi
	push	ebp
	push	ebx
	push	eax
	lea	eax, DWORD PTR $T553719[esp+48]
	push	eax
	call	?erase@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@0@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::erase

; 1098 : 		insert(begin(), _Count, _Tmp);

	mov	esi, DWORD PTR [edi+12]
	cmp	esi, DWORD PTR [edi+16]
	jbe	SHORT $LN40@Assign_n@2
	call	__invalid_parameter_noinfo
$LN40@Assign_n@2:
	mov	eax, DWORD PTR [edi]
	push	esi
	push	eax
	lea	ecx, DWORD PTR __Tmp$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+40]
	mov	edx, edi
	call	?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Insert_n

; 1099 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Assign_n
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@0@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Where$ = 12						; size = 8
__First$ = 20						; size = 8
?splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@0@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::splice, COMDAT
; __Right$ = eax

; 883  : 		{	// splice _Right [_First, _First + 1) at _Where

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]
	push	esi
	mov	esi, eax

; 884  : 
; 885  :  #if _HAS_ITERATOR_DEBUGGING
; 886  : 		if (_First == _Right.end())
; 887  : 			_DEBUG_ERROR("list splice iterator outside range");
; 888  : 		else
; 889  : 
; 890  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 891  : 		if (_First != _Right.end())

	mov	eax, DWORD PTR __First$[esp+8]
	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN24@splice@2
	cmp	eax, ecx
	je	SHORT $LN25@splice@2
$LN24@splice@2:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+12]
$LN25@splice@2:
	mov	ecx, DWORD PTR __First$[esp+16]
	cmp	ecx, edi
	je	SHORT $LN2@splice@2

; 892  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 893  : 
; 894  : 			{	// element exists, try splice
; 895  : 			const_iterator _Last = _First;

	mov	ebx, eax
	mov	edi, ecx

; 896  : 			++_Last;

	test	eax, eax
	jne	SHORT $LN71@splice@2
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+12]
	xor	ecx, ecx
$LN44@splice@2:
	cmp	edi, DWORD PTR [ecx+20]
	jne	SHORT $LN33@splice@2
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+12]
$LN33@splice@2:
	mov	edi, DWORD PTR [edi]

; 897  : 			if (this != &_Right
; 898  : 				|| (_Where != _First && _Where != _Last))

	mov	ecx, DWORD PTR __Where$[esp+12]
	cmp	ebp, esi
	jne	SHORT $LN1@splice@2
	test	ecx, ecx
	je	SHORT $LN51@splice@2
	cmp	ecx, eax
	je	SHORT $LN52@splice@2
$LN51@splice@2:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+12]
	mov	ecx, DWORD PTR __Where$[esp+12]
$LN52@splice@2:
	mov	edx, DWORD PTR __First$[esp+16]
	cmp	DWORD PTR __Where$[esp+16], edx
	je	SHORT $LN2@splice@2
	test	ecx, ecx
	je	SHORT $LN62@splice@2
	cmp	ecx, ebx
	je	SHORT $LN63@splice@2
$LN62@splice@2:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+12]
	mov	ecx, DWORD PTR __Where$[esp+12]
$LN63@splice@2:
	cmp	DWORD PTR __Where$[esp+16], edi
	je	SHORT $LN2@splice@2
$LN1@splice@2:

; 899  : 				_Splice(_Where, _Right, _First, _Last, 1);

	mov	edx, DWORD PTR __First$[esp+16]
	push	edi
	push	ebx
	push	edx
	push	eax
	mov	eax, DWORD PTR __Where$[esp+32]
	push	eax
	push	ecx
	mov	ecx, ebp
	call	?_Splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@00I_N@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Splice
$LN2@splice@2:

; 900  : 			}
; 901  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	20					; 00000014H
$LN71@splice@2:

; 896  : 			++_Last;

	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN44@splice@2
?splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@0@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::splice
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1102 : 		{	// allocate array with _Capacity elements

	push	ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@13

; 1105 : 			return (false);

	xor	al, al
	pop	ecx

; 1115 : 		}

	ret	0
$LN4@Buy@13:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@13

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN14@Buy@13:
$LN2@Buy@13:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	ecx

; 1115 : 		}

	ret	0
$LN13@Buy@13:
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?assign@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::assign, COMDAT
; _this$ = ecx
; __Count$ = eax

; 871  : 		_Assign_n(_Count, _Val);

	push	eax
	mov	eax, DWORD PTR __Val$[esp]
	call	?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Assign_n

; 872  : 		}

	ret	4
?assign@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n, COMDAT
; _this$ = esi
; __Count$ = edi

; 545  : 		{	// construct from _Count * _Val

	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	push	ebp

; 546  : 		if (_Buy(_Count))

	xor	ebp, ebp
	mov	DWORD PTR [esi+12], ebp
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebp
	cmp	edi, ebp
	je	SHORT $LN5@Construct_@3
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN10@Construct_@3
	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN50@Construct_@3:
$LN10@Construct_@3:
	mov	ecx, edi
	call	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	ecx, edi
	mov	edx, eax
	cmp	edi, ebp
	jbe	SHORT $LN40@Construct_@3
	npad	3
$LL42@Construct_@3:
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR [edx], ebp
	dec	ecx
	add	edx, 4
	test	ecx, ecx
	ja	SHORT $LL42@Construct_@3
$LN40@Construct_@3:
	lea	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+16], edx
$LN5@Construct_@3:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();
; 552  : 			_RERAISE;
; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	pop	ebp
	pop	ebx
	ret	4
$LN49@Construct_@3:
?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Init@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXI@Z
_TEXT	SEGMENT
$T554348 = -8						; size = 8
?_Init@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXI@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Init, COMDAT
; _this$ = esi
; __Buckets$ = edi

; 829  : 		{	// initialize hash table with _Buckets buckets, leave list alone

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 830  : 		_Vec.assign(_Buckets + 1, end());

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+28]
	sub	esp, 8
	test	eax, eax
	je	SHORT $LN25@Init@5
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN26@Init@5
$LN25@Init@5:
	xor	eax, eax
$LN26@Init@5:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T554348[esp+12], ecx
	lea	ecx, DWORD PTR [edi+1]
	mov	DWORD PTR $T554348[esp+8], eax
	push	ecx
	lea	ecx, DWORD PTR [esi+36]
	lea	eax, DWORD PTR $T554348[esp+12]
	call	?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Assign_n

; 831  : 		_Mask = _Buckets - 1;

	lea	edx, DWORD PTR [edi-1]
	mov	DWORD PTR [esi+60], edx

; 832  : 		_Maxidx = _Buckets;

	mov	DWORD PTR [esi+64], edi

; 833  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXI@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Init
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z$1
__ehfuncinfo$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
xdata$x	ENDS
;	COMDAT ??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Parg$ = 12						; size = 4
??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >, COMDAT

; 343  : 		{	// construct empty hash table

	push	-1
	push	__ehhandler$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+24]
	mov	eax, DWORD PTR __Parg$[esp+24]
	mov	cx, WORD PTR [eax]
	lea	edx, DWORD PTR [esi+8]
	push	edx
	mov	WORD PTR [esi+4], cx
	call	??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
	lea	eax, DWORD PTR [esi+36]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+40], 0
	call	??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
	mov	BYTE PTR __$EHRec$[esp+36], 1
	movss	xmm0, DWORD PTR __real@40800000

; 344  : 		_Init();

	mov	edi, 8
	movss	DWORD PTR [esi+68], xmm0
	call	?_Init@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Init

; 345  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 8
	jmp	??1?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::~list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z$1:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 36					; 00000024H
	jmp	??1?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@XZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::~vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
__ehhandler$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?reserve@?$vector@_JV?$allocator@_J@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@_JV?$allocator@_J@std@@@std@@QAEXI@Z PROC ; std::vector<__int64,std::allocator<__int64> >::reserve, COMDAT
; _this$ = esi

; 602  : 		{	// determine new minimum length of allocated storage

	push	ecx

; 603  : 		if (max_size() < _Count)

	mov	ecx, DWORD PTR __Count$[esp]
	push	ebx
	push	ebp
	push	edi
	cmp	ecx, 536870911				; 1fffffffH
	jbe	SHORT $LN5@reserve@6

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ ; std::vector<__int64,std::allocator<__int64> >::_Xlen
$LN97@reserve@6:
$LN5@reserve@6:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR [esi+12]
	test	edx, edx
	jne	SHORT $LN20@reserve@6
	xor	eax, eax
	jmp	SHORT $LN21@reserve@6
$LN20@reserve@6:
	mov	eax, DWORD PTR [esi+20]
	sub	eax, edx
	sar	eax, 3
$LN21@reserve@6:
	cmp	eax, ecx
	jae	SHORT $LN3@reserve@6

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	call	?allocate@?$allocator@_J@std@@QAEPA_JI@Z ; std::allocator<__int64>::allocate

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	edi, DWORD PTR [esi+16]
	mov	ebx, eax
	cmp	DWORD PTR [esi+12], edi
	jbe	SHORT $LN27@reserve@6
	call	__invalid_parameter_noinfo
$LN27@reserve@6:
	mov	ebp, DWORD PTR [esi+12]
	cmp	ebp, DWORD PTR [esi+16]
	jbe	SHORT $LN43@reserve@6
	call	__invalid_parameter_noinfo
$LN43@reserve@6:
	sub	edi, ebp
	sar	edi, 3
	test	edi, edi
	jbe	SHORT $LN86@reserve@6
	lea	eax, DWORD PTR [edi*8]
	push	eax
	push	ebp
	push	eax
	push	ebx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN86@reserve@6:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);
; 613  : 			_RERAISE;
; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+16]
	sub	edi, eax
	sar	edi, 3

; 617  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN93@reserve@6

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);
; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN93@reserve@6:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[esp+12]
	lea	ecx, DWORD PTR [ebx+eax*8]

; 628  : 			_Mylast = _Ptr + _Size;

	lea	edx, DWORD PTR [ebx+edi*8]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+16], edx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+12], ebx
$LN3@reserve@6:

; 630  : 			}
; 631  : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN96@reserve@6:
?reserve@?$vector@_JV?$allocator@_J@std@@@std@@QAEXI@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::reserve
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
$T555130 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; __Count$ = edi

; 482  : 		{	// construct from _Count * _Ty()

	push	-1
	push	__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@40
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@40
$LN13@vector@40:
	xor	eax, eax
$LN14@vector@40:
	mov	DWORD PTR [esi], eax

; 483  : 		_Construct_n(_Count, _Ty());

	lea	eax, DWORD PTR $T555130[esp+24]
	mov	DWORD PTR __$EHRec$[esp+32], ecx
	push	eax
	mov	DWORD PTR $T555130[esp+28], ecx
	call	?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n

; 484  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >, COMDAT
; _this$ = esi

; 103  : 		{	// construct empty map from defaults

	push	esi
	call	??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >

; 104  : 		}

	mov	eax, esi
	ret	0
??0?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAE@XZ PROC ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >, COMDAT
; _this$ = esi

; 103  : 		{	// construct empty map from defaults

	push	esi
	call	??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >

; 104  : 		}

	mov	eax, esi
	ret	0
??0?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAE@XZ ENDP ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ
_TEXT	SEGMENT
$T555492 = -8						; size = 8
?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear, COMDAT
; _this$ = esi

; 613  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 614  : 		_List.clear();

	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ecx
	mov	ecx, DWORD PTR [esi+28]
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+4], ecx
	push	edi
	mov	DWORD PTR [esi+32], 0
	cmp	eax, DWORD PTR [esi+28]
	je	SHORT $LN3@clear@19
$LL5@clear@19:
	mov	edi, DWORD PTR [eax]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, edi
	cmp	edi, DWORD PTR [esi+28]
	jne	SHORT $LL5@clear@19
$LN3@clear@19:

; 615  : 		_Init();

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN42@clear@19
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN43@clear@19
$LN42@clear@19:
	xor	eax, eax
$LN43@clear@19:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T555492[esp+20], ecx
	mov	DWORD PTR $T555492[esp+16], eax
	push	9
	lea	ecx, DWORD PTR [esi+36]
	lea	eax, DWORD PTR $T555492[esp+20]
	call	?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Assign_n
	mov	DWORD PTR [esi+60], 7
	mov	DWORD PTR [esi+64], 8

; 616  : 		}

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ??0?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
_TEXT	SEGMENT
$T555544 = -2						; size = 2
??0?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ PROC ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >, COMDAT
; _this$ = esi

; 118  : 		{	// construct empty map from defaults

	push	ecx
	lea	eax, DWORD PTR $T555544[esp+4]
	push	eax
	push	esi
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >

; 119  : 		}

	mov	eax, esi
	pop	ecx
	ret	0
??0?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ ENDP ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
_TEXT	ENDS
PUBLIC	?clear@Statistics@DRAMsimII@@QAEXXZ		; DRAMsimII::Statistics::clear
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.cpp
_TEXT	SEGMENT
?clear@Statistics@DRAMsimII@@QAEXXZ PROC		; DRAMsimII::Statistics::clear
; _this$ = eax

; 313  : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, eax

; 314  : 	using std::vector;
; 315  : 
; 316  : 	commandTurnaround.clear();

	lea	esi, DWORD PTR [edi+212]
	call	?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear

; 317  : 	commandDelay.clear();	

	lea	esi, DWORD PTR [edi+68]
	call	?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear

; 318  : 	commandExecution.clear();

	lea	esi, DWORD PTR [edi+140]
	call	?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear

; 319  : 	transactionExecution.clear();

	lea	esi, DWORD PTR [edi+356]
	call	?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear

; 320  : 	transactionDecodeDelay.clear();

	lea	esi, DWORD PTR [edi+284]
	call	?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear

; 321  : 	workingSet.clear();

	mov	eax, DWORD PTR [edi+484]
	mov	ecx, DWORD PTR [eax+4]
	lea	esi, DWORD PTR [edi+460]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+24]
	xor	ebx, ebx
	mov	DWORD PTR [esi+28], ebx
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], esi

; 322  : 	issuedAtTFAW = rowHits = rowMisses = readBytesTransferred = writeBytesTransferred = readCount = writeCount = 0;

	mov	DWORD PTR [edi+40], ebx
	mov	DWORD PTR [edi+36], ebx
	mov	DWORD PTR [edi+48], ebx
	mov	DWORD PTR [edi+44], ebx
	mov	DWORD PTR [edi+60], ebx
	mov	DWORD PTR [edi+56], ebx
	mov	DWORD PTR [edi+64], ebx

; 323  : 	for (vector<unsigned>::size_type i = 0; i < aggregateBankUtilization.size(); i++)

	mov	edx, DWORD PTR [edi+508]
	sub	edx, DWORD PTR [edi+504]
	xor	esi, esi
	sar	edx, 2
	test	edx, edx
	jbe	SHORT $LN4@clear@20
$LL6@clear@20:

; 324  : 		aggregateBankUtilization[i] = 0;

	mov	eax, DWORD PTR [edi+508]
	sub	eax, DWORD PTR [edi+504]
	sar	eax, 2
	cmp	esi, eax
	jb	SHORT $LN29@clear@20
	call	__invalid_parameter_noinfo
$LN29@clear@20:
	mov	ecx, DWORD PTR [edi+504]
	mov	DWORD PTR [ecx+esi*4], ebx
	mov	edx, DWORD PTR [edi+508]
	sub	edx, DWORD PTR [edi+504]
	inc	esi
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LL6@clear@20
$LN4@clear@20:

; 325  : 	for (vector<unsigned>::size_type i = 0; i < bankLatencyUtilization.size(); i++)

	mov	eax, DWORD PTR [edi+532]
	sub	eax, DWORD PTR [edi+528]
	xor	esi, esi
	sar	eax, 3
	test	eax, eax
	jbe	SHORT $LN1@clear@20
	npad	5
$LL3@clear@20:

; 326  : 		bankLatencyUtilization[i] = 0;

	mov	ecx, DWORD PTR [edi+532]
	sub	ecx, DWORD PTR [edi+528]
	sar	ecx, 3
	cmp	esi, ecx
	jb	SHORT $LN36@clear@20
	call	__invalid_parameter_noinfo
$LN36@clear@20:
	mov	eax, DWORD PTR [edi+528]
	mov	DWORD PTR [eax+esi*8], ebx
	mov	DWORD PTR [eax+esi*8+4], ebx
	mov	edx, DWORD PTR [edi+532]
	sub	edx, DWORD PTR [edi+528]
	inc	esi
	sar	edx, 3
	cmp	esi, edx
	jb	SHORT $LL3@clear@20
$LN1@clear@20:

; 327  : 	pcOccurrence.clear();

	mov	eax, DWORD PTR [edi+452]
	mov	ebp, DWORD PTR [eax+4]
	add	edi, 428				; 000001acH
	mov	esi, ebp
	cmp	BYTE PTR [ebp+41], bl
	jne	SHORT $LN47@clear@20
	npad	1
$LL49@clear@20:
	mov	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, edi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Erase
	mov	esi, DWORD PTR [esi]
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	ebp, esi
	cmp	BYTE PTR [esi+41], bl
	je	SHORT $LL49@clear@20
$LN47@clear@20:
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [edi+28], ebx
	mov	DWORD PTR [eax], eax
	mov	edi, DWORD PTR [edi+24]
	mov	DWORD PTR [edi+8], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 328  : #ifdef M5
; 329  : 	//async_statdump =
; 330  : 	async_event = async_statreset = true;	
; 331  : #endif // M5DEBUG
; 332  : }

	ret	0
?clear@Statistics@DRAMsimII@@QAEXXZ ENDP		; DRAMsimII::Statistics::clear
_TEXT	ENDS
PUBLIC	??0Statistics@DRAMsimII@@AAE@XZ			; DRAMsimII::Statistics::Statistics
__ehfuncinfo$??0Statistics@DRAMsimII@@AAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??0Statistics@DRAMsimII@@AAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0Statistics@DRAMsimII@@AAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$7
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T555849 = 8						; size = 2
$T555830 = 8						; size = 2
$T555811 = 8						; size = 2
$T555792 = 8						; size = 2
$T555773 = 8						; size = 2
_this$ = 8						; size = 4
??0Statistics@DRAMsimII@@AAE@XZ PROC			; DRAMsimII::Statistics::Statistics

; 106  : {}

	push	-1
	push	__ehhandler$??0Statistics@DRAMsimII@@AAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	xorps	xmm0, xmm0
	or	eax, -1
	xor	edi, edi
	lea	ecx, DWORD PTR $T555773[esp+20]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	lea	eax, DWORD PTR [esi+68]
	push	ecx
	push	eax
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+36], edi
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	mov	DWORD PTR [esi+48], edi
	movss	DWORD PTR [esi+52], xmm0
	mov	DWORD PTR [esi+56], edi
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [esi+64], edi
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	edx, DWORD PTR $T555792[esp+20]
	lea	eax, DWORD PTR [esi+140]
	push	edx
	push	eax
	mov	DWORD PTR __$EHRec$[esp+40], edi
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	ecx, DWORD PTR $T555811[esp+20]
	lea	eax, DWORD PTR [esi+212]
	push	ecx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+40], 1
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	edx, DWORD PTR $T555830[esp+20]
	lea	eax, DWORD PTR [esi+284]
	push	edx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+40], 2
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	ecx, DWORD PTR $T555849[esp+20]
	lea	eax, DWORD PTR [esi+356]
	push	ecx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+40], 3
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	eax, DWORD PTR [esi+428]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+36], 4
	call	??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
	lea	eax, DWORD PTR [esi+460]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+36], 5
	call	??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
	lea	edx, DWORD PTR [esi+492]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+36], 6
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	lea	eax, DWORD PTR [esi+516]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+36], 7
	call	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 68					; 00000044H
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$1:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 140				; 0000008cH
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$2:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 212				; 000000d4H
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$3:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 284				; 0000011cH
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$4:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 356				; 00000164H
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$5:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 428				; 000001acH
	push	eax
	call	??1?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAE@XZ
	ret	0
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$6:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 460				; 000001ccH
	push	eax
	call	??1?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAE@XZ
	ret	0
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$7:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 492				; 000001ecH
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__ehhandler$??0Statistics@DRAMsimII@@AAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Statistics@DRAMsimII@@AAE@XZ
	jmp	___CxxFrameHandler3
??0Statistics@DRAMsimII@@AAE@XZ ENDP			; DRAMsimII::Statistics::Statistics
PUBLIC	??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z	; DRAMsimII::Statistics::Statistics
__unwindtable$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$8
__ehfuncinfo$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
tv448 = -16						; size = 4
tv445 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T555994 = 12						; size = 2
$T555975 = 12						; size = 2
$T555956 = 12						; size = 2
$T555937 = 12						; size = 2
$T555918 = 12						; size = 2
_settings$ = 12						; size = 4
??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z PROC	; DRAMsimII::Statistics::Statistics

; 71   : {

	push	-1
	push	__ehhandler$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _settings$[esp+32]
	mov	ebx, DWORD PTR _this$[esp+32]
	mov	eax, DWORD PTR [ebp+300]
	mov	DWORD PTR [ebx], eax
	mov	ecx, DWORD PTR [ebp+304]
	xor	esi, esi
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR [ebp+308]
	mov	DWORD PTR [ebx+8], edx
	mov	DWORD PTR [ebx+12], esi
	mov	DWORD PTR [ebx+16], esi
	mov	DWORD PTR [ebx+20], esi
	mov	DWORD PTR [ebx+24], esi
	mov	DWORD PTR [ebx+28], esi
	mov	ecx, DWORD PTR [ebp+224]
	xor	eax, eax
	shr	ecx, 1
	je	SHORT $LN12@Statistics@11
$LL14@Statistics@11:
	inc	eax
	shr	ecx, 1
	jne	SHORT $LL14@Statistics@11
$LN12@Statistics@11:
	mov	DWORD PTR [ebx+32], eax
	mov	DWORD PTR [ebx+36], esi
	mov	DWORD PTR [ebx+40], esi
	mov	DWORD PTR [ebx+44], esi
	mov	DWORD PTR [ebx+48], esi
	fild	DWORD PTR [ebp+28]
	mov	eax, DWORD PTR [ebp+28]
	test	eax, eax
	jge	SHORT $LN65@Statistics@11
	fadd	DWORD PTR __real@4f800000
$LN65@Statistics@11:
	mov	ecx, DWORD PTR [ebp+204]
	fild	DWORD PTR [ebp+204]
	test	ecx, ecx
	jge	SHORT $LN66@Statistics@11
	fadd	DWORD PTR __real@4f800000
$LN66@Statistics@11:
	fdivp	ST(1), ST(0)
	lea	edx, DWORD PTR $T555918[esp+32]
	lea	eax, DWORD PTR [ebx+68]
	push	edx
	push	eax
	mov	DWORD PTR [ebx+56], esi
	mov	DWORD PTR [ebx+60], esi
	mov	DWORD PTR [ebx+64], esi
	fstp	DWORD PTR [ebx+52]
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	ecx, DWORD PTR $T555937[esp+32]
	lea	eax, DWORD PTR [ebx+140]
	push	ecx
	push	eax
	mov	DWORD PTR __$EHRec$[esp+52], esi
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	edx, DWORD PTR $T555956[esp+32]
	lea	eax, DWORD PTR [ebx+212]
	push	edx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+52], 1
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	ecx, DWORD PTR $T555975[esp+32]
	lea	eax, DWORD PTR [ebx+284]
	push	ecx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+52], 2
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	edx, DWORD PTR $T555994[esp+32]
	lea	eax, DWORD PTR [ebx+356]
	push	edx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+52], 3
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	eax, DWORD PTR [ebx+428]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+48], 4
	call	??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
	lea	eax, DWORD PTR [ebx+460]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+48], 5
	call	??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
	mov	BYTE PTR __$EHRec$[esp+44], 6
	mov	edi, DWORD PTR [ebp+308]
	imul	edi, DWORD PTR [ebp+304]
	imul	edi, DWORD PTR [ebp+300]
	lea	eax, DWORD PTR [ebx+492]
	push	eax
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	mov	BYTE PTR __$EHRec$[esp+44], 7
	mov	edi, DWORD PTR [ebp+308]
	imul	edi, DWORD PTR [ebp+304]
	imul	edi, DWORD PTR [ebp+300]
	lea	esi, DWORD PTR [ebx+516]
	push	esi
	call	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
	mov	BYTE PTR __$EHRec$[esp+44], 8

; 72   : 	bankLatencyUtilization.reserve(settings.channelCount * settings.rankCount * settings.bankCount);

	mov	eax, DWORD PTR [ebp+308]
	imul	eax, DWORD PTR [ebp+304]
	imul	eax, DWORD PTR [ebp+300]
	push	eax
	call	?reserve@?$vector@_JV?$allocator@_J@std@@@std@@QAEXI@Z ; std::vector<__int64,std::allocator<__int64> >::reserve

; 73   : 	aggregateBankUtilization.reserve(settings.channelCount * settings.rankCount * settings.bankCount);

	mov	ecx, DWORD PTR [ebp+308]
	imul	ecx, DWORD PTR [ebp+304]
	imul	ecx, DWORD PTR [ebp+300]
	push	ecx
	lea	esi, DWORD PTR [ebx+492]
	call	?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::reserve

; 74   : }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 68					; 00000044H
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$1:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 140				; 0000008cH
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$2:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 212				; 000000d4H
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$3:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 284				; 0000011cH
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$4:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 356				; 00000164H
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$5:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 428				; 000001acH
	push	eax
	call	??1?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAE@XZ
	ret	0
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$6:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 460				; 000001ccH
	push	eax
	call	??1?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAE@XZ
	ret	0
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$7:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 492				; 000001ecH
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$8:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 516				; 00000204H
	jmp	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
__ehhandler$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z
	jmp	___CxxFrameHandler3
??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z ENDP	; DRAMsimII::Statistics::Statistics
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?_Insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@4@@Z
_TEXT	SEGMENT
__Bucket$ = -28						; size = 4
__Num$573504 = -24					; size = 4
tv1572 = -20						; size = 4
tv1569 = -20						; size = 4
tv1566 = -20						; size = 4
tv1277 = -20						; size = 4
$T574774 = -20						; size = 4
__Tmp$575029 = -16					; size = 8
__Plist$ = -16						; size = 8
$T575035 = -8						; size = 8
$T575032 = -8						; size = 8
$T573473 = -8						; size = 8
$T573472 = -8						; size = 8
$T573468 = -8						; size = 8
$T573466 = -8						; size = 8
$T573463 = -8						; size = 8
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Val$ = 16						; size = 4
__Where$ = 20						; size = 8
?_Insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@4@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Insert, COMDAT

; 836  : 		{	// try to insert (possibly existing) node with value _Val

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 837  : 		size_type _Bucket = _Hashval(this->_Kfn(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	push	127773					; 0001f31dH
	push	ecx
	call	_ldiv
	imul	eax, 2836				; 00000b14H
	imul	edx, 16807				; 000041a7H
	add	esp, 8
	sub	edx, eax
	jns	SHORT $LN28@Insert@8
	add	edx, 2147483647				; 7fffffffH
$LN28@Insert@8:
	mov	edi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edi+60]
	mov	eax, ecx
	and	eax, edx
	mov	DWORD PTR __Num$573504[esp+40], eax
	cmp	DWORD PTR [edi+64], eax
	ja	SHORT $LN23@Insert@8
	shr	ecx, 1
	or	edx, -1
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR __Num$573504[esp+40], eax
$LN23@Insert@8:

; 838  : 		iterator _Plist = _Get_iter_from_vec(_Vec[_Bucket + 1]);

	lea	ebx, DWORD PTR [eax+1]
	mov	DWORD PTR __Bucket$[esp+40], eax
	mov	eax, DWORD PTR [edi+52]
	sub	eax, DWORD PTR [edi+48]
	lea	esi, DWORD PTR [edi+36]
	sar	eax, 3
	cmp	ebx, eax
	jb	SHORT $LN31@Insert@8
	call	__invalid_parameter_noinfo
$LN31@Insert@8:
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [ecx+ebx*8+4]
	add	edi, 8
	mov	DWORD PTR tv1277[esp+40], edi
	mov	DWORD PTR __Plist$[esp+44], edx
	jne	SHORT $LN44@Insert@8
	call	__invalid_parameter_noinfo
$LN44@Insert@8:
	mov	ebx, DWORD PTR [edi]
	mov	DWORD PTR __Plist$[esp+40], ebx
$LN18@Insert@8:

; 839  : 
; 840  : 		for (; _Plist != _Get_iter_from_vec(_Vec[_Bucket]); )

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 3
	cmp	DWORD PTR __Num$573504[esp+40], eax
	jb	SHORT $LN56@Insert@8
	call	__invalid_parameter_noinfo
$LN56@Insert@8:
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR __Num$573504[esp+40]
	mov	eax, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR $T573463[esp+44], eax
	test	edi, edi
	jne	SHORT $LN69@Insert@8
	call	__invalid_parameter_noinfo
$LN69@Insert@8:
	mov	eax, DWORD PTR [edi]
	test	ebx, ebx
	je	SHORT $LN83@Insert@8
	cmp	ebx, eax
	je	SHORT $LN84@Insert@8
$LN83@Insert@8:
	call	__invalid_parameter_noinfo
$LN84@Insert@8:
	mov	ecx, DWORD PTR __Plist$[esp+44]
	cmp	ecx, DWORD PTR $T573463[esp+44]
	je	$LN17@Insert@8

; 841  : 			if (this->comp(this->_Kfn(_Val), this->_Kfn(*--_Plist)))

	test	ebx, ebx
	jne	SHORT $LN96@Insert@8
	call	__invalid_parameter_noinfo
$LN96@Insert@8:
	mov	edx, DWORD PTR __Plist$[esp+44]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Plist$[esp+44], ecx
	test	ebx, ebx
	je	SHORT $LN106@Insert@8
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN107@Insert@8
$LN106@Insert@8:
	xor	eax, eax
$LN107@Insert@8:
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN94@Insert@8
	call	__invalid_parameter_noinfo
$LN94@Insert@8:
	test	ebx, ebx
	jne	$LN430@Insert@8
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN123@Insert@8:
	mov	ecx, DWORD PTR __Plist$[esp+44]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN112@Insert@8
	call	__invalid_parameter_noinfo
$LN112@Insert@8:
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Plist$[esp+44]
	cmp	eax, DWORD PTR [ecx+8]
	jne	$LN18@Insert@8

; 842  : 				;	// still too high in bucket list
; 843  : 			else if (_Multi
; 844  : 				|| this->comp(this->_Kfn(*_Plist), this->_Kfn(_Val)))

	test	ebx, ebx
	jne	$LN429@Insert@8
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN151@Insert@8:
	mov	edx, DWORD PTR __Plist$[esp+44]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN140@Insert@8
	call	__invalid_parameter_noinfo
$LN140@Insert@8:
	mov	eax, DWORD PTR __Plist$[esp+44]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Val$[ebp]
	cmp	ecx, DWORD PTR [edx]
	je	SHORT $LN14@Insert@8

; 845  : 				{	// found insertion point, back up to it
; 846  : 				++_Plist;

	test	ebx, ebx
	jne	SHORT $LN428@Insert@8
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN175@Insert@8:
	mov	ecx, DWORD PTR __Plist$[esp+44]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN164@Insert@8
	call	__invalid_parameter_noinfo
$LN164@Insert@8:
	mov	edx, DWORD PTR __Plist$[esp+44]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Plist$[esp+44], eax
$LN17@Insert@8:

; 854  : 				}
; 855  : 
; 856  : 		if (_Where != end())

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR $T573468[esp+44], eax
	mov	eax, DWORD PTR __Where$[ebp]
	test	eax, eax
	je	SHORT $LN231@Insert@8
	cmp	eax, ecx
	je	SHORT $LN232@Insert@8
$LN231@Insert@8:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[ebp]
$LN232@Insert@8:
	mov	ecx, DWORD PTR __Where$[ebp+4]
	cmp	ecx, DWORD PTR $T573468[esp+44]
	je	SHORT $LN10@Insert@8

; 857  : 			_List.splice(_Plist, _List, _Where);	// move element into place

	push	ecx
	mov	ecx, DWORD PTR __Plist$[esp+48]
	push	eax
	push	ecx
	push	ebx
	push	edi
	mov	eax, edi
	call	?splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@0@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::splice

; 858  : 		else

	jmp	SHORT $LL433@Insert@8
$LN430@Insert@8:

; 841  : 			if (this->comp(this->_Kfn(_Val), this->_Kfn(*--_Plist)))

	mov	eax, DWORD PTR [ebx]
	jmp	$LN123@Insert@8
$LN429@Insert@8:

; 842  : 				;	// still too high in bucket list
; 843  : 			else if (_Multi
; 844  : 				|| this->comp(this->_Kfn(*_Plist), this->_Kfn(_Val)))

	mov	eax, DWORD PTR [ebx]
	jmp	$LN151@Insert@8
$LN428@Insert@8:

; 845  : 				{	// found insertion point, back up to it
; 846  : 				++_Plist;

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN175@Insert@8
$LN14@Insert@8:

; 847  : 				break;
; 848  : 				}
; 849  : 			else
; 850  : 				{	// discard new list element and return existing
; 851  : 				if (_Where != end())

	mov	eax, DWORD PTR __Where$[ebp]
	mov	esi, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN200@Insert@8
	cmp	eax, ecx
	je	SHORT $LN201@Insert@8
$LN200@Insert@8:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[ebp]
$LN201@Insert@8:
	mov	ecx, DWORD PTR __Where$[ebp+4]
	cmp	ecx, esi
	je	SHORT $LN11@Insert@8

; 852  : 					_List.erase(_Where);

	push	ecx
	push	eax
	lea	ecx, DWORD PTR $T573466[esp+48]
	push	ecx
	call	?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase
$LN11@Insert@8:

; 853  : 				return (_Pairib(_Plist, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Plist$[esp+44]
	mov	DWORD PTR [eax], ebx
	mov	BYTE PTR [eax+8], 0

; 880  : 			}
; 881  : #endif /* _HAS_INCREMENTAL_HASH */
; 882  : 
; 883  : 		return (_Pairib(_Where, true));	// return iterator for new element

	mov	DWORD PTR [eax+4], edx

; 884  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN10@Insert@8:

; 859  : 			_Where = _List.insert(_Plist, _Val);	// insert new element

	mov	edx, DWORD PTR __Plist$[esp+44]
	push	edx
	mov	edx, DWORD PTR __Val$[ebp]
	push	ebx
	lea	eax, DWORD PTR $T573472[esp+48]
	push	eax
	push	edi
	call	?insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::insert
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Where$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Where$[ebp+4], edx
	npad	6
$LL433@Insert@8:

; 860  : 		for (; _Plist == _Get_iter_from_vec(_Vec[_Bucket]); --_Bucket)

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 3
	cmp	DWORD PTR __Bucket$[esp+40], eax
	jb	SHORT $LN240@Insert@8
	call	__invalid_parameter_noinfo
$LN240@Insert@8:
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR __Bucket$[esp+40]
	mov	eax, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR $T573473[esp+44], eax
	test	edi, edi
	jne	SHORT $LN253@Insert@8
	call	__invalid_parameter_noinfo
$LN253@Insert@8:
	mov	eax, DWORD PTR [edi]
	test	ebx, ebx
	je	SHORT $LN265@Insert@8
	cmp	ebx, eax
	je	SHORT $LN266@Insert@8
$LN265@Insert@8:
	call	__invalid_parameter_noinfo
$LN266@Insert@8:
	mov	ecx, DWORD PTR $T573473[esp+44]
	cmp	DWORD PTR __Plist$[esp+44], ecx
	jne	SHORT $LN424@Insert@8

; 861  : 			{	// update end iterators if new first bucket element
; 862  : 			_Vec[_Bucket] = _Where;

	mov	eax, DWORD PTR __Where$[ebp]
	test	eax, eax
	je	SHORT $LN278@Insert@8
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN279@Insert@8
$LN278@Insert@8:
	xor	eax, eax
$LN279@Insert@8:
	mov	edx, DWORD PTR [esi+16]
	sub	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR __Bucket$[esp+40]
	mov	edi, DWORD PTR __Where$[ebp+4]
	mov	ebx, DWORD PTR [eax]
	sar	edx, 3
	cmp	ecx, edx
	jb	SHORT $LN298@Insert@8
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR __Bucket$[esp+40]
$LN298@Insert@8:
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+ecx*8], ebx
	mov	DWORD PTR [eax+ecx*8+4], edi
	mov	edi, DWORD PTR tv1277[esp+40]

; 863  : 			if (_Bucket == 0)

	test	ecx, ecx
	je	SHORT $LN424@Insert@8
	mov	ebx, DWORD PTR __Plist$[esp+40]
	dec	ecx
	mov	DWORD PTR __Bucket$[esp+40], ecx
	jmp	$LL433@Insert@8
$LN424@Insert@8:

; 864  : 				break;
; 865  : 			}
; 866  : 
; 867  : 		if (max_load_factor() < load_factor())

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+68]
	mov	ebx, DWORD PTR [eax+64]
	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR tv1572[esp+40], eax
	fild	DWORD PTR tv1572[esp+40]
	test	eax, eax
	jge	SHORT $LN438@Insert@8
	fadd	DWORD PTR __real@4f800000
$LN438@Insert@8:
	mov	ecx, ebx
	mov	DWORD PTR tv1569[esp+40], ecx
	fild	DWORD PTR tv1569[esp+40]
	test	ecx, ecx
	jge	SHORT $LN439@Insert@8
	fadd	DWORD PTR __real@4f800000
$LN439@Insert@8:
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR tv1566[esp+40]
	fld	DWORD PTR tv1566[esp+40]
	fcomip	ST(1)
	fstp	ST(0)
	jbe	$LN4@Insert@8

; 868  :  #if _HAS_INCREMENTAL_HASH
; 869  : 			_Grow();	// too dense, need to grow hash table
; 870  : 
; 871  :  #else /* _HAS_INCREMENTAL_HASH */
; 872  : 			{	// rehash to bigger table
; 873  : 			size_type _Maxsize = _Vec.max_size() / 2;
; 874  : 			size_type _Newsize = bucket_count();
; 875  : 
; 876  : 			for (int _Idx = 0; _Idx < 3 && _Newsize < _Maxsize; ++_Idx)

	xor	eax, eax
	npad	7
$LL3@Insert@8:
	cmp	ebx, 268435455				; 0fffffffH
	jae	SHORT $LN1@Insert@8
	inc	eax

; 877  : 				_Newsize *= 2;	// multiply safely by 8

	add	ebx, ebx
	cmp	eax, 3
	jl	SHORT $LL3@Insert@8
$LN1@Insert@8:

; 878  : 			_Init(_Newsize);

	mov	ecx, DWORD PTR [edi+20]
	mov	edi, DWORD PTR [edi]
	test	edi, edi
	je	SHORT $LN345@Insert@8
	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LN346@Insert@8
$LN345@Insert@8:
	xor	edi, edi
$LN346@Insert@8:
	mov	eax, DWORD PTR [edi]
	mov	edi, DWORD PTR [esi+16]
	mov	DWORD PTR __Tmp$575029[esp+40], eax
	mov	DWORD PTR __Tmp$575029[esp+44], ecx
	cmp	DWORD PTR [esi+12], edi
	jbe	SHORT $LN374@Insert@8
	call	__invalid_parameter_noinfo
$LN374@Insert@8:
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR $T575032[esp+40], edx
	mov	DWORD PTR $T574774[esp+40], ecx
	cmp	ecx, DWORD PTR [esi+16]
	jbe	SHORT $LN390@Insert@8
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR $T574774[esp+40]
$LN390@Insert@8:
	mov	edx, DWORD PTR $T575032[esp+40]
	mov	eax, DWORD PTR [esi]
	push	edi
	push	edx
	push	ecx
	push	eax
	lea	eax, DWORD PTR $T575035[esp+56]
	push	eax
	mov	edi, esi
	call	?erase@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@0@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::erase
	mov	edi, DWORD PTR [esi+12]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN406@Insert@8
	call	__invalid_parameter_noinfo
$LN406@Insert@8:
	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	lea	ecx, DWORD PTR __Tmp$575029[esp+48]
	push	ecx
	lea	ecx, DWORD PTR [ebx+1]
	mov	edx, esi
	call	?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Insert_n
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ebx-1]
	mov	DWORD PTR [ecx+60], edx
	mov	DWORD PTR [ecx+64], ebx

; 879  : 			_Reinsert();

	call	?_Reinsert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Reinsert
$LN4@Insert@8:

; 880  : 			}
; 881  : #endif /* _HAS_INCREMENTAL_HASH */
; 882  : 
; 883  : 		return (_Pairib(_Where, true));	// return iterator for new element

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]

; 884  : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+8], 1
	mov	DWORD PTR [eax+4], edx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?_Insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@4@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::insert, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 545  : 		return (_Insert(_Val, end()));

	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR __Val$[esp]
	push	edx
	push	ecx
	push	esi
	push	eax
	call	?_Insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@4@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Insert
	mov	eax, esi

; 546  : 		}

	ret	4
?insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z
_TEXT	SEGMENT
$T575203 = -20						; size = 8
__Where$ = -20						; size = 8
$T575205 = -12						; size = 12
$T575202 = -12						; size = 8
__Keyval$ = 8						; size = 4
??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z PROC ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[], COMDAT
; _this$ = esi

; 209  : 		{	// find element matching _Keyval or insert with default mapped

	sub	esp, 20					; 00000014H
	push	ebx
	mov	ebx, DWORD PTR __Keyval$[esp+20]
	push	ebp
	push	edi

; 210  : 		iterator _Where = this->lower_bound(_Keyval);

	push	ebx
	lea	eax, DWORD PTR __Where$[esp+36]
	push	eax
	push	esi
	call	?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound

; 211  : 		if (_Where == this->end())

	mov	edi, DWORD PTR __Where$[esp+32]
	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR $T575202[esp+36], ecx
	test	edi, edi
	je	SHORT $LN22@operator@318
	cmp	edi, eax
	je	SHORT $LN23@operator@318
$LN22@operator@318:
	call	__invalid_parameter_noinfo
$LN23@operator@318:
	mov	ebp, DWORD PTR __Where$[esp+36]
	cmp	ebp, DWORD PTR $T575202[esp+36]
	jne	SHORT $LN1@operator@318

; 212  : 			_Where = _Mybase::insert(value_type(_Keyval, mapped_type())).first;

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [ebx]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T575203[esp+40]
	push	eax
	lea	ecx, DWORD PTR $T575205[esp+44]
	push	ecx
	push	esi
	mov	DWORD PTR $T575203[esp+52], edx
	mov	DWORD PTR $T575203[esp+56], 0
	call	?_Insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@4@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Insert
	mov	edi, DWORD PTR $T575205[esp+32]
	mov	ebp, DWORD PTR $T575205[esp+36]
$LN1@operator@318:

; 213  : 		return ((*_Where).second);

	test	edi, edi
	jne	SHORT $LN71@operator@318
	call	__invalid_parameter_noinfo
$LN66@operator@318:
	cmp	ebp, DWORD PTR [edi+20]
	jne	SHORT $LN72@operator@318
	call	__invalid_parameter_noinfo
$LN72@operator@318:

; 214  : 		}

	pop	edi
	lea	eax, DWORD PTR [ebp+12]
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
$LN71@operator@318:

; 213  : 		return ((*_Where).second);

	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LN66@operator@318
??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z ENDP ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[]
_TEXT	ENDS
PUBLIC	?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::Statistics::collectCommandStats
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.cpp
_TEXT	SEGMENT
$T575479 = 8						; size = 4
$T575478 = 8						; size = 4
$T575477 = 8						; size = 4
_this$ = 8						; size = 4
?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z PROC ; DRAMsimII::Statistics::collectCommandStats
; _currentCommand$ = edi

; 167  : 	//#pragma omp critical
; 168  : 	{
; 169  : 		if (!currentCommand->isRefresh())

	cmp	DWORD PTR [edi+80], 12			; 0000000cH
	push	ebx
	mov	ebx, DWORD PTR _this$[esp]
	push	esi
	je	SHORT $LN1@collectCom

; 170  : 		{
; 171  : 			commandDelay[currentCommand->getDelayTime()]++;

	mov	eax, DWORD PTR [edi+24]
	sub	eax, DWORD PTR [edi+16]
	lea	ecx, DWORD PTR $T575477[esp+4]
	push	ecx
	lea	esi, DWORD PTR [ebx+68]
	mov	DWORD PTR $T575477[esp+8], eax
	call	??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[]
	inc	DWORD PTR [eax]

; 172  : 			commandExecution[currentCommand->getExecuteTime()]++;

	mov	edx, DWORD PTR [edi+32]
	sub	edx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR $T575478[esp+4]
	push	eax
	lea	esi, DWORD PTR [ebx+140]
	mov	DWORD PTR $T575478[esp+8], edx
	call	??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[]
	inc	DWORD PTR [eax]

; 173  : 			commandTurnaround[currentCommand->getLatency()]++;		

	mov	ecx, DWORD PTR [edi+32]
	sub	ecx, DWORD PTR [edi+16]
	lea	edx, DWORD PTR $T575479[esp+4]
	push	edx
	lea	esi, DWORD PTR [ebx+212]
	mov	DWORD PTR $T575479[esp+8], ecx
	call	??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[]
	inc	DWORD PTR [eax]
$LN1@collectCom:

; 174  : 		}
; 175  : 	}
; 176  : }

	pop	esi
	pop	ebx
	ret	4
?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z ENDP ; DRAMsimII::Statistics::collectCommandStats
_TEXT	ENDS
PUBLIC	?collectTransactionStats@Statistics@DRAMsimII@@QAEXPBVTransaction@2@@Z ; DRAMsimII::Statistics::collectTransactionStats
EXTRN	__aullshr:PROC
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T575497 = -16						; size = 8
$T575496 = -16						; size = 8
$T575495 = -16						; size = 8
$T575603 = -8						; size = 8
_this$ = 8						; size = 4
$T575494 = 12						; size = 4
$T575493 = 12						; size = 4
_currentTransaction$ = 12				; size = 4
?collectTransactionStats@Statistics@DRAMsimII@@QAEXPBVTransaction@2@@Z PROC ; DRAMsimII::Statistics::collectTransactionStats

; 112  : {

	sub	esp, 20					; 00000014H
	push	ebx
	mov	ebx, DWORD PTR _currentTransaction$[esp+20]

; 113  : 	//#pragma omp critical
; 114  : 	{
; 115  : 		if (currentTransaction->isRead() || currentTransaction->isWrite())

	mov	eax, DWORD PTR [ebx+80]
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+24]
	push	esi
	push	edi
	test	eax, eax
	je	SHORT $LN73@collectTra
	cmp	eax, 2
	je	SHORT $LN73@collectTra
	cmp	eax, 3
	je	SHORT $LN73@collectTra
	mov	edi, 1
	cmp	eax, edi
	jne	$LN68@collectTra
	jmp	SHORT $LN6@collectTra
$LN73@collectTra:
	mov	edi, 1
$LN6@collectTra:

; 116  : 		{
; 117  : 			if (currentTransaction->getLength() == 8)

	cmp	DWORD PTR [ebx+84], 8
	jne	SHORT $LN5@collectTra

; 118  : 			{
; 119  : 				++burstOf8Count;

	add	DWORD PTR [ebp+24], edi

; 120  : 			}
; 121  : 			else

	jmp	SHORT $LN4@collectTra
$LN5@collectTra:

; 122  : 			{
; 123  : 				++burstOf4Count;

	add	DWORD PTR [ebp+28], edi
$LN4@collectTra:

; 124  : 			}
; 125  : 			if (currentTransaction->isRead())

	mov	eax, DWORD PTR [ebx+80]
	test	eax, eax
	je	SHORT $LN20@collectTra
	cmp	eax, 2
	je	SHORT $LN20@collectTra
	cmp	eax, 3
	jne	$LN3@collectTra
$LN20@collectTra:

; 126  : 			{
; 127  : 				//if (currentTransaction->getLatency() > 1024)
; 128  : 				//	std::cerr << currentTransaction->getLatency() << std::endl;
; 129  : 				transactionExecution[currentTransaction->getLatency()]++;

	mov	eax, DWORD PTR [ebx+32]
	sub	eax, DWORD PTR [ebx+16]
	lea	ecx, DWORD PTR $T575493[esp+32]
	push	ecx
	lea	esi, DWORD PTR [ebp+356]
	mov	DWORD PTR $T575493[esp+36], eax
	call	??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[]
	add	DWORD PTR [eax], edi

; 130  : 				assert(currentTransaction->getLatency() > 4);
; 131  : 				unsigned index = currentTransaction->getAddress().getChannel() * (ranks * banks) +
; 132  : 					currentTransaction->getAddress().getRank() * banks +
; 133  : 					currentTransaction->getAddress().getBank();

	mov	esi, DWORD PTR [ebx+56]
	imul	esi, DWORD PTR [ebp+4]
	add	esi, DWORD PTR [ebx+60]

; 134  : 				bankLatencyUtilization[index] += currentTransaction->getLatency();

	mov	edx, DWORD PTR [ebp+532]
	imul	esi, DWORD PTR [ebp+8]
	sub	edx, DWORD PTR [ebp+528]
	add	esi, DWORD PTR [ebx+64]
	sar	edx, 3
	cmp	esi, edx
	jb	SHORT $LN36@collectTra
	call	__invalid_parameter_noinfo
$LN36@collectTra:
	mov	ecx, DWORD PTR [ebx+32]
	sub	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [ebp+528]
	mov	edx, DWORD PTR [ebx+36]
	sbb	edx, DWORD PTR [ebx+20]
	add	DWORD PTR [eax+esi*8], ecx
	lea	eax, DWORD PTR [eax+esi*8]
	adc	DWORD PTR [eax+4], edx

; 135  : 				aggregateBankUtilization[index]++;

	mov	eax, DWORD PTR [ebp+508]
	sub	eax, DWORD PTR [ebp+504]
	sar	eax, 2
	cmp	esi, eax
	jb	SHORT $LN43@collectTra
	call	__invalid_parameter_noinfo
$LN43@collectTra:
	mov	ecx, DWORD PTR [ebp+504]
	add	DWORD PTR [ecx+esi*4], edi

; 136  : 				readCount++;

	add	DWORD PTR [ebp+36], edi

; 137  : 				readBytesTransferred += currentTransaction->getLength() * 8;

	mov	edx, DWORD PTR [ebx+84]
	lea	eax, DWORD PTR [ecx+esi*4]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [ebp+44], edx

; 138  : 			}
; 139  : 			else

	jmp	SHORT $LN2@collectTra
$LN3@collectTra:

; 140  : 			{
; 141  : 				// 64bit bus for most DDRx architectures
; 142  : 				/// @todo use #DQ * length to calculate bytes Tx, Rx
; 143  : 				writeBytesTransferred += currentTransaction->getLength() * 8;

	mov	eax, DWORD PTR [ebx+84]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	add	DWORD PTR [ebp+48], eax

; 144  : 				writeCount++;

	add	DWORD PTR [ebp+40], edi
$LN2@collectTra:

; 145  : 			}
; 146  : 
; 147  : 			transactionDecodeDelay[currentTransaction->getDecodeDelay()]++;

	mov	ecx, DWORD PTR [ebx+88]
	sub	ecx, DWORD PTR [ebx+16]
	lea	edx, DWORD PTR $T575494[esp+32]
	push	edx
	lea	esi, DWORD PTR [ebp+284]
	mov	DWORD PTR $T575494[esp+36], ecx
	call	??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[]
	add	DWORD PTR [eax], edi

; 148  : 
; 149  : 			// gather working set information for this epoch, exclude the entries which alias to the same column		
; 150  : 			workingSet[currentTransaction->getAddress().getPhysicalAddress() >> columnDepth]++;

	mov	eax, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ebx+52]
	mov	ecx, DWORD PTR [ebp+32]
	call	__aullshr
	mov	DWORD PTR $T575495[esp+36], eax
	lea	eax, DWORD PTR [ebp+460]
	push	eax
	lea	edi, DWORD PTR $T575495[esp+40]
	mov	DWORD PTR $T575495[esp+44], edx
	call	??A?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAEAAIAB_K@Z ; std::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::operator[]
	inc	DWORD PTR [eax]

; 151  : 
; 152  : 			// ignore write / tlb transactions that don't have a specific PC
; 153  : 			if (currentTransaction->getProgramCounter() > 0x00)

	mov	eax, DWORD PTR [ebx+100]
	mov	ecx, DWORD PTR [ebx+96]
	test	eax, eax
	ja	SHORT $LN72@collectTra
	test	ecx, ecx
	jbe	SHORT $LN68@collectTra
$LN72@collectTra:

; 154  : 			{
; 155  : 				pcOccurrence[currentTransaction->getProgramCounter()].countUp();

	add	ebp, 428				; 000001acH
	push	ebp
	lea	edi, DWORD PTR $T575496[esp+40]
	mov	DWORD PTR $T575496[esp+40], ecx
	mov	DWORD PTR $T575496[esp+44], eax
	call	??A?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAEAAVDelayCounter@Statistics@DRAMsimII@@AB_K@Z ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::operator[]
	inc	DWORD PTR [eax+8]

; 156  : 				pcOccurrence[currentTransaction->getProgramCounter()].delay(currentTransaction->getLatency());

	mov	esi, DWORD PTR [ebx+32]
	sub	esi, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [ebx+36]
	sbb	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [ebx+96]
	mov	edx, DWORD PTR [ebx+100]
	push	ebp
	lea	edi, DWORD PTR $T575497[esp+40]
	mov	DWORD PTR $T575497[esp+40], ecx
	mov	DWORD PTR $T575497[esp+44], edx
	mov	DWORD PTR $T575603[esp+44], eax
	call	??A?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAEAAVDelayCounter@Statistics@DRAMsimII@@AB_K@Z ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::operator[]
	add	DWORD PTR [eax], esi
	adc	DWORD PTR [eax+4], 0
$LN68@collectTra:

; 157  : 			}
; 158  : 		}
; 159  : 	}
; 160  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	8
?collectTransactionStats@Statistics@DRAMsimII@@QAEXPBVTransaction@2@@Z ENDP ; DRAMsimII::Statistics::collectTransactionStats
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?_Reinsert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXXZ
_TEXT	SEGMENT
$T586921 = -20						; size = 8
$T586922 = -12						; size = 12
?_Reinsert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXXZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Reinsert, COMDAT
; _this$ = ecx

; 887  : 		{	// insert elements at beginning of list into table

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx
	push	edi
	lea	edi, DWORD PTR [ebx+8]
	npad	4
$LL2@Reinsert@2:

; 888  : 		iterator _First;
; 889  : 		for (; (_First = _List.begin()) != _Get_iter_from_vec(_Vec[0]); )

	mov	ecx, DWORD PTR [ebx+52]
	sub	ecx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [edi+20]
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [edi]
	sar	ecx, 3
	test	ecx, ecx
	ja	SHORT $LN33@Reinsert@2
	call	__invalid_parameter_noinfo
$LN33@Reinsert@2:
	mov	edx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T586921[esp+40], eax
	test	edi, edi
	jne	SHORT $LN46@Reinsert@2
	call	__invalid_parameter_noinfo
$LN46@Reinsert@2:
	mov	eax, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN60@Reinsert@2
	cmp	esi, eax
	je	SHORT $LN61@Reinsert@2
$LN60@Reinsert@2:
	call	__invalid_parameter_noinfo
$LN61@Reinsert@2:
	cmp	ebp, DWORD PTR $T586921[esp+40]
	je	SHORT $LN1@Reinsert@2

; 890  : 			_Insert(*_First, _First);

	test	esi, esi
	jne	SHORT $LN88@Reinsert@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN82@Reinsert@2:
	cmp	ebp, DWORD PTR [eax+20]
	jne	SHORT $LN71@Reinsert@2
	call	__invalid_parameter_noinfo
$LN71@Reinsert@2:
	push	ebp
	push	esi
	add	ebp, 8
	push	ebp
	lea	ecx, DWORD PTR $T586922[esp+48]
	push	ecx
	push	ebx
	call	?_Insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@4@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Insert
	jmp	SHORT $LL2@Reinsert@2
$LN88@Reinsert@2:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN82@Reinsert@2
$LN1@Reinsert@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 891  : 		}

	add	esp, 20					; 00000014H
	ret	0
?_Reinsert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXXZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Reinsert
_TEXT	ENDS
PUBLIC	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVStatistics@0@@Z ; DRAMsimII::operator<<
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.cpp
_TEXT	SEGMENT
_i$124188 = -36						; size = 4
_k$124172 = -36						; size = 4
_currentValue$124113 = -36				; size = 8
tv5327 = -28						; size = 4
$T590988 = -28						; size = 4
$T590687 = -28						; size = 4
_j$124192 = -28						; size = 4
_j$124168 = -28						; size = 4
tv5325 = -24						; size = 4
tv5323 = -24						; size = 4
tv5321 = -24						; size = 4
tv5288 = -24						; size = 4
tv5286 = -24						; size = 4
tv4480 = -24						; size = 4
$T590984 = -24						; size = 4
__State$590977 = -24					; size = 4
$T590765 = -24						; size = 4
$T589782 = -24						; size = 4
_k$124196 = -24						; size = 4
_i$124164 = -24						; size = 4
_currentValue$123960 = -24				; size = 8
_currentValue$123925 = -24				; size = 8
_currentValue$123890 = -24				; size = 8
_currentValue$123855 = -24				; size = 8
_currentValue$123795 = -24				; size = 8
$T590726 = -16						; size = 8
$T587231 = -8						; size = 8
$T587229 = -8						; size = 8
_os$ = 8						; size = 4
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVStatistics@0@@Z PROC ; DRAMsimII::operator<<
; _statsLog$ = eax

; 183  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi

; 184  : 	using std::vector;
; 185  : #if 0
; 186  : 	os << "RR[" << setw(6) << setprecision(6) << (double)statsLog.end_time/max(1,statsLog.bo4_count + statsLog.bo8_count) << "] ";
; 187  : 	os << "BWE[" << setw(6) << setprecision(6) << ((double)statsLog.bo8_count * 8.0 + statsLog.bo4_count * 4.0) * 100.0 / max(statsLog.end_time,(tick)1) << "]" << endl;
; 188  : 
; 189  : 	os << "----R W Total----" << endl;
; 190  : 	os << statsLog.readCount << " " << statsLog.writeCount << " " << statsLog.readCount + statsLog.writeCount << endl;
; 191  : #endif
; 192  : 	os << "----Transaction Delay " << statsLog.transactionDecodeDelay.size() << "----" << endl;

	push	OFFSET ??_C@_04ECGLBLOI@?9?9?9?9?$AA@
	mov	edi, eax
	mov	eax, DWORD PTR [edi+316]
	push	ecx
	push	eax
	mov	eax, DWORD PTR _os$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BH@GGHGAMGD@?9?9?9?9Transaction?5Delay?5?$AA@
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 193  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.transactionDecodeDelay.begin(); currentValue != statsLog.transactionDecodeDelay.end(); currentValue++)

	mov	ecx, DWORD PTR [edi+312]
	mov	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [edi+292]
	mov	DWORD PTR _currentValue$123795[esp+52], edx
	mov	DWORD PTR _currentValue$123795[esp+48], esi
	npad	9
$LL71@operator@339:
	mov	ebx, DWORD PTR [edi+312]
	mov	eax, DWORD PTR [edi+292]
	test	esi, esi
	je	SHORT $LN101@operator@339
	cmp	esi, eax
	je	SHORT $LN102@operator@339
$LN101@operator@339:
	call	__invalid_parameter_noinfo
$LN102@operator@339:
	cmp	DWORD PTR _currentValue$123795[esp+52], ebx
	je	$LN34@operator@339

; 194  : 	{
; 195  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	test	esi, esi
	jne	$LN1317@operator@339
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN121@operator@339:
	mov	ecx, DWORD PTR _currentValue$123795[esp+52]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN110@operator@339
	call	__invalid_parameter_noinfo
$LN110@operator@339:
	test	esi, esi
	jne	$LN1316@operator@339
	call	__invalid_parameter_noinfo
$LN137@operator@339:
	mov	edx, DWORD PTR _currentValue$123795[esp+52]
	cmp	edx, DWORD PTR [esi+20]
	jne	SHORT $LN126@operator@339
	call	__invalid_parameter_noinfo
$LN126@operator@339:
	mov	eax, DWORD PTR _currentValue$123795[esp+52]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _os$[ebp]
	push	ecx
	push	ecx
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	push	edx
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN146@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN146@operator@339
	mov	ebx, 4
$LN146@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN35@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN164@operator@339
	or	eax, 4
$LN164@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN35@operator@339:
	mov	eax, DWORD PTR _currentValue$123795[esp+48]
	test	eax, eax
	jne	SHORT $LN1315@operator@339
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN78@operator@339:
	mov	edx, DWORD PTR _currentValue$123795[esp+52]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN67@operator@339

; 193  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.transactionDecodeDelay.begin(); currentValue != statsLog.transactionDecodeDelay.end(); currentValue++)

	call	__invalid_parameter_noinfo
$LN67@operator@339:
	mov	eax, DWORD PTR _currentValue$123795[esp+52]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR _currentValue$123795[esp+48]
	mov	DWORD PTR _currentValue$123795[esp+52], ecx
	jmp	$LL71@operator@339
$LN1317@operator@339:

; 194  : 	{
; 195  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	mov	eax, DWORD PTR [esi]
	jmp	$LN121@operator@339
$LN1316@operator@339:
	mov	esi, DWORD PTR [esi]
	jmp	$LN137@operator@339
$LN1315@operator@339:

; 193  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.transactionDecodeDelay.begin(); currentValue != statsLog.transactionDecodeDelay.end(); currentValue++)

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN78@operator@339
$LN34@operator@339:

; 196  : 	}
; 197  : 	os << "----Command Turnaround " << statsLog.commandTurnaround.size() << "----" << endl;

	mov	eax, DWORD PTR [edi+244]
	mov	edx, DWORD PTR _os$[ebp]
	push	OFFSET ??_C@_04ECGLBLOI@?9?9?9?9?$AA@
	push	ecx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BI@OFHLBMPE@?9?9?9?9Command?5Turnaround?5?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN174@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN174@operator@339
	mov	ebx, 4
$LN174@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN190@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN192@operator@339
	or	eax, 4
$LN192@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN190@operator@339:

; 198  : 	for (unordered_map<unsigned,unsigned>::const_iterator currentValue = statsLog.commandTurnaround.begin(); currentValue != statsLog.commandTurnaround.end(); currentValue++)

	mov	edx, DWORD PTR [edi+240]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR [edi+220]
	mov	DWORD PTR _currentValue$123855[esp+52], eax
	mov	DWORD PTR _currentValue$123855[esp+48], esi
	npad	10
$LL218@operator@339:
	mov	ebx, DWORD PTR [edi+240]
	mov	eax, DWORD PTR [edi+220]
	test	esi, esi
	je	SHORT $LN248@operator@339
	cmp	esi, eax
	je	SHORT $LN249@operator@339
$LN248@operator@339:
	call	__invalid_parameter_noinfo
$LN249@operator@339:
	cmp	DWORD PTR _currentValue$123855[esp+52], ebx
	je	$LN31@operator@339

; 199  : 	{
; 200  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	test	esi, esi
	jne	$LN1314@operator@339
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN268@operator@339:
	mov	ecx, DWORD PTR _currentValue$123855[esp+52]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN257@operator@339
	call	__invalid_parameter_noinfo
$LN257@operator@339:
	test	esi, esi
	jne	$LN1313@operator@339
	call	__invalid_parameter_noinfo
$LN284@operator@339:
	mov	edx, DWORD PTR _currentValue$123855[esp+52]
	cmp	edx, DWORD PTR [esi+20]
	jne	SHORT $LN273@operator@339
	call	__invalid_parameter_noinfo
$LN273@operator@339:
	mov	eax, DWORD PTR _currentValue$123855[esp+52]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _os$[ebp]
	push	ecx
	push	ecx
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	push	edx
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN293@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN293@operator@339
	mov	ebx, 4
$LN293@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN32@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN311@operator@339
	or	eax, 4
$LN311@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN32@operator@339:
	mov	eax, DWORD PTR _currentValue$123855[esp+48]
	test	eax, eax
	jne	SHORT $LN1312@operator@339
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN225@operator@339:
	mov	edx, DWORD PTR _currentValue$123855[esp+52]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN214@operator@339

; 198  : 	for (unordered_map<unsigned,unsigned>::const_iterator currentValue = statsLog.commandTurnaround.begin(); currentValue != statsLog.commandTurnaround.end(); currentValue++)

	call	__invalid_parameter_noinfo
$LN214@operator@339:
	mov	eax, DWORD PTR _currentValue$123855[esp+52]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR _currentValue$123855[esp+48]
	mov	DWORD PTR _currentValue$123855[esp+52], ecx
	jmp	$LL218@operator@339
$LN1314@operator@339:

; 199  : 	{
; 200  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	mov	eax, DWORD PTR [esi]
	jmp	$LN268@operator@339
$LN1313@operator@339:
	mov	esi, DWORD PTR [esi]
	jmp	$LN284@operator@339
$LN1312@operator@339:

; 198  : 	for (unordered_map<unsigned,unsigned>::const_iterator currentValue = statsLog.commandTurnaround.begin(); currentValue != statsLog.commandTurnaround.end(); currentValue++)

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN225@operator@339
$LN31@operator@339:

; 201  : 	}
; 202  : 	os << "----Command Delay " << statsLog.commandDelay.size() << "----" << endl;

	mov	eax, DWORD PTR [edi+100]
	mov	edx, DWORD PTR _os$[ebp]
	push	OFFSET ??_C@_04ECGLBLOI@?9?9?9?9?$AA@
	push	ecx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BD@BJDMIPKA@?9?9?9?9Command?5Delay?5?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN321@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN321@operator@339
	mov	ebx, 4
$LN321@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN337@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN339@operator@339
	or	eax, 4
$LN339@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN337@operator@339:

; 203  : 	for (unordered_map<unsigned,unsigned>::const_iterator currentValue = statsLog.commandDelay.begin(); currentValue != statsLog.commandDelay.end(); currentValue++)

	mov	edx, DWORD PTR [edi+96]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR [edi+76]
	mov	DWORD PTR _currentValue$123890[esp+52], eax
	mov	DWORD PTR _currentValue$123890[esp+48], esi
	npad	3
$LL365@operator@339:
	mov	ebx, DWORD PTR [edi+96]
	mov	eax, DWORD PTR [edi+76]
	test	esi, esi
	je	SHORT $LN395@operator@339
	cmp	esi, eax
	je	SHORT $LN396@operator@339
$LN395@operator@339:
	call	__invalid_parameter_noinfo
$LN396@operator@339:
	cmp	DWORD PTR _currentValue$123890[esp+52], ebx
	je	$LN28@operator@339

; 204  : 	{
; 205  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	test	esi, esi
	jne	$LN1311@operator@339
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN415@operator@339:
	mov	ecx, DWORD PTR _currentValue$123890[esp+52]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN404@operator@339
	call	__invalid_parameter_noinfo
$LN404@operator@339:
	test	esi, esi
	jne	$LN1310@operator@339
	call	__invalid_parameter_noinfo
$LN431@operator@339:
	mov	edx, DWORD PTR _currentValue$123890[esp+52]
	cmp	edx, DWORD PTR [esi+20]
	jne	SHORT $LN420@operator@339
	call	__invalid_parameter_noinfo
$LN420@operator@339:
	mov	eax, DWORD PTR _currentValue$123890[esp+52]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _os$[ebp]
	push	ecx
	push	ecx
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	push	edx
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN440@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN440@operator@339
	mov	ebx, 4
$LN440@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN29@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN458@operator@339
	or	eax, 4
$LN458@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN29@operator@339:
	mov	eax, DWORD PTR _currentValue$123890[esp+48]
	test	eax, eax
	jne	SHORT $LN1309@operator@339
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN372@operator@339:
	mov	edx, DWORD PTR _currentValue$123890[esp+52]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN361@operator@339

; 203  : 	for (unordered_map<unsigned,unsigned>::const_iterator currentValue = statsLog.commandDelay.begin(); currentValue != statsLog.commandDelay.end(); currentValue++)

	call	__invalid_parameter_noinfo
$LN361@operator@339:
	mov	eax, DWORD PTR _currentValue$123890[esp+52]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR _currentValue$123890[esp+48]
	mov	DWORD PTR _currentValue$123890[esp+52], ecx
	jmp	$LL365@operator@339
$LN1311@operator@339:

; 204  : 	{
; 205  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	mov	eax, DWORD PTR [esi]
	jmp	$LN415@operator@339
$LN1310@operator@339:
	mov	esi, DWORD PTR [esi]
	jmp	$LN431@operator@339
$LN1309@operator@339:

; 203  : 	for (unordered_map<unsigned,unsigned>::const_iterator currentValue = statsLog.commandDelay.begin(); currentValue != statsLog.commandDelay.end(); currentValue++)

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN372@operator@339
$LN28@operator@339:

; 206  : 	}
; 207  : 	os << "----CMD Execution Time " << statsLog.commandExecution.size() << "----" << endl;

	mov	eax, DWORD PTR [edi+172]
	mov	edx, DWORD PTR _os$[ebp]
	push	OFFSET ??_C@_04ECGLBLOI@?9?9?9?9?$AA@
	push	ecx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BI@FKLHOOHD@?9?9?9?9CMD?5Execution?5Time?5?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN468@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN468@operator@339
	mov	ebx, 4
$LN468@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN484@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN486@operator@339
	or	eax, 4
$LN486@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN484@operator@339:

; 208  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.commandExecution.begin(); currentValue != statsLog.commandExecution.end(); currentValue++)

	mov	edx, DWORD PTR [edi+168]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR [edi+148]
	mov	DWORD PTR _currentValue$123925[esp+52], eax
	mov	DWORD PTR _currentValue$123925[esp+48], esi
$LL512@operator@339:
	mov	ebx, DWORD PTR [edi+168]
	mov	eax, DWORD PTR [edi+148]
	test	esi, esi
	je	SHORT $LN542@operator@339
	cmp	esi, eax
	je	SHORT $LN543@operator@339
$LN542@operator@339:
	call	__invalid_parameter_noinfo
$LN543@operator@339:
	cmp	DWORD PTR _currentValue$123925[esp+52], ebx
	je	$LN25@operator@339

; 209  : 	{
; 210  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	test	esi, esi
	jne	$LN1308@operator@339
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN562@operator@339:
	mov	ecx, DWORD PTR _currentValue$123925[esp+52]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN551@operator@339
	call	__invalid_parameter_noinfo
$LN551@operator@339:
	test	esi, esi
	jne	$LN1307@operator@339
	call	__invalid_parameter_noinfo
$LN578@operator@339:
	mov	edx, DWORD PTR _currentValue$123925[esp+52]
	cmp	edx, DWORD PTR [esi+20]
	jne	SHORT $LN567@operator@339
	call	__invalid_parameter_noinfo
$LN567@operator@339:
	mov	eax, DWORD PTR _currentValue$123925[esp+52]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _os$[ebp]
	push	ecx
	push	ecx
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	push	edx
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN587@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN587@operator@339
	mov	ebx, 4
$LN587@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN26@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN605@operator@339
	or	eax, 4
$LN605@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN26@operator@339:
	mov	eax, DWORD PTR _currentValue$123925[esp+48]
	test	eax, eax
	jne	SHORT $LN1306@operator@339
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN519@operator@339:
	mov	edx, DWORD PTR _currentValue$123925[esp+52]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN508@operator@339

; 208  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.commandExecution.begin(); currentValue != statsLog.commandExecution.end(); currentValue++)

	call	__invalid_parameter_noinfo
$LN508@operator@339:
	mov	eax, DWORD PTR _currentValue$123925[esp+52]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR _currentValue$123925[esp+48]
	mov	DWORD PTR _currentValue$123925[esp+52], ecx
	jmp	$LL512@operator@339
$LN1308@operator@339:

; 209  : 	{
; 210  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	mov	eax, DWORD PTR [esi]
	jmp	$LN562@operator@339
$LN1307@operator@339:
	mov	esi, DWORD PTR [esi]
	jmp	$LN578@operator@339
$LN1306@operator@339:

; 208  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.commandExecution.begin(); currentValue != statsLog.commandExecution.end(); currentValue++)

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN519@operator@339
$LN25@operator@339:

; 211  : 	}
; 212  : 	os << "----Transaction Latency " << statsLog.transactionExecution.size() << "----" << endl;

	mov	eax, DWORD PTR [edi+388]
	mov	edx, DWORD PTR _os$[ebp]
	push	OFFSET ??_C@_04ECGLBLOI@?9?9?9?9?$AA@
	push	ecx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BJ@CCJBOFFI@?9?9?9?9Transaction?5Latency?5?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN615@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN615@operator@339
	mov	ebx, 4
$LN615@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN631@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN633@operator@339
	or	eax, 4
$LN633@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN631@operator@339:

; 213  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.transactionExecution.begin(); currentValue != statsLog.transactionExecution.end(); currentValue++)

	mov	edx, DWORD PTR [edi+384]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR [edi+364]
	mov	DWORD PTR _currentValue$123960[esp+52], eax
	mov	DWORD PTR _currentValue$123960[esp+48], esi
	npad	10
$LL659@operator@339:
	mov	ebx, DWORD PTR [edi+384]
	mov	eax, DWORD PTR [edi+364]
	test	esi, esi
	je	SHORT $LN689@operator@339
	cmp	esi, eax
	je	SHORT $LN690@operator@339
$LN689@operator@339:
	call	__invalid_parameter_noinfo
$LN690@operator@339:
	cmp	DWORD PTR _currentValue$123960[esp+52], ebx
	je	$LN22@operator@339

; 214  : 	{
; 215  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	test	esi, esi
	jne	$LN1305@operator@339
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN709@operator@339:
	mov	ecx, DWORD PTR _currentValue$123960[esp+52]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN698@operator@339
	call	__invalid_parameter_noinfo
$LN698@operator@339:
	test	esi, esi
	jne	$LN1304@operator@339
	call	__invalid_parameter_noinfo
$LN725@operator@339:
	mov	edx, DWORD PTR _currentValue$123960[esp+52]
	cmp	edx, DWORD PTR [esi+20]
	jne	SHORT $LN714@operator@339
	call	__invalid_parameter_noinfo
$LN714@operator@339:
	mov	eax, DWORD PTR _currentValue$123960[esp+52]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _os$[ebp]
	push	ecx
	push	ecx
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	push	edx
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN734@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN734@operator@339
	mov	ebx, 4
$LN734@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN23@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN752@operator@339
	or	eax, 4
$LN752@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN23@operator@339:
	mov	eax, DWORD PTR _currentValue$123960[esp+48]
	test	eax, eax
	jne	SHORT $LN1303@operator@339
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN666@operator@339:
	mov	edx, DWORD PTR _currentValue$123960[esp+52]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN655@operator@339

; 213  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.transactionExecution.begin(); currentValue != statsLog.transactionExecution.end(); currentValue++)

	call	__invalid_parameter_noinfo
$LN655@operator@339:
	mov	eax, DWORD PTR _currentValue$123960[esp+52]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR _currentValue$123960[esp+48]
	mov	DWORD PTR _currentValue$123960[esp+52], ecx
	jmp	$LL659@operator@339
$LN1305@operator@339:

; 214  : 	{
; 215  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	mov	eax, DWORD PTR [esi]
	jmp	$LN709@operator@339
$LN1304@operator@339:
	mov	esi, DWORD PTR [esi]
	jmp	$LN725@operator@339
$LN1303@operator@339:

; 213  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.transactionExecution.begin(); currentValue != statsLog.transactionExecution.end(); currentValue++)

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN666@operator@339
$LN22@operator@339:

; 216  : 	}
; 217  : 
; 218  : 	os << "----Working Set----" << endl << statsLog.workingSet.size() << endl;

	mov	eax, DWORD PTR _os$[ebp]
	mov	edx, DWORD PTR [edi+488]
	push	OFFSET ??_C@_0BE@PBEECLAB@?9?9?9?9Working?5Set?9?9?9?9?$AA@
	push	eax
	mov	DWORD PTR $T589782[esp+56], edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN760@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN760@operator@339
	mov	ebx, 4
$LN760@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN776@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN778@operator@339
	or	eax, 4
$LN778@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN776@operator@339:
	mov	edx, DWORD PTR $T589782[esp+48]
	push	edx
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN784@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN784@operator@339
	mov	ebx, 4
$LN784@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN800@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN802@operator@339
	or	eax, 4
$LN802@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN800@operator@339:

; 219  : 
; 220  : 	os << "----Bandwidth----" << endl << setprecision(10) << (float)statsLog.readBytesTransferred / statsLog.timePerEpoch << " " << (float)statsLog.writeBytesTransferred / statsLog.timePerEpoch << endl;

	mov	edx, DWORD PTR _os$[ebp]
	push	OFFSET ??_C@_0BC@FLEKEEG@?9?9?9?9Bandwidth?9?9?9?9?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN808@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN808@operator@339
	mov	ebx, 4
$LN808@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN824@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN826@operator@339
	or	eax, 4
$LN826@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN824@operator@339:
	lea	edx, DWORD PTR $T587229[esp+48]
	push	10					; 0000000aH
	push	edx
	call	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z ; std::setprecision
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax]
	add	ecx, esi
	push	edx
	push	ecx
	call	eax
	fld	DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [edi+48]
	fstp	DWORD PTR tv4480[esp+64]
	fild	DWORD PTR [edi+48]
	test	ecx, ecx
	jge	SHORT $LN1348@operator@339
	fadd	DWORD PTR __real@4f800000
$LN1348@operator@339:
	fld	DWORD PTR tv4480[esp+64]
	mov	edx, DWORD PTR [edi+44]
	fld	ST(0)
	add	esp, 8
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR tv5325[esp+56]
	fld	DWORD PTR tv5325[esp+56]
	fstp	DWORD PTR [esp+4]
	fild	DWORD PTR [edi+44]
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	test	edx, edx
	jge	SHORT $LN1349@operator@339
	fadd	DWORD PTR __real@4f800000
$LN1349@operator@339:
	fdivrp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR tv5321[esp+68]
	fld	DWORD PTR tv5321[esp+68]
	fstp	DWORD PTR [esp]
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN836@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN836@operator@339
	mov	ebx, 4
$LN836@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN852@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN854@operator@339
	or	eax, 4
$LN854@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN852@operator@339:

; 221  : 
; 222  : 	os << "----Average Transaction Latency Per PC Value " << statsLog.pcOccurrence.size() << "----" << endl;

	mov	eax, DWORD PTR [edi+456]
	mov	edx, DWORD PTR _os$[ebp]
	push	OFFSET ??_C@_04ECGLBLOI@?9?9?9?9?$AA@
	push	ecx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0CO@FAIAOJGB@?9?9?9?9Average?5Transaction?5Latency?5@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN862@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN862@operator@339
	mov	ebx, 4
$LN862@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN878@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN880@operator@339
	or	eax, 4
$LN880@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN878@operator@339:

; 223  : 	for (std::map<PhysicalAddress, Statistics::DelayCounter>::const_iterator currentValue = statsLog.pcOccurrence.begin(); currentValue != statsLog.pcOccurrence.end(); currentValue++)

	mov	edx, DWORD PTR [edi+452]
	mov	esi, DWORD PTR [edi+428]
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR _currentValue$124113[esp+48], esi
	npad	7
$LL905@operator@339:
	mov	eax, DWORD PTR [edi+452]
	mov	DWORD PTR $T587231[esp+52], eax
	mov	eax, DWORD PTR [edi+428]
	test	esi, esi
	je	SHORT $LN953@operator@339
	cmp	esi, eax
	je	SHORT $LN954@operator@339
$LN953@operator@339:
	call	__invalid_parameter_noinfo
$LN954@operator@339:
	cmp	ebx, DWORD PTR $T587231[esp+52]
	je	$LN19@operator@339

; 224  : 	{
; 225  : 		os << std::hex << (*currentValue).first << " " << std::noshowpoint << (float)(*currentValue).second.getAccumulatedLatency() / (float)(*currentValue).second.getCount() << " " << std::dec << (*currentValue).second.getCount() << endl;

	test	esi, esi
	jne	SHORT $LN1302@operator@339
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN970@operator@339:
	cmp	ebx, DWORD PTR [eax+24]
	jne	SHORT $LN961@operator@339
	call	__invalid_parameter_noinfo
$LN961@operator@339:
	mov	ecx, DWORD PTR [ebx+32]
	mov	DWORD PTR $T590687[esp+48], ecx
	test	esi, esi
	jne	SHORT $LN1301@operator@339
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN986@operator@339:
	cmp	ebx, DWORD PTR [eax+24]
	jne	SHORT $LN977@operator@339
	call	__invalid_parameter_noinfo
$LN977@operator@339:
	mov	edx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR $T590726[esp+48], edx
	mov	DWORD PTR $T590726[esp+52], eax
	test	esi, esi
	jne	SHORT $LN1300@operator@339
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1002@operator@339:
	cmp	ebx, DWORD PTR [eax+24]
	jne	SHORT $LN993@operator@339
	call	__invalid_parameter_noinfo
$LN993@operator@339:
	mov	ecx, DWORD PTR [ebx+32]
	mov	DWORD PTR $T590765[esp+48], ecx
	test	esi, esi
	jne	SHORT $LN1299@operator@339
	call	__invalid_parameter_noinfo
$LN1018@operator@339:
	cmp	ebx, DWORD PTR [esi+24]
	jne	SHORT $LN1009@operator@339
	call	__invalid_parameter_noinfo
$LN1009@operator@339:
	mov	ecx, DWORD PTR _os$[ebp]
	test	ecx, ecx
	jne	SHORT $LN1025@operator@339
	xor	eax, eax
	jmp	SHORT $LN1026@operator@339
$LN1302@operator@339:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN970@operator@339
$LN1301@operator@339:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN986@operator@339
$LN1300@operator@339:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN1002@operator@339
$LN1299@operator@339:
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN1018@operator@339
$LN1025@operator@339:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	add	eax, ecx
$LN1026@operator@339:
	mov	edx, DWORD PTR [eax+16]
	and	edx, -1537				; fffff9ffH
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	or	edx, 2048				; 00000800H
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR [ebx+20]
	mov	edx, DWORD PTR [ebx+16]
	push	ecx
	push	eax
	push	edx
	push	ecx
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1033@operator@339
	xor	ecx, ecx
	jmp	SHORT $LN1034@operator@339
$LN1033@operator@339:
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
$LN1034@operator@339:
	mov	edx, DWORD PTR $T590765[esp+48]
	fild	QWORD PTR $T590726[esp+48]
	and	DWORD PTR [ecx+16], -17			; ffffffefH
	fild	DWORD PTR $T590765[esp+48]
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	test	edx, edx
	jge	SHORT $LN1350@operator@339
	fadd	DWORD PTR __real@4f800000
$LN1350@operator@339:
	fdivp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR tv5286[esp+60]
	fld	DWORD PTR tv5286[esp+60]
	fstp	DWORD PTR [esp]
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1041@operator@339
	xor	ecx, ecx
	jmp	SHORT $LN1042@operator@339
$LN1041@operator@339:
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
$LN1042@operator@339:
	mov	edx, DWORD PTR [ecx+16]
	and	edx, -3073				; fffff3ffH
	or	edx, 512				; 00000200H
	mov	DWORD PTR [ecx+16], edx
	mov	ecx, DWORD PTR $T590687[esp+48]
	push	ecx
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	test	BYTE PTR [eax+8], 6
	mov	DWORD PTR __State$590977[esp+48], 0
	jne	SHORT $LN1322@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	mov	edx, 4
	cmp	eax, -1
	je	SHORT $LN1051@operator@339
$LN1322@operator@339:
	mov	edx, DWORD PTR __State$590977[esp+48]
$LN1051@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edx, edx
	je	SHORT $LN20@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN1069@operator@339
	or	eax, 4
$LN1069@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN20@operator@339:

; 223  : 	for (std::map<PhysicalAddress, Statistics::DelayCounter>::const_iterator currentValue = statsLog.pcOccurrence.begin(); currentValue != statsLog.pcOccurrence.end(); currentValue++)

	cmp	DWORD PTR _currentValue$124113[esp+48], 0
	jne	SHORT $LN909@operator@339
	call	__invalid_parameter_noinfo
$LN909@operator@339:
	cmp	BYTE PTR [ebx+41], 0
	je	SHORT $LN908@operator@339
	call	__invalid_parameter_noinfo
	mov	esi, DWORD PTR _currentValue$124113[esp+48]
	jmp	$LL905@operator@339
$LN908@operator@339:
	mov	eax, DWORD PTR [ebx+8]
	cmp	BYTE PTR [eax+41], 0
	jne	SHORT $LN1284@operator@339
	mov	ebx, eax
	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+41], 0
	jne	SHORT $LN922@operator@339
$LL923@operator@339:
	mov	ebx, eax
	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+41], 0
	je	SHORT $LL923@operator@339
$LN922@operator@339:
	mov	esi, DWORD PTR _currentValue$124113[esp+48]
	jmp	$LL905@operator@339
$LN1284@operator@339:
	mov	eax, DWORD PTR [ebx+4]
	cmp	BYTE PTR [eax+41], 0
	jne	SHORT $LN903@operator@339
	npad	2
$LL904@operator@339:
	cmp	ebx, DWORD PTR [eax+8]
	jne	SHORT $LN903@operator@339
	mov	ebx, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+41], 0
	je	SHORT $LL904@operator@339
$LN903@operator@339:
	mov	esi, DWORD PTR _currentValue$124113[esp+48]
	mov	ebx, eax
	jmp	$LL905@operator@339
$LN19@operator@339:

; 226  : 	}
; 227  : 
; 228  : 	os << "----Row Hit/Miss Counts----" << endl << statsLog.getHitCount() << " " << statsLog.getMissCount() << endl;

	mov	ecx, DWORD PTR _os$[ebp]
	mov	edx, DWORD PTR [edi+60]
	mov	eax, DWORD PTR [edi+56]
	push	OFFSET ??_C@_0BM@FMOJPDMJ@?9?9?9?9Row?5Hit?1Miss?5Counts?9?9?9?9?$AA@
	push	ecx
	mov	DWORD PTR $T590984[esp+56], edx
	mov	DWORD PTR $T590988[esp+56], eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN1079@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1079@operator@339
	mov	ebx, 4
$LN1079@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN1095@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN1097@operator@339
	or	eax, 4
$LN1097@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN1095@operator@339:
	mov	edx, DWORD PTR $T590984[esp+48]
	mov	eax, DWORD PTR $T590988[esp+48]
	push	edx
	push	ecx
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	push	eax
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN1103@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1103@operator@339
	mov	ebx, 4
$LN1103@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN1119@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN1121@operator@339
	or	eax, 4
$LN1121@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN1119@operator@339:

; 229  : 
; 230  : 	os << "----Utilization----" << endl;

	mov	edx, DWORD PTR _os$[ebp]
	push	OFFSET ??_C@_0BE@JGDENAHI@?9?9?9?9Utilization?9?9?9?9?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN1127@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1127@operator@339
	mov	ebx, 4
$LN1127@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN1143@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN1145@operator@339
	or	eax, 4
$LN1145@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN1143@operator@339:

; 231  : 	for (unsigned i = 0; i < statsLog.channels; i++)

	cmp	DWORD PTR [edi], 0
	mov	DWORD PTR _i$124164[esp+48], 0
	jbe	$LN16@operator@339
	npad	6
$LL18@operator@339:

; 232  : 	{
; 233  : 		for (unsigned j = 0; j < statsLog.ranks; j++)

	cmp	DWORD PTR [edi+4], 0
	mov	DWORD PTR _j$124168[esp+48], 0
	jbe	$LN17@operator@339
$LL15@operator@339:

; 234  : 		{
; 235  : 			for (unsigned k = 0; k < statsLog.banks; k++)

	cmp	DWORD PTR [edi+8], 0
	mov	DWORD PTR _k$124172[esp+48], 0
	jbe	$LN14@operator@339
$LL12@operator@339:

; 236  : 			{
; 237  : 				os << "(" << i << "," << j << "," << k << ") " << statsLog.aggregateBankUtilization[i * statsLog.ranks * statsLog.banks + j * statsLog.banks + k] << endl;

	mov	esi, DWORD PTR [edi+4]
	imul	esi, DWORD PTR _i$124164[esp+48]
	add	esi, DWORD PTR _j$124168[esp+48]
	mov	edx, DWORD PTR [edi+508]
	imul	esi, DWORD PTR [edi+8]
	sub	edx, DWORD PTR [edi+504]
	add	esi, DWORD PTR _k$124172[esp+48]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN1147@operator@339
	call	__invalid_parameter_noinfo
$LN1147@operator@339:
	mov	eax, DWORD PTR [edi+504]
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	edx, DWORD PTR _k$124172[esp+48]
	push	ecx
	push	ecx
	push	OFFSET ??_C@_02KCKGHPCA@?$CJ?5?$AA@
	push	ecx
	lea	eax, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _j$124168[esp+64]
	push	edx
	mov	edx, DWORD PTR _os$[ebp]
	push	ecx
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	push	eax
	push	ecx
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	mov	ecx, DWORD PTR _i$124164[esp+96]
	push	ecx
	push	ecx
	push	OFFSET ??_C@_01ODHLEDKK@?$CI?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN1156@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1156@operator@339
	mov	ebx, 4
$LN1156@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN11@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN1174@operator@339
	or	eax, 4
$LN1174@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN11@operator@339:
	mov	eax, DWORD PTR _k$124172[esp+48]
	inc	eax
	mov	DWORD PTR _k$124172[esp+48], eax
	cmp	eax, DWORD PTR [edi+8]
	jb	$LL12@operator@339
$LN14@operator@339:

; 232  : 	{
; 233  : 		for (unsigned j = 0; j < statsLog.ranks; j++)

	mov	eax, DWORD PTR _j$124168[esp+48]
	inc	eax
	mov	DWORD PTR _j$124168[esp+48], eax
	cmp	eax, DWORD PTR [edi+4]
	jb	$LL15@operator@339
$LN17@operator@339:

; 231  : 	for (unsigned i = 0; i < statsLog.channels; i++)

	mov	eax, DWORD PTR _i$124164[esp+48]
	inc	eax
	mov	DWORD PTR _i$124164[esp+48], eax
	cmp	eax, DWORD PTR [edi]
	jb	$LL18@operator@339
$LN16@operator@339:

; 238  : 			}
; 239  : 		}
; 240  : 	}
; 241  : 
; 242  : 	os << "----Latency Breakdown----" << endl;

	mov	edx, DWORD PTR _os$[ebp]
	push	OFFSET ??_C@_0BK@JBNJPPAB@?9?9?9?9Latency?5Breakdown?9?9?9?9?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN1180@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1180@operator@339
	mov	ebx, 4
$LN1180@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN1196@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN1198@operator@339
	or	eax, 4
$LN1198@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN1196@operator@339:

; 243  : 	for (unsigned i = 0; i < statsLog.channels; i++)

	cmp	DWORD PTR [edi], 0
	mov	DWORD PTR _i$124188[esp+48], 0
	jbe	$LN7@operator@339
	npad	6
$LL9@operator@339:

; 244  : 	{
; 245  : 		for (unsigned j = 0; j < statsLog.ranks; j++)

	cmp	DWORD PTR [edi+4], 0
	mov	DWORD PTR _j$124192[esp+48], 0
	jbe	$LN8@operator@339
$LL6@operator@339:

; 246  : 		{
; 247  : 			for (unsigned k = 0; k < statsLog.banks; k++)

	cmp	DWORD PTR [edi+8], 0
	mov	DWORD PTR _k$124196[esp+48], 0
	jbe	$LN5@operator@339
$LL3@operator@339:

; 248  : 			{
; 249  : 				os << "(" << i << "," << j << "," << k << ") " << statsLog.bankLatencyUtilization[i * statsLog.ranks * statsLog.banks + j * statsLog.banks + k] << endl;

	mov	esi, DWORD PTR [edi+4]
	imul	esi, DWORD PTR _i$124188[esp+48]
	add	esi, DWORD PTR _j$124192[esp+48]
	mov	edx, DWORD PTR [edi+532]
	imul	esi, DWORD PTR [edi+8]
	sub	edx, DWORD PTR [edi+528]
	add	esi, DWORD PTR _k$124196[esp+48]
	sar	edx, 3
	cmp	esi, edx
	jb	SHORT $LN1200@operator@339
	call	__invalid_parameter_noinfo
$LN1200@operator@339:
	mov	eax, DWORD PTR [edi+528]
	mov	ecx, DWORD PTR [eax+esi*8+4]
	mov	edx, DWORD PTR [eax+esi*8]
	push	ecx
	push	edx
	mov	edx, DWORD PTR _i$124188[esp+56]
	lea	eax, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR _k$124196[esp+56]
	push	OFFSET ??_C@_02KCKGHPCA@?$CJ?5?$AA@
	push	ecx
	push	eax
	mov	eax, DWORD PTR _os$[ebp]
	push	ecx
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	mov	ecx, DWORD PTR _j$124192[esp+80]
	push	ecx
	push	ecx
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	push	edx
	push	ecx
	push	OFFSET ??_C@_01ODHLEDKK@?$CI?$AA@
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN1209@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1209@operator@339
	mov	ebx, 4
$LN1209@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN2@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN1227@operator@339
	or	eax, 4
$LN1227@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN2@operator@339:
	mov	eax, DWORD PTR _k$124196[esp+48]
	inc	eax
	mov	DWORD PTR _k$124196[esp+48], eax
	cmp	eax, DWORD PTR [edi+8]
	jb	$LL3@operator@339
$LN5@operator@339:

; 244  : 	{
; 245  : 		for (unsigned j = 0; j < statsLog.ranks; j++)

	mov	eax, DWORD PTR _j$124192[esp+48]
	inc	eax
	mov	DWORD PTR _j$124192[esp+48], eax
	cmp	eax, DWORD PTR [edi+4]
	jb	$LL6@operator@339
$LN8@operator@339:

; 243  : 	for (unsigned i = 0; i < statsLog.channels; i++)

	mov	eax, DWORD PTR _i$124188[esp+48]
	inc	eax
	mov	DWORD PTR _i$124188[esp+48], eax
	cmp	eax, DWORD PTR [edi]
	jb	$LL9@operator@339
$LN7@operator@339:

; 250  : 			}
; 251  : 		}
; 252  : 	}
; 253  : 
; 254  : 	os << "----tFAW Limited Commands----" << endl << statsLog.issuedAtTFAW << endl;

	mov	edx, DWORD PTR _os$[ebp]
	push	OFFSET ??_C@_0BO@EIIIOAJG@?9?9?9?9tFAW?5Limited?5Commands?9?9?9?9?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN1233@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1233@operator@339
	mov	ebx, 4
$LN1233@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN1249@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN1251@operator@339
	or	eax, 4
$LN1251@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN1249@operator@339:
	mov	edx, DWORD PTR [edi+64]
	push	edx
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN1257@operator@339
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1257@operator@339
	mov	edi, 4
$LN1257@operator@339:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN1318@operator@339
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN1275@operator@339
	or	eax, 4
$LN1275@operator@339:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN1318@operator@339:

; 255  : #ifdef M5
; 256  : 
; 257  : 	using Stats::Info;
; 258  : 	std::list<Info *>::const_iterator i = Stats::statsList().begin();
; 259  : 	std::list<Info *>::const_iterator end = Stats::statsList().end();
; 260  : 
; 261  : 	for (;i != end;++i)
; 262  : 	{
; 263  : 		Info *info = *i;
; 264  : 		if (info->name.find("ipc_total") != string::npos)
; 265  : 		{
; 266  : 			os << "----IPC----" << endl;
; 267  : 			std::vector<Stats::Result>::const_iterator start = ((Stats::FormulaInfoProxy<Stats::Formula> *)info)->result().begin();
; 268  : 			std::vector<Stats::Result>::const_iterator end = ((Stats::FormulaInfoProxy<Stats::Formula> *)info)->result().end();
; 269  : 			while (start != end)
; 270  : 			{
; 271  : 				os << *start << endl;
; 272  : 				start++;
; 273  : 				// only considering single-threaded for now
; 274  : 				//break;
; 275  : 			}
; 276  : 		}
; 277  : 		if ((info->name.find("dcache.overall_hits") != string::npos) ||
; 278  : 			(info->name.find("dcache.overall_misses") != string::npos) ||
; 279  : 			(info->name.find("dcache.overall_miss_latency") != string::npos) ||
; 280  : 			(info->name.find("icache.overall_hits") != string::npos) ||
; 281  : 			(info->name.find("icache.overall_misses") != string::npos) ||
; 282  : 			(info->name.find("icache.overall_miss_latency") != string::npos) ||
; 283  : 			(info->name.find("l2.overall_hits") != string::npos) ||
; 284  : 			(info->name.find("l2.overall_misses") != string::npos) ||
; 285  : 			(info->name.find("l2.overall_mshr_hits") != string::npos) ||
; 286  : 			(info->name.find("l2.overall_mshr_misses") != string::npos) ||
; 287  : 			(info->name.find("l2.overall_mshr_miss_latency") != string::npos) ||
; 288  : 			(info->name.find("l2.overall_miss_latency") != string::npos))
; 289  : 		{
; 290  : 			{
; 291  : 				os << "----M5 Stat: " << info->name << " ";
; 292  : 
; 293  : 				std::vector<Stats::Result>::const_iterator start = ((Stats::FormulaInfoProxy<Stats::Formula> *)info)->result().begin();
; 294  : 				std::vector<Stats::Result>::const_iterator end = ((Stats::FormulaInfoProxy<Stats::Formula> *)info)->result().end();
; 295  : 				while (start != end)
; 296  : 				{
; 297  : 					os << *start << " ";
; 298  : 					start++;
; 299  : 				}
; 300  : 				os << endl;
; 301  : 			}
; 302  : 		}		
; 303  : 	}		
; 304  : #endif
; 305  : 
; 306  : 	return os;

	mov	eax, DWORD PTR _os$[ebp]

; 307  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVStatistics@0@@Z ENDP ; DRAMsimII::operator<<
END
