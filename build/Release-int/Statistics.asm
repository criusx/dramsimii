; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\CriuS\Documents\Visual Studio 2008\Projects\DRAMsimIIhg\src\Statistics.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
PUBLIC	?_Checked_iterator_base@?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEPAIXZ ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@@Z ; std::_Checked_base<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ; std::_Move_cat<unsigned int *>
PUBLIC	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$_Umove@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_iterator@IV?$allocator@I@std@@@1@0PAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::reserve
PUBLIC	?_Checked_iterator_base@?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEPA_JXZ ; std::_Vector_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<__int64,std::allocator<__int64> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@@Z ; std::_Checked_base<std::_Vector_iterator<__int64,std::allocator<__int64> > >
PUBLIC	??$_Move_cat@PA_J@std@@YA?AU_Undefined_move_tag@0@ABQA_J@Z ; std::_Move_cat<__int64 *>
PUBLIC	??$_Uninit_move@PA_JPA_JV?$allocator@_J@std@@U_Undefined_move_tag@2@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<__int64 *,__int64 *,std::allocator<__int64>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<__int64,std::allocator<__int64> >,__int64 *,std::allocator<__int64> >
PUBLIC	??$_Umove@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z ; std::vector<__int64,std::allocator<__int64> >::_Umove<std::_Vector_iterator<__int64,std::allocator<__int64> > >
PUBLIC	?reserve@?$vector@_JV?$allocator@_J@std@@@std@@QAEXI@Z ; std::vector<__int64,std::allocator<__int64> >::reserve
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEPBU?$pair@U?$pair@_K_K@std@@U12@@2@XZ ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBU?$pair@U?$pair@_K_K@std@@U12@@0@AAV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@YAPBU?$pair@U?$pair@_K_K@std@@U12@@0@AAV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@PAU?$pair@U?$pair@_K_K@std@@U12@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@AAPAU?$pair@U?$pair@_K_K@std@@U12@@0@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *>
PUBLIC	??$_Uninit_copy@PBU?$pair@U?$pair@_K_K@std@@U12@@std@@PAU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@0@PBU10@0PAU10@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@PAU?$pair@U?$pair@_K_K@std@@U12@@2@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@stdext@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@std@@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAEPAU?$pair@U?$pair@_K_K@std@@U12@@1@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@0PAU21@@Z ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Ucopy<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >
PUBLIC	??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
PUBLIC	??$_Construct@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@ABV10@@Z ; std::_Construct<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >
PUBLIC	?construct@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@ABV32@@Z ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::construct
PUBLIC	??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > *,unsigned int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
PUBLIC	??$unchecked_uninitialized_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@stdext@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IABV12@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > *,unsigned int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
PUBLIC	?_Ufill@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@PAV32@IABV32@@Z ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Ufill
PUBLIC	?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Construct_n
PUBLIC	??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@@Z ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
PUBLIC	??0?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAE@XZ ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??$?0U?$pair@U?$pair@_K_K@std@@U12@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Container_base_aux_alloc_real<std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
PUBLIC	??0?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??0?$_Vector_val@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAE@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@1@@Z ; std::_Vector_val<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Vector_val<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
PUBLIC	??$_Allocate@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@0@IPAU10@@Z ; std::_Allocate<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	?allocate@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAEPAU?$pair@U?$pair@_K_K@std@@U12@@2@I@Z ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::allocate
PUBLIC	?max_size@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QBEIXZ ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::max_size
PUBLIC	?max_size@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::max_size
PUBLIC	?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Xlen
PUBLIC	?_Buy@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Buy
PUBLIC	??$_Construct@U?$pair@U?$pair@_K_K@std@@U12@@std@@U12@@std@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@0@ABU10@@Z ; std::_Construct<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	?construct@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAEXPAU?$pair@U?$pair@_K_K@std@@U12@@2@ABU32@@Z ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::construct
PUBLIC	??$_Uninit_fill_n@PAU?$pair@U?$pair@_K_K@std@@U12@@std@@IU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@0@IABU10@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,unsigned int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
PUBLIC	??$unchecked_uninitialized_fill_n@PAU?$pair@U?$pair@_K_K@std@@U12@@std@@IU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@stdext@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@std@@IABU12@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,unsigned int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
PUBLIC	?_Ufill@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAEPAU?$pair@U?$pair@_K_K@std@@U12@@2@PAU32@IABU32@@Z ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Ufill
PUBLIC	?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Construct_n
PUBLIC	??0?$pair@_K_K@std@@QAE@XZ			; std::pair<unsigned __int64,unsigned __int64>::pair<unsigned __int64,unsigned __int64>
PUBLIC	??0?$pair@U?$pair@_K_K@std@@U12@@std@@QAE@XZ	; std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >
PUBLIC	??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@I@Z ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
PUBLIC	??0?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAE@XZ ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >
PUBLIC	??$?0V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Container_base_aux_alloc_real<std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
PUBLIC	??0?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >
PUBLIC	??0?$_Vector_val@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@1@@Z ; std::_Vector_val<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Vector_val<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
PUBLIC	??$_Allocate@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@YAPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >
PUBLIC	?allocate@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@I@Z ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::allocate
PUBLIC	?max_size@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QBEIXZ ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::max_size
PUBLIC	?max_size@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::max_size
PUBLIC	?_Xlen@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Xlen
PUBLIC	?_Buy@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Buy
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEPBU?$pair@II@2@XZ ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBU?$pair@II@0@AAV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@YAPBU?$pair@II@0@AAV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@PAU?$pair@II@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@AAPAU?$pair@II@0@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::pair<unsigned int,unsigned int> *>
PUBLIC	??$_Uninit_copy@PBU?$pair@II@std@@PAU12@V?$allocator@U?$pair@II@std@@@2@@std@@YAPAU?$pair@II@0@PBU10@0PAU10@AAV?$allocator@U?$pair@II@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> *,std::allocator<std::pair<unsigned int,unsigned int> > >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@PAU?$pair@II@2@V?$allocator@U?$pair@II@std@@@2@@stdext@@YAPAU?$pair@II@std@@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@II@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::pair<unsigned int,unsigned int> *,std::allocator<std::pair<unsigned int,unsigned int> > >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAEPAU?$pair@II@1@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@0PAU21@@Z ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Ucopy<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >
PUBLIC	??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
PUBLIC	??$_Construct@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@ABV10@@Z ; std::_Construct<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >
PUBLIC	?construct@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@ABV32@@Z ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::construct
PUBLIC	??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > *,unsigned int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
PUBLIC	??$unchecked_uninitialized_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@stdext@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IABV12@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > *,unsigned int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
PUBLIC	?_Ufill@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@IAEPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@PAV32@IABV32@@Z ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Ufill
PUBLIC	?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Construct_n
PUBLIC	??0?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@@Z ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
PUBLIC	??0?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$?0V?$vector@IV?$allocator@I@std@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Container_base_aux_alloc_real<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
PUBLIC	??0?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??0?$_Vector_val@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@IAE@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@@Z ; std::_Vector_val<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Vector_val<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
PUBLIC	??$_Allocate@V?$vector@IV?$allocator@I@std@@@std@@@std@@YAPAV?$vector@IV?$allocator@I@std@@@0@IPAV10@@Z ; std::_Allocate<std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	?allocate@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEPAV?$vector@IV?$allocator@I@std@@@2@I@Z ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocate
PUBLIC	?max_size@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QBEIXZ ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::max_size
PUBLIC	?max_size@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::max_size
PUBLIC	?_Xlen@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Xlen
PUBLIC	?_Buy@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Buy
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@AAPAI@Z ; std::_Ptr_cat<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *>
PUBLIC	??$_Uninit_copy@PBIPAIV?$allocator@I@std@@@std@@YAPAIPBI0PAIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int const *,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@1@0PAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	??$_Construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@ABV10@@Z ; std::_Construct<std::vector<unsigned int,std::allocator<unsigned int> >,std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	?construct@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEXPAV?$vector@IV?$allocator@I@std@@@2@ABV32@@Z ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::construct
PUBLIC	??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<unsigned int,std::allocator<unsigned int> > *,unsigned int,std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
PUBLIC	??$unchecked_uninitialized_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@stdext@@YAXPAV?$vector@IV?$allocator@I@std@@@std@@IABV12@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::vector<unsigned int,std::allocator<unsigned int> > *,unsigned int,std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
PUBLIC	?_Ufill@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@IAEPAV?$vector@IV?$allocator@I@std@@@2@PAV32@IABV32@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Ufill
PUBLIC	?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Construct_n
PUBLIC	??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@IABV?$vector@IV?$allocator@I@std@@@1@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
PUBLIC	??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@XZ	; std::allocator<std::pair<unsigned int const ,unsigned int> >::allocator<std::pair<unsigned int const ,unsigned int> >
PUBLIC	??0?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QAE@XZ ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >
PUBLIC	??0?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@@Z ; std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>
PUBLIC	??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,unsigned int> >::allocator<std::pair<unsigned int const ,unsigned int> >
PUBLIC	??$?0U?$pair@$$CBII@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,unsigned int> >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBII@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,unsigned int> > >
PUBLIC	??$?0U?$pair@$$CBII@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node><std::pair<unsigned int const ,unsigned int> >
PUBLIC	??0?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
PUBLIC	??$?0U?$pair@$$CBII@std@@@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *><std::pair<unsigned int const ,unsigned int> >
PUBLIC	??0?$_List_ptr@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::_List_ptr<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_ptr<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
PUBLIC	??0?$_List_val@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_val<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
PUBLIC	?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode
PUBLIC	??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
PUBLIC	??$?0U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Container_base_aux_alloc_real<std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	??0?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV01@@Z ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
PUBLIC	??0?$_Vector_val@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ; std::_Vector_val<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_val<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	?_Buy@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE_NI@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Buy
PUBLIC	??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	??$?0U?$pair@$$CBII@std@@@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position><std::pair<unsigned int const ,unsigned int> >
PUBLIC	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
PUBLIC	??0?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
PUBLIC	??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
PUBLIC	??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >
PUBLIC	??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
PUBLIC	??0?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>
PUBLIC	??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
PUBLIC	??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_val<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>::construct
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Init
PUBLIC	??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
PUBLIC	??0?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAE@XZ ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >
PUBLIC	??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::allocator<std::pair<unsigned __int64 const ,unsigned int> >
PUBLIC	??$?0U?$pair@$$CB_KI@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64 const ,unsigned int> >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >
PUBLIC	??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::allocator<std::pair<unsigned __int64 const ,unsigned int> >
PUBLIC	??0?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>
PUBLIC	??$?0U?$pair@$$CB_KI@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node><std::pair<unsigned __int64 const ,unsigned int> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
PUBLIC	??$?0U?$pair@$$CB_KI@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *><std::pair<unsigned __int64 const ,unsigned int> >
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>::construct
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Init
PUBLIC	??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
PUBLIC	??0?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAE@XZ ; std::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >
PUBLIC	??0?$allocator@I@std@@QAE@XZ			; std::allocator<unsigned int>::allocator<unsigned int>
PUBLIC	??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned int>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::_Container_base_aux_alloc_real<std::allocator<unsigned int> >
PUBLIC	??0?$allocator@I@std@@QAE@ABV01@@Z		; std::allocator<unsigned int>::allocator<unsigned int>
PUBLIC	??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
PUBLIC	??$_Allocate@I@std@@YAPAIIPAI@Z			; std::_Allocate<unsigned int>
PUBLIC	?allocate@?$allocator@I@std@@QAEPAII@Z		; std::allocator<unsigned int>::allocate
PUBLIC	?max_size@?$allocator@I@std@@QBEIXZ		; std::allocator<unsigned int>::max_size
PUBLIC	?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
PUBLIC	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
PUBLIC	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
PUBLIC	??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ; std::_Iter_cat<unsigned int *>
PUBLIC	??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<unsigned int *>
PUBLIC	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z		; std::_Checked_base<unsigned int *>
PUBLIC	??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
PUBLIC	??$_Fill_n@PAIII@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
PUBLIC	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
PUBLIC	??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
PUBLIC	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
PUBLIC	?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	??0?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAE@XZ ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >
PUBLIC	??$?0V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Container_base_aux_alloc_real<std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
PUBLIC	??0?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >
PUBLIC	??0?$_Vector_val@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@1@@Z ; std::_Vector_val<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Vector_val<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
PUBLIC	??$_Allocate@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@YAPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IPAV10@@Z ; std::_Allocate<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >
PUBLIC	?allocate@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@I@Z ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::allocate
PUBLIC	?max_size@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QBEIXZ ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::max_size
PUBLIC	?max_size@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::max_size
PUBLIC	?_Xlen@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Xlen
PUBLIC	?_Buy@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Buy
PUBLIC	??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
PUBLIC	??0?$pair@II@std@@QAE@XZ			; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int>
PUBLIC	??0?$allocator@U?$pair@II@std@@@std@@QAE@XZ	; std::allocator<std::pair<unsigned int,unsigned int> >::allocator<std::pair<unsigned int,unsigned int> >
PUBLIC	??$?0U?$pair@II@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@II@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int,unsigned int> >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@II@std@@@std@@@std@@IAE@V?$allocator@U?$pair@II@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,unsigned int> > >
PUBLIC	??0?$allocator@U?$pair@II@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int,unsigned int> >::allocator<std::pair<unsigned int,unsigned int> >
PUBLIC	??0?$_Vector_val@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAE@V?$allocator@U?$pair@II@std@@@1@@Z ; std::_Vector_val<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Vector_val<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
PUBLIC	??$_Allocate@U?$pair@II@std@@@std@@YAPAU?$pair@II@0@IPAU10@@Z ; std::_Allocate<std::pair<unsigned int,unsigned int> >
PUBLIC	?allocate@?$allocator@U?$pair@II@std@@@std@@QAEPAU?$pair@II@2@I@Z ; std::allocator<std::pair<unsigned int,unsigned int> >::allocate
PUBLIC	?max_size@?$allocator@U?$pair@II@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int,unsigned int> >::max_size
PUBLIC	?max_size@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::max_size
PUBLIC	?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Xlen
PUBLIC	?_Buy@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Buy
PUBLIC	??$_Construct@U?$pair@II@std@@U12@@std@@YAXPAU?$pair@II@0@ABU10@@Z ; std::_Construct<std::pair<unsigned int,unsigned int>,std::pair<unsigned int,unsigned int> >
PUBLIC	?construct@?$allocator@U?$pair@II@std@@@std@@QAEXPAU?$pair@II@2@ABU32@@Z ; std::allocator<std::pair<unsigned int,unsigned int> >::construct
PUBLIC	??$_Uninit_fill_n@PAU?$pair@II@std@@IU12@V?$allocator@U?$pair@II@std@@@2@@std@@YAXPAU?$pair@II@0@IABU10@AAV?$allocator@U?$pair@II@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned int,unsigned int> *,unsigned int,std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
PUBLIC	??$unchecked_uninitialized_fill_n@PAU?$pair@II@std@@IU12@V?$allocator@U?$pair@II@std@@@2@@stdext@@YAXPAU?$pair@II@std@@IABU12@AAV?$allocator@U?$pair@II@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned int,unsigned int> *,unsigned int,std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
PUBLIC	?_Ufill@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAEPAU?$pair@II@2@PAU32@IABU32@@Z ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Ufill
PUBLIC	?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Construct_n
PUBLIC	??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@I@Z ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
PUBLIC	?getDecodeDelay@Transaction@DRAMsimII@@QBE_JXZ	; DRAMsimII::Transaction::getDecodeDelay
PUBLIC	?getProgramCounter@Transaction@DRAMsimII@@QBE_KXZ ; DRAMsimII::Transaction::getProgramCounter
PUBLIC	?getLength@Transaction@DRAMsimII@@QBEIXZ	; DRAMsimII::Transaction::getLength
PUBLIC	?isWrite@Transaction@DRAMsimII@@QBE_NXZ		; DRAMsimII::Transaction::isWrite
PUBLIC	?countUp@DelayCounter@Statistics@DRAMsimII@@QAEXXZ ; DRAMsimII::Statistics::DelayCounter::countUp
PUBLIC	?delay@DelayCounter@Statistics@DRAMsimII@@QAEXI@Z ; DRAMsimII::Statistics::DelayCounter::delay
PUBLIC	??0DelayCounter@Statistics@DRAMsimII@@QAE@XZ	; DRAMsimII::Statistics::DelayCounter::DelayCounter
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator::operator--
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator,bool>
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert
PUBLIC	?max_size@?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::max_size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::max_size
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>::allocate
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node::_Node
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::const_iterator
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Dec
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::operator--
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert
PUBLIC	?_Kfn@?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@SAAB_KABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>::_Kfn
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Key
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@AB_K@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Lbound
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::lower_bound
PUBLIC	??0?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@QAE@AB_KABVDelayCounter@Statistics@DRAMsimII@@@Z ; std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator::operator*
PUBLIC	??A?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAEAAVDelayCounter@Statistics@DRAMsimII@@AB_K@Z ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::operator[]
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator::operator--
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator,bool>
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert
PUBLIC	?max_size@?$allocator@U?$pair@$$CB_KI@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::max_size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::max_size
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>::allocate
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KI@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node::_Node
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KI@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::const_iterator
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Dec
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::operator--
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert
PUBLIC	??R?$less@_K@std@@QBE_NAB_K0@Z			; std::less<unsigned __int64>::operator()
PUBLIC	?_Kfn@?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@SAAB_KABU?$pair@$$CB_KI@2@@Z ; std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>::_Kfn
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Key
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@AB_K@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Lbound
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::lower_bound
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KI@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator::operator*
PUBLIC	??0?$pair@$$CB_KI@std@@QAE@AB_KABI@Z		; std::pair<unsigned __int64 const ,unsigned int>::pair<unsigned __int64 const ,unsigned int>
PUBLIC	??A?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAEAAIAB_K@Z ; std::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::operator[]
PUBLIC	??A?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEAAV?$vector@IV?$allocator@I@std@@@1@I@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator[]
PUBLIC	?size@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::size
PUBLIC	??A?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEAAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@I@Z ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator[]
PUBLIC	?size@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::size
PUBLIC	??A?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEAAU?$pair@II@1@I@Z ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator[]
PUBLIC	?getChannel@Address@DRAMsimII@@QBEIXZ		; DRAMsimII::Address::getChannel
PUBLIC	?getDelayTime@Event@DRAMsimII@@QBE_JXZ		; DRAMsimII::Event::getDelayTime
PUBLIC	?isHit@Command@DRAMsimII@@QBE_NXZ		; DRAMsimII::Command::isHit
PUBLIC	?insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::insert
PUBLIC	?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@0@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase
PUBLIC	??$?8U?$pair@$$CBII@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBII@std@@@0@0@Z ; std::operator==<std::pair<unsigned int const ,unsigned int>,std::pair<unsigned int const ,unsigned int> >
PUBLIC	??$_Iter_cat@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@@Z ; std::_Iter_cat<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >
PUBLIC	??$_Construct@U?$pair@$$CBII@std@@U12@@std@@YAXPAU?$pair@$$CBII@0@ABU10@@Z ; std::_Construct<std::pair<unsigned int const ,unsigned int>,std::pair<unsigned int const ,unsigned int> >
PUBLIC	?construct@?$allocator@U?$pair@$$CBII@std@@@std@@QAEXPAU?$pair@$$CBII@2@ABU32@@Z ; std::allocator<std::pair<unsigned int const ,unsigned int> >::construct
PUBLIC	??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@I@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>::allocate
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *,std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>::construct
PUBLIC	?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PAU342@0ABU?$pair@$$CBII@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode
PUBLIC	?max_size@?$allocator@U?$pair@$$CBII@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int const ,unsigned int> >::max_size
PUBLIC	?max_size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::max_size
PUBLIC	?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Incsize
PUBLIC	?_Insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Insert
PUBLIC	?_Make_iter@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Make_iter
PUBLIC	?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase
PUBLIC	??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Insert<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >
PUBLIC	??$insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::insert<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >
PUBLIC	?_Splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@00I_N@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Splice
PUBLIC	?splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@0@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::splice
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::bucket_count
PUBLIC	?load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::load_factor
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::max_load_factor
PUBLIC	?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::begin
PUBLIC	?_Reinsert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Reinsert
PUBLIC	??F?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator--
PUBLIC	??F?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator--
PUBLIC	??0?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@QAE@ABV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@1@AB_N@Z ; std::pair<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>,bool>::pair<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>,bool>
PUBLIC	?_Insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@4@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Insert
PUBLIC	?insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::insert
PUBLIC	??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEAAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator[]
PUBLIC	??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::_Iterator<1>
PUBLIC	??E?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator++
PUBLIC	?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound
PUBLIC	??0?$pair@$$CBII@std@@QAE@ABI0@Z		; std::pair<unsigned int const ,unsigned int>::pair<unsigned int const ,unsigned int>
PUBLIC	??D?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEAAU?$pair@$$CBII@2@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator*
PUBLIC	??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[]
PUBLIC	??A?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEAAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@I@Z ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator[]
PUBLIC	??A?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEAAU?$pair@U?$pair@_K_K@std@@U12@@1@I@Z ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator[]
PUBLIC	?noshowpoint@std@@YAAAVios_base@1@AAV21@@Z	; std::noshowpoint
PUBLIC	?getAccumulatedLatency@DelayCounter@Statistics@DRAMsimII@@QBE_JXZ ; DRAMsimII::Statistics::DelayCounter::getAccumulatedLatency
PUBLIC	?getCount@DelayCounter@Statistics@DRAMsimII@@QBEIXZ ; DRAMsimII::Statistics::DelayCounter::getCount
PUBLIC	?begin@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::begin
PUBLIC	?end@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::end
PUBLIC	?begin@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::begin
PUBLIC	?end@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::end
PUBLIC	?getRowBufferAccesses@Statistics@DRAMsimII@@QBEABV?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@XZ ; DRAMsimII::Statistics::getRowBufferAccesses
PUBLIC	?begin@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::begin
PUBLIC	?end@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::end
PUBLIC	?begin@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::begin
PUBLIC	?end@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::end
PUBLIC	??C?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEPBV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator->
PUBLIC	??E?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator++
PUBLIC	??C?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEPBU?$pair@II@1@XZ ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator->
PUBLIC	??E?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator++
PUBLIC	??C?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEPBV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator->
PUBLIC	??E?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator++
PUBLIC	??C?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEPBU?$pair@U?$pair@_K_K@std@@U12@@1@XZ ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator->
PUBLIC	??E?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator++
PUBLIC	?begin@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const *,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const *,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const *,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const &>::_Ranit<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const *,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const &>
PUBLIC	??0?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
PUBLIC	??0?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
PUBLIC	?end@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::end
PUBLIC	?begin@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@2@XZ ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$vector@IV?$allocator@I@std@@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,std::vector<unsigned int,std::allocator<unsigned int> >,int,std::vector<unsigned int,std::allocator<unsigned int> > const *,std::vector<unsigned int,std::allocator<unsigned int> > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::vector<unsigned int,std::allocator<unsigned int> >,int,std::vector<unsigned int,std::allocator<unsigned int> > const *,std::vector<unsigned int,std::allocator<unsigned int> > const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@V?$vector@IV?$allocator@I@std@@@std@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<std::vector<unsigned int,std::allocator<unsigned int> >,int,std::vector<unsigned int,std::allocator<unsigned int> > const *,std::vector<unsigned int,std::allocator<unsigned int> > const &>::_Ranit<std::vector<unsigned int,std::allocator<unsigned int> >,int,std::vector<unsigned int,std::allocator<unsigned int> > const *,std::vector<unsigned int,std::allocator<unsigned int> > const &>
PUBLIC	??0?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@PAV?$vector@IV?$allocator@I@std@@@1@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
PUBLIC	??0?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@PAV?$vector@IV?$allocator@I@std@@@1@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
PUBLIC	?end@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@2@XZ ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::end
PUBLIC	?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::end
PUBLIC	?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::end
PUBLIC	?begin@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::begin
PUBLIC	?end@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::end
PUBLIC	??$_Allocate@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IPAU123@@Z ; std::_Allocate<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
PUBLIC	?allocate@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocate
PUBLIC	?capacity@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::capacity
PUBLIC	?max_size@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QBEIXZ ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::max_size
PUBLIC	?max_size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::max_size
PUBLIC	??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@IABU120@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	?_Ufill@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU345@IABU345@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Ufill
PUBLIC	?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Xlen
PUBLIC	??$_Construct@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU123@@Z ; std::_Construct<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
PUBLIC	?construct@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU345@@Z ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::construct
PUBLIC	??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	??$unchecked_uninitialized_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z ; stdext::unchecked_uninitialized_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	??$_Uninit_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	??$_Umove@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU234@00@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Umove<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	??$_Fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z ; std::_Fill<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
PUBLIC	??$fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z ; std::fill<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
PUBLIC	??$_Move_cat@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::_Move_cat<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::forward_iterator_tag>
PUBLIC	??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	??$_Move_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z ; stdext::_Unchecked_move_backward<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Insert_n
PUBLIC	?insert@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::insert
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &>::_Ranit<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &>
PUBLIC	??0?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	??0?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
PUBLIC	?_Make_iter@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator==
PUBLIC	??9?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator!=
PUBLIC	??$_Iter_random@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0@Z ; std::_Iter_random<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@@Z ; std::_Checked_base<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::forward_iterator_tag>
PUBLIC	??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	??$unchecked_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z ; stdext::unchecked_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
PUBLIC	?erase@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@0@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::erase
PUBLIC	?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Assign_n
PUBLIC	?assign@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::assign
PUBLIC	??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<0>::_Const_iterator<0>
PUBLIC	??0?$_Iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<0>::_Iterator<0>
PUBLIC	??0_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::_List_position
PUBLIC	?_Init@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Init
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
PUBLIC	??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
PUBLIC	?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
PUBLIC	??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
PUBLIC	?begin@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const *,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const *,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const *,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const &>::_Ranit<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const *,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const &>
PUBLIC	??0?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
PUBLIC	??0?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
PUBLIC	?end@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::end
PUBLIC	?begin@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@II@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,unsigned int>,int,std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,unsigned int>,int,std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@U?$pair@II@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Ranit<std::pair<unsigned int,unsigned int>,int,std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> const &>::_Ranit<std::pair<unsigned int,unsigned int>,int,std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> const &>
PUBLIC	??0?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@PAU?$pair@II@1@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
PUBLIC	??0?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@PAU?$pair@II@1@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
PUBLIC	?end@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::end
PUBLIC	?begin@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@U?$pair@_K_K@std@@U12@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@U?$pair@U?$pair@_K_K@std@@U12@@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Ranit<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const &>::_Ranit<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const &>
PUBLIC	??0?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@PAU?$pair@U?$pair@_K_K@std@@U12@@1@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
PUBLIC	??0?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@PAU?$pair@U?$pair@_K_K@std@@U12@@1@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
PUBLIC	?end@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::end
PUBLIC	??8?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator!=
PUBLIC	??8?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator!=
PUBLIC	??8?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator!=
PUBLIC	??8?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator==
PUBLIC	??9?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator!=
PUBLIC	??D?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator*
PUBLIC	??D?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEAAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator*
PUBLIC	??C?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator->
PUBLIC	??E?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator++
PUBLIC	??D?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEABU?$pair@II@1@XZ ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator*
PUBLIC	??D?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEAAU?$pair@II@1@XZ ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator*
PUBLIC	??C?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEPAU?$pair@II@1@XZ ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator->
PUBLIC	??E?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator++
PUBLIC	??E?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator++
PUBLIC	??E?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator++
PUBLIC	??D?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator*
PUBLIC	??D?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEAAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator*
PUBLIC	??C?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator->
PUBLIC	??E?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator++
PUBLIC	??D?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEABU?$pair@U?$pair@_K_K@std@@U12@@1@XZ ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator*
PUBLIC	??D?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEAAU?$pair@U?$pair@_K_K@std@@U12@@1@XZ ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator*
PUBLIC	??C?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEPAU?$pair@U?$pair@_K_K@std@@U12@@1@XZ ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator->
PUBLIC	??E?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator++
PUBLIC	??E?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator++
PUBLIC	??E?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator!=
PUBLIC	??D?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEABV?$vector@IV?$allocator@I@std@@@1@XZ ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator*
PUBLIC	??D?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEAAV?$vector@IV?$allocator@I@std@@@1@XZ ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator*
PUBLIC	??C?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEPAV?$vector@IV?$allocator@I@std@@@1@XZ ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator->
PUBLIC	??E?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator++
PUBLIC	??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==
PUBLIC	??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=
PUBLIC	??D?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEABIXZ ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator*
PUBLIC	??D?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEAAIXZ ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator*
PUBLIC	??E?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator++
PUBLIC	??E?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator++
PUBLIC	??E?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator++
PUBLIC	?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::begin
PUBLIC	?begin@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::begin
PUBLIC	?size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::size
PUBLIC	?size@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::size
PUBLIC	?_Kfn@?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@SAABIABU?$pair@$$CBII@3@@Z ; std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>::_Kfn
PUBLIC	??R?$equal_to@I@std@@QBE_NABI0@Z		; std::equal_to<unsigned int>::operator()
PUBLIC	??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBE_NABI0@Z ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::operator()
PUBLIC	??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::_Iterator<1>
PUBLIC	?_Get_iter@_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABV56@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::_Get_iter
PUBLIC	?_Get_iter_from_vec@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABU_List_position@12@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Get_iter_from_vec
PUBLIC	??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Const_iterator<1>
PUBLIC	?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::end
PUBLIC	?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::end
PUBLIC	??R?$hash@I@tr1@std@@QBEIABI@Z			; std::tr1::hash<unsigned int>::operator()
PUBLIC	??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBEIABI@Z ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::operator()
PUBLIC	?_Hashval@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IBEIABI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hashval
PUBLIC	?size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::size
PUBLIC	??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator[]
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBII@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Bidit@U?$pair@$$CBII@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &>::_Bidit<std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &>
PUBLIC	??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Const_iterator<1>
PUBLIC	?_Mynode@?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Mynode
PUBLIC	?_Mynode@?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<0>::_Mynode
PUBLIC	??8_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::operator==
PUBLIC	??9_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::operator!=
PUBLIC	?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound
PUBLIC	?find@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::find
PUBLIC	?_Myval@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@KAAAU?$pair@$$CBII@2@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Myval
PUBLIC	??D?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEABU?$pair@$$CBII@2@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator*
PUBLIC	??C?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPBU?$pair@$$CBII@2@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator->
PUBLIC	??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator++
PUBLIC	??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV012@H@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator++
PUBLIC	??8?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator==
PUBLIC	??9?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator!=
PUBLIC	??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z ; DRAMsimII::operator==<unsigned int,unsigned int>
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@IHPBIABI@std@@QAE@XZ		; std::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>
PUBLIC	??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
PUBLIC	?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
PUBLIC	??$_Iter_random@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@0@Z ; std::_Iter_random<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
PUBLIC	??H?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEPBIXZ ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$_Equal@PBIPBIUforward_iterator_tag@std@@@std@@YA_NPBI00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<unsigned int const *,unsigned int const *,std::forward_iterator_tag>
PUBLIC	??$_Equal@PBIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YA_NPBI0V?$_Vector_const_iterator@IV?$allocator@I@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<unsigned int const *,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$equal@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@00@Z ; std::equal<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$?8IV?$allocator@I@std@@@std@@YA_NABV?$vector@IV?$allocator@I@std@@@0@0@Z ; std::operator==<unsigned int,std::allocator<unsigned int> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::end
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::size
PUBLIC	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
PUBLIC	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
PUBLIC	??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z ; std::_Iter_random<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Myval
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::operator*
PUBLIC	??8DelayCounter@Statistics@DRAMsimII@@QBE_NABV012@@Z ; DRAMsimII::Statistics::DelayCounter::operator==
PUBLIC	??$?8$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@YA_NABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@0@0@Z ; std::operator==<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>
PUBLIC	??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::forward_iterator_tag>
PUBLIC	??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00@Z ; std::equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
PUBLIC	??$?8V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z ; std::operator==<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::end
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::size
PUBLIC	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
PUBLIC	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
PUBLIC	??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z ; std::_Iter_random<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CB_KI@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Myval
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CB_KI@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::operator*
PUBLIC	??$?8$$CB_KI@std@@YA_NABU?$pair@$$CB_KI@0@0@Z	; std::operator==<unsigned __int64 const ,unsigned int>
PUBLIC	??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::forward_iterator_tag>
PUBLIC	??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00@Z ; std::equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
PUBLIC	??$?8V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z ; std::operator==<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
PUBLIC	??_C@_04ECGLBLOI@?9?9?9?9?$AA@			; `string'
PUBLIC	??_C@_0BH@GGHGAMGD@?9?9?9?9Transaction?5Delay?5?$AA@ ; `string'
PUBLIC	??_C@_0BI@OFHLBMPE@?9?9?9?9Command?5Turnaround?5?$AA@ ; `string'
PUBLIC	??_C@_0BD@BJDMIPKA@?9?9?9?9Command?5Delay?5?$AA@ ; `string'
PUBLIC	??_C@_0BI@FKLHOOHD@?9?9?9?9CMD?5Execution?5Time?5?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CCJBOFFI@?9?9?9?9Transaction?5Latency?5?$AA@ ; `string'
PUBLIC	??_C@_0BE@PBEECLAB@?9?9?9?9Working?5Set?9?9?9?9?$AA@ ; `string'
PUBLIC	??_C@_0BC@FLEKEEG@?9?9?9?9Bandwidth?9?9?9?9?$AA@ ; `string'
PUBLIC	??_C@_0CO@FAIAOJGB@?9?9?9?9Average?5Transaction?5Latency?5@ ; `string'
PUBLIC	??_C@_0BM@FMOJPDMJ@?9?9?9?9Row?5Hit?1Miss?5Counts?9?9?9?9?$AA@ ; `string'
PUBLIC	??_C@_0BO@DIGAELIB@?9?9?9?9Cache?5Hit?1Miss?5Counts?9?9?9?9?$AA@ ; `string'
PUBLIC	??_C@_0BE@JGDENAHI@?9?9?9?9Utilization?9?9?9?9?$AA@ ; `string'
PUBLIC	??_C@_02KCKGHPCA@?$CJ?5?$AA@			; `string'
PUBLIC	??_C@_01ODHLEDKK@?$CI?$AA@			; `string'
PUBLIC	??_C@_0BK@JBNJPPAB@?9?9?9?9Latency?5Breakdown?9?9?9?9?$AA@ ; `string'
PUBLIC	??_C@_0BO@EIIIOAJG@?9?9?9?9tFAW?5Limited?5Commands?9?9?9?9?$AA@ ; `string'
EXTRN	_ldiv:PROC
;	COMDAT ??_C@_0BO@EIIIOAJG@?9?9?9?9tFAW?5Limited?5Commands?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0BO@EIIIOAJG@?9?9?9?9tFAW?5Limited?5Commands?9?9?9?9?$AA@ DB '----t'
	DB	'FAW Limited Commands----', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JBNJPPAB@?9?9?9?9Latency?5Breakdown?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0BK@JBNJPPAB@?9?9?9?9Latency?5Breakdown?9?9?9?9?$AA@ DB '----Latenc'
	DB	'y Breakdown----', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI?$AA@
CONST	SEGMENT
??_C@_01ODHLEDKK@?$CI?$AA@ DB '(', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KCKGHPCA@?$CJ?5?$AA@
CONST	SEGMENT
??_C@_02KCKGHPCA@?$CJ?5?$AA@ DB ') ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JGDENAHI@?9?9?9?9Utilization?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0BE@JGDENAHI@?9?9?9?9Utilization?9?9?9?9?$AA@ DB '----Utilization--'
	DB	'--', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DIGAELIB@?9?9?9?9Cache?5Hit?1Miss?5Counts?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0BO@DIGAELIB@?9?9?9?9Cache?5Hit?1Miss?5Counts?9?9?9?9?$AA@ DB '----'
	DB	'Cache Hit/Miss Counts----', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FMOJPDMJ@?9?9?9?9Row?5Hit?1Miss?5Counts?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0BM@FMOJPDMJ@?9?9?9?9Row?5Hit?1Miss?5Counts?9?9?9?9?$AA@ DB '----Ro'
	DB	'w Hit/Miss Counts----', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FAIAOJGB@?9?9?9?9Average?5Transaction?5Latency?5@
CONST	SEGMENT
??_C@_0CO@FAIAOJGB@?9?9?9?9Average?5Transaction?5Latency?5@ DB '----Avera'
	DB	'ge Transaction Latency Per PC Value ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FLEKEEG@?9?9?9?9Bandwidth?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0BC@FLEKEEG@?9?9?9?9Bandwidth?9?9?9?9?$AA@ DB '----Bandwidth----', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PBEECLAB@?9?9?9?9Working?5Set?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0BE@PBEECLAB@?9?9?9?9Working?5Set?9?9?9?9?$AA@ DB '----Working Set-'
	DB	'---', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CCJBOFFI@?9?9?9?9Transaction?5Latency?5?$AA@
CONST	SEGMENT
??_C@_0BJ@CCJBOFFI@?9?9?9?9Transaction?5Latency?5?$AA@ DB '----Transactio'
	DB	'n Latency ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FKLHOOHD@?9?9?9?9CMD?5Execution?5Time?5?$AA@
CONST	SEGMENT
??_C@_0BI@FKLHOOHD@?9?9?9?9CMD?5Execution?5Time?5?$AA@ DB '----CMD Execut'
	DB	'ion Time ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BJDMIPKA@?9?9?9?9Command?5Delay?5?$AA@
CONST	SEGMENT
??_C@_0BD@BJDMIPKA@?9?9?9?9Command?5Delay?5?$AA@ DB '----Command Delay ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OFHLBMPE@?9?9?9?9Command?5Turnaround?5?$AA@
CONST	SEGMENT
??_C@_0BI@OFHLBMPE@?9?9?9?9Command?5Turnaround?5?$AA@ DB '----Command Tur'
	DB	'naround ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GGHGAMGD@?9?9?9?9Transaction?5Delay?5?$AA@
CONST	SEGMENT
??_C@_0BH@GGHGAMGD@?9?9?9?9Transaction?5Delay?5?$AA@ DB '----Transaction '
	DB	'Delay ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04ECGLBLOI@?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_04ECGLBLOI@?9?9?9?9?$AA@ DB '----', 00H		; `string'
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEPBU?$pair@U?$pair@_K_K@std@@U12@@2@XZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEPBU?$pair@U?$pair@_K_K@std@@U12@@2@XZ PROC ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEPBU?$pair@U?$pair@_K_K@std@@U12@@2@XZ ENDP ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Checked_iterator_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEPBU?$pair@II@2@XZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEPBU?$pair@II@2@XZ PROC ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEPBU?$pair@II@2@XZ ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBU?$pair@U?$pair@_K_K@std@@U12@@0@AAV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBU?$pair@U?$pair@_K_K@std@@U12@@0@AAV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBU?$pair@U?$pair@_K_K@std@@U12@@0@AAV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBU?$pair@II@0@AAV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBU?$pair@II@0@AAV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBU?$pair@II@0@AAV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@PAU?$pair@U?$pair@_K_K@std@@U12@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@AAPAU?$pair@U?$pair@_K_K@std@@U12@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@PAU?$pair@U?$pair@_K_K@std@@U12@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@AAPAU?$pair@U?$pair@_K_K@std@@U12@@0@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@PAU?$pair@U?$pair@_K_K@std@@U12@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@AAPAU?$pair@U?$pair@_K_K@std@@U12@@0@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@YAPBU?$pair@U?$pair@_K_K@std@@U12@@0@AAV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@YAPBU?$pair@U?$pair@_K_K@std@@U12@@0@AAV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@YAPBU?$pair@U?$pair@_K_K@std@@U12@@0@AAV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@PAU?$pair@II@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@AAPAU?$pair@II@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@PAU?$pair@II@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@AAPAU?$pair@II@0@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::pair<unsigned int,unsigned int> *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@PAU?$pair@II@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@AAPAU?$pair@II@0@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::pair<unsigned int,unsigned int> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@YAPBU?$pair@II@0@AAV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@YAPBU?$pair@II@0@AAV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@YAPBU?$pair@II@0@AAV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBIPAIV?$allocator@I@std@@@std@@YAPAIPBI0PAIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PBIPAIV?$allocator@I@std@@@std@@YAPAIPBI0PAIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned int const *,unsigned int *,std::allocator<unsigned int> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PBIPAIV?$allocator@I@std@@@std@@YAPAIPBI0PAIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned int const *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@AAPAI@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@AAPAI@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@AAPAI@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<unsigned int *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<unsigned int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	push	esi
	npad	7
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAI@std@@YAPAIAAPAI@Z
_TEXT	SEGMENT
??$_Checked_base@PAI@std@@YAPAIAAPAI@Z PROC		; std::_Checked_base<unsigned int *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAI@std@@YAPAIAAPAI@Z ENDP		; std::_Checked_base<unsigned int *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEPA_JXZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEPA_JXZ PROC ; std::_Vector_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 305  : 		return (this->_Myptr);

	mov	eax, DWORD PTR [eax+4]

; 306  : 		}

	ret	0
?_Checked_iterator_base@?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEPA_JXZ ENDP ; std::_Vector_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEPBIXZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEPBIXZ PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEPBIXZ ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEPAIXZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEPAIXZ PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 305  : 		return (this->_Myptr);

	mov	eax, DWORD PTR [eax+4]

; 306  : 		}

	ret	0
?_Checked_iterator_base@?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEPAIXZ ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::forward_iterator_tag>, COMDAT
; __Last$ = ecx
; __Dest$ = eax

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	mov	edx, DWORD PTR __First$[esp-4]

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@2
	push	esi
	npad	7
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@2
	pop	esi
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAIII@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAIII@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@2
	push	esi
	npad	7
$LL9@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@2
	pop	esi
$LN7@Fill_n@2:

; 3255 : 	}

	ret	0
??$_Fill_n@PAIII@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z
_TEXT	SEGMENT
??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z PROC ; std::_Iter_cat<unsigned int *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ENDP ; std::_Iter_cat<unsigned int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<__int64,std::allocator<__int64> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<__int64,std::allocator<__int64> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?8$$CB_KI@std@@YA_NABU?$pair@$$CB_KI@0@0@Z
_TEXT	SEGMENT
??$?8$$CB_KI@std@@YA_NABU?$pair@$$CB_KI@0@0@Z PROC	; std::operator==<unsigned __int64 const ,unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 86   : 	return (_Left.first == _Right.first && _Left.second == _Right.second);

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@operator@3
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator@3
	mov	ecx, DWORD PTR [ecx+8]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator@3
	mov	eax, 1

; 87   : 	}

	ret	0
$LN3@operator@3:

; 86   : 	return (_Left.first == _Right.first && _Left.second == _Right.second);

	xor	eax, eax

; 87   : 	}

	ret	0
??$?8$$CB_KI@std@@YA_NABU?$pair@$$CB_KI@0@0@Z ENDP	; std::operator==<unsigned __int64 const ,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax
; __It$ = ecx

; 1147 : 		return _It;

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1148 : 	}

	ret	0
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax
; __It$ = ecx

; 1147 : 		return _It;

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1148 : 	}

	ret	0
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Equal@PBIPBIUforward_iterator_tag@std@@@std@@YA_NPBI00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Equal@PBIPBIUforward_iterator_tag@std@@@std@@YA_NPBI00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<unsigned int const *,unsigned int const *,std::forward_iterator_tag>, COMDAT
; __Last1$ = edx
; __First2$ = ecx

; 2991 : 	{	// compare [_First1, _Last1) to [First2, ...)

	mov	eax, DWORD PTR __First1$[esp-4]
	push	esi

; 2992 : 	for (; _First1 != _Last1; ++_First1, ++_First2)

	cmp	eax, edx
	je	SHORT $LN2@Equal
	npad	7
$LL4@Equal:

; 2993 : 		if (!(*_First1 == *_First2))

	mov	esi, DWORD PTR [eax]
	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN8@Equal
	add	eax, 4
	add	ecx, 4
	cmp	eax, edx
	jne	SHORT $LL4@Equal
$LN2@Equal:

; 2995 : 	return (true);

	mov	al, 1
	pop	esi

; 2996 : 	}

	ret	0
$LN8@Equal:

; 2994 : 			return (false);

	xor	al, al
	pop	esi

; 2996 : 	}

	ret	0
??$_Equal@PBIPBIUforward_iterator_tag@std@@@std@@YA_NPBI00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<unsigned int const *,unsigned int const *,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::forward_iterator_tag>, COMDAT
; __Last$ = edx
; __Dest$ = eax

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	mov	ecx, DWORD PTR __First$[esp-4]

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@2
	push	esi
	npad	7
$LL3@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@2
	pop	esi
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z PROC	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_
	push	esi
	npad	7
$LL13@unchecked_:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_
	pop	esi
$LN11@unchecked_:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ENDP	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PA_J@std@@YA?AU_Undefined_move_tag@0@ABQA_J@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PA_J@std@@YA?AU_Undefined_move_tag@0@ABQA_J@Z PROC ; std::_Move_cat<__int64 *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PA_J@std@@YA?AU_Undefined_move_tag@0@ABQA_J@Z ENDP ; std::_Move_cat<__int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<__int64,std::allocator<__int64> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPA_JAAV?$_Vector_iterator@_JV?$allocator@_J@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z PROC ; std::_Move_cat<unsigned int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ENDP ; std::_Move_cat<unsigned int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@std@@YAPAIAAV?$_Vector_iterator@IV?$allocator@I@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@@Z
_TEXT	SEGMENT
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@@Z PROC ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax
; __It$ = ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1166 : 	}

	ret	0
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@AAV120@@Z ENDP ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@@Z
_TEXT	SEGMENT
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@@Z PROC ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax
; __It$ = ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1166 : 	}

	ret	0
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@AAV120@@Z ENDP ; std::_Checked_base<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@0@Z
_TEXT	SEGMENT
??$_Iter_random@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z PROC ; std::_Move_cat<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ENDP ; std::_Move_cat<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$_Fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z PROC ; std::_Fill<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>, COMDAT
; __Last$ = edx
; __Val$ = ecx

; 3156 : 	{	// copy _Val through [_First, _Last)

	mov	eax, DWORD PTR __First$[esp-4]

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	cmp	eax, edx
	je	SHORT $LN1@Fill@3
	push	esi
	npad	7
$LL3@Fill@3:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL3@Fill@3
	pop	esi
$LN1@Fill@3:

; 3160 : 	}

	ret	0
??$_Fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z ENDP ; std::_Fill<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0@Z
_TEXT	SEGMENT
??$_Iter_random@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0@Z PROC ; std::_Iter_random<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0@Z ENDP ; std::_Iter_random<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@@Z
_TEXT	SEGMENT
??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@@Z PROC ; std::_Checked_base<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@AAPAU123@@Z ENDP ; std::_Checked_base<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@@Z PROC ; std::_Iter_cat<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@@Z ENDP ; std::_Iter_cat<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil
	push	esi
	npad	7
$LL15@Uninit_fil:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil
	pop	esi
$LN13@Uninit_fil:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CB_KI@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CB_KI@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64 const ,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CB_KI@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64 const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBII@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBII@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CBII@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z PROC ; std::fill<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>, COMDAT
; __Last$ = edx
; __Val$ = ecx

; 3186 : 	{	// copy _Val through [_First, _Last)

	mov	eax, DWORD PTR __First$[esp-4]

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	cmp	eax, edx
	je	SHORT $LN11@fill@2
	push	esi
	npad	7
$LL13@fill@2:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL13@fill@2
	pop	esi
$LN11@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z ENDP ; std::fill<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBII@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBII@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node><std::pair<unsigned int const ,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CBII@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node><std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CB_KI@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CB_KI@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node><std::pair<unsigned __int64 const ,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CB_KI@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node><std::pair<unsigned __int64 const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z
_TEXT	SEGMENT
??$?0U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBII@std@@@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBII@std@@@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *><std::pair<unsigned int const ,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CBII@std@@@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *><std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?8U?$pair@$$CBII@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBII@std@@@0@0@Z
_TEXT	SEGMENT
??$?8U?$pair@$$CBII@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBII@std@@@0@0@Z PROC ; std::operator==<std::pair<unsigned int const ,unsigned int>,std::pair<unsigned int const ,unsigned int> >, COMDAT

; 175  : 	return (true);

	mov	al, 1

; 176  : 	}

	ret	0
??$?8U?$pair@$$CBII@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBII@std@@@0@0@Z ENDP ; std::operator==<std::pair<unsigned int const ,unsigned int>,std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CB_KI@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CB_KI@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *><std::pair<unsigned __int64 const ,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CB_KI@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *><std::pair<unsigned __int64 const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *><std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@U?$pair@_K_K@std@@U12@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@U?$pair@_K_K@std@@U12@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@U?$pair@_K_K@std@@U12@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@II@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@II@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@II@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@II@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@II@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@II@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
??$?0V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT
??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned int>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0V?$vector@IV?$allocator@I@std@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0V?$vector@IV?$allocator@I@std@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0V?$vector@IV?$allocator@I@std@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::vector<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
??$?0V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBII@std@@@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBII@std@@@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position><std::pair<unsigned int const ,unsigned int> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@$$CBII@std@@@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position><std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBII@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBII@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned int const ,unsigned int> >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBII@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int const ,unsigned int> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@3
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@3:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?max_size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::max_size, COMDAT

; 625  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 626  : 		}

	ret	0
?max_size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KI@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Carg$ = 20						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KI@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node::_Node, COMDAT
; _this$ = eax
; __Val$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], edx
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	mov	cl, BYTE PTR __Carg$[esp-4]
	movq	QWORD PTR [eax+24], xmm0
	mov	BYTE PTR [eax+32], cl
	mov	BYTE PTR [eax+33], 0

; 39   : 			}

	ret	16					; 00000010H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KI@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Carg$ = 20						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node::_Node, COMDAT
; _this$ = eax
; __Val$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], edx
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR [eax+24], xmm0
	movq	xmm0, QWORD PTR [ecx+16]
	mov	cl, BYTE PTR __Carg$[esp-4]
	movq	QWORD PTR [eax+32], xmm0
	mov	BYTE PTR [eax+40], cl
	mov	BYTE PTR [eax+41], 0

; 39   : 			}

	ret	16					; 00000010H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ
_TEXT	SEGMENT
?_Mynode@?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<0>::_Mynode, COMDAT
; _this$ = eax

; 308  : 			return (_Ptr);

	mov	eax, DWORD PTR [eax+4]

; 309  : 			}

	ret	0
?_Mynode@?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<0>::_Mynode
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 134217727				; 07ffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@II@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@II@std@@@std@@QBEIXZ PROC	; std::allocator<std::pair<unsigned int,unsigned int> >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@II@std@@@std@@QBEIXZ ENDP	; std::allocator<std::pair<unsigned int,unsigned int> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CB_KI@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CB_KI@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 268435455				; 0fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CB_KI@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 178956970				; 0aaaaaaaH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QBEIXZ PROC ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QBEIXZ ENDP ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\functional
_TEXT	ENDS
;	COMDAT ??R?$hash@I@tr1@std@@QBEIABI@Z
_TEXT	SEGMENT
??R?$hash@I@tr1@std@@QBEIABI@Z PROC			; std::tr1::hash<unsigned int>::operator(), COMDAT
; __Keyval$ = eax

; 1265 : 		ldiv_t _Qrem = ldiv((long)(size_t)_Keyval, 127773);

	mov	ecx, DWORD PTR [eax]
	push	127773					; 0001f31dH
	push	ecx
	call	_ldiv

; 1266 : 
; 1267 : 		_Qrem.rem = 16807 * _Qrem.rem - 2836 * _Qrem.quot;

	imul	eax, 2836				; 00000b14H
	imul	edx, 16807				; 000041a7H
	add	esp, 8
	sub	edx, eax
	mov	eax, edx

; 1268 : 		if (_Qrem.rem < 0)

	jns	SHORT $LN1@operator@4

; 1269 : 			_Qrem.rem += 2147483647;

	add	eax, 2147483647				; 7fffffffH
$LN1@operator@4:

; 1270 : 		return ((size_t)_Qrem.rem);
; 1271 : 		}

	ret	0
??R?$hash@I@tr1@std@@QBEIABI@Z ENDP			; std::tr1::hash<unsigned int>::operator()
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 178956970				; 0aaaaaaaH

; 167  : 		}

	ret	0
?max_size@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QBEIXZ PROC ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 178956970				; 0aaaaaaaH

; 167  : 		}

	ret	0
?max_size@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 50   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax+8], cl

; 51   : 		}

	ret	4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 50   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax+8], cl

; 51   : 		}

	ret	4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@QAE@ABV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@QAE@ABV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@1@AB_N@Z PROC ; std::pair<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>,bool>::pair<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 50   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax+8], cl

; 51   : 		}

	ret	4
??0?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@QAE@ABV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@1@AB_N@Z ENDP ; std::pair<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>,bool>::pair<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>,bool>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ
_TEXT	SEGMENT
?_Mynode@?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Mynode, COMDAT
; _this$ = eax

; 308  : 			return (_Ptr);

	mov	eax, DWORD PTR [eax+4]

; 309  : 			}

	ret	0
?_Mynode@?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@3@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Mynode
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 134217727				; 07ffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QBEIXZ PROC ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 178956970				; 0aaaaaaaH

; 167  : 		}

	ret	0
?max_size@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::max_size, COMDAT

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 268435455				; 0fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::max_size, COMDAT

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 178956970				; 0aaaaaaaH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV01@@Z PROC ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEIXZ ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\functional
_TEXT	ENDS
;	COMDAT ??R?$equal_to@I@std@@QBE_NABI0@Z
_TEXT	SEGMENT
??R?$equal_to@I@std@@QBE_NABI0@Z PROC			; std::equal_to<unsigned int>::operator(), COMDAT
; __Left$ = eax
; __Right$ = edx

; 110  : 		return (_Left == _Right);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 111  : 		}

	ret	0
??R?$equal_to@I@std@@QBE_NABI0@Z ENDP			; std::equal_to<unsigned int>::operator()
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBEIABI@Z
_TEXT	SEGMENT
??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBEIABI@Z PROC ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::operator(), COMDAT
; __Keyval$ = eax

; 174  : 		{	// hash _Keyval to size_t value

	push	ecx

; 175  : 		return ((size_t)_Hashobj(_Keyval));

	mov	ecx, DWORD PTR [eax]
	push	127773					; 0001f31dH
	push	ecx
	call	_ldiv
	imul	eax, 2836				; 00000b14H
	imul	edx, 16807				; 000041a7H
	add	esp, 8
	sub	edx, eax
	mov	eax, edx
	jns	SHORT $LN3@operator@5
	add	eax, 2147483647				; 7fffffffH
$LN3@operator@5:
	pop	ecx

; 176  : 		}

	ret	0
??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBEIABI@Z ENDP ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::operator()
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int const ,unsigned int> >::allocator<std::pair<unsigned int const ,unsigned int> >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int const ,unsigned int> >::allocator<std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ
_TEXT	SEGMENT
?max_load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::max_load_factor, COMDAT
; _this$ = eax

; 513  : 		return (_Max_bucket_size);

	movss	xmm0, DWORD PTR [eax+68]

; 514  : 		}

	ret	0
?max_load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::max_load_factor
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ
_TEXT	SEGMENT
?bucket_count@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::bucket_count, COMDAT
; _this$ = eax

; 451  : 		return (_Maxidx);

	mov	eax, DWORD PTR [eax+64]

; 452  : 		}

	ret	0
?bucket_count@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::bucket_count
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 178956970				; 0aaaaaaaH

; 732  : 		}

	ret	0
?max_size@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 178956970				; 0aaaaaaaH

; 732  : 		}

	ret	0
?max_size@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@_K_K@std@@QAE@XZ
_TEXT	SEGMENT
??0?$pair@_K_K@std@@QAE@XZ PROC				; std::pair<unsigned __int64,unsigned __int64>::pair<unsigned __int64,unsigned __int64>, COMDAT
; _this$ = eax

; 45   : 		{	// construct from defaults

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 46   : 		}

	ret	0
??0?$pair@_K_K@std@@QAE@XZ ENDP				; std::pair<unsigned __int64,unsigned __int64>::pair<unsigned __int64,unsigned __int64>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@II@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@II@std@@@std@@QAE@ABV01@@Z PROC	; std::allocator<std::pair<unsigned int,unsigned int> >::allocator<std::pair<unsigned int,unsigned int> >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@U?$pair@II@std@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<std::pair<unsigned int,unsigned int> >::allocator<std::pair<unsigned int,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 178956970				; 0aaaaaaaH

; 732  : 		}

	ret	0
?max_size@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@I@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@I@std@@QBEIXZ PROC		; std::allocator<unsigned int>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@I@std@@QBEIXZ ENDP		; std::allocator<unsigned int>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@I@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@I@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@I@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::allocator<std::pair<unsigned __int64 const ,unsigned int> >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::allocator<std::pair<unsigned __int64 const ,unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@SAAB_KABU?$pair@$$CB_KI@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@SAAB_KABU?$pair@$$CB_KI@2@@Z PROC ; std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 65   : 		return (_Val.first);
; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@SAAB_KABU?$pair@$$CB_KI@2@@Z ENDP ; std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CB_KI@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CB_KI@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	add	eax, 16					; 00000010H

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CB_KI@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Myval
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@SAAB_KABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@SAAB_KABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z PROC ; std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 65   : 		return (_Val.first);
; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@SAAB_KABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ENDP ; std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEAAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z
_TEXT	SEGMENT
??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEAAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 3
	cmp	edi, eax
	jb	SHORT $LN1@operator@6
	call	__invalid_parameter_noinfo
$LN1@operator@6:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*8]

; 786  : 		}

	ret	0
??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEAAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBE_NABI0@Z
_TEXT	SEGMENT
??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBE_NABI0@Z PROC ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::operator(), COMDAT
; __Keyval1$ = eax
; __Keyval2$ = edx

; 180  : 		return (!_Keyeqobj(_Keyval1, _Keyval2));

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al

; 181  : 		}

	ret	0
??R?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QBE_NABI0@Z ENDP ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::operator()
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@SAABIABU?$pair@$$CBII@3@@Z
_TEXT	SEGMENT
?_Kfn@?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@SAABIABU?$pair@$$CBII@3@@Z PROC ; std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 71   : 		return (_Val.first);
; 72   : 		}

	ret	0
?_Kfn@?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@SAABIABU?$pair@$$CBII@3@@Z ENDP ; std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Hashval@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IBEIABI@Z
_TEXT	SEGMENT
?_Hashval@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IBEIABI@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hashval, COMDAT
; _this$ = esi
; __Keyval$ = eax

; 821  : 		{	// return hash value, masked and wrapped to current table size

	push	ecx

; 822  : 		size_type _Num = this->comp(_Keyval) & _Mask;

	mov	ecx, DWORD PTR [eax]
	push	127773					; 0001f31dH
	push	ecx
	call	_ldiv
	imul	edx, 16807				; 000041a7H
	imul	eax, 2836				; 00000b14H
	add	esp, 8
	sub	edx, eax
	jns	SHORT $LN6@Hashval
	add	edx, 2147483647				; 7fffffffH
$LN6@Hashval:
	mov	ecx, DWORD PTR [esi+60]
	mov	eax, ecx
	and	eax, edx

; 823  : 		if (_Maxidx <= _Num)

	cmp	DWORD PTR [esi+64], eax
	ja	SHORT $LN1@Hashval

; 824  : 			_Num -= (_Mask >> 1) + 1;

	shr	ecx, 1
	or	edx, -1
	sub	edx, ecx
	add	eax, edx
$LN1@Hashval:
	pop	ecx

; 825  : 		return (_Num);
; 826  : 		}

	ret	0
?_Hashval@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IBEIABI@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hashval
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CB_KI@std@@QAE@AB_KABI@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CB_KI@std@@QAE@AB_KABI@Z PROC		; std::pair<unsigned __int64 const ,unsigned int>::pair<unsigned __int64 const ,unsigned int>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 50   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax+8], ecx

; 51   : 		}

	ret	4
??0?$pair@$$CB_KI@std@@QAE@AB_KABI@Z ENDP		; std::pair<unsigned __int64 const ,unsigned int>::pair<unsigned __int64 const ,unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@QAE@AB_KABVDelayCounter@Statistics@DRAMsimII@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??0?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@QAE@AB_KABVDelayCounter@Statistics@DRAMsimII@@@Z PROC ; std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>, COMDAT
; __Val1$ = edx
; __Val2$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, DWORD PTR _this$[esp-4]
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], edx
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax+8], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR [eax+16], xmm0
	pop	esi

; 51   : 		}

	ret	4
??0?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@QAE@AB_KABVDelayCounter@Statistics@DRAMsimII@@@Z ENDP ; std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBII@std@@QAE@ABI0@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBII@std@@QAE@ABI0@Z PROC			; std::pair<unsigned int const ,unsigned int>::pair<unsigned int const ,unsigned int>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 50   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	4
??0?$pair@$$CBII@std@@QAE@ABI0@Z ENDP			; std::pair<unsigned int const ,unsigned int>::pair<unsigned int const ,unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$pair@U?$pair@_K_K@std@@U12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$pair@U?$pair@_K_K@std@@U12@@std@@QAE@XZ PROC	; std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >, COMDAT
; _this$ = eax

; 45   : 		{	// construct from defaults

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx

; 46   : 		}

	ret	0
??0?$pair@U?$pair@_K_K@std@@U12@@std@@QAE@XZ ENDP	; std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@II@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@II@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<unsigned int,unsigned int> >::allocator<std::pair<unsigned int,unsigned int> >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@II@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<unsigned int,unsigned int> >::allocator<std::pair<unsigned int,unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@II@std@@QAE@XZ
_TEXT	SEGMENT
??0?$pair@II@std@@QAE@XZ PROC				; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int>, COMDAT
; _this$ = eax

; 45   : 		{	// construct from defaults

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 46   : 		}

	ret	0
??0?$pair@II@std@@QAE@XZ ENDP				; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@I@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@I@std@@QAE@XZ PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@I@std@@QAE@XZ ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@4
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@4:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::allocator<std::pair<unsigned __int64 const ,unsigned int> >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CB_KI@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<unsigned __int64 const ,unsigned int> >::allocator<std::pair<unsigned __int64 const ,unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	add	eax, 16					; 00000010H

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\functional
_TEXT	ENDS
;	COMDAT ??R?$less@_K@std@@QBE_NAB_K0@Z
_TEXT	SEGMENT
??R?$less@_K@std@@QBE_NAB_K0@Z PROC			; std::less<unsigned __int64>::operator(), COMDAT
; __Left$ = ecx
; __Right$ = eax

; 143  : 		return (_Left < _Right);

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]
	ja	SHORT $LN3@operator@7
	jb	SHORT $LN5@operator@7
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN3@operator@7
$LN5@operator@7:
	mov	eax, 1

; 144  : 		}

	ret	0
$LN3@operator@7:

; 143  : 		return (_Left < _Right);

	xor	eax, eax

; 144  : 		}

	ret	0
??R?$less@_K@std@@QBE_NAB_K0@Z ENDP			; std::less<unsigned __int64>::operator()
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	add	eax, 16					; 00000010H

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Myval
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	add	eax, 16					; 00000010H

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@KAAB_KPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::size, COMDAT
; _this$ = eax

; 620  : 		return (_Mysize);

	mov	eax, DWORD PTR [eax+24]

; 621  : 		}

	ret	0
?size@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@KAAAU?$pair@$$CBII@2@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@@Z
_TEXT	SEGMENT
?_Myval@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@KAAAU?$pair@$$CBII@2@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Myval, COMDAT
; __Pnode$ = eax

; 125  : 		return ((_Vref)(*_Pnode)._Myval);

	add	eax, 8

; 126  : 		}

	ret	0
?_Myval@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@KAAAU?$pair@$$CBII@2@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Myval
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??0?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QAE@XZ
_TEXT	SEGMENT
??0?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QAE@XZ PROC ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >, COMDAT
; _this$ = eax

; 160  : 		{	// construct with default hasher and equality comparator
; 161  : 		}

	ret	0
??0?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@QAE@XZ ENDP ; stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<unsigned int const ,unsigned int> >::allocator<std::pair<unsigned int const ,unsigned int> >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBII@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<unsigned int const ,unsigned int> >::allocator<std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAE@XZ PROC ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::size, COMDAT
; _this$ = eax

; 726  : 		return (_Mylast - _Myfirst);

	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEAAU?$pair@II@1@I@Z
_TEXT	SEGMENT
??A?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEAAU?$pair@II@1@I@Z PROC ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 3
	cmp	edi, eax
	jb	SHORT $LN1@operator@8
	call	__invalid_parameter_noinfo
$LN1@operator@8:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*8]

; 786  : 		}

	ret	0
??A?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEAAU?$pair@II@1@I@Z ENDP ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::size, COMDAT
; _this$ = eax

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [eax+28]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::size, COMDAT
; _this$ = eax

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [eax+28]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?size@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::size, COMDAT
; _this$ = eax

; 417  : 		return (_List.size());

	mov	eax, DWORD PTR [eax+32]

; 418  : 		}

	ret	0
?size@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEIXZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEAAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@I@Z
_TEXT	SEGMENT
??A?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEAAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@I@Z PROC ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN1@operator@9
	call	__invalid_parameter_noinfo
$LN1@operator@9:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	edx, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	eax, DWORD PTR [edx+ecx*8]

; 786  : 		}

	ret	0
??A?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEAAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@I@Z ENDP ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator[]
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.h
_TEXT	ENDS
;	COMDAT ?getRowBufferAccesses@Statistics@DRAMsimII@@QBEABV?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@XZ
_TEXT	SEGMENT
?getRowBufferAccesses@Statistics@DRAMsimII@@QBEABV?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@XZ PROC ; DRAMsimII::Statistics::getRowBufferAccesses, COMDAT
; _this$ = eax

; 160  : 		const std::vector<std::vector<std::pair<unsigned,unsigned> > > &getRowBufferAccesses() const { return rowBufferAccesses; }

	add	eax, 56					; 00000038H
	ret	0
?getRowBufferAccesses@Statistics@DRAMsimII@@QBEABV?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@XZ ENDP ; DRAMsimII::Statistics::getRowBufferAccesses
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8DelayCounter@Statistics@DRAMsimII@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8DelayCounter@Statistics@DRAMsimII@@QBE_NABV012@@Z PROC ; DRAMsimII::Statistics::DelayCounter::operator==, COMDAT
; _this$ = ecx
; _right$ = eax

; 91   : 				  return accumulatedLatency == right.accumulatedLatency &&
; 92   : 					  count == right.count;

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@operator@10
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator@10
	mov	ecx, DWORD PTR [ecx+8]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator@10
	mov	eax, 1

; 93   : 			  }

	ret	0
$LN3@operator@10:

; 91   : 				  return accumulatedLatency == right.accumulatedLatency &&
; 92   : 					  count == right.count;

	xor	eax, eax

; 93   : 			  }

	ret	0
??8DelayCounter@Statistics@DRAMsimII@@QBE_NABV012@@Z ENDP ; DRAMsimII::Statistics::DelayCounter::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCount@DelayCounter@Statistics@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getCount@DelayCounter@Statistics@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::Statistics::DelayCounter::getCount, COMDAT
; _this$ = eax

; 87   : 			  unsigned getCount() const { return count; }

	mov	eax, DWORD PTR [eax+8]
	ret	0
?getCount@DelayCounter@Statistics@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::Statistics::DelayCounter::getCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getAccumulatedLatency@DelayCounter@Statistics@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getAccumulatedLatency@DelayCounter@Statistics@DRAMsimII@@QBE_JXZ PROC ; DRAMsimII::Statistics::DelayCounter::getAccumulatedLatency, COMDAT
; _this$ = ecx

; 86   : 			  tick getAccumulatedLatency() const { return accumulatedLatency; }

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]
	ret	0
?getAccumulatedLatency@DelayCounter@Statistics@DRAMsimII@@QBE_JXZ ENDP ; DRAMsimII::Statistics::DelayCounter::getAccumulatedLatency
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?delay@DelayCounter@Statistics@DRAMsimII@@QAEXI@Z
_TEXT	SEGMENT
?delay@DelayCounter@Statistics@DRAMsimII@@QAEXI@Z PROC	; DRAMsimII::Statistics::DelayCounter::delay, COMDAT
; _this$ = eax
; _value$ = ecx

; 83   : 				  accumulatedLatency += value;

	add	DWORD PTR [eax], ecx
	adc	DWORD PTR [eax+4], 0

; 84   : 			  }

	ret	0
?delay@DelayCounter@Statistics@DRAMsimII@@QAEXI@Z ENDP	; DRAMsimII::Statistics::DelayCounter::delay
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?countUp@DelayCounter@Statistics@DRAMsimII@@QAEXXZ
_TEXT	SEGMENT
?countUp@DelayCounter@Statistics@DRAMsimII@@QAEXXZ PROC	; DRAMsimII::Statistics::DelayCounter::countUp, COMDAT
; _this$ = eax

; 78   : 				  count++;

	inc	DWORD PTR [eax+8]

; 79   : 			  }

	ret	0
?countUp@DelayCounter@Statistics@DRAMsimII@@QAEXXZ ENDP	; DRAMsimII::Statistics::DelayCounter::countUp
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0DelayCounter@Statistics@DRAMsimII@@QAE@XZ
_TEXT	SEGMENT
??0DelayCounter@Statistics@DRAMsimII@@QAE@XZ PROC	; DRAMsimII::Statistics::DelayCounter::DelayCounter, COMDAT
; _this$ = eax

; 74   : 				  count(0) {}

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0DelayCounter@Statistics@DRAMsimII@@QAE@XZ ENDP	; DRAMsimII::Statistics::DelayCounter::DelayCounter
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\command.h
_TEXT	ENDS
;	COMDAT ?isHit@Command@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isHit@Command@DRAMsimII@@QBE_NXZ PROC			; DRAMsimII::Command::isHit, COMDAT
; _this$ = eax

; 90   : 		bool isHit() const { return hit; }

	mov	al, BYTE PTR [eax+92]
	ret	0
?isHit@Command@DRAMsimII@@QBE_NXZ ENDP			; DRAMsimII::Command::isHit
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\transaction.h
_TEXT	ENDS
;	COMDAT ?isWrite@Transaction@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isWrite@Transaction@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Transaction::isWrite, COMDAT
; _this$ = ecx

; 67   : 		bool isWrite() const { return (type == WRITE_TRANSACTION); }

	xor	eax, eax
	cmp	DWORD PTR [ecx+80], 1
	sete	al
	ret	0
?isWrite@Transaction@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Transaction::isWrite
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLength@Transaction@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getLength@Transaction@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Transaction::getLength, COMDAT
; _this$ = eax

; 63   : 		unsigned getLength() const { return length; }								///< get the number of bytes requested

	mov	eax, DWORD PTR [eax+84]
	ret	0
?getLength@Transaction@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Transaction::getLength
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getProgramCounter@Transaction@DRAMsimII@@QBE_KXZ
_TEXT	SEGMENT
?getProgramCounter@Transaction@DRAMsimII@@QBE_KXZ PROC	; DRAMsimII::Transaction::getProgramCounter, COMDAT
; _this$ = ecx

; 62   : 		PhysicalAddress getProgramCounter() const { return PC; }					///< get the program counter for this transaction

	mov	eax, DWORD PTR [ecx+96]
	mov	edx, DWORD PTR [ecx+100]
	ret	0
?getProgramCounter@Transaction@DRAMsimII@@QBE_KXZ ENDP	; DRAMsimII::Transaction::getProgramCounter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getDecodeDelay@Transaction@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getDecodeDelay@Transaction@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Transaction::getDecodeDelay, COMDAT
; _this$ = ecx

; 61   : 		tick getDecodeDelay() const { return decodeTime - enqueueTime; }			///< get the time it took before this transaction was decoded

	mov	eax, DWORD PTR [ecx+88]
	sub	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR [ecx+92]
	sbb	edx, DWORD PTR [ecx+20]
	ret	0
?getDecodeDelay@Transaction@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Transaction::getDecodeDelay
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\event.h
_TEXT	ENDS
;	COMDAT ?getDelayTime@Event@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getDelayTime@Event@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Event::getDelayTime, COMDAT
; _this$ = ecx

; 93   : 		tick getDelayTime() const { return startTime - enqueueTime; }

	mov	eax, DWORD PTR [ecx+24]
	sub	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR [ecx+28]
	sbb	edx, DWORD PTR [ecx+20]
	ret	0
?getDelayTime@Event@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Event::getDelayTime
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.h
_TEXT	ENDS
;	COMDAT ?getChannel@Address@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getChannel@Address@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Address::getChannel, COMDAT
; _this$ = eax

; 86   : 		unsigned getChannel() const { return channel; }

	mov	eax, DWORD PTR [eax+16]
	ret	0
?getChannel@Address@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Address::getChannel
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >, COMDAT
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN20@unchecked_@20
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN20@unchecked_@20:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@1@0PAI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Ucopy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@1@0PAI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT
; __Ptr$ = edx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN22@Ucopy@5
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Ucopy@5:

; 1142 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Ucopy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@1@0PAI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@21
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@21:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?8$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@YA_NABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@0@0@Z
_TEXT	SEGMENT
??$?8$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@YA_NABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@0@0@Z PROC ; std::operator==<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 86   : 	return (_Left.first == _Right.first && _Left.second == _Right.second);

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@operator@46
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator@46
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator@46
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR [eax+12]
	jne	SHORT $LN3@operator@46
	mov	ecx, DWORD PTR [ecx+16]
	cmp	ecx, DWORD PTR [eax+16]
	jne	SHORT $LN3@operator@46
	mov	eax, 1

; 87   : 	}

	ret	0
$LN3@operator@46:

; 86   : 	return (_Left.first == _Right.first && _Left.second == _Right.second);

	xor	eax, eax

; 87   : 	}

	ret	0
??$?8$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@YA_NABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@0@0@Z ENDP ; std::operator==<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@U?$pair@U?$pair@_K_K@std@@U12@@std@@U12@@std@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@0@ABU10@@Z
_TEXT	SEGMENT
??$_Construct@U?$pair@U?$pair@_K_K@std@@U12@@std@@U12@@std@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@0@ABU10@@Z PROC ; std::_Construct<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@4
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR [eax+8], xmm0
	movq	xmm0, QWORD PTR [ecx+16]
	movq	QWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [ecx+24]
	movq	QWORD PTR [eax+24], xmm0
$LN3@Construct@4:

; 53   : 	}

	ret	0
??$_Construct@U?$pair@U?$pair@_K_K@std@@U12@@std@@U12@@std@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@0@ABU10@@Z ENDP ; std::_Construct<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Construct@U?$pair@II@std@@U12@@std@@YAXPAU?$pair@II@0@ABU10@@Z
_TEXT	SEGMENT
??$_Construct@U?$pair@II@std@@U12@@std@@YAXPAU?$pair@II@0@ABU10@@Z PROC ; std::_Construct<std::pair<unsigned int,unsigned int>,std::pair<unsigned int,unsigned int> >, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@5
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct@5:

; 53   : 	}

	ret	0
??$_Construct@U?$pair@II@std@@U12@@std@@YAXPAU?$pair@II@0@ABU10@@Z ENDP ; std::_Construct<std::pair<unsigned int,unsigned int>,std::pair<unsigned int,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Construct@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU123@@Z
_TEXT	SEGMENT
??$_Construct@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU123@@Z PROC ; std::_Construct<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@6
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct@6:

; 53   : 	}

	ret	0
??$_Construct@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU123@@Z ENDP ; std::_Construct<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; __First$ = esi
; __Last$ = ecx
; __Dest$ = edx

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, ecx
	sub	eax, esi
	sar	eax, 3
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	edi
	mov	edi, eax
	mov	eax, edx
	sub	eax, edi

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	cmp	esi, ecx
	je	SHORT $LN7@Copy_backw@5
	sub	edx, ecx
	npad	6
$LL8@Copy_backw@5:
	mov	edi, DWORD PTR [ecx-8]
	sub	ecx, 8
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	cmp	ecx, esi
	jne	SHORT $LL8@Copy_backw@5
$LN7@Copy_backw@5:
	pop	edi

; 2690 : 	return _Result;
; 2691 : 	}

	ret	0
??$_Copy_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Uninit_mov
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Uninit_mov:
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAEXPAU?$pair@U?$pair@_K_K@std@@U12@@2@ABU32@@Z
_TEXT	SEGMENT
?construct@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAEXPAU?$pair@U?$pair@_K_K@std@@U12@@2@ABU32@@Z PROC ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@4
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR [eax+8], xmm0
	movq	xmm0, QWORD PTR [ecx+16]
	movq	QWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [ecx+24]
	movq	QWORD PTR [eax+24], xmm0
$LN5@construct@4:

; 156  : 		}

	ret	0
?construct@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAEXPAU?$pair@U?$pair@_K_K@std@@U12@@2@ABU32@@Z ENDP ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::construct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@II@std@@@std@@QAEXPAU?$pair@II@2@ABU32@@Z
_TEXT	SEGMENT
?construct@?$allocator@U?$pair@II@std@@@std@@QAEXPAU?$pair@II@2@ABU32@@Z PROC ; std::allocator<std::pair<unsigned int,unsigned int> >::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@5
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct@5:

; 156  : 		}

	ret	0
?construct@?$allocator@U?$pair@II@std@@@std@@QAEXPAU?$pair@II@2@ABU32@@Z ENDP ; std::allocator<std::pair<unsigned int,unsigned int> >::construct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU345@@Z
_TEXT	SEGMENT
?construct@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU345@@Z PROC ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@6
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct@6:

; 156  : 		}

	ret	0
?construct@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@ABU345@@Z ENDP ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::construct
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	mov	eax, DWORD PTR __First$[esp-4]

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@6
	push	esi
	npad	7
$LL6@Uninit_fil@6:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@6
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_fil@6:
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@6
	pop	esi
$LN4@Uninit_fil@6:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = esi
; __Last$ = ecx
; __Dest$ = edx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, ecx
	sub	eax, esi
	sar	eax, 3
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	edi
	mov	edi, eax
	mov	eax, edx
	sub	eax, edi
	cmp	esi, ecx
	je	SHORT $LN11@Move_backw@3
	sub	edx, ecx
	npad	6
$LL12@Move_backw@3:
	mov	edi, DWORD PTR [ecx-8]
	sub	ecx, 8
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	cmp	ecx, esi
	jne	SHORT $LL12@Move_backw@3
$LN11@Move_backw@3:
	pop	edi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; __First$ = ecx
; __Last$ = esi
; __Dest$ = edx

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	lea	eax, DWORD PTR [edx+eax*8]

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	cmp	ecx, esi
	je	SHORT $LN7@Copy_opt@5
	sub	edx, ecx
	push	edi
$LL9@Copy_opt@5:
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	add	ecx, 8
	cmp	ecx, esi
	jne	SHORT $LL9@Copy_opt@5
	pop	edi
$LN7@Copy_opt@5:

; 2486 : 	return _Result;
; 2487 : 	}

	ret	0
??$_Copy_opt@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU?$pair@U?$pair@_K_K@std@@U12@@std@@IU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@0@IABU10@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAU?$pair@U?$pair@_K_K@std@@U12@@std@@IU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@0@IABU10@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,unsigned int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	mov	eax, DWORD PTR __First$[esp-4]

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@7
$LL6@Uninit_fil@7:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@7
	movq	xmm0, QWORD PTR [edx]
	movq	QWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [edx+8]
	movq	QWORD PTR [eax+8], xmm0
	movq	xmm0, QWORD PTR [edx+16]
	movq	QWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [edx+24]
	movq	QWORD PTR [eax+24], xmm0
$LN5@Uninit_fil@7:
	dec	ecx
	add	eax, 32					; 00000020H
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@7
$LN4@Uninit_fil@7:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAU?$pair@U?$pair@_K_K@std@@U12@@std@@IU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@0@IABU10@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,unsigned int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU?$pair@II@std@@IU12@V?$allocator@U?$pair@II@std@@@2@@std@@YAXPAU?$pair@II@0@IABU10@AAV?$allocator@U?$pair@II@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAU?$pair@II@std@@IU12@V?$allocator@U?$pair@II@std@@@2@@std@@YAXPAU?$pair@II@0@IABU10@AAV?$allocator@U?$pair@II@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::pair<unsigned int,unsigned int> *,unsigned int,std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	mov	eax, DWORD PTR __First$[esp-4]

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@8
	push	esi
	npad	7
$LL6@Uninit_fil@8:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@8
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_fil@8:
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@8
	pop	esi
$LN4@Uninit_fil@8:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAU?$pair@II@std@@IU12@V?$allocator@U?$pair@II@std@@@2@@std@@YAXPAU?$pair@II@0@IABU10@AAV?$allocator@U?$pair@II@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::pair<unsigned int,unsigned int> *,unsigned int,std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >, COMDAT
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN34@Unchecked_@3
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN34@Unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z
_TEXT	SEGMENT
??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 3
	cmp	edi, eax
	jb	SHORT $LN1@operator@47
	call	__invalid_parameter_noinfo
$LN1@operator@47:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*8]

; 771  : 		}

	ret	0
??A?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBEABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@IABU120@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z
_TEXT	SEGMENT
$T334636 = -4						; size = 1
__Cat$334640 = -4					; size = 1
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
??$unchecked_uninitialized_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@IABU120@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; __First$ = edx

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	BYTE PTR $T334636[esp+4], 0
	mov	eax, DWORD PTR $T334636[esp+4]
	mov	ecx, DWORD PTR __Cat$334640[esp+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Val$[esp+12]
	call	??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 943  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$unchecked_uninitialized_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@IABU120@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@U?$pair@$$CBII@std@@U12@@std@@YAXPAU?$pair@$$CBII@0@ABU10@@Z
_TEXT	SEGMENT
??$_Construct@U?$pair@$$CBII@std@@U12@@std@@YAXPAU?$pair@$$CBII@0@ABU10@@Z PROC ; std::_Construct<std::pair<unsigned int const ,unsigned int>,std::pair<unsigned int const ,unsigned int> >, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@7
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct@7:

; 53   : 	}

	ret	0
??$_Construct@U?$pair@$$CBII@std@@U12@@std@@YAXPAU?$pair@$$CBII@0@ABU10@@Z ENDP ; std::_Construct<std::pair<unsigned int const ,unsigned int>,std::pair<unsigned int const ,unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z PROC ; stdext::_Unchecked_move_backward<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; __First$ = esi
; __Last$ = ecx
; __Dest$ = edx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, ecx
	sub	eax, esi
	sar	eax, 3
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	edi
	mov	edi, eax
	mov	eax, edx
	sub	eax, edi
	cmp	esi, ecx
	je	SHORT $LN25@Unchecked_@4
	sub	edx, ecx
	npad	6
$LL26@Unchecked_@4:
	mov	edi, DWORD PTR [ecx-8]
	sub	ecx, 8
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	cmp	ecx, esi
	jne	SHORT $LL26@Unchecked_@4
$LN25@Unchecked_@4:
	pop	edi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z ENDP ; stdext::_Unchecked_move_backward<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@8
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@8:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T334781 = -16						; size = 4
$T334773 = -12						; size = 12
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 40					; 00000028H
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T334781[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T334773[esp+20]
	mov	DWORD PTR $T334781[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T334773[esp+20]
	push	ecx
	mov	DWORD PTR $T334773[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@4:
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*4]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@4:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@9
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@9:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T334804 = -16						; size = 4
$T334796 = -12						; size = 12
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 48					; 00000030H
	jae	SHORT $LN1@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T334804[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T334796[esp+20]
	mov	DWORD PTR $T334804[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T334796[esp+20]
	push	ecx
	mov	DWORD PTR $T334796[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@5:
$LN1@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	shl	edx, 4
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@5:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IPAU123@@Z
_TEXT	SEGMENT
$T334818 = -16						; size = 4
$T334810 = -12						; size = 12
??$_Allocate@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IPAU123@@Z PROC ; std::_Allocate<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 8
	jae	SHORT $LN1@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T334818[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T334810[esp+20]
	mov	DWORD PTR $T334818[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T334810[esp+20]
	push	ecx
	mov	DWORD PTR $T334810[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@6:
$LN1@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@6:
??$_Allocate@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IPAU123@@Z ENDP ; std::_Allocate<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z PROC ; stdext::unchecked_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; __First$ = ecx
; __Last$ = esi
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	lea	eax, DWORD PTR [edx+eax*8]
	cmp	ecx, esi
	je	SHORT $LN21@unchecked_@22
	sub	edx, ecx
	push	edi
$LL23@unchecked_@22:
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	add	ecx, 8
	cmp	ecx, esi
	jne	SHORT $LL23@unchecked_@22
	pop	edi
$LN21@unchecked_@22:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z ENDP ; stdext::unchecked_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@ABQAU120@@Z PROC ; std::_Construct<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *,std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@10
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@10:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *,std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@IPAU120@@Z
_TEXT	SEGMENT
$T334920 = -16						; size = 4
$T334912 = -12						; size = 12
??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@IPAU120@@Z PROC ; std::_Allocate<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN1@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T334920[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T334912[esp+20]
	mov	DWORD PTR $T334920[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T334912[esp+20]
	push	ecx
	mov	DWORD PTR $T334912[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@7:
$LN1@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@7:
??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@0@IPAU10@@Z
_TEXT	SEGMENT
$T334934 = -16						; size = 4
$T334926 = -12						; size = 12
??$_Allocate@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@0@IPAU10@@Z PROC ; std::_Allocate<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN1@Allocate@8

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T334934[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T334926[esp+20]
	mov	DWORD PTR $T334934[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T334926[esp+20]
	push	ecx
	mov	DWORD PTR $T334926[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@8:
$LN1@Allocate@8:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	shl	ecx, 5
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@8:
??$_Allocate@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U?$pair@II@std@@@std@@YAPAU?$pair@II@0@IPAU10@@Z
_TEXT	SEGMENT
$T334948 = -16						; size = 4
$T334940 = -12						; size = 12
??$_Allocate@U?$pair@II@std@@@std@@YAPAU?$pair@II@0@IPAU10@@Z PROC ; std::_Allocate<std::pair<unsigned int,unsigned int> >, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 8
	jae	SHORT $LN1@Allocate@9

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T334948[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T334940[esp+20]
	mov	DWORD PTR $T334948[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T334940[esp+20]
	push	ecx
	mov	DWORD PTR $T334940[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@9:
$LN1@Allocate@9:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@9:
??$_Allocate@U?$pair@II@std@@@std@@YAPAU?$pair@II@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<unsigned int,unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$vector@IV?$allocator@I@std@@@std@@@std@@YAPAV?$vector@IV?$allocator@I@std@@@0@IPAV10@@Z
_TEXT	SEGMENT
$T334962 = -16						; size = 4
$T334954 = -12						; size = 12
??$_Allocate@V?$vector@IV?$allocator@I@std@@@std@@@std@@YAPAV?$vector@IV?$allocator@I@std@@@0@IPAV10@@Z PROC ; std::_Allocate<std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN1@Allocate@10

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T334962[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T334954[esp+20]
	mov	DWORD PTR $T334962[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T334954[esp+20]
	push	ecx
	mov	DWORD PTR $T334954[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@10:
$LN1@Allocate@10:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@10:
??$_Allocate@V?$vector@IV?$allocator@I@std@@@std@@@std@@YAPAV?$vector@IV?$allocator@I@std@@@0@IPAV10@@Z ENDP ; std::_Allocate<std::vector<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@YAPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IPAV10@@Z
_TEXT	SEGMENT
$T334976 = -16						; size = 4
$T334968 = -12						; size = 12
??$_Allocate@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@YAPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IPAV10@@Z PROC ; std::_Allocate<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN1@Allocate@11

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T334976[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T334968[esp+20]
	mov	DWORD PTR $T334976[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T334968[esp+20]
	push	ecx
	mov	DWORD PTR $T334968[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@11:
$LN1@Allocate@11:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@11:
??$_Allocate@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@YAPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAU?$pair@U?$pair@_K_K@std@@U12@@std@@IU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@stdext@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@std@@IABU12@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@Z
_TEXT	SEGMENT
$T334982 = -4						; size = 1
__Cat$334987 = -4					; size = 1
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
??$unchecked_uninitialized_fill_n@PAU?$pair@U?$pair@_K_K@std@@U12@@std@@IU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@stdext@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@std@@IABU12@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,unsigned int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >, COMDAT
; __First$ = edx

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	BYTE PTR $T334982[esp+4], 0
	mov	eax, DWORD PTR $T334982[esp+4]
	mov	ecx, DWORD PTR __Cat$334987[esp+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Val$[esp+12]
	call	??$_Uninit_fill_n@PAU?$pair@U?$pair@_K_K@std@@U12@@std@@IU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@0@IABU10@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,unsigned int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >

; 943  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$unchecked_uninitialized_fill_n@PAU?$pair@U?$pair@_K_K@std@@U12@@std@@IU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@stdext@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@std@@IABU12@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,unsigned int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAU?$pair@II@std@@IU12@V?$allocator@U?$pair@II@std@@@2@@stdext@@YAXPAU?$pair@II@std@@IABU12@AAV?$allocator@U?$pair@II@std@@@2@@Z
_TEXT	SEGMENT
$T334991 = -4						; size = 1
__Cat$334996 = -4					; size = 1
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
??$unchecked_uninitialized_fill_n@PAU?$pair@II@std@@IU12@V?$allocator@U?$pair@II@std@@@2@@stdext@@YAXPAU?$pair@II@std@@IABU12@AAV?$allocator@U?$pair@II@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned int,unsigned int> *,unsigned int,std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >, COMDAT
; __First$ = edx

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	BYTE PTR $T334991[esp+4], 0
	mov	eax, DWORD PTR $T334991[esp+4]
	mov	ecx, DWORD PTR __Cat$334996[esp+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Val$[esp+12]
	call	??$_Uninit_fill_n@PAU?$pair@II@std@@IU12@V?$allocator@U?$pair@II@std@@@2@@std@@YAXPAU?$pair@II@0@IABU10@AAV?$allocator@U?$pair@II@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned int,unsigned int> *,unsigned int,std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >

; 943  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$unchecked_uninitialized_fill_n@PAU?$pair@II@std@@IU12@V?$allocator@U?$pair@II@std@@@2@@stdext@@YAXPAU?$pair@II@std@@IABU12@AAV?$allocator@U?$pair@II@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned int,unsigned int> *,unsigned int,std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@YAPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IPAV10@@Z
_TEXT	SEGMENT
$T335008 = -16						; size = 4
$T335000 = -12						; size = 12
??$_Allocate@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@YAPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IPAV10@@Z PROC ; std::_Allocate<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN1@Allocate@12

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T335008[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T335000[esp+20]
	mov	DWORD PTR $T335008[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T335000[esp+20]
	push	ecx
	mov	DWORD PTR $T335000[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@12:
$LN1@Allocate@12:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@12:
??$_Allocate@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@YAPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@23
	push	esi
	npad	7
$LL19@unchecked_@23:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@23
	pop	esi
$LN17@unchecked_@23:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@I@std@@YAPAIIPAI@Z
_TEXT	SEGMENT
$T335125 = -16						; size = 4
$T335117 = -12						; size = 12
??$_Allocate@I@std@@YAPAIIPAI@Z PROC			; std::_Allocate<unsigned int>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@13

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T335125[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T335117[esp+20]
	mov	DWORD PTR $T335125[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T335117[esp+20]
	push	ecx
	mov	DWORD PTR $T335117[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@13:
$LN1@Allocate@13:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@13:
??$_Allocate@I@std@@YAPAIIPAI@Z ENDP			; std::_Allocate<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_iterator@IV?$allocator@I@std@@@1@0PAI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Umove@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_iterator@IV?$allocator@I@std@@@1@0PAI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN36@Umove
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN36@Umove:

; 1149 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Umove@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_iterator@IV?$allocator@I@std@@@1@0PAI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &>::_Ranit<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &>::_Ranit<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@48
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@48
$LN1@operator@48:
	call	__invalid_parameter_noinfo
$LN2@operator@48:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@2
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@2
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@2
$LN1@Vector_con@2:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@2:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU345@IABU345@@Z
_TEXT	SEGMENT
$T335366 = -4						; size = 1
__Cat$335370 = -4					; size = 1
?_Ufill@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU345@IABU345@@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	BYTE PTR $T335366[esp+4], 0
	mov	eax, DWORD PTR $T335366[esp+4]
	mov	ecx, DWORD PTR __Cat$335370[esp+4]
	push	eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]

; 1256 : 		}

	add	esp, 16					; 00000010H
	ret	0
?_Ufill@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU345@IABU345@@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@$$CBII@std@@@std@@QAEXPAU?$pair@$$CBII@2@ABU32@@Z
_TEXT	SEGMENT
?construct@?$allocator@U?$pair@$$CBII@std@@@std@@QAEXPAU?$pair@$$CBII@2@ABU32@@Z PROC ; std::allocator<std::pair<unsigned int const ,unsigned int> >::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@7
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct@7:

; 156  : 		}

	ret	0
?construct@?$allocator@U?$pair@$$CBII@std@@@std@@QAEXPAU?$pair@$$CBII@2@ABU32@@Z ENDP ; std::allocator<std::pair<unsigned int const ,unsigned int> >::construct
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@49
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@49
$LN3@operator@49:
	call	__invalid_parameter_noinfo
$LN4@operator@49:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@2
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@2
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@2
$LN3@Vector_ite@2:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@2:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_iterator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN5@Make_iter@3
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN5@Make_iter@3
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN6@Make_iter@3
$LN5@Make_iter@3:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN6@Make_iter@3:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QBE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@8
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@8:

; 156  : 		}

	ret	0
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>::allocate, COMDAT

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	ecx, 1
	jmp	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@9
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@9:

; 156  : 		}

	ret	0
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>::allocate, COMDAT

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	ret	0
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z
_TEXT	SEGMENT
$T335576 = -16						; size = 4
$T335578 = -12						; size = 12
?allocate@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z PROC ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@3
	xor	ecx, ecx
$LN3@allocate@3:
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@3:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN3@allocate@3
	lea	eax, DWORD PTR $T335576[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T335578[esp+20]
	mov	DWORD PTR $T335576[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T335578[esp+20]
	push	ecx
	mov	DWORD PTR $T335578[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@3:
$LN11@allocate@3:
	int	3
?allocate@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ENDP ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@0@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::erase, COMDAT
; _this$ = edi

; 1028 : 		{	// erase [_First, _Last)

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp
	push	esi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	DWORD PTR [ebx], 0
	test	edi, edi
	je	SHORT $LN8@erase@2
	mov	eax, DWORD PTR __First_arg$[esp+12]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN8@erase@2
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN9@erase@2
$LN8@erase@2:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+12]
$LN9@erase@2:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	esi, DWORD PTR __Last_arg$[esp+12]
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [edi+12], esi
	ja	SHORT $LN24@erase@2
	cmp	esi, DWORD PTR [edi+16]
	jbe	SHORT $LN25@erase@2
$LN24@erase@2:
	call	__invalid_parameter_noinfo
	mov	esi, DWORD PTR __Last_arg$[esp+12]
$LN25@erase@2:

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN38@erase@2
	cmp	eax, ecx
	je	SHORT $LN39@erase@2
$LN38@erase@2:
	call	__invalid_parameter_noinfo
$LN39@erase@2:
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, esi
	je	SHORT $LN73@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ecx, DWORD PTR [edi+16]
	mov	eax, ecx
	sub	eax, esi
	sar	eax, 3
	lea	ebp, DWORD PTR [edx+eax*8]
	mov	eax, esi
	cmp	esi, ecx
	je	SHORT $LN66@erase@2
	sub	edx, esi
$LL68@erase@2:
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+eax+4], esi
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL68@erase@2
$LN66@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+16], ebp
$LN73@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	20					; 00000014H
?erase@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@0@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@2
	call	__invalid_parameter_noinfo
$LN6@end@2:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@2
	call	__invalid_parameter_noinfo
$LN6@begin@2:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@XZ ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@ABQAU342@@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@10
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@10:

; 156  : 		}

	ret	0
?construct@?$allocator@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node *>::construct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@I@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>::allocate, COMDAT

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	ret	0
?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@I@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??8_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z
_TEXT	SEGMENT
??8_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 297  : 			return (_Mypos._Mynode() == _Right._Mynode());

	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx+4]
	sete	al

; 298  : 			}

	ret	0
??8_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::operator==
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAEPAU?$pair@U?$pair@_K_K@std@@U12@@2@I@Z
_TEXT	SEGMENT
$T336019 = -16						; size = 4
$T336021 = -12						; size = 12
?allocate@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAEPAU?$pair@U?$pair@_K_K@std@@U12@@2@I@Z PROC ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@4
	xor	ecx, ecx
$LN3@allocate@4:
	shl	ecx, 5
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@4:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN3@allocate@4
	lea	eax, DWORD PTR $T336019[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T336021[esp+20]
	mov	DWORD PTR $T336019[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T336021[esp+20]
	push	ecx
	mov	DWORD PTR $T336021[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@4:
$LN11@allocate@4:
	int	3
?allocate@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAEPAU?$pair@U?$pair@_K_K@std@@U12@@2@I@Z ENDP ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U?$pair@II@std@@@std@@QAEPAU?$pair@II@2@I@Z
_TEXT	SEGMENT
$T336041 = -16						; size = 4
$T336043 = -12						; size = 12
?allocate@?$allocator@U?$pair@II@std@@@std@@QAEPAU?$pair@II@2@I@Z PROC ; std::allocator<std::pair<unsigned int,unsigned int> >::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@5
	xor	ecx, ecx
$LN3@allocate@5:
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@5:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN3@allocate@5
	lea	eax, DWORD PTR $T336041[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T336043[esp+20]
	mov	DWORD PTR $T336041[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T336043[esp+20]
	push	ecx
	mov	DWORD PTR $T336043[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@5:
$LN11@allocate@5:
	int	3
?allocate@?$allocator@U?$pair@II@std@@@std@@QAEPAU?$pair@II@2@I@Z ENDP ; std::allocator<std::pair<unsigned int,unsigned int> >::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KI@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Carg$ = 20						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KI@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode, COMDAT
; __Val$ = esi

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	mov	ecx, 1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode@2
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [esi+8]
	movq	QWORD PTR [eax+24], xmm0
	mov	BYTE PTR [eax+32], dl
	mov	BYTE PTR [eax+33], 0
$LN4@Buynode@2:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	16					; 00000010H
?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KI@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode, COMDAT

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	mov	ecx, 1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Node>

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode@3
	mov	DWORD PTR [eax], 0
$LN27@Buynode@3:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@3
	mov	DWORD PTR [ecx], 0
$LN37@Buynode@3:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@3
	mov	DWORD PTR [ecx], 0
$LN47@Buynode@3:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+32], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+33], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Carg$ = 20						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode, COMDAT
; __Val$ = esi

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode@4
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [esi+8]
	movq	QWORD PTR [eax+24], xmm0
	movq	xmm0, QWORD PTR [esi+16]
	movq	QWORD PTR [eax+32], xmm0
	mov	BYTE PTR [eax+40], dl
	mov	BYTE PTR [eax+41], 0
$LN4@Buynode@4:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	16					; 00000010H
?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode, COMDAT

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode@5
	mov	DWORD PTR [eax], 0
$LN27@Buynode@5:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@5
	mov	DWORD PTR [ecx], 0
$LN37@Buynode@5:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@5
	mov	DWORD PTR [ecx], 0
$LN47@Buynode@5:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+40], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+41], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode, COMDAT

; 1172 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1173 : 		int _Linkcnt = 0;
; 1174 : 
; 1175 : 		_TRY_BEGIN
; 1176 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

	test	eax, eax
	je	SHORT $LN26@Buynode@6
	mov	DWORD PTR [eax], eax
$LN26@Buynode@6:

; 1177 : 		++_Linkcnt;
; 1178 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN36@Buynode@6
	mov	DWORD PTR [ecx], eax
$LN36@Buynode@6:

; 1179 : 		_CATCH_ALL
; 1180 : 		if (0 < _Linkcnt)
; 1181 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1182 : 		this->_Alnod.deallocate(_Pnode, 1);
; 1183 : 		_RERAISE;
; 1184 : 		_CATCH_END
; 1185 : 		return (_Pnode);
; 1186 : 		}

	ret	0
?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ
_TEXT	SEGMENT
tv139 = -4						; size = 4
tv132 = -4						; size = 4
tv129 = -4						; size = 4
?load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::load_factor, COMDAT
; _this$ = eax

; 507  : 		{	// return elements per bucket

	push	ecx

; 508  : 		return ((float)size() / (float)bucket_count());

	mov	ecx, DWORD PTR [eax+32]
	fild	DWORD PTR [eax+32]
	test	ecx, ecx
	jge	SHORT $LN9@load_facto@2
	fadd	DWORD PTR __real@4f800000
$LN9@load_facto@2:
	mov	edx, DWORD PTR [eax+64]
	fild	DWORD PTR [eax+64]
	test	edx, edx
	jge	SHORT $LN10@load_facto@2
	fadd	DWORD PTR __real@4f800000
$LN10@load_facto@2:
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR tv129[esp+4]
	fld	DWORD PTR tv129[esp+4]

; 509  : 		}

	pop	ecx
	ret	0
?load_factor@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBEMXZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::load_factor
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEPAV?$vector@IV?$allocator@I@std@@@2@I@Z
_TEXT	SEGMENT
$T336575 = -16						; size = 4
$T336581 = -12						; size = 12
?allocate@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEPAV?$vector@IV?$allocator@I@std@@@2@I@Z PROC ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@6
	xor	ecx, ecx
$LN3@allocate@6:
	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@6:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN3@allocate@6
	lea	eax, DWORD PTR $T336575[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T336581[esp+20]
	mov	DWORD PTR $T336575[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T336581[esp+20]
	push	ecx
	mov	DWORD PTR $T336581[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@6:
$LN11@allocate@6:
	int	3
?allocate@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEPAV?$vector@IV?$allocator@I@std@@@2@I@Z ENDP ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@I@Z
_TEXT	SEGMENT
$T336597 = -16						; size = 4
$T336603 = -12						; size = 12
?allocate@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@I@Z PROC ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@7
	xor	ecx, ecx
$LN3@allocate@7:
	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@7:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN3@allocate@7
	lea	eax, DWORD PTR $T336597[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T336603[esp+20]
	mov	DWORD PTR $T336597[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T336603[esp+20]
	push	ecx
	mov	DWORD PTR $T336603[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@7:
$LN11@allocate@7:
	int	3
?allocate@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@I@Z ENDP ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$vector@IV?$allocator@I@std@@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$vector@IV?$allocator@I@std@@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,std::vector<unsigned int,std::allocator<unsigned int> >,int,std::vector<unsigned int,std::allocator<unsigned int> > const *,std::vector<unsigned int,std::allocator<unsigned int> > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::vector<unsigned int,std::allocator<unsigned int> >,int,std::vector<unsigned int,std::allocator<unsigned int> > const *,std::vector<unsigned int,std::allocator<unsigned int> > const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$vector@IV?$allocator@I@std@@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,std::vector<unsigned int,std::allocator<unsigned int> >,int,std::vector<unsigned int,std::allocator<unsigned int> > const *,std::vector<unsigned int,std::allocator<unsigned int> > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::vector<unsigned int,std::allocator<unsigned int> >,int,std::vector<unsigned int,std::allocator<unsigned int> > const *,std::vector<unsigned int,std::allocator<unsigned int> > const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBII@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBII@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBII@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@IHPBIABI@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@IHPBIABI@std@@QAE@XZ PROC			; std::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@IHPBIABI@std@@QAE@XZ ENDP			; std::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@V?$vector@IV?$allocator@I@std@@@std@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@V?$vector@IV?$allocator@I@std@@@std@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<std::vector<unsigned int,std::allocator<unsigned int> >,int,std::vector<unsigned int,std::allocator<unsigned int> > const *,std::vector<unsigned int,std::allocator<unsigned int> > const &>::_Ranit<std::vector<unsigned int,std::allocator<unsigned int> >,int,std::vector<unsigned int,std::allocator<unsigned int> > const *,std::vector<unsigned int,std::allocator<unsigned int> > const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@V?$vector@IV?$allocator@I@std@@@std@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<std::vector<unsigned int,std::allocator<unsigned int> >,int,std::vector<unsigned int,std::allocator<unsigned int> > const *,std::vector<unsigned int,std::allocator<unsigned int> > const &>::_Ranit<std::vector<unsigned int,std::allocator<unsigned int> >,int,std::vector<unsigned int,std::allocator<unsigned int> > const *,std::vector<unsigned int,std::allocator<unsigned int> > const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Bidit@U?$pair@$$CBII@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Bidit@U?$pair@$$CBII@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &>::_Bidit<std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Bidit@U?$pair@$$CBII@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &>::_Bidit<std::pair<unsigned int const ,unsigned int>,int,std::pair<unsigned int const ,unsigned int> const *,std::pair<unsigned int const ,unsigned int> const &>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??9_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z
_TEXT	SEGMENT
??9_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 302  : 			return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx+4]
	setne	al

; 303  : 			}

	ret	0
??9_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE_NABV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::operator!=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@3
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@3
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@3
$LN1@Vector_con@3:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@3:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@PAV?$vector@IV?$allocator@I@std@@@1@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@PAV?$vector@IV?$allocator@I@std@@@1@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@4
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@4
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@4
$LN1@Vector_con@4:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@4:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@PAV?$vector@IV?$allocator@I@std@@@1@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z
_TEXT	SEGMENT
??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Const_iterator<1>, COMDAT
; _this$ = esi
; __Pnode$ = eax
; __Plist$ = edi

; 176  : 			{	// construct with node pointer _Pnode

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax

; 177  : 			_SCL_SECURE_TRAITS_VALIDATE(_Plist != NULL);

	test	edi, edi
	jne	SHORT $LN1@Const_iter@3
	call	__invalid_parameter_noinfo
$LN1@Const_iter@3:

; 178  : 			this->_Set_container(_Plist);

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 179  : 			}

	mov	eax, esi
	ret	0
??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Const_iterator<1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAEPAU?$pair@U?$pair@_K_K@std@@U12@@2@PAU32@IABU32@@Z
_TEXT	SEGMENT
$T336755 = -4						; size = 1
__Cat$336758 = -4					; size = 1
?_Ufill@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAEPAU?$pair@U?$pair@_K_K@std@@U12@@2@PAU32@IABU32@@Z PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	BYTE PTR $T336755[esp+4], 0
	mov	eax, DWORD PTR $T336755[esp+4]
	mov	ecx, DWORD PTR __Cat$336758[esp+4]
	push	eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	??$_Uninit_fill_n@PAU?$pair@U?$pair@_K_K@std@@U12@@std@@IU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@0@IABU10@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,unsigned int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >

; 1255 : 		return (_Ptr + _Count);

	mov	eax, esi
	shl	eax, 5
	add	eax, edi

; 1256 : 		}

	add	esp, 16					; 00000010H
	ret	0
?_Ufill@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAEPAU?$pair@U?$pair@_K_K@std@@U12@@2@PAU32@IABU32@@Z ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAEPAU?$pair@II@2@PAU32@IABU32@@Z
_TEXT	SEGMENT
$T336773 = -4						; size = 1
__Cat$336776 = -4					; size = 1
?_Ufill@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAEPAU?$pair@II@2@PAU32@IABU32@@Z PROC ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	BYTE PTR $T336773[esp+4], 0
	mov	eax, DWORD PTR $T336773[esp+4]
	mov	ecx, DWORD PTR __Cat$336776[esp+4]
	push	eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	??$_Uninit_fill_n@PAU?$pair@II@std@@IU12@V?$allocator@U?$pair@II@std@@@2@@std@@YAXPAU?$pair@II@0@IABU10@AAV?$allocator@U?$pair@II@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned int,unsigned int> *,unsigned int,std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]

; 1256 : 		}

	add	esp, 16					; 00000010H
	ret	0
?_Ufill@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAEPAU?$pair@II@2@PAU32@IABU32@@Z ENDP ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@I@Z
_TEXT	SEGMENT
$T336787 = -16						; size = 4
$T336793 = -12						; size = 12
?allocate@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@I@Z PROC ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@8
	xor	ecx, ecx
$LN3@allocate@8:
	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@8:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN3@allocate@8
	lea	eax, DWORD PTR $T336787[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T336793[esp+20]
	mov	DWORD PTR $T336787[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T336793[esp+20]
	push	ecx
	mov	DWORD PTR $T336793[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@8:
$LN11@allocate@8:
	int	3
?allocate@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@I@Z ENDP ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z
_TEXT	SEGMENT
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill@4
	push	ebx
	npad	7
$LL21@Ufill@4:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL21@Ufill@4
	pop	ebx
$LN26@Ufill@4:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]

; 1256 : 		}

	ret	0
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ??0?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@@Z
_TEXT	SEGMENT
??0?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@@Z PROC ; std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>, COMDAT
; _this$ = eax
; __Traits$ = ecx

; 45   : 		{	// construct with specified comparator

	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax+4], dx

; 46   : 		}

	ret	0
??0?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@@Z ENDP ; std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@U?$pair@_K_K@std@@U12@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@U?$pair@_K_K@std@@U12@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@U?$pair@_K_K@std@@U12@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const *,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const *,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const *,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const *,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@II@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@II@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,unsigned int>,int,std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,unsigned int>,int,std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@II@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,unsigned int>,int,std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,unsigned int>,int,std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const *,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const *,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const *,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const *,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@U?$pair@U?$pair@_K_K@std@@U12@@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@U?$pair@U?$pair@_K_K@std@@U12@@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Ranit<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const &>::_Ranit<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@U?$pair@U?$pair@_K_K@std@@U12@@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Ranit<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const &>::_Ranit<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const *,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const &>::_Ranit<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const *,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const *,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const &>::_Ranit<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const *,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@U?$pair@II@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@U?$pair@II@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Ranit<std::pair<unsigned int,unsigned int>,int,std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> const &>::_Ranit<std::pair<unsigned int,unsigned int>,int,std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@U?$pair@II@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Ranit<std::pair<unsigned int,unsigned int>,int,std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> const &>::_Ranit<std::pair<unsigned int,unsigned int>,int,std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const *,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const &>::_Ranit<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const *,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const *,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const &>::_Ranit<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const *,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > const &>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@50
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@50
$LN1@operator@50:
	call	__invalid_parameter_noinfo
$LN2@operator@50:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@3
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@3
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@3
$LN3@Vector_ite@3:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@3:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@51
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@51
$LN1@operator@51:
	call	__invalid_parameter_noinfo
$LN2@operator@51:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@PAV?$vector@IV?$allocator@I@std@@@1@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@PAV?$vector@IV?$allocator@I@std@@@1@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@4
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@4
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@4
$LN3@Vector_ite@4:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@4:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@PAV?$vector@IV?$allocator@I@std@@@1@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@52
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@52
$LN1@operator@52:
	call	__invalid_parameter_noinfo
$LN2@operator@52:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@PAU?$pair@U?$pair@_K_K@std@@U12@@1@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@PAU?$pair@U?$pair@_K_K@std@@U12@@1@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@5
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@5
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@5
$LN1@Vector_con@5:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@5:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@PAU?$pair@U?$pair@_K_K@std@@U12@@1@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@53
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@53
$LN1@operator@53:
	call	__invalid_parameter_noinfo
$LN2@operator@53:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@6
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@6
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@6
$LN1@Vector_con@6:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@6:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@54
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@54
$LN1@operator@54:
	call	__invalid_parameter_noinfo
$LN2@operator@54:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@PAU?$pair@II@1@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@PAU?$pair@II@1@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@7
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@7
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@7
$LN1@Vector_con@7:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@7:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@PAU?$pair@II@1@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@55
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@55
$LN1@operator@55:
	call	__invalid_parameter_noinfo
$LN2@operator@55:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@8
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@8
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@8
$LN1@Vector_con@8:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@8:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??8?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 291  : 
; 292  :  #if _HAS_ITERATOR_DEBUGGING
; 293  : 			_Compat(_Right);
; 294  :  #else
; 295  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@56
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@56
$LN1@operator@56:
	call	__invalid_parameter_noinfo
$LN2@operator@56:

; 296  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 297  : 
; 298  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 299  : 			}

	ret	0
??8?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator==
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@I@std@@QAEPAII@Z
_TEXT	SEGMENT
$T337231 = -16						; size = 4
$T337233 = -12						; size = 12
?allocate@?$allocator@I@std@@QAEPAII@Z PROC		; std::allocator<unsigned int>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@9
	xor	ecx, ecx
$LN3@allocate@9:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@9:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate@9
	lea	eax, DWORD PTR $T337231[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T337233[esp+20]
	mov	DWORD PTR $T337231[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T337233[esp+20]
	push	ecx
	mov	DWORD PTR $T337233[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@9:
$LN11@allocate@9:
	int	3
?allocate@?$allocator@I@std@@QAEPAII@Z ENDP		; std::allocator<unsigned int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ
_TEXT	SEGMENT
?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 549  : 		return (const_iterator(_Myhead, this));

	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 550  : 		}

	ret	0
?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ
_TEXT	SEGMENT
?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 539  : 		return (const_iterator(_Nextnode(_Myhead), this));

	mov	edx, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 540  : 		}

	ret	0
?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Const_iterator@$00@12@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@57
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@57
$LN3@operator@57:
	call	__invalid_parameter_noinfo
$LN4@operator@57:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@58
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@58
$LN3@operator@58:
	call	__invalid_parameter_noinfo
$LN4@operator@58:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@59
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@59
$LN3@operator@59:
	call	__invalid_parameter_noinfo
$LN4@operator@59:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@60
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@60
$LN3@operator@60:
	call	__invalid_parameter_noinfo
$LN4@operator@60:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@61
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@61
$LN3@operator@61:
	call	__invalid_parameter_noinfo
$LN4@operator@61:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@62
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@62
$LN3@operator@62:
	call	__invalid_parameter_noinfo
$LN4@operator@62:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator!=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??9?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 303  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@63
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@63
$LN3@operator@63:
	call	__invalid_parameter_noinfo
$LN4@operator@63:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 304  : 			}

	ret	0
??9?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator!=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEAAU?$pair@U?$pair@_K_K@std@@U12@@1@I@Z
_TEXT	SEGMENT
??A?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEAAU?$pair@U?$pair@_K_K@std@@U12@@1@I@Z PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 5
	cmp	edi, eax
	jb	SHORT $LN1@operator@64
	call	__invalid_parameter_noinfo
$LN1@operator@64:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, edi
	shl	eax, 5
	add	eax, DWORD PTR [esi+12]

; 786  : 		}

	ret	0
??A?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEAAU?$pair@U?$pair@_K_K@std@@U12@@1@I@Z ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ
_TEXT	SEGMENT
?end@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@3
	call	__invalid_parameter_noinfo
$LN4@end@3:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@3
	call	__invalid_parameter_noinfo
$LN4@begin@3:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ
_TEXT	SEGMENT
?end@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ PROC ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@4
	call	__invalid_parameter_noinfo
$LN4@end@4:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ ENDP ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ PROC ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@4
	call	__invalid_parameter_noinfo
$LN4@begin@4:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ ENDP ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEAAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@I@Z
_TEXT	SEGMENT
??A?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEAAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@I@Z PROC ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN1@operator@65
	call	__invalid_parameter_noinfo
$LN1@operator@65:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	edx, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	eax, DWORD PTR [edx+ecx*8]

; 786  : 		}

	ret	0
??A?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEAAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@I@Z ENDP ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
?end@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@5
	call	__invalid_parameter_noinfo
$LN4@end@5:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@5
	call	__invalid_parameter_noinfo
$LN4@begin@5:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z
_TEXT	SEGMENT
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@66
	call	__invalid_parameter_noinfo
$LN1@operator@66:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 786  : 		}

	ret	0
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@6
	call	__invalid_parameter_noinfo
$LN6@end@6:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@6
	call	__invalid_parameter_noinfo
$LN6@begin@6:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ
_TEXT	SEGMENT
?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 392  : 		return (_List.end());

	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 393  : 		}

	ret	0
?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ
_TEXT	SEGMENT
?begin@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 382  : 		return (_List.begin());

	mov	edx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 383  : 		}

	ret	0
?begin@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEAAV?$vector@IV?$allocator@I@std@@@1@I@Z
_TEXT	SEGMENT
??A?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEAAV?$vector@IV?$allocator@I@std@@@1@I@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN1@operator@67
	call	__invalid_parameter_noinfo
$LN1@operator@67:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	edx, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	eax, DWORD PTR [edx+ecx*8]

; 786  : 		}

	ret	0
??A?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEAAV?$vector@IV?$allocator@I@std@@@1@I@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?end@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@2@XZ PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@7
	call	__invalid_parameter_noinfo
$LN6@end@7:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@2@XZ ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@2@XZ PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@7
	call	__invalid_parameter_noinfo
$LN6@begin@7:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@2@XZ ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
?end@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@8
	call	__invalid_parameter_noinfo
$LN4@end@8:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@8
	call	__invalid_parameter_noinfo
$LN4@begin@8:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::begin
_TEXT	ENDS
PUBLIC	?reportRowBufferAccess@Statistics@DRAMsimII@@QAEXPBVTransaction@2@_N@Z ; DRAMsimII::Statistics::reportRowBufferAccess
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.cpp
_TEXT	SEGMENT
_isHit$ = 8						; size = 1
?reportRowBufferAccess@Statistics@DRAMsimII@@QAEXPBVTransaction@2@_N@Z PROC ; DRAMsimII::Statistics::reportRowBufferAccess
; _this$ = ecx
; _currentTransaction$ = eax

; 176  : {

	push	ebx

; 177  : 	if (isHit)
; 178  : 	{
; 179  : 		rowBufferAccesses[currentTransaction->getAddress().getChannel()][currentTransaction->getAddress().getRank()].first++;

	mov	ebx, DWORD PTR [eax+60]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+72]
	sub	ecx, DWORD PTR [esi+68]
	push	edi
	mov	edi, DWORD PTR [eax+56]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	BYTE PTR _isHit$[esp+8], 0
	je	SHORT $LN2@reportRowB
	cmp	edi, eax
	jb	SHORT $LN13@reportRowB
	call	__invalid_parameter_noinfo
$LN13@reportRowB:
	mov	edx, DWORD PTR [esi+68]
	lea	ecx, DWORD PTR [edi+edi*2]
	mov	eax, DWORD PTR [edx+ecx*8+16]
	sub	eax, DWORD PTR [edx+ecx*8+12]
	lea	esi, DWORD PTR [edx+ecx*8]
	sar	eax, 3
	cmp	ebx, eax
	jb	SHORT $LN18@reportRowB
	call	__invalid_parameter_noinfo
$LN18@reportRowB:
	mov	ecx, DWORD PTR [esi+12]

; 180  : 	}
; 181  : 	else
; 182  : 	{
; 183  : 		rowBufferAccesses[currentTransaction->getAddress().getChannel()][currentTransaction->getAddress().getRank()].second++;

	inc	DWORD PTR [ecx+ebx*8]
	pop	edi
	lea	eax, DWORD PTR [ecx+ebx*8]
	pop	esi
	pop	ebx

; 184  : 	}
; 185  : 	//#pragma omp atomic
; 186  : 	//rowHits++;
; 187  : }

	ret	4
$LN2@reportRowB:

; 180  : 	}
; 181  : 	else
; 182  : 	{
; 183  : 		rowBufferAccesses[currentTransaction->getAddress().getChannel()][currentTransaction->getAddress().getRank()].second++;

	cmp	edi, eax
	jb	SHORT $LN31@reportRowB
	call	__invalid_parameter_noinfo
$LN31@reportRowB:
	mov	edx, DWORD PTR [esi+68]
	lea	ecx, DWORD PTR [edi+edi*2]
	mov	eax, DWORD PTR [edx+ecx*8+16]
	sub	eax, DWORD PTR [edx+ecx*8+12]
	lea	esi, DWORD PTR [edx+ecx*8]
	sar	eax, 3
	cmp	ebx, eax
	jb	SHORT $LN36@reportRowB
	call	__invalid_parameter_noinfo
$LN36@reportRowB:
	mov	ecx, DWORD PTR [esi+12]
	inc	DWORD PTR [ecx+ebx*8+4]
	pop	edi
	lea	eax, DWORD PTR [ecx+ebx*8+4]
	pop	esi
	pop	ebx

; 184  : 	}
; 185  : 	//#pragma omp atomic
; 186  : 	//rowHits++;
; 187  : }

	ret	4
?reportRowBufferAccess@Statistics@DRAMsimII@@QAEXPBVTransaction@2@_N@Z ENDP ; DRAMsimII::Statistics::reportRowBufferAccess
_TEXT	ENDS
PUBLIC	?reportRasReduction@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::Statistics::reportRasReduction
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?reportRasReduction@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z PROC ; DRAMsimII::Statistics::reportRasReduction
; _this$ = edi
; _currentCommand$ = eax

; 169  : 	rasReduction[currentCommand->getAddress().getChannel()][currentCommand->getAddress().getRank()]++;

	mov	ecx, DWORD PTR [edi+96]
	sub	ecx, DWORD PTR [edi+92]
	push	ebx
	mov	ebx, DWORD PTR [eax+60]
	push	esi
	mov	esi, DWORD PTR [eax+56]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jb	SHORT $LN11@reportRasR
	call	__invalid_parameter_noinfo
$LN11@reportRasR:
	mov	edx, DWORD PTR [edi+92]
	lea	ecx, DWORD PTR [esi+esi*2]
	mov	eax, DWORD PTR [edx+ecx*8+16]
	sub	eax, DWORD PTR [edx+ecx*8+12]
	lea	esi, DWORD PTR [edx+ecx*8]
	sar	eax, 2
	cmp	ebx, eax
	jb	SHORT $LN16@reportRasR
	call	__invalid_parameter_noinfo
$LN16@reportRasR:
	mov	ecx, DWORD PTR [esi+12]
	inc	DWORD PTR [ecx+ebx*4]
	lea	eax, DWORD PTR [ecx+ebx*4]
	pop	esi
	pop	ebx

; 170  : }

	ret	0
?reportRasReduction@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z ENDP ; DRAMsimII::Statistics::reportRasReduction
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
_TEXT	ENDS
;	COMDAT ?noshowpoint@std@@YAAAVios_base@1@AAV21@@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
?noshowpoint@std@@YAAAVios_base@1@AAV21@@Z PROC		; std::noshowpoint, COMDAT

; 230  : 	_Iosbase.unsetf(ios_base::showpoint);

	mov	eax, DWORD PTR __Iosbase$[esp-4]
	and	DWORD PTR [eax+16], -17			; ffffffefH

; 231  : 	return (_Iosbase);
; 232  : 	}

	ret	0
?noshowpoint@std@@YAAAVios_base@1@AAV21@@Z ENDP		; std::noshowpoint
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PBU?$pair@U?$pair@_K_K@std@@U12@@std@@PAU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@0@PBU10@0PAU10@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_copy@PBU?$pair@U?$pair@_K_K@std@@U12@@std@@PAU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@0@PBU10@0PAU10@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >, COMDAT
; __Last$ = edx
; __Dest$ = eax

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	mov	ecx, DWORD PTR __First$[esp-4]

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@3
$LL6@Uninit_cop@3:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@3
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR [eax+8], xmm0
	movq	xmm0, QWORD PTR [ecx+16]
	movq	QWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR [ecx+24]
	movq	QWORD PTR [eax+24], xmm0
$LN5@Uninit_cop@3:
	add	ecx, 32					; 00000020H
	add	eax, 32					; 00000020H
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@3
$LN4@Uninit_cop@3:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PBU?$pair@U?$pair@_K_K@std@@U12@@std@@PAU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@0@PBU10@0PAU10@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBU?$pair@II@std@@PAU12@V?$allocator@U?$pair@II@std@@@2@@std@@YAPAU?$pair@II@0@PBU10@0PAU10@AAV?$allocator@U?$pair@II@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_copy@PBU?$pair@II@std@@PAU12@V?$allocator@U?$pair@II@std@@@2@@std@@YAPAU?$pair@II@0@PBU10@0PAU10@AAV?$allocator@U?$pair@II@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> *,std::allocator<std::pair<unsigned int,unsigned int> > >, COMDAT
; __Last$ = edx
; __Dest$ = eax

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	mov	ecx, DWORD PTR __First$[esp-4]

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@4
	push	esi
	npad	7
$LL6@Uninit_cop@4:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@4
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_cop@4:
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@4
	pop	esi
$LN4@Uninit_cop@4:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PBU?$pair@II@std@@PAU12@V?$allocator@U?$pair@II@std@@@2@@std@@YAPAU?$pair@II@0@PBU10@0PAU10@AAV?$allocator@U?$pair@II@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> *,std::allocator<std::pair<unsigned int,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@PAU?$pair@U?$pair@_K_K@std@@U12@@2@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@stdext@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@std@@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@Z
_TEXT	SEGMENT
$T378843 = -4						; size = 1
__Cat$378847 = 8					; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@PAU?$pair@U?$pair@_K_K@std@@U12@@2@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@stdext@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@std@@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$378847[esp]
	mov	edx, DWORD PTR __First$[esp+4]
	mov	BYTE PTR $T378843[esp+4], 0
	mov	eax, DWORD PTR $T378843[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	call	??$_Uninit_copy@PBU?$pair@U?$pair@_K_K@std@@U12@@std@@PAU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@0@PBU10@0PAU10@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >

; 823  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@PAU?$pair@U?$pair@_K_K@std@@U12@@2@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@stdext@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@std@@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@PAU?$pair@II@2@V?$allocator@U?$pair@II@std@@@2@@stdext@@YAPAU?$pair@II@std@@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@II@std@@@2@@Z
_TEXT	SEGMENT
$T378886 = -4						; size = 1
__Cat$378891 = 8					; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@PAU?$pair@II@2@V?$allocator@U?$pair@II@std@@@2@@stdext@@YAPAU?$pair@II@std@@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@II@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::pair<unsigned int,unsigned int> *,std::allocator<std::pair<unsigned int,unsigned int> > >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$378891[esp]
	mov	edx, DWORD PTR __First$[esp+4]
	mov	BYTE PTR $T378886[esp+4], 0
	mov	eax, DWORD PTR $T378886[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	call	??$_Uninit_copy@PBU?$pair@II@std@@PAU12@V?$allocator@U?$pair@II@std@@@2@@std@@YAPAU?$pair@II@0@PBU10@0PAU10@AAV?$allocator@U?$pair@II@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> *,std::allocator<std::pair<unsigned int,unsigned int> > >

; 823  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@PAU?$pair@II@2@V?$allocator@U?$pair@II@std@@@2@@stdext@@YAPAU?$pair@II@std@@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@II@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::pair<unsigned int,unsigned int> *,std::allocator<std::pair<unsigned int,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; __Last$ = edx
; __Dest$ = eax

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	mov	ecx, DWORD PTR __First$[esp-4]

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@5
	push	esi
	npad	7
$LL6@Uninit_cop@5:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@5
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_cop@5:
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@5
	pop	esi
$LN4@Uninit_cop@5:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAEPAU?$pair@U?$pair@_K_K@std@@U12@@1@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@0PAU21@@Z
_TEXT	SEGMENT
$T379010 = -4						; size = 1
__Cat$379014 = 8					; size = 1
__Ptr$ = 8						; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
??$_Ucopy@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAEPAU?$pair@U?$pair@_K_K@std@@U12@@1@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@0PAU21@@Z PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Ucopy<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >, COMDAT

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	ecx, DWORD PTR __Cat$379014[esp]
	mov	edx, DWORD PTR __First$[esp+4]
	mov	BYTE PTR $T379010[esp+4], 0
	mov	eax, DWORD PTR $T379010[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	call	??$_Uninit_copy@PBU?$pair@U?$pair@_K_K@std@@U12@@std@@PAU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@0@PBU10@0PAU10@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >

; 1142 : 		}

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAEPAU?$pair@U?$pair@_K_K@std@@U12@@1@V?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@0PAU21@@Z ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Ucopy<std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAEPAU?$pair@II@1@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@0PAU21@@Z
_TEXT	SEGMENT
$T379078 = -4						; size = 1
__Cat$379082 = 8					; size = 1
__Ptr$ = 8						; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
??$_Ucopy@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAEPAU?$pair@II@1@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@0PAU21@@Z PROC ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Ucopy<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >, COMDAT

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	ecx, DWORD PTR __Cat$379082[esp]
	mov	edx, DWORD PTR __First$[esp+4]
	mov	BYTE PTR $T379078[esp+4], 0
	mov	eax, DWORD PTR $T379078[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	call	??$_Uninit_copy@PBU?$pair@II@std@@PAU12@V?$allocator@U?$pair@II@std@@@2@@std@@YAPAU?$pair@II@0@PBU10@0PAU10@AAV?$allocator@U?$pair@II@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> *,std::allocator<std::pair<unsigned int,unsigned int> > >

; 1142 : 		}

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAEPAU?$pair@II@1@V?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@0PAU21@@Z ENDP ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Ucopy<std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z
_TEXT	SEGMENT
$T379104 = -4						; size = 1
__Cat$379109 = 8					; size = 1
__Last$ = 8						; size = 4
__Dest$ = 12						; size = 4
??$unchecked_uninitialized_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; __First$ = edx

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$379109[esp]
	mov	BYTE PTR $T379104[esp+4], 0
	mov	eax, DWORD PTR $T379104[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	call	??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 823  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$unchecked_uninitialized_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN20@operator@169
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@operator@169
$LN20@operator@169:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@169
$LN10@operator@169:
	xor	edx, edx
$LN11@operator@169:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@169
	test	eax, eax
	je	SHORT $LN16@operator@169
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@169
$LN16@operator@169:
	xor	eax, eax
$LN17@operator@169:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@169
$LN1@operator@169:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@169:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [esi+4], edi

; 165  : 		return (*this);

	mov	eax, esi
	pop	edi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+, COMDAT
; _this$ = eax

; 169  : 		{	// return this + integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 170  : 		_Myt _Tmp = *this;

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 171  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN22@operator@170
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN13@operator@170:
	mov	ecx, DWORD PTR __Off$[esp+8]
	lea	edi, DWORD PTR [edi+ecx*4]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN3@operator@170
	test	esi, esi
	je	SHORT $LN18@operator@170
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN19@operator@170
$LN22@operator@170:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN13@operator@170
$LN18@operator@170:
	xor	eax, eax
$LN19@operator@170:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN4@operator@170
$LN3@operator@170:
	call	__invalid_parameter_noinfo
$LN4@operator@170:
	mov	DWORD PTR [ebx+4], edi
	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 172  : 		}

	ret	8
??H?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T379251 = -4						; size = 1
__Last$ = 8						; size = 4
__Cat$379255 = 12					; size = 1
__Dest$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>,std::_Undefined_move_tag>, COMDAT
; __First$ = edx

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$379255[esp]
	mov	BYTE PTR $T379251[esp+4], 0
	mov	eax, DWORD PTR $T379251[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	call	??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 208  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Uninit_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@U_Undefined_move_tag@5@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PA_JPA_JV?$allocator@_J@std@@U_Undefined_move_tag@2@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PA_JPA_JV?$allocator@_J@std@@U_Undefined_move_tag@2@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<__int64 *,__int64 *,std::allocator<__int64>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Uninit_mov@7
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Uninit_mov@7:
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PA_JPA_JV?$allocator@_J@std@@U_Undefined_move_tag@2@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<__int64 *,__int64 *,std::allocator<__int64>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Equal@PBIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YA_NPBI0V?$_Vector_const_iterator@IV?$allocator@I@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 8
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Equal@PBIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YA_NPBI0V?$_Vector_const_iterator@IV?$allocator@I@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<unsigned int const *,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT

; 3043 : 	// for range checked iterators, this will make sure there is enough space
; 3044 : 	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);

	mov	edx, DWORD PTR __Last1$[esp-4]
	mov	eax, DWORD PTR __First2$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First1$[esp]
	push	ebp
	push	esi
	mov	esi, edx
	sub	esi, ebx
	sar	esi, 2
	push	edi
	mov	edi, DWORD PTR __First2$[esp+16]
	mov	ebp, eax
	test	eax, eax
	jne	SHORT $LN39@Equal@5
	call	__invalid_parameter_noinfo
	mov	edx, DWORD PTR __Last1$[esp+12]
	xor	eax, eax
$LN15@Equal@5:
	lea	esi, DWORD PTR [edi+esi*4]
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN5@Equal@5
	test	ebp, ebp
	je	SHORT $LN20@Equal@5
	mov	ebp, DWORD PTR [ebp]
	jmp	SHORT $LN21@Equal@5
$LN39@Equal@5:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN15@Equal@5
$LN20@Equal@5:
	xor	ebp, ebp
$LN21@Equal@5:
	cmp	esi, DWORD PTR [ebp+12]
	jae	SHORT $LN6@Equal@5
$LN5@Equal@5:
	call	__invalid_parameter_noinfo
	mov	edx, DWORD PTR __Last1$[esp+12]
$LN6@Equal@5:

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	mov	eax, ebx
	cmp	ebx, edx
	je	SHORT $LN31@Equal@5
	mov	ecx, DWORD PTR __First2$[esp+16]
	sub	ecx, ebx
	npad	3
$LL33@Equal@5:
	mov	esi, DWORD PTR [eax]
	cmp	esi, DWORD PTR [ecx+eax]
	jne	SHORT $LN37@Equal@5
	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL33@Equal@5
$LN31@Equal@5:
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx

; 3047 : 	}

	ret	0
$LN37@Equal@5:
	pop	edi
	pop	esi
	pop	ebp

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	xor	al, al
	pop	ebx

; 3047 : 	}

	ret	0
??$_Equal@PBIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YA_NPBI0V?$_Vector_const_iterator@IV?$allocator@I@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<unsigned int const *,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z
_TEXT	SEGMENT
$T379522 = -4						; size = 1
__Last$ = 8						; size = 4
__Cat$379526 = 12					; size = 1
__Dest$ = 12						; size = 4
??$_Unchecked_uninitialized_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; __First$ = edx

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$379526[esp]
	mov	BYTE PTR $T379522[esp+4], 0
	mov	eax, DWORD PTR $T379522[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	call	??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 865  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Unchecked_uninitialized_move@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<__int64,std::allocator<__int64> >,__int64 *,std::allocator<__int64> >, COMDAT
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN34@Unchecked_@16
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN34@Unchecked_@16:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<__int64,std::allocator<__int64> >,__int64 *,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$equal@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@00@Z
_TEXT	SEGMENT
$T379674 = -4						; size = 1
__First1$ = 8						; size = 8
$T379675 = 16						; size = 1
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
??$equal@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@00@Z PROC ; std::equal<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT

; 3055 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ecx

; 3056 : 	return _Equal(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _First2,
; 3057 : 		_Iter_random(_First1, _First2), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T379675[esp]
	mov	edx, DWORD PTR __First2$[esp+4]
	mov	BYTE PTR $T379674[esp+4], 0
	mov	eax, DWORD PTR $T379674[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+16]
	push	eax
	push	ecx
	push	edx
	call	??$_Equal@PBIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YA_NPBI0V?$_Vector_const_iterator@IV?$allocator@I@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<unsigned int const *,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >

; 3058 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$equal@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@00@Z ENDP ; std::equal<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@30
	call	__invalid_parameter_noinfo
$LN4@end@30:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@33
	call	__invalid_parameter_noinfo
$LN4@begin@33:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 571  : 		return (_TREE_CONST_ITERATOR(_Myhead));

	mov	edx, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 572  : 		}

	ret	0
?end@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 561  : 		return (_TREE_CONST_ITERATOR(_Lmost()));

	mov	edx, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 562  : 		}

	ret	0
?begin@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU234@00@Z
_TEXT	SEGMENT
$T379971 = -4						; size = 1
__Last$ = 8						; size = 4
__Cat$379974 = 12					; size = 1
__Ptr$ = 12						; size = 4
??$_Umove@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU234@00@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Umove<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>, COMDAT
; __First$ = edx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	ecx, DWORD PTR __Cat$379974[esp]
	mov	BYTE PTR $T379971[esp+4], 0
	mov	eax, DWORD PTR $T379971[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	call	??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 1149 : 		}

	add	esp, 16					; 00000010H
	ret	8
??$_Umove@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU234@00@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Umove<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Umove@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Umove@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Umove<std::_Vector_iterator<__int64,std::allocator<__int64> > >, COMDAT
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN36@Umove@9
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN36@Umove@9:

; 1149 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Umove@V?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Umove<std::_Vector_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?8IV?$allocator@I@std@@@std@@YA_NABV?$vector@IV?$allocator@I@std@@@0@0@Z
_TEXT	SEGMENT
$T380182 = -8						; size = 8
$T380377 = 8						; size = 1
$T380378 = 8						; size = 1
__Right$ = 8						; size = 4
??$?8IV?$allocator@I@std@@@std@@YA_NABV?$vector@IV?$allocator@I@std@@@0@0@Z PROC ; std::operator==<unsigned int,std::allocator<unsigned int> >, COMDAT
; __Left$ = esi

; 1308 : 	return (_Left.size() == _Right.size()
; 1309 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	mov	edx, DWORD PTR [esi+16]
	sub	edx, DWORD PTR [esi+12]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Right$[esp+8]
	mov	eax, DWORD PTR [ebx+16]
	push	edi
	mov	edi, DWORD PTR [ebx+12]
	mov	ecx, eax
	sub	ecx, edi
	xor	ecx, edx
	test	ecx, -4					; fffffffcH
	jne	SHORT $LN3@operator@171
	cmp	edi, eax
	jbe	SHORT $LN12@operator@171
	call	__invalid_parameter_noinfo
$LN12@operator@171:
	mov	eax, DWORD PTR [ebx]
	push	ebp
	mov	ebp, DWORD PTR [esi+16]
	mov	DWORD PTR $T380182[esp+20], eax
	cmp	DWORD PTR [esi+12], ebp
	jbe	SHORT $LN26@operator@171
	call	__invalid_parameter_noinfo
$LN26@operator@171:
	mov	ebx, DWORD PTR [esi+12]
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN40@operator@171
	call	__invalid_parameter_noinfo
$LN40@operator@171:
	mov	eax, DWORD PTR $T380182[esp+20]
	mov	BYTE PTR $T380377[esp+16], 0
	mov	ecx, DWORD PTR $T380377[esp+16]
	mov	edx, DWORD PTR $T380378[esp+16]
	push	ecx
	push	edx
	push	edi
	push	eax
	push	ebp
	push	ebx
	call	??$_Equal@PBIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YA_NPBI0V?$_Vector_const_iterator@IV?$allocator@I@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<unsigned int const *,std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
	add	esp, 24					; 00000018H
	pop	ebp
	test	al, al
	je	SHORT $LN3@operator@171
	pop	edi
	mov	eax, 1
	pop	ebx

; 1310 : 	}

	add	esp, 8
	ret	0
$LN3@operator@171:
	pop	edi

; 1308 : 	return (_Left.size() == _Right.size()
; 1309 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	xor	eax, eax
	pop	ebx

; 1310 : 	}

	add	esp, 8
	ret	0
??$?8IV?$allocator@I@std@@@std@@YA_NABV?$vector@IV?$allocator@I@std@@@0@0@Z ENDP ; std::operator==<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@5
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@5:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@6
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@6:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBII@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBII@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,unsigned int> > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@7
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@7:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBII@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,unsigned int> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>, COMDAT
; _this$ = esi

; 39   : 		{	// construct with specified comparator

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Tmap_trait
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 40   : 		}

	mov	eax, esi
	ret	8

; 39   : 		{	// construct with specified comparator

$LN8@Tmap_trait:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 40   : 		}

	mov	eax, esi
	ret	8
??0?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>, COMDAT
; _this$ = esi

; 39   : 		{	// construct with specified comparator

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Tmap_trait@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 40   : 		}

	mov	eax, esi
	ret	8

; 39   : 		{	// construct with specified comparator

$LN8@Tmap_trait@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 40   : 		}

	mov	eax, esi
	ret	8
??0?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@QAE@U?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >, COMDAT
; _this$ = esi

; 47   : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@List_nod@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 48   : 		}

	mov	eax, esi
	ret	4

; 47   : 		{	// construct allocator from _Al

$LN8@List_nod@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 48   : 		}

	mov	eax, esi
	ret	4
??0?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_nod<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PAU342@0ABU?$pair@$$CBII@2@@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PAU342@0ABU?$pair@$$CBII@2@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode, COMDAT
; __Val$ = esi

; 1191 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1192 : 		int _Linkcnt = 0;
; 1193 : 
; 1194 : 		_TRY_BEGIN
; 1195 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Next);

	test	eax, eax
	je	SHORT $LN27@Buynode@14
	mov	ecx, DWORD PTR __Next$[esp-4]
	mov	DWORD PTR [eax], ecx
$LN27@Buynode@14:

; 1196 : 		++_Linkcnt;
; 1197 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Prev);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@14
	mov	edx, DWORD PTR __Prev$[esp-4]
	mov	DWORD PTR [ecx], edx
$LN37@Buynode@14:

; 1198 : 		++_Linkcnt;
; 1199 : 		this->_Alval.construct(&_Myval(_Pnode), _Val);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@14
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], edx
$LN47@Buynode@14:

; 1200 : 		_CATCH_ALL
; 1201 : 		if (1 < _Linkcnt)
; 1202 : 			this->_Alptr.destroy(&_Prevnode(_Pnode));
; 1203 : 		if (0 < _Linkcnt)
; 1204 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1205 : 		this->_Alnod.deallocate(_Pnode, 1);
; 1206 : 		_RERAISE;
; 1207 : 		_CATCH_END
; 1208 : 		return (_Pnode);
; 1209 : 		}

	ret	8
?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PAU342@0ABU?$pair@$$CBII@2@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z
_TEXT	SEGMENT
__Plist$ = 8						; size = 4
??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<0>::_Const_iterator<0>, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 177  : 			_SCL_SECURE_TRAITS_VALIDATE(_Plist != NULL);
; 178  : 			this->_Set_container(_Plist);

	mov	edx, DWORD PTR __Plist$[esp-4]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 179  : 			}

	ret	4
??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<0>::_Const_iterator<0>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??F?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??F?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator--, COMDAT
; _this$ = esi

; 263  : 
; 264  :  #if _HAS_ITERATOR_DEBUGGING
; 265  : 			if (this->_Mycont == 0
; 266  : 				|| _Ptr == 0
; 267  : 				|| (_Ptr = _Prevnode(_Ptr))
; 268  : 					== ((_Myt *)this->_Mycont)->_Myhead)
; 269  : 				{
; 270  : 				_DEBUG_ERROR("list iterator not decrementable");
; 271  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 272  : 				}
; 273  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 274  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN3@operator@172
	call	__invalid_parameter_noinfo
$LN3@operator@172:

; 275  : 			_Ptr = _Prevnode(_Ptr);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 276  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], ecx
	test	eax, eax
	je	SHORT $LN13@operator@172
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@172
$LN13@operator@172:
	xor	eax, eax
$LN14@operator@172:
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN17@operator@172
	call	__invalid_parameter_noinfo
$LN17@operator@172:

; 277  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 278  : 
; 279  : 			return (*this);

	mov	eax, esi

; 280  : 			}

	ret	0
??F?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator--
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >, COMDAT
; _this$ = esi

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@Tree_nod
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 53   : 		}

	mov	eax, esi
	ret	4

; 52   : 		{	// construct traits from _Parg and allocator from _Al

$LN13@Tree_nod:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 53   : 		}

	mov	eax, esi
	ret	4
??0?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >, COMDAT
; _this$ = esi

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@Tree_nod@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 53   : 		}

	mov	eax, esi
	ret	4

; 52   : 		{	// construct traits from _Parg and allocator from _Al

$LN13@Tree_nod@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 53   : 		}

	mov	eax, esi
	ret	4
??0?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Container_base_aux_alloc_real<std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@8
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@8:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Container_base_aux_alloc_real<std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_ptr@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::_List_ptr<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_ptr<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >, COMDAT
; _this$ = esi

; 67   : 		{	// construct base, and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@List_ptr@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 68   : 		}

	mov	eax, esi
	ret	4

; 67   : 		{	// construct base, and allocator from _Al

$LN13@List_ptr@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 68   : 		}

	mov	eax, esi
	ret	4
??0?$_List_ptr@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::_List_ptr<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_ptr<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z
_TEXT	SEGMENT
__Plist$ = 8						; size = 4
??0?$_Iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<0>::_Iterator<0>, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 361  : 			{	// construct with node pointer _Pnode

	mov	edx, DWORD PTR __Plist$[esp-4]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 362  : 			}

	ret	4
??0?$_Iterator@$0A@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<0>::_Iterator<0>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = esi

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN10@Dec@2
	call	__invalid_parameter_noinfo
$LN10@Dec@2:

; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LN9@Dec@2

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], eax

; 336  :    				if (_Isnil(_Ptr))

	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LN1@Dec@2

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;

	jmp	__invalid_parameter_noinfo
$LN9@Dec@2:

; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN46@Dec@2

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN27@Dec@2
$LL28@Dec@2:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL28@Dec@2
$LN27@Dec@2:
	mov	DWORD PTR [esi+4], ecx

; 373  : 				}
; 374  : 			}

	ret	0
$LN46@Dec@2:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN3@Dec@2
	npad	3
$LL4@Dec@2:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec@2

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [esi+4], eax
	mov	edx, eax
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL4@Dec@2
$LN3@Dec@2:

; 358  : 				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LN2@Dec@2

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;

	jmp	__invalid_parameter_noinfo
$LN2@Dec@2:

; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [esi+4], eax
$LN1@Dec@2:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??F?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??F?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator--, COMDAT
; _this$ = esi

; 417  : 			--(*(_Mybase_iter *)this);

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN5@operator@173
	call	__invalid_parameter_noinfo
$LN5@operator@173:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], ecx
	test	eax, eax
	je	SHORT $LN15@operator@173
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN16@operator@173
$LN15@operator@173:
	xor	eax, eax
$LN16@operator@173:
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN19@operator@173
	call	__invalid_parameter_noinfo
$LN19@operator@173:

; 418  : 			return (*this);

	mov	eax, esi

; 419  : 			}

	ret	0
??F?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator--
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z
_TEXT	SEGMENT
??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::_Iterator<1>, COMDAT
; _this$ = esi
; __Pnode$ = eax
; __Plist$ = edi

; 361  : 			{	// construct with node pointer _Pnode

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	test	edi, edi
	jne	SHORT $LN3@Iterator@3
	call	__invalid_parameter_noinfo
$LN3@Iterator@3:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 362  : 			}

	mov	eax, esi
	ret	0
??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PBV12@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::_Iterator<1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = esi

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN10@Dec@3
	call	__invalid_parameter_noinfo
$LN10@Dec@3:

; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+41], 0
	je	SHORT $LN9@Dec@3

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], eax

; 336  :    				if (_Isnil(_Ptr))

	cmp	BYTE PTR [eax+41], 0
	je	SHORT $LN1@Dec@3

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;

	jmp	__invalid_parameter_noinfo
$LN9@Dec@3:

; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+41], 0
	jne	SHORT $LN46@Dec@3

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+41], 0
	jne	SHORT $LN27@Dec@3
$LL28@Dec@3:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+41], 0
	je	SHORT $LL28@Dec@3
$LN27@Dec@3:
	mov	DWORD PTR [esi+4], ecx

; 373  : 				}
; 374  : 			}

	ret	0
$LN46@Dec@3:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+41], 0
	jne	SHORT $LN3@Dec@3
	npad	3
$LL4@Dec@3:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec@3

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [esi+4], eax
	mov	edx, eax
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+41], 0
	je	SHORT $LL4@Dec@3
$LN3@Dec@3:

; 358  : 				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+41], 0
	je	SHORT $LN2@Dec@3

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;

	jmp	__invalid_parameter_noinfo
$LN2@Dec@3:

; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [esi+4], eax
$LN1@Dec@3:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Const_iterator<1>, COMDAT
; _this$ = eax

; 163  : 			{	// construct with null node pointer

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 164  : 			}

	ret	0
??0?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::_Const_iterator<1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >, COMDAT
; _this$ = esi

; 78   : 		{	// construct base, and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@Tree_ptr
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 79   : 		}

	mov	eax, esi
	ret	4

; 78   : 		{	// construct base, and allocator from _Al

$LN18@Tree_ptr:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 79   : 		}

	mov	eax, esi
	ret	4
??0?$_Tree_ptr@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >, COMDAT
; _this$ = esi

; 78   : 		{	// construct base, and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@Tree_ptr@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 79   : 		}

	mov	eax, esi
	ret	4

; 78   : 		{	// construct base, and allocator from _Al

$LN18@Tree_ptr@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 79   : 		}

	mov	eax, esi
	ret	4
??0?$_Tree_ptr@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z PROC ; std::_Vector_val<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_val<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@4
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@4:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ENDP ; std::_Vector_val<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Vector_val<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_val@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_val@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::_List_val<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_val<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >, COMDAT
; _this$ = esi

; 85   : 		{	// construct base, and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@List_val@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 86   : 		}

	mov	eax, esi
	ret	4

; 85   : 		{	// construct base, and allocator from _Al

$LN18@List_val@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 86   : 		}

	mov	eax, esi
	ret	4
??0?$_List_val@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::_List_val<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_List_val<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??0_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 8
??0_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::_List_position, COMDAT
; _this$ = eax

; 269  : 			{

	mov	ecx, DWORD PTR __Iter$[esp-4]
	test	ecx, ecx
	je	SHORT $LN5@List_posit@2
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Iter$[esp]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 270  : 			}

	ret	8

; 269  : 			{

$LN5@List_posit@2:
	mov	edx, DWORD PTR __Iter$[esp]
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 270  : 			}

	ret	8
??0_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::_List_position
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::operator--, COMDAT
; _this$ = eax

; 286  : 			{	// predecrement

	push	esi
	mov	esi, eax

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CB_KI@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CB_KI@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::operator*, COMDAT
; _this$ = esi

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@174
	call	__invalid_parameter_noinfo

; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@174
$LN15@operator@174:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@174
$LN9@operator@174:
	xor	eax, eax
$LN10@operator@174:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN1@operator@174
	call	__invalid_parameter_noinfo
$LN1@operator@174:

; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [esi+4]
	add	eax, 16					; 00000010H

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CB_KI@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 217  : 			{	// construct with null node pointer

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 218  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::_Iterator<1>, COMDAT
; _this$ = eax

; 348  : 		_Iterator()

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 349  : 			{	// construct with null node
; 350  : 			}

	ret	0
??0?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::_Iterator<1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@175
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@175
$LN13@operator@175:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@175
$LN9@operator@175:
	xor	eax, eax
$LN10@operator@175:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@175
	call	__invalid_parameter_noinfo
$LN14@operator@175:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 4

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@176
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@176
$LN13@operator@176:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@176
$LN9@operator@176:
	xor	eax, eax
$LN10@operator@176:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@176
	call	__invalid_parameter_noinfo
$LN14@operator@176:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 24			; 00000018H

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEABV?$vector@IV?$allocator@I@std@@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEABV?$vector@IV?$allocator@I@std@@@1@XZ PROC ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@177
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@177
$LN13@operator@177:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@177
$LN9@operator@177:
	xor	eax, eax
$LN10@operator@177:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@177
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN14@operator@177:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEABV?$vector@IV?$allocator@I@std@@@1@XZ ENDP ; std::_Vector_const_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::operator--, COMDAT
; _this$ = eax

; 286  : 			{	// predecrement

	push	esi
	mov	esi, eax

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 217  : 			{	// construct with null node pointer

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 218  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Container_base_aux_alloc_real<std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@9
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@9:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Container_base_aux_alloc_real<std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@II@std@@@std@@@std@@IAE@V?$allocator@U?$pair@II@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@II@std@@@std@@@std@@IAE@V?$allocator@U?$pair@II@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,unsigned int> > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@10
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@10:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@II@std@@@std@@@std@@IAE@V?$allocator@U?$pair@II@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Container_base_aux_alloc_real<std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@11
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@11:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Container_base_aux_alloc_real<std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::_Container_base_aux_alloc_real<std::allocator<unsigned int> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@12
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@12:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::_Container_base_aux_alloc_real<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >, COMDAT
; _this$ = esi

; 97   : 		{	// construct base, and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@Tree_val
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 98   : 		}

	mov	eax, esi
	ret	4

; 97   : 		{	// construct base, and allocator from _Al

$LN23@Tree_val:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 98   : 		}

	mov	eax, esi
	ret	4
??0?$_Tree_val@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@AB_K@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@AB_K@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN3@Lbound@3
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	push	edi
$LL4@Lbound@3:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	edi, DWORD PTR [ecx+20]
	cmp	edi, edx
	ja	SHORT $LN2@Lbound@3
	jb	SHORT $LN29@Lbound@3
	mov	edi, DWORD PTR [ecx+16]
	cmp	edi, esi
	jae	SHORT $LN2@Lbound@3
$LN29@Lbound@3:

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound@3
$LN2@Lbound@3:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound@3:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL4@Lbound@3
	pop	edi
	pop	esi
$LN3@Lbound@3:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	0
?_Lbound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@AB_K@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Lbound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Init, COMDAT
; _this$ = esi

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode
	mov	DWORD PTR [esi+24], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+33], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+28], 0

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_val<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >, COMDAT
; _this$ = esi

; 97   : 		{	// construct base, and allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@Tree_val@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 98   : 		}

	mov	eax, esi
	ret	4

; 97   : 		{	// construct base, and allocator from _Al

$LN23@Tree_val@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 98   : 		}

	mov	eax, esi
	ret	4
??0?$_Tree_val@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@_K@1@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree_val<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@AB_K@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@AB_K@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+41], 0
	jne	SHORT $LN3@Lbound@4
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	push	edi
$LL4@Lbound@4:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	edi, DWORD PTR [ecx+20]
	cmp	edi, edx
	ja	SHORT $LN2@Lbound@4
	jb	SHORT $LN29@Lbound@4
	mov	edi, DWORD PTR [ecx+16]
	cmp	edi, esi
	jae	SHORT $LN2@Lbound@4
$LN29@Lbound@4:

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound@4
$LN2@Lbound@4:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound@4:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+41], 0
	je	SHORT $LL4@Lbound@4
	pop	edi
	pop	esi
$LN3@Lbound@4:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	0
?_Lbound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@AB_K@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Lbound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Init, COMDAT
; _this$ = esi

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode
	mov	DWORD PTR [esi+24], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+41], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+28], 0

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Init
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ
_TEXT	SEGMENT
?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 544  : 		return (iterator(_Myhead, this));

	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 545  : 		}

	ret	0
?end@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::end
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z$0
__ehfuncinfo$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
xdata$x	ENDS
;	COMDAT ??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >, COMDAT

; 441  : 		{	// construct empty list, allocator

	push	-1
	push	__ehhandler$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+16]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@list@2
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN24@list@2
$LN23@list@2:
	xor	eax, eax
$LN24@list@2:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+28], 0
	call	?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], 0

; 442  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_List_val@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Container_base_aux_alloc_real<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@13
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@13:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Container_base_aux_alloc_real<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Container_base_aux_alloc_real<std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@14
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@14:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@@std@@IAE@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Container_base_aux_alloc_real<std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KI@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KI@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator::operator*, COMDAT
; _this$ = esi

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@178
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@178
$LN17@operator@178:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@178
$LN11@operator@178:
	xor	eax, eax
$LN12@operator@178:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN3@operator@178
	call	__invalid_parameter_noinfo
$LN3@operator@178:
	mov	eax, DWORD PTR [esi+4]
	add	eax, 16					; 00000010H

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KI@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEABIXZ PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@179
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@179
$LN13@operator@179:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@179
$LN9@operator@179:
	xor	eax, eax
$LN10@operator@179:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@179
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN14@operator@179:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEABIXZ ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@180
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@180
$LN15@operator@180:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@180
$LN11@operator@180:
	xor	eax, eax
$LN12@operator@180:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@180
	call	__invalid_parameter_noinfo
$LN16@operator@180:
	add	DWORD PTR [esi+4], 4

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@181
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@181
$LN15@operator@181:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@181
$LN11@operator@181:
	xor	eax, eax
$LN12@operator@181:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@181
	call	__invalid_parameter_noinfo
$LN16@operator@181:
	add	DWORD PTR [esi+4], 24			; 00000018H

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEAAV?$vector@IV?$allocator@I@std@@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEAAV?$vector@IV?$allocator@I@std@@@1@XZ PROC ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator*, COMDAT
; _this$ = esi

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@182
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@182
$LN15@operator@182:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@182
$LN11@operator@182:
	xor	eax, eax
$LN12@operator@182:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@182
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 340  : 		}

	ret	0
$LN16@operator@182:

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 340  : 		}

	ret	0
??D?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEAAV?$vector@IV?$allocator@I@std@@@1@XZ ENDP ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@PAU?$pair@U?$pair@_K_K@std@@U12@@1@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@PAU?$pair@U?$pair@_K_K@std@@U12@@1@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@11
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@11
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@11
$LN3@Vector_ite@11:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@11:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@PAU?$pair@U?$pair@_K_K@std@@U12@@1@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@12
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@12
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@12
$LN3@Vector_ite@12:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@12:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@PAU?$pair@II@1@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@PAU?$pair@II@1@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@13
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@13
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@13
$LN3@Vector_ite@13:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@13:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@PAU?$pair@II@1@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@14
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@14
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@14
$LN3@Vector_ite@14:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@14:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@183
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@183
$LN13@operator@183:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@183
$LN9@operator@183:
	xor	eax, eax
$LN10@operator@183:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@183
	call	__invalid_parameter_noinfo
$LN14@operator@183:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 32			; 00000020H

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEABU?$pair@U?$pair@_K_K@std@@U12@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEABU?$pair@U?$pair@_K_K@std@@U12@@1@XZ PROC ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@184
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@184
$LN13@operator@184:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@184
$LN9@operator@184:
	xor	eax, eax
$LN10@operator@184:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@184
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN14@operator@184:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEABU?$pair@U?$pair@_K_K@std@@U12@@1@XZ ENDP ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@185
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@185
$LN13@operator@185:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@185
$LN9@operator@185:
	xor	eax, eax
$LN10@operator@185:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@185
	call	__invalid_parameter_noinfo
$LN14@operator@185:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 24			; 00000018H

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ PROC ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@186
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@186
$LN13@operator@186:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@186
$LN9@operator@186:
	xor	eax, eax
$LN10@operator@186:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@186
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN14@operator@186:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ ENDP ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@187
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@187
$LN13@operator@187:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@187
$LN9@operator@187:
	xor	eax, eax
$LN10@operator@187:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@187
	call	__invalid_parameter_noinfo
$LN14@operator@187:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 8

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEABU?$pair@II@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEABU?$pair@II@1@XZ PROC ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@188
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@188
$LN13@operator@188:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@188
$LN9@operator@188:
	xor	eax, eax
$LN10@operator@188:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@188
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN14@operator@188:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEABU?$pair@II@1@XZ ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@189
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@189
$LN13@operator@189:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@189
$LN9@operator@189:
	xor	eax, eax
$LN10@operator@189:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@189
	call	__invalid_parameter_noinfo
$LN14@operator@189:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 24			; 00000018H

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ PROC ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@190
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@190
$LN13@operator@190:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@190
$LN9@operator@190:
	xor	eax, eax
$LN10@operator@190:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@190
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN14@operator@190:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ ENDP ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator++, COMDAT
; _this$ = esi

; 236  : 
; 237  :  #if _HAS_ITERATOR_DEBUGGING
; 238  : 			if (this->_Mycont == 0
; 239  : 				|| _Ptr == 0
; 240  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 241  : 				{
; 242  : 				_DEBUG_ERROR("list iterator not incrementable");
; 243  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 244  : 				}
; 245  :  #else
; 246  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@191
	call	__invalid_parameter_noinfo

; 247  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@191
$LN17@operator@191:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@191
$LN11@operator@191:
	xor	eax, eax
$LN12@operator@191:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN1@operator@191
	call	__invalid_parameter_noinfo
$LN1@operator@191:

; 248  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 249  : 
; 250  : 			_Ptr = _Nextnode(_Ptr);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+4], eax

; 251  : 			return (*this);

	mov	eax, esi

; 252  : 			}

	ret	0
??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator++
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAE@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAE@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@1@@Z PROC ; std::_Vector_val<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Vector_val<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@5
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@5:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAE@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@1@@Z ENDP ; std::_Vector_val<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Vector_val<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAE@V?$allocator@U?$pair@II@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAE@V?$allocator@U?$pair@II@std@@@1@@Z PROC ; std::_Vector_val<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Vector_val<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@6
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@6:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAE@V?$allocator@U?$pair@II@std@@@1@@Z ENDP ; std::_Vector_val<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Vector_val<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@1@@Z PROC ; std::_Vector_val<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Vector_val<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@7
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@7:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@1@@Z ENDP ; std::_Vector_val<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Vector_val<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@8
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@8:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::lower_bound, COMDAT
; ___$ReturnUdt$ = eax
; __Keyval$ = ecx

; 1003 : 		{	// find leftmost node not less than _Keyval in mutable tree

	push	ebx
	mov	ebx, DWORD PTR _this$[esp]

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	edx, DWORD PTR [ebx+24]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [edx+4]
	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN5@lower_boun@3
	push	ebp
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	npad	5
$LL6@lower_boun@3:
	mov	ebp, DWORD PTR [ecx+20]
	cmp	ebp, esi
	ja	SHORT $LN4@lower_boun@3
	jb	SHORT $LN44@lower_boun@3
	mov	ebp, DWORD PTR [ecx+16]
	cmp	ebp, edi
	jae	SHORT $LN4@lower_boun@3
$LN44@lower_boun@3:
	mov	ecx, DWORD PTR [ecx+8]
	jmp	SHORT $LN3@lower_boun@3
$LN4@lower_boun@3:
	mov	edx, ecx
	mov	ecx, DWORD PTR [ecx]
$LN3@lower_boun@3:
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL6@lower_boun@3
	pop	edi
	pop	ebp
$LN5@lower_boun@3:
	mov	ecx, DWORD PTR [ebx]
	pop	esi
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 1005 : 		}

	ret	4
?lower_bound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::lower_bound
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >, COMDAT

; 509  : 		{	// construct empty tree

	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+16]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN28@Tree
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN29@Tree
$LN28@Tree:
	xor	eax, eax
$LN29@Tree:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+28], 0

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode
	mov	DWORD PTR [esi+24], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+28], 0

; 511  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::lower_bound, COMDAT
; ___$ReturnUdt$ = eax
; __Keyval$ = ecx

; 1003 : 		{	// find leftmost node not less than _Keyval in mutable tree

	push	ebx
	mov	ebx, DWORD PTR _this$[esp]

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	edx, DWORD PTR [ebx+24]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [edx+4]
	cmp	BYTE PTR [ecx+41], 0
	jne	SHORT $LN5@lower_boun@4
	push	ebp
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	npad	5
$LL6@lower_boun@4:
	mov	ebp, DWORD PTR [ecx+20]
	cmp	ebp, esi
	ja	SHORT $LN4@lower_boun@4
	jb	SHORT $LN44@lower_boun@4
	mov	ebp, DWORD PTR [ecx+16]
	cmp	ebp, edi
	jae	SHORT $LN4@lower_boun@4
$LN44@lower_boun@4:
	mov	ecx, DWORD PTR [ecx+8]
	jmp	SHORT $LN3@lower_boun@4
$LN4@lower_boun@4:
	mov	edx, ecx
	mov	ecx, DWORD PTR [ecx]
$LN3@lower_boun@4:
	cmp	BYTE PTR [ecx+41], 0
	je	SHORT $LL6@lower_boun@4
	pop	edi
	pop	ebp
$LN5@lower_boun@4:
	mov	ecx, DWORD PTR [ebx]
	pop	esi
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 1005 : 		}

	ret	4
?lower_bound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::lower_bound
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >, COMDAT

; 509  : 		{	// construct empty tree

	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+16]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN28@Tree@2
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN29@Tree@2
$LN28@Tree@2:
	xor	eax, eax
$LN29@Tree@2:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+28], 0

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode
	mov	DWORD PTR [esi+24], eax
	mov	BYTE PTR [eax+41], 1
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+28], 0

; 511  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ
_TEXT	SEGMENT
?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 387  : 		return (_List.end());

	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 388  : 		}

	ret	0
?end@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@XZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::end
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@IAE@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@IAE@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@@Z PROC ; std::_Vector_val<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Vector_val<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@9
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@9:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@IAE@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@@Z ENDP ; std::_Vector_val<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Vector_val<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@1@@Z PROC ; std::_Vector_val<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Vector_val<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@10
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@10:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@IAE@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@1@@Z ENDP ; std::_Vector_val<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Vector_val<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@192
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@192
$LN17@operator@192:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@192
$LN13@operator@192:
	xor	eax, eax
$LN14@operator@192:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@192
	call	__invalid_parameter_noinfo
$LN18@operator@192:
	add	DWORD PTR [esi+4], 4

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEAAIXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEAAIXZ PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator*, COMDAT
; _this$ = esi

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@193
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@193
$LN15@operator@193:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@193
$LN11@operator@193:
	xor	eax, eax
$LN12@operator@193:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@193
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 340  : 		}

	ret	0
$LN16@operator@193:

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 340  : 		}

	ret	0
??D?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEAAIXZ ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@194
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@194
$LN17@operator@194:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@194
$LN13@operator@194:
	xor	eax, eax
$LN14@operator@194:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@194
	call	__invalid_parameter_noinfo
$LN18@operator@194:
	add	DWORD PTR [esi+4], 24			; 00000018H

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEPAV?$vector@IV?$allocator@I@std@@@1@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEPAV?$vector@IV?$allocator@I@std@@@1@XZ PROC ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator->, COMDAT
; _this$ = esi

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@195
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@195
$LN17@operator@195:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@195
$LN13@operator@195:
	xor	eax, eax
$LN14@operator@195:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@195
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 345  : 		}

	ret	0
$LN18@operator@195:

; 344  : 		return (&**this);

	mov	eax, ecx

; 345  : 		}

	ret	0
??C?$_Vector_iterator@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QBEPAV?$vector@IV?$allocator@I@std@@@1@XZ ENDP ; std::_Vector_iterator<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 131  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 132  : 		++*this;

	test	eax, eax
	jne	SHORT $LN15@operator@196
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@196
$LN15@operator@196:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@196
$LN11@operator@196:
	xor	eax, eax
$LN12@operator@196:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@196
	call	__invalid_parameter_noinfo
$LN16@operator@196:
	add	DWORD PTR [esi+4], 32			; 00000020H

; 133  : 		return (_Tmp);

	mov	eax, edi

; 134  : 		}

	ret	0
??E?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEPBU?$pair@U?$pair@_K_K@std@@U12@@1@XZ
_TEXT	SEGMENT
??C?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEPBU?$pair@U?$pair@_K_K@std@@U12@@1@XZ PROC ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator->, COMDAT
; _this$ = esi

; 111  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@197
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@197
$LN15@operator@197:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@197
$LN11@operator@197:
	xor	eax, eax
$LN12@operator@197:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@197
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 112  : 		}

	ret	0
$LN16@operator@197:

; 111  : 		return (&**this);

	mov	eax, ecx

; 112  : 		}

	ret	0
??C?$_Vector_const_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEPBU?$pair@U?$pair@_K_K@std@@U12@@1@XZ ENDP ; std::_Vector_const_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 131  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 132  : 		++*this;

	test	eax, eax
	jne	SHORT $LN15@operator@198
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@198
$LN15@operator@198:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@198
$LN11@operator@198:
	xor	eax, eax
$LN12@operator@198:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@198
	call	__invalid_parameter_noinfo
$LN16@operator@198:
	add	DWORD PTR [esi+4], 24			; 00000018H

; 133  : 		return (_Tmp);

	mov	eax, edi

; 134  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEPBV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ
_TEXT	SEGMENT
??C?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEPBV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ PROC ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator->, COMDAT
; _this$ = esi

; 111  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@199
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@199
$LN15@operator@199:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@199
$LN11@operator@199:
	xor	eax, eax
$LN12@operator@199:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@199
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 112  : 		}

	ret	0
$LN16@operator@199:

; 111  : 		return (&**this);

	mov	eax, ecx

; 112  : 		}

	ret	0
??C?$_Vector_const_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEPBV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ ENDP ; std::_Vector_const_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 131  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 132  : 		++*this;

	test	eax, eax
	jne	SHORT $LN15@operator@200
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@200
$LN15@operator@200:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@200
$LN11@operator@200:
	xor	eax, eax
$LN12@operator@200:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@200
	call	__invalid_parameter_noinfo
$LN16@operator@200:
	add	DWORD PTR [esi+4], 8

; 133  : 		return (_Tmp);

	mov	eax, edi

; 134  : 		}

	ret	0
??E?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEPBU?$pair@II@1@XZ
_TEXT	SEGMENT
??C?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEPBU?$pair@II@1@XZ PROC ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator->, COMDAT
; _this$ = esi

; 111  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@201
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@201
$LN15@operator@201:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@201
$LN11@operator@201:
	xor	eax, eax
$LN12@operator@201:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@201
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 112  : 		}

	ret	0
$LN16@operator@201:

; 111  : 		return (&**this);

	mov	eax, ecx

; 112  : 		}

	ret	0
??C?$_Vector_const_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEPBU?$pair@II@1@XZ ENDP ; std::_Vector_const_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 131  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 132  : 		++*this;

	test	eax, eax
	jne	SHORT $LN15@operator@202
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@202
$LN15@operator@202:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@202
$LN11@operator@202:
	xor	eax, eax
$LN12@operator@202:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@202
	call	__invalid_parameter_noinfo
$LN16@operator@202:
	add	DWORD PTR [esi+4], 24			; 00000018H

; 133  : 		return (_Tmp);

	mov	eax, edi

; 134  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEPBV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ
_TEXT	SEGMENT
??C?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEPBV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ PROC ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator->, COMDAT
; _this$ = esi

; 111  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@203
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@203
$LN15@operator@203:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@203
$LN11@operator@203:
	xor	eax, eax
$LN12@operator@203:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@203
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 112  : 		}

	ret	0
$LN16@operator@203:

; 111  : 		return (&**this);

	mov	eax, ecx

; 112  : 		}

	ret	0
??C?$_Vector_const_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEPBV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ ENDP ; std::_Vector_const_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator->
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::operator*, COMDAT
; _this$ = esi

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@204
	call	__invalid_parameter_noinfo

; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@204
$LN15@operator@204:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@204
$LN9@operator@204:
	xor	eax, eax
$LN10@operator@204:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN1@operator@204
	call	__invalid_parameter_noinfo
$LN1@operator@204:

; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [esi+4]
	add	eax, 16					; 00000010H

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV012@H@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 256  : 			_Myt_iter _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 257  : 			++*this;

	test	eax, eax
	jne	SHORT $LN19@operator@205
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@205
$LN19@operator@205:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@205
$LN13@operator@205:
	xor	eax, eax
$LN14@operator@205:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN3@operator@205
	call	__invalid_parameter_noinfo
$LN3@operator@205:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+4], ecx

; 258  : 			return (_Tmp);

	mov	eax, edi

; 259  : 			}

	ret	0
??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV012@H@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEABU?$pair@$$CBII@2@XZ
_TEXT	SEGMENT
??D?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEABU?$pair@$$CBII@2@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator*, COMDAT
; _this$ = esi

; 212  : 
; 213  :  #if _HAS_ITERATOR_DEBUGGING
; 214  : 			if (this->_Mycont == 0
; 215  : 				|| _Ptr == 0
; 216  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 217  : 				{
; 218  : 				_DEBUG_ERROR("list iterator not dereferencable");
; 219  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 220  : 				}
; 221  :  #else
; 222  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@206
	call	__invalid_parameter_noinfo

; 223  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@206
$LN17@operator@206:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@206
$LN11@operator@206:
	xor	eax, eax
$LN12@operator@206:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN1@operator@206
	call	__invalid_parameter_noinfo
$LN1@operator@206:

; 224  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 225  : 
; 226  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [esi+4]
	add	eax, 8

; 227  : 			}

	ret	0
??D?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEABU?$pair@$$CBII@2@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?end@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ
_TEXT	SEGMENT
?end@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@31
	call	__invalid_parameter_noinfo
$LN6@end@31:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@34
	call	__invalid_parameter_noinfo
$LN6@begin@34:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@XZ ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ
_TEXT	SEGMENT
?end@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ PROC ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@32
	call	__invalid_parameter_noinfo
$LN6@end@32:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ ENDP ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ PROC ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@35
	call	__invalid_parameter_noinfo
$LN6@begin@35:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@XZ ENDP ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
?end@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@33
	call	__invalid_parameter_noinfo
$LN6@end@33:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@36
	call	__invalid_parameter_noinfo
$LN6@begin@36:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 571  : 		return (_TREE_CONST_ITERATOR(_Myhead));

	mov	edx, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 572  : 		}

	ret	0
?end@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 561  : 		return (_TREE_CONST_ITERATOR(_Lmost()));

	mov	edx, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 562  : 		}

	ret	0
?begin@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
?end@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@34
	call	__invalid_parameter_noinfo
$LN6@end@34:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ PROC ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@37
	call	__invalid_parameter_noinfo
$LN6@begin@37:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@2@XZ ENDP ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 8
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::forward_iterator_tag>, COMDAT

; 2991 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	esi

; 2992 : 	for (; _First1 != _Last1; ++_First1, ++_First2)

$LL9@Equal@8:
	mov	eax, DWORD PTR __First1$[esp]
	test	eax, eax
	je	SHORT $LN13@Equal@8
	cmp	eax, DWORD PTR __Last1$[esp]
	je	SHORT $LN14@Equal@8
$LN13@Equal@8:
	call	__invalid_parameter_noinfo
$LN14@Equal@8:
	mov	eax, DWORD PTR __First1$[esp+4]
	cmp	eax, DWORD PTR __Last1$[esp+4]
	je	$LN2@Equal@8

; 2993 : 		if (!(*_First1 == *_First2))

	mov	eax, DWORD PTR __First2$[esp]
	test	eax, eax
	jne	SHORT $LN56@Equal@8
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First2$[esp]
	test	eax, eax
	je	SHORT $LN29@Equal@8
$LN56@Equal@8:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN30@Equal@8
$LN29@Equal@8:
	xor	eax, eax
$LN30@Equal@8:
	mov	ecx, DWORD PTR __First2$[esp+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN21@Equal@8
	call	__invalid_parameter_noinfo
$LN21@Equal@8:
	mov	esi, DWORD PTR __First2$[esp+4]
	mov	eax, DWORD PTR __First1$[esp]
	add	esi, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN55@Equal@8
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First1$[esp]
	test	eax, eax
	je	SHORT $LN43@Equal@8
$LN55@Equal@8:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN44@Equal@8
$LN43@Equal@8:
	xor	eax, eax
$LN44@Equal@8:
	mov	edx, DWORD PTR __First1$[esp+4]
	cmp	edx, DWORD PTR [eax+24]
	jne	SHORT $LN35@Equal@8
	call	__invalid_parameter_noinfo
$LN35@Equal@8:
	mov	eax, DWORD PTR __First1$[esp+4]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN51@Equal@8
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [esi+4]
	jne	SHORT $LN51@Equal@8
	mov	eax, DWORD PTR [eax+24]
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN51@Equal@8
	lea	esi, DWORD PTR __First1$[esp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Inc
	lea	esi, DWORD PTR __First2$[esp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Inc
	jmp	$LL9@Equal@8
$LN51@Equal@8:

; 2994 : 			return (false);

	xor	al, al
	pop	esi

; 2996 : 	}

	ret	0
$LN2@Equal@8:

; 2995 : 	return (true);

	mov	al, 1
	pop	esi

; 2996 : 	}

	ret	0
??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 8
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::forward_iterator_tag>, COMDAT

; 2991 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	esi

; 2992 : 	for (; _First1 != _Last1; ++_First1, ++_First2)

$LL9@Equal@9:
	mov	eax, DWORD PTR __First1$[esp]
	test	eax, eax
	je	SHORT $LN13@Equal@9
	cmp	eax, DWORD PTR __Last1$[esp]
	je	SHORT $LN14@Equal@9
$LN13@Equal@9:
	call	__invalid_parameter_noinfo
$LN14@Equal@9:
	mov	eax, DWORD PTR __First1$[esp+4]
	cmp	eax, DWORD PTR __Last1$[esp+4]
	je	$LN2@Equal@9

; 2993 : 		if (!(*_First1 == *_First2))

	mov	eax, DWORD PTR __First2$[esp]
	test	eax, eax
	jne	SHORT $LN60@Equal@9
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First2$[esp]
	test	eax, eax
	je	SHORT $LN29@Equal@9
$LN60@Equal@9:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN30@Equal@9
$LN29@Equal@9:
	xor	eax, eax
$LN30@Equal@9:
	mov	ecx, DWORD PTR __First2$[esp+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN21@Equal@9
	call	__invalid_parameter_noinfo
$LN21@Equal@9:
	mov	esi, DWORD PTR __First2$[esp+4]
	mov	eax, DWORD PTR __First1$[esp]
	add	esi, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN59@Equal@9
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First1$[esp]
	test	eax, eax
	je	SHORT $LN43@Equal@9
$LN59@Equal@9:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN44@Equal@9
$LN43@Equal@9:
	xor	eax, eax
$LN44@Equal@9:
	mov	edx, DWORD PTR __First1$[esp+4]
	cmp	edx, DWORD PTR [eax+24]
	jne	SHORT $LN35@Equal@9
	call	__invalid_parameter_noinfo
$LN35@Equal@9:
	mov	eax, DWORD PTR __First1$[esp+4]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN55@Equal@9
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [esi+4]
	jne	SHORT $LN55@Equal@9
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR [esi+8]
	jne	SHORT $LN55@Equal@9
	mov	edx, DWORD PTR [eax+28]
	cmp	edx, DWORD PTR [esi+12]
	jne	SHORT $LN55@Equal@9
	mov	eax, DWORD PTR [eax+32]
	cmp	eax, DWORD PTR [esi+16]
	jne	SHORT $LN55@Equal@9
	lea	esi, DWORD PTR __First1$[esp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Inc
	lea	esi, DWORD PTR __First2$[esp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Inc
	jmp	$LL9@Equal@9
$LN55@Equal@9:

; 2994 : 			return (false);

	xor	al, al
	pop	esi

; 2996 : 	}

	ret	0
$LN2@Equal@9:

; 2995 : 	return (true);

	mov	al, 1
	pop	esi

; 2996 : 	}

	ret	0
??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00@Z
_TEXT	SEGMENT
$T429556 = -4						; size = 1
__First1$ = 8						; size = 8
$T429557 = 16						; size = 1
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00@Z PROC ; std::equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>, COMDAT

; 3055 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ecx

; 3056 : 	return _Equal(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _First2,
; 3057 : 		_Iter_random(_First1, _First2), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T429557[esp]
	mov	edx, DWORD PTR __First2$[esp+4]
	mov	BYTE PTR $T429556[esp+4], 0
	mov	eax, DWORD PTR $T429556[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+20]
	push	edx
	push	eax
	push	ecx
	call	??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::forward_iterator_tag>

; 3058 : 	}

	add	esp, 36					; 00000024H
	ret	0
??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00@Z ENDP ; std::equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00@Z
_TEXT	SEGMENT
$T429585 = -4						; size = 1
__First1$ = 8						; size = 8
$T429586 = 16						; size = 1
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00@Z PROC ; std::equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>, COMDAT

; 3055 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ecx

; 3056 : 	return _Equal(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _First2,
; 3057 : 		_Iter_random(_First1, _First2), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T429586[esp]
	mov	edx, DWORD PTR __First2$[esp+4]
	mov	BYTE PTR $T429585[esp+4], 0
	mov	eax, DWORD PTR $T429585[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+20]
	push	edx
	push	eax
	push	ecx
	call	??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::forward_iterator_tag>

; 3058 : 	}

	add	esp, 36					; 00000024H
	ret	0
??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00@Z ENDP ; std::equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??C?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPBU?$pair@$$CBII@2@XZ
_TEXT	SEGMENT
??C?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPBU?$pair@$$CBII@2@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator->, COMDAT
; _this$ = esi

; 231  : 			return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN19@operator@304
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@304
$LN19@operator@304:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@304
$LN13@operator@304:
	xor	eax, eax
$LN14@operator@304:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN3@operator@304
	call	__invalid_parameter_noinfo
$LN3@operator@304:
	mov	eax, DWORD PTR [esi+4]
	add	eax, 8

; 232  : 			}

	ret	0
??C?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEPBU?$pair@$$CBII@2@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator->
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??$?8V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
$T429858 = -4						; size = 1
$T429859 = -4						; size = 1
??$?8V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z PROC ; std::operator==<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 1454 : 	{	// test for _Tree equality

	push	ecx

; 1455 : 	return (_Left.size() == _Right.size()
; 1456 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	mov	edx, DWORD PTR [ecx+28]
	cmp	edx, DWORD PTR [eax+28]
	jne	SHORT $LN3@operator@305
	mov	edx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [edx]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	BYTE PTR $T429858[esp+16], 0
	mov	ebx, DWORD PTR $T429858[esp+16]
	push	ebx
	mov	ebx, DWORD PTR $T429859[esp+20]
	push	ebx
	push	edx
	push	esi
	push	eax
	push	ecx
	push	edi
	push	ecx
	call	??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator,std::forward_iterator_tag>
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebx
	test	al, al
	je	SHORT $LN3@operator@305
	mov	eax, 1

; 1457 : 	}

	pop	ecx
	ret	0
$LN3@operator@305:

; 1455 : 	return (_Left.size() == _Right.size()
; 1456 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	xor	eax, eax

; 1457 : 	}

	pop	ecx
	ret	0
??$?8V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z ENDP ; std::operator==<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?8V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
$T430086 = -4						; size = 1
$T430087 = -4						; size = 1
??$?8V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z PROC ; std::operator==<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 1454 : 	{	// test for _Tree equality

	push	ecx

; 1455 : 	return (_Left.size() == _Right.size()
; 1456 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	mov	edx, DWORD PTR [ecx+28]
	cmp	edx, DWORD PTR [eax+28]
	jne	SHORT $LN3@operator@306
	mov	edx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [edx]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	BYTE PTR $T430086[esp+16], 0
	mov	ebx, DWORD PTR $T430086[esp+16]
	push	ebx
	mov	ebx, DWORD PTR $T430087[esp+20]
	push	ebx
	push	edx
	push	esi
	push	eax
	push	ecx
	push	edi
	push	ecx
	call	??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator,std::forward_iterator_tag>
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebx
	test	al, al
	je	SHORT $LN3@operator@306
	mov	eax, 1

; 1457 : 	}

	pop	ecx
	ret	0
$LN3@operator@306:

; 1455 : 	return (_Left.size() == _Right.size()
; 1456 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	xor	eax, eax

; 1457 : 	}

	pop	ecx
	ret	0
??$?8V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z ENDP ; std::operator==<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 554  : 		return (iterator(_Where._Ptr, this));

	mov	eax, DWORD PTR __Where$[esp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	test	edi, edi
	jne	SHORT $LN5@Make_iter@18
	call	__invalid_parameter_noinfo
$LN5@Make_iter@18:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 555  : 		}

	ret	8
?_Make_iter@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Make_iter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ
_TEXT	SEGMENT
?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 534  : 		return (iterator(_Nextnode(_Myhead), this));

	mov	edx, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 535  : 		}

	ret	0
?begin@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Get_iter@_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABV56@@Z
_TEXT	SEGMENT
?_Get_iter@_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABV56@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::_Get_iter, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __List$ = edi

; 281  : 			// reparent the iterator
; 282  : 			return (_Myiterator(_Mypos._Mynode(), &_List));

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], ecx
	test	edi, edi
	jne	SHORT $LN7@Get_iter@2
	call	__invalid_parameter_noinfo
$LN7@Get_iter@2:
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [esi], edx
	mov	eax, esi

; 283  : 			}

	ret	0
?_Get_iter@_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABV56@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position::_Get_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator::operator--, COMDAT
; _this$ = eax

; 487  : 			{	// predecrement

	push	esi
	mov	esi, eax

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator::operator--, COMDAT
; _this$ = eax

; 487  : 			{	// predecrement

	push	esi
	mov	esi, eax

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z
_TEXT	SEGMENT
$T430275 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase, COMDAT
; _this$ = edi

; 786  : 		{	// erase element at _Where

	sub	esp, 8

; 787  : 
; 788  :  #if _HAS_ITERATOR_DEBUGGING
; 789  : 		if (_Where._Mycont != this || _Where._Ptr == _Myhead)
; 790  : 			_DEBUG_ERROR("list erase iterator outside range");
; 791  : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 792  : 		_Orphan_ptr(*this, _Pnode);
; 793  : 
; 794  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 795  : 		_Nodeptr _Pnode = (_Where++)._Mynode();

	mov	eax, DWORD PTR __Where$[esp+4]
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+8]
	push	esi
	mov	esi, DWORD PTR __Where$[esp+16]
	mov	DWORD PTR $T430275[esp+16], eax
	test	eax, eax
	jne	SHORT $LN54@erase@11
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp+12]
	test	eax, eax
	je	SHORT $LN16@erase@11
$LN54@erase@11:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@erase@11
$LN16@erase@11:
	xor	eax, eax
$LN17@erase@11:
	mov	ecx, DWORD PTR __Where$[esp+16]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN6@erase@11
	call	__invalid_parameter_noinfo
$LN6@erase@11:
	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Where$[esp+16], eax

; 796  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 797  : 
; 798  : 		if (_Pnode != _Myhead)

	cmp	esi, DWORD PTR [edi+20]
	je	SHORT $LN1@erase@11

; 799  : 			{	// not list head, safe to erase
; 800  : 			_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], edx

; 801  : 			_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]

; 802  : 			this->_Alnod.destroy(_Pnode);
; 803  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	esi
	mov	DWORD PTR [eax+4], ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 804  : 			--_Mysize;

	dec	DWORD PTR [edi+24]
$LN1@erase@11:

; 805  : 			}
; 806  : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR __Where$[esp+16]
	mov	DWORD PTR [ebx], eax

; 807  : 		}

	pop	esi
	mov	DWORD PTR [ebx+4], edx
	mov	eax, ebx
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH
?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator++, COMDAT
; _this$ = esi

; 404  : 			++(*(_Mybase_iter *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN19@operator@307
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@307
$LN19@operator@307:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@307
$LN13@operator@307:
	xor	eax, eax
$LN14@operator@307:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN3@operator@307
	call	__invalid_parameter_noinfo
$LN3@operator@307:
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+4], eax

; 405  : 			return (*this);

	mov	eax, esi

; 406  : 			}

	ret	0
??E?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator++
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Get_iter_from_vec@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABU_List_position@12@@Z
_TEXT	SEGMENT
?_Get_iter_from_vec@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABU_List_position@12@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Get_iter_from_vec, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi
; __Pos$ = eax

; 312  : 	{

	push	edi

; 313  : 	return (_Pos._Get_iter(_List));

	mov	edi, ecx
	add	edi, 8
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], ecx
	jne	SHORT $LN9@Get_iter_f@2
	call	__invalid_parameter_noinfo
$LN9@Get_iter_f@2:
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [esi], edx
	mov	eax, esi
	pop	edi

; 314  : 	}

	ret	0
?_Get_iter_from_vec@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABU_List_position@12@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Get_iter_from_vec
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator::operator*, COMDAT
; _this$ = esi

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@308
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@308
$LN17@operator@308:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@308
$LN11@operator@308:
	xor	eax, eax
$LN12@operator@308:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN3@operator@308
	call	__invalid_parameter_noinfo
$LN3@operator@308:
	mov	eax, DWORD PTR [esi+4]
	add	eax, 16					; 00000010H

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??D?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEAAU?$pair@$$CBII@2@XZ
_TEXT	SEGMENT
??D?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEAAU?$pair@$$CBII@2@XZ PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator*, COMDAT
; _this$ = esi

; 394  : 			return ((reference)**(_Mybase_iter *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN19@operator@309
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@309
$LN19@operator@309:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@309
$LN13@operator@309:
	xor	eax, eax
$LN14@operator@309:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN3@operator@309
	call	__invalid_parameter_noinfo
$LN3@operator@309:
	mov	eax, DWORD PTR [esi+4]
	add	eax, 8

; 395  : 			}

	ret	0
??D?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBEAAU?$pair@$$CBII@2@XZ ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Iterator<1>::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@310
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@310
$LN15@operator@310:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@310
$LN11@operator@310:
	xor	eax, eax
$LN12@operator@310:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@310
	call	__invalid_parameter_noinfo
$LN16@operator@310:
	add	DWORD PTR [esi+4], 32			; 00000020H

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEAAU?$pair@U?$pair@_K_K@std@@U12@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEAAU?$pair@U?$pair@_K_K@std@@U12@@1@XZ PROC ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator*, COMDAT
; _this$ = esi

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@311
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@311
$LN15@operator@311:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@311
$LN11@operator@311:
	xor	eax, eax
$LN12@operator@311:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@311
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 340  : 		}

	ret	0
$LN16@operator@311:

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 340  : 		}

	ret	0
??D?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEAAU?$pair@U?$pair@_K_K@std@@U12@@1@XZ ENDP ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@312
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@312
$LN15@operator@312:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@312
$LN11@operator@312:
	xor	eax, eax
$LN12@operator@312:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@312
	call	__invalid_parameter_noinfo
$LN16@operator@312:
	add	DWORD PTR [esi+4], 24			; 00000018H

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEAAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEAAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ PROC ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator*, COMDAT
; _this$ = esi

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@313
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@313
$LN15@operator@313:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@313
$LN11@operator@313:
	xor	eax, eax
$LN12@operator@313:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@313
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 340  : 		}

	ret	0
$LN16@operator@313:

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 340  : 		}

	ret	0
??D?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEAAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ ENDP ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@314
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@314
$LN15@operator@314:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@314
$LN11@operator@314:
	xor	eax, eax
$LN12@operator@314:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@314
	call	__invalid_parameter_noinfo
$LN16@operator@314:
	add	DWORD PTR [esi+4], 8

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEAAU?$pair@II@1@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEAAU?$pair@II@1@XZ PROC ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator*, COMDAT
; _this$ = esi

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@315
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@315
$LN15@operator@315:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@315
$LN11@operator@315:
	xor	eax, eax
$LN12@operator@315:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@315
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 340  : 		}

	ret	0
$LN16@operator@315:

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 340  : 		}

	ret	0
??D?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEAAU?$pair@II@1@XZ ENDP ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@316
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@316
$LN15@operator@316:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@316
$LN11@operator@316:
	xor	eax, eax
$LN12@operator@316:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@316
	call	__invalid_parameter_noinfo
$LN16@operator@316:
	add	DWORD PTR [esi+4], 24			; 00000018H

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEAAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEAAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ PROC ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator*, COMDAT
; _this$ = esi

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@317
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@317
$LN15@operator@317:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@317
$LN11@operator@317:
	xor	eax, eax
$LN12@operator@317:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@317
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 340  : 		}

	ret	0
$LN16@operator@317:

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 340  : 		}

	ret	0
??D?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEAAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ ENDP ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z
_TEXT	SEGMENT
$T431140 = -16						; size = 4
$T430907 = -16						; size = 8
__Where$ = -8						; size = 8
tv540 = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Keyval$ = 16						; size = 4
?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound, COMDAT

; 638  : 		size_type _Bucket = _Hashval(_Keyval);

	mov	eax, DWORD PTR __Keyval$[esp-4]
	mov	ecx, DWORD PTR [eax]
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+16]
	push	ebp
	push	esi
	push	edi
	push	127773					; 0001f31dH
	push	ecx
	call	_ldiv
	imul	edx, 16807				; 000041a7H
	imul	eax, 2836				; 00000b14H
	add	esp, 8
	sub	edx, eax
	jns	SHORT $LN14@lower_boun@6
	add	edx, 2147483647				; 7fffffffH
$LN14@lower_boun@6:
	mov	eax, DWORD PTR [ebx+60]
	mov	esi, eax
	and	esi, edx
	cmp	DWORD PTR [ebx+64], esi
	ja	SHORT $LN9@lower_boun@6
	shr	eax, 1
	or	edx, -1
	sub	edx, eax
	add	esi, edx
$LN9@lower_boun@6:

; 639  : 		iterator _Where;
; 640  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	mov	eax, DWORD PTR [ebx+52]
	sub	eax, DWORD PTR [ebx+48]
	sar	eax, 3
	cmp	esi, eax
	jb	SHORT $LN27@lower_boun@6
	call	__invalid_parameter_noinfo
$LN27@lower_boun@6:
	mov	ecx, DWORD PTR [ebx+48]
	mov	edi, DWORD PTR [ecx+esi*8+4]
	lea	ebp, DWORD PTR [ebx+8]
	mov	DWORD PTR tv540[esp+28], ebp
	test	ebp, ebp
	jne	SHORT $LN40@lower_boun@6
	call	__invalid_parameter_noinfo
$LN40@lower_boun@6:
	mov	ebp, DWORD PTR [ebp]
	inc	esi
	mov	DWORD PTR __Where$[esp+32], ebp
	mov	DWORD PTR __Where$[esp+36], edi

; 642  : 				return (this->comp(_Keyval,
; 643  : 					this->_Kfn(*_Where)) ? end() : _Where);

	mov	DWORD PTR $T431140[esp+32], esi
$LL58@lower_boun@6:
	mov	edx, DWORD PTR [ebx+52]
	sub	edx, DWORD PTR [ebx+48]
	sar	edx, 3
	cmp	esi, edx
	jb	SHORT $LN70@lower_boun@6

; 639  : 		iterator _Where;
; 640  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	call	__invalid_parameter_noinfo
$LN70@lower_boun@6:
	mov	eax, DWORD PTR [ebx+48]
	cmp	DWORD PTR [eax+esi*8+4], edi
	je	$LN2@lower_boun@6

; 641  : 			if (!this->comp(this->_Kfn(*_Where), _Keyval))

	test	ebp, ebp
	jne	SHORT $LN171@lower_boun@6
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN96@lower_boun@6:
	cmp	edi, DWORD PTR [eax+20]
	jne	SHORT $LN85@lower_boun@6
	call	__invalid_parameter_noinfo
$LN85@lower_boun@6:
	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR __Keyval$[esp+28]
	cmp	ecx, DWORD PTR [esi]
	je	SHORT $LN168@lower_boun@6

; 639  : 		iterator _Where;
; 640  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	test	ebp, ebp
	jne	SHORT $LN170@lower_boun@6
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN65@lower_boun@6:
	cmp	edi, DWORD PTR [eax+20]
	jne	SHORT $LN54@lower_boun@6
	call	__invalid_parameter_noinfo
$LN54@lower_boun@6:
	mov	edi, DWORD PTR [edi]
	mov	esi, DWORD PTR $T431140[esp+32]
	jmp	SHORT $LL58@lower_boun@6
$LN171@lower_boun@6:

; 641  : 			if (!this->comp(this->_Kfn(*_Where), _Keyval))

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN96@lower_boun@6
$LN170@lower_boun@6:

; 639  : 		iterator _Where;
; 640  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN65@lower_boun@6
$LN168@lower_boun@6:
	mov	DWORD PTR __Where$[esp+36], edi

; 642  : 				return (this->comp(_Keyval,
; 643  : 					this->_Kfn(*_Where)) ? end() : _Where);

	test	ebp, ebp
	jne	SHORT $LN169@lower_boun@6
	call	__invalid_parameter_noinfo
$LN120@lower_boun@6:
	cmp	edi, DWORD PTR [ebp+20]
	jne	SHORT $LN109@lower_boun@6
	call	__invalid_parameter_noinfo
$LN109@lower_boun@6:
	mov	edx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [edi+8]
	je	SHORT $LN7@lower_boun@6
	mov	eax, DWORD PTR tv540[esp+28]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	DWORD PTR $T430907[esp+36], ecx
	lea	ecx, DWORD PTR $T430907[esp+32]
	mov	DWORD PTR $T430907[esp+32], edx
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 645  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN169@lower_boun@6:

; 642  : 				return (this->comp(_Keyval,
; 643  : 					this->_Kfn(*_Where)) ? end() : _Where);

	mov	ebp, DWORD PTR [ebp]
	jmp	SHORT $LN120@lower_boun@6
$LN7@lower_boun@6:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	lea	ecx, DWORD PTR __Where$[esp+32]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 645  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN2@lower_boun@6:

; 644  : 		return (end());

	mov	ecx, DWORD PTR tv540[esp+28]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR __Where$[esp+36], edi

; 645  : 		}

	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx
	pop	ebx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@318
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@318
$LN17@operator@318:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@318
$LN13@operator@318:
	xor	eax, eax
$LN14@operator@318:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@318
	call	__invalid_parameter_noinfo
$LN18@operator@318:
	add	DWORD PTR [esi+4], 32			; 00000020H

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEPAU?$pair@U?$pair@_K_K@std@@U12@@1@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEPAU?$pair@U?$pair@_K_K@std@@U12@@1@XZ PROC ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator->, COMDAT
; _this$ = esi

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@319
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@319
$LN17@operator@319:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@319
$LN13@operator@319:
	xor	eax, eax
$LN14@operator@319:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@319
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 345  : 		}

	ret	0
$LN18@operator@319:

; 344  : 		return (&**this);

	mov	eax, ecx

; 345  : 		}

	ret	0
??C?$_Vector_iterator@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QBEPAU?$pair@U?$pair@_K_K@std@@U12@@1@XZ ENDP ; std::_Vector_iterator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@320
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@320
$LN17@operator@320:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@320
$LN13@operator@320:
	xor	eax, eax
$LN14@operator@320:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@320
	call	__invalid_parameter_noinfo
$LN18@operator@320:
	add	DWORD PTR [esi+4], 24			; 00000018H

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ PROC ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator->, COMDAT
; _this$ = esi

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@321
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@321
$LN17@operator@321:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@321
$LN13@operator@321:
	xor	eax, eax
$LN14@operator@321:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@321
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 345  : 		}

	ret	0
$LN18@operator@321:

; 344  : 		return (&**this);

	mov	eax, ecx

; 345  : 		}

	ret	0
??C?$_Vector_iterator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QBEPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@XZ ENDP ; std::_Vector_iterator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@322
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@322
$LN17@operator@322:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@322
$LN13@operator@322:
	xor	eax, eax
$LN14@operator@322:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@322
	call	__invalid_parameter_noinfo
$LN18@operator@322:
	add	DWORD PTR [esi+4], 8

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEPAU?$pair@II@1@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEPAU?$pair@II@1@XZ PROC ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator->, COMDAT
; _this$ = esi

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@323
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@323
$LN17@operator@323:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@323
$LN13@operator@323:
	xor	eax, eax
$LN14@operator@323:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@323
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 345  : 		}

	ret	0
$LN18@operator@323:

; 344  : 		return (&**this);

	mov	eax, ecx

; 345  : 		}

	ret	0
??C?$_Vector_iterator@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QBEPAU?$pair@II@1@XZ ENDP ; std::_Vector_iterator<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@324
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@324
$LN17@operator@324:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@324
$LN13@operator@324:
	xor	eax, eax
$LN14@operator@324:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@324
	call	__invalid_parameter_noinfo
$LN18@operator@324:
	add	DWORD PTR [esi+4], 24			; 00000018H

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ PROC ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator->, COMDAT
; _this$ = esi

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@325
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@325
$LN17@operator@325:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@325
$LN13@operator@325:
	xor	eax, eax
$LN14@operator@325:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@325
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 345  : 		}

	ret	0
$LN18@operator@325:

; 344  : 		return (&**this);

	mov	eax, ecx

; 345  : 		}

	ret	0
??C?$_Vector_iterator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QBEPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@XZ ENDP ; std::_Vector_iterator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::operator->
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z
_TEXT	SEGMENT
$T467904 = -16						; size = 4
$T467701 = -16						; size = 8
__Where$ = -8						; size = 8
tv508 = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Keyval$ = 16						; size = 4
?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound, COMDAT

; 649  : 		size_type _Bucket = _Hashval(_Keyval);

	mov	eax, DWORD PTR __Keyval$[esp-4]
	mov	ecx, DWORD PTR [eax]
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+16]
	push	ebp
	push	esi
	push	edi
	push	127773					; 0001f31dH
	push	ecx
	call	_ldiv
	imul	edx, 16807				; 000041a7H
	imul	eax, 2836				; 00000b14H
	add	esp, 8
	sub	edx, eax
	jns	SHORT $LN14@lower_boun@7
	add	edx, 2147483647				; 7fffffffH
$LN14@lower_boun@7:
	mov	eax, DWORD PTR [ebx+60]
	mov	esi, eax
	and	esi, edx
	cmp	DWORD PTR [ebx+64], esi
	ja	SHORT $LN9@lower_boun@7
	shr	eax, 1
	or	edx, -1
	sub	edx, eax
	add	esi, edx
$LN9@lower_boun@7:

; 650  : 		const_iterator _Where;
; 651  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	mov	eax, DWORD PTR [ebx+52]
	sub	eax, DWORD PTR [ebx+48]
	sar	eax, 3
	cmp	esi, eax
	jb	SHORT $LN25@lower_boun@7
	call	__invalid_parameter_noinfo
$LN25@lower_boun@7:
	mov	ecx, DWORD PTR [ebx+48]
	mov	edi, DWORD PTR [ecx+esi*8+4]
	lea	ebp, DWORD PTR [ebx+8]
	mov	DWORD PTR tv508[esp+28], ebp
	test	ebp, ebp
	jne	SHORT $LN38@lower_boun@7
	call	__invalid_parameter_noinfo
$LN38@lower_boun@7:
	mov	ebp, DWORD PTR [ebp]
	inc	esi
	mov	DWORD PTR __Where$[esp+32], ebp
	mov	DWORD PTR __Where$[esp+36], edi

; 653  : 				return (this->comp(_Keyval,
; 654  : 					this->_Kfn(*_Where)) ? end() : _Where);

	mov	DWORD PTR $T467904[esp+32], esi
$LL54@lower_boun@7:
	mov	edx, DWORD PTR [ebx+52]
	sub	edx, DWORD PTR [ebx+48]
	sar	edx, 3
	cmp	esi, edx
	jb	SHORT $LN66@lower_boun@7

; 650  : 		const_iterator _Where;
; 651  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	call	__invalid_parameter_noinfo
$LN66@lower_boun@7:
	mov	eax, DWORD PTR [ebx+48]
	cmp	DWORD PTR [eax+esi*8+4], edi
	je	$LN2@lower_boun@7

; 652  : 			if (!this->comp(this->_Kfn(*_Where), _Keyval))

	test	ebp, ebp
	jne	SHORT $LN159@lower_boun@7
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN90@lower_boun@7:
	cmp	edi, DWORD PTR [eax+20]
	jne	SHORT $LN79@lower_boun@7
	call	__invalid_parameter_noinfo
$LN79@lower_boun@7:
	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR __Keyval$[esp+28]
	cmp	ecx, DWORD PTR [esi]
	je	SHORT $LN156@lower_boun@7

; 650  : 		const_iterator _Where;
; 651  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	test	ebp, ebp
	jne	SHORT $LN158@lower_boun@7
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN61@lower_boun@7:
	cmp	edi, DWORD PTR [eax+20]
	jne	SHORT $LN50@lower_boun@7
	call	__invalid_parameter_noinfo
$LN50@lower_boun@7:
	mov	edi, DWORD PTR [edi]
	mov	esi, DWORD PTR $T467904[esp+32]
	jmp	SHORT $LL54@lower_boun@7
$LN159@lower_boun@7:

; 652  : 			if (!this->comp(this->_Kfn(*_Where), _Keyval))

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN90@lower_boun@7
$LN158@lower_boun@7:

; 650  : 		const_iterator _Where;
; 651  : 		for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN61@lower_boun@7
$LN156@lower_boun@7:
	mov	DWORD PTR __Where$[esp+36], edi

; 653  : 				return (this->comp(_Keyval,
; 654  : 					this->_Kfn(*_Where)) ? end() : _Where);

	test	ebp, ebp
	jne	SHORT $LN157@lower_boun@7
	call	__invalid_parameter_noinfo
$LN112@lower_boun@7:
	cmp	edi, DWORD PTR [ebp+20]
	jne	SHORT $LN101@lower_boun@7
	call	__invalid_parameter_noinfo
$LN101@lower_boun@7:
	mov	edx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [edi+8]
	je	SHORT $LN7@lower_boun@7
	mov	eax, DWORD PTR tv508[esp+28]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	DWORD PTR $T467701[esp+36], ecx
	pop	edi
	lea	ecx, DWORD PTR $T467701[esp+28]
	mov	DWORD PTR $T467701[esp+28], edx
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebx

; 656  : 		}

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN157@lower_boun@7:

; 653  : 				return (this->comp(_Keyval,
; 654  : 					this->_Kfn(*_Where)) ? end() : _Where);

	mov	ebp, DWORD PTR [ebp]
	jmp	SHORT $LN112@lower_boun@7
$LN7@lower_boun@7:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	pop	edi
	lea	ecx, DWORD PTR __Where$[esp+28]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebx

; 656  : 		}

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN2@lower_boun@7:

; 655  : 		return (end());

	mov	ecx, DWORD PTR tv508[esp+28]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR __Where$[esp+36], edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 656  : 		}

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?find@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z
_TEXT	SEGMENT
?find@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::find, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi
; __Keyval$ = eax

; 625  : 		return (lower_bound(_Keyval));

	push	eax
	push	esi
	push	ecx
	call	?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound
	mov	eax, esi

; 626  : 		}

	ret	0
?find@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::find
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.h
_TEXT	ENDS
;	COMDAT ??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z
_TEXT	SEGMENT
_it2$134655 = -24					; size = 8
_firstEnd$ = -16					; size = 8
_secondEnd$ = -8					; size = 8
_second$ = 8						; size = 4
??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z PROC ; DRAMsimII::operator==<unsigned int,unsigned int>, COMDAT
; _first$ = eax

; 46   : 		if (first.size() != second.size()) return false;

	mov	ecx, DWORD PTR [eax+32]
	sub	esp, 24					; 00000018H
	push	esi
	mov	esi, DWORD PTR _second$[esp+24]
	cmp	ecx, DWORD PTR [esi+32]
	je	SHORT $LN6@operator@345
	xor	al, al
	pop	esi

; 58   : 	}

	add	esp, 24					; 00000018H
	ret	0
$LN6@operator@345:

; 47   : 
; 48   : 		typename std::tr1::unordered_map<A, B>::const_iterator firstEnd = first.end();

	mov	edx, DWORD PTR [eax+28]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _firstEnd$[esp+32], edx

; 49   : 		typename std::tr1::unordered_map<A, B>::const_iterator secondEnd = second.end();

	mov	edx, DWORD PTR [esi+28]
	push	ebp
	push	edi

; 50   : 		for (typename std::tr1::unordered_map<A, B>::const_iterator it1 = first.begin();it1 != firstEnd; it1++) 

	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR _firstEnd$[esp+36], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR _secondEnd$[esp+40], edx
	mov	edx, DWORD PTR [eax+28]
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR _secondEnd$[esp+36], ecx
	push	ebx
	npad	2
$LL73@operator@345:
	test	edi, edi
	je	SHORT $LN87@operator@345
	cmp	edi, DWORD PTR _firstEnd$[esp+40]
	je	SHORT $LN88@operator@345
$LN87@operator@345:
	call	__invalid_parameter_noinfo
$LN88@operator@345:
	cmp	ebp, DWORD PTR _firstEnd$[esp+44]
	je	$LN3@operator@345

; 51   : 		{
; 52   : 			typename std::tr1::unordered_map<A, B>::const_iterator it2 = second.find(it1->first);

	test	edi, edi
	jne	$LN166@operator@345
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN109@operator@345:
	cmp	ebp, DWORD PTR [eax+20]
	jne	SHORT $LN98@operator@345
	call	__invalid_parameter_noinfo
$LN98@operator@345:
	lea	ebx, DWORD PTR [ebp+8]
	push	ebx
	lea	eax, DWORD PTR _it2$134655[esp+44]
	push	eax
	push	esi
	call	?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QBE?AV?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound

; 53   : 
; 54   : 			if(it2 == secondEnd || (it1->second != it2->second)) 

	mov	esi, DWORD PTR _it2$134655[esp+40]
	test	esi, esi
	je	SHORT $LN116@operator@345
	cmp	esi, DWORD PTR _secondEnd$[esp+40]
	je	SHORT $LN117@operator@345
$LN116@operator@345:
	call	__invalid_parameter_noinfo
$LN117@operator@345:
	mov	ecx, DWORD PTR _it2$134655[esp+44]
	cmp	ecx, DWORD PTR _secondEnd$[esp+44]
	je	SHORT $LN162@operator@345
	test	edi, edi
	jne	SHORT $LN165@operator@345
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN138@operator@345:
	cmp	ebp, DWORD PTR [eax+20]
	jne	SHORT $LN127@operator@345
	call	__invalid_parameter_noinfo
$LN127@operator@345:
	test	esi, esi
	jne	SHORT $LN164@operator@345
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN156@operator@345:
	mov	edx, DWORD PTR _it2$134655[esp+44]
	cmp	edx, DWORD PTR [eax+20]
	jne	SHORT $LN145@operator@345
	call	__invalid_parameter_noinfo
$LN145@operator@345:
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR _it2$134655[esp+44]
	cmp	eax, DWORD PTR [ecx+12]
	jne	SHORT $LN162@operator@345

; 50   : 		for (typename std::tr1::unordered_map<A, B>::const_iterator it1 = first.begin();it1 != firstEnd; it1++) 

	test	edi, edi
	jne	SHORT $LN163@operator@345
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN80@operator@345:
	cmp	ebp, DWORD PTR [eax+20]
	jne	SHORT $LN69@operator@345
	call	__invalid_parameter_noinfo
$LN69@operator@345:
	mov	ebp, DWORD PTR [ebp]
	mov	esi, DWORD PTR _second$[esp+36]
	jmp	$LL73@operator@345
$LN166@operator@345:

; 51   : 		{
; 52   : 			typename std::tr1::unordered_map<A, B>::const_iterator it2 = second.find(it1->first);

	mov	eax, DWORD PTR [edi]
	jmp	$LN109@operator@345
$LN165@operator@345:

; 53   : 
; 54   : 			if(it2 == secondEnd || (it1->second != it2->second)) 

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN138@operator@345
$LN164@operator@345:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN156@operator@345
$LN163@operator@345:

; 50   : 		for (typename std::tr1::unordered_map<A, B>::const_iterator it1 = first.begin();it1 != firstEnd; it1++) 

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN80@operator@345
$LN162@operator@345:
	pop	ebx
	pop	edi
	pop	ebp

; 55   : 				return false;

	xor	al, al
	pop	esi

; 58   : 	}

	add	esp, 24					; 00000018H
	ret	0
$LN3@operator@345:
	pop	ebx
	pop	edi
	pop	ebp

; 56   : 		} 
; 57   : 		return true;

	mov	al, 1
	pop	esi

; 58   : 	}

	add	esp, 24					; 00000018H
	ret	0
??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z ENDP ; DRAMsimII::operator==<unsigned int,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@0@Z
_TEXT	SEGMENT
$T468671 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@0@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase, COMDAT
; _this$ = eax

; 811  : 		if (_First == begin() && _Last == end())

	mov	ecx, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+8]
	push	ebp
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR [esi+20]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN25@erase@15
	cmp	ecx, eax
	je	SHORT $LN26@erase@15
$LN25@erase@15:
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR __First$[esp+20]
$LN26@erase@15:
	mov	eax, DWORD PTR __First$[esp+24]
	cmp	eax, edi
	jne	SHORT $LL2@erase@15
	mov	ebp, DWORD PTR __Last$[esp+20]
	mov	edi, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi]
	test	ebp, ebp
	je	SHORT $LN50@erase@15
	cmp	ebp, edx
	je	SHORT $LN51@erase@15
$LN50@erase@15:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+24]
	mov	ecx, DWORD PTR __First$[esp+20]
$LN51@erase@15:
	cmp	DWORD PTR __Last$[esp+24], edi
	jne	SHORT $LL2@erase@15

; 812  : 			{	// erase all and return fresh iterator
; 813  : 			clear();

	call	?clear@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXXZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::clear

; 814  : 			return (end());

	mov	ecx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ebx+4], ecx
	mov	DWORD PTR [ebx], edx

; 820  : 			return (_Make_iter(_Last));

	mov	eax, ebx

; 821  : 			}
; 822  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	20					; 00000014H
$LL2@erase@15:

; 815  : 			}
; 816  : 		else
; 817  : 			{	// erase subrange
; 818  : 			while (_First != _Last)

	test	ecx, ecx
	je	SHORT $LN77@erase@15
	cmp	ecx, DWORD PTR __Last$[esp+20]
	je	SHORT $LN78@erase@15
$LN77@erase@15:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+24]
	mov	ecx, DWORD PTR __First$[esp+20]
$LN78@erase@15:
	mov	edx, DWORD PTR __Last$[esp+24]
	cmp	eax, edx
	je	SHORT $LN1@erase@15

; 819  : 				_First = erase(_First);

	push	eax
	push	ecx
	lea	eax, DWORD PTR $T468671[esp+32]
	push	eax
	mov	edi, esi
	call	?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __First$[esp+20], ecx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __First$[esp+24], eax
	jmp	SHORT $LL2@erase@15
$LN1@erase@15:

; 820  : 			return (_Make_iter(_Last));

	mov	ecx, DWORD PTR [esi]

; 821  : 			}
; 822  : 		}

	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ebx+4], edx
	mov	DWORD PTR [ebx], ecx
	mov	eax, ebx
	pop	ebx
	add	esp, 8
	ret	20					; 00000014H
?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@0@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase
_TEXT	ENDS
PUBLIC	??8Statistics@DRAMsimII@@QBE_NABV01@@Z		; DRAMsimII::Statistics::operator==
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
??8Statistics@DRAMsimII@@QBE_NABV01@@Z PROC		; DRAMsimII::Statistics::operator==
; _rhs$ = edi

; 421  : {

	push	ebx
	mov	ebx, DWORD PTR _this$[esp]

; 422  : 	return (validTransactionCount == rhs.validTransactionCount && startNumber == rhs.startNumber && endNumber == rhs.endNumber &&
; 423  : 		burstOf8Count == rhs.burstOf8Count && burstOf4Count == rhs.burstOf4Count && columnDepth == rhs.columnDepth &&
; 424  : 		/// @todo restore comparisons once tr1 implementations support this
; 425  : 		commandDelay ==  rhs.commandDelay && commandExecution == rhs.commandExecution && commandTurnaround == rhs.commandTurnaround &&
; 426  : 		transactionDecodeDelay == rhs.transactionDecodeDelay && transactionExecution == rhs.transactionExecution &&
; 427  : 		channels == rhs.channels && ranks == rhs.ranks && banks == rhs.banks && aggregateBankUtilization == rhs.aggregateBankUtilization &&
; 428  : 		pcOccurrence == rhs.pcOccurrence && workingSet == rhs.workingSet && readCount == rhs.readCount && writeCount == rhs.writeCount &&
; 429  : 		readBytesTransferred == rhs.readBytesTransferred && writeBytesTransferred == rhs.writeBytesTransferred && issuedAtTFAW == rhs.issuedAtTFAW);

	mov	eax, DWORD PTR [ebx+12]
	cmp	eax, DWORD PTR [edi+12]
	jne	$LN3@operator@346
	mov	ecx, DWORD PTR [ebx+16]
	cmp	ecx, DWORD PTR [edi+16]
	jne	$LN3@operator@346
	mov	edx, DWORD PTR [ebx+20]
	cmp	edx, DWORD PTR [edi+20]
	jne	$LN3@operator@346
	mov	eax, DWORD PTR [ebx+24]
	cmp	eax, DWORD PTR [edi+24]
	jne	$LN3@operator@346
	mov	ecx, DWORD PTR [ebx+28]
	cmp	ecx, DWORD PTR [edi+28]
	jne	$LN3@operator@346
	mov	edx, DWORD PTR [ebx+32]
	cmp	edx, DWORD PTR [edi+32]
	jne	$LN3@operator@346
	lea	eax, DWORD PTR [edi+108]
	push	eax
	lea	eax, DWORD PTR [ebx+108]
	call	??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z ; DRAMsimII::operator==<unsigned int,unsigned int>
	add	esp, 4
	test	al, al
	je	$LN3@operator@346
	lea	ecx, DWORD PTR [edi+180]
	push	ecx
	lea	eax, DWORD PTR [ebx+180]
	call	??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z ; DRAMsimII::operator==<unsigned int,unsigned int>
	add	esp, 4
	test	al, al
	je	$LN3@operator@346
	lea	edx, DWORD PTR [edi+252]
	push	edx
	lea	eax, DWORD PTR [ebx+252]
	call	??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z ; DRAMsimII::operator==<unsigned int,unsigned int>
	add	esp, 4
	test	al, al
	je	$LN3@operator@346
	lea	eax, DWORD PTR [edi+324]
	push	eax
	lea	eax, DWORD PTR [ebx+324]
	call	??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z ; DRAMsimII::operator==<unsigned int,unsigned int>
	add	esp, 4
	test	al, al
	je	$LN3@operator@346
	lea	ecx, DWORD PTR [edi+396]
	push	ecx
	lea	eax, DWORD PTR [ebx+396]
	call	??$?8II@DRAMsimII@@YA_NABV?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@0@Z ; DRAMsimII::operator==<unsigned int,unsigned int>
	add	esp, 4
	test	al, al
	je	$LN3@operator@346
	mov	edx, DWORD PTR [ebx]
	cmp	edx, DWORD PTR [edi]
	jne	$LN3@operator@346
	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN3@operator@346
	mov	ecx, DWORD PTR [ebx+8]
	cmp	ecx, DWORD PTR [edi+8]
	jne	SHORT $LN3@operator@346
	push	esi
	lea	edx, DWORD PTR [edi+532]
	push	edx
	lea	esi, DWORD PTR [ebx+532]
	call	??$?8IV?$allocator@I@std@@@std@@YA_NABV?$vector@IV?$allocator@I@std@@@0@0@Z ; std::operator==<unsigned int,std::allocator<unsigned int> >
	add	esp, 4
	pop	esi
	test	al, al
	je	SHORT $LN3@operator@346
	lea	eax, DWORD PTR [edi+468]
	lea	ecx, DWORD PTR [ebx+468]
	call	??$?8V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@0@0@Z ; std::operator==<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
	test	al, al
	je	SHORT $LN3@operator@346
	lea	eax, DWORD PTR [edi+500]
	lea	ecx, DWORD PTR [ebx+500]
	call	??$?8V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@0@0@Z ; std::operator==<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
	test	al, al
	je	SHORT $LN3@operator@346
	mov	eax, DWORD PTR [ebx+36]
	cmp	eax, DWORD PTR [edi+36]
	jne	SHORT $LN3@operator@346
	mov	ecx, DWORD PTR [ebx+40]
	cmp	ecx, DWORD PTR [edi+40]
	jne	SHORT $LN3@operator@346
	mov	edx, DWORD PTR [ebx+44]
	cmp	edx, DWORD PTR [edi+44]
	jne	SHORT $LN3@operator@346
	mov	eax, DWORD PTR [ebx+48]
	cmp	eax, DWORD PTR [edi+48]
	jne	SHORT $LN3@operator@346
	mov	ecx, DWORD PTR [ebx+104]
	cmp	ecx, DWORD PTR [edi+104]
	jne	SHORT $LN3@operator@346
	mov	eax, 1
	pop	ebx

; 430  : }

	ret	4
$LN3@operator@346:

; 422  : 	return (validTransactionCount == rhs.validTransactionCount && startNumber == rhs.startNumber && endNumber == rhs.endNumber &&
; 423  : 		burstOf8Count == rhs.burstOf8Count && burstOf4Count == rhs.burstOf4Count && columnDepth == rhs.columnDepth &&
; 424  : 		/// @todo restore comparisons once tr1 implementations support this
; 425  : 		commandDelay ==  rhs.commandDelay && commandExecution == rhs.commandExecution && commandTurnaround == rhs.commandTurnaround &&
; 426  : 		transactionDecodeDelay == rhs.transactionDecodeDelay && transactionExecution == rhs.transactionExecution &&
; 427  : 		channels == rhs.channels && ranks == rhs.ranks && banks == rhs.banks && aggregateBankUtilization == rhs.aggregateBankUtilization &&
; 428  : 		pcOccurrence == rhs.pcOccurrence && workingSet == rhs.workingSet && readCount == rhs.readCount && writeCount == rhs.writeCount &&
; 429  : 		readBytesTransferred == rhs.readBytesTransferred && writeBytesTransferred == rhs.writeBytesTransferred && issuedAtTFAW == rhs.issuedAtTFAW);

	xor	eax, eax
	pop	ebx

; 430  : }

	ret	4
??8Statistics@DRAMsimII@@QBE_NABV01@@Z ENDP		; DRAMsimII::Statistics::operator==
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z$0
__ehfuncinfo$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
xdata$x	ENDS
;	COMDAT ?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
$T504831 = -80						; size = 28
$T504830 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Incsize, COMDAT
; _this$ = ecx

; 1239 : 		{	// alter element count, with checking

	push	-1
	push	__ehhandler$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1240 : 		if (max_size() - _Mysize < _Count)

	mov	eax, DWORD PTR [ecx+24]
	mov	edx, 536870911				; 1fffffffH
	sub	edx, eax
	cmp	edx, 1
	jae	SHORT $LN1@Incsize@2

; 1241 : 			_THROW(length_error, "list<T> too long");

	push	16					; 00000010H
	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T504831[esp+92]
	mov	DWORD PTR $T504831[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T504831[esp+112], 0
	mov	BYTE PTR $T504831[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T504831[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T504830[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T504830[esp+88]
	push	ecx
	mov	DWORD PTR $T504830[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN52@Incsize@2:
$LN1@Incsize@2:

; 1242 : 		_Mysize += _Count;

	inc	eax
	mov	DWORD PTR [ecx+24], eax

; 1243 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 80					; 00000050H
	ret	0
$LN51@Incsize@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z$0:
	lea	ecx, DWORD PTR $T504831[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Incsize
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T505008 = -80						; size = 28
$T505007 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T505008[esp+92]
	mov	DWORD PTR $T505008[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T505008[esp+112], 0
	mov	BYTE PTR $T505008[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T505008[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T505007[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T505007[esp+88]
	push	ecx
	mov	DWORD PTR $T505007[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@3:
$LN44@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T505008[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Xlen
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Where$ = 12						; size = 8
?_Insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Insert, COMDAT
; __Val$ = edx

; 711  : 
; 712  :  #if _HAS_ITERATOR_DEBUGGING
; 713  : 		if (_Where._Mycont != this)
; 714  : 			_DEBUG_ERROR("list insert iterator outside range");
; 715  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 716  : 
; 717  : 		_Nodeptr _Pnode = _Where._Mynode();
; 718  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

	mov	eax, DWORD PTR __Where$[esp]
	mov	ecx, DWORD PTR [eax+4]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax+4]
	push	ecx
	push	eax
	mov	esi, edx
	call	?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PAU342@0ABU?$pair@$$CBII@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode

; 719  : 		_Incsize(1);

	mov	ecx, DWORD PTR _this$[esp+4]
	mov	esi, eax
	call	?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Incsize

; 720  : 		_Prevnode(_Pnode) = _Newnode;

	mov	DWORD PTR [edi], esi

; 721  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

	mov	edx, DWORD PTR [esi+4]

; 722  : 		}

	pop	edi
	mov	DWORD PTR [edx], esi
	pop	esi
	ret	12					; 0000000cH
?_Insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Insert
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T505188 = -80						; size = 28
$T505187 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T505188[esp+92]
	mov	DWORD PTR $T505188[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T505188[esp+112], 0
	mov	BYTE PTR $T505188[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T505188[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T505187[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T505187[esp+88]
	push	ecx
	mov	DWORD PTR $T505187[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@4:
$LN44@Xlen@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T505188[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T505349 = -80						; size = 28
$T505348 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ PROC ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T505349[esp+92]
	mov	DWORD PTR $T505349[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T505349[esp+112], 0
	mov	BYTE PTR $T505349[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T505349[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T505348[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T505348[esp+88]
	push	ecx
	mov	DWORD PTR $T505348[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@5:
$LN44@Xlen@5:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T505349[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE_NI@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1102 : 		{	// allocate array with _Capacity elements

	push	ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Xlen
$LN18@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	ecx

; 1115 : 		}

	ret	0
$LN17@Buy@3:
?_Buy@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 8
?insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::insert, COMDAT
; __Val$ = edx

; 703  : 		{	// insert _Val at _Where

	push	ecx

; 704  : 		_Insert(_Where, _Val);

	mov	eax, DWORD PTR __Where$[esp+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+8]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax+4]
	push	ecx
	push	eax
	mov	esi, edx
	call	?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PAU342@0ABU?$pair@$$CBII@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode
	mov	ecx, ebx
	mov	esi, eax
	call	?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Incsize
	mov	DWORD PTR [edi], esi
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [edx], esi

; 705  : 		return (_Make_iter(--_Where));

	mov	eax, DWORD PTR __Where$[esp+16]
	test	eax, eax
	jne	SHORT $LN17@insert@3
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp+16]
$LN17@insert@3:
	mov	ecx, DWORD PTR __Where$[esp+20]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Where$[esp+20], ecx
	test	eax, eax
	je	SHORT $LN27@insert@3
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN28@insert@3
$LN27@insert@3:
	xor	eax, eax
$LN28@insert@3:
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN15@insert@3
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR __Where$[esp+20]
$LN15@insert@3:
	mov	DWORD PTR [ebp], 0
	mov	DWORD PTR [ebp+4], ecx
	test	ebx, ebx
	jne	SHORT $LN35@insert@3
	call	__invalid_parameter_noinfo
$LN35@insert@3:
	mov	edx, DWORD PTR [ebx]

; 706  : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [ebp], edx
	mov	eax, ebp
	pop	ebp
	pop	ebx
	pop	ecx
	ret	16					; 00000010H
?insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::insert
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T505670 = -80						; size = 28
$T505669 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T505670[esp+92]
	mov	DWORD PTR $T505670[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T505670[esp+112], 0
	mov	BYTE PTR $T505670[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T505670[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T505669[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T505669[esp+88]
	push	ecx
	mov	DWORD PTR $T505669[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@6:
$LN44@Xlen@6:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T505670[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T505831 = -80						; size = 28
$T505830 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T505831[esp+92]
	mov	DWORD PTR $T505831[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T505831[esp+112], 0
	mov	BYTE PTR $T505831[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T505831[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T505830[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T505830[esp+88]
	push	ecx
	mov	DWORD PTR $T505830[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@7:
$LN44@Xlen@7:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T505831[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = eax

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi
	mov	esi, eax

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	esi, eax
	jne	SHORT $LN4@Buy@4

; 1105 : 			return (false);

	xor	al, al

; 1115 : 		}

	pop	esi
	ret	0
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	esi, 134217727				; 07ffffffH
	jbe	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Xlen
$LN14@Buy@4:
$LN2@Buy@4:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, esi
	call	?allocate@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAEPAU?$pair@U?$pair@_K_K@std@@U12@@2@I@Z ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::allocate

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	shl	esi, 5
	add	esi, eax
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], esi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1

; 1115 : 		}

	pop	esi
	ret	0
$LN13@Buy@4:
?_Buy@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1102 : 		{	// allocate array with _Capacity elements

	push	ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@5

; 1105 : 			return (false);

	xor	al, al
	pop	ecx

; 1115 : 		}

	ret	0
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Xlen
$LN14@Buy@5:
$LN2@Buy@5:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@U?$pair@II@std@@@std@@QAEPAU?$pair@II@2@I@Z ; std::allocator<std::pair<unsigned int,unsigned int> >::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	ecx

; 1115 : 		}

	ret	0
$LN13@Buy@5:
?_Buy@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Buy
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T506034 = -80						; size = 28
$T506033 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T506034[esp+92]
	mov	DWORD PTR $T506034[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T506034[esp+112], 0
	mov	BYTE PTR $T506034[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T506034[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T506033[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T506033[esp+88]
	push	ecx
	mov	DWORD PTR $T506033[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@8:
$LN44@Xlen@8:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T506034[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z
_TEXT	SEGMENT
$T506195 = -80						; size = 28
$T506194 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Newnode$ = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Addleft$ = 16						; size = 1
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert, COMDAT
; __Wherenode$ = edi

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	push	ebx
	push	ebp
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _this$[esp+96]

; 1188 : 		if (max_size() - 1 <= _Mysize)
; 1189 : 			_THROW(length_error, "map/set<T> too long");

	xor	ebx, ebx
	cmp	DWORD PTR [ebp+28], 268435454		; 0ffffffeH
	jb	SHORT $LN17@Insert
	push	19					; 00000013H
	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T506195[esp+108]
	mov	DWORD PTR $T506195[esp+132], 15		; 0000000fH
	mov	DWORD PTR $T506195[esp+128], ebx
	mov	BYTE PTR $T506195[esp+112], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T506195[esp+100]
	push	eax
	lea	ecx, DWORD PTR $T506194[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], ebx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T506194[esp+104]
	push	ecx
	mov	DWORD PTR $T506194[esp+108], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN370@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	eax, DWORD PTR [ebp+24]
	mov	esi, DWORD PTR __Val$[esp+96]
	push	ebx
	push	eax
	push	edi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KI@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Buynode

; 1192 : 
; 1193 : 		++_Mysize;

	inc	DWORD PTR [ebp+28]
	mov	esi, eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [ebp+24]
	mov	DWORD PTR __Newnode$[esp+96], esi
	cmp	edi, eax
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], esi

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	edx, DWORD PTR [ebp+24]
	mov	DWORD PTR [edx], esi
	mov	eax, DWORD PTR [ebp+24]
	jmp	SHORT $LN367@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+96], bl
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [edi], esi

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [ebp+24]
	cmp	edi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], esi

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [edi+8], esi

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [ebp+24]
	cmp	edi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert
$LN367@Insert:

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], esi
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	ecx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+32], bl
	jne	$LN9@Insert
	npad	5
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	$LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+32], bl

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;
; 1219 : 					_Color(_Wherenode) = _Black;
; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));
; 1222 : 					}
; 1223 : 				else

	je	$LN369@Insert

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN145@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+33], bl
	jne	SHORT $LN144@Insert
	mov	DWORD PTR [eax+4], esi
$LN144@Insert:
	mov	edx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [ebp+24]
	cmp	esi, DWORD PTR [edx+4]
	jne	SHORT $LN143@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN140@Insert
$LN143@Insert:
	mov	edx, DWORD PTR [eax]
	cmp	esi, DWORD PTR [edx]
	jne	SHORT $LN141@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN140@Insert
$LN141@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN140@Insert:
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], ecx
$LN145@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+32], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+32], bl

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+33], bl
	jne	SHORT $LN207@Insert
	mov	DWORD PTR [edx+4], eax
$LN207@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [ebp+24]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN206@Insert
	mov	DWORD PTR [edx+4], ecx
	mov	DWORD PTR [ecx+8], eax

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN368@Insert

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

$LN206@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN204@Insert
	mov	DWORD PTR [edx+8], ecx
	mov	DWORD PTR [ecx+8], eax

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN368@Insert

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

$LN204@Insert:
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [ecx+8], eax

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN368@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+32], bl
	jne	SHORT $LN3@Insert
$LN369@Insert:

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+32], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+32], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+32], bl

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN301@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);
; 1250 : 						_Rrotate(_Pnode);

	push	ebp
	mov	esi, ecx
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+32], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+32], bl

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+33], bl
	jne	SHORT $LN300@Insert
	mov	DWORD PTR [edx+4], eax
$LN300@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [ebp+24]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN299@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN296@Insert
$LN299@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN297@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN296@Insert
$LN297@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN296@Insert:
	mov	DWORD PTR [ecx], eax
$LN368@Insert:
	mov	DWORD PTR [eax+4], ecx
$LN301@Insert:
	mov	ecx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+32], bl
	je	$LL10@Insert

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	esi, DWORD PTR __Newnode$[esp+96]
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [ebp+24]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+32], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+96]
	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 84					; 00000054H
	ret	16					; 00000010H
$LN366@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z$0:
	lea	ecx, DWORD PTR $T506195[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-84]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KI@2@@Z
_TEXT	SEGMENT
$T507017 = -8						; size = 8
$T507015 = -8						; size = 8
__Where$131558 = -8					; size = 8
_this$ = 8						; size = 4
__Addleft$ = 12						; size = 1
___$ReturnUdt$ = 12					; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KI@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert, COMDAT

; 630  : 		{	// try to insert node with value _Val

	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+8]

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	ecx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ecx+4]

; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+33], 0
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+12]
	push	esi
	mov	esi, DWORD PTR __Val$[esp+16]
	push	edi
	mov	edi, ecx
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+20], cl
	jne	SHORT $LN9@insert@4
	mov	edx, DWORD PTR [esi+4]
	npad	6
$LL10@insert@4:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	edi, eax

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+20]
	ja	SHORT $LN31@insert@4
	jb	SHORT $LN107@insert@4
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN31@insert@4
$LN107@insert@4:

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	mov	eax, DWORD PTR [eax]
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+20], cl
	jmp	SHORT $LN14@insert@4

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

$LN31@insert@4:

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	mov	eax, DWORD PTR [eax+8]
	xor	cl, cl
	mov	BYTE PTR __Addleft$[esp+20], cl
$LN14@insert@4:

; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL10@insert@4
$LN9@insert@4:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, DWORD PTR [ebx]
	mov	eax, edi
	mov	DWORD PTR __Where$131558[esp+28], eax
	mov	DWORD PTR __Where$131558[esp+24], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN83@insert@4

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN71@insert@4
	cmp	edx, edx
	je	SHORT $LN72@insert@4
$LN71@insert@4:
	call	__invalid_parameter_noinfo
$LN72@insert@4:
	cmp	edi, esi
	jne	SHORT $LN4@insert@4

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Val$[esp+20]
	push	ecx
	push	1
	lea	edx, DWORD PTR $T507015[esp+32]
	push	edx
$LN111@insert@4:
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ebp], ecx
	mov	DWORD PTR [ebp+4], edx
	mov	BYTE PTR [ebp+8], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, ebp

; 659  : 			}
; 660  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH
$LN4@insert@4:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	lea	esi, DWORD PTR __Where$131558[esp+24]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Where$131558[esp+28]
	mov	edx, DWORD PTR __Where$131558[esp+24]
	mov	esi, DWORD PTR __Val$[esp+20]
$LN83@insert@4:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR [esi+4]
	ja	SHORT $LN2@insert@4
	jb	SHORT $LN108@insert@4
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [esi]
	jae	SHORT $LN2@insert@4
$LN108@insert@4:

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	edx, DWORD PTR __Addleft$[esp+20]
	push	esi
	push	edx
	lea	eax, DWORD PTR $T507017[esp+32]
	push	eax
	jmp	SHORT $LN111@insert@4
$LN2@insert@4:

; 659  : 			}
; 660  : 		}

	pop	edi
	mov	DWORD PTR [ebp+4], eax
	pop	esi
	mov	DWORD PTR [ebp], edx
	mov	BYTE PTR [ebp+8], 0
	mov	eax, ebp
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KI@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z
_TEXT	SEGMENT
$T507255 = -80						; size = 28
$T507254 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Newnode$ = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Addleft$ = 16						; size = 1
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert, COMDAT
; __Wherenode$ = edi

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	push	ebx
	push	ebp
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _this$[esp+96]

; 1188 : 		if (max_size() - 1 <= _Mysize)
; 1189 : 			_THROW(length_error, "map/set<T> too long");

	xor	ebx, ebx
	cmp	DWORD PTR [ebp+28], 178956969		; 0aaaaaa9H
	jb	SHORT $LN17@Insert@2
	push	19					; 00000013H
	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T507255[esp+108]
	mov	DWORD PTR $T507255[esp+132], 15		; 0000000fH
	mov	DWORD PTR $T507255[esp+128], ebx
	mov	BYTE PTR $T507255[esp+112], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T507255[esp+100]
	push	eax
	lea	ecx, DWORD PTR $T507254[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], ebx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T507254[esp+104]
	push	ecx
	mov	DWORD PTR $T507254[esp+108], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN370@Insert@2:
$LN17@Insert@2:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	eax, DWORD PTR [ebp+24]
	mov	esi, DWORD PTR __Val$[esp+96]
	push	ebx
	push	eax
	push	edi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Buynode

; 1192 : 
; 1193 : 		++_Mysize;

	inc	DWORD PTR [ebp+28]
	mov	esi, eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [ebp+24]
	mov	DWORD PTR __Newnode$[esp+96], esi
	cmp	edi, eax
	jne	SHORT $LN16@Insert@2

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], esi

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	edx, DWORD PTR [ebp+24]
	mov	DWORD PTR [edx], esi
	mov	eax, DWORD PTR [ebp+24]
	jmp	SHORT $LN367@Insert@2
$LN16@Insert@2:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+96], bl
	je	SHORT $LN14@Insert@2

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [edi], esi

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [ebp+24]
	cmp	edi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert@2

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], esi

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert@2
$LN14@Insert@2:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [edi+8], esi

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [ebp+24]
	cmp	edi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert@2
$LN367@Insert@2:

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], esi
$LN11@Insert@2:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	ecx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+40], bl
	jne	$LN9@Insert@2
	npad	5
$LL10@Insert@2:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	$LN8@Insert@2

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+40], bl

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;
; 1219 : 					_Color(_Wherenode) = _Black;
; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));
; 1222 : 					}
; 1223 : 				else

	je	$LN369@Insert@2

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN145@Insert@2

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+41], bl
	jne	SHORT $LN144@Insert@2
	mov	DWORD PTR [eax+4], esi
$LN144@Insert@2:
	mov	edx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [ebp+24]
	cmp	esi, DWORD PTR [edx+4]
	jne	SHORT $LN143@Insert@2
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN140@Insert@2
$LN143@Insert@2:
	mov	edx, DWORD PTR [eax]
	cmp	esi, DWORD PTR [edx]
	jne	SHORT $LN141@Insert@2
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN140@Insert@2
$LN141@Insert@2:
	mov	DWORD PTR [edx+8], ecx
$LN140@Insert@2:
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], ecx
$LN145@Insert@2:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+40], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+40], bl

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+41], bl
	jne	SHORT $LN207@Insert@2
	mov	DWORD PTR [edx+4], eax
$LN207@Insert@2:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [ebp+24]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN206@Insert@2
	mov	DWORD PTR [edx+4], ecx
	mov	DWORD PTR [ecx+8], eax

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN368@Insert@2

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

$LN206@Insert@2:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN204@Insert@2
	mov	DWORD PTR [edx+8], ecx
	mov	DWORD PTR [ecx+8], eax

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN368@Insert@2

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

$LN204@Insert@2:
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [ecx+8], eax

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN368@Insert@2
$LN8@Insert@2:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+40], bl
	jne	SHORT $LN3@Insert@2
$LN369@Insert@2:

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+40], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+40], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+40], bl

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN301@Insert@2
$LN3@Insert@2:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert@2

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);
; 1250 : 						_Rrotate(_Pnode);

	push	ebp
	mov	esi, ecx
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Rrotate
$LN1@Insert@2:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+40], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+40], bl

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+41], bl
	jne	SHORT $LN300@Insert@2
	mov	DWORD PTR [edx+4], eax
$LN300@Insert@2:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [ebp+24]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN299@Insert@2
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN296@Insert@2
$LN299@Insert@2:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN297@Insert@2
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN296@Insert@2
$LN297@Insert@2:
	mov	DWORD PTR [edx+8], ecx
$LN296@Insert@2:
	mov	DWORD PTR [ecx], eax
$LN368@Insert@2:
	mov	DWORD PTR [eax+4], ecx
$LN301@Insert@2:
	mov	ecx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+40], bl
	je	$LL10@Insert@2

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	esi, DWORD PTR __Newnode$[esp+96]
$LN9@Insert@2:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [ebp+24]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+40], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+96]
	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 84					; 00000054H
	ret	16					; 00000010H
$LN366@Insert@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z$0:
	lea	ecx, DWORD PTR $T507255[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-84]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z
_TEXT	SEGMENT
$T508077 = -8						; size = 8
$T508075 = -8						; size = 8
__Where$131417 = -8					; size = 8
_this$ = 8						; size = 4
__Addleft$ = 12						; size = 1
___$ReturnUdt$ = 12					; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert, COMDAT

; 630  : 		{	// try to insert node with value _Val

	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+8]

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	ecx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ecx+4]

; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+41], 0
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+12]
	push	esi
	mov	esi, DWORD PTR __Val$[esp+16]
	push	edi
	mov	edi, ecx
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+20], cl
	jne	SHORT $LN9@insert@5
	mov	edx, DWORD PTR [esi+4]
	npad	6
$LL10@insert@5:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	edi, eax

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+20]
	ja	SHORT $LN31@insert@5
	jb	SHORT $LN107@insert@5
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN31@insert@5
$LN107@insert@5:

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	mov	eax, DWORD PTR [eax]
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+20], cl
	jmp	SHORT $LN14@insert@5

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

$LN31@insert@5:

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	mov	eax, DWORD PTR [eax+8]
	xor	cl, cl
	mov	BYTE PTR __Addleft$[esp+20], cl
$LN14@insert@5:

; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+41], 0
	je	SHORT $LL10@insert@5
$LN9@insert@5:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, DWORD PTR [ebx]
	mov	eax, edi
	mov	DWORD PTR __Where$131417[esp+28], eax
	mov	DWORD PTR __Where$131417[esp+24], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN83@insert@5

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN71@insert@5
	cmp	edx, edx
	je	SHORT $LN72@insert@5
$LN71@insert@5:
	call	__invalid_parameter_noinfo
$LN72@insert@5:
	cmp	edi, esi
	jne	SHORT $LN4@insert@5

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Val$[esp+20]
	push	ecx
	push	1
	lea	edx, DWORD PTR $T508075[esp+32]
	push	edx
$LN111@insert@5:
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ebp], ecx
	mov	DWORD PTR [ebp+4], edx
	mov	BYTE PTR [ebp+8], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, ebp

; 659  : 			}
; 660  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH
$LN4@insert@5:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	lea	esi, DWORD PTR __Where$131417[esp+24]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Where$131417[esp+28]
	mov	edx, DWORD PTR __Where$131417[esp+24]
	mov	esi, DWORD PTR __Val$[esp+20]
$LN83@insert@5:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR [esi+4]
	ja	SHORT $LN2@insert@5
	jb	SHORT $LN108@insert@5
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [esi]
	jae	SHORT $LN2@insert@5
$LN108@insert@5:

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	edx, DWORD PTR __Addleft$[esp+20]
	push	esi
	push	edx
	lea	eax, DWORD PTR $T508077[esp+32]
	push	eax
	jmp	SHORT $LN111@insert@5
$LN2@insert@5:

; 659  : 			}
; 660  : 		}

	pop	edi
	mov	DWORD PTR [ebp+4], eax
	pop	esi
	mov	DWORD PTR [ebp], edx
	mov	BYTE PTR [ebp+8], 0
	mov	eax, ebp
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z$0
__ehfuncinfo$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >, COMDAT

; 476  : 		{	// construct empty vector with allocator

	push	-1
	push	__ehhandler$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@37
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@37
$LN13@vector@37:
	xor	eax, eax
$LN14@vector@37:
	mov	DWORD PTR [esi], eax

; 477  : 		_Buy(0);

	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx

; 478  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1102 : 		{	// allocate array with _Capacity elements

	push	ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@6

; 1105 : 			return (false);

	xor	al, al
	pop	ecx

; 1115 : 		}

	ret	0
$LN4@Buy@6:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN2@Buy@6

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Xlen
$LN14@Buy@6:
$LN2@Buy@6:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEPAV?$vector@IV?$allocator@I@std@@@2@I@Z ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocate

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	ecx

; 1115 : 		}

	ret	0
$LN13@Buy@6:
?_Buy@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1102 : 		{	// allocate array with _Capacity elements

	push	ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@7

; 1105 : 			return (false);

	xor	al, al
	pop	ecx

; 1115 : 		}

	ret	0
$LN4@Buy@7:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN2@Buy@7

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Xlen
$LN14@Buy@7:
$LN2@Buy@7:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@I@Z ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::allocate

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	ecx

; 1115 : 		}

	ret	0
$LN13@Buy@7:
?_Buy@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Buy
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z$0
__tryblocktable$?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z$2
__ehfuncinfo$?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z
_TEXT	SEGMENT
$T508608 = -20						; size = 1
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Cat$508611 = 12					; size = 1
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Construct_n, COMDAT

; 545  : 		{	// construct from _Count * _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR _this$[ebp]

; 546  : 		if (_Buy(_Count))

	mov	ebx, DWORD PTR __Count$[ebp]
	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	cmp	ebx, eax
	je	SHORT $LN7@Construct_
	cmp	ebx, 134217727				; 07ffffffH
	jbe	SHORT $LN10@Construct_
	call	?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Xlen
$LN32@Construct_:
$LN10@Construct_:
	mov	ecx, ebx
	call	?allocate@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAEPAU?$pair@U?$pair@_K_K@std@@U12@@2@I@Z ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::allocate

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	edx, DWORD PTR __Cat$508611[ebp]
	mov	edi, eax
	mov	BYTE PTR $T508608[ebp], 0
	mov	ecx, DWORD PTR $T508608[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Count$[ebp]
	push	edx
	mov	edx, DWORD PTR __Val$[ebp]
	shl	ebx, 5
	lea	eax, DWORD PTR [ebx+edi]
	push	edi
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], eax
	call	??$_Uninit_fill_n@PAU?$pair@U?$pair@_K_K@std@@U12@@std@@IU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@YAXPAU?$pair@U?$pair@_K_K@std@@U12@@0@IABU10@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,unsigned int,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
	add	esp, 12					; 0000000cH
	add	ebx, edi
	mov	DWORD PTR [esi+16], ebx
$LN7@Construct_:

; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z$0:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Tidy

; 552  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN33@Construct_:
$LN31@Construct_:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Construct_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z$0
__tryblocktable$?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z$2
__ehfuncinfo$?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
__Cat$508689 = 8					; size = 1
_this$ = 8						; size = 4
$T508686 = 12						; size = 1
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z PROC ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Construct_n, COMDAT

; 545  : 		{	// construct from _Count * _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR __Count$[ebp]
	mov	esi, DWORD PTR _this$[ebp]

; 546  : 		if (_Buy(_Count))

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	cmp	ebx, eax
	je	SHORT $LN7@Construct_@2
	cmp	ebx, 536870911				; 1fffffffH
	jbe	SHORT $LN10@Construct_@2
	call	?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Xlen
$LN32@Construct_@2:
$LN10@Construct_@2:
	mov	ecx, ebx
	call	?allocate@?$allocator@U?$pair@II@std@@@std@@QAEPAU?$pair@II@2@I@Z ; std::allocator<std::pair<unsigned int,unsigned int> >::allocate

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	edx, DWORD PTR __Cat$508689[ebp]
	mov	edi, eax
	mov	BYTE PTR $T508686[ebp], 0
	mov	ecx, DWORD PTR $T508686[ebp]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Val$[ebp]
	lea	eax, DWORD PTR [edi+ebx*8]
	push	edi
	mov	ecx, ebx
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], eax
	call	??$_Uninit_fill_n@PAU?$pair@II@std@@IU12@V?$allocator@U?$pair@II@std@@@2@@std@@YAXPAU?$pair@II@0@IABU10@AAV?$allocator@U?$pair@II@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned int,unsigned int> *,unsigned int,std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
	lea	eax, DWORD PTR [edi+ebx*8]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+16], eax
$LN7@Construct_@2:

; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z$0:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Tidy

; 552  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN33@Construct_@2:
$LN31@Construct_@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z ENDP ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Construct_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = esi

; 1102 : 		{	// allocate array with _Capacity elements

	push	ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

	cmp	esi, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN2@Buy@8

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Xlen
$LN18@Buy@8:
$LN2@Buy@8:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, esi
	call	?allocate@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@I@Z ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::allocate

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [esi+esi*2]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	ecx

; 1115 : 		}

	ret	0
$LN17@Buy@8:
?_Buy@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Buy
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T508733 = -80						; size = 28
$T508732 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T508733[esp+92]
	mov	DWORD PTR $T508733[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T508733[esp+112], 0
	mov	BYTE PTR $T508733[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T508733[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T508732[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T508732[esp+88]
	push	ecx
	mov	DWORD PTR $T508732[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@9:
$LN44@Xlen@9:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T508733[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KI@2@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 8
$T508899 = -12						; size = 12
$T508898 = -12						; size = 8
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Val$ = 16						; size = 4
__Where$ = 20						; size = 8
?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KI@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert, COMDAT

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	sub	esp, 24					; 00000018H
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+24]

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;
; 672  : 
; 673  : 		if (size() == 0)

	cmp	DWORD PTR [ebx+28], 0
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+28]
	push	esi
	push	edi
	jne	SHORT $LN32@insert@6

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[esp+36]
	mov	edi, DWORD PTR [ebx+24]
	push	eax
	push	1
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN32@insert@6:

; 675  : 		else if (this->_Multi)
; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())
; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,
; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 682  : 				}
; 683  : 			else if (_Where == end())
; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,
; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));
; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,
; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))
; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 696  : 				else
; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,
; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))
; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 707  : 				else
; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 709  : 				}
; 710  : 			}
; 711  : 		else
; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	ecx, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Where$[esp+36]
	mov	eax, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN237@insert@6
	cmp	ecx, eax
	je	SHORT $LN238@insert@6
$LN237@insert@6:
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR __Where$[esp+36]
$LN238@insert@6:
	mov	eax, DWORD PTR __Where$[esp+40]
	cmp	eax, esi
	jne	SHORT $LN14@insert@6

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Val$[esp+36]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+20]
	ja	$LN1@insert@6
	jb	SHORT $LN395@insert@6
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+16]
	jae	$LN1@insert@6
$LN395@insert@6:

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	ecx
	push	1
	push	ebp
	push	ebx
	mov	edi, eax
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN14@insert@6:

; 718  : 				}
; 719  : 			else if (_Where == end())

	mov	esi, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN276@insert@6
	cmp	ecx, edx
	je	SHORT $LN277@insert@6
$LN276@insert@6:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp+40]
	mov	ecx, DWORD PTR __Where$[esp+36]
$LN277@insert@6:
	cmp	eax, esi
	jne	SHORT $LN11@insert@6

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [ebx+24]
	mov	edi, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [edi+20]
	mov	edx, DWORD PTR __Val$[esp+36]
	cmp	ecx, DWORD PTR [edx+4]
	ja	$LN400@insert@6
	jb	SHORT $LN396@insert@6
	mov	eax, DWORD PTR [edi+16]
	mov	ecx, edx
	cmp	eax, DWORD PTR [ecx]
	jae	$LN400@insert@6
$LN396@insert@6:

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	push	edx
	push	0
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN11@insert@6:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,
; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	edi, DWORD PTR __Val$[esp+36]
	mov	edx, DWORD PTR [edi+4]
	cmp	edx, DWORD PTR [eax+20]
	ja	SHORT $LN8@insert@6
	jb	SHORT $LN397@insert@6
	mov	edx, DWORD PTR [edi]
	cmp	edx, DWORD PTR [eax+16]
	jae	SHORT $LN8@insert@6
$LN397@insert@6:
	lea	esi, DWORD PTR __Next$[esp+40]
	mov	DWORD PTR __Next$[esp+40], ecx
	mov	DWORD PTR __Next$[esp+44], eax
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Dec
	mov	esi, DWORD PTR __Next$[esp+44]
	lea	ecx, DWORD PTR [esi+16]
	mov	eax, edi
	call	??R?$less@_K@std@@QBE_NAB_K0@Z		; std::less<unsigned __int64>::operator()
	test	al, al
	je	SHORT $LN399@insert@6

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+33], 0

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	push	edi
	je	SHORT $LN7@insert@6
	push	0
	push	ebp
	push	ebx
	mov	edi, esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN7@insert@6:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	edi, DWORD PTR __Where$[esp+44]
	push	1
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN399@insert@6:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Where$[esp+40]
	mov	ecx, DWORD PTR __Where$[esp+36]
$LN8@insert@6:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,
; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [edi+4]
	ja	$LN400@insert@6
	jb	SHORT $LN398@insert@6
	mov	edx, DWORD PTR [eax+16]
	mov	esi, edi
	cmp	edx, DWORD PTR [esi]
	jae	$LN400@insert@6
$LN398@insert@6:
	mov	DWORD PTR __Next$[esp+40], ecx
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR __Next$[esp+44], eax
	mov	eax, DWORD PTR [ebx+24]
	lea	esi, DWORD PTR __Next$[esp+40]
	mov	DWORD PTR $T508898[esp+44], eax
	mov	DWORD PTR $T508898[esp+40], ecx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::_Inc
	lea	esi, DWORD PTR $T508898[esp+40]
	lea	edi, DWORD PTR __Next$[esp+40]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::const_iterator::operator==
	mov	edi, DWORD PTR __Next$[esp+44]
	test	al, al
	jne	SHORT $LN3@insert@6
	mov	ecx, DWORD PTR __Val$[esp+36]
	lea	eax, DWORD PTR [edi+16]
	call	??R?$less@_K@std@@QBE_NAB_K0@Z		; std::less<unsigned __int64>::operator()
	test	al, al
	je	SHORT $LN400@insert@6
$LN3@insert@6:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	eax, DWORD PTR __Where$[esp+40]
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+33], 0
	je	SHORT $LN2@insert@6

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[esp+36]
	push	ecx
	push	0
	push	ebp
	push	ebx
	mov	edi, eax
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN2@insert@6:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[esp+36]
	push	edx
	push	1
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN400@insert@6:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[esp+36]
$LN1@insert@6:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	push	ecx
	lea	eax, DWORD PTR $T508899[esp+44]
	push	eax
	push	ebx
	call	?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert
	mov	ecx, DWORD PTR [eax]

; 749  : 		}

	pop	edi
	mov	DWORD PTR [ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	pop	esi
	mov	DWORD PTR [ebp+4], edx
	mov	eax, ebp
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KI@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 8
$T509812 = -12						; size = 12
$T509811 = -12						; size = 8
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Val$ = 16						; size = 4
__Where$ = 20						; size = 8
?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert, COMDAT

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	sub	esp, 24					; 00000018H
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+24]

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;
; 672  : 
; 673  : 		if (size() == 0)

	cmp	DWORD PTR [ebx+28], 0
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+28]
	push	esi
	push	edi
	jne	SHORT $LN32@insert@7

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[esp+36]
	mov	edi, DWORD PTR [ebx+24]
	push	eax
	push	1
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN32@insert@7:

; 675  : 		else if (this->_Multi)
; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())
; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,
; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 682  : 				}
; 683  : 			else if (_Where == end())
; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,
; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));
; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,
; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))
; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 696  : 				else
; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,
; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))
; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 707  : 				else
; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 709  : 				}
; 710  : 			}
; 711  : 		else
; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	ecx, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Where$[esp+36]
	mov	eax, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN237@insert@7
	cmp	ecx, eax
	je	SHORT $LN238@insert@7
$LN237@insert@7:
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR __Where$[esp+36]
$LN238@insert@7:
	mov	eax, DWORD PTR __Where$[esp+40]
	cmp	eax, esi
	jne	SHORT $LN14@insert@7

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Val$[esp+36]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+20]
	ja	$LN1@insert@7
	jb	SHORT $LN395@insert@7
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+16]
	jae	$LN1@insert@7
$LN395@insert@7:

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	ecx
	push	1
	push	ebp
	push	ebx
	mov	edi, eax
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN14@insert@7:

; 718  : 				}
; 719  : 			else if (_Where == end())

	mov	esi, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN276@insert@7
	cmp	ecx, edx
	je	SHORT $LN277@insert@7
$LN276@insert@7:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp+40]
	mov	ecx, DWORD PTR __Where$[esp+36]
$LN277@insert@7:
	cmp	eax, esi
	jne	SHORT $LN11@insert@7

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [ebx+24]
	mov	edi, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [edi+20]
	mov	edx, DWORD PTR __Val$[esp+36]
	cmp	ecx, DWORD PTR [edx+4]
	ja	$LN400@insert@7
	jb	SHORT $LN396@insert@7
	mov	eax, DWORD PTR [edi+16]
	mov	ecx, edx
	cmp	eax, DWORD PTR [ecx]
	jae	$LN400@insert@7
$LN396@insert@7:

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	push	edx
	push	0
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN11@insert@7:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,
; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	edi, DWORD PTR __Val$[esp+36]
	mov	edx, DWORD PTR [edi+4]
	cmp	edx, DWORD PTR [eax+20]
	ja	SHORT $LN8@insert@7
	jb	SHORT $LN397@insert@7
	mov	edx, DWORD PTR [edi]
	cmp	edx, DWORD PTR [eax+16]
	jae	SHORT $LN8@insert@7
$LN397@insert@7:
	lea	esi, DWORD PTR __Next$[esp+40]
	mov	DWORD PTR __Next$[esp+40], ecx
	mov	DWORD PTR __Next$[esp+44], eax
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Dec
	mov	esi, DWORD PTR __Next$[esp+44]
	lea	ecx, DWORD PTR [esi+16]
	mov	eax, edi
	call	??R?$less@_K@std@@QBE_NAB_K0@Z		; std::less<unsigned __int64>::operator()
	test	al, al
	je	SHORT $LN399@insert@7

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+41], 0

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	push	edi
	je	SHORT $LN7@insert@7
	push	0
	push	ebp
	push	ebx
	mov	edi, esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN7@insert@7:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	edi, DWORD PTR __Where$[esp+44]
	push	1
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN399@insert@7:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Where$[esp+40]
	mov	ecx, DWORD PTR __Where$[esp+36]
$LN8@insert@7:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,
; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [edi+4]
	ja	$LN400@insert@7
	jb	SHORT $LN398@insert@7
	mov	edx, DWORD PTR [eax+16]
	mov	esi, edi
	cmp	edx, DWORD PTR [esi]
	jae	$LN400@insert@7
$LN398@insert@7:
	mov	DWORD PTR __Next$[esp+40], ecx
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR __Next$[esp+44], eax
	mov	eax, DWORD PTR [ebx+24]
	lea	esi, DWORD PTR __Next$[esp+40]
	mov	DWORD PTR $T509811[esp+44], eax
	mov	DWORD PTR $T509811[esp+40], ecx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::_Inc
	lea	esi, DWORD PTR $T509811[esp+40]
	lea	edi, DWORD PTR __Next$[esp+40]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::const_iterator::operator==
	mov	edi, DWORD PTR __Next$[esp+44]
	test	al, al
	jne	SHORT $LN3@insert@7
	mov	ecx, DWORD PTR __Val$[esp+36]
	lea	eax, DWORD PTR [edi+16]
	call	??R?$less@_K@std@@QBE_NAB_K0@Z		; std::less<unsigned __int64>::operator()
	test	al, al
	je	SHORT $LN400@insert@7
$LN3@insert@7:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	eax, DWORD PTR __Where$[esp+40]
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+41], 0
	je	SHORT $LN2@insert@7

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[esp+36]
	push	ecx
	push	0
	push	ebp
	push	ebx
	mov	edi, eax
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN2@insert@7:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[esp+36]
	push	edx
	push	1
	push	ebp
	push	ebx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Insert

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, ebp

; 749  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN400@insert@7:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[esp+36]
$LN1@insert@7:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	push	ecx
	lea	eax, DWORD PTR $T509812[esp+44]
	push	eax
	push	ebx
	call	?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert
	mov	ecx, DWORD PTR [eax]

; 749  : 		}

	pop	edi
	mov	DWORD PTR [ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	pop	esi
	mov	DWORD PTR [ebp+4], edx
	mov	eax, ebp
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@I@Z
_TEXT	SEGMENT
$T510720 = -48						; size = 32
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@I@Z PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >, COMDAT

; 482  : 		{	// construct from _Count * _Ty()

	push	-1
	push	__ehhandler$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+60]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+56]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@38
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@38
$LN13@vector@38:
	xor	eax, eax
$LN14@vector@38:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+68], ecx

; 483  : 		_Construct_n(_Count, _Ty());

	lea	eax, DWORD PTR $T510720[esp+60]
	mov	DWORD PTR $T510720[esp+60], ecx
	mov	DWORD PTR $T510720[esp+64], ecx
	mov	DWORD PTR $T510720[esp+68], ecx
	mov	DWORD PTR $T510720[esp+72], ecx
	mov	DWORD PTR $T510720[esp+76], ecx
	mov	DWORD PTR $T510720[esp+80], ecx
	mov	DWORD PTR $T510720[esp+84], ecx
	mov	DWORD PTR $T510720[esp+88], ecx
	mov	ecx, DWORD PTR __Count$[esp+56]
	push	eax
	push	ecx
	push	esi
	call	?_Construct_n@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAEXIABU?$pair@U?$pair@_K_K@std@@U12@@2@@Z ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Construct_n

; 484  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 52					; 00000034H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@I@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-44]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@I@Z ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@I@Z
_TEXT	SEGMENT
$T510862 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@I@Z PROC ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >, COMDAT

; 482  : 		{	// construct from _Count * _Ty()

	push	-1
	push	__ehhandler$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+24]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@39
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@39
$LN13@vector@39:
	xor	eax, eax
$LN14@vector@39:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+36], ecx

; 483  : 		_Construct_n(_Count, _Ty());

	lea	eax, DWORD PTR $T510862[esp+28]
	mov	DWORD PTR $T510862[esp+28], ecx
	mov	DWORD PTR $T510862[esp+32], ecx
	mov	ecx, DWORD PTR __Count$[esp+24]
	push	eax
	push	ecx
	push	esi
	call	?_Construct_n@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAEXIABU?$pair@II@2@@Z ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Construct_n

; 484  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@I@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@I@Z ENDP ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >, COMDAT

; 470  : 		{	// construct empty vector

	push	-1
	push	__ehhandler$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+16]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@40
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@40
$LN13@vector@40:
	xor	eax, eax
$LN14@vector@40:
	mov	DWORD PTR [esi], eax

; 471  : 		_Buy(0);

	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx

; 472  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::reserve, COMDAT
; _this$ = esi

; 602  : 		{	// determine new minimum length of allocated storage

	push	ecx

; 603  : 		if (max_size() < _Count)

	mov	ecx, DWORD PTR __Count$[esp]
	push	ebx
	push	ebp
	push	edi
	cmp	ecx, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@reserve@2

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN97@reserve@2:
$LN5@reserve@2:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR [esi+12]
	test	edx, edx
	jne	SHORT $LN20@reserve@2
	xor	eax, eax
	jmp	SHORT $LN21@reserve@2
$LN20@reserve@2:
	mov	eax, DWORD PTR [esi+20]
	sub	eax, edx
	sar	eax, 2
$LN21@reserve@2:
	cmp	eax, ecx
	jae	SHORT $LN3@reserve@2

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	call	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	edi, DWORD PTR [esi+16]
	mov	ebx, eax
	cmp	DWORD PTR [esi+12], edi
	jbe	SHORT $LN27@reserve@2
	call	__invalid_parameter_noinfo
$LN27@reserve@2:
	mov	ebp, DWORD PTR [esi+12]
	cmp	ebp, DWORD PTR [esi+16]
	jbe	SHORT $LN43@reserve@2
	call	__invalid_parameter_noinfo
$LN43@reserve@2:
	sub	edi, ebp
	sar	edi, 2
	test	edi, edi
	jbe	SHORT $LN86@reserve@2
	lea	eax, DWORD PTR [edi*4]
	push	eax
	push	ebp
	push	eax
	push	ebx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN86@reserve@2:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);
; 613  : 			_RERAISE;
; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+16]
	sub	edi, eax
	sar	edi, 2

; 617  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN93@reserve@2

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);
; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN93@reserve@2:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[esp+12]
	lea	ecx, DWORD PTR [ebx+eax*4]

; 628  : 			_Mylast = _Ptr + _Size;

	lea	edx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+16], edx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+12], ebx
$LN3@reserve@2:

; 630  : 			}
; 631  : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN96@reserve@2:
?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::reserve
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??A?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAEAAIAB_K@Z
_TEXT	SEGMENT
$T511592 = -24						; size = 16
__Where$ = -24						; size = 8
$T511595 = -8						; size = 8
$T511591 = -8						; size = 8
_this$ = 8						; size = 4
??A?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAEAAIAB_K@Z PROC ; std::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::operator[], COMDAT
; __Keyval$ = edi

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	sub	esp, 28					; 0000001cH
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+28]
	push	ebp
	push	esi

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	push	ebx
	mov	ecx, edi
	lea	eax, DWORD PTR __Where$[esp+44]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::lower_bound

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	mov	eax, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR __Where$[esp+40]
	mov	DWORD PTR $T511591[esp+44], eax
	mov	eax, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN20@operator@362
	cmp	esi, eax
	je	SHORT $LN21@operator@362
$LN20@operator@362:
	call	__invalid_parameter_noinfo
$LN21@operator@362:
	mov	ebp, DWORD PTR __Where$[esp+44]
	cmp	ebp, DWORD PTR $T511591[esp+44]
	je	SHORT $LN59@operator@362
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [ebp+20]
	ja	SHORT $LN2@operator@362
	jb	SHORT $LN59@operator@362
	mov	edx, DWORD PTR [edi]
	cmp	edx, DWORD PTR [ebp+16]
	jae	SHORT $LN2@operator@362
$LN59@operator@362:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+4]
	push	ebp
	push	esi
	lea	edx, DWORD PTR $T511592[esp+48]
	mov	DWORD PTR $T511592[esp+48], eax
	push	edx
	lea	eax, DWORD PTR $T511595[esp+52]
	push	eax
	push	ebx
	mov	DWORD PTR $T511592[esp+64], ecx
	mov	DWORD PTR $T511592[esp+68], 0
	call	?insert@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KI@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::insert
	mov	esi, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
$LN2@operator@362:

; 174  : 		return ((*_Where).second);

	test	esi, esi
	jne	SHORT $LN58@operator@362
	call	__invalid_parameter_noinfo
$LN53@operator@362:
	cmp	ebp, DWORD PTR [esi+24]
	jne	SHORT $LN60@operator@362
	call	__invalid_parameter_noinfo
$LN60@operator@362:

; 175  : 		}

	pop	esi
	lea	eax, DWORD PTR [ebp+24]
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	4
$LN58@operator@362:

; 174  : 		return ((*_Where).second);

	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN53@operator@362
??A?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAEAAIAB_K@Z ENDP ; std::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAEAAVDelayCounter@Statistics@DRAMsimII@@AB_K@Z
_TEXT	SEGMENT
__Where$ = -48						; size = 8
$T511761 = -40						; size = 8
$T511759 = -40						; size = 16
$T511757 = -40						; size = 8
$T511758 = -24						; size = 24
_this$ = 8						; size = 4
??A?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAEAAVDelayCounter@Statistics@DRAMsimII@@AB_K@Z PROC ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::operator[], COMDAT
; __Keyval$ = edi

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	sub	esp, 52					; 00000034H
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+52]
	push	ebp
	push	esi

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	push	ebx
	mov	ecx, edi
	lea	eax, DWORD PTR __Where$[esp+68]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@AB_K@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::lower_bound

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	mov	eax, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR __Where$[esp+64]
	mov	DWORD PTR $T511757[esp+68], eax
	mov	eax, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN20@operator@363
	cmp	esi, eax
	je	SHORT $LN21@operator@363
$LN20@operator@363:
	call	__invalid_parameter_noinfo
$LN21@operator@363:
	mov	ebp, DWORD PTR __Where$[esp+68]
	cmp	ebp, DWORD PTR $T511757[esp+68]
	je	SHORT $LN61@operator@363
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [ebp+20]
	ja	SHORT $LN2@operator@363
	jb	SHORT $LN61@operator@363
	mov	edx, DWORD PTR [edi]
	cmp	edx, DWORD PTR [ebp+16]
	jae	SHORT $LN2@operator@363
$LN61@operator@363:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	ecx, DWORD PTR [edi+4]
	xor	eax, eax
	push	ebp
	mov	DWORD PTR $T511759[esp+68], eax
	mov	DWORD PTR $T511759[esp+72], eax
	movq	xmm0, QWORD PTR $T511759[esp+68]
	mov	DWORD PTR $T511759[esp+76], eax
	mov	eax, DWORD PTR [edi]
	push	esi
	lea	edx, DWORD PTR $T511758[esp+72]
	mov	DWORD PTR $T511758[esp+72], eax
	push	edx
	lea	eax, DWORD PTR $T511761[esp+76]
	push	eax
	movq	QWORD PTR $T511758[esp+88], xmm0
	movq	xmm0, QWORD PTR $T511759[esp+88]
	push	ebx
	mov	DWORD PTR $T511758[esp+88], ecx
	movq	QWORD PTR $T511758[esp+100], xmm0
	call	?insert@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::insert
	mov	esi, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
$LN2@operator@363:

; 174  : 		return ((*_Where).second);

	test	esi, esi
	jne	SHORT $LN60@operator@363
	call	__invalid_parameter_noinfo
$LN55@operator@363:
	cmp	ebp, DWORD PTR [esi+24]
	jne	SHORT $LN62@operator@363
	call	__invalid_parameter_noinfo
$LN62@operator@363:

; 175  : 		}

	pop	esi
	lea	eax, DWORD PTR [ebp+24]
	pop	ebp
	pop	ebx
	add	esp, 52					; 00000034H
	ret	4
$LN60@operator@363:

; 174  : 		return ((*_Where).second);

	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN55@operator@363
??A?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAEAAVDelayCounter@Statistics@DRAMsimII@@AB_K@Z ENDP ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::operator[]
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z$5
__ehfuncinfo$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T584263 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$584399 = 8					; size = 1
_this$ = 8						; size = 4
$T584395 = 12						; size = 1
__Right$ = 12						; size = 4
??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >, COMDAT

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR __Right$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN19@vector@57
	mov	DWORD PTR [eax], edi
	jmp	SHORT $LN20@vector@57
$LN19@vector@57:
	xor	eax, eax
$LN20@vector@57:
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR __$EHRec$[ebp+12], ecx

; 501  : 		if (_Buy(_Right.size()))

	mov	esi, DWORD PTR [ebx+16]
	sub	esi, DWORD PTR [ebx+12]
	mov	DWORD PTR [edi+12], ecx
	sar	esi, 5
	mov	DWORD PTR [edi+16], ecx
	mov	DWORD PTR [edi+20], ecx
	cmp	esi, ecx
	je	SHORT $LN8@vector@57
	cmp	esi, 134217727				; 07ffffffH
	jbe	SHORT $LN46@vector@57
	call	?_Xlen@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@KAXXZ ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Xlen
$LN107@vector@57:
$LN46@vector@57:
	mov	ecx, esi
	call	?allocate@?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@std@@QAEPAU?$pair@U?$pair@_K_K@std@@U12@@2@I@Z ; std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > >::allocate
	shl	esi, 5
	add	esi, eax
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], esi

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR $T584263[ebp], eax
	cmp	DWORD PTR [ebx+12], eax
	jbe	SHORT $LN60@vector@57
	call	__invalid_parameter_noinfo
$LN60@vector@57:
	mov	esi, DWORD PTR [ebx+12]
	cmp	esi, DWORD PTR [ebx+16]
	jbe	SHORT $LN74@vector@57
	call	__invalid_parameter_noinfo
$LN74@vector@57:
	mov	edx, DWORD PTR __Cat$584399[ebp]
	mov	eax, DWORD PTR [edi+12]
	mov	BYTE PTR $T584395[ebp], 0
	mov	ecx, DWORD PTR $T584395[ebp]
	push	ecx
	push	edx
	mov	edx, DWORD PTR $T584263[ebp]
	push	esi
	call	??$_Uninit_copy@PBU?$pair@U?$pair@_K_K@std@@U12@@std@@PAU12@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@YAPAU?$pair@U?$pair@_K_K@std@@U12@@0@PBU10@0PAU10@AAV?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > const *,std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > *,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+16], eax
$LN8@vector@57:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN108@vector@57:
$LN106@vector@57:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z$2:
	mov	eax, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z$5
__ehfuncinfo$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T584623 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$584769 = 8					; size = 1
_this$ = 8						; size = 4
$T584766 = 12						; size = 1
__Right$ = 12						; size = 4
??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >, COMDAT

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR __Right$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN19@vector@58
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN20@vector@58
$LN19@vector@58:
	xor	eax, eax
$LN20@vector@58:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[ebp+12], ecx

; 501  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+16]
	sub	edi, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+12], ecx
	sar	edi, 3
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	cmp	edi, ecx
	je	SHORT $LN8@vector@58
	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN46@vector@58
	call	?_Xlen@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Xlen
$LN107@vector@58:
$LN46@vector@58:
	mov	ecx, edi
	call	?allocate@?$allocator@U?$pair@II@std@@@std@@QAEPAU?$pair@II@2@I@Z ; std::allocator<std::pair<unsigned int,unsigned int> >::allocate
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+20], eax

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR $T584623[ebp], eax
	cmp	DWORD PTR [ebx+12], eax
	jbe	SHORT $LN60@vector@58
	call	__invalid_parameter_noinfo
$LN60@vector@58:
	mov	edi, DWORD PTR [ebx+12]
	cmp	edi, DWORD PTR [ebx+16]
	jbe	SHORT $LN74@vector@58
	call	__invalid_parameter_noinfo
$LN74@vector@58:
	mov	edx, DWORD PTR __Cat$584769[ebp]
	mov	eax, DWORD PTR [esi+12]
	mov	BYTE PTR $T584766[ebp], 0
	mov	ecx, DWORD PTR $T584766[ebp]
	push	ecx
	push	edx
	mov	edx, DWORD PTR $T584623[ebp]
	push	edi
	call	??$_Uninit_copy@PBU?$pair@II@std@@PAU12@V?$allocator@U?$pair@II@std@@@2@@std@@YAPAU?$pair@II@0@PBU10@0PAU10@AAV?$allocator@U?$pair@II@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,unsigned int> const *,std::pair<unsigned int,unsigned int> *,std::allocator<std::pair<unsigned int,unsigned int> > >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+16], eax
$LN8@vector@58:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN108@vector@58:
$LN106@vector@58:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z$2:
	mov	eax, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Construct@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@ABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@ABV10@@Z$0
__ehfuncinfo$??$_Construct@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@ABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@ABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@ABV10@@Z
_TEXT	SEGMENT
$T584793 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
??$_Construct@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@ABV10@@Z PROC ; std::_Construct<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >, COMDAT
; __Val$ = ecx

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Ptr$[esp+20]

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	DWORD PTR __Vptr$[esp+20], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T584793[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	eax, eax
	je	SHORT $LN3@Construct@23
	push	ecx
	push	eax
	call	??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
$LN3@Construct@23:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@ABV10@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T584793[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@ABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@ABV10@@Z ENDP ; std::_Construct<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Construct@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@ABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@ABV10@@Z$0
__ehfuncinfo$??$_Construct@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@ABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@ABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@ABV10@@Z
_TEXT	SEGMENT
$T584810 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
??$_Construct@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@ABV10@@Z PROC ; std::_Construct<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >, COMDAT
; __Val$ = ecx

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Ptr$[esp+20]

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	DWORD PTR __Vptr$[esp+20], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T584810[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	eax, eax
	je	SHORT $LN3@Construct@24
	push	ecx
	push	eax
	call	??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
$LN3@Construct@24:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@ABV10@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T584810[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@ABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V12@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@ABV10@@Z ENDP ; std::_Construct<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@ABV32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@ABV32@@Z$0
__ehfuncinfo$?construct@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@ABV32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@ABV32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@ABV32@@Z
_TEXT	SEGMENT
$T584837 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$584843 = 8					; size = 4
__Ptr$ = 8						; size = 4
?construct@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@ABV32@@Z PROC ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::construct, COMDAT
; __Val$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@ABV32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Ptr$[esp+20]

; 155  : 		_Construct(_Ptr, _Val);

	mov	DWORD PTR __Vptr$584843[esp+20], eax
	mov	DWORD PTR $T584837[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	eax, eax
	je	SHORT $LN5@construct@20
	push	ecx
	push	eax
	call	??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
$LN5@construct@20:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@ABV32@@Z$0:
	mov	eax, DWORD PTR __Vptr$584843[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T584837[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@ABV32@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@ABV32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@ABV32@@Z ENDP ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::construct
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@ABV32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@ABV32@@Z$0
__ehfuncinfo$?construct@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@ABV32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@ABV32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@ABV32@@Z
_TEXT	SEGMENT
$T584864 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$584870 = 8					; size = 4
__Ptr$ = 8						; size = 4
?construct@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@ABV32@@Z PROC ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::construct, COMDAT
; __Val$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@ABV32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Ptr$[esp+20]

; 155  : 		_Construct(_Ptr, _Val);

	mov	DWORD PTR __Vptr$584870[esp+20], eax
	mov	DWORD PTR $T584864[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	eax, eax
	je	SHORT $LN5@construct@21
	push	ecx
	push	eax
	call	??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
$LN5@construct@21:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@ABV32@@Z$0:
	mov	eax, DWORD PTR __Vptr$584870[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T584864[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@ABV32@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@ABV32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@ABV32@@Z ENDP ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::construct
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\list
xdata$x	SEGMENT
__unwindtable$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z$0
__tryblocktable$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z$2
__ehfuncinfo$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
$T584880 = -40						; size = 8
__Before$137252 = -32					; size = 8
__Next$ = -24						; size = 8
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
___formal$ = 12						; size = 1
__Where$ = 16						; size = 8
__First$ = 24						; size = 8
__Last$ = 32						; size = 8
??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Insert<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >, COMDAT

; 762  : 		void _Insert(const_iterator _Where,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR _this$[ebp]

; 763  : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 764  : 		{	// insert [_First, _Last) at _Where, forward iterators
; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		_DEBUG_RANGE(_First, _Last);
; 768  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 769  : 
; 770  : 		_Iter _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR __Next$[ebp], eax
	mov	DWORD PTR __Next$[ebp+4], ecx

; 771  : 
; 772  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 773  : 		for (; _First != _Last; ++_First)

$LL18@Insert@7:
	test	eax, eax
	je	SHORT $LN32@Insert@7
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN33@Insert@7
$LN32@Insert@7:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[ebp]
$LN33@Insert@7:
	mov	edx, DWORD PTR __First$[ebp+4]
	cmp	edx, DWORD PTR __Last$[ebp+4]
	je	$LN4@Insert@7

; 774  : 			_Insert(_Where, *_First);

	test	eax, eax
	jne	SHORT $LN74@Insert@7
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN51@Insert@7
$LN74@Insert@7:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN52@Insert@7
$LN51@Insert@7:
	xor	eax, eax
$LN52@Insert@7:
	mov	ecx, DWORD PTR __First$[ebp+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN41@Insert@7
	call	__invalid_parameter_noinfo
$LN41@Insert@7:
	mov	eax, DWORD PTR __Where$[ebp+4]
	mov	edx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR __First$[ebp+4]
	lea	edi, DWORD PTR [eax+4]
	push	edx
	add	esi, 8
	push	eax
	call	?_Buynode@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEPAU_Node@?$_List_nod@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@2@PAU342@0ABU?$pair@$$CBII@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Buynode
	mov	ecx, ebx
	mov	esi, eax
	call	?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Incsize
	mov	DWORD PTR [edi], esi
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], esi
	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	jne	SHORT $LN73@Insert@7
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN24@Insert@7
$LN73@Insert@7:

; 773  : 		for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN25@Insert@7
$LN24@Insert@7:
	xor	ecx, ecx
$LN25@Insert@7:
	mov	edx, DWORD PTR __First$[ebp+4]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN14@Insert@7
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[ebp]
$LN14@Insert@7:
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __First$[ebp+4], edx
	jmp	$LL18@Insert@7
__catch$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z$0:

; 775  : 		_CATCH_ALL
; 776  : 		for (; _Next != _First; ++_Next)

	lea	esi, DWORD PTR __First$[ebp]
	lea	edi, DWORD PTR __Next$[ebp]
	call	??9?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator!=
	test	al, al
	je	SHORT $LN1@Insert@7
	mov	ebx, DWORD PTR _this$[ebp]
	npad	1
$LL3@Insert@7:

; 777  : 			{	// undo inserts
; 778  : 			const_iterator _Before = _Where;

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]

; 779  : 			erase(--_Before);

	lea	esi, DWORD PTR __Before$137252[ebp]
	mov	DWORD PTR __Before$137252[ebp], eax
	mov	DWORD PTR __Before$137252[ebp+4], ecx
	call	??F?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator--
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T584880[ebp]
	push	ecx
	mov	edi, ebx
	call	?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase
	lea	esi, DWORD PTR __Next$[ebp]
	call	??E?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator++
	lea	esi, DWORD PTR __First$[ebp]
	lea	edi, DWORD PTR __Next$[ebp]
	call	??9?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QBE_NABV012@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1>::operator!=
	test	al, al
	jne	SHORT $LL3@Insert@7
$LN1@Insert@7:

; 780  : 			}
; 781  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN77@Insert@7:
$LN4@Insert@7:

; 782  : 		_CATCH_END
; 783  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN76@Insert@7:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Insert<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T585064 = -28						; size = 4
__Vptr$585070 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Val$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > *,unsigned int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >, COMDAT
; __Count$ = ecx

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	esi, DWORD PTR __First$[ebp]

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
$LL6@Uninit_fil@18:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil@18

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$585070[ebp], esi
	mov	DWORD PTR $T585064[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil@18
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	esi
	call	??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
$LN18@Uninit_fil@18:
	dec	edi
	add	esi, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@18
__catch$??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@18
	npad	6
$LL3@Uninit_fil@18:

; 407  : 		_Al.destroy(_Next);

	call	?destroy@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::destroy
	add	esi, 24					; 00000018H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@18
$LN1@Uninit_fil@18:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN29@Uninit_fil@18:
$LN4@Uninit_fil@18:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@Uninit_fil@18:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$585070[ebp]
	push	eax
	mov	ecx, DWORD PTR $T585064[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > *,unsigned int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T585114 = -28						; size = 4
__Vptr$585120 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Val$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > *,unsigned int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >, COMDAT
; __Count$ = ecx

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	esi, DWORD PTR __First$[ebp]

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
$LL6@Uninit_fil@19:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil@19

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$585120[ebp], esi
	mov	DWORD PTR $T585114[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil@19
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	esi
	call	??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
$LN18@Uninit_fil@19:
	dec	edi
	add	esi, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@19
__catch$??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@19
	npad	6
$LL3@Uninit_fil@19:

; 407  : 		_Al.destroy(_Next);

	call	?destroy@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::destroy
	add	esi, 24					; 00000018H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@19
$LN1@Uninit_fil@19:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN29@Uninit_fil@19:
$LN4@Uninit_fil@19:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@Uninit_fil@19:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$585120[ebp]
	push	eax
	mov	ecx, DWORD PTR $T585114[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > *,unsigned int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??$insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00@Z
_TEXT	SEGMENT
$T585138 = 8						; size = 1
_this$ = 8						; size = 4
__Where$ = 12						; size = 8
__First$ = 20						; size = 8
__Last$ = 28						; size = 8
??$insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::insert<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >, COMDAT

; 731  : 		{	// insert [_First, _Last) at _Where
; 732  : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp]
	push	eax
	mov	eax, DWORD PTR __First$[esp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Where$[esp+8]
	push	eax
	mov	eax, DWORD PTR $T585138[esp+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+16]
	push	edx
	push	eax
	push	ecx
	call	??$_Insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00Uforward_iterator_tag@1@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Insert<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >

; 733  : 		}

	ret	28					; 0000001cH
??$insert@V?$_Const_iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@01@00@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::insert<std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Const_iterator<1> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@stdext@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IABV12@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
$T585146 = -4						; size = 1
__Cat$585151 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
??$unchecked_uninitialized_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@stdext@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IABV12@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > *,unsigned int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >, COMDAT
; __Val$ = edx

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	BYTE PTR $T585146[esp+4], 0
	mov	eax, DWORD PTR $T585146[esp+4]
	mov	ecx, DWORD PTR __Cat$585151[esp+4]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	push	eax
	call	??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > *,unsigned int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >

; 943  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$unchecked_uninitialized_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@stdext@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IABV12@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > *,unsigned int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@stdext@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IABV12@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
$T585155 = -4						; size = 1
__Cat$585160 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
??$unchecked_uninitialized_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@stdext@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IABV12@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > *,unsigned int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >, COMDAT
; __Val$ = edx

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	BYTE PTR $T585155[esp+4], 0
	mov	eax, DWORD PTR $T585155[esp+4]
	mov	ecx, DWORD PTR __Cat$585160[esp+4]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	push	eax
	call	??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > *,unsigned int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >

; 943  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$unchecked_uninitialized_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@stdext@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IABV12@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > *,unsigned int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$0
__catchsym$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$2
__tryblocktable$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$5
__ehfuncinfo$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
_TEXT	SEGMENT
__Tmp$133643 = -40					; size = 8
$T585631 = -36						; size = 1
$T585243 = -36						; size = 1
__Tmp$133633 = -32					; size = 8
__Newvec$133618 = -28					; size = 4
__Capacity$ = -24					; size = 4
__$EHRec$ = -16						; size = 16
tv515 = 8						; size = 4
__Cat$585634 = 8					; size = 1
$T585584 = 8						; size = 1
__Cat$585587 = 8					; size = 1
$T585408 = 8						; size = 1
__Cat$585412 = 8					; size = 1
__Cat$585247 = 8					; size = 1
__Val$ = 8						; size = 4
__Where$ = 12						; size = 8
?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Insert_n, COMDAT
; _this$ = edx
; __Count$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	esi, edx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+12]
	test	edx, edx
	jne	SHORT $LN29@Insert_n@5
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@5
$LN29@Insert_n@5:
	mov	eax, DWORD PTR [esi+20]
	sub	eax, edx
	sar	eax, 3
	mov	ecx, eax
$LN30@Insert_n@5:

; 1162 : 
; 1163 : 		if (_Count == 0)

	test	edi, edi
	je	$LN1@Insert_n@5

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+16]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 3
	mov	edx, 536870911				; 1fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@KAXXZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Xlen
$LN130@Insert_n@5:
$LN12@Insert_n@5:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 536870911				; 1fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@5
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@5:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@5:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	call	?allocate@?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@QAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@I@Z ; std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>::allocate

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp+4]
	sub	ebx, DWORD PTR [esi+12]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Cat$585247[ebp]
	mov	BYTE PTR $T585243[ebp], 0
	mov	ecx, DWORD PTR $T585243[ebp]
	push	ecx
	mov	DWORD PTR __Newvec$133618[ebp], eax
	sar	ebx, 3
	push	edx
	mov	edx, DWORD PTR __Val$[ebp]
	lea	eax, DWORD PTR [eax+ebx*8]
	push	eax
	mov	ecx, edi
	call	??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR [esi+12]
	add	esp, 12					; 0000000cH
	mov	BYTE PTR $T585408[ebp], 0
	mov	ecx, DWORD PTR $T585408[ebp]
	mov	edx, DWORD PTR __Cat$585412[ebp]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	eax, DWORD PTR __Newvec$133618[ebp]
	call	??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	mov	BYTE PTR $T585584[ebp], 0
	mov	ecx, DWORD PTR $T585584[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Cat$585587[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$133618[ebp]
	lea	eax, DWORD PTR [ebx+eax*8]
	push	ecx
	call	??$_Uninit_copy@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@00AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+16]
	sub	edx, eax
	sar	edx, 3
	add	esp, 12					; 0000000cH
	add	edi, edx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN117@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN117@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	ecx, DWORD PTR [ebx+eax*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [ebx+edi*8]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+16], edx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+12], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$133618[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN131@Insert_n@5:
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR __Where$[ebp+4]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, ebx
	sub	ecx, edx
	sar	ecx, 3
	cmp	ecx, edi
	mov	ecx, DWORD PTR [eax]
	jae	SHORT $LN3@Insert_n@5
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$133633[ebp+4], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [edi*8]
	mov	DWORD PTR tv515[ebp], eax
	add	eax, edx
	push	eax
	push	ebx
	mov	DWORD PTR __Tmp$133633[ebp], ecx
	call	??$_Umove@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU234@00@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Umove<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp+4]
	mov	BYTE PTR $T585631[ebp], 0
	mov	edx, DWORD PTR $T585631[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$585634[ebp]
	sar	ecx, 3
	push	edx
	sub	edi, ecx
	mov	ecx, edi
	push	eax
	lea	edx, DWORD PTR __Tmp$133633[ebp]
	call	??$_Uninit_fill_n@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IU123@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IABU123@AAV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,unsigned int,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	sub	edx, eax
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR __Tmp$133633[ebp]

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN129@Insert_n@5
$LN3@Insert_n@5:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR [eax+4]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [edi*8]
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	mov	DWORD PTR __Tmp$133643[ebp+4], edx
	push	ebx
	mov	edx, edi
	mov	DWORD PTR __Tmp$133643[ebp], ecx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU234@00@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Umove<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>
	mov	DWORD PTR [esi+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	esi, DWORD PTR __Where$[ebp+4]
	mov	edx, ebx
	mov	ecx, edi
	call	??$_Unchecked_move_backward@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@PAU123@@stdext@@YAPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@0@PAU120@00@Z ; stdext::_Unchecked_move_backward<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR tv515[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax]
	lea	ecx, DWORD PTR __Tmp$133643[ebp]
$LN129@Insert_n@5:
	push	eax
	call	??$fill@PAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@U123@@std@@YAXPAU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@0ABU123@@Z ; std::fill<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position *,stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position>
	add	esp, 4
$LN1@Insert_n@5:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN128@Insert_n@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Count$ = 12						; size = 4
__Where$ = 16						; size = 8
?insert@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::insert, COMDAT
; __Val$ = edx

; 882  : 		{	// insert _Count * _Val at _Where

	push	ecx

; 883  : 		_Insert_n(_Where, _Count, _Val);

	mov	eax, DWORD PTR __Where$[esp+4]
	mov	ecx, DWORD PTR __Where$[esp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR _this$[esp+12]
	call	?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Insert_n
	pop	ecx

; 884  : 		}

	ret	16					; 00000010H
?insert@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::insert
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@00I_N@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
__First$ = 16						; size = 8
__Last$ = 24						; size = 8
?_Splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@00I_N@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Splice, COMDAT
; _this$ = ecx
; __Right$ = esi

; 1126 : 		{	// splice _Right [_First, _Last) before _Where

	push	ecx

; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 		if (_Where._Mycont != this)
; 1129 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1130 : 		if (this->_Alval == _Right._Alval)
; 1131 : 			{	// same allocator, just relink
; 1132 : 			if (!_Keep && this != &_Right)
; 1133 : 				for (const_iterator _Next = _First; _Next != _Last; )
; 1134 : 					_Orphan_ptr(_Right, (_Next++)._Ptr);
; 1135 : 
; 1136 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1137 :         _Keep;                  // unused in this branch
; 1138 : 		if (this->_Alval == _Right._Alval)
; 1139 : 			{	// same allocator, just relink
; 1140 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1141 : 
; 1142 : 			if (this != &_Right)

	cmp	ecx, esi
	je	SHORT $LN2@Splice@2

; 1143 : 				{	// splicing from another list, adjust counts
; 1144 : 				_Incsize(_Count);

	call	?_Incsize@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@IAEXI@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Incsize

; 1145 : 				_Right._Mysize -= _Count;

	dec	DWORD PTR [esi+24]
$LN2@Splice@2:

; 1146 : 				}
; 1147 : 			_Nextnode(_Prevnode(_First._Mynode())) = _Last._Mynode();

	mov	eax, DWORD PTR __First$[esp+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Last$[esp+4]
	mov	DWORD PTR [ecx], edx

; 1148 : 			_Nextnode(_Prevnode(_Last._Mynode())) = _Where._Mynode();

	mov	eax, DWORD PTR __Last$[esp+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Where$[esp+4]
	mov	DWORD PTR [ecx], edx

; 1149 : 			_Nextnode(_Prevnode(_Where._Mynode())) = _First._Mynode();

	mov	eax, DWORD PTR __Where$[esp+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __First$[esp+4]
	mov	DWORD PTR [ecx], edx

; 1150 : 			_Nodeptr _Pnode = _Prevnode(_Where._Mynode());

	mov	eax, DWORD PTR __Where$[esp+4]

; 1151 : 			_Prevnode(_Where._Mynode()) = _Prevnode(_Last._Mynode());

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+4], edx

; 1152 : 			_Prevnode(_Last._Mynode()) = _Prevnode(_First._Mynode());

	mov	eax, DWORD PTR __First$[esp+4]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[esp+4]
	mov	DWORD PTR [eax+4], edx

; 1153 : 			_Prevnode(_First._Mynode()) = _Pnode;

	mov	edx, DWORD PTR __First$[esp+4]
	mov	DWORD PTR [edx+4], ecx
	pop	ecx

; 1154 : 			}
; 1155 : 		else
; 1156 : 			{	// different allocator, copy nodes then erase source
; 1157 : 			insert(_Where, _First, _Last);
; 1158 : 			_Right.erase(_First, _Last);
; 1159 : 			}
; 1160 :         }

	ret	24					; 00000018H
?_Splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@00I_N@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Splice
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
_TEXT	SEGMENT
__Tmp$ = -16						; size = 8
$T585774 = -8						; size = 8
__Count$ = 8						; size = 4
?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Assign_n, COMDAT
; _this$ = ecx
; __Val$ = eax

; 1095 : 		{	// assign _Count * _Val

	sub	esp, 16					; 00000010H

; 1096 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR [eax+4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 1097 : 		erase(begin(), end());

	mov	esi, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[esp+32], ecx
	mov	DWORD PTR __Tmp$[esp+36], edx
	cmp	DWORD PTR [edi+12], esi
	jbe	SHORT $LN8@Assign_n@2
	call	__invalid_parameter_noinfo
$LN8@Assign_n@2:
	mov	ebx, DWORD PTR [edi+12]
	mov	ebp, DWORD PTR [edi]
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN24@Assign_n@2
	call	__invalid_parameter_noinfo
$LN24@Assign_n@2:
	mov	eax, DWORD PTR [edi]
	push	esi
	push	ebp
	push	ebx
	push	eax
	lea	eax, DWORD PTR $T585774[esp+48]
	push	eax
	call	?erase@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@0@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::erase

; 1098 : 		insert(begin(), _Count, _Tmp);

	mov	esi, DWORD PTR [edi+12]
	cmp	esi, DWORD PTR [edi+16]
	jbe	SHORT $LN40@Assign_n@2
	call	__invalid_parameter_noinfo
$LN40@Assign_n@2:
	mov	eax, DWORD PTR [edi]
	push	esi
	push	eax
	lea	ecx, DWORD PTR __Tmp$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+40]
	mov	edx, edi
	call	?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Insert_n

; 1099 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Assign_n
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@0@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Where$ = 12						; size = 8
__First$ = 20						; size = 8
?splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@0@Z PROC ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::splice, COMDAT
; __Right$ = eax

; 883  : 		{	// splice _Right [_First, _First + 1) at _Where

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]
	push	esi
	mov	esi, eax

; 884  : 
; 885  :  #if _HAS_ITERATOR_DEBUGGING
; 886  : 		if (_First == _Right.end())
; 887  : 			_DEBUG_ERROR("list splice iterator outside range");
; 888  : 		else
; 889  : 
; 890  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 891  : 		if (_First != _Right.end())

	mov	eax, DWORD PTR __First$[esp+8]
	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN24@splice@2
	cmp	eax, ecx
	je	SHORT $LN25@splice@2
$LN24@splice@2:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+12]
$LN25@splice@2:
	mov	ecx, DWORD PTR __First$[esp+16]
	cmp	ecx, edi
	je	SHORT $LN2@splice@2

; 892  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 893  : 
; 894  : 			{	// element exists, try splice
; 895  : 			const_iterator _Last = _First;

	mov	ebx, eax
	mov	edi, ecx

; 896  : 			++_Last;

	test	eax, eax
	jne	SHORT $LN71@splice@2
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+12]
	xor	ecx, ecx
$LN44@splice@2:
	cmp	edi, DWORD PTR [ecx+20]
	jne	SHORT $LN33@splice@2
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+12]
$LN33@splice@2:
	mov	edi, DWORD PTR [edi]

; 897  : 			if (this != &_Right
; 898  : 				|| (_Where != _First && _Where != _Last))

	mov	ecx, DWORD PTR __Where$[esp+12]
	cmp	ebp, esi
	jne	SHORT $LN1@splice@2
	test	ecx, ecx
	je	SHORT $LN51@splice@2
	cmp	ecx, eax
	je	SHORT $LN52@splice@2
$LN51@splice@2:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+12]
	mov	ecx, DWORD PTR __Where$[esp+12]
$LN52@splice@2:
	mov	edx, DWORD PTR __First$[esp+16]
	cmp	DWORD PTR __Where$[esp+16], edx
	je	SHORT $LN2@splice@2
	test	ecx, ecx
	je	SHORT $LN62@splice@2
	cmp	ecx, ebx
	je	SHORT $LN63@splice@2
$LN62@splice@2:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First$[esp+12]
	mov	ecx, DWORD PTR __Where$[esp+12]
$LN63@splice@2:
	cmp	DWORD PTR __Where$[esp+16], edi
	je	SHORT $LN2@splice@2
$LN1@splice@2:

; 899  : 				_Splice(_Where, _Right, _First, _Last, 1);

	mov	edx, DWORD PTR __First$[esp+16]
	push	edi
	push	ebx
	push	edx
	push	eax
	mov	eax, DWORD PTR __Where$[esp+32]
	push	eax
	push	ecx
	mov	ecx, ebp
	call	?_Splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@00I_N@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::_Splice
$LN2@splice@2:

; 900  : 			}
; 901  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	20					; 00000014H
$LN71@splice@2:

; 896  : 			++_Last;

	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN44@splice@2
?splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@0@Z ENDP ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::splice
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT
$T586177 = -4						; size = 1
__Cat$586181 = -4					; size = 1
?_Ufill@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@PAV32@IABV32@@Z PROC ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	BYTE PTR $T586177[esp+4], 0
	mov	eax, DWORD PTR $T586177[esp+4]
	mov	ecx, DWORD PTR __Cat$586181[esp+4]
	push	eax
	push	ecx
	push	edx
	push	edi
	mov	ecx, esi
	call	??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > *,unsigned int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [esi+esi*2]
	lea	eax, DWORD PTR [edi+eax*8]

; 1256 : 		}

	add	esp, 20					; 00000014H
	ret	0
?_Ufill@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@IAEPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@PAV32@IABV32@@Z ENDP ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1102 : 		{	// allocate array with _Capacity elements

	push	ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@22

; 1105 : 			return (false);

	xor	al, al
	pop	ecx

; 1115 : 		}

	ret	0
$LN4@Buy@22:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@22

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN14@Buy@22:
$LN2@Buy@22:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	ecx

; 1115 : 		}

	ret	0
$LN13@Buy@22:
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?assign@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z PROC ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::assign, COMDAT
; _this$ = ecx
; __Count$ = eax

; 871  : 		_Assign_n(_Count, _Val);

	push	eax
	mov	eax, DWORD PTR __Val$[esp]
	call	?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Assign_n

; 872  : 		}

	ret	4
?assign@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ENDP ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@IAEPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT
$T586219 = -4						; size = 1
__Cat$586223 = -4					; size = 1
?_Ufill@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@IAEPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@PAV32@IABV32@@Z PROC ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	BYTE PTR $T586219[esp+4], 0
	mov	eax, DWORD PTR $T586219[esp+4]
	mov	ecx, DWORD PTR __Cat$586223[esp+4]
	push	eax
	push	ecx
	push	edx
	push	edi
	mov	ecx, esi
	call	??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > *,unsigned int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [esi+esi*2]
	lea	eax, DWORD PTR [edi+eax*8]

; 1256 : 		}

	add	esp, 20					; 00000014H
	ret	0
?_Ufill@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@IAEPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@PAV32@IABV32@@Z ENDP ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Ufill
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z$0
__tryblocktable$?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z$2
__ehfuncinfo$?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z
_TEXT	SEGMENT
tv202 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$586287 = 8					; size = 1
_this$ = 8						; size = 4
$T586283 = 12						; size = 1
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z PROC ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Construct_n, COMDAT

; 545  : 		{	// construct from _Count * _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR __Count$[ebp]
	mov	esi, DWORD PTR _this$[ebp]

; 546  : 		if (_Buy(_Count))

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	cmp	ebx, eax
	je	SHORT $LN7@Construct_@8
	cmp	ebx, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN10@Construct_@8
	call	?_Xlen@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Xlen
$LN32@Construct_@8:
$LN10@Construct_@8:
	mov	ecx, ebx
	call	?allocate@?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@std@@QAEPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@I@Z ; std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > >::allocate

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	mov	edi, eax
	lea	eax, DWORD PTR [ebx+ebx*2]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv202[ebp], eax
	add	eax, edi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR __Cat$586287[ebp]
	mov	DWORD PTR [esi+20], eax
	mov	BYTE PTR $T586283[ebp], 0
	mov	eax, DWORD PTR $T586283[ebp]
	push	eax
	push	ecx
	push	edx
	push	edi
	mov	ecx, ebx
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	call	??$_Uninit_fill_n@PAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > *,unsigned int,std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
	mov	eax, DWORD PTR tv202[ebp]
	add	esp, 16					; 00000010H
	add	eax, edi
	mov	DWORD PTR [esi+16], eax
$LN7@Construct_@8:

; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z$0:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Tidy

; 552  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN33@Construct_@8:
$LN31@Construct_@8:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z ENDP ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Construct_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n, COMDAT
; _this$ = esi
; __Count$ = edi

; 545  : 		{	// construct from _Count * _Val

	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	push	ebp

; 546  : 		if (_Buy(_Count))

	xor	ebp, ebp
	mov	DWORD PTR [esi+12], ebp
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebp
	cmp	edi, ebp
	je	SHORT $LN5@Construct_@9
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN10@Construct_@9
	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN50@Construct_@9:
$LN10@Construct_@9:
	mov	ecx, edi
	call	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	ecx, edi
	mov	edx, eax
	cmp	edi, ebp
	jbe	SHORT $LN40@Construct_@9
	npad	3
$LL42@Construct_@9:
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR [edx], ebp
	dec	ecx
	add	edx, 4
	test	ecx, ecx
	ja	SHORT $LL42@Construct_@9
$LN40@Construct_@9:
	lea	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+16], edx
$LN5@Construct_@9:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();
; 552  : 			_RERAISE;
; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	pop	ebp
	pop	ebx
	ret	4
$LN49@Construct_@9:
?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Init@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXI@Z
_TEXT	SEGMENT
$T586516 = -12						; size = 8
?_Init@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXI@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Init, COMDAT
; _this$ = esi
; __Buckets$ = edi

; 830  : 		_Vec.assign(_Buckets + 1, end());

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+28]
	sub	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN25@Init@5
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN26@Init@5
$LN25@Init@5:
	xor	eax, eax
$LN26@Init@5:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T586516[esp+16], ecx
	lea	ecx, DWORD PTR [edi+1]
	mov	DWORD PTR $T586516[esp+12], eax
	push	ecx
	lea	ecx, DWORD PTR [esi+36]
	lea	eax, DWORD PTR $T586516[esp+16]
	call	?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Assign_n

; 831  : 		_Mask = _Buckets - 1;

	lea	edx, DWORD PTR [edi-1]
	mov	DWORD PTR [esi+60], edx

; 832  : 		_Maxidx = _Buckets;

	mov	DWORD PTR [esi+64], edi

; 833  : 		}

	add	esp, 12					; 0000000cH
	ret	0
?_Init@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXI@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Init
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z$1
__ehfuncinfo$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
xdata$x	ENDS
;	COMDAT ??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z
_TEXT	SEGMENT
$T586933 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Parg$ = 12						; size = 4
??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >, COMDAT

; 343  : 		{	// construct empty hash table

	push	-1
	push	__ehhandler$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+32]
	mov	eax, DWORD PTR __Parg$[esp+32]
	mov	cx, WORD PTR [eax]
	lea	edi, DWORD PTR [esi+8]
	push	edi
	mov	WORD PTR [esi+4], cx
	call	??0?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBII@std@@@1@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
	lea	ebx, DWORD PTR [esi+36]
	push	ebx
	mov	DWORD PTR __$EHRec$[esp+48], 0
	call	??0?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@ABV?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@1@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
	mov	BYTE PTR __$EHRec$[esp+44], 1
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [esi+68], xmm0

; 344  : 		_Init();

	mov	eax, DWORD PTR [edi+20]
	mov	edi, DWORD PTR [edi]
	test	edi, edi
	je	SHORT $LN33@Hash@4
	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LN34@Hash@4
$LN33@Hash@4:
	xor	edi, edi
$LN34@Hash@4:
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR $T586933[esp+40], eax
	push	9
	lea	eax, DWORD PTR $T586933[esp+40]
	mov	ecx, ebx
	mov	DWORD PTR $T586933[esp+40], edx
	call	?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Assign_n
	mov	DWORD PTR [esi+60], 7
	mov	DWORD PTR [esi+64], 8

; 345  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 8
	jmp	??1?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE@XZ ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::~list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z$1:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 36					; 00000024H
	jmp	??1?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE@XZ ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::~vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >
__ehhandler$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z$0
__tryblocktable$?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z$2
__ehfuncinfo$?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z
_TEXT	SEGMENT
tv202 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$587004 = 8					; size = 1
_this$ = 8						; size = 4
$T587000 = 12						; size = 1
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z PROC ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Construct_n, COMDAT

; 545  : 		{	// construct from _Count * _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR __Count$[ebp]
	mov	esi, DWORD PTR _this$[ebp]

; 546  : 		if (_Buy(_Count))

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	cmp	ebx, eax
	je	SHORT $LN7@Construct_@10
	cmp	ebx, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN10@Construct_@10
	call	?_Xlen@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Xlen
$LN32@Construct_@10:
$LN10@Construct_@10:
	mov	ecx, ebx
	call	?allocate@?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@std@@QAEPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@I@Z ; std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::allocate

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	mov	edi, eax
	lea	eax, DWORD PTR [ebx+ebx*2]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv202[ebp], eax
	add	eax, edi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR __Cat$587004[ebp]
	mov	DWORD PTR [esi+20], eax
	mov	BYTE PTR $T587000[ebp], 0
	mov	eax, DWORD PTR $T587000[ebp]
	push	eax
	push	ecx
	push	edx
	push	edi
	mov	ecx, ebx
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	call	??$_Uninit_fill_n@PAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@IV12@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@YAXPAV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@0@IABV10@AAV?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > *,unsigned int,std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
	mov	eax, DWORD PTR tv202[ebp]
	add	esp, 16					; 00000010H
	add	eax, edi
	mov	DWORD PTR [esi+16], eax
$LN7@Construct_@10:

; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z$0:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Tidy

; 552  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN33@Construct_@10:
$LN31@Construct_@10:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z ENDP ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Construct_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@@Z$0
__ehfuncinfo$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@@Z PROC ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >, COMDAT

; 488  : 		{	// construct from _Count * _Val

	push	-1
	push	__ehhandler$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@vector@59
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@59
$LN13@vector@59:
	xor	eax, eax
$LN14@vector@59:
	mov	DWORD PTR [esi], eax

; 489  : 		_Construct_n(_Count, _Val);

	mov	eax, DWORD PTR __Val$[esp+20]
	mov	ecx, DWORD PTR __Count$[esp+20]
	push	eax
	push	ecx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+44], 0
	call	?_Construct_n@?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@2@@Z ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::_Construct_n

; 490  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@@Z ENDP ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ?reserve@?$vector@_JV?$allocator@_J@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@_JV?$allocator@_J@std@@@std@@QAEXI@Z PROC ; std::vector<__int64,std::allocator<__int64> >::reserve, COMDAT
; _this$ = esi

; 602  : 		{	// determine new minimum length of allocated storage

	push	ecx

; 603  : 		if (max_size() < _Count)

	mov	ecx, DWORD PTR __Count$[esp]
	push	ebx
	push	ebp
	push	edi
	cmp	ecx, 536870911				; 1fffffffH
	jbe	SHORT $LN5@reserve@6

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ ; std::vector<__int64,std::allocator<__int64> >::_Xlen
$LN97@reserve@6:
$LN5@reserve@6:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR [esi+12]
	test	edx, edx
	jne	SHORT $LN20@reserve@6
	xor	eax, eax
	jmp	SHORT $LN21@reserve@6
$LN20@reserve@6:
	mov	eax, DWORD PTR [esi+20]
	sub	eax, edx
	sar	eax, 3
$LN21@reserve@6:
	cmp	eax, ecx
	jae	SHORT $LN3@reserve@6

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	call	?allocate@?$allocator@_J@std@@QAEPA_JI@Z ; std::allocator<__int64>::allocate

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	edi, DWORD PTR [esi+16]
	mov	ebx, eax
	cmp	DWORD PTR [esi+12], edi
	jbe	SHORT $LN27@reserve@6
	call	__invalid_parameter_noinfo
$LN27@reserve@6:
	mov	ebp, DWORD PTR [esi+12]
	cmp	ebp, DWORD PTR [esi+16]
	jbe	SHORT $LN43@reserve@6
	call	__invalid_parameter_noinfo
$LN43@reserve@6:
	sub	edi, ebp
	sar	edi, 3
	test	edi, edi
	jbe	SHORT $LN86@reserve@6
	lea	eax, DWORD PTR [edi*8]
	push	eax
	push	ebp
	push	eax
	push	ebx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN86@reserve@6:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);
; 613  : 			_RERAISE;
; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+16]
	sub	edi, eax
	sar	edi, 3

; 617  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN93@reserve@6

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);
; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN93@reserve@6:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[esp+12]
	lea	ecx, DWORD PTR [ebx+eax*8]

; 628  : 			_Mylast = _Ptr + _Size;

	lea	edx, DWORD PTR [ebx+edi*8]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+16], edx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+12], ebx
$LN3@reserve@6:

; 630  : 			}
; 631  : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN96@reserve@6:
?reserve@?$vector@_JV?$allocator@_J@std@@@std@@QAEXI@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::reserve
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
$T587551 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; __Count$ = edi

; 482  : 		{	// construct from _Count * _Ty()

	push	-1
	push	__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@60
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@60
$LN13@vector@60:
	xor	eax, eax
$LN14@vector@60:
	mov	DWORD PTR [esi], eax

; 483  : 		_Construct_n(_Count, _Ty());

	lea	eax, DWORD PTR $T587551[esp+24]
	mov	DWORD PTR __$EHRec$[esp+32], ecx
	push	eax
	mov	DWORD PTR $T587551[esp+28], ecx
	call	?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n

; 484  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >, COMDAT
; _this$ = esi

; 103  : 		{	// construct empty map from defaults

	push	esi
	call	??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >

; 104  : 		}

	mov	eax, esi
	ret	0
??0?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAE@XZ PROC ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >, COMDAT
; _this$ = esi

; 103  : 		{	// construct empty map from defaults

	push	esi
	call	??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >

; 104  : 		}

	mov	eax, esi
	ret	0
??0?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAE@XZ ENDP ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ
_TEXT	SEGMENT
$T587958 = -12						; size = 8
?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear, COMDAT
; _this$ = esi

; 614  : 		_List.clear();

	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ecx
	mov	ecx, DWORD PTR [esi+28]
	sub	esp, 16					; 00000010H
	mov	DWORD PTR [ecx+4], ecx
	push	edi
	mov	DWORD PTR [esi+32], 0
	cmp	eax, DWORD PTR [esi+28]
	je	SHORT $LN3@clear@20
	npad	3
$LL5@clear@20:
	mov	edi, DWORD PTR [eax]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, edi
	cmp	edi, DWORD PTR [esi+28]
	jne	SHORT $LL5@clear@20
$LN3@clear@20:

; 615  : 		_Init();

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN42@clear@20
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN43@clear@20
$LN42@clear@20:
	xor	eax, eax
$LN43@clear@20:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T587958[esp+24], ecx
	mov	DWORD PTR $T587958[esp+20], eax
	push	9
	lea	ecx, DWORD PTR [esi+36]
	lea	eax, DWORD PTR $T587958[esp+24]
	call	?_Assign_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXIABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Assign_n
	mov	DWORD PTR [esi+60], 7
	mov	DWORD PTR [esi+64], 8

; 616  : 		}

	pop	edi
	add	esp, 16					; 00000010H
	ret	0
?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ??0?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
_TEXT	SEGMENT
$T587966 = -2						; size = 2
??0?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ PROC ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >, COMDAT
; _this$ = esi

; 118  : 		{	// construct empty map from defaults

	push	ecx
	lea	eax, DWORD PTR $T587966[esp+4]
	push	eax
	push	esi
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >

; 119  : 		}

	mov	eax, esi
	pop	ecx
	ret	0
??0?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ ENDP ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@@Z$0
__ehfuncinfo$??0?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??0?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@@Z PROC ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >, COMDAT

; 488  : 		{	// construct from _Count * _Val

	push	-1
	push	__ehhandler$??0?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@vector@61
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@61
$LN13@vector@61:
	xor	eax, eax
$LN14@vector@61:
	mov	DWORD PTR [esi], eax

; 489  : 		_Construct_n(_Count, _Val);

	mov	eax, DWORD PTR __Val$[esp+20]
	mov	ecx, DWORD PTR __Count$[esp+20]
	push	eax
	push	ecx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+44], 0
	call	?_Construct_n@?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAEXIABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@2@@Z ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::_Construct_n

; 490  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@@Z ENDP ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
PUBLIC	?clear@Statistics@DRAMsimII@@QAEXXZ		; DRAMsimII::Statistics::clear
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.cpp
_TEXT	SEGMENT
_h$126951 = -8						; size = 8
_h$126713 = -8						; size = 8
_h$126567 = -8						; size = 8
_this$ = 8						; size = 4
?clear@Statistics@DRAMsimII@@QAEXXZ PROC		; DRAMsimII::Statistics::clear

; 376  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _this$[esp+20]

; 377  : 	using std::vector;
; 378  : 
; 379  : 	commandTurnaround.clear();

	lea	esi, DWORD PTR [edi+252]
	call	?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear

; 380  : 	commandDelay.clear();	

	lea	esi, DWORD PTR [edi+108]
	call	?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear

; 381  : 	commandExecution.clear();

	lea	esi, DWORD PTR [edi+180]
	call	?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear

; 382  : 	transactionExecution.clear();

	lea	esi, DWORD PTR [edi+396]
	call	?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear

; 383  : 	transactionDecodeDelay.clear();

	lea	esi, DWORD PTR [edi+324]
	call	?clear@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::clear

; 384  : 	workingSet.clear();

	mov	eax, DWORD PTR [edi+524]
	mov	ecx, DWORD PTR [eax+4]
	lea	esi, DWORD PTR [edi+500]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+24]
	xor	ecx, ecx
	mov	DWORD PTR [esi+28], ecx
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], esi

; 385  : 	issuedAtTFAW = readBytesTransferred = writeBytesTransferred = readCount = writeCount = 0;

	mov	DWORD PTR [edi+40], ecx
	mov	DWORD PTR [edi+36], ecx
	mov	DWORD PTR [edi+48], ecx
	mov	DWORD PTR [edi+44], ecx
	mov	DWORD PTR [edi+104], ecx

; 386  : 	for (vector<vector<pair<unsigned,unsigned> > >::iterator h = rowBufferAccesses.begin(); h != rowBufferAccesses.end(); h++)

	mov	esi, DWORD PTR [edi+68]
	cmp	esi, DWORD PTR [edi+72]
	jbe	SHORT $LN50@clear@21
	call	__invalid_parameter_noinfo
$LN50@clear@21:
	mov	ebp, DWORD PTR [edi+56]
	mov	DWORD PTR _h$126567[esp+24], ebp
	mov	ebx, esi
$LL67@clear@21:
	mov	esi, DWORD PTR [edi+72]
	cmp	DWORD PTR [edi+68], esi
	jbe	SHORT $LN82@clear@21
	call	__invalid_parameter_noinfo
$LN82@clear@21:
	mov	eax, DWORD PTR [edi+56]
	test	ebp, ebp
	je	SHORT $LN95@clear@21
	cmp	ebp, eax
	je	SHORT $LN96@clear@21
$LN95@clear@21:
	call	__invalid_parameter_noinfo
$LN96@clear@21:
	cmp	ebx, esi
	je	$LN22@clear@21

; 387  : 	{
; 388  : 		for (vector<pair<unsigned,unsigned> >::iterator i = h->begin(); i != h->end(); i++)

	test	ebp, ebp
	jne	$LN674@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN116@clear@21:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN107@clear@21
	call	__invalid_parameter_noinfo
$LN107@clear@21:
	mov	edi, DWORD PTR [ebx+12]
	cmp	edi, DWORD PTR [ebx+16]
	jbe	SHORT $LN124@clear@21
	call	__invalid_parameter_noinfo
$LN124@clear@21:
	mov	esi, DWORD PTR [ebx]
	mov	ebp, edi
$LL141@clear@21:
	mov	eax, DWORD PTR _h$126567[esp+24]
	test	eax, eax
	jne	$LN673@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN164@clear@21:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN155@clear@21
	call	__invalid_parameter_noinfo
$LN155@clear@21:
	mov	edi, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], edi
	ja	SHORT $LN171@clear@21
	cmp	edi, edi
	jbe	SHORT $LN172@clear@21
$LN171@clear@21:
	call	__invalid_parameter_noinfo
$LN172@clear@21:
	mov	eax, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN185@clear@21
	cmp	esi, eax
	je	SHORT $LN186@clear@21
$LN185@clear@21:
	call	__invalid_parameter_noinfo
$LN186@clear@21:
	cmp	ebp, edi
	je	SHORT $LN23@clear@21

; 389  : 		{
; 390  : 			i->first = i->second = 0;

	test	esi, esi
	jne	SHORT $LN672@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN206@clear@21:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN197@clear@21
	call	__invalid_parameter_noinfo
$LN197@clear@21:
	mov	DWORD PTR [ebp+4], 0
	test	esi, esi
	jne	SHORT $LN671@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN222@clear@21:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN213@clear@21
	call	__invalid_parameter_noinfo
$LN213@clear@21:
	mov	DWORD PTR [ebp], 0
	test	esi, esi
	jne	SHORT $LN670@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN148@clear@21:

; 387  : 	{
; 388  : 		for (vector<pair<unsigned,unsigned> >::iterator i = h->begin(); i != h->end(); i++)

	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN139@clear@21
	call	__invalid_parameter_noinfo
$LN139@clear@21:
	add	ebp, 8
	jmp	$LL141@clear@21
$LN674@clear@21:
	mov	eax, DWORD PTR [ebp]
	jmp	$LN116@clear@21
$LN673@clear@21:
	mov	eax, DWORD PTR [eax]
	jmp	$LN164@clear@21
$LN672@clear@21:

; 389  : 		{
; 390  : 			i->first = i->second = 0;

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN206@clear@21
$LN671@clear@21:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN222@clear@21
$LN670@clear@21:

; 387  : 	{
; 388  : 		for (vector<pair<unsigned,unsigned> >::iterator i = h->begin(); i != h->end(); i++)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN148@clear@21
$LN23@clear@21:

; 386  : 	for (vector<vector<pair<unsigned,unsigned> > >::iterator h = rowBufferAccesses.begin(); h != rowBufferAccesses.end(); h++)

	mov	eax, DWORD PTR _h$126567[esp+24]
	test	eax, eax
	jne	SHORT $LN669@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN74@clear@21:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN65@clear@21
	call	__invalid_parameter_noinfo
$LN65@clear@21:
	mov	edi, DWORD PTR _this$[esp+20]
	mov	ebp, DWORD PTR _h$126567[esp+24]
	add	ebx, 24					; 00000018H
	jmp	$LL67@clear@21
$LN669@clear@21:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN74@clear@21
$LN22@clear@21:

; 391  : 		}
; 392  : 	}
; 393  : 
; 394  : 	for (vector<unsigned>::size_type i = 0; i < aggregateBankUtilization.size(); i++)

	mov	edx, DWORD PTR [edi+548]
	sub	edx, DWORD PTR [edi+544]
	xor	esi, esi
	sar	edx, 2
	test	edx, edx
	jbe	SHORT $LN16@clear@21
	npad	13
$LL18@clear@21:

; 395  : 		aggregateBankUtilization[i] = 0;

	mov	eax, DWORD PTR [edi+548]
	sub	eax, DWORD PTR [edi+544]
	sar	eax, 2
	cmp	esi, eax
	jb	SHORT $LN227@clear@21
	call	__invalid_parameter_noinfo
$LN227@clear@21:
	mov	ecx, DWORD PTR [edi+544]
	mov	DWORD PTR [ecx+esi*4], 0
	mov	edx, DWORD PTR [edi+548]
	sub	edx, DWORD PTR [edi+544]
	inc	esi
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LL18@clear@21
$LN16@clear@21:

; 396  : 	for (vector<unsigned>::size_type i = 0; i < bankLatencyUtilization.size(); i++)

	mov	eax, DWORD PTR [edi+572]
	sub	eax, DWORD PTR [edi+568]
	xor	esi, esi
	sar	eax, 3
	test	eax, eax
	jbe	SHORT $LN13@clear@21
	npad	2
$LL15@clear@21:

; 397  : 		bankLatencyUtilization[i] = 0;

	mov	ecx, DWORD PTR [edi+572]
	sub	ecx, DWORD PTR [edi+568]
	sar	ecx, 3
	cmp	esi, ecx
	jb	SHORT $LN234@clear@21
	call	__invalid_parameter_noinfo
$LN234@clear@21:
	mov	eax, DWORD PTR [edi+568]
	mov	DWORD PTR [eax+esi*8], 0
	mov	DWORD PTR [eax+esi*8+4], 0
	mov	edx, DWORD PTR [edi+572]
	sub	edx, DWORD PTR [edi+568]
	inc	esi
	sar	edx, 3
	cmp	esi, edx
	jb	SHORT $LL15@clear@21
$LN13@clear@21:

; 398  : 	pcOccurrence.clear();

	mov	esi, DWORD PTR _this$[esp+20]
	mov	eax, DWORD PTR [esi+492]
	mov	ebp, DWORD PTR [eax+4]
	add	esi, 468				; 000001d4H
	cmp	BYTE PTR [ebp+41], 0
	mov	edi, ebp
	jne	SHORT $LN245@clear@21
	npad	4
$LL247@clear@21:
	mov	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Erase
	mov	edi, DWORD PTR [edi]
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [edi+41], 0
	mov	ebp, edi
	je	SHORT $LL247@clear@21
$LN245@clear@21:
	mov	eax, DWORD PTR [esi+24]

; 399  : 
; 400  : 	for (vector<vector<pair<pair<uint64_t, uint64_t>, pair<uint64_t, uint64_t> > > >::iterator h = hitRate.begin(); h != hitRate.end(); h++)

	mov	edi, DWORD PTR _this$[esp+20]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+24]
	xor	ebx, ebx
	mov	DWORD PTR [esi+28], ebx
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], esi
	mov	esi, DWORD PTR [edi+592]
	cmp	esi, DWORD PTR [edi+596]
	jbe	SHORT $LN275@clear@21
	call	__invalid_parameter_noinfo
$LN275@clear@21:
	mov	ebp, DWORD PTR [edi+580]
	mov	DWORD PTR _h$126713[esp+24], ebp
	mov	DWORD PTR _h$126713[esp+28], esi
	npad	7
$LL292@clear@21:
	mov	esi, DWORD PTR [edi+596]
	cmp	DWORD PTR [edi+592], esi
	jbe	SHORT $LN307@clear@21
	call	__invalid_parameter_noinfo
$LN307@clear@21:
	mov	eax, DWORD PTR [edi+580]
	cmp	ebp, ebx
	je	SHORT $LN320@clear@21
	cmp	ebp, eax
	je	SHORT $LN321@clear@21
$LN320@clear@21:
	call	__invalid_parameter_noinfo
$LN321@clear@21:
	cmp	DWORD PTR _h$126713[esp+28], esi
	je	$LN10@clear@21

; 401  : 	{
; 402  : 		for (vector<pair<pair<uint64_t, uint64_t>, pair<uint64_t, uint64_t> > >::iterator i = h->begin(); i != h->end(); i++)

	cmp	ebp, ebx
	jne	$LN668@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN341@clear@21:
	mov	edx, DWORD PTR _h$126713[esp+28]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN332@clear@21
	call	__invalid_parameter_noinfo
$LN332@clear@21:
	mov	eax, DWORD PTR _h$126713[esp+28]
	mov	esi, DWORD PTR [eax+12]
	cmp	esi, DWORD PTR [eax+16]
	jbe	SHORT $LN349@clear@21
	call	__invalid_parameter_noinfo
$LN349@clear@21:
	mov	eax, DWORD PTR _h$126713[esp+28]
	mov	edi, DWORD PTR [eax]
$LL366@clear@21:
	cmp	ebp, ebx
	jne	$LN667@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN389@clear@21:
	mov	ecx, DWORD PTR _h$126713[esp+28]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN380@clear@21
	call	__invalid_parameter_noinfo
$LN380@clear@21:
	mov	eax, DWORD PTR _h$126713[esp+28]
	mov	ebp, DWORD PTR [eax+16]
	cmp	DWORD PTR [eax+12], ebp
	ja	SHORT $LN396@clear@21
	cmp	ebp, ebp
	jbe	SHORT $LN397@clear@21
$LN396@clear@21:
	call	__invalid_parameter_noinfo
$LN397@clear@21:
	mov	edx, DWORD PTR _h$126713[esp+28]
	mov	eax, DWORD PTR [edx]
	cmp	edi, ebx
	je	SHORT $LN410@clear@21
	cmp	edi, eax
	je	SHORT $LN411@clear@21
$LN410@clear@21:
	call	__invalid_parameter_noinfo
$LN411@clear@21:
	cmp	esi, ebp
	je	$LN11@clear@21

; 403  : 			i->first.first = i->first.second = i->second.first = i->second.second = 0;

	cmp	edi, ebx
	jne	$LN666@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN431@clear@21:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN422@clear@21
	call	__invalid_parameter_noinfo
$LN422@clear@21:
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+28], ebx
	cmp	edi, ebx
	jne	$LN665@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN447@clear@21:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN438@clear@21
	call	__invalid_parameter_noinfo
$LN438@clear@21:
	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	cmp	edi, ebx
	jne	SHORT $LN664@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN463@clear@21:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN454@clear@21
	call	__invalid_parameter_noinfo
$LN454@clear@21:
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	cmp	edi, ebx
	jne	SHORT $LN663@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN479@clear@21:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN470@clear@21
	call	__invalid_parameter_noinfo
$LN470@clear@21:
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	cmp	edi, ebx
	jne	SHORT $LN662@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN373@clear@21:

; 401  : 	{
; 402  : 		for (vector<pair<pair<uint64_t, uint64_t>, pair<uint64_t, uint64_t> > >::iterator i = h->begin(); i != h->end(); i++)

	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN364@clear@21
	call	__invalid_parameter_noinfo
$LN364@clear@21:
	mov	ebp, DWORD PTR _h$126713[esp+24]
	add	esi, 32					; 00000020H
	jmp	$LL366@clear@21
$LN668@clear@21:
	mov	eax, DWORD PTR [ebp]
	jmp	$LN341@clear@21
$LN667@clear@21:
	mov	eax, DWORD PTR [ebp]
	jmp	$LN389@clear@21
$LN666@clear@21:

; 403  : 			i->first.first = i->first.second = i->second.first = i->second.second = 0;

	mov	eax, DWORD PTR [edi]
	jmp	$LN431@clear@21
$LN665@clear@21:
	mov	eax, DWORD PTR [edi]
	jmp	$LN447@clear@21
$LN664@clear@21:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN463@clear@21
$LN663@clear@21:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN479@clear@21
$LN662@clear@21:

; 401  : 	{
; 402  : 		for (vector<pair<pair<uint64_t, uint64_t>, pair<uint64_t, uint64_t> > >::iterator i = h->begin(); i != h->end(); i++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN373@clear@21
$LN11@clear@21:

; 399  : 
; 400  : 	for (vector<vector<pair<pair<uint64_t, uint64_t>, pair<uint64_t, uint64_t> > > >::iterator h = hitRate.begin(); h != hitRate.end(); h++)

	mov	eax, DWORD PTR _h$126713[esp+24]
	cmp	eax, ebx
	jne	SHORT $LN661@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN299@clear@21:
	mov	ecx, DWORD PTR _h$126713[esp+28]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN290@clear@21
	call	__invalid_parameter_noinfo
$LN290@clear@21:
	add	DWORD PTR _h$126713[esp+28], 24		; 00000018H
	mov	edi, DWORD PTR _this$[esp+20]
	mov	ebp, DWORD PTR _h$126713[esp+24]
	jmp	$LL292@clear@21
$LN661@clear@21:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN299@clear@21
$LN10@clear@21:

; 404  : 	}
; 405  : 
; 406  : 	for (vector<vector<unsigned> >::iterator h = rasReduction.begin(); h != rasReduction.end(); h++)

	mov	esi, DWORD PTR [edi+92]
	cmp	esi, DWORD PTR [edi+96]
	jbe	SHORT $LN487@clear@21
	call	__invalid_parameter_noinfo
$LN487@clear@21:
	mov	ebp, DWORD PTR _this$[esp+20]
	mov	edi, DWORD PTR [ebp+80]
	mov	DWORD PTR _h$126951[esp+24], edi
	mov	ebx, esi
	npad	4
$LL504@clear@21:
	mov	esi, DWORD PTR [ebp+96]
	cmp	DWORD PTR [ebp+92], esi
	jbe	SHORT $LN519@clear@21
	call	__invalid_parameter_noinfo
$LN519@clear@21:
	mov	eax, DWORD PTR [ebp+80]
	test	edi, edi
	je	SHORT $LN532@clear@21
	cmp	edi, eax
	je	SHORT $LN533@clear@21
$LN532@clear@21:
	call	__invalid_parameter_noinfo
$LN533@clear@21:
	cmp	ebx, esi
	je	$LN4@clear@21

; 407  : 	{
; 408  : 		for (vector<unsigned>::iterator i = h->begin(); i != h->end(); i++)

	test	edi, edi
	jne	$LN660@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN553@clear@21:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN544@clear@21
	call	__invalid_parameter_noinfo
$LN544@clear@21:
	mov	edi, DWORD PTR [ebx+12]
	cmp	edi, DWORD PTR [ebx+16]
	jbe	SHORT $LN561@clear@21
	call	__invalid_parameter_noinfo
$LN561@clear@21:
	mov	esi, DWORD PTR [ebx]
	mov	ebp, edi
	npad	1
$LL578@clear@21:
	mov	eax, DWORD PTR _h$126951[esp+24]
	test	eax, eax
	jne	SHORT $LN659@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN601@clear@21:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN592@clear@21
	call	__invalid_parameter_noinfo
$LN592@clear@21:
	mov	edi, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], edi
	ja	SHORT $LN608@clear@21
	cmp	edi, edi
	jbe	SHORT $LN609@clear@21
$LN608@clear@21:
	call	__invalid_parameter_noinfo
$LN609@clear@21:
	mov	eax, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN622@clear@21
	cmp	esi, eax
	je	SHORT $LN623@clear@21
$LN622@clear@21:
	call	__invalid_parameter_noinfo
$LN623@clear@21:
	cmp	ebp, edi
	je	SHORT $LN5@clear@21

; 409  : 			*i = 0;

	test	esi, esi
	jne	SHORT $LN658@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN641@clear@21:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN632@clear@21
	call	__invalid_parameter_noinfo
$LN632@clear@21:
	mov	DWORD PTR [ebp], 0
	test	esi, esi
	jne	SHORT $LN657@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN585@clear@21:

; 407  : 	{
; 408  : 		for (vector<unsigned>::iterator i = h->begin(); i != h->end(); i++)

	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN576@clear@21
	call	__invalid_parameter_noinfo
$LN576@clear@21:
	add	ebp, 4
	jmp	SHORT $LL578@clear@21
$LN660@clear@21:
	mov	eax, DWORD PTR [edi]
	jmp	$LN553@clear@21
$LN659@clear@21:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN601@clear@21
$LN658@clear@21:

; 409  : 			*i = 0;

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN641@clear@21
$LN657@clear@21:

; 407  : 	{
; 408  : 		for (vector<unsigned>::iterator i = h->begin(); i != h->end(); i++)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN585@clear@21
$LN5@clear@21:

; 404  : 	}
; 405  : 
; 406  : 	for (vector<vector<unsigned> >::iterator h = rasReduction.begin(); h != rasReduction.end(); h++)

	mov	eax, DWORD PTR _h$126951[esp+24]
	test	eax, eax
	jne	SHORT $LN656@clear@21
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN511@clear@21:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN502@clear@21
	call	__invalid_parameter_noinfo
$LN502@clear@21:
	mov	edi, DWORD PTR _h$126951[esp+24]
	mov	ebp, DWORD PTR _this$[esp+20]
	add	ebx, 24					; 00000018H
	jmp	$LL504@clear@21
$LN656@clear@21:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN511@clear@21
$LN4@clear@21:

; 410  : 	}
; 411  : #ifdef M5
; 412  : 	//async_statdump =
; 413  : 	async_event = async_statreset = true;	
; 414  : #endif // M5DEBUG
; 415  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
?clear@Statistics@DRAMsimII@@QAEXXZ ENDP		; DRAMsimII::Statistics::clear
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Right$ = 12						; size = 4
??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT

; 500  : 		{	// construct by copying _Right

	push	-1
	push	__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR __Right$[esp+32]
	mov	esi, DWORD PTR _this$[esp+32]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN19@vector@70
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN20@vector@70
$LN19@vector@70:
	xor	eax, eax
$LN20@vector@70:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+44], ecx

; 501  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+16]
	sub	edi, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+12], ecx
	sar	edi, 2
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	cmp	edi, ecx
	je	SHORT $LN5@vector@70
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN46@vector@70
	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN110@vector@70:
$LN46@vector@70:
	mov	ecx, edi
	call	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], eax

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edi, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], edi
	jbe	SHORT $LN60@vector@70
	call	__invalid_parameter_noinfo
$LN60@vector@70:
	mov	ebp, DWORD PTR [ebx+12]
	cmp	ebp, DWORD PTR [ebx+16]
	jbe	SHORT $LN74@vector@70
	call	__invalid_parameter_noinfo
$LN74@vector@70:
	mov	ecx, DWORD PTR [esi+12]
	sub	edi, ebp
	sar	edi, 2
	lea	eax, DWORD PTR [edi*4]
	lea	ebx, DWORD PTR [eax+ecx]
	test	edi, edi
	jbe	SHORT $LN103@vector@70
	push	eax
	push	ebp
	push	eax
	push	ecx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN103@vector@70:
	mov	DWORD PTR [esi+16], ebx
$LN5@vector@70:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();
; 506  : 			_RERAISE;
; 507  : 			_CATCH_END
; 508  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
$LN109@vector@70:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$2:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@ABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@ABV10@@Z$0
__ehfuncinfo$??$_Construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@ABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@ABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@ABV10@@Z
_TEXT	SEGMENT
$T610174 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
??$_Construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@ABV10@@Z PROC ; std::_Construct<std::vector<unsigned int,std::allocator<unsigned int> >,std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT
; __Val$ = ecx

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Ptr$[esp+20]

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	DWORD PTR __Vptr$[esp+20], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T610174[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	eax, eax
	je	SHORT $LN3@Construct@27
	push	ecx
	push	eax
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
$LN3@Construct@27:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@ABV10@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T610174[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@ABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@ABV10@@Z ENDP ; std::_Construct<std::vector<unsigned int,std::allocator<unsigned int> >,std::vector<unsigned int,std::allocator<unsigned int> > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEXPAV?$vector@IV?$allocator@I@std@@@2@ABV32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEXPAV?$vector@IV?$allocator@I@std@@@2@ABV32@@Z$0
__ehfuncinfo$?construct@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEXPAV?$vector@IV?$allocator@I@std@@@2@ABV32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEXPAV?$vector@IV?$allocator@I@std@@@2@ABV32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEXPAV?$vector@IV?$allocator@I@std@@@2@ABV32@@Z
_TEXT	SEGMENT
$T610203 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$610200 = 8					; size = 4
__Ptr$ = 8						; size = 4
?construct@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEXPAV?$vector@IV?$allocator@I@std@@@2@ABV32@@Z PROC ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::construct, COMDAT
; __Val$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEXPAV?$vector@IV?$allocator@I@std@@@2@ABV32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Ptr$[esp+20]

; 155  : 		_Construct(_Ptr, _Val);

	mov	DWORD PTR __Vptr$610200[esp+20], eax
	mov	DWORD PTR $T610203[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	eax, eax
	je	SHORT $LN5@construct@23
	push	ecx
	push	eax
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
$LN5@construct@23:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEXPAV?$vector@IV?$allocator@I@std@@@2@ABV32@@Z$0:
	mov	eax, DWORD PTR __Vptr$610200[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T610203[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEXPAV?$vector@IV?$allocator@I@std@@@2@ABV32@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEXPAV?$vector@IV?$allocator@I@std@@@2@ABV32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEXPAV?$vector@IV?$allocator@I@std@@@2@ABV32@@Z ENDP ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::construct
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T610246 = -28						; size = 4
__Vptr$610243 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Val$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::vector<unsigned int,std::allocator<unsigned int> > *,unsigned int,std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >, COMDAT
; __Count$ = ecx

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	esi, DWORD PTR __First$[ebp]

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
$LL6@Uninit_fil@21:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil@21

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$610243[ebp], esi
	mov	DWORD PTR $T610246[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil@21
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	esi
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
$LN18@Uninit_fil@21:
	dec	edi
	add	esi, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@21
__catch$??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@21
	npad	6
$LL3@Uninit_fil@21:

; 407  : 		_Al.destroy(_Next);

	call	?destroy@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEXPAV?$vector@IV?$allocator@I@std@@@2@@Z ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::destroy
	add	esi, 24					; 00000018H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@21
$LN1@Uninit_fil@21:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN29@Uninit_fil@21:
$LN4@Uninit_fil@21:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@Uninit_fil@21:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$610243[ebp]
	push	eax
	mov	ecx, DWORD PTR $T610246[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::vector<unsigned int,std::allocator<unsigned int> > *,unsigned int,std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@stdext@@YAXPAV?$vector@IV?$allocator@I@std@@@std@@IABV12@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T610267 = -4						; size = 1
__Cat$610271 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
??$unchecked_uninitialized_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@stdext@@YAXPAV?$vector@IV?$allocator@I@std@@@std@@IABV12@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::vector<unsigned int,std::allocator<unsigned int> > *,unsigned int,std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >, COMDAT
; __Val$ = edx

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	BYTE PTR $T610267[esp+4], 0
	mov	eax, DWORD PTR $T610267[esp+4]
	mov	ecx, DWORD PTR __Cat$610271[esp+4]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	push	eax
	call	??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<unsigned int,std::allocator<unsigned int> > *,unsigned int,std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >

; 943  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$unchecked_uninitialized_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@stdext@@YAXPAV?$vector@IV?$allocator@I@std@@@std@@IABV12@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::vector<unsigned int,std::allocator<unsigned int> > *,unsigned int,std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@4@@Z
_TEXT	SEGMENT
__Bucket$ = -24						; size = 4
__Num$610313 = -20					; size = 4
__Tmp$611897 = -16					; size = 8
__Plist$ = -16						; size = 8
$T611843 = -8						; size = 8
$T611840 = -8						; size = 8
$T610285 = -8						; size = 8
$T610281 = -8						; size = 8
$T610279 = -8						; size = 8
$T610276 = -8						; size = 8
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
tv1572 = 16						; size = 4
tv1569 = 16						; size = 4
tv1566 = 16						; size = 4
__Val$ = 16						; size = 4
__Where$ = 20						; size = 8
?_Insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@4@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Insert, COMDAT

; 837  : 		size_type _Bucket = _Hashval(this->_Kfn(_Val));

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	push	edi
	push	127773					; 0001f31dH
	push	ecx
	call	_ldiv
	imul	eax, 2836				; 00000b14H
	imul	edx, 16807				; 000041a7H
	add	esp, 8
	sub	edx, eax
	jns	SHORT $LN28@Insert@9
	add	edx, 2147483647				; 7fffffffH
$LN28@Insert@9:
	mov	ebp, DWORD PTR _this$[esp+36]
	mov	eax, DWORD PTR [ebp+60]
	mov	edi, eax
	and	edi, edx
	mov	DWORD PTR __Num$610313[esp+40], edi
	cmp	DWORD PTR [ebp+64], edi
	ja	SHORT $LN23@Insert@9
	shr	eax, 1
	or	edx, -1
	sub	edx, eax
	add	edi, edx
	mov	DWORD PTR __Num$610313[esp+40], edi
$LN23@Insert@9:

; 838  : 		iterator _Plist = _Get_iter_from_vec(_Vec[_Bucket + 1]);

	mov	eax, DWORD PTR [ebp+52]
	sub	eax, DWORD PTR [ebp+48]
	lea	esi, DWORD PTR [ebp+36]
	mov	DWORD PTR __Bucket$[esp+40], edi
	inc	edi
	sar	eax, 3
	cmp	edi, eax
	jb	SHORT $LN31@Insert@9
	call	__invalid_parameter_noinfo
$LN31@Insert@9:
	add	ebp, 8
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [ecx+edi*8+4]
	mov	DWORD PTR __Plist$[esp+44], edx
	jne	SHORT $LN44@Insert@9
	call	__invalid_parameter_noinfo
$LN44@Insert@9:
	mov	ebx, DWORD PTR [ebp]
	mov	DWORD PTR __Plist$[esp+40], ebx
$LN18@Insert@9:

; 839  : 
; 840  : 		for (; _Plist != _Get_iter_from_vec(_Vec[_Bucket]); )

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR __Num$610313[esp+40]
	sar	eax, 3
	cmp	edi, eax
	jb	SHORT $LN56@Insert@9
	call	__invalid_parameter_noinfo
$LN56@Insert@9:
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [ecx+edi*8+4]
	mov	DWORD PTR $T610276[esp+44], edx
	test	ebp, ebp
	jne	SHORT $LN69@Insert@9
	call	__invalid_parameter_noinfo
$LN69@Insert@9:
	mov	eax, DWORD PTR [ebp]
	test	ebx, ebx
	je	SHORT $LN83@Insert@9
	cmp	ebx, eax
	je	SHORT $LN84@Insert@9
$LN83@Insert@9:
	call	__invalid_parameter_noinfo
$LN84@Insert@9:
	mov	edi, DWORD PTR __Plist$[esp+44]
	cmp	edi, DWORD PTR $T610276[esp+44]
	je	$LN17@Insert@9

; 841  : 			if (this->comp(this->_Kfn(_Val), this->_Kfn(*--_Plist)))

	test	ebx, ebx
	jne	SHORT $LN96@Insert@9
	call	__invalid_parameter_noinfo
$LN96@Insert@9:
	mov	edi, DWORD PTR [edi+4]
	mov	DWORD PTR __Plist$[esp+44], edi
	test	ebx, ebx
	je	SHORT $LN106@Insert@9
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN107@Insert@9
$LN106@Insert@9:
	xor	eax, eax
$LN107@Insert@9:
	cmp	edi, DWORD PTR [eax+20]
	jne	SHORT $LN94@Insert@9
	call	__invalid_parameter_noinfo
$LN94@Insert@9:
	test	ebx, ebx
	jne	$LN430@Insert@9
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN123@Insert@9:
	cmp	edi, DWORD PTR [eax+20]
	jne	SHORT $LN112@Insert@9
	call	__invalid_parameter_noinfo
$LN112@Insert@9:
	mov	eax, DWORD PTR __Val$[esp+36]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [edi+8]
	jne	$LN18@Insert@9

; 842  : 				;	// still too high in bucket list
; 843  : 			else if (_Multi
; 844  : 				|| this->comp(this->_Kfn(*_Plist), this->_Kfn(_Val)))

	test	ebx, ebx
	jne	SHORT $LN429@Insert@9
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN151@Insert@9:
	mov	edi, DWORD PTR __Plist$[esp+44]
	cmp	edi, DWORD PTR [eax+20]
	jne	SHORT $LN140@Insert@9
	call	__invalid_parameter_noinfo
$LN140@Insert@9:
	mov	edx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR __Val$[esp+36]
	cmp	edx, DWORD PTR [eax]
	je	SHORT $LN14@Insert@9

; 845  : 				{	// found insertion point, back up to it
; 846  : 				++_Plist;

	test	ebx, ebx
	jne	SHORT $LN428@Insert@9
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN175@Insert@9:
	cmp	edi, DWORD PTR [eax+20]
	jne	SHORT $LN164@Insert@9
	call	__invalid_parameter_noinfo
$LN164@Insert@9:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR __Plist$[esp+44], ecx

; 847  : 				break;

	mov	edi, ecx
$LN17@Insert@9:

; 854  : 				}
; 855  : 
; 856  : 		if (_Where != end())

	mov	eax, DWORD PTR [ebp+20]
	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR $T610281[esp+44], eax
	mov	eax, DWORD PTR __Where$[esp+36]
	test	eax, eax
	je	SHORT $LN231@Insert@9
	cmp	eax, ecx
	je	SHORT $LN232@Insert@9
$LN231@Insert@9:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp+36]
$LN232@Insert@9:
	mov	ecx, DWORD PTR __Where$[esp+40]
	cmp	ecx, DWORD PTR $T610281[esp+44]
	je	SHORT $LN10@Insert@9

; 857  : 			_List.splice(_Plist, _List, _Where);	// move element into place

	push	ecx
	push	eax
	push	edi
	push	ebx
	push	ebp
	mov	eax, ebp
	call	?splice@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAEXV?$_Const_iterator@$00@12@AAV12@0@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::splice

; 858  : 		else

	jmp	SHORT $LL433@Insert@9
$LN430@Insert@9:

; 841  : 			if (this->comp(this->_Kfn(_Val), this->_Kfn(*--_Plist)))

	mov	eax, DWORD PTR [ebx]
	jmp	$LN123@Insert@9
$LN429@Insert@9:

; 842  : 				;	// still too high in bucket list
; 843  : 			else if (_Multi
; 844  : 				|| this->comp(this->_Kfn(*_Plist), this->_Kfn(_Val)))

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN151@Insert@9
$LN428@Insert@9:

; 845  : 				{	// found insertion point, back up to it
; 846  : 				++_Plist;

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN175@Insert@9
$LN14@Insert@9:

; 848  : 				}
; 849  : 			else
; 850  : 				{	// discard new list element and return existing
; 851  : 				if (_Where != end())

	mov	eax, DWORD PTR __Where$[esp+36]
	mov	esi, DWORD PTR [ebp+20]
	mov	ecx, DWORD PTR [ebp]
	test	eax, eax
	je	SHORT $LN200@Insert@9
	cmp	eax, ecx
	je	SHORT $LN201@Insert@9
$LN200@Insert@9:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp+36]
$LN201@Insert@9:
	mov	ecx, DWORD PTR __Where$[esp+40]
	cmp	ecx, esi
	je	SHORT $LN11@Insert@9

; 852  : 					_List.erase(_Where);

	push	ecx
	push	eax
	lea	edx, DWORD PTR $T610279[esp+48]
	push	edx
	mov	edi, ebp
	call	?erase@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::erase
	mov	edi, DWORD PTR __Plist$[esp+44]
$LN11@Insert@9:

; 853  : 				return (_Pairib(_Plist, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], edi
	mov	BYTE PTR [eax+8], 0

; 884  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
$LN10@Insert@9:

; 859  : 			_Where = _List.insert(_Plist, _Val);	// insert new element

	mov	edx, DWORD PTR __Val$[esp+36]
	push	edi
	push	ebx
	lea	ecx, DWORD PTR $T610285[esp+48]
	push	ecx
	push	ebp
	call	?insert@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@QAE?AV?$_Iterator@$00@12@V?$_Const_iterator@$00@12@ABU?$pair@$$CBII@2@@Z ; std::list<std::pair<unsigned int const ,unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::insert
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Where$[esp+36], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Where$[esp+40], eax
	npad	3
$LL433@Insert@9:

; 860  : 		for (; _Plist == _Get_iter_from_vec(_Vec[_Bucket]); --_Bucket)

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR __Bucket$[esp+40]
	sar	ecx, 3
	cmp	edi, ecx
	jb	SHORT $LN240@Insert@9
	call	__invalid_parameter_noinfo
$LN240@Insert@9:
	mov	edx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [edx+edi*8+4]
	test	ebp, ebp
	jne	SHORT $LN253@Insert@9
	call	__invalid_parameter_noinfo
$LN253@Insert@9:
	mov	eax, DWORD PTR [ebp]
	test	ebx, ebx
	je	SHORT $LN265@Insert@9
	cmp	ebx, eax
	je	SHORT $LN266@Insert@9
$LN265@Insert@9:
	call	__invalid_parameter_noinfo
$LN266@Insert@9:
	cmp	DWORD PTR __Plist$[esp+44], edi
	jne	SHORT $LN424@Insert@9

; 861  : 			{	// update end iterators if new first bucket element
; 862  : 			_Vec[_Bucket] = _Where;

	mov	eax, DWORD PTR __Where$[esp+36]
	test	eax, eax
	je	SHORT $LN278@Insert@9
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN279@Insert@9
$LN278@Insert@9:
	xor	eax, eax
$LN279@Insert@9:
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR __Bucket$[esp+40]
	mov	ebx, DWORD PTR __Where$[esp+40]
	sar	eax, 3
	cmp	ecx, eax
	jb	SHORT $LN298@Insert@9
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR __Bucket$[esp+40]
$LN298@Insert@9:
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+ecx*8], edi
	mov	DWORD PTR [eax+ecx*8+4], ebx

; 863  : 			if (_Bucket == 0)

	test	ecx, ecx
	je	SHORT $LN424@Insert@9
	mov	ebx, DWORD PTR __Plist$[esp+40]
	dec	ecx
	mov	DWORD PTR __Bucket$[esp+40], ecx
	jmp	$LL433@Insert@9
$LN424@Insert@9:

; 864  : 				break;
; 865  : 			}
; 866  : 
; 867  : 		if (max_load_factor() < load_factor())

	mov	eax, DWORD PTR _this$[esp+36]
	mov	ecx, DWORD PTR [eax+32]
	fld	DWORD PTR [eax+68]
	mov	ebx, DWORD PTR [eax+64]
	fild	DWORD PTR [eax+32]
	test	ecx, ecx
	jge	SHORT $LN438@Insert@9
	fadd	DWORD PTR __real@4f800000
$LN438@Insert@9:
	mov	edx, ebx
	mov	DWORD PTR tv1569[esp+36], edx
	fild	DWORD PTR tv1569[esp+36]
	test	edx, edx
	jge	SHORT $LN439@Insert@9
	fadd	DWORD PTR __real@4f800000
$LN439@Insert@9:
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR tv1566[esp+36]
	fld	DWORD PTR tv1566[esp+36]
	fcomip	ST(1)
	fstp	ST(0)
	jbe	$LN4@Insert@9

; 868  :  #if _HAS_INCREMENTAL_HASH
; 869  : 			_Grow();	// too dense, need to grow hash table
; 870  : 
; 871  :  #else /* _HAS_INCREMENTAL_HASH */
; 872  : 			{	// rehash to bigger table
; 873  : 			size_type _Maxsize = _Vec.max_size() / 2;
; 874  : 			size_type _Newsize = bucket_count();
; 875  : 
; 876  : 			for (int _Idx = 0; _Idx < 3 && _Newsize < _Maxsize; ++_Idx)

	xor	eax, eax
	npad	6
$LL3@Insert@9:
	cmp	ebx, 268435455				; 0fffffffH
	jae	SHORT $LN1@Insert@9
	inc	eax

; 877  : 				_Newsize *= 2;	// multiply safely by 8

	add	ebx, ebx
	cmp	eax, 3
	jl	SHORT $LL3@Insert@9
$LN1@Insert@9:

; 878  : 			_Init(_Newsize);

	mov	ecx, DWORD PTR [ebp+20]
	mov	ebp, DWORD PTR [ebp]
	test	ebp, ebp
	je	SHORT $LN345@Insert@9
	mov	ebp, DWORD PTR [ebp]
	jmp	SHORT $LN346@Insert@9
$LN345@Insert@9:
	xor	ebp, ebp
$LN346@Insert@9:
	mov	edi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR __Tmp$611897[esp+40], eax
	mov	DWORD PTR __Tmp$611897[esp+44], ecx
	cmp	DWORD PTR [esi+12], edi
	jbe	SHORT $LN374@Insert@9
	call	__invalid_parameter_noinfo
$LN374@Insert@9:
	mov	ebp, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T611840[esp+40], eax
	cmp	ebp, DWORD PTR [esi+16]
	jbe	SHORT $LN390@Insert@9
	call	__invalid_parameter_noinfo
$LN390@Insert@9:
	mov	ecx, DWORD PTR $T611840[esp+40]
	mov	eax, DWORD PTR [esi]
	push	edi
	push	ecx
	push	ebp
	push	eax
	lea	edx, DWORD PTR $T611843[esp+56]
	push	edx
	mov	edi, esi
	call	?erase@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@QAE?AV?$_Vector_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@V?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@0@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::erase
	mov	edi, DWORD PTR [esi+12]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN406@Insert@9
	call	__invalid_parameter_noinfo
$LN406@Insert@9:
	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	lea	eax, DWORD PTR __Tmp$611897[esp+48]
	push	eax
	lea	ecx, DWORD PTR [ebx+1]
	mov	edx, esi
	call	?_Insert_n@?$vector@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@V?$allocator@U_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@std@@@2@IABU_List_position@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@@Z ; std::vector<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position,std::allocator<stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_List_position> >::_Insert_n
	mov	ecx, DWORD PTR _this$[esp+36]
	lea	edx, DWORD PTR [ebx-1]
	mov	DWORD PTR [ecx+60], edx
	mov	DWORD PTR [ecx+64], ebx

; 879  : 			_Reinsert();

	call	?_Reinsert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXXZ ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Reinsert
$LN4@Insert@9:

; 880  : 			}
; 881  : #endif /* _HAS_INCREMENTAL_HASH */
; 882  : 
; 883  : 		return (_Pairib(_Where, true));	// return iterator for new element

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	mov	ecx, DWORD PTR __Where$[esp+36]
	mov	edx, DWORD PTR __Where$[esp+40]

; 884  : 		}

	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	BYTE PTR [eax+8], 1
	pop	ebx
	add	esp, 24					; 00000018H
	ret	20					; 00000014H
?_Insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@4@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Insert
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@IAEPAV?$vector@IV?$allocator@I@std@@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT
$T611936 = -4						; size = 1
__Cat$611940 = -4					; size = 1
?_Ufill@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@IAEPAV?$vector@IV?$allocator@I@std@@@2@PAV32@IABV32@@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	BYTE PTR $T611936[esp+4], 0
	mov	eax, DWORD PTR $T611936[esp+4]
	mov	ecx, DWORD PTR __Cat$611940[esp+4]
	push	eax
	push	ecx
	push	edx
	push	edi
	mov	ecx, esi
	call	??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<unsigned int,std::allocator<unsigned int> > *,unsigned int,std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [esi+esi*2]
	lea	eax, DWORD PTR [edi+eax*8]

; 1256 : 		}

	add	esp, 20					; 00000014H
	ret	0
?_Ufill@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@IAEPAV?$vector@IV?$allocator@I@std@@@2@PAV32@IABV32@@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@@Z PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::insert, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 545  : 		return (_Insert(_Val, end()));

	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR __Val$[esp]
	push	edx
	push	ecx
	push	esi
	push	eax
	call	?_Insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@4@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Insert
	mov	eax, esi

; 546  : 		}

	ret	4
?insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@@Z ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z$0
__tryblocktable$?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z$2
__ehfuncinfo$?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT
tv202 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$612092 = 8					; size = 1
_this$ = 8						; size = 4
$T612089 = 12						; size = 1
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Construct_n, COMDAT

; 545  : 		{	// construct from _Count * _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR __Count$[ebp]
	mov	esi, DWORD PTR _this$[ebp]

; 546  : 		if (_Buy(_Count))

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	cmp	ebx, eax
	je	SHORT $LN7@Construct_@16
	cmp	ebx, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN10@Construct_@16
	call	?_Xlen@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@KAXXZ ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Xlen
$LN32@Construct_@16:
$LN10@Construct_@16:
	mov	ecx, ebx
	call	?allocate@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAEPAV?$vector@IV?$allocator@I@std@@@2@I@Z ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocate

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	mov	edi, eax
	lea	eax, DWORD PTR [ebx+ebx*2]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv202[ebp], eax
	add	eax, edi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR __Cat$612092[ebp]
	mov	DWORD PTR [esi+20], eax
	mov	BYTE PTR $T612089[ebp], 0
	mov	eax, DWORD PTR $T612089[ebp]
	push	eax
	push	ecx
	push	edx
	push	edi
	mov	ecx, ebx
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	call	??$_Uninit_fill_n@PAV?$vector@IV?$allocator@I@std@@@std@@IV12@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAXPAV?$vector@IV?$allocator@I@std@@@0@IABV10@AAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<unsigned int,std::allocator<unsigned int> > *,unsigned int,std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
	mov	eax, DWORD PTR tv202[ebp]
	add	esp, 16					; 00000010H
	add	eax, edi
	mov	DWORD PTR [esi+16], eax
$LN7@Construct_@16:

; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z$0:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@IAEXXZ ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Tidy

; 552  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN33@Construct_@16:
$LN31@Construct_@16:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Construct_n
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\unordered_map
;	COMDAT ??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z
_TEXT	SEGMENT
$T612111 = -20						; size = 8
__Where$ = -20						; size = 8
$T612113 = -12						; size = 12
$T612110 = -12						; size = 8
__Keyval$ = 8						; size = 4
??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z PROC ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[], COMDAT
; _this$ = esi

; 209  : 		{	// find element matching _Keyval or insert with default mapped

	sub	esp, 20					; 00000014H
	push	ebx
	mov	ebx, DWORD PTR __Keyval$[esp+20]
	push	ebp
	push	edi

; 210  : 		iterator _Where = this->lower_bound(_Keyval);

	push	ebx
	lea	eax, DWORD PTR __Where$[esp+36]
	push	eax
	push	esi
	call	?lower_bound@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE?AV?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@ABI@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::lower_bound

; 211  : 		if (_Where == this->end())

	mov	edi, DWORD PTR __Where$[esp+32]
	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR $T612110[esp+36], ecx
	test	edi, edi
	je	SHORT $LN22@operator@392
	cmp	edi, eax
	je	SHORT $LN23@operator@392
$LN22@operator@392:
	call	__invalid_parameter_noinfo
$LN23@operator@392:
	mov	ebp, DWORD PTR __Where$[esp+36]
	cmp	ebp, DWORD PTR $T612110[esp+36]
	jne	SHORT $LN1@operator@392

; 212  : 			_Where = _Mybase::insert(value_type(_Keyval, mapped_type())).first;

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [ebx]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T612111[esp+40]
	push	eax
	lea	ecx, DWORD PTR $T612113[esp+44]
	push	ecx
	push	esi
	mov	DWORD PTR $T612111[esp+52], edx
	mov	DWORD PTR $T612111[esp+56], 0
	call	?_Insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@4@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Insert
	mov	edi, DWORD PTR $T612113[esp+32]
	mov	ebp, DWORD PTR $T612113[esp+36]
$LN1@operator@392:

; 213  : 		return ((*_Where).second);

	test	edi, edi
	jne	SHORT $LN71@operator@392
	call	__invalid_parameter_noinfo
$LN66@operator@392:
	cmp	ebp, DWORD PTR [edi+20]
	jne	SHORT $LN72@operator@392
	call	__invalid_parameter_noinfo
$LN72@operator@392:

; 214  : 		}

	pop	edi
	lea	eax, DWORD PTR [ebp+12]
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
$LN71@operator@392:

; 213  : 		return ((*_Where).second);

	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LN66@operator@392
??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z ENDP ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[]
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@IABV?$vector@IV?$allocator@I@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@IABV?$vector@IV?$allocator@I@std@@@1@@Z$0
__ehfuncinfo$??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@IABV?$vector@IV?$allocator@I@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@IABV?$vector@IV?$allocator@I@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@IABV?$vector@IV?$allocator@I@std@@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@IABV?$vector@IV?$allocator@I@std@@@1@@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >, COMDAT

; 488  : 		{	// construct from _Count * _Val

	push	-1
	push	__ehhandler$??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@IABV?$vector@IV?$allocator@I@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@vector@71
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@71
$LN13@vector@71:
	xor	eax, eax
$LN14@vector@71:
	mov	DWORD PTR [esi], eax

; 489  : 		_Construct_n(_Count, _Val);

	mov	eax, DWORD PTR __Val$[esp+20]
	mov	ecx, DWORD PTR __Count$[esp+20]
	push	eax
	push	ecx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+44], 0
	call	?_Construct_n@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAEXIABV?$vector@IV?$allocator@I@std@@@2@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Construct_n

; 490  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@IABV?$vector@IV?$allocator@I@std@@@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@IABV?$vector@IV?$allocator@I@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@IABV?$vector@IV?$allocator@I@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@IABV?$vector@IV?$allocator@I@std@@@1@@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
PUBLIC	?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::Statistics::collectCommandStats
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.cpp
_TEXT	SEGMENT
$T612514 = 8						; size = 4
$T612513 = 8						; size = 4
$T612512 = 8						; size = 4
_this$ = 8						; size = 4
?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z PROC ; DRAMsimII::Statistics::collectCommandStats
; _currentCommand$ = edi

; 193  : {

	push	ecx

; 194  : 	//#pragma omp critical
; 195  : 	{
; 196  : 		if (currentCommand->isHit())

	cmp	BYTE PTR [edi+92], 0

; 197  : 		{
; 198  : 			if (currentCommand->isRead())

	mov	eax, DWORD PTR [edi+80]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+8]
	push	esi
	je	$LN9@collectCom
	cmp	eax, 1
	je	SHORT $LN16@collectCom
	cmp	eax, 2
	jne	SHORT $LN8@collectCom
$LN16@collectCom:

; 199  : 				hitRate[currentCommand->getAddress().getChannel()][currentCommand->getAddress().getRank()].first.first++;

	mov	ecx, DWORD PTR [ebp+596]
	sub	ecx, DWORD PTR [ebp+592]
	mov	ebx, DWORD PTR [edi+56]
	mov	esi, DWORD PTR [edi+60]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	jb	SHORT $LN26@collectCom
	call	__invalid_parameter_noinfo
$LN26@collectCom:
	mov	edx, DWORD PTR [ebp+592]
	lea	ecx, DWORD PTR [ebx+ebx*2]
	mov	eax, DWORD PTR [edx+ecx*8+16]
	sub	eax, DWORD PTR [edx+ecx*8+12]
	lea	ebx, DWORD PTR [edx+ecx*8]
	sar	eax, 5
	cmp	esi, eax
	jb	SHORT $LN31@collectCom
	call	__invalid_parameter_noinfo
$LN31@collectCom:
	mov	ecx, DWORD PTR [ebx+12]
	shl	esi, 5
	lea	eax, DWORD PTR [esi+ecx]
	jmp	$LN115@collectCom
$LN8@collectCom:

; 200  : 			else if (currentCommand->isWrite())

	cmp	eax, 3
	je	SHORT $LN38@collectCom
	cmp	eax, 4
	jne	$LN2@collectCom
$LN38@collectCom:

; 201  : 				hitRate[currentCommand->getAddress().getChannel()][currentCommand->getAddress().getRank()].second.first++;

	mov	ecx, DWORD PTR [ebp+596]
	sub	ecx, DWORD PTR [ebp+592]
	mov	ebx, DWORD PTR [edi+56]
	mov	esi, DWORD PTR [edi+60]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	jb	SHORT $LN48@collectCom
	call	__invalid_parameter_noinfo
$LN48@collectCom:
	mov	edx, DWORD PTR [ebp+592]
	lea	ecx, DWORD PTR [ebx+ebx*2]
	mov	eax, DWORD PTR [edx+ecx*8+16]
	sub	eax, DWORD PTR [edx+ecx*8+12]
	lea	ebx, DWORD PTR [edx+ecx*8]
	sar	eax, 5
	cmp	esi, eax
	jb	SHORT $LN53@collectCom
	call	__invalid_parameter_noinfo
$LN53@collectCom:
	mov	ecx, DWORD PTR [ebx+12]
	shl	esi, 5
	lea	eax, DWORD PTR [esi+ecx+16]

; 202  : 		}
; 203  : 		else

	jmp	$LN115@collectCom
$LN9@collectCom:

; 204  : 		{
; 205  : 			if (currentCommand->isRead())

	cmp	eax, 1
	je	SHORT $LN60@collectCom
	cmp	eax, 2
	jne	SHORT $LN4@collectCom
$LN60@collectCom:

; 206  : 				hitRate[currentCommand->getAddress().getChannel()][currentCommand->getAddress().getRank()].first.second++;

	mov	ecx, DWORD PTR [ebp+596]
	sub	ecx, DWORD PTR [ebp+592]
	mov	ebx, DWORD PTR [edi+56]
	mov	esi, DWORD PTR [edi+60]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	jb	SHORT $LN70@collectCom
	call	__invalid_parameter_noinfo
$LN70@collectCom:
	mov	edx, DWORD PTR [ebp+592]
	lea	ecx, DWORD PTR [ebx+ebx*2]
	mov	eax, DWORD PTR [edx+ecx*8+16]
	sub	eax, DWORD PTR [edx+ecx*8+12]
	lea	ebx, DWORD PTR [edx+ecx*8]
	sar	eax, 5
	cmp	esi, eax
	jb	SHORT $LN75@collectCom
	call	__invalid_parameter_noinfo
$LN75@collectCom:
	mov	ecx, DWORD PTR [ebx+12]
	shl	esi, 5
	lea	eax, DWORD PTR [esi+ecx+8]
	jmp	SHORT $LN115@collectCom
$LN4@collectCom:

; 207  : 			else if (currentCommand->isWrite())

	cmp	eax, 3
	je	SHORT $LN82@collectCom
	cmp	eax, 4
	jne	SHORT $LN2@collectCom
$LN82@collectCom:

; 208  : 				hitRate[currentCommand->getAddress().getChannel()][currentCommand->getAddress().getRank()].second.second++;

	mov	ecx, DWORD PTR [ebp+596]
	sub	ecx, DWORD PTR [ebp+592]
	mov	ebx, DWORD PTR [edi+56]
	mov	esi, DWORD PTR [edi+60]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	jb	SHORT $LN92@collectCom
	call	__invalid_parameter_noinfo
$LN92@collectCom:
	mov	edx, DWORD PTR [ebp+592]
	lea	ecx, DWORD PTR [ebx+ebx*2]
	mov	eax, DWORD PTR [edx+ecx*8+16]
	sub	eax, DWORD PTR [edx+ecx*8+12]
	lea	ebx, DWORD PTR [edx+ecx*8]
	sar	eax, 5
	cmp	esi, eax
	jb	SHORT $LN97@collectCom
	call	__invalid_parameter_noinfo
$LN97@collectCom:
	mov	ecx, DWORD PTR [ebx+12]
	shl	esi, 5
	lea	eax, DWORD PTR [esi+ecx+24]
$LN115@collectCom:
	add	DWORD PTR [eax], 1
	adc	DWORD PTR [eax+4], 0
$LN2@collectCom:

; 209  : 		}
; 210  : 
; 211  : 		if (!currentCommand->isRefresh())

	cmp	DWORD PTR [edi+80], 12			; 0000000cH
	je	SHORT $LN1@collectCom

; 212  : 		{
; 213  : 			commandDelay[currentCommand->getDelayTime()]++;

	mov	edx, DWORD PTR [edi+24]
	sub	edx, DWORD PTR [edi+16]
	lea	eax, DWORD PTR $T612512[esp+12]
	push	eax
	lea	esi, DWORD PTR [ebp+108]
	mov	DWORD PTR $T612512[esp+16], edx
	call	??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[]
	inc	DWORD PTR [eax]

; 214  : 			commandExecution[currentCommand->getExecuteTime()]++;

	mov	ecx, DWORD PTR [edi+32]
	sub	ecx, DWORD PTR [edi+24]
	lea	edx, DWORD PTR $T612513[esp+12]
	push	edx
	lea	esi, DWORD PTR [ebp+180]
	mov	DWORD PTR $T612513[esp+16], ecx
	call	??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[]
	inc	DWORD PTR [eax]

; 215  : 			commandTurnaround[currentCommand->getLatency()]++;		

	mov	eax, DWORD PTR [edi+32]
	sub	eax, DWORD PTR [edi+16]
	lea	ecx, DWORD PTR $T612514[esp+12]
	push	ecx
	lea	esi, DWORD PTR [ebp+252]
	mov	DWORD PTR $T612514[esp+16], eax
	call	??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[]
	inc	DWORD PTR [eax]
$LN1@collectCom:

; 216  : 		}
; 217  : 	}
; 218  : }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z ENDP ; DRAMsimII::Statistics::collectCommandStats
_TEXT	ENDS
PUBLIC	?collectTransactionStats@Statistics@DRAMsimII@@QAEXPBVTransaction@2@@Z ; DRAMsimII::Statistics::collectTransactionStats
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T612706 = -16						; size = 8
$T612705 = -16						; size = 8
$T612704 = -16						; size = 8
$T612812 = -8						; size = 8
_this$ = 8						; size = 4
$T612703 = 12						; size = 4
$T612702 = 12						; size = 4
_currentTransaction$ = 12				; size = 4
?collectTransactionStats@Statistics@DRAMsimII@@QAEXPBVTransaction@2@@Z PROC ; DRAMsimII::Statistics::collectTransactionStats

; 117  : {

	sub	esp, 20					; 00000014H
	push	ebx
	mov	ebx, DWORD PTR _currentTransaction$[esp+20]

; 118  : 	//#pragma omp critical
; 119  : 	{
; 120  : 		if (currentTransaction->isRead() || currentTransaction->isWrite())

	mov	eax, DWORD PTR [ebx+80]
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+24]
	push	esi
	push	edi
	test	eax, eax
	je	SHORT $LN73@collectTra
	cmp	eax, 2
	je	SHORT $LN73@collectTra
	cmp	eax, 3
	je	SHORT $LN73@collectTra
	mov	edi, 1
	cmp	eax, edi
	jne	$LN68@collectTra
	jmp	SHORT $LN6@collectTra
$LN73@collectTra:
	mov	edi, 1
$LN6@collectTra:

; 121  : 		{
; 122  : 			if (currentTransaction->getLength() == 8)

	cmp	DWORD PTR [ebx+84], 8
	jne	SHORT $LN5@collectTra

; 123  : 			{
; 124  : 				++burstOf8Count;

	add	DWORD PTR [ebp+24], edi

; 125  : 			}
; 126  : 			else

	jmp	SHORT $LN4@collectTra
$LN5@collectTra:

; 127  : 			{
; 128  : 				++burstOf4Count;

	add	DWORD PTR [ebp+28], edi
$LN4@collectTra:

; 129  : 			}
; 130  : 			if (currentTransaction->isRead())

	mov	eax, DWORD PTR [ebx+80]
	test	eax, eax
	je	SHORT $LN20@collectTra
	cmp	eax, 2
	je	SHORT $LN20@collectTra
	cmp	eax, 3
	jne	$LN3@collectTra
$LN20@collectTra:

; 131  : 			{
; 132  : 				//if (currentTransaction->getLatency() > 1024)
; 133  : 				//	std::cerr << currentTransaction->getLatency() << std::endl;
; 134  : 				transactionExecution[currentTransaction->getLatency()]++;

	mov	eax, DWORD PTR [ebx+32]
	sub	eax, DWORD PTR [ebx+16]
	lea	ecx, DWORD PTR $T612702[esp+32]
	push	ecx
	lea	esi, DWORD PTR [ebp+396]
	mov	DWORD PTR $T612702[esp+36], eax
	call	??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[]
	add	DWORD PTR [eax], edi

; 135  : 				assert(currentTransaction->getLatency() > 4);
; 136  : 				unsigned index = currentTransaction->getAddress().getChannel() * (ranks * banks) +
; 137  : 					currentTransaction->getAddress().getRank() * banks +
; 138  : 					currentTransaction->getAddress().getBank();

	mov	esi, DWORD PTR [ebx+56]
	imul	esi, DWORD PTR [ebp+4]
	add	esi, DWORD PTR [ebx+60]

; 139  : 				bankLatencyUtilization[index] += currentTransaction->getLatency();

	mov	edx, DWORD PTR [ebp+572]
	imul	esi, DWORD PTR [ebp+8]
	sub	edx, DWORD PTR [ebp+568]
	add	esi, DWORD PTR [ebx+64]
	sar	edx, 3
	cmp	esi, edx
	jb	SHORT $LN36@collectTra
	call	__invalid_parameter_noinfo
$LN36@collectTra:
	mov	ecx, DWORD PTR [ebx+32]
	sub	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [ebp+568]
	mov	edx, DWORD PTR [ebx+36]
	sbb	edx, DWORD PTR [ebx+20]
	add	DWORD PTR [eax+esi*8], ecx
	lea	eax, DWORD PTR [eax+esi*8]
	adc	DWORD PTR [eax+4], edx

; 140  : 				aggregateBankUtilization[index]++;

	mov	eax, DWORD PTR [ebp+548]
	sub	eax, DWORD PTR [ebp+544]
	sar	eax, 2
	cmp	esi, eax
	jb	SHORT $LN43@collectTra
	call	__invalid_parameter_noinfo
$LN43@collectTra:
	mov	ecx, DWORD PTR [ebp+544]
	add	DWORD PTR [ecx+esi*4], edi

; 141  : 				readCount++;

	add	DWORD PTR [ebp+36], edi

; 142  : 				readBytesTransferred += currentTransaction->getLength() * 8;

	mov	edx, DWORD PTR [ebx+84]
	lea	eax, DWORD PTR [ecx+esi*4]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [ebp+44], edx

; 143  : 			}
; 144  : 			else

	jmp	SHORT $LN2@collectTra
$LN3@collectTra:

; 145  : 			{
; 146  : 				// 64bit bus for most DDRx architectures
; 147  : 				/// @todo use #DQ * length to calculate bytes Tx, Rx
; 148  : 				writeBytesTransferred += currentTransaction->getLength() * 8;

	mov	eax, DWORD PTR [ebx+84]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	add	DWORD PTR [ebp+48], eax

; 149  : 				writeCount++;

	add	DWORD PTR [ebp+40], edi
$LN2@collectTra:

; 150  : 			}
; 151  : 
; 152  : 			transactionDecodeDelay[currentTransaction->getDecodeDelay()]++;

	mov	ecx, DWORD PTR [ebx+88]
	sub	ecx, DWORD PTR [ebx+16]
	lea	edx, DWORD PTR $T612703[esp+32]
	push	edx
	lea	esi, DWORD PTR [ebp+324]
	mov	DWORD PTR $T612703[esp+36], ecx
	call	??A?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAEAAIABI@Z ; std::tr1::unordered_map<unsigned int,unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,unsigned int> > >::operator[]
	add	DWORD PTR [eax], edi

; 153  : 
; 154  : 			// gather working set information for this epoch, exclude the entries which alias to the same column		
; 155  : 			workingSet[currentTransaction->getAddress().getPhysicalAddress() >> columnDepth]++;

	mov	eax, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ebx+52]
	mov	ecx, DWORD PTR [ebp+32]
	call	__aullshr
	mov	DWORD PTR $T612704[esp+36], eax
	lea	eax, DWORD PTR [ebp+500]
	push	eax
	lea	edi, DWORD PTR $T612704[esp+40]
	mov	DWORD PTR $T612704[esp+44], edx
	call	??A?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAEAAIAB_K@Z ; std::map<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> > >::operator[]
	inc	DWORD PTR [eax]

; 156  : 
; 157  : 			// ignore write / tlb transactions that don't have a specific PC
; 158  : 			if (currentTransaction->getProgramCounter() > 0x00)

	mov	eax, DWORD PTR [ebx+100]
	mov	ecx, DWORD PTR [ebx+96]
	test	eax, eax
	ja	SHORT $LN72@collectTra
	test	ecx, ecx
	jbe	SHORT $LN68@collectTra
$LN72@collectTra:

; 159  : 			{
; 160  : 				pcOccurrence[currentTransaction->getProgramCounter()].countUp();

	add	ebp, 468				; 000001d4H
	push	ebp
	lea	edi, DWORD PTR $T612705[esp+40]
	mov	DWORD PTR $T612705[esp+40], ecx
	mov	DWORD PTR $T612705[esp+44], eax
	call	??A?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAEAAVDelayCounter@Statistics@DRAMsimII@@AB_K@Z ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::operator[]
	inc	DWORD PTR [eax+8]

; 161  : 				pcOccurrence[currentTransaction->getProgramCounter()].delay(currentTransaction->getLatency());

	mov	esi, DWORD PTR [ebx+32]
	sub	esi, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [ebx+36]
	sbb	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [ebx+96]
	mov	edx, DWORD PTR [ebx+100]
	push	ebp
	lea	edi, DWORD PTR $T612706[esp+40]
	mov	DWORD PTR $T612706[esp+40], ecx
	mov	DWORD PTR $T612706[esp+44], edx
	mov	DWORD PTR $T612812[esp+44], eax
	call	??A?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAEAAVDelayCounter@Statistics@DRAMsimII@@AB_K@Z ; std::map<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> > >::operator[]
	add	DWORD PTR [eax], esi
	adc	DWORD PTR [eax+4], 0
$LN68@collectTra:

; 162  : 			}
; 163  : 		}
; 164  : 	}
; 165  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	8
?collectTransactionStats@Statistics@DRAMsimII@@QAEXPBVTransaction@2@@Z ENDP ; DRAMsimII::Statistics::collectTransactionStats
_TEXT	ENDS
PUBLIC	??0Statistics@DRAMsimII@@AAE@XZ			; DRAMsimII::Statistics::Statistics
__ehfuncinfo$??0Statistics@DRAMsimII@@AAE@XZ DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$??0Statistics@DRAMsimII@@AAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0Statistics@DRAMsimII@@AAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$2
	DD	03H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$3
	DD	05H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$4
	DD	06H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$5
	DD	07H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$6
	DD	08H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$7
	DD	09H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$8
	DD	0aH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$9
	DD	0bH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$10
	DD	0cH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$11
	DD	0dH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$12
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T612822 = -60						; size = 24
$T612823 = -36						; size = 24
__$EHRec$ = -12						; size = 12
$T613027 = 8						; size = 2
$T613008 = 8						; size = 2
$T612989 = 8						; size = 2
$T612970 = 8						; size = 2
$T612951 = 8						; size = 2
_this$ = 8						; size = 4
??0Statistics@DRAMsimII@@AAE@XZ PROC			; DRAMsimII::Statistics::Statistics

; 111  : {}

	push	-1
	push	__ehhandler$??0Statistics@DRAMsimII@@AAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+76]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+72]
	xorps	xmm0, xmm0
	or	eax, -1
	xor	ebx, ebx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	push	ebx
	lea	eax, DWORD PTR $T612822[esp+80]
	push	eax
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+36], ebx
	mov	DWORD PTR [esi+40], ebx
	mov	DWORD PTR [esi+44], ebx
	mov	DWORD PTR [esi+48], ebx
	movss	DWORD PTR [esi+52], xmm0
	call	??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@I@Z ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
	push	eax
	push	ebx
	lea	ecx, DWORD PTR [esi+56]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+96], ebx
	call	??0?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@@Z ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
	mov	BYTE PTR __$EHRec$[esp+84], 2
	mov	eax, DWORD PTR $T612822[esp+88]
	cmp	eax, ebx
	je	SHORT $LN22@Statistics@11
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN22@Statistics@11:
	mov	edx, DWORD PTR $T612822[esp+76]
	push	edx
	mov	DWORD PTR $T612822[esp+92], ebx
	mov	DWORD PTR $T612822[esp+96], ebx
	mov	DWORD PTR $T612822[esp+100], ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	lea	eax, DWORD PTR $T612823[esp+76]
	push	eax
	xor	edi, edi
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	push	eax
	push	ebx
	lea	ecx, DWORD PTR [esi+80]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 3
	call	??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@IABV?$vector@IV?$allocator@I@std@@@1@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
	mov	BYTE PTR __$EHRec$[esp+84], 5
	mov	eax, DWORD PTR $T612823[esp+88]
	cmp	eax, ebx
	je	SHORT $LN37@Statistics@11
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@Statistics@11:
	mov	edx, DWORD PTR $T612823[esp+76]
	push	edx
	mov	DWORD PTR $T612823[esp+92], ebx
	mov	DWORD PTR $T612823[esp+96], ebx
	mov	DWORD PTR $T612823[esp+100], ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	lea	ecx, DWORD PTR $T612951[esp+72]
	lea	eax, DWORD PTR [esi+108]
	push	ecx
	push	eax
	mov	DWORD PTR [esi+104], ebx
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	edx, DWORD PTR $T612970[esp+72]
	lea	eax, DWORD PTR [esi+180]
	push	edx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+92], 6
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	ecx, DWORD PTR $T612989[esp+72]
	lea	eax, DWORD PTR [esi+252]
	push	ecx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+92], 7
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	edx, DWORD PTR $T613008[esp+72]
	lea	eax, DWORD PTR [esi+324]
	push	edx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+92], 8
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	ecx, DWORD PTR $T613027[esp+72]
	lea	eax, DWORD PTR [esi+396]
	push	ecx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+92], 9
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	eax, DWORD PTR [esi+468]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+88], 10		; 0000000aH
	call	??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
	lea	eax, DWORD PTR [esi+500]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+88], 11		; 0000000bH
	call	??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
	lea	edx, DWORD PTR [esi+532]
	push	edx
	xor	edi, edi
	mov	BYTE PTR __$EHRec$[esp+88], 12		; 0000000cH
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	lea	eax, DWORD PTR [esi+556]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+88], 13		; 0000000dH
	call	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
	lea	ecx, DWORD PTR [esi+580]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+88], 14		; 0000000eH
	call	??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 60					; 0000003cH
	ret	4
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$0:
	lea	esi, DWORD PTR $T612822[ebp]
	jmp	??1?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::~vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$1:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 56					; 00000038H
	jmp	??1?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::~vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$2:
	lea	esi, DWORD PTR $T612823[ebp]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$3:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 80					; 00000050H
	jmp	??1?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::~vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$4:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 108				; 0000006cH
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$5:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 180				; 000000b4H
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$6:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 252				; 000000fcH
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$7:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 324				; 00000144H
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$8:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 396				; 0000018cH
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$9:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 468				; 000001d4H
	push	eax
	call	??1?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAE@XZ
	ret	0
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$10:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 500				; 000001f4H
	push	eax
	call	??1?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAE@XZ
	ret	0
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$11:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 532				; 00000214H
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__unwindfunclet$??0Statistics@DRAMsimII@@AAE@XZ$12:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 556				; 0000022cH
	jmp	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
__ehhandler$??0Statistics@DRAMsimII@@AAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-60]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Statistics@DRAMsimII@@AAE@XZ
	jmp	___CxxFrameHandler3
??0Statistics@DRAMsimII@@AAE@XZ ENDP			; DRAMsimII::Statistics::Statistics
PUBLIC	??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z	; DRAMsimII::Statistics::Statistics
__unwindtable$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$3
	DD	05H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$4
	DD	06H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$5
	DD	07H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$6
	DD	08H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$7
	DD	09H
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$8
	DD	0aH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$9
	DD	0bH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$10
	DD	0cH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$11
	DD	0dH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$12
	DD	0eH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$13
	DD	0fH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$14
__ehfuncinfo$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z DD 019930522H
	DD	012H
	DD	FLAT:__unwindtable$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T613066 = -60						; size = 24
$T613068 = -36						; size = 24
$T613067 = -36						; size = 24
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
tv655 = 12						; size = 4
tv652 = 12						; size = 4
$T613281 = 12						; size = 2
$T613262 = 12						; size = 2
$T613243 = 12						; size = 2
$T613224 = 12						; size = 2
$T613205 = 12						; size = 2
_settings$ = 12						; size = 4
??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z PROC	; DRAMsimII::Statistics::Statistics

; 75   : {

	push	-1
	push	__ehhandler$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _settings$[esp+80]
	mov	ebx, DWORD PTR _this$[esp+80]
	mov	eax, DWORD PTR [ebp+300]
	mov	DWORD PTR [ebx], eax
	mov	ecx, DWORD PTR [ebp+304]
	xor	esi, esi
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR [ebp+308]
	mov	DWORD PTR [ebx+8], edx
	mov	DWORD PTR [ebx+12], esi
	mov	DWORD PTR [ebx+16], esi
	mov	DWORD PTR [ebx+20], esi
	mov	DWORD PTR [ebx+24], esi
	mov	DWORD PTR [ebx+28], esi
	mov	eax, DWORD PTR [ebp+224]
	xor	ecx, ecx
	shr	eax, 1
	je	SHORT $LN18@Statistics@12
$LL20@Statistics@12:
	inc	ecx
	shr	eax, 1
	jne	SHORT $LL20@Statistics@12
$LN18@Statistics@12:
	mov	DWORD PTR [ebx+32], ecx
	mov	DWORD PTR [ebx+36], esi
	mov	DWORD PTR [ebx+40], esi
	mov	DWORD PTR [ebx+44], esi
	mov	DWORD PTR [ebx+48], esi
	fild	DWORD PTR [ebp+28]
	mov	eax, DWORD PTR [ebp+28]
	test	eax, eax
	jge	SHORT $LN116@Statistics@12
	fadd	DWORD PTR __real@4f800000
$LN116@Statistics@12:
	mov	ecx, DWORD PTR [ebp+204]
	fild	DWORD PTR [ebp+204]
	test	ecx, ecx
	jge	SHORT $LN117@Statistics@12
	fadd	DWORD PTR __real@4f800000
$LN117@Statistics@12:
	fdivp	ST(1), ST(0)
	lea	eax, DWORD PTR $T613066[esp+84]
	fstp	DWORD PTR [ebx+52]
	mov	edx, DWORD PTR [ebp+304]
	push	edx
	push	eax
	call	??0?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@I@Z ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
	mov	DWORD PTR __$EHRec$[esp+92], esi
	mov	ecx, DWORD PTR [ebp+300]
	push	eax
	push	ecx
	lea	edx, DWORD PTR [ebx+56]
	push	edx
	call	??0?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@1@@Z ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
	mov	BYTE PTR __$EHRec$[esp+92], 2
	mov	eax, DWORD PTR $T613066[esp+96]
	cmp	eax, esi
	je	SHORT $LN28@Statistics@12
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN28@Statistics@12:
	mov	eax, DWORD PTR $T613066[esp+84]
	push	eax
	mov	DWORD PTR $T613066[esp+100], esi
	mov	DWORD PTR $T613066[esp+104], esi
	mov	DWORD PTR $T613066[esp+108], esi
	call	??3@YAXPAX@Z				; operator delete
	mov	edi, DWORD PTR [ebp+304]
	add	esp, 4
	lea	ecx, DWORD PTR $T613067[esp+84]
	push	ecx
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	push	eax
	mov	BYTE PTR __$EHRec$[esp+96], 3
	mov	edx, DWORD PTR [ebp+300]
	push	edx
	lea	eax, DWORD PTR [ebx+80]
	push	eax
	call	??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@IABV?$vector@IV?$allocator@I@std@@@1@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
	mov	BYTE PTR __$EHRec$[esp+92], 5
	mov	eax, DWORD PTR $T613067[esp+96]
	cmp	eax, esi
	je	SHORT $LN43@Statistics@12
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN43@Statistics@12:
	mov	ecx, DWORD PTR $T613067[esp+84]
	push	ecx
	mov	DWORD PTR $T613067[esp+100], esi
	mov	DWORD PTR $T613067[esp+104], esi
	mov	DWORD PTR $T613067[esp+108], esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	lea	edx, DWORD PTR $T613205[esp+80]
	lea	eax, DWORD PTR [ebx+108]
	push	edx
	push	eax
	mov	DWORD PTR [ebx+104], esi
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	ecx, DWORD PTR $T613224[esp+80]
	lea	eax, DWORD PTR [ebx+180]
	push	ecx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+100], 6
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	edx, DWORD PTR $T613243[esp+80]
	lea	eax, DWORD PTR [ebx+252]
	push	edx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+100], 7
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	ecx, DWORD PTR $T613262[esp+80]
	lea	eax, DWORD PTR [ebx+324]
	push	ecx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+100], 8
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	edx, DWORD PTR $T613281[esp+80]
	lea	eax, DWORD PTR [ebx+396]
	push	edx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+100], 9
	call	??0?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@QAE@ABV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@1@ABV?$allocator@U?$pair@$$CBII@std@@@std@@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >
	lea	eax, DWORD PTR [ebx+468]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+96], 10		; 0000000aH
	call	??0?$_Tree@V?$_Tmap_traits@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,DRAMsimII::Statistics::DelayCounter,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,DRAMsimII::Statistics::DelayCounter> >,0> >
	lea	eax, DWORD PTR [ebx+500]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+96], 11		; 0000000bH
	call	??0?$_Tree@V?$_Tmap_traits@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@_K@1@ABV?$allocator@U?$pair@$$CB_KI@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<unsigned __int64,unsigned int,std::less<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned int> >,0> >
	mov	BYTE PTR __$EHRec$[esp+92], 12		; 0000000cH
	mov	edi, DWORD PTR [ebp+308]
	imul	edi, DWORD PTR [ebp+304]
	imul	edi, DWORD PTR [ebp+300]
	lea	eax, DWORD PTR [ebx+532]
	push	eax
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@I@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	mov	BYTE PTR __$EHRec$[esp+92], 13		; 0000000dH
	mov	edi, DWORD PTR [ebp+308]
	imul	edi, DWORD PTR [ebp+304]
	imul	edi, DWORD PTR [ebp+300]
	lea	eax, DWORD PTR [ebx+556]
	push	eax
	call	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
	mov	BYTE PTR __$EHRec$[esp+92], 14		; 0000000eH
	mov	eax, DWORD PTR [ebp+304]
	push	eax
	lea	ecx, DWORD PTR $T613068[esp+88]
	push	ecx
	call	??0?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@I@Z ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
	push	eax
	mov	BYTE PTR __$EHRec$[esp+96], 15		; 0000000fH
	mov	edx, DWORD PTR [ebp+300]
	push	edx
	lea	eax, DWORD PTR [ebx+580]
	push	eax
	call	??0?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@IABV?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@1@@Z ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
	mov	BYTE PTR __$EHRec$[esp+92], 17		; 00000011H
	mov	eax, DWORD PTR $T613068[esp+96]
	cmp	eax, esi
	je	SHORT $LN103@Statistics@12
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN103@Statistics@12:
	mov	ecx, DWORD PTR $T613068[esp+84]
	push	ecx
	mov	DWORD PTR $T613068[esp+100], esi
	mov	DWORD PTR $T613068[esp+104], esi
	mov	DWORD PTR $T613068[esp+108], esi
	call	??3@YAXPAX@Z				; operator delete

; 76   : 	bankLatencyUtilization.reserve(settings.channelCount * settings.rankCount * settings.bankCount);

	mov	edx, DWORD PTR [ebp+308]
	imul	edx, DWORD PTR [ebp+304]
	imul	edx, DWORD PTR [ebp+300]
	add	esp, 4
	push	edx
	lea	esi, DWORD PTR [ebx+556]
	call	?reserve@?$vector@_JV?$allocator@_J@std@@@std@@QAEXI@Z ; std::vector<__int64,std::allocator<__int64> >::reserve

; 77   : 	aggregateBankUtilization.reserve(settings.channelCount * settings.rankCount * settings.bankCount);

	mov	eax, DWORD PTR [ebp+308]
	imul	eax, DWORD PTR [ebp+304]
	imul	eax, DWORD PTR [ebp+300]
	push	eax
	lea	esi, DWORD PTR [ebx+532]
	call	?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::reserve

; 78   : }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 64					; 00000040H
	ret	8
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$0:
	lea	esi, DWORD PTR $T613066[ebp]
	jmp	??1?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >::~vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$1:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 56					; 00000038H
	jmp	??1?$vector@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@II@std@@V?$allocator@U?$pair@II@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >::~vector<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >,std::allocator<std::vector<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > > >
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$2:
	lea	esi, DWORD PTR $T613067[ebp]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$3:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 80					; 00000050H
	jmp	??1?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::~vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$4:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 108				; 0000006cH
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$5:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 180				; 000000b4H
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$6:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 252				; 000000fcH
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$7:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 324				; 00000144H
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$8:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 396				; 0000018cH
	jmp	??1?$unordered_map@IIV?$hash@I@tr1@std@@U?$equal_to@I@3@V?$allocator@U?$pair@$$CBII@std@@@3@@tr1@std@@QAE@XZ
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$9:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 468				; 000001d4H
	push	eax
	call	??1?$map@_KVDelayCounter@Statistics@DRAMsimII@@U?$less@_K@std@@V?$allocator@U?$pair@$$CB_KVDelayCounter@Statistics@DRAMsimII@@@std@@@5@@std@@QAE@XZ
	ret	0
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$10:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 500				; 000001f4H
	push	eax
	call	??1?$map@_KIU?$less@_K@std@@V?$allocator@U?$pair@$$CB_KI@std@@@2@@std@@QAE@XZ
	ret	0
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$11:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 532				; 00000214H
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$12:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 556				; 0000022cH
	jmp	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$13:
	lea	esi, DWORD PTR $T613068[ebp]
	jmp	??1?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >::~vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >
__unwindfunclet$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z$14:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 580				; 00000244H
	jmp	??1?$vector@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@V?$allocator@V?$vector@U?$pair@U?$pair@_K_K@std@@U12@@std@@V?$allocator@U?$pair@U?$pair@_K_K@std@@U12@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >::~vector<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > >,std::allocator<std::vector<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >,std::allocator<std::pair<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> > > > > >
__ehhandler$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z
	jmp	___CxxFrameHandler3
??0Statistics@DRAMsimII@@QAE@ABVSettings@1@@Z ENDP	; DRAMsimII::Statistics::Statistics
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xhash
;	COMDAT ?_Reinsert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXXZ
_TEXT	SEGMENT
$T626451 = -20						; size = 8
$T626452 = -12						; size = 12
?_Reinsert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXXZ PROC ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Reinsert, COMDAT
; _this$ = ecx

; 887  : 		{	// insert elements at beginning of list into table

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx
	push	edi
	lea	edi, DWORD PTR [ebx+8]
	npad	4
$LL2@Reinsert@2:

; 888  : 		iterator _First;
; 889  : 		for (; (_First = _List.begin()) != _Get_iter_from_vec(_Vec[0]); )

	mov	ecx, DWORD PTR [ebx+52]
	sub	ecx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [edi+20]
	mov	ebp, DWORD PTR [eax]
	mov	esi, DWORD PTR [edi]
	sar	ecx, 3
	test	ecx, ecx
	ja	SHORT $LN33@Reinsert@2
	call	__invalid_parameter_noinfo
$LN33@Reinsert@2:
	mov	edx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T626451[esp+40], eax
	test	edi, edi
	jne	SHORT $LN46@Reinsert@2
	call	__invalid_parameter_noinfo
$LN46@Reinsert@2:
	mov	eax, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN60@Reinsert@2
	cmp	esi, eax
	je	SHORT $LN61@Reinsert@2
$LN60@Reinsert@2:
	call	__invalid_parameter_noinfo
$LN61@Reinsert@2:
	cmp	ebp, DWORD PTR $T626451[esp+40]
	je	SHORT $LN1@Reinsert@2

; 890  : 			_Insert(*_First, _First);

	test	esi, esi
	jne	SHORT $LN88@Reinsert@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN82@Reinsert@2:
	cmp	ebp, DWORD PTR [eax+20]
	jne	SHORT $LN71@Reinsert@2
	call	__invalid_parameter_noinfo
$LN71@Reinsert@2:
	push	ebp
	push	esi
	add	ebp, 8
	push	ebp
	lea	ecx, DWORD PTR $T626452[esp+48]
	push	ecx
	push	ebx
	call	?_Insert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAE?AU?$pair@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@std@@_N@std@@ABU?$pair@$$CBII@4@V?$_Iterator@$00@?$list@U?$pair@$$CBII@std@@V?$allocator@U?$pair@$$CBII@std@@@2@@4@@Z ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Insert
	jmp	SHORT $LL2@Reinsert@2
$LN88@Reinsert@2:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN82@Reinsert@2
$LN1@Reinsert@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 891  : 		}

	add	esp, 20					; 00000014H
	ret	0
?_Reinsert@?$_Hash@V?$_Umap_traits@IIV?$_Hash_compare@IV?$hash@I@tr1@std@@U?$equal_to@I@3@@stdext@@V?$allocator@U?$pair@$$CBII@std@@@std@@$0A@@tr1@std@@@stdext@@IAEXXZ ENDP ; stdext::_Hash<std::tr1::_Umap_traits<unsigned int,unsigned int,stdext::_Hash_compare<unsigned int,std::tr1::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,unsigned int> >,0> >::_Reinsert
_TEXT	ENDS
PUBLIC	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVStatistics@0@@Z ; DRAMsimII::operator<<
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.cpp
_TEXT	SEGMENT
tv6210 = -28						; size = 4
$T630225 = -28						; size = 4
_misses$ = -28						; size = 8
_hitCount$ = -28					; size = 4
$T630264 = -20						; size = 8
_h$126309 = -20						; size = 8
_h$126044 = -20						; size = 8
_hits$ = -12						; size = 8
_currentValue$125885 = -12				; size = 8
$T626759 = -12						; size = 8
_currentValue$125732 = -12				; size = 8
_currentValue$125697 = -12				; size = 8
_currentValue$125662 = -12				; size = 8
_currentValue$125627 = -12				; size = 8
_currentValue$125567 = -12				; size = 8
_os$ = 8						; size = 4
tv6208 = 12						; size = 4
tv6206 = 12						; size = 4
tv6204 = 12						; size = 4
tv6171 = 12						; size = 4
tv6169 = 12						; size = 4
tv5056 = 12						; size = 4
_i$126481 = 12						; size = 4
_i$126457 = 12						; size = 4
_missCount$ = 12					; size = 4
_statsLog$ = 12						; size = 4
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVStatistics@0@@Z PROC ; DRAMsimII::operator<<

; 225  : {

	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _statsLog$[esp+32]

; 226  : 	using std::vector;
; 227  : #if 0
; 228  : 	os << "RR[" << setw(6) << setprecision(6) << (double)statsLog.end_time/max(1,statsLog.bo4_count + statsLog.bo8_count) << "] ";
; 229  : 	os << "BWE[" << setw(6) << setprecision(6) << ((double)statsLog.bo8_count * 8.0 + statsLog.bo4_count * 4.0) * 100.0 / max(statsLog.end_time,(tick)1) << "]" << endl;
; 230  : 
; 231  : 	os << "----R W Total----" << endl;
; 232  : 	os << statsLog.readCount << " " << statsLog.writeCount << " " << statsLog.readCount + statsLog.writeCount << endl;
; 233  : #endif
; 234  : 	os << "----Transaction Delay " << statsLog.transactionDecodeDelay.size() << "----" << endl;

	mov	eax, DWORD PTR [ebp+356]
	push	esi
	push	edi
	push	OFFSET ??_C@_04ECGLBLOI@?9?9?9?9?$AA@
	push	ecx
	push	eax
	mov	eax, DWORD PTR _os$[esp+52]
	push	ecx
	push	OFFSET ??_C@_0BH@GGHGAMGD@?9?9?9?9Transaction?5Delay?5?$AA@
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 235  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.transactionDecodeDelay.begin(); currentValue != statsLog.transactionDecodeDelay.end(); currentValue++)

	mov	ecx, DWORD PTR [ebp+352]
	mov	esi, DWORD PTR [ebp+332]
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR _currentValue$125567[esp+44], esi
$LL83@operator@413:
	mov	edi, DWORD PTR [ebp+352]
	mov	eax, DWORD PTR [ebp+332]
	test	esi, esi
	je	SHORT $LN113@operator@413
	cmp	esi, eax
	je	SHORT $LN114@operator@413
$LN113@operator@413:
	call	__invalid_parameter_noinfo
$LN114@operator@413:
	cmp	ebx, edi
	je	$LN46@operator@413

; 236  : 	{
; 237  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	test	esi, esi
	jne	$LN1581@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN133@operator@413:
	cmp	ebx, DWORD PTR [eax+20]
	jne	SHORT $LN122@operator@413
	call	__invalid_parameter_noinfo
$LN122@operator@413:
	test	esi, esi
	jne	$LN1580@operator@413
	call	__invalid_parameter_noinfo
$LN149@operator@413:
	cmp	ebx, DWORD PTR [esi+20]
	jne	SHORT $LN138@operator@413
	call	__invalid_parameter_noinfo
$LN138@operator@413:
	mov	edx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+8]
	push	edx
	push	ecx
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	mov	ecx, DWORD PTR _os$[esp+56]
	push	eax
	push	ecx
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN158@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN158@operator@413
	mov	edi, 4
$LN158@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN47@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN176@operator@413
	or	eax, 4
$LN176@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN47@operator@413:
	mov	eax, DWORD PTR _currentValue$125567[esp+44]
	test	eax, eax
	jne	SHORT $LN1579@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN90@operator@413:

; 235  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.transactionDecodeDelay.begin(); currentValue != statsLog.transactionDecodeDelay.end(); currentValue++)

	cmp	ebx, DWORD PTR [eax+20]
	jne	SHORT $LN79@operator@413
	call	__invalid_parameter_noinfo
$LN79@operator@413:
	mov	ebx, DWORD PTR [ebx]
	mov	esi, DWORD PTR _currentValue$125567[esp+44]
	jmp	$LL83@operator@413
$LN1581@operator@413:

; 236  : 	{
; 237  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	mov	eax, DWORD PTR [esi]
	jmp	$LN133@operator@413
$LN1580@operator@413:
	mov	esi, DWORD PTR [esi]
	jmp	$LN149@operator@413
$LN1579@operator@413:

; 235  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.transactionDecodeDelay.begin(); currentValue != statsLog.transactionDecodeDelay.end(); currentValue++)

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN90@operator@413
$LN46@operator@413:

; 238  : 	}
; 239  : 	os << "----Command Turnaround " << statsLog.commandTurnaround.size() << "----" << endl;

	mov	eax, DWORD PTR [ebp+284]
	mov	edx, DWORD PTR _os$[esp+40]
	push	OFFSET ??_C@_04ECGLBLOI@?9?9?9?9?$AA@
	push	ecx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BI@OFHLBMPE@?9?9?9?9Command?5Turnaround?5?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN186@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN186@operator@413
	mov	edi, 4
$LN186@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN202@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN204@operator@413
	or	eax, 4
$LN204@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN202@operator@413:

; 240  : 	for (unordered_map<unsigned,unsigned>::const_iterator currentValue = statsLog.commandTurnaround.begin(); currentValue != statsLog.commandTurnaround.end(); currentValue++)

	mov	edx, DWORD PTR [ebp+280]
	mov	esi, DWORD PTR [ebp+260]
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR _currentValue$125627[esp+44], esi
	npad	6
$LL230@operator@413:
	mov	edi, DWORD PTR [ebp+280]
	mov	eax, DWORD PTR [ebp+260]
	test	esi, esi
	je	SHORT $LN260@operator@413
	cmp	esi, eax
	je	SHORT $LN261@operator@413
$LN260@operator@413:
	call	__invalid_parameter_noinfo
$LN261@operator@413:
	cmp	ebx, edi
	je	$LN43@operator@413

; 241  : 	{
; 242  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	test	esi, esi
	jne	$LN1578@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN280@operator@413:
	cmp	ebx, DWORD PTR [eax+20]
	jne	SHORT $LN269@operator@413
	call	__invalid_parameter_noinfo
$LN269@operator@413:
	test	esi, esi
	jne	$LN1577@operator@413
	call	__invalid_parameter_noinfo
$LN296@operator@413:
	cmp	ebx, DWORD PTR [esi+20]
	jne	SHORT $LN285@operator@413
	call	__invalid_parameter_noinfo
$LN285@operator@413:
	mov	eax, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR _os$[esp+40]
	push	eax
	push	ecx
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	mov	ecx, DWORD PTR [ebx+8]
	push	ecx
	push	edx
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN305@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN305@operator@413
	mov	edi, 4
$LN305@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN44@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN323@operator@413
	or	eax, 4
$LN323@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN44@operator@413:
	mov	eax, DWORD PTR _currentValue$125627[esp+44]
	test	eax, eax
	jne	SHORT $LN1576@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN237@operator@413:

; 240  : 	for (unordered_map<unsigned,unsigned>::const_iterator currentValue = statsLog.commandTurnaround.begin(); currentValue != statsLog.commandTurnaround.end(); currentValue++)

	cmp	ebx, DWORD PTR [eax+20]
	jne	SHORT $LN226@operator@413
	call	__invalid_parameter_noinfo
$LN226@operator@413:
	mov	ebx, DWORD PTR [ebx]
	mov	esi, DWORD PTR _currentValue$125627[esp+44]
	jmp	$LL230@operator@413
$LN1578@operator@413:

; 241  : 	{
; 242  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	mov	eax, DWORD PTR [esi]
	jmp	$LN280@operator@413
$LN1577@operator@413:
	mov	esi, DWORD PTR [esi]
	jmp	$LN296@operator@413
$LN1576@operator@413:

; 240  : 	for (unordered_map<unsigned,unsigned>::const_iterator currentValue = statsLog.commandTurnaround.begin(); currentValue != statsLog.commandTurnaround.end(); currentValue++)

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN237@operator@413
$LN43@operator@413:

; 243  : 	}
; 244  : 	os << "----Command Delay " << statsLog.commandDelay.size() << "----" << endl;

	mov	eax, DWORD PTR [ebp+140]
	mov	edx, DWORD PTR _os$[esp+40]
	push	OFFSET ??_C@_04ECGLBLOI@?9?9?9?9?$AA@
	push	ecx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BD@BJDMIPKA@?9?9?9?9Command?5Delay?5?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN333@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN333@operator@413
	mov	edi, 4
$LN333@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN349@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN351@operator@413
	or	eax, 4
$LN351@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN349@operator@413:

; 245  : 	for (unordered_map<unsigned,unsigned>::const_iterator currentValue = statsLog.commandDelay.begin(); currentValue != statsLog.commandDelay.end(); currentValue++)

	mov	edx, DWORD PTR [ebp+136]
	mov	esi, DWORD PTR [ebp+116]
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR _currentValue$125662[esp+44], esi
	npad	9
$LL377@operator@413:
	mov	edi, DWORD PTR [ebp+136]
	mov	eax, DWORD PTR [ebp+116]
	test	esi, esi
	je	SHORT $LN407@operator@413
	cmp	esi, eax
	je	SHORT $LN408@operator@413
$LN407@operator@413:
	call	__invalid_parameter_noinfo
$LN408@operator@413:
	cmp	ebx, edi
	je	$LN40@operator@413

; 246  : 	{
; 247  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	test	esi, esi
	jne	$LN1575@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN427@operator@413:
	cmp	ebx, DWORD PTR [eax+20]
	jne	SHORT $LN416@operator@413
	call	__invalid_parameter_noinfo
$LN416@operator@413:
	test	esi, esi
	jne	$LN1574@operator@413
	call	__invalid_parameter_noinfo
$LN443@operator@413:
	cmp	ebx, DWORD PTR [esi+20]
	jne	SHORT $LN432@operator@413
	call	__invalid_parameter_noinfo
$LN432@operator@413:
	mov	eax, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR _os$[esp+40]
	push	eax
	push	ecx
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	mov	ecx, DWORD PTR [ebx+8]
	push	ecx
	push	edx
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN452@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN452@operator@413
	mov	edi, 4
$LN452@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN41@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN470@operator@413
	or	eax, 4
$LN470@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN41@operator@413:
	mov	eax, DWORD PTR _currentValue$125662[esp+44]
	test	eax, eax
	jne	SHORT $LN1573@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN384@operator@413:

; 245  : 	for (unordered_map<unsigned,unsigned>::const_iterator currentValue = statsLog.commandDelay.begin(); currentValue != statsLog.commandDelay.end(); currentValue++)

	cmp	ebx, DWORD PTR [eax+20]
	jne	SHORT $LN373@operator@413
	call	__invalid_parameter_noinfo
$LN373@operator@413:
	mov	ebx, DWORD PTR [ebx]
	mov	esi, DWORD PTR _currentValue$125662[esp+44]
	jmp	$LL377@operator@413
$LN1575@operator@413:

; 246  : 	{
; 247  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	mov	eax, DWORD PTR [esi]
	jmp	$LN427@operator@413
$LN1574@operator@413:
	mov	esi, DWORD PTR [esi]
	jmp	$LN443@operator@413
$LN1573@operator@413:

; 245  : 	for (unordered_map<unsigned,unsigned>::const_iterator currentValue = statsLog.commandDelay.begin(); currentValue != statsLog.commandDelay.end(); currentValue++)

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN384@operator@413
$LN40@operator@413:

; 248  : 	}
; 249  : 	os << "----CMD Execution Time " << statsLog.commandExecution.size() << "----" << endl;

	mov	eax, DWORD PTR [ebp+212]
	mov	edx, DWORD PTR _os$[esp+40]
	push	OFFSET ??_C@_04ECGLBLOI@?9?9?9?9?$AA@
	push	ecx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BI@FKLHOOHD@?9?9?9?9CMD?5Execution?5Time?5?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN480@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN480@operator@413
	mov	edi, 4
$LN480@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN496@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN498@operator@413
	or	eax, 4
$LN498@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN496@operator@413:

; 250  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.commandExecution.begin(); currentValue != statsLog.commandExecution.end(); currentValue++)

	mov	edx, DWORD PTR [ebp+208]
	mov	esi, DWORD PTR [ebp+188]
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR _currentValue$125697[esp+44], esi
	npad	9
$LL524@operator@413:
	mov	edi, DWORD PTR [ebp+208]
	mov	eax, DWORD PTR [ebp+188]
	test	esi, esi
	je	SHORT $LN554@operator@413
	cmp	esi, eax
	je	SHORT $LN555@operator@413
$LN554@operator@413:
	call	__invalid_parameter_noinfo
$LN555@operator@413:
	cmp	ebx, edi
	je	$LN37@operator@413

; 251  : 	{
; 252  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	test	esi, esi
	jne	$LN1572@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN574@operator@413:
	cmp	ebx, DWORD PTR [eax+20]
	jne	SHORT $LN563@operator@413
	call	__invalid_parameter_noinfo
$LN563@operator@413:
	test	esi, esi
	jne	$LN1571@operator@413
	call	__invalid_parameter_noinfo
$LN590@operator@413:
	cmp	ebx, DWORD PTR [esi+20]
	jne	SHORT $LN579@operator@413
	call	__invalid_parameter_noinfo
$LN579@operator@413:
	mov	eax, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR _os$[esp+40]
	push	eax
	push	ecx
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	mov	ecx, DWORD PTR [ebx+8]
	push	ecx
	push	edx
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN599@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN599@operator@413
	mov	edi, 4
$LN599@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN38@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN617@operator@413
	or	eax, 4
$LN617@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN38@operator@413:
	mov	eax, DWORD PTR _currentValue$125697[esp+44]
	test	eax, eax
	jne	SHORT $LN1570@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN531@operator@413:

; 250  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.commandExecution.begin(); currentValue != statsLog.commandExecution.end(); currentValue++)

	cmp	ebx, DWORD PTR [eax+20]
	jne	SHORT $LN520@operator@413
	call	__invalid_parameter_noinfo
$LN520@operator@413:
	mov	ebx, DWORD PTR [ebx]
	mov	esi, DWORD PTR _currentValue$125697[esp+44]
	jmp	$LL524@operator@413
$LN1572@operator@413:

; 251  : 	{
; 252  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	mov	eax, DWORD PTR [esi]
	jmp	$LN574@operator@413
$LN1571@operator@413:
	mov	esi, DWORD PTR [esi]
	jmp	$LN590@operator@413
$LN1570@operator@413:

; 250  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.commandExecution.begin(); currentValue != statsLog.commandExecution.end(); currentValue++)

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN531@operator@413
$LN37@operator@413:

; 253  : 	}
; 254  : 	os << "----Transaction Latency " << statsLog.transactionExecution.size() << "----" << endl;

	mov	eax, DWORD PTR [ebp+428]
	mov	edx, DWORD PTR _os$[esp+40]
	push	OFFSET ??_C@_04ECGLBLOI@?9?9?9?9?$AA@
	push	ecx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BJ@CCJBOFFI@?9?9?9?9Transaction?5Latency?5?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN627@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN627@operator@413
	mov	edi, 4
$LN627@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN643@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN645@operator@413
	or	eax, 4
$LN645@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN643@operator@413:

; 255  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.transactionExecution.begin(); currentValue != statsLog.transactionExecution.end(); currentValue++)

	mov	edx, DWORD PTR [ebp+424]
	mov	esi, DWORD PTR [ebp+404]
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR _currentValue$125732[esp+44], esi
	npad	6
$LL671@operator@413:
	mov	edi, DWORD PTR [ebp+424]
	mov	eax, DWORD PTR [ebp+404]
	test	esi, esi
	je	SHORT $LN701@operator@413
	cmp	esi, eax
	je	SHORT $LN702@operator@413
$LN701@operator@413:
	call	__invalid_parameter_noinfo
$LN702@operator@413:
	cmp	ebx, edi
	je	$LN34@operator@413

; 256  : 	{
; 257  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	test	esi, esi
	jne	$LN1569@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN721@operator@413:
	cmp	ebx, DWORD PTR [eax+20]
	jne	SHORT $LN710@operator@413
	call	__invalid_parameter_noinfo
$LN710@operator@413:
	test	esi, esi
	jne	$LN1568@operator@413
	call	__invalid_parameter_noinfo
$LN737@operator@413:
	cmp	ebx, DWORD PTR [esi+20]
	jne	SHORT $LN726@operator@413
	call	__invalid_parameter_noinfo
$LN726@operator@413:
	mov	eax, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR _os$[esp+40]
	push	eax
	push	ecx
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	mov	ecx, DWORD PTR [ebx+8]
	push	ecx
	push	edx
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN746@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN746@operator@413
	mov	edi, 4
$LN746@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN35@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN764@operator@413
	or	eax, 4
$LN764@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN35@operator@413:
	mov	eax, DWORD PTR _currentValue$125732[esp+44]
	test	eax, eax
	jne	SHORT $LN1567@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN678@operator@413:

; 255  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.transactionExecution.begin(); currentValue != statsLog.transactionExecution.end(); currentValue++)

	cmp	ebx, DWORD PTR [eax+20]
	jne	SHORT $LN667@operator@413
	call	__invalid_parameter_noinfo
$LN667@operator@413:
	mov	ebx, DWORD PTR [ebx]
	mov	esi, DWORD PTR _currentValue$125732[esp+44]
	jmp	$LL671@operator@413
$LN1569@operator@413:

; 256  : 	{
; 257  : 		os << (*currentValue).first << " " << (*currentValue).second << endl;

	mov	eax, DWORD PTR [esi]
	jmp	$LN721@operator@413
$LN1568@operator@413:
	mov	esi, DWORD PTR [esi]
	jmp	$LN737@operator@413
$LN1567@operator@413:

; 255  : 	for (unordered_map<unsigned, unsigned>::const_iterator currentValue = statsLog.transactionExecution.begin(); currentValue != statsLog.transactionExecution.end(); currentValue++)

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN678@operator@413
$LN34@operator@413:

; 258  : 	}
; 259  : 
; 260  : 	os << "----Working Set----" << endl << statsLog.workingSet.size() << endl;

	mov	edx, DWORD PTR _os$[esp+40]
	mov	ebx, DWORD PTR [ebp+528]
	push	OFFSET ??_C@_0BE@PBEECLAB@?9?9?9?9Working?5Set?9?9?9?9?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN772@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN772@operator@413
	mov	edi, 4
$LN772@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN788@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN790@operator@413
	or	eax, 4
$LN790@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN788@operator@413:
	push	ebx
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN796@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN796@operator@413
	mov	edi, 4
$LN796@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN812@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN814@operator@413
	or	eax, 4
$LN814@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN812@operator@413:

; 261  : 
; 262  : 	os << "----Bandwidth----" << endl << setprecision(10) << (float)statsLog.readBytesTransferred / statsLog.timePerEpoch << " " << (float)statsLog.writeBytesTransferred / statsLog.timePerEpoch << endl;

	mov	ebx, DWORD PTR _os$[esp+40]
	push	OFFSET ??_C@_0BC@FLEKEEG@?9?9?9?9Bandwidth?9?9?9?9?$AA@
	push	ebx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN820@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN820@operator@413
	mov	edi, 4
$LN820@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN836@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN838@operator@413
	or	eax, 4
$LN838@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN836@operator@413:
	lea	edx, DWORD PTR $T626759[esp+44]
	push	10					; 0000000aH
	push	edx
	call	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z ; std::setprecision
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax]
	add	ecx, esi
	push	edx
	push	ecx
	call	eax
	fld	DWORD PTR [ebp+52]
	mov	ecx, DWORD PTR [ebp+48]
	fstp	DWORD PTR tv5056[esp+56]
	fild	DWORD PTR [ebp+48]
	test	ecx, ecx
	jge	SHORT $LN1603@operator@413
	fadd	DWORD PTR __real@4f800000
$LN1603@operator@413:
	fld	DWORD PTR tv5056[esp+56]
	mov	edx, DWORD PTR [ebp+44]
	fld	ST(0)
	add	esp, 8
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR tv6208[esp+48]
	fld	DWORD PTR tv6208[esp+48]
	fstp	DWORD PTR [esp+4]
	fild	DWORD PTR [ebp+44]
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	test	edx, edx
	jge	SHORT $LN1604@operator@413
	fadd	DWORD PTR __real@4f800000
$LN1604@operator@413:
	fdivrp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR tv6204[esp+60]
	fld	DWORD PTR tv6204[esp+60]
	fstp	DWORD PTR [esp]
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN848@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN848@operator@413
	mov	edi, 4
$LN848@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN864@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN866@operator@413
	or	eax, 4
$LN866@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN864@operator@413:

; 263  : 
; 264  : 	os << "----Average Transaction Latency Per PC Value " << statsLog.pcOccurrence.size() << "----" << endl;

	mov	eax, DWORD PTR [ebp+496]
	push	OFFSET ??_C@_04ECGLBLOI@?9?9?9?9?$AA@
	push	ecx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0CO@FAIAOJGB@?9?9?9?9Average?5Transaction?5Latency?5@
	push	ebx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN874@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN874@operator@413
	mov	edi, 4
$LN874@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN890@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN892@operator@413
	or	eax, 4
$LN892@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN890@operator@413:

; 265  : 	for (std::map<PhysicalAddress, Statistics::DelayCounter>::const_iterator currentValue = statsLog.pcOccurrence.begin(); currentValue != statsLog.pcOccurrence.end(); currentValue++)

	mov	edx, DWORD PTR [ebp+492]
	mov	esi, DWORD PTR [ebp+468]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR _currentValue$125885[esp+44], esi
	npad	12
$LL917@operator@413:
	mov	ebx, DWORD PTR [ebp+492]
	mov	eax, DWORD PTR [ebp+468]
	test	esi, esi
	je	SHORT $LN965@operator@413
	cmp	esi, eax
	je	SHORT $LN966@operator@413
$LN965@operator@413:
	call	__invalid_parameter_noinfo
$LN966@operator@413:
	cmp	edi, ebx
	je	$LN31@operator@413

; 266  : 	{
; 267  : 		os << std::hex << (*currentValue).first << " " << std::noshowpoint << (float)(*currentValue).second.getAccumulatedLatency() / (float)(*currentValue).second.getCount() << " " << std::dec << (*currentValue).second.getCount() << endl;

	test	esi, esi
	jne	SHORT $LN1566@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN982@operator@413:
	cmp	edi, DWORD PTR [eax+24]
	jne	SHORT $LN973@operator@413
	call	__invalid_parameter_noinfo
$LN973@operator@413:
	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR $T630225[esp+44], eax
	test	esi, esi
	jne	SHORT $LN1565@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN998@operator@413:
	cmp	edi, DWORD PTR [eax+24]
	jne	SHORT $LN989@operator@413
	call	__invalid_parameter_noinfo
$LN989@operator@413:
	mov	ecx, DWORD PTR [edi+24]
	mov	edx, DWORD PTR [edi+28]
	mov	DWORD PTR $T630264[esp+44], ecx
	mov	DWORD PTR $T630264[esp+48], edx
	test	esi, esi
	jne	SHORT $LN1564@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1014@operator@413:
	cmp	edi, DWORD PTR [eax+24]
	jne	SHORT $LN1005@operator@413
	call	__invalid_parameter_noinfo
$LN1005@operator@413:
	mov	ebx, DWORD PTR [edi+32]
	test	esi, esi
	jne	SHORT $LN1563@operator@413
	call	__invalid_parameter_noinfo
$LN1030@operator@413:
	cmp	edi, DWORD PTR [esi+24]
	jne	SHORT $LN1021@operator@413
	call	__invalid_parameter_noinfo
$LN1021@operator@413:
	mov	ecx, DWORD PTR _os$[esp+40]
	test	ecx, ecx
	jne	SHORT $LN1037@operator@413
	xor	eax, eax
	jmp	SHORT $LN1038@operator@413
$LN1566@operator@413:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN982@operator@413
$LN1565@operator@413:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN998@operator@413
$LN1564@operator@413:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN1014@operator@413
$LN1563@operator@413:
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN1030@operator@413
$LN1037@operator@413:
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	add	eax, ecx
$LN1038@operator@413:
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -1537				; fffff9ffH
	or	ecx, 2048				; 00000800H
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [edi+16]
	push	ecx
	mov	ecx, DWORD PTR _os$[esp+48]
	push	edx
	push	eax
	push	ecx
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1045@operator@413
	xor	ecx, ecx
	jmp	SHORT $LN1046@operator@413
$LN1045@operator@413:
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, eax
$LN1046@operator@413:
	and	DWORD PTR [ecx+16], -17			; ffffffefH
	fild	QWORD PTR $T630264[esp+44]
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	DWORD PTR tv6171[esp+44], ebx
	fild	DWORD PTR tv6171[esp+44]
	push	ecx
	test	ebx, ebx
	jge	SHORT $LN1605@operator@413
	fadd	DWORD PTR __real@4f800000
$LN1605@operator@413:
	fdivp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR tv6169[esp+52]
	fld	DWORD PTR tv6169[esp+52]
	fstp	DWORD PTR [esp]
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1053@operator@413
	xor	ecx, ecx
	jmp	SHORT $LN1054@operator@413
$LN1053@operator@413:
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
$LN1054@operator@413:
	mov	edx, DWORD PTR [ecx+16]
	and	edx, -3073				; fffff3ffH
	or	edx, 512				; 00000200H
	mov	DWORD PTR [ecx+16], edx
	mov	ecx, DWORD PTR $T630225[esp+44]
	push	ecx
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN1063@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1063@operator@413
	mov	ebx, 4
$LN1063@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN32@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN1081@operator@413
	or	eax, 4
$LN1081@operator@413:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN32@operator@413:

; 265  : 	for (std::map<PhysicalAddress, Statistics::DelayCounter>::const_iterator currentValue = statsLog.pcOccurrence.begin(); currentValue != statsLog.pcOccurrence.end(); currentValue++)

	cmp	DWORD PTR _currentValue$125885[esp+44], 0
	jne	SHORT $LN921@operator@413
	call	__invalid_parameter_noinfo
$LN921@operator@413:
	cmp	BYTE PTR [edi+41], 0
	je	SHORT $LN920@operator@413
	call	__invalid_parameter_noinfo
	mov	esi, DWORD PTR _currentValue$125885[esp+44]
	jmp	$LL917@operator@413
$LN920@operator@413:
	mov	eax, DWORD PTR [edi+8]
	cmp	BYTE PTR [eax+41], 0
	jne	SHORT $LN1530@operator@413
	mov	edi, eax
	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+41], 0
	jne	SHORT $LN934@operator@413
$LL935@operator@413:
	mov	edi, eax
	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+41], 0
	je	SHORT $LL935@operator@413
$LN934@operator@413:
	mov	esi, DWORD PTR _currentValue$125885[esp+44]
	jmp	$LL917@operator@413
$LN1530@operator@413:
	mov	eax, DWORD PTR [edi+4]
	cmp	BYTE PTR [eax+41], 0
	jne	SHORT $LN915@operator@413
	npad	1
$LL916@operator@413:
	cmp	edi, DWORD PTR [eax+8]
	jne	SHORT $LN915@operator@413
	mov	edi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+41], 0
	je	SHORT $LL916@operator@413
$LN915@operator@413:
	mov	esi, DWORD PTR _currentValue$125885[esp+44]
	mov	edi, eax
	jmp	$LL917@operator@413
$LN31@operator@413:

; 268  : 	}
; 269  : 
; 270  : 	unsigned hitCount = 0, missCount = 0;
; 271  : 	for (vector<vector<pair<unsigned,unsigned> > >::const_iterator h = statsLog.getRowBufferAccesses().begin(); h != statsLog.rowBufferAccesses.end(); h++)

	mov	edi, DWORD PTR [ebp+68]
	xor	eax, eax
	mov	DWORD PTR _hitCount$[esp+44], eax
	mov	DWORD PTR _missCount$[esp+40], eax
	cmp	edi, DWORD PTR [ebp+72]
	jbe	SHORT $LN1088@operator@413
	call	__invalid_parameter_noinfo
$LN1088@operator@413:
	mov	esi, DWORD PTR [ebp+56]
	mov	DWORD PTR _h$126044[esp+44], esi
	mov	DWORD PTR _h$126044[esp+48], edi
	npad	3
$LL1103@operator@413:
	mov	ebx, DWORD PTR [ebp+72]
	cmp	DWORD PTR [ebp+68], ebx
	jbe	SHORT $LN1116@operator@413
	call	__invalid_parameter_noinfo
$LN1116@operator@413:
	mov	eax, DWORD PTR [ebp+56]
	test	esi, esi
	je	SHORT $LN1129@operator@413
	cmp	esi, eax
	je	SHORT $LN1130@operator@413
$LN1129@operator@413:
	call	__invalid_parameter_noinfo
$LN1130@operator@413:
	cmp	edi, ebx
	je	$LN28@operator@413

; 272  : 	{
; 273  : 		for (vector<pair<unsigned,unsigned> >::const_iterator i = h->begin(); i != h->end(); i++)

	test	esi, esi
	jne	$LN1562@operator@413
	call	__invalid_parameter_noinfo
$LN1148@operator@413:
	cmp	edi, DWORD PTR [esi+16]
	jb	SHORT $LN1139@operator@413
	call	__invalid_parameter_noinfo
$LN1139@operator@413:
	mov	ebx, DWORD PTR [edi+12]
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN1154@operator@413
	call	__invalid_parameter_noinfo
$LN1154@operator@413:
	mov	edx, DWORD PTR _h$126044[esp+48]
	mov	esi, DWORD PTR [edx]
	npad	1
$LL1169@operator@413:
	mov	eax, DWORD PTR _h$126044[esp+44]
	test	eax, eax
	jne	$LN1561@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1190@operator@413:
	mov	ecx, DWORD PTR _h$126044[esp+48]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN1181@operator@413
	call	__invalid_parameter_noinfo
$LN1181@operator@413:
	mov	eax, DWORD PTR _h$126044[esp+48]
	mov	edi, DWORD PTR [eax+16]
	cmp	DWORD PTR [eax+12], edi
	ja	SHORT $LN1195@operator@413
	cmp	edi, edi
	jbe	SHORT $LN1196@operator@413
$LN1195@operator@413:
	call	__invalid_parameter_noinfo
$LN1196@operator@413:
	mov	edx, DWORD PTR _h$126044[esp+48]
	mov	eax, DWORD PTR [edx]
	test	esi, esi
	je	SHORT $LN1209@operator@413
	cmp	esi, eax
	je	SHORT $LN1210@operator@413
$LN1209@operator@413:
	call	__invalid_parameter_noinfo
$LN1210@operator@413:
	cmp	ebx, edi
	je	SHORT $LN29@operator@413

; 274  : 		{
; 275  : 			hitCount += i->first;

	test	esi, esi
	jne	SHORT $LN1560@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1228@operator@413:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1219@operator@413
	call	__invalid_parameter_noinfo
$LN1219@operator@413:
	mov	eax, DWORD PTR [ebx]
	add	DWORD PTR _hitCount$[esp+44], eax

; 276  : 			missCount += i->second;

	test	esi, esi
	jne	SHORT $LN1559@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1242@operator@413:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1233@operator@413
	call	__invalid_parameter_noinfo
$LN1233@operator@413:
	mov	ecx, DWORD PTR [ebx+4]
	add	DWORD PTR _missCount$[esp+40], ecx
	test	esi, esi
	jne	SHORT $LN1558@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1176@operator@413:

; 272  : 	{
; 273  : 		for (vector<pair<unsigned,unsigned> >::const_iterator i = h->begin(); i != h->end(); i++)

	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1167@operator@413
	call	__invalid_parameter_noinfo
$LN1167@operator@413:
	add	ebx, 8
	jmp	$LL1169@operator@413
$LN1562@operator@413:
	mov	esi, DWORD PTR [esi]
	jmp	$LN1148@operator@413
$LN1561@operator@413:
	mov	eax, DWORD PTR [eax]
	jmp	$LN1190@operator@413
$LN1560@operator@413:

; 274  : 		{
; 275  : 			hitCount += i->first;

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN1228@operator@413
$LN1559@operator@413:

; 276  : 			missCount += i->second;

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN1242@operator@413
$LN1558@operator@413:

; 272  : 	{
; 273  : 		for (vector<pair<unsigned,unsigned> >::const_iterator i = h->begin(); i != h->end(); i++)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN1176@operator@413
$LN29@operator@413:

; 268  : 	}
; 269  : 
; 270  : 	unsigned hitCount = 0, missCount = 0;
; 271  : 	for (vector<vector<pair<unsigned,unsigned> > >::const_iterator h = statsLog.getRowBufferAccesses().begin(); h != statsLog.rowBufferAccesses.end(); h++)

	mov	eax, DWORD PTR _h$126044[esp+44]
	test	eax, eax
	jne	SHORT $LN1557@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1110@operator@413:
	mov	edx, DWORD PTR _h$126044[esp+48]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN1101@operator@413
	call	__invalid_parameter_noinfo
$LN1101@operator@413:
	add	DWORD PTR _h$126044[esp+48], 24		; 00000018H
	mov	esi, DWORD PTR _h$126044[esp+44]
	mov	edi, DWORD PTR _h$126044[esp+48]
	jmp	$LL1103@operator@413
$LN1557@operator@413:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1110@operator@413
$LN28@operator@413:

; 277  : 		}
; 278  : 	}
; 279  : 	os << "----Row Hit/Miss Counts----" << endl << hitCount << " " << missCount << endl;

	mov	eax, DWORD PTR _os$[esp+40]
	push	OFFSET ??_C@_0BM@FMOJPDMJ@?9?9?9?9Row?5Hit?1Miss?5Counts?9?9?9?9?$AA@
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	xor	ebx, ebx
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN1249@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1249@operator@413
	mov	edi, 4
$LN1249@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	cmp	edi, ebx
	je	SHORT $LN1265@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], ebx
	jne	SHORT $LN1267@operator@413
	or	eax, 4
$LN1267@operator@413:
	push	ebx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN1265@operator@413:
	mov	edx, DWORD PTR _missCount$[esp+40]
	mov	eax, DWORD PTR _hitCount$[esp+44]
	push	edx
	push	ecx
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	push	eax
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN1273@operator@413
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1273@operator@413
	mov	edi, 4
$LN1273@operator@413:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	cmp	edi, ebx
	je	SHORT $LN1289@operator@413
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], ebx
	jne	SHORT $LN1291@operator@413
	or	eax, 4
$LN1291@operator@413:
	push	ebx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN1289@operator@413:

; 280  : 
; 281  : 
; 282  : 	uint64_t hits = 0, misses = 0;
; 283  : 	for (vector<vector<pair<pair<uint64_t, uint64_t>, pair<uint64_t, uint64_t> > > >::const_iterator h = statsLog.hitRate.begin(); h != statsLog.hitRate.end(); h++)

	mov	esi, DWORD PTR [ebp+592]
	mov	DWORD PTR _hits$[esp+44], ebx
	mov	DWORD PTR _hits$[esp+48], ebx
	mov	DWORD PTR _misses$[esp+44], ebx
	mov	DWORD PTR _misses$[esp+48], ebx
	cmp	esi, DWORD PTR [ebp+596]
	jbe	SHORT $LN1296@operator@413
	call	__invalid_parameter_noinfo
$LN1296@operator@413:
	mov	ebx, DWORD PTR [ebp+580]
	mov	edi, esi
	mov	DWORD PTR _h$126309[esp+44], ebx
	mov	DWORD PTR _h$126309[esp+48], edi
	npad	2
$LL1311@operator@413:
	mov	esi, DWORD PTR [ebp+596]
	cmp	DWORD PTR [ebp+592], esi
	jbe	SHORT $LN1324@operator@413
	call	__invalid_parameter_noinfo
$LN1324@operator@413:
	mov	eax, DWORD PTR [ebp+580]
	test	ebx, ebx
	je	SHORT $LN1337@operator@413
	cmp	ebx, eax
	je	SHORT $LN1338@operator@413
$LN1337@operator@413:
	call	__invalid_parameter_noinfo
$LN1338@operator@413:
	cmp	edi, esi
	je	$LN22@operator@413

; 284  : 	{
; 285  : 		for (vector<pair<pair<uint64_t, uint64_t>, pair<uint64_t, uint64_t> > >::const_iterator i = h->begin(); i != h->end(); i++)

	test	ebx, ebx
	jne	$LN1556@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1356@operator@413:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN1347@operator@413
	call	__invalid_parameter_noinfo
$LN1347@operator@413:
	mov	esi, DWORD PTR [edi+12]
	cmp	esi, DWORD PTR [edi+16]
	jbe	SHORT $LN1362@operator@413
	call	__invalid_parameter_noinfo
$LN1362@operator@413:
	mov	edx, DWORD PTR _h$126309[esp+48]
	mov	edi, DWORD PTR [edx]
	npad	6
$LL1377@operator@413:
	test	ebx, ebx
	jne	$LN1555@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1398@operator@413:
	mov	ecx, DWORD PTR _h$126309[esp+48]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN1389@operator@413
	call	__invalid_parameter_noinfo
$LN1389@operator@413:
	mov	eax, DWORD PTR _h$126309[esp+48]
	mov	ebx, DWORD PTR [eax+16]
	cmp	DWORD PTR [eax+12], ebx
	ja	SHORT $LN1403@operator@413
	cmp	ebx, ebx
	jbe	SHORT $LN1404@operator@413
$LN1403@operator@413:
	call	__invalid_parameter_noinfo
$LN1404@operator@413:
	mov	edx, DWORD PTR _h$126309[esp+48]
	mov	eax, DWORD PTR [edx]
	test	edi, edi
	je	SHORT $LN1417@operator@413
	cmp	edi, eax
	je	SHORT $LN1418@operator@413
$LN1417@operator@413:
	call	__invalid_parameter_noinfo
$LN1418@operator@413:
	cmp	esi, ebx
	je	$LN23@operator@413

; 286  : 		{
; 287  : 			hits += i->first.first + i->second.first;

	test	edi, edi
	jne	$LN1554@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1436@operator@413:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN1427@operator@413
	call	__invalid_parameter_noinfo
$LN1427@operator@413:
	test	edi, edi
	jne	$LN1553@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1450@operator@413:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN1441@operator@413
	call	__invalid_parameter_noinfo
$LN1441@operator@413:
	mov	eax, DWORD PTR [esi+16]
	add	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+20]
	adc	ecx, DWORD PTR [esi+4]
	add	DWORD PTR _hits$[esp+44], eax
	adc	DWORD PTR _hits$[esp+48], ecx

; 288  : 			misses += i->first.second + i->second.second;

	test	edi, edi
	jne	SHORT $LN1552@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1464@operator@413:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN1455@operator@413
	call	__invalid_parameter_noinfo
$LN1455@operator@413:
	test	edi, edi
	jne	SHORT $LN1551@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1478@operator@413:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN1469@operator@413
	call	__invalid_parameter_noinfo
$LN1469@operator@413:
	mov	edx, DWORD PTR [esi+8]
	add	edx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+12]
	adc	eax, DWORD PTR [esi+28]
	add	DWORD PTR _misses$[esp+44], edx
	adc	DWORD PTR _misses$[esp+48], eax
	test	edi, edi
	jne	SHORT $LN1550@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1384@operator@413:

; 284  : 	{
; 285  : 		for (vector<pair<pair<uint64_t, uint64_t>, pair<uint64_t, uint64_t> > >::const_iterator i = h->begin(); i != h->end(); i++)

	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN1375@operator@413
	call	__invalid_parameter_noinfo
$LN1375@operator@413:
	mov	ebx, DWORD PTR _h$126309[esp+44]
	add	esi, 32					; 00000020H
	jmp	$LL1377@operator@413
$LN1556@operator@413:
	mov	eax, DWORD PTR [ebx]
	jmp	$LN1356@operator@413
$LN1555@operator@413:
	mov	eax, DWORD PTR [ebx]
	jmp	$LN1398@operator@413
$LN1554@operator@413:

; 286  : 		{
; 287  : 			hits += i->first.first + i->second.first;

	mov	eax, DWORD PTR [edi]
	jmp	$LN1436@operator@413
$LN1553@operator@413:
	mov	eax, DWORD PTR [edi]
	jmp	$LN1450@operator@413
$LN1552@operator@413:

; 288  : 			misses += i->first.second + i->second.second;

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN1464@operator@413
$LN1551@operator@413:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN1478@operator@413
$LN1550@operator@413:

; 284  : 	{
; 285  : 		for (vector<pair<pair<uint64_t, uint64_t>, pair<uint64_t, uint64_t> > >::const_iterator i = h->begin(); i != h->end(); i++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN1384@operator@413
$LN23@operator@413:

; 280  : 
; 281  : 
; 282  : 	uint64_t hits = 0, misses = 0;
; 283  : 	for (vector<vector<pair<pair<uint64_t, uint64_t>, pair<uint64_t, uint64_t> > > >::const_iterator h = statsLog.hitRate.begin(); h != statsLog.hitRate.end(); h++)

	mov	eax, DWORD PTR _h$126309[esp+44]
	test	eax, eax
	jne	SHORT $LN1549@operator@413
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1318@operator@413:
	mov	ecx, DWORD PTR _h$126309[esp+48]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN1309@operator@413
	call	__invalid_parameter_noinfo
$LN1309@operator@413:
	add	DWORD PTR _h$126309[esp+48], 24		; 00000018H
	mov	edi, DWORD PTR _h$126309[esp+48]
	mov	ebx, DWORD PTR _h$126309[esp+44]
	jmp	$LL1311@operator@413
$LN1549@operator@413:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1318@operator@413
$LN22@operator@413:

; 289  : 		}
; 290  : 	}
; 291  : 	os << "----Cache Hit/Miss Counts----" << endl << hits << " " << misses << endl;

	mov	edi, DWORD PTR _os$[esp+40]
	push	OFFSET ??_C@_0BO@DIGAELIB@?9?9?9?9Cache?5Hit?1Miss?5Counts?9?9?9?9?$AA@
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	edx, DWORD PTR _misses$[esp+48]
	mov	eax, DWORD PTR _misses$[esp+44]
	push	edx
	mov	edx, DWORD PTR _hits$[esp+48]
	push	eax
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	ecx
	mov	ecx, DWORD PTR _hits$[esp+64]
	push	ecx
	push	edx
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_K@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 292  : 
; 293  : 	os << "----Utilization----" << endl;

	push	OFFSET ??_C@_0BE@JGDENAHI@?9?9?9?9Utilization?9?9?9?9?$AA@
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 294  : 	for (unsigned i = 0; i < statsLog.channels; i++)

	cmp	DWORD PTR [ebp], 0
	mov	DWORD PTR _i$126457[esp+40], 0
	jbe	$LN16@operator@413
	npad	10
$LL18@operator@413:

; 295  : 	{
; 296  : 		for (unsigned j = 0; j < statsLog.ranks; j++)

	xor	ebx, ebx
	cmp	DWORD PTR [ebp+4], ebx
	jbe	$LN17@operator@413
	npad	5
$LL15@operator@413:

; 297  : 		{
; 298  : 			for (unsigned k = 0; k < statsLog.banks; k++)

	xor	edi, edi
	cmp	DWORD PTR [ebp+8], edi
	jbe	$LN14@operator@413
	npad	5
$LL12@operator@413:

; 299  : 			{
; 300  : 				os << "(" << i << "," << j << "," << k << ") " << statsLog.aggregateBankUtilization[i * statsLog.ranks * statsLog.banks + j * statsLog.banks + k] << endl;

	mov	esi, DWORD PTR [ebp+4]
	imul	esi, DWORD PTR _i$126457[esp+40]
	mov	eax, DWORD PTR [ebp+548]
	sub	eax, DWORD PTR [ebp+544]
	add	esi, ebx
	imul	esi, DWORD PTR [ebp+8]
	add	esi, edi
	sar	eax, 2
	cmp	esi, eax
	jb	SHORT $LN1493@operator@413
	call	__invalid_parameter_noinfo
$LN1493@operator@413:
	mov	ecx, DWORD PTR [ebp+544]
	mov	edx, DWORD PTR [ecx+esi*4]
	push	edx
	push	ecx
	push	OFFSET ??_C@_02KCKGHPCA@?$CJ?5?$AA@
	lea	eax, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR _i$126457[esp+52]
	push	ecx
	push	edi
	push	ecx
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	push	ebx
	push	ecx
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _os$[esp+96]
	push	OFFSET ??_C@_01ODHLEDKK@?$CI?$AA@
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	inc	edi
	cmp	edi, DWORD PTR [ebp+8]
	jb	$LL12@operator@413
$LN14@operator@413:

; 295  : 	{
; 296  : 		for (unsigned j = 0; j < statsLog.ranks; j++)

	inc	ebx
	cmp	ebx, DWORD PTR [ebp+4]
	jb	$LL15@operator@413
$LN17@operator@413:

; 294  : 	for (unsigned i = 0; i < statsLog.channels; i++)

	mov	eax, DWORD PTR _i$126457[esp+40]
	inc	eax
	mov	DWORD PTR _i$126457[esp+40], eax
	cmp	eax, DWORD PTR [ebp]
	jb	$LL18@operator@413
$LN16@operator@413:

; 301  : 			}
; 302  : 		}
; 303  : 	}
; 304  : 
; 305  : 	os << "----Latency Breakdown----" << endl;

	mov	edx, DWORD PTR _os$[esp+40]
	push	OFFSET ??_C@_0BK@JBNJPPAB@?9?9?9?9Latency?5Breakdown?9?9?9?9?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 306  : 	for (unsigned i = 0; i < statsLog.channels; i++)

	cmp	DWORD PTR [ebp], 0
	mov	DWORD PTR _i$126481[esp+40], 0
	jbe	$LN7@operator@413
	npad	2
$LL9@operator@413:

; 307  : 	{
; 308  : 		for (unsigned j = 0; j < statsLog.ranks; j++)

	xor	ebx, ebx
	cmp	DWORD PTR [ebp+4], ebx
	jbe	$LN8@operator@413
	npad	5
$LL6@operator@413:

; 309  : 		{
; 310  : 			for (unsigned k = 0; k < statsLog.banks; k++)

	xor	edi, edi
	cmp	DWORD PTR [ebp+8], edi
	jbe	$LN5@operator@413
	npad	5
$LL3@operator@413:

; 311  : 			{
; 312  : 				os << "(" << i << "," << j << "," << k << ") " << statsLog.bankLatencyUtilization[i * statsLog.ranks * statsLog.banks + j * statsLog.banks + k] << endl;

	mov	esi, DWORD PTR [ebp+4]
	imul	esi, DWORD PTR _i$126481[esp+40]
	mov	eax, DWORD PTR [ebp+572]
	sub	eax, DWORD PTR [ebp+568]
	add	esi, ebx
	imul	esi, DWORD PTR [ebp+8]
	add	esi, edi
	sar	eax, 3
	cmp	esi, eax
	jb	SHORT $LN1506@operator@413
	call	__invalid_parameter_noinfo
$LN1506@operator@413:
	mov	ecx, DWORD PTR [ebp+568]
	mov	edx, DWORD PTR [ecx+esi*8+4]
	push	edx
	lea	eax, DWORD PTR [ecx+esi*8]
	mov	eax, DWORD PTR [eax]
	push	eax
	push	OFFSET ??_C@_02KCKGHPCA@?$CJ?5?$AA@
	push	ecx
	mov	edx, DWORD PTR _os$[esp+56]
	push	edi
	push	ecx
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	push	ebx
	push	ecx
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	mov	ecx, DWORD PTR _i$126481[esp+88]
	push	ecx
	push	ecx
	push	OFFSET ??_C@_01ODHLEDKK@?$CI?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	inc	edi
	cmp	edi, DWORD PTR [ebp+8]
	jb	$LL3@operator@413
$LN5@operator@413:

; 307  : 	{
; 308  : 		for (unsigned j = 0; j < statsLog.ranks; j++)

	inc	ebx
	cmp	ebx, DWORD PTR [ebp+4]
	jb	$LL6@operator@413
$LN8@operator@413:

; 306  : 	for (unsigned i = 0; i < statsLog.channels; i++)

	mov	eax, DWORD PTR _i$126481[esp+40]
	inc	eax
	mov	DWORD PTR _i$126481[esp+40], eax
	cmp	eax, DWORD PTR [ebp]
	jb	$LL9@operator@413
$LN7@operator@413:

; 313  : 			}
; 314  : 		}
; 315  : 	}
; 316  : 
; 317  : 	os << "----tFAW Limited Commands----" << endl << statsLog.issuedAtTFAW << endl;

	mov	edi, DWORD PTR _os$[esp+40]
	push	OFFSET ??_C@_0BO@EIIIOAJG@?9?9?9?9tFAW?5Limited?5Commands?9?9?9?9?$AA@
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	eax, DWORD PTR [ebp+104]
	push	eax
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 318  : #ifdef M5
; 319  : 
; 320  : 	using Stats::Info;
; 321  : 	std::list<Info *>::const_iterator i = Stats::statsList().begin();
; 322  : 	std::list<Info *>::const_iterator end = Stats::statsList().end();
; 323  : 
; 324  : 	for (;i != end;++i)
; 325  : 	{
; 326  : 		Info *info = *i;
; 327  : 		if (info->name.find("ipc_total") != string::npos)
; 328  : 		{
; 329  : 			os << "----IPC----" << endl;
; 330  : 			std::vector<Stats::Result>::const_iterator start = ((Stats::FormulaInfoProxy<Stats::Formula> *)info)->result().begin();
; 331  : 			std::vector<Stats::Result>::const_iterator end = ((Stats::FormulaInfoProxy<Stats::Formula> *)info)->result().end();
; 332  : 			while (start != end)
; 333  : 			{
; 334  : 				os << *start << endl;
; 335  : 				start++;
; 336  : 				// only considering single-threaded for now
; 337  : 				//break;
; 338  : 			}
; 339  : 		}
; 340  : 		if ((info->name.find("dcache.overall_hits") != string::npos) ||
; 341  : 			(info->name.find("dcache.overall_misses") != string::npos) ||
; 342  : 			(info->name.find("dcache.overall_miss_latency") != string::npos) ||
; 343  : 			(info->name.find("icache.overall_hits") != string::npos) ||
; 344  : 			(info->name.find("icache.overall_misses") != string::npos) ||
; 345  : 			(info->name.find("icache.overall_miss_latency") != string::npos) ||
; 346  : 			(info->name.find("l2.overall_hits") != string::npos) ||
; 347  : 			(info->name.find("l2.overall_misses") != string::npos) ||
; 348  : 			(info->name.find("l2.overall_mshr_hits") != string::npos) ||
; 349  : 			(info->name.find("l2.overall_mshr_misses") != string::npos) ||
; 350  : 			(info->name.find("l2.overall_mshr_miss_latency") != string::npos) ||
; 351  : 			(info->name.find("l2.overall_miss_latency") != string::npos))
; 352  : 		{
; 353  : 			{
; 354  : 				os << "----M5 Stat: " << info->name << " ";
; 355  : 
; 356  : 				std::vector<Stats::Result>::const_iterator start = ((Stats::FormulaInfoProxy<Stats::Formula> *)info)->result().begin();
; 357  : 				std::vector<Stats::Result>::const_iterator end = ((Stats::FormulaInfoProxy<Stats::Formula> *)info)->result().end();
; 358  : 				while (start != end)
; 359  : 				{
; 360  : 					os << *start << " ";
; 361  : 					start++;
; 362  : 				}
; 363  : 				os << endl;
; 364  : 			}
; 365  : 		}		
; 366  : 	}		
; 367  : #endif
; 368  : 
; 369  : 	return os;

	mov	eax, edi

; 370  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVStatistics@0@@Z ENDP ; DRAMsimII::operator<<
END
