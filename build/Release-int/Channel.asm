; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\CriuS\Documents\Visual Studio 2008\Projects\DRAMsimIIhg\src\Channel.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@ ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8 ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8 ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8 ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@8 ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > `RTTI Type Descriptor'
PUBLIC	??_R4thread_data_base@detail@boost@@6B@		; boost::detail::thread_data_base::`RTTI Complete Object Locator'
PUBLIC	??_R3thread_data_base@detail@boost@@8		; boost::detail::thread_data_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2thread_data_base@detail@boost@@8		; boost::detail::thread_data_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@thread_data_base@detail@boost@@8	; boost::detail::thread_data_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUthread_data_base@detail@boost@@@8	; boost::detail::thread_data_base `RTTI Type Descriptor'
PUBLIC	??_R4thread_resource_error@boost@@6B@		; boost::thread_resource_error::`RTTI Complete Object Locator'
PUBLIC	??_R3thread_resource_error@boost@@8		; boost::thread_resource_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2thread_resource_error@boost@@8		; boost::thread_resource_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@thread_resource_error@boost@@8	; boost::thread_resource_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4thread_exception@boost@@6B@		; boost::thread_exception::`RTTI Complete Object Locator'
PUBLIC	??_R3thread_exception@boost@@8			; boost::thread_exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2thread_exception@boost@@8			; boost::thread_exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@thread_exception@boost@@8		; boost::thread_exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4DRAMsimWSSoapHttp@@6B@			; DRAMsimWSSoapHttp::`RTTI Complete Object Locator'
PUBLIC	??_R3DRAMsimWSSoapHttp@@8			; DRAMsimWSSoapHttp::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DRAMsimWSSoapHttp@@8			; DRAMsimWSSoapHttp::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DRAMsimWSSoapHttp@@8		; DRAMsimWSSoapHttp::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVDRAMsimWSSoapHttp@@@8			; DRAMsimWSSoapHttp `RTTI Type Descriptor'
PUBLIC	??_R4_ns2__submitEpochResultResponseElement@@6B@ ; _ns2__submitEpochResultResponseElement::`RTTI Complete Object Locator'
PUBLIC	??_R3_ns2__submitEpochResultResponseElement@@8	; _ns2__submitEpochResultResponseElement::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_ns2__submitEpochResultResponseElement@@8	; _ns2__submitEpochResultResponseElement::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_ns2__submitEpochResultResponseElement@@8 ; _ns2__submitEpochResultResponseElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_ns2__submitEpochResultResponseElement@@@8 ; _ns2__submitEpochResultResponseElement `RTTI Type Descriptor'
PUBLIC	??_R4_ns2__submitEpochResultElement@@6B@	; _ns2__submitEpochResultElement::`RTTI Complete Object Locator'
PUBLIC	??_R3_ns2__submitEpochResultElement@@8		; _ns2__submitEpochResultElement::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_ns2__submitEpochResultElement@@8		; _ns2__submitEpochResultElement::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_ns2__submitEpochResultElement@@8	; _ns2__submitEpochResultElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_ns2__submitEpochResultElement@@@8	; _ns2__submitEpochResultElement `RTTI Type Descriptor'
PUBLIC	?moveToTime@Channel@DRAMsimII@@UAEX_J@Z		; DRAMsimII::Channel::moveToTime
PUBLIC	?nextTick@Channel@DRAMsimII@@UBE_JXZ		; DRAMsimII::Channel::nextTick
PUBLIC	?earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z ; DRAMsimII::Channel::earliestExecuteTimeLog
PUBLIC	?earliestExecuteTime@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z ; DRAMsimII::Channel::earliestExecuteTime
PUBLIC	?minProtocolGap@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z ; DRAMsimII::Channel::minProtocolGap
PUBLIC	?readNextCommand@Channel@DRAMsimII@@MBEPBVCommand@2@XZ ; DRAMsimII::Channel::readNextCommand
PUBLIC	??_R4Channel@DRAMsimII@@6B@			; DRAMsimII::Channel::`RTTI Complete Object Locator'
PUBLIC	??_R3Channel@DRAMsimII@@8			; DRAMsimII::Channel::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Channel@DRAMsimII@@8			; DRAMsimII::Channel::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Channel@DRAMsimII@@8		; DRAMsimII::Channel::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVChannel@DRAMsimII@@@8			; DRAMsimII::Channel `RTTI Type Descriptor'
PUBLIC	??_R4Event@DRAMsimII@@6B@			; DRAMsimII::Event::`RTTI Complete Object Locator'
PUBLIC	??_R3Event@DRAMsimII@@8				; DRAMsimII::Event::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Event@DRAMsimII@@8				; DRAMsimII::Event::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Event@DRAMsimII@@8		; DRAMsimII::Event::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVEvent@DRAMsimII@@@8			; DRAMsimII::Event `RTTI Type Descriptor'
PUBLIC	??_C@_0BO@FBMBEAKI@http?3?1?1DRAMsimReporter?1types?1?$AA@ ; `string'
PUBLIC	??_C@_03LOIFCCKL@ns2?$AA@			; `string'
PUBLIC	??_C@_0BI@BIJMMJIB@http?3?1?1DRAMsimReporter?1?$AA@ ; `string'
PUBLIC	??_C@_03JFKIHBGI@ns1?$AA@			; `string'
PUBLIC	??_C@_0BO@GGEJJCPG@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?$AA@ ; `string'
PUBLIC	??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchema@ ; `string'
PUBLIC	??_C@_03CHBGNADK@xsd?$AA@			; `string'
PUBLIC	??_C@_0CH@GIPGGJFA@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?9in@ ; `string'
PUBLIC	??_C@_0CK@FAJBIKFJ@http?3?1?1www?4w3?4org?12001?1XMLSchema@ ; `string'
PUBLIC	??_C@_03JCLIKOHH@xsi?$AA@			; `string'
PUBLIC	??_C@_0CC@BEGEDPPO@http?3?1?1www?4w3?4org?1?$CK?1soap?9encodin@ ; `string'
PUBLIC	??_C@_0CK@OLCGFEIF@http?3?1?1schemas?4xmlsoap?4org?1soap?1@ ; `string'
PUBLIC	??_C@_08HIKNMPCP@SOAP?9ENC?$AA@			; `string'
PUBLIC	??_C@_0CC@LBIMFHBE@http?3?1?1www?4w3?4org?1?$CK?1soap?9envelop@ ; `string'
PUBLIC	??_C@_0CK@KLFMLHIL@http?3?1?1schemas?4xmlsoap?4org?1soap?1@ ; `string'
PUBLIC	??_C@_08EPBICJDL@SOAP?9ENV?$AA@			; `string'
PUBLIC	?setRankID@Rank@DRAMsimII@@QAEXI@Z		; DRAMsimII::Rank::setRankID
PUBLIC	??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
PUBLIC	??0?$allocator@_J@std@@QAE@XZ			; std::allocator<__int64>::allocator<__int64>
PUBLIC	??$_Iter_cat@PA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J@Z ; std::_Iter_cat<__int64 *>
PUBLIC	??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<__int64 *,unsigned int,__int64>
PUBLIC	??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<__int64 *,unsigned int,__int64>
PUBLIC	??$unchecked_fill_n@PA_JI_J@stdext@@YAXPA_JIAB_J@Z ; stdext::unchecked_fill_n<__int64 *,unsigned int,__int64>
PUBLIC	??$_Uninit_fill_n@PA_JI_JV?$allocator@_J@std@@@std@@YAXPA_JIAB_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<__int64 *,unsigned int,__int64,std::allocator<__int64> >
PUBLIC	??$unchecked_uninitialized_fill_n@PA_JI_JV?$allocator@_J@std@@@stdext@@YAXPA_JIAB_JAAV?$allocator@_J@std@@@Z ; stdext::unchecked_uninitialized_fill_n<__int64 *,unsigned int,__int64,std::allocator<__int64> >
PUBLIC	?_Ufill@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_JIAB_J@Z ; std::vector<__int64,std::allocator<__int64> >::_Ufill
PUBLIC	?_Construct_n@?$vector@_JV?$allocator@_J@std@@@std@@QAEXIAB_J@Z ; std::vector<__int64,std::allocator<__int64> >::_Construct_n
PUBLIC	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@AAPAVRank@DRAMsimII@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,DRAMsimII::Rank *>
PUBLIC	??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Rank const *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@2@@stdext@@YAPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@1@0PAV23@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
PUBLIC	??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@XZ ; std::allocator<DRAMsimII::Transaction *>::allocator<DRAMsimII::Transaction *>
PUBLIC	??$?0PAVTransaction@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVTransaction@DRAMsimII@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Transaction *>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@ABV01@@Z ; std::allocator<DRAMsimII::Transaction *>::allocator<DRAMsimII::Transaction *>
PUBLIC	??0?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z ; std::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	?_Buy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE_NI@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Buy
PUBLIC	?_Construct_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIABQAVTransaction@DRAMsimII@@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Construct_n
PUBLIC	??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	?_Checked_iterator_base@?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEPAPAVTransaction@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> > >
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@PAPAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@2@@stdext@@YAPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@4@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??$_Umove@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@1@0PAPAV23@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> > >
PUBLIC	?reserve@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::reserve
PUBLIC	??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
PUBLIC	??0?$allocator@_J@std@@QAE@ABV01@@Z		; std::allocator<__int64>::allocator<__int64>
PUBLIC	??$?0_J@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_J@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><__int64>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<__int64> >::_Container_base_aux_alloc_real<std::allocator<__int64> >
PUBLIC	??0?$_Vector_val@_JV?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z ; std::_Vector_val<__int64,std::allocator<__int64> >::_Vector_val<__int64,std::allocator<__int64> >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@AAPA_J@Z ; std::_Ptr_cat<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 *>
PUBLIC	??$_Uninit_copy@PB_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPB_J0PA_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<__int64 const *,__int64 *,std::allocator<__int64> >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 *,std::allocator<__int64> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
PUBLIC	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
PUBLIC	??0?$allocator@VRank@DRAMsimII@@@std@@QAE@XZ	; std::allocator<DRAMsimII::Rank>::allocator<DRAMsimII::Rank>
PUBLIC	??$?0VRank@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VRank@DRAMsimII@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Rank>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >
PUBLIC	??0?$allocator@VRank@DRAMsimII@@@std@@QAE@ABV01@@Z ; std::allocator<DRAMsimII::Rank>::allocator<DRAMsimII::Rank>
PUBLIC	??0?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z ; std::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	?_Ufill@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV34@IABV34@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ufill
PUBLIC	?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Construct_n
PUBLIC	??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??0?$allocator@U?$pair@I_J@std@@@std@@QAE@XZ	; std::allocator<std::pair<unsigned int,__int64> >::allocator<std::pair<unsigned int,__int64> >
PUBLIC	??$?0U?$pair@I_J@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int,__int64> >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	??0?$allocator@U?$pair@I_J@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int,__int64> >::allocator<std::pair<unsigned int,__int64> >
PUBLIC	??$?0U?$pair@I_J@std@@@?$allocator@PAU?$pair@I_J@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z ; std::allocator<std::pair<unsigned int,__int64> *>::allocator<std::pair<unsigned int,__int64> *><std::pair<unsigned int,__int64> >
PUBLIC	??0?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z ; std::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	??0?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z ; std::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	??0?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	??0?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??1?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	?_Tidy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Tidy
PUBLIC	??1?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	?pop@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::pop
PUBLIC	??E?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++
PUBLIC	??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++
PUBLIC	??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++
PUBLIC	??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<__int64> >::~_Container_base_aux_alloc_real<std::allocator<__int64> >
PUBLIC	??1?$_Vector_val@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::_Vector_val<__int64,std::allocator<__int64> >::~_Vector_val<__int64,std::allocator<__int64> >
PUBLIC	?_Tidy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXXZ ; std::vector<__int64,std::allocator<__int64> >::_Tidy
PUBLIC	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ	; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >
PUBLIC	??1?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	?_Tidy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Tidy
PUBLIC	??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	??1?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ; std::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	??1?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ; std::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	?deallocate@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@I@Z ; std::allocator<std::pair<unsigned int,__int64> >::deallocate
PUBLIC	??$_Destroy@PAU?$pair@I_J@std@@@std@@YAXPAPAU?$pair@I_J@0@@Z ; std::_Destroy<std::pair<unsigned int,__int64> *>
PUBLIC	?destroy@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@@Z ; std::allocator<std::pair<unsigned int,__int64> *>::destroy
PUBLIC	?pop_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::pop_back
PUBLIC	?_Tidy@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Tidy
PUBLIC	??1?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
PUBLIC	??1?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::~queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >
PUBLIC	??_GChannel@DRAMsimII@@UAEPAXI@Z		; DRAMsimII::Channel::`scalar deleting destructor'
PUBLIC	?getArrivalTime@Event@DRAMsimII@@QBE_JXZ	; DRAMsimII::Event::getArrivalTime
PUBLIC	?size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::size
PUBLIC	?size@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QBEIXZ ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::size
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@I_J@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@U?$pair@I_J@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Ranit<std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &>::_Ranit<std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &>
PUBLIC	??0?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>
PUBLIC	??0?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>
PUBLIC	?begin@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE?AV?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@2@XZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::begin
PUBLIC	??D?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEABU?$pair@I_J@1@XZ ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*
PUBLIC	??D?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEAAU?$pair@I_J@1@XZ ; std::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*
PUBLIC	?front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEAAU?$pair@I_J@2@XZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::front
PUBLIC	?front@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEAAU?$pair@I_J@2@XZ ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::front
PUBLIC	??$_Destroy@U?$pair@I_J@std@@@std@@YAXPAU?$pair@I_J@0@@Z ; std::_Destroy<std::pair<unsigned int,__int64> >
PUBLIC	?destroy@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@@Z ; std::allocator<std::pair<unsigned int,__int64> >::destroy
PUBLIC	?empty@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBE_NXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::empty
PUBLIC	?pop_front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::pop_front
PUBLIC	?pop@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXXZ ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::pop
PUBLIC	??$_Min_element@PB_J@std@@YAPB_JPB_J0@Z		; std::_Min_element<__int64 const *>
PUBLIC	?_Checked_iterator_assign_from_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEXPB_J@Z ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_assign_from_base
PUBLIC	??$_Checked_assign_from_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PB_J@std@@YAXAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@ABQB_J@Z ; std::_Checked_assign_from_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 const *>
PUBLIC	??$min_element@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@V10@0@Z ; std::min_element<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
PUBLIC	?getOriginalTransaction@Transaction@DRAMsimII@@QBEIXZ ; DRAMsimII::Transaction::getOriginalTransaction
PUBLIC	?removeHost@Command@DRAMsimII@@QAEPAVTransaction@2@XZ ; DRAMsimII::Command::removeHost
PUBLIC	??0?$pair@I_J@std@@QAE@ABIAB_J@Z		; std::pair<unsigned int,__int64>::pair<unsigned int,__int64>
PUBLIC	??$_Allocate@U?$pair@I_J@std@@@std@@YAPAU?$pair@I_J@0@IPAU10@@Z ; std::_Allocate<std::pair<unsigned int,__int64> >
PUBLIC	?allocate@?$allocator@U?$pair@I_J@std@@@std@@QAEPAU?$pair@I_J@2@I@Z ; std::allocator<std::pair<unsigned int,__int64> >::allocate
PUBLIC	??$_Construct@U?$pair@I_J@std@@U12@@std@@YAXPAU?$pair@I_J@0@ABU10@@Z ; std::_Construct<std::pair<unsigned int,__int64>,std::pair<unsigned int,__int64> >
PUBLIC	?construct@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@ABU32@@Z ; std::allocator<std::pair<unsigned int,__int64> >::construct
PUBLIC	?deallocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@I@Z ; std::allocator<std::pair<unsigned int,__int64> *>::deallocate
PUBLIC	??$_Allocate@PAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@IPAPAU10@@Z ; std::_Allocate<std::pair<unsigned int,__int64> *>
PUBLIC	?allocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEPAPAU?$pair@I_J@2@I@Z ; std::allocator<std::pair<unsigned int,__int64> *>::allocate
PUBLIC	?max_size@?$allocator@U?$pair@I_J@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int,__int64> >::max_size
PUBLIC	?max_size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::max_size
PUBLIC	?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Xlen
PUBLIC	??$_Uninit_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAPAPAU?$pair@I_J@0@PAPAU10@00AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *,std::allocator<std::pair<unsigned int,__int64> *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAPAPAU?$pair@I_J@std@@PAPAU12@00AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *,std::allocator<std::pair<unsigned int,__int64> *> >
PUBLIC	??$_Iter_cat@PAPAU?$pair@I_J@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAU?$pair@I_J@0@@Z ; std::_Iter_cat<std::pair<unsigned int,__int64> * *>
PUBLIC	??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::pair<unsigned int,__int64> * *>
PUBLIC	??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@@Z ; std::_Checked_base<std::pair<unsigned int,__int64> * *>
PUBLIC	??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>
PUBLIC	??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>
PUBLIC	??$unchecked_fill_n@PAPAU?$pair@I_J@std@@IPAU12@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@@Z ; stdext::unchecked_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>
PUBLIC	??$_Uninit_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *,std::allocator<std::pair<unsigned int,__int64> *> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *,std::allocator<std::pair<unsigned int,__int64> *> >
PUBLIC	??$_Ptr_cat@PAPAU?$pair@I_J@std@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAU?$pair@I_J@0@0@Z ; std::_Ptr_cat<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *>
PUBLIC	??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::pair<unsigned int,__int64> *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<unsigned int,__int64> *> >
PUBLIC	?_Growmap@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXI@Z ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Growmap
PUBLIC	?push_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXABU?$pair@I_J@2@@Z ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::push_back
PUBLIC	?push@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXABU?$pair@I_J@2@@Z ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::push
PUBLIC	?setEnqueueTime@Event@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Event::setEnqueueTime
PUBLIC	?push@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::push
PUBLIC	?push_front@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::push_front
PUBLIC	?insert@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::insert
PUBLIC	?isFull@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::isFull
PUBLIC	?isRead@Transaction@DRAMsimII@@QBE_NXZ		; DRAMsimII::Transaction::isRead
PUBLIC	?getTransactionOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4TransactionOrderingAlgorithm@2@XZ ; DRAMsimII::SystemConfiguration::getTransactionOrderingAlgorithm
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?accumulateAndResetCounts@Bank@DRAMsimII@@QAEXXZ ; DRAMsimII::Bank::accumulateAndResetCounts
PUBLIC	?getRASCount@Bank@DRAMsimII@@QBEIXZ		; DRAMsimII::Bank::getRASCount
PUBLIC	?getReadCycles@Rank@DRAMsimII@@QBEIXZ		; DRAMsimII::Rank::getReadCycles
PUBLIC	?getWriteCycles@Rank@DRAMsimII@@QBEIXZ		; DRAMsimII::Rank::getWriteCycles
PUBLIC	?resetCycleCounts@Rank@DRAMsimII@@QAEXXZ	; DRAMsimII::Rank::resetCycleCounts
PUBLIC	?getVDDmax@PowerConfig@DRAMsimII@@QBEMXZ	; DRAMsimII::PowerConfig::getVDDmax
PUBLIC	?getLastCalculation@PowerConfig@DRAMsimII@@QBE_JXZ ; DRAMsimII::PowerConfig::getLastCalculation
PUBLIC	?getPdsACT@PowerConfig@DRAMsimII@@QBENXZ	; DRAMsimII::PowerConfig::getPdsACT
PUBLIC	?getPdsRD@PowerConfig@DRAMsimII@@QBENXZ		; DRAMsimII::PowerConfig::getPdsRD
PUBLIC	?getPdsWR@PowerConfig@DRAMsimII@@QBENXZ		; DRAMsimII::PowerConfig::getPdsWR
PUBLIC	?gettRC@PowerConfig@DRAMsimII@@QBEIXZ		; DRAMsimII::PowerConfig::gettRC
PUBLIC	?getDevicesPerRank@PowerConfig@DRAMsimII@@QBEIXZ ; DRAMsimII::PowerConfig::getDevicesPerRank
PUBLIC	?getIDD2N@PowerConfig@DRAMsimII@@QBEHXZ		; DRAMsimII::PowerConfig::getIDD2N
PUBLIC	?getIDD2P@PowerConfig@DRAMsimII@@QBEHXZ		; DRAMsimII::PowerConfig::getIDD2P
PUBLIC	?getIDD3N@PowerConfig@DRAMsimII@@QBEHXZ		; DRAMsimII::PowerConfig::getIDD3N
PUBLIC	?getIDD3P@PowerConfig@DRAMsimII@@QBEHXZ		; DRAMsimII::PowerConfig::getIDD3P
PUBLIC	?getVoltageScaleFactor@PowerConfig@DRAMsimII@@QBENXZ ; DRAMsimII::PowerConfig::getVoltageScaleFactor
PUBLIC	?getFrequencyScaleFactor@PowerConfig@DRAMsimII@@QBENXZ ; DRAMsimII::PowerConfig::getFrequencyScaleFactor
PUBLIC	?setLastCalculation@PowerConfig@DRAMsimII@@QAEX_J@Z ; DRAMsimII::PowerConfig::setLastCalculation
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	??0?$allocator@N@std@@QAE@XZ			; std::allocator<double>::allocator<double>
PUBLIC	??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ	; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
PUBLIC	?end@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ ; std::vector<double,std::allocator<double> >::end
PUBLIC	??0?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<double,std::allocator<double> >::_Vector_iterator<double,std::allocator<double> >
PUBLIC	?begin@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ ; std::vector<double,std::allocator<double> >::begin
PUBLIC	?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ; std::vector<double,std::allocator<double> >::capacity
PUBLIC	??$_Uninit_copy@PANPANV?$allocator@N@std@@@std@@YAPANPAN00AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<double *,double *,std::allocator<double> >
PUBLIC	??$unchecked_uninitialized_copy@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z ; stdext::unchecked_uninitialized_copy<double *,double *,std::allocator<double> >
PUBLIC	??$_Uninit_move@PANPANV?$allocator@N@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00AAV?$allocator@N@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<double *,double *,std::allocator<double>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z ; stdext::_Unchecked_uninitialized_move<double *,double *,std::allocator<double> >
PUBLIC	??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z ; std::vector<double,std::allocator<double> >::_Umove<double *>
PUBLIC	??$_Fill@PANN@std@@YAXPAN0ABN@Z			; std::_Fill<double *,double>
PUBLIC	??$fill@PANN@std@@YAXPAN0ABN@Z			; std::fill<double *,double>
PUBLIC	??$_Iter_random@PANPAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN0@Z ; std::_Iter_random<double *,double *>
PUBLIC	??$_Move_cat@PAN@std@@YA?AU_Undefined_move_tag@0@ABQAN@Z ; std::_Move_cat<double *>
PUBLIC	??$_Copy_backward_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<double *,double *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PANPANUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<double *,double *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PANPAN@stdext@@YAPANPAN00@Z ; stdext::_Unchecked_move_backward<double *,double *>
PUBLIC	?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z ; std::vector<double,std::allocator<double> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<double,std::allocator<double> >::operator-
PUBLIC	??Y?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<double,std::allocator<double> >::operator+=
PUBLIC	??Y?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<double,std::allocator<double> >::operator+=
PUBLIC	??H?$_Vector_iterator@NV?$allocator@N@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<double,std::allocator<double> >::operator+
PUBLIC	?insert@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@ABN@Z ; std::vector<double,std::allocator<double> >::insert
PUBLIC	??$_Iter_cat@PAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN@Z ; std::_Iter_cat<double *>
PUBLIC	??$_Checked_base@PAN@std@@YAPANAAPANU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<double *>
PUBLIC	??$_Checked_base@PAN@std@@YAPANAAPAN@Z		; std::_Checked_base<double *>
PUBLIC	??$_Fill_n@PANIN@std@@YAXPANIABNU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<double *,unsigned int,double>
PUBLIC	??$_Fill_n@PANIN@std@@YAXPANIABNUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<double *,unsigned int,double>
PUBLIC	??$unchecked_fill_n@PANIN@stdext@@YAXPANIABN@Z	; stdext::unchecked_fill_n<double *,unsigned int,double>
PUBLIC	??$_Uninit_fill_n@PANINV?$allocator@N@std@@@std@@YAXPANIABNAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<double *,unsigned int,double,std::allocator<double> >
PUBLIC	??$unchecked_uninitialized_fill_n@PANINV?$allocator@N@std@@@stdext@@YAXPANIABNAAV?$allocator@N@std@@@Z ; stdext::unchecked_uninitialized_fill_n<double *,unsigned int,double,std::allocator<double> >
PUBLIC	?_Ufill@?$vector@NV?$allocator@N@std@@@std@@IAEPANPANIABN@Z ; std::vector<double,std::allocator<double> >::_Ufill
PUBLIC	?push_back@?$vector@NV?$allocator@N@std@@@std@@QAEXABN@Z ; std::vector<double,std::allocator<double> >::push_back
PUBLIC	??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@ABV?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@12@@Z ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >
PUBLIC	??0?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QAE@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@Z@Z ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
PUBLIC	??0?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAE@ABQAVChannel@DRAMsimII@@@Z ; boost::_bi::value<DRAMsimII::Channel *>::value<DRAMsimII::Channel *>
PUBLIC	??0?$value@N@_bi@boost@@QAE@ABN@Z		; boost::_bi::value<double>::value<double>
PUBLIC	??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; boost::_bi::value<std::vector<int,std::allocator<int> > >::value<std::vector<int,std::allocator<int> > >
PUBLIC	??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV?$vector@NV?$allocator@N@std@@@std@@@Z ; boost::_bi::value<std::vector<double,std::allocator<double> > >::value<std::vector<double,std::allocator<double> > >
PUBLIC	??0?$value@_J@_bi@boost@@QAE@AB_J@Z		; boost::_bi::value<__int64>::value<__int64>
PUBLIC	??0?$storage1@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@@Z ; boost::_bi::storage1<boost::_bi::value<DRAMsimII::Channel *> >::storage1<boost::_bi::value<DRAMsimII::Channel *> >
PUBLIC	??0?$storage2@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@@Z ; boost::_bi::storage2<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double> >::storage2<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double> >
PUBLIC	??0?$storage3@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1@Z ; boost::_bi::storage3<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double> >::storage3<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double> >
PUBLIC	??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >
PUBLIC	??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
PUBLIC	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
PUBLIC	??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
PUBLIC	??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
PUBLIC	??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z ; boost::bind<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64,DRAMsimII::Channel *,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
PUBLIC	??0noncopyable@noncopyable_@boost@@IAE@XZ	; boost::noncopyable_::noncopyable::noncopyable
PUBLIC	?initialize@basic_timed_mutex@detail@boost@@QAEXXZ ; boost::detail::basic_timed_mutex::initialize
PUBLIC	??0mutex@boost@@QAE@XZ				; boost::mutex::mutex
PUBLIC	??1noncopyable@noncopyable_@boost@@IAE@XZ	; boost::noncopyable_::noncopyable::~noncopyable
PUBLIC	?destroy@basic_timed_mutex@detail@boost@@QAEXXZ	; boost::detail::basic_timed_mutex::destroy
PUBLIC	??1mutex@boost@@QAE@XZ				; boost::mutex::~mutex
PUBLIC	?intrusive_ptr_add_ref@@YAXPAUthread_data_base@detail@boost@@@Z ; intrusive_ptr_add_ref
PUBLIC	??0?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@PAUthread_data_base@detail@1@_N@Z ; boost::intrusive_ptr<boost::detail::thread_data_base>::intrusive_ptr<boost::detail::thread_data_base>
PUBLIC	??$heap_delete@Uthread_data_base@detail@boost@@@detail@boost@@YAXPAUthread_data_base@01@@Z ; boost::detail::heap_delete<boost::detail::thread_data_base>
PUBLIC	?intrusive_ptr_release@@YAXPAUthread_data_base@detail@boost@@@Z ; intrusive_ptr_release
PUBLIC	??1?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@XZ ; boost::intrusive_ptr<boost::detail::thread_data_base>::~intrusive_ptr<boost::detail::thread_data_base>
PUBLIC	??0bad_alloc@std@@QAE@XZ			; std::bad_alloc::bad_alloc
PUBLIC	?allocate_raw_heap_memory@detail@boost@@YAPAXI@Z ; boost::detail::allocate_raw_heap_memory
PUBLIC	?free_raw_heap_memory@detail@boost@@YAXPAX@Z	; boost::detail::free_raw_heap_memory
PUBLIC	??_Gthread_resource_error@boost@@UAEPAXI@Z	; boost::thread_resource_error::`scalar deleting destructor'
PUBLIC	??0thread_resource_error@boost@@QAE@ABV01@@Z	; boost::thread_resource_error::thread_resource_error
PUBLIC	??_Gthread_exception@boost@@UAEPAXI@Z		; boost::thread_exception::`scalar deleting destructor'
PUBLIC	??0thread_exception@boost@@QAE@ABV01@@Z		; boost::thread_exception::thread_exception
PUBLIC	?create_anonymous_event@win32@detail@boost@@YAPAXW4event_type@123@W4initial_event_state@123@@Z ; boost::detail::win32::create_anonymous_event
PUBLIC	??0handle_manager@win32@detail@boost@@QAE@PAX@Z	; boost::detail::win32::handle_manager::handle_manager
PUBLIC	??0thread_data_base@detail@boost@@QAE@XZ	; boost::detail::thread_data_base::thread_data_base
PUBLIC	??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV012@@Z ; boost::_bi::value<std::vector<int,std::allocator<int> > >::value<std::vector<int,std::allocator<int> > >
PUBLIC	??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >
PUBLIC	??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV012@@Z ; boost::_bi::value<std::vector<double,std::allocator<double> > >::value<std::vector<double,std::allocator<double> > >
PUBLIC	??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
PUBLIC	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
PUBLIC	??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABU012@@Z ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
PUBLIC	??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABV012@@Z ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
PUBLIC	??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@ABV012@@Z ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >
PUBLIC	??0list0@_bi@boost@@QAE@XZ			; boost::_bi::list0::list0
PUBLIC	?unwrap@?$unwrapper@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@@_bi@boost@@SAAAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@3@AAV453@J@Z ; boost::_bi::unwrapper<boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64> >::unwrap
PUBLIC	?get@?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAEAAPAVChannel@DRAMsimII@@XZ ; boost::_bi::value<DRAMsimII::Channel *>::get
PUBLIC	??$?APAVChannel@DRAMsimII@@@list0@_bi@boost@@QBEAAPAVChannel@DRAMsimII@@AAV?$value@PAVChannel@DRAMsimII@@@12@@Z ; boost::_bi::list0::operator[]<DRAMsimII::Channel *>
PUBLIC	?get@?$value@N@_bi@boost@@QAEAANXZ		; boost::_bi::value<double>::get
PUBLIC	??$?AN@list0@_bi@boost@@QBEAANAAV?$value@N@12@@Z ; boost::_bi::list0::operator[]<double>
PUBLIC	?get@?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@XZ ; boost::_bi::value<std::vector<int,std::allocator<int> > >::get
PUBLIC	??$?AV?$vector@HV?$allocator@H@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@HV?$allocator@H@std@@@std@@AAV?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z ; boost::_bi::list0::operator[]<std::vector<int,std::allocator<int> > >
PUBLIC	?get@?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAEAAV?$vector@NV?$allocator@N@std@@@std@@XZ ; boost::_bi::value<std::vector<double,std::allocator<double> > >::get
PUBLIC	??$?AV?$vector@NV?$allocator@N@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@NV?$allocator@N@std@@@std@@AAV?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z ; boost::_bi::list0::operator[]<std::vector<double,std::allocator<double> > >
PUBLIC	?get@?$value@_J@_bi@boost@@QAEAA_JXZ		; boost::_bi::value<__int64>::get
PUBLIC	??$?A_J@list0@_bi@boost@@QBEAA_JAAV?$value@_J@12@@Z ; boost::_bi::list0::operator[]<__int64>
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEPBHXZ ; std::_Vector_const_iterator<int,std::allocator<int> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<int,std::allocator<int> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<int,std::allocator<int> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@AAPAH@Z ; std::_Ptr_cat<std::_Vector_const_iterator<int,std::allocator<int> >,int *>
PUBLIC	??$_Uninit_copy@PBHPAHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int const *,int *,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<int,std::allocator<int> > >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??$?0N@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@N@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><double>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<double> >::_Container_base_aux_alloc_real<std::allocator<double> >
PUBLIC	??0?$allocator@N@std@@QAE@ABV01@@Z		; std::allocator<double>::allocator<double>
PUBLIC	??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z ; std::_Vector_val<double,std::allocator<double> >::_Vector_val<double,std::allocator<double> >
PUBLIC	?begin@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ ; std::vector<double,std::allocator<double> >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@NHPBNABNV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@NHPBNABN@std@@QAE@XZ		; std::_Ranit<double,int,double const *,double const &>::_Ranit<double,int,double const *,double const &>
PUBLIC	??0?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<double,std::allocator<double> >::_Vector_const_iterator<double,std::allocator<double> >
PUBLIC	?end@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ ; std::vector<double,std::allocator<double> >::end
PUBLIC	??$_Allocate@N@std@@YAPANIPAN@Z			; std::_Allocate<double>
PUBLIC	?allocate@?$allocator@N@std@@QAEPANI@Z		; std::allocator<double>::allocate
PUBLIC	?max_size@?$allocator@N@std@@QBEIXZ		; std::allocator<double>::max_size
PUBLIC	?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ; std::vector<double,std::allocator<double> >::max_size
PUBLIC	?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ ; std::vector<double,std::allocator<double> >::_Xlen
PUBLIC	?_Buy@?$vector@NV?$allocator@N@std@@@std@@IAE_NI@Z ; std::vector<double,std::allocator<double> >::_Buy
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEPBNXZ ; std::_Vector_const_iterator<double,std::allocator<double> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<double,std::allocator<double> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<double,std::allocator<double> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@AAPAN@Z ; std::_Ptr_cat<std::_Vector_const_iterator<double,std::allocator<double> >,double *>
PUBLIC	??$_Uninit_copy@PBNPANV?$allocator@N@std@@@std@@YAPANPBN0PANAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<double const *,double *,std::allocator<double> >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PANV?$allocator@N@2@@stdext@@YAPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@0PANAAV?$allocator@N@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<double,std::allocator<double> >,double *,std::allocator<double> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@?$vector@NV?$allocator@N@std@@@std@@IAEPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@1@0PAN@Z ; std::vector<double,std::allocator<double> >::_Ucopy<std::_Vector_const_iterator<double,std::allocator<double> > >
PUBLIC	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
PUBLIC	??$get_pointer@VChannel@DRAMsimII@@@boost@@YAPAVChannel@DRAMsimII@@PAV12@@Z ; boost::get_pointer<DRAMsimII::Channel>
PUBLIC	??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::call<DRAMsimII::Channel * const,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
PUBLIC	??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::operator()<DRAMsimII::Channel *>
PUBLIC	??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::operator()<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list0>
PUBLIC	??R?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE_NXZ ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::operator()
PUBLIC	?run@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEXXZ ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::run
PUBLIC	?cleanup@handle_manager@win32@detail@boost@@AAEXXZ ; boost::detail::win32::handle_manager::cleanup
PUBLIC	??1handle_manager@win32@detail@boost@@QAE@XZ	; boost::detail::win32::handle_manager::~handle_manager
PUBLIC	??_Gthread_data_base@detail@boost@@UAEPAXI@Z	; boost::detail::thread_data_base::`scalar deleting destructor'
PUBLIC	??1thread_data_base@detail@boost@@UAE@XZ	; boost::detail::thread_data_base::~thread_data_base
PUBLIC	??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ ; boost::_bi::value<std::vector<int,std::allocator<int> > >::~value<std::vector<int,std::allocator<int> > >
PUBLIC	??1?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@XZ ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::~storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >
PUBLIC	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ ; boost::_bi::value<std::vector<double,std::allocator<double> > >::~value<std::vector<double,std::allocator<double> > >
PUBLIC	??1?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@XZ ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::~storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
PUBLIC	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::~storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
PUBLIC	??1?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::~storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
PUBLIC	??1?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::~list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
PUBLIC	??1?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@XZ ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::~bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >
PUBLIC	??1?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAE@XZ ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::~thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
PUBLIC	??_G?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEPAXI@Z ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`scalar deleting destructor'
PUBLIC	??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
PUBLIC	??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ; boost::detail::heap_new_impl<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &>
PUBLIC	??$heap_new@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ; boost::detail::heap_new<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
PUBLIC	??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ; boost::thread::make_thread_info<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
PUBLIC	??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z ; boost::thread::thread<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
PUBLIC	?getSessionID@SystemConfiguration@DRAMsimII@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; DRAMsimII::SystemConfiguration::getSessionID
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@HHPBHABHV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@HHPBHABH@std@@QAE@XZ		; std::_Ranit<int,int,int const *,int const &>::_Ranit<int,int,int const *,int const &>
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
PUBLIC	?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
PUBLIC	??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
PUBLIC	??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
PUBLIC	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
PUBLIC	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
PUBLIC	??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z ; std::_Iter_cat<float *>
PUBLIC	??$_Fill_n@PAMIM@std@@YAXPAMIABMU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<float *,unsigned int,float>
PUBLIC	??$_Fill_n@PAMIM@std@@YAXPAMIABMUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<float *,unsigned int,float>
PUBLIC	??$unchecked_fill_n@PAMIM@stdext@@YAXPAMIABM@Z	; stdext::unchecked_fill_n<float *,unsigned int,float>
PUBLIC	??$_Uninit_fill_n@PAMIMV?$allocator@M@std@@@std@@YAXPAMIABMAAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<float *,unsigned int,float,std::allocator<float> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAMIMV?$allocator@M@std@@@stdext@@YAXPAMIABMAAV?$allocator@M@std@@@Z ; stdext::unchecked_uninitialized_fill_n<float *,unsigned int,float,std::allocator<float> >
PUBLIC	?_Ufill@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAMIABM@Z ; std::vector<float,std::allocator<float> >::_Ufill
PUBLIC	?_Construct_n@?$vector@MV?$allocator@M@std@@@std@@QAEXIABM@Z ; std::vector<float,std::allocator<float> >::_Construct_n
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::capacity
PUBLIC	?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ ; std::vector<float,std::allocator<float> >::begin
PUBLIC	?end@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ ; std::vector<float,std::allocator<float> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@MHPBMABMV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@MHPBMABM@std@@QAE@XZ		; std::_Ranit<float,int,float const *,float const &>::_Ranit<float,int,float const *,float const &>
PUBLIC	??0?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<float,std::allocator<float> >::_Vector_const_iterator<float,std::allocator<float> >
PUBLIC	??0?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<float,std::allocator<float> >::_Vector_iterator<float,std::allocator<float> >
PUBLIC	?_Make_iter@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@@Z ; std::vector<float,std::allocator<float> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<float,std::allocator<float> >::operator==
PUBLIC	??9?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<float,std::allocator<float> >::operator!=
PUBLIC	?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z ; std::vector<float,std::allocator<float> >::erase
PUBLIC	?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ ; std::vector<float,std::allocator<float> >::clear
PUBLIC	??$_Iter_random@PAMPAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM0@Z ; std::_Iter_random<float *,float *>
PUBLIC	??$_Copy_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<float *,float *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAMPAM@stdext@@YAPAMPAM00@Z	; stdext::unchecked_copy<float *,float *>
PUBLIC	??$_Checked_base@PAM@std@@YAPAMAAPAMU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<float *>
PUBLIC	??$_Checked_base@PAM@std@@YAPAMAAPAM@Z		; std::_Checked_base<float *>
PUBLIC	??$_Uninit_copy@PAMPAMV?$allocator@M@std@@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<float *,float *,std::allocator<float> >
PUBLIC	??$unchecked_uninitialized_copy@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z ; stdext::unchecked_uninitialized_copy<float *,float *,std::allocator<float> >
PUBLIC	??$_Ucopy@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ; std::vector<float,std::allocator<float> >::_Ucopy<float *>
PUBLIC	??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<float,std::allocator<float> >::operator=
PUBLIC	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::size
PUBLIC	??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z ; std::vector<float,std::allocator<float> >::operator[]
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0?$allocator@M@std@@QAE@XZ			; std::allocator<float>::allocator<float>
PUBLIC	??$?0M@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@M@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><float>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<float> >::_Container_base_aux_alloc_real<std::allocator<float> >
PUBLIC	??0?$allocator@M@std@@QAE@ABV01@@Z		; std::allocator<float>::allocator<float>
PUBLIC	??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >
PUBLIC	??$_Allocate@M@std@@YAPAMIPAM@Z			; std::_Allocate<float>
PUBLIC	?allocate@?$allocator@M@std@@QAEPAMI@Z		; std::allocator<float>::allocate
PUBLIC	?max_size@?$allocator@M@std@@QBEIXZ		; std::allocator<float>::max_size
PUBLIC	?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::max_size
PUBLIC	?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ; std::vector<float,std::allocator<float> >::_Xlen
PUBLIC	?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z ; std::vector<float,std::allocator<float> >::_Buy
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	??0_ns2__submitEpochResultElement@@QAE@XZ	; _ns2__submitEpochResultElement::_ns2__submitEpochResultElement
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<float> >::~_Container_base_aux_alloc_real<std::allocator<float> >
PUBLIC	??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ ; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >
PUBLIC	?deallocate@?$allocator@M@std@@QAEXPAMI@Z	; std::allocator<float>::deallocate
PUBLIC	??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z ; std::_Ptr_cat<float *,float *>
PUBLIC	??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<float> >
PUBLIC	??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z ; std::_Destroy_range<std::allocator<float> >
PUBLIC	?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ; std::vector<float,std::allocator<float> >::_Destroy
PUBLIC	?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ; std::vector<float,std::allocator<float> >::_Tidy
PUBLIC	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
PUBLIC	?soap_type@_ns2__submitEpochResultElement@@UBEHXZ ; _ns2__submitEpochResultElement::soap_type
PUBLIC	??_G_ns2__submitEpochResultElement@@UAEPAXI@Z	; _ns2__submitEpochResultElement::`scalar deleting destructor'
PUBLIC	??1_ns2__submitEpochResultElement@@UAE@XZ	; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement
PUBLIC	??0_ns2__submitEpochResultResponseElement@@QAE@XZ ; _ns2__submitEpochResultResponseElement::_ns2__submitEpochResultResponseElement
PUBLIC	?soap_type@_ns2__submitEpochResultResponseElement@@UBEHXZ ; _ns2__submitEpochResultResponseElement::soap_type
PUBLIC	??_G_ns2__submitEpochResultResponseElement@@UAEPAXI@Z ; _ns2__submitEpochResultResponseElement::`scalar deleting destructor'
PUBLIC	??1_ns2__submitEpochResultResponseElement@@UAE@XZ ; _ns2__submitEpochResultResponseElement::~_ns2__submitEpochResultResponseElement
PUBLIC	??0DRAMsimWSSoapHttp@@QAE@XZ			; DRAMsimWSSoapHttp::DRAMsimWSSoapHttp
PUBLIC	?__ns1__getSessionID@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSessionIDElement@@PAV_ns2__getSessionIDResponseElement@@@Z ; DRAMsimWSSoapHttp::__ns1__getSessionID
PUBLIC	?__ns1__getSettingsFile@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSettingsFileElement@@PAV_ns2__getSettingsFileResponseElement@@@Z ; DRAMsimWSSoapHttp::__ns1__getSettingsFile
PUBLIC	??_GDRAMsimWSSoapHttp@@UAEPAXI@Z		; DRAMsimWSSoapHttp::`scalar deleting destructor'
PUBLIC	??1DRAMsimWSSoapHttp@@UAE@XZ			; DRAMsimWSSoapHttp::~DRAMsimWSSoapHttp
PUBLIC	?__ns1__submitEpochResult@DRAMsimWSSoapHttp@@UAEHPAV_ns2__submitEpochResultElement@@PAV_ns2__submitEpochResultResponseElement@@@Z ; DRAMsimWSSoapHttp::__ns1__submitEpochResult
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<double> >::~_Container_base_aux_alloc_real<std::allocator<double> >
PUBLIC	??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ ; std::_Vector_val<double,std::allocator<double> >::~_Vector_val<double,std::allocator<double> >
PUBLIC	?deallocate@?$allocator@N@std@@QAEXPANI@Z	; std::allocator<double>::deallocate
PUBLIC	??$_Ptr_cat@PANPAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAN0@Z ; std::_Ptr_cat<double *,double *>
PUBLIC	??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<double> >
PUBLIC	??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z ; std::_Destroy_range<std::allocator<double> >
PUBLIC	?_Destroy@?$vector@NV?$allocator@N@std@@@std@@IAEXPAN0@Z ; std::vector<double,std::allocator<double> >::_Destroy
PUBLIC	?_Tidy@?$vector@NV?$allocator@N@std@@@std@@IAEXXZ ; std::vector<double,std::allocator<double> >::_Tidy
PUBLIC	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
PUBLIC	?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ; std::vector<double,std::allocator<double> >::size
PUBLIC	??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z ; std::vector<double,std::allocator<double> >::operator[]
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	??$?0H@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><int>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<int> >::_Container_base_aux_alloc_real<std::allocator<int> >
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<int> >::~_Container_base_aux_alloc_real<std::allocator<int> >
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	??$_Iter_cat@I@std@@YA?AU_Int_iterator_tag@0@ABI@Z ; std::_Iter_cat<unsigned int>
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
PUBLIC	??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<int *>
PUBLIC	??$_Checked_base@PAH@std@@YAPAHAAPAH@Z		; std::_Checked_base<int *>
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
PUBLIC	?_Construct_n@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z ; std::vector<int,std::allocator<int> >::_Construct_n
PUBLIC	??$_Construct@I@?$vector@HV?$allocator@H@std@@@std@@QAEXIIU_Int_iterator_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Construct<unsigned int>
PUBLIC	??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> ><unsigned int>
PUBLIC	?size@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEIXZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::size
PUBLIC	?getDecodeWindow@SystemConfiguration@DRAMsimII@@QBEIXZ ; DRAMsimII::SystemConfiguration::getDecodeWindow
PUBLIC	?remove@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::remove
PUBLIC	??A?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@1@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator[]
PUBLIC	?tBufferDelay@TimingSpecification@DRAMsimII@@QBEHXZ ; DRAMsimII::TimingSpecification::tBufferDelay
PUBLIC	?getRefreshPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RefreshPolicy@2@XZ ; DRAMsimII::SystemConfiguration::getRefreshPolicy
PUBLIC	?tREFI@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tREFI
PUBLIC	??A?$vector@_JV?$allocator@_J@std@@@std@@QAEAA_JI@Z ; std::vector<__int64,std::allocator<__int64> >::operator[]
PUBLIC	??A?$vector@_JV?$allocator@_J@std@@@std@@QBEAB_JI@Z ; std::vector<__int64,std::allocator<__int64> >::operator[]
PUBLIC	??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator++
PUBLIC	??_GEvent@DRAMsimII@@UAEPAXI@Z			; DRAMsimII::Event::`scalar deleting destructor'
PUBLIC	??1Event@DRAMsimII@@UAE@XZ			; DRAMsimII::Event::~Event
PUBLIC	??1Transaction@DRAMsimII@@UAE@XZ		; DRAMsimII::Transaction::~Transaction
PUBLIC	?resetToTime@PowerConfig@DRAMsimII@@QAEX_J@Z	; DRAMsimII::PowerConfig::resetToTime
PUBLIC	??D?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEAB_JXZ ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator*
PUBLIC	??D?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEAA_JXZ ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator*
PUBLIC	??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator++
PUBLIC	??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator++
PUBLIC	??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator++
PUBLIC	?setBank@Address@DRAMsimII@@QAEXI@Z		; DRAMsimII::Address::setBank
PUBLIC	?isRefresh@Transaction@DRAMsimII@@QBE_NXZ	; DRAMsimII::Transaction::isRefresh
PUBLIC	?setDecodeTime@Transaction@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Transaction::setDecodeTime
PUBLIC	?push@Bank@DRAMsimII@@QAE_NPAVCommand@2@@Z	; DRAMsimII::Bank::push
PUBLIC	?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ	; DRAMsimII::Bank::back
PUBLIC	?freeCommandSlots@Bank@DRAMsimII@@QBEIXZ	; DRAMsimII::Bank::freeCommandSlots
PUBLIC	?isFull@Bank@DRAMsimII@@QBE_NXZ			; DRAMsimII::Bank::isFull
PUBLIC	?reportHit@Statistics@DRAMsimII@@QAEXXZ		; DRAMsimII::Statistics::reportHit
PUBLIC	?reportMiss@Statistics@DRAMsimII@@QAEXXZ	; DRAMsimII::Statistics::reportMiss
PUBLIC	?getRowBufferManagementPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RowBufferPolicy@2@XZ ; DRAMsimII::SystemConfiguration::getRowBufferManagementPolicy
PUBLIC	?pop@Bank@DRAMsimII@@QAEPAVCommand@2@XZ		; DRAMsimII::Bank::pop
PUBLIC	?depth@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ ; DRAMsimII::Queue<DRAMsimII::Command>::depth
PUBLIC	?isHighUtilization@Bank@DRAMsimII@@QBE_NXZ	; DRAMsimII::Bank::isHighUtilization
PUBLIC	??Y?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+=
PUBLIC	??H?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
PUBLIC	??D?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEAAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*
PUBLIC	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
PUBLIC	??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
PUBLIC	??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
PUBLIC	??Y?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+=
PUBLIC	??H?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
PUBLIC	?isReadWriteGrouping@SystemConfiguration@DRAMsimII@@QBE_NXZ ; DRAMsimII::SystemConfiguration::isReadWriteGrouping
PUBLIC	?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z	; DRAMsimII::Bank::read
PUBLIC	?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::front
PUBLIC	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ	; DRAMsimII::Bank::front
PUBLIC	?size@Bank@DRAMsimII@@QBEIXZ			; DRAMsimII::Bank::size
PUBLIC	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
PUBLIC	?getStartTime@Event@DRAMsimII@@QBE_JXZ		; DRAMsimII::Event::getStartTime
PUBLIC	?getCompletionTime@Event@DRAMsimII@@QBE_JXZ	; DRAMsimII::Event::getCompletionTime
PUBLIC	?setStartTime@Event@DRAMsimII@@QAEX_J@Z		; DRAMsimII::Event::setStartTime
PUBLIC	?setCompletionTime@Event@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Event::setCompletionTime
PUBLIC	?getHost@Command@DRAMsimII@@QBEPAVTransaction@2@XZ ; DRAMsimII::Command::getHost
PUBLIC	?isActivated@Bank@DRAMsimII@@QBE_NXZ		; DRAMsimII::Bank::isActivated
PUBLIC	?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAA_JXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::back
PUBLIC	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
PUBLIC	??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
PUBLIC	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
PUBLIC	?setLastBankID@Rank@DRAMsimII@@QAEXI@Z		; DRAMsimII::Rank::setLastBankID
PUBLIC	?reportTFawCommand@Statistics@DRAMsimII@@QAEXXZ	; DRAMsimII::Statistics::reportTFawCommand
PUBLIC	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
PUBLIC	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
PUBLIC	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
PUBLIC	??8?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator==
PUBLIC	??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=
PUBLIC	??D?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEAAVRank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*
PUBLIC	??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
PUBLIC	??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
PUBLIC	??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
PUBLIC	?getRankID@Rank@DRAMsimII@@QBEIXZ		; DRAMsimII::Rank::getRankID
PUBLIC	?getLastCASLength@Rank@DRAMsimII@@QBEIXZ	; DRAMsimII::Rank::getLastCASLength
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>
PUBLIC	??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
PUBLIC	??D?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*
PUBLIC	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
PUBLIC	??Y?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+=
PUBLIC	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
PUBLIC	?isEmpty@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::isEmpty
PUBLIC	??D?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*
PUBLIC	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
PUBLIC	??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
PUBLIC	??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
PUBLIC	?tRRD@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRRD
PUBLIC	?tFAW@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tFAW
PUBLIC	?tRFC@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRFC
PUBLIC	?tRTRS@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tRTRS
PUBLIC	?tOST@TimingSpecification@DRAMsimII@@QBEHXZ	; DRAMsimII::TimingSpecification::tOST
PUBLIC	?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ		; DRAMsimII::Bank::getLastRASTime
PUBLIC	?getLastCASTime@Bank@DRAMsimII@@QBE_JXZ		; DRAMsimII::Bank::getLastCASTime
PUBLIC	?getLastCASWTime@Bank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Bank::getLastCASWTime
PUBLIC	?getLastPrechargeTime@Bank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Bank::getLastPrechargeTime
PUBLIC	?front@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::front
PUBLIC	?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::back
PUBLIC	?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::size
PUBLIC	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
PUBLIC	?getLastRefreshTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getLastRefreshTime
PUBLIC	?getLastCASTime@Rank@DRAMsimII@@QBE_JXZ		; DRAMsimII::Rank::getLastCASTime
PUBLIC	?getLastCASWTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getLastCASWTime
PUBLIC	?getOtherLastCASTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getOtherLastCASTime
PUBLIC	?getOtherLastCASWTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getOtherLastCASWTime
PUBLIC	?getLastPrechargeTime@Rank@DRAMsimII@@QBE_JXZ	; DRAMsimII::Rank::getLastPrechargeTime
PUBLIC	?getLastCASWLength@Rank@DRAMsimII@@QBEIXZ	; DRAMsimII::Rank::getLastCASWLength
PUBLIC	?getOtherLastCASLength@Rank@DRAMsimII@@QBEIXZ	; DRAMsimII::Rank::getOtherLastCASLength
PUBLIC	?getOtherLastCASWLength@Rank@DRAMsimII@@QBEIXZ	; DRAMsimII::Rank::getOtherLastCASWLength
PUBLIC	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?getRank@Address@DRAMsimII@@QBEIXZ		; DRAMsimII::Address::getRank
PUBLIC	?getColumn@Address@DRAMsimII@@QBEIXZ		; DRAMsimII::Address::getColumn
PUBLIC	?isActivate@Command@DRAMsimII@@QBE_NXZ		; DRAMsimII::Command::isActivate
PUBLIC	?getDatarate@SystemConfiguration@DRAMsimII@@QBENXZ ; DRAMsimII::SystemConfiguration::getDatarate
PUBLIC	?begin@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::begin
PUBLIC	?end@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVTransaction@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@PAVTransaction@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &>::_Ranit<DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &>
PUBLIC	??0?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??0?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	?_Make_iter@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator==
PUBLIC	??9?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator!=
PUBLIC	??$_Copy_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z ; stdext::unchecked_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
PUBLIC	?erase@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@0@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::erase
PUBLIC	?deallocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEXPAPAVTransaction@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Transaction *>::deallocate
PUBLIC	??$_Allocate@PAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@IPAPAV12@@Z ; std::_Allocate<DRAMsimII::Transaction *>
PUBLIC	?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Transaction *>::allocate
PUBLIC	?capacity@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::capacity
PUBLIC	?max_size@?$allocator@PAVTransaction@DRAMsimII@@@std@@QBEIXZ ; std::allocator<DRAMsimII::Transaction *>::max_size
PUBLIC	?max_size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::max_size
PUBLIC	??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::Transaction *> >
PUBLIC	?_Destroy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXPAPAVTransaction@DRAMsimII@@0@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Destroy
PUBLIC	??$_Iter_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z ; std::_Iter_cat<DRAMsimII::Transaction * *>
PUBLIC	??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>
PUBLIC	??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>
PUBLIC	??$unchecked_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@@Z ; stdext::unchecked_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>
PUBLIC	??$_Uninit_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	?_Ufill@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV34@IABQAV34@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Ufill
PUBLIC	?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Xlen
PUBLIC	??$_Uninit_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??$_Uninit_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
PUBLIC	??$_Umove@PAPAVTransaction@DRAMsimII@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV23@00@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<DRAMsimII::Transaction * *>
PUBLIC	??$_Fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z ; std::_Fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>
PUBLIC	??$fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z ; std::fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>
PUBLIC	??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<DRAMsimII::Transaction * *>
PUBLIC	??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@@Z ; std::_Checked_base<DRAMsimII::Transaction * *>
PUBLIC	??$_Iter_random@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@0@Z ; std::_Iter_random<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
PUBLIC	??$_Move_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z ; std::_Move_cat<DRAMsimII::Transaction * *>
PUBLIC	??$_Ptr_cat@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVTransaction@DRAMsimII@@0@Z ; std::_Ptr_cat<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
PUBLIC	??$_Copy_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
PUBLIC	?_Insert_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@IABQAVTransaction@DRAMsimII@@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Insert_n
PUBLIC	??Y?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+=
PUBLIC	??Y?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+=
PUBLIC	??H?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+
PUBLIC	?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIPAVTransaction@DRAMsimII@@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize
PUBLIC	?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize
PUBLIC	??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAPAVTransaction@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator[]
PUBLIC	??4?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator=
PUBLIC	?capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::capacity
PUBLIC	?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ ; std::vector<__int64,std::allocator<__int64> >::begin
PUBLIC	?end@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ ; std::vector<__int64,std::allocator<__int64> >::end
PUBLIC	??0?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<__int64,std::allocator<__int64> >::_Vector_iterator<__int64,std::allocator<__int64> >
PUBLIC	?_Make_iter@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@@Z ; std::vector<__int64,std::allocator<__int64> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator==
PUBLIC	??9?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator!=
PUBLIC	?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@0@Z ; std::vector<__int64,std::allocator<__int64> >::erase
PUBLIC	?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ ; std::vector<__int64,std::allocator<__int64> >::clear
PUBLIC	??$_Allocate@_J@std@@YAPA_JIPA_J@Z		; std::_Allocate<__int64>
PUBLIC	?allocate@?$allocator@_J@std@@QAEPA_JI@Z	; std::allocator<__int64>::allocate
PUBLIC	?max_size@?$allocator@_J@std@@QBEIXZ		; std::allocator<__int64>::max_size
PUBLIC	?max_size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::max_size
PUBLIC	?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ ; std::vector<__int64,std::allocator<__int64> >::_Xlen
PUBLIC	?_Buy@?$vector@_JV?$allocator@_J@std@@@std@@IAE_NI@Z ; std::vector<__int64,std::allocator<__int64> >::_Buy
PUBLIC	??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<__int64> >
PUBLIC	??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@@Z ; std::_Destroy_range<std::allocator<__int64> >
PUBLIC	?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z ; std::vector<__int64,std::allocator<__int64> >::_Destroy
PUBLIC	??$_Iter_random@PA_JPA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J0@Z ; std::_Iter_random<__int64 *,__int64 *>
PUBLIC	??$_Copy_opt@PA_JPA_JUrandom_access_iterator_tag@std@@@std@@YAPA_JPA_J00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<__int64 *,__int64 *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PA_JPA_J@stdext@@YAPA_JPA_J00@Z ; stdext::unchecked_copy<__int64 *,__int64 *>
PUBLIC	??$_Checked_base@PA_J@std@@YAPA_JAAPA_JU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<__int64 *>
PUBLIC	??$_Checked_base@PA_J@std@@YAPA_JAAPA_J@Z	; std::_Checked_base<__int64 *>
PUBLIC	??$_Ptr_cat@PA_JPA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPA_J0@Z ; std::_Ptr_cat<__int64 *,__int64 *>
PUBLIC	??$_Uninit_copy@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<__int64 *,__int64 *,std::allocator<__int64> >
PUBLIC	??$unchecked_uninitialized_copy@PA_JPA_JV?$allocator@_J@std@@@stdext@@YAPA_JPA_J00AAV?$allocator@_J@std@@@Z ; stdext::unchecked_uninitialized_copy<__int64 *,__int64 *,std::allocator<__int64> >
PUBLIC	??$_Ucopy@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<__int64 *>
PUBLIC	??4?$vector@_JV?$allocator@_J@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<__int64,std::allocator<__int64> >::operator=
PUBLIC	?deallocate@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Rank>::deallocate
PUBLIC	?capacity@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::capacity
PUBLIC	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
PUBLIC	?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
PUBLIC	??0?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	?_Make_iter@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator==
PUBLIC	??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator!=
PUBLIC	?erase@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@0@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::erase
PUBLIC	?clear@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::clear
PUBLIC	??$_Allocate@VRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@IPAV12@@Z ; std::_Allocate<DRAMsimII::Rank>
PUBLIC	?allocate@?$allocator@VRank@DRAMsimII@@@std@@QAEPAVRank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Rank>::allocate
PUBLIC	?max_size@?$allocator@VRank@DRAMsimII@@@std@@QBEIXZ ; std::allocator<DRAMsimII::Rank>::max_size
PUBLIC	?max_size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::max_size
PUBLIC	?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Xlen
PUBLIC	?_Buy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE_NI@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Buy
PUBLIC	??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::Rank> >
PUBLIC	??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::Rank> >
PUBLIC	?_Destroy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXPAVRank@DRAMsimII@@0@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Destroy
PUBLIC	??$_Iter_random@PAVRank@DRAMsimII@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVRank@DRAMsimII@@0@Z ; std::_Iter_random<DRAMsimII::Rank *,DRAMsimII::Rank *>
PUBLIC	??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *,std::forward_iterator_tag>
PUBLIC	??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@@std@@YAPAVRank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *>
PUBLIC	??$unchecked_copy@PAVRank@DRAMsimII@@PAV12@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00@Z ; stdext::unchecked_copy<DRAMsimII::Rank *,DRAMsimII::Rank *>
PUBLIC	??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<DRAMsimII::Rank *>
PUBLIC	??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@@Z ; std::_Checked_base<DRAMsimII::Rank *>
PUBLIC	??$_Ptr_cat@PAVRank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVRank@DRAMsimII@@0@Z ; std::_Ptr_cat<DRAMsimII::Rank *,DRAMsimII::Rank *>
PUBLIC	??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z ; std::_Construct<DRAMsimII::Rank,DRAMsimII::Rank>
PUBLIC	?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z ; std::allocator<DRAMsimII::Rank>::construct
PUBLIC	?capacity@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::capacity
PUBLIC	?deallocate@?$allocator@_J@std@@QAEXPA_JI@Z	; std::allocator<__int64>::deallocate
PUBLIC	?deallocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_JI@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::deallocate
PUBLIC	?size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::size
PUBLIC	??$_Destroy@_J@std@@YAXPA_J@Z			; std::_Destroy<__int64>
PUBLIC	?destroy@?$allocator@_J@std@@QAEXPA_J@Z		; std::allocator<__int64>::destroy
PUBLIC	?destroy_item@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_J@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy_item
PUBLIC	??$increment@PA_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPA_J@Z ; boost::circular_buffer<__int64,std::allocator<__int64> >::increment<__int64 *>
PUBLIC	?destroy_content@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy_content
PUBLIC	?destroy@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy
PUBLIC	??1?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@XZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::~circular_buffer<__int64,std::allocator<__int64> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >
PUBLIC	??1?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	?deallocate@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Bank>::deallocate
PUBLIC	??$_Ptr_cat@PAVBank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVBank@DRAMsimII@@0@Z ; std::_Ptr_cat<DRAMsimII::Bank *,DRAMsimII::Bank *>
PUBLIC	??1Bank@DRAMsimII@@QAE@XZ			; DRAMsimII::Bank::~Bank
PUBLIC	??_GBank@DRAMsimII@@QAEPAXI@Z			; DRAMsimII::Bank::`scalar deleting destructor'
PUBLIC	??$_Destroy@VBank@DRAMsimII@@@std@@YAXPAVBank@DRAMsimII@@@Z ; std::_Destroy<DRAMsimII::Bank>
PUBLIC	?destroy@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@@Z ; std::allocator<DRAMsimII::Bank>::destroy
PUBLIC	??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::Bank> >
PUBLIC	??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@@Z ; std::_Destroy_range<std::allocator<DRAMsimII::Bank> >
PUBLIC	?_Destroy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXPAVBank@DRAMsimII@@0@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Destroy
PUBLIC	?_Tidy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Tidy
PUBLIC	??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	??1Rank@DRAMsimII@@QAE@XZ			; DRAMsimII::Rank::~Rank
PUBLIC	??_GRank@DRAMsimII@@QAEPAXI@Z			; DRAMsimII::Rank::`scalar deleting destructor'
PUBLIC	??$_Destroy@VRank@DRAMsimII@@@std@@YAXPAVRank@DRAMsimII@@@Z ; std::_Destroy<DRAMsimII::Rank>
PUBLIC	?destroy@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@@Z ; std::allocator<DRAMsimII::Rank>::destroy
PUBLIC	??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
PUBLIC	??$unchecked_uninitialized_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@std@@@Z ; stdext::unchecked_uninitialized_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
PUBLIC	??$_Ucopy@PAVRank@DRAMsimII@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV23@00@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<DRAMsimII::Rank *>
PUBLIC	??4?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator=
PUBLIC	?size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::size
PUBLIC	??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEABQAVTransaction@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator[]
PUBLIC	?read@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPAVTransaction@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::read
PUBLIC	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
PUBLIC	??8?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator==
PUBLIC	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>
PUBLIC	??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
PUBLIC	?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::size
PUBLIC	??$_Iter_random@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z ; std::_Iter_random<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
PUBLIC	??Y?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+=
PUBLIC	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
PUBLIC	??$_Equal@PBVRank@DRAMsimII@@PBV12@Uforward_iterator_tag@std@@@std@@YA_NPBVRank@DRAMsimII@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<DRAMsimII::Rank const *,DRAMsimII::Rank const *,std::forward_iterator_tag>
PUBLIC	??$_Equal@PBVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVRank@DRAMsimII@@0V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<DRAMsimII::Rank const *,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
PUBLIC	??$equal@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@00@Z ; std::equal<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
PUBLIC	??$?8VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z ; std::operator==<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	?begin@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ ; std::vector<__int64,std::allocator<__int64> >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_JHPB_JAB_JV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,__int64,int,__int64 const *,__int64 const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,__int64,int,__int64 const *,__int64 const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@_JHPB_JAB_J@std@@QAE@XZ		; std::_Ranit<__int64,int,__int64 const *,__int64 const &>::_Ranit<__int64,int,__int64 const *,__int64 const &>
PUBLIC	??0?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Vector_const_iterator<__int64,std::allocator<__int64> >
PUBLIC	?end@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ ; std::vector<__int64,std::allocator<__int64> >::end
PUBLIC	?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::size
PUBLIC	??$_Iter_random@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@0@Z ; std::_Iter_random<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
PUBLIC	??Y?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator+=
PUBLIC	??H?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator+
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEPB_JXZ ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
PUBLIC	??$_Equal@PB_JPB_JUforward_iterator_tag@std@@@std@@YA_NPB_J00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<__int64 const *,__int64 const *,std::forward_iterator_tag>
PUBLIC	??$_Equal@PB_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA_NPB_J0V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<__int64 const *,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
PUBLIC	??$equal@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@00@Z ; std::equal<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
PUBLIC	??$?8_JV?$allocator@_J@std@@@std@@YA_NABV?$vector@_JV?$allocator@_J@std@@@0@0@Z ; std::operator==<__int64,std::allocator<__int64> >
PUBLIC	??0?$arg@$05@boost@@QAE@XZ			; boost::arg<6>::arg<6>
PUBLIC	??0?$arg@$02@boost@@QAE@XZ			; boost::arg<3>::arg<3>
PUBLIC	??0?$arg@$06@boost@@QAE@XZ			; boost::arg<7>::arg<7>
PUBLIC	??0?$arg@$01@boost@@QAE@XZ			; boost::arg<2>::arg<2>
PUBLIC	??0?$arg@$03@boost@@QAE@XZ			; boost::arg<4>::arg<4>
PUBLIC	??0?$arg@$08@boost@@QAE@XZ			; boost::arg<9>::arg<9>
PUBLIC	??0?$arg@$04@boost@@QAE@XZ			; boost::arg<5>::arg<5>
PUBLIC	??0?$arg@$00@boost@@QAE@XZ			; boost::arg<1>::arg<1>
PUBLIC	??0?$arg@$07@boost@@QAE@XZ			; boost::arg<8>::arg<8>
PUBLIC	?value@?$is_empty_impl@X@detail@boost@@2_NB	; boost::detail::is_empty_impl<void>::value
PUBLIC	?value@?$is_empty_impl@$$CBX@detail@boost@@2_NB	; boost::detail::is_empty_impl<void const >::value
PUBLIC	?value@?$is_empty_impl@$$CCX@detail@boost@@2_NB	; boost::detail::is_empty_impl<void volatile >::value
PUBLIC	?value@?$is_empty_impl@$$CDX@detail@boost@@2_NB	; boost::detail::is_empty_impl<void const volatile >::value
PUBLIC	?value@?$not_satisfied@U?$usage_requirements@U?$SGIAssignable@_J@boost@@@concept@boost@@@concept@boost@@2_NB ; boost::concept::not_satisfied<boost::concept::usage_requirements<boost::SGIAssignable<__int64> > >::value
PUBLIC	?value@?$not_satisfied@U?$SGIAssignableConcept@_J@boost@@@concept@boost@@2_NB ; boost::concept::not_satisfied<boost::SGIAssignableConcept<__int64> >::value
PUBLIC	?is_const@?$cv_traits_imp@PA_J@detail@boost@@2_NB ; boost::detail::cv_traits_imp<__int64 *>::is_const
PUBLIC	?is_volatile@?$cv_traits_imp@PA_J@detail@boost@@2_NB ; boost::detail::cv_traits_imp<__int64 *>::is_volatile
PUBLIC	?value@?$is_pointer_helper@_J@detail@boost@@2_NB ; boost::detail::is_pointer_helper<__int64>::value
PUBLIC	?value@?$result_@_J@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB ; boost::detail::is_mem_fun_pointer_select<0>::result_<__int64>::value
PUBLIC	?value@?$is_pointer_impl@_J@detail@boost@@2_NB	; boost::detail::is_pointer_impl<__int64>::value
PUBLIC	?value@?$is_arithmetic_impl@_J@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<__int64>::value
PUBLIC	?_EEM_DS@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@2HB ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_EEM_DS
PUBLIC	??_C@_0DJ@LMOMBNJL@http?3?1?1id2?4gentag?4com?37777?1DRAMs@ ; `string'
PUBLIC	?namespaces@?4???0DRAMsimWSSoapHttp@@QAE@XZ@4QBUNamespace@@B ; `DRAMsimWSSoapHttp::DRAMsimWSSoapHttp'::`5'::namespaces
PUBLIC	_namespaces
PUBLIC	?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_weekday@gregorian@boost@@@detail@boost@@2_NB ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_weekday>::value
PUBLIC	?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_day_of_month@gregorian@boost@@@detail@boost@@2_NB ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_day_of_month>::value
PUBLIC	?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_year@gregorian@boost@@@detail@boost@@2_NB ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_year>::value
PUBLIC	?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_month@gregorian@boost@@@detail@boost@@2_NB ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_month>::value
PUBLIC	?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_day_of_year@gregorian@boost@@@detail@boost@@2_NB ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_day_of_year>::value
PUBLIC	?ticks_per_second@?$time_resolution_traits@Utime_resolution_traits_adapted64_impl@date_time@boost@@$04$0PECEA@$05J@date_time@boost@@2_JB ; boost::date_time::time_resolution_traits<boost::date_time::time_resolution_traits_adapted64_impl,5,1000000,6,long>::ticks_per_second
PUBLIC	?tick_per_second@millisec_posix_time_system_config@posix_time@boost@@2_JB ; boost::posix_time::millisec_posix_time_system_config::tick_per_second
PUBLIC	??_R0?AVthread_resource_error@boost@@@8		; boost::thread_resource_error `RTTI Type Descriptor'
PUBLIC	??_R0?AVthread_exception@boost@@@8		; boost::thread_exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVthread_resource_error@boost@@@8??0thread_resource_error@boost@@QAE@ABV01@@Z16
PUBLIC	__CT??_R0?AVthread_exception@boost@@@8??0thread_exception@boost@@QAE@ABV01@@Z16
PUBLIC	__CTA3?AVthread_resource_error@boost@@
PUBLIC	__TI3?AVthread_resource_error@boost@@
PUBLIC	?max_non_infinite_wait@timeout@detail@boost@@2KB ; boost::detail::timeout::max_non_infinite_wait
PUBLIC	?lock_flag_bit@basic_timed_mutex@detail@boost@@2EB ; boost::detail::basic_timed_mutex::lock_flag_bit
PUBLIC	?event_set_flag_bit@basic_timed_mutex@detail@boost@@2EB ; boost::detail::basic_timed_mutex::event_set_flag_bit
PUBLIC	?lock_flag_value@basic_timed_mutex@detail@boost@@2JB ; boost::detail::basic_timed_mutex::lock_flag_value
PUBLIC	?event_set_flag_value@basic_timed_mutex@detail@boost@@2JB ; boost::detail::basic_timed_mutex::event_set_flag_value
PUBLIC	?value@?$is_convertible_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@23@@detail@boost@@2_NB ; boost::detail::is_convertible_impl<boost::detail::thread_move_t<boost::thread> &,boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
PUBLIC	?value@?$is_convertible_basic_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@23@@detail@boost@@2_NB ; boost::detail::is_convertible_basic_impl<boost::detail::thread_move_t<boost::thread> &,boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
PUBLIC	?value@?$is_abstract_imp@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@@detail@boost@@2_NB ; boost::detail::is_abstract_imp<boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
PUBLIC	?value@?$is_arithmetic_impl@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
PUBLIC	?value@?$is_arithmetic_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::thread> &>::value
PUBLIC	?value@?$is_arithmetic_impl@AAVthread@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::thread &>::value
PUBLIC	?value@?$is_arithmetic_impl@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::thread> >::value
PUBLIC	?value@?$is_abstract_imp@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB ; boost::detail::is_abstract_imp<boost::detail::thread_move_t<boost::thread> >::value
PUBLIC	?value@?$is_convertible_basic_impl@AAVthread@boost@@U?$thread_move_t@Vthread@boost@@@detail@2@@detail@boost@@2_NB ; boost::detail::is_convertible_basic_impl<boost::thread &,boost::detail::thread_move_t<boost::thread> >::value
PUBLIC	?value@?$is_convertible_impl@AAVthread@boost@@U?$thread_move_t@Vthread@boost@@@detail@2@@detail@boost@@2_NB ; boost::detail::is_convertible_impl<boost::thread &,boost::detail::thread_move_t<boost::thread> >::value
PUBLIC	??_C@_0CI@CNIHCHBK@Unknown?5transaction?5ordering?5alg@ ; `string'
PUBLIC	??_C@_04CNFIBAEC@?$HN?5mW?$AA@			; `string'
PUBLIC	??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@		; `string'
PUBLIC	??_C@_0BE@OKBLMJCG@?9Psys?$CIACT_STBY?$CJ?5ch?$FL?$AA@ ; `string'
PUBLIC	??_C@_0L@EOFJECFB@?$HN?5mW?5tRRD?$FL?$AA@	; `string'
PUBLIC	??_C@_0P@JAGAIFBA@?9Psys?$CIACT?$CJ?5ch?$FL?$AA@ ; `string'
PUBLIC	??_C@_0BE@OPIKMKPA@?9Psys?$CIPRE_STBY?$CJ?5ch?$FL?$AA@ ; `string'
PUBLIC	??_C@_0O@NPIBAAFJ@?9Psys?$CIRD?$CJ?5ch?$FL?$AA@	; `string'
PUBLIC	??_C@_0O@JDGPKHMJ@?9Psys?$CIWR?$CJ?5ch?$FL?$AA@	; `string'
PUBLIC	?value@?$is_arithmetic_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &>::value
PUBLIC	?value@?$is_arithmetic_impl@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@detail@boost@@2_NB ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
PUBLIC	?value@?$is_abstract_imp@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@detail@boost@@2_NB ; boost::detail::is_abstract_imp<boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
PUBLIC	?value@?$is_convertible_basic_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@3@@detail@boost@@2_NB ; boost::detail::is_convertible_basic_impl<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &,boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
PUBLIC	?value@?$is_convertible_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@3@@detail@boost@@2_NB ; boost::detail::is_convertible_impl<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &,boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
PUBLIC	??_C@_0CH@PMAPFHOL@Unhandled?5row?5buffer?5management?5@ ; `string'
PUBLIC	??_C@_0DO@NJGLEKNI@error?3?5Found?5a?5row?5activate?5not?5@ ; `string'
PUBLIC	??_C@_0BO@IIOHHIBJ@warn?3?5Unhandled?5command?5type?4?$AA@ ; `string'
PUBLIC	??_C@_0DO@LMCLJHD@error?3?5row?5activate?5command?5not?5@ ; `string'
PUBLIC	??_C@_0BN@DBBBPOIP@warn?3?5unhandled?5command?5type?$AA@ ; `string'
PUBLIC	??_C@_0DO@ENOGKDBL@This?5configuration?5and?5algorithm@ ; `string'
PUBLIC	??_C@_0BF@IGPJINBF@Unknown?5command?5type?$AA@	; `string'
PUBLIC	??_C@_0CB@JLFGGPAL@Unsupported?5command?5encountered?4@ ; `string'
PUBLIC	??_C@_05DJFABFLL@?$CJ?$DL?5?1?1?$AA@		; `string'
PUBLIC	??_C@_04HFDGOAGB@nop?$CI?$AA@			; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_02OACLCCCA@?0?7?$AA@			; `string'
PUBLIC	??_C@_07CNLIACOE@read?7?7?$CI?$AA@		; `string'
PUBLIC	??_C@_0N@DCHNCKN@?0?70?0?710?$CJ?$DL?5?1?1?$AA@	; `string'
PUBLIC	??_C@_08JDIKLHND@write?7?7?$CI?$AA@		; `string'
PUBLIC	??_C@_0L@EDCPHMCE@activate?7?$CI?$AA@		; `string'
PUBLIC	??_C@_02LJALELK@?$CJ?$DL?$AA@			; `string'
PUBLIC	??_C@_08MCOFLILF@refresh?$CI?$AA@		; `string'
PUBLIC	??_C@_0M@EJENEINP@precharge?7?$CI?$AA@		; `string'
PUBLIC	??_C@_05JPECMJL@?$FN?5ch?$FL?$AA@		; `string'
PUBLIC	??_C@_02DCEECEBO@T?$FL?$AA@			; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_7Event@DRAMsimII@@6B@			; DRAMsimII::Event::`vftable'
PUBLIC	??_7Channel@DRAMsimII@@6B@			; DRAMsimII::Channel::`vftable'
PUBLIC	??_7_ns2__submitEpochResultElement@@6B@		; _ns2__submitEpochResultElement::`vftable'
PUBLIC	??_7_ns2__submitEpochResultResponseElement@@6B@	; _ns2__submitEpochResultResponseElement::`vftable'
PUBLIC	??_7DRAMsimWSSoapHttp@@6B@			; DRAMsimWSSoapHttp::`vftable'
PUBLIC	??_7thread_exception@boost@@6B@			; boost::thread_exception::`vftable'
PUBLIC	??_7thread_resource_error@boost@@6B@		; boost::thread_resource_error::`vftable'
PUBLIC	??_7thread_data_base@detail@boost@@6B@		; boost::detail::thread_data_base::`vftable'
PUBLIC	??_7?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@ ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`vftable'
EXTRN	??_EChannel@DRAMsimII@@UAEPAXI@Z:PROC		; DRAMsimII::Channel::`vector deleting destructor'
EXTRN	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z:PROC	; std::setprecision
EXTRN	??1thread@boost@@QAE@XZ:PROC			; boost::thread::~thread
EXTRN	?start_thread@thread@boost@@AAEXXZ:PROC		; boost::thread::start_thread
EXTRN	??0exception@std@@QAE@ABQBDH@Z:PROC		; std::exception::exception
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__HeapFree@12:PROC
EXTRN	??0thread_resource_error@boost@@QAE@XZ:PROC	; boost::thread_resource_error::thread_resource_error
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	?what@thread_resource_error@boost@@UBEPBDXZ:PROC ; boost::thread_resource_error::what
EXTRN	??1thread_resource_error@boost@@UAE@XZ:PROC	; boost::thread_resource_error::~thread_resource_error
EXTRN	??_Ethread_resource_error@boost@@UAEPAXI@Z:PROC	; boost::thread_resource_error::`vector deleting destructor'
EXTRN	??1thread_exception@boost@@UAE@XZ:PROC		; boost::thread_exception::~thread_exception
EXTRN	??_Ethread_exception@boost@@UAEPAXI@Z:PROC	; boost::thread_exception::`vector deleting destructor'
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__purecall:PROC
EXTRN	??_Ethread_data_base@detail@boost@@UAEPAXI@Z:PROC ; boost::detail::thread_data_base::`vector deleting destructor'
EXTRN	??_E?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEPAXI@Z:PROC ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`vector deleting destructor'
EXTRN	??_EDRAMsimWSSoapHttp@@UAEPAXI@Z:PROC		; DRAMsimWSSoapHttp::`vector deleting destructor'
EXTRN	_atexit:PROC
EXTRN	??_EEvent@DRAMsimII@@UAEPAXI@Z:PROC		; DRAMsimII::Event::`vector deleting destructor'
EXTRN	_exit:PROC
;	COMDAT ??_7?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@
CONST	SEGMENT
??_7?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@ DD FLAT:??_R4?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@ ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`vftable'
	DD	FLAT:??_E?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEPAXI@Z
	DD	FLAT:?run@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R4?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@
rdata$r	SEGMENT
??_R4?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@ DD 00H ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@8
	DD	FLAT:??_R3?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R3?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8
rdata$r	SEGMENT
??_R3?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8 DD 00H ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R2?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8
rdata$r	SEGMENT
??_R2?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8 DD FLAT:??_R1A@?0A@EA@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8 ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@thread_data_base@detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8 DD FLAT:??_R0?AV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@8 ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@8
_DATA	SEGMENT
??_R0?AV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@8 DD FLAT:??_7type_info@@6B@ ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsim'
	DB	'II@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allo'
	DB	'cator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChann'
	DB	'el@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vect'
	DB	'or@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allo'
	DB	'cator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@'
	DB	'@@detail@boost@@', 00H
_DATA	ENDS
;	COMDAT ??_7thread_data_base@detail@boost@@6B@
CONST	SEGMENT
??_7thread_data_base@detail@boost@@6B@ DD FLAT:??_R4thread_data_base@detail@boost@@6B@ ; boost::detail::thread_data_base::`vftable'
	DD	FLAT:??_Ethread_data_base@detail@boost@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4thread_data_base@detail@boost@@6B@
rdata$r	SEGMENT
??_R4thread_data_base@detail@boost@@6B@ DD 00H		; boost::detail::thread_data_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUthread_data_base@detail@boost@@@8
	DD	FLAT:??_R3thread_data_base@detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R3thread_data_base@detail@boost@@8
rdata$r	SEGMENT
??_R3thread_data_base@detail@boost@@8 DD 00H		; boost::detail::thread_data_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2thread_data_base@detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R2thread_data_base@detail@boost@@8
rdata$r	SEGMENT
??_R2thread_data_base@detail@boost@@8 DD FLAT:??_R1A@?0A@EA@thread_data_base@detail@boost@@8 ; boost::detail::thread_data_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@thread_data_base@detail@boost@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@thread_data_base@detail@boost@@8 DD FLAT:??_R0?AUthread_data_base@detail@boost@@@8 ; boost::detail::thread_data_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3thread_data_base@detail@boost@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUthread_data_base@detail@boost@@@8
_DATA	SEGMENT
??_R0?AUthread_data_base@detail@boost@@@8 DD FLAT:??_7type_info@@6B@ ; boost::detail::thread_data_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUthread_data_base@detail@boost@@', 00H
_DATA	ENDS
;	COMDAT ??_7thread_resource_error@boost@@6B@
CONST	SEGMENT
??_7thread_resource_error@boost@@6B@ DD FLAT:??_R4thread_resource_error@boost@@6B@ ; boost::thread_resource_error::`vftable'
	DD	FLAT:??_Ethread_resource_error@boost@@UAEPAXI@Z
	DD	FLAT:?what@thread_resource_error@boost@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4thread_resource_error@boost@@6B@
rdata$r	SEGMENT
??_R4thread_resource_error@boost@@6B@ DD 00H		; boost::thread_resource_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVthread_resource_error@boost@@@8
	DD	FLAT:??_R3thread_resource_error@boost@@8
rdata$r	ENDS
;	COMDAT ??_R3thread_resource_error@boost@@8
rdata$r	SEGMENT
??_R3thread_resource_error@boost@@8 DD 00H		; boost::thread_resource_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2thread_resource_error@boost@@8
rdata$r	ENDS
;	COMDAT ??_R2thread_resource_error@boost@@8
rdata$r	SEGMENT
??_R2thread_resource_error@boost@@8 DD FLAT:??_R1A@?0A@EA@thread_resource_error@boost@@8 ; boost::thread_resource_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@thread_exception@boost@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@thread_resource_error@boost@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@thread_resource_error@boost@@8 DD FLAT:??_R0?AVthread_resource_error@boost@@@8 ; boost::thread_resource_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3thread_resource_error@boost@@8
rdata$r	ENDS
;	COMDAT ??_7thread_exception@boost@@6B@
CONST	SEGMENT
??_7thread_exception@boost@@6B@ DD FLAT:??_R4thread_exception@boost@@6B@ ; boost::thread_exception::`vftable'
	DD	FLAT:??_Ethread_exception@boost@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4thread_exception@boost@@6B@
rdata$r	SEGMENT
??_R4thread_exception@boost@@6B@ DD 00H			; boost::thread_exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVthread_exception@boost@@@8
	DD	FLAT:??_R3thread_exception@boost@@8
rdata$r	ENDS
;	COMDAT ??_R3thread_exception@boost@@8
rdata$r	SEGMENT
??_R3thread_exception@boost@@8 DD 00H			; boost::thread_exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2thread_exception@boost@@8
rdata$r	ENDS
;	COMDAT ??_R2thread_exception@boost@@8
rdata$r	SEGMENT
??_R2thread_exception@boost@@8 DD FLAT:??_R1A@?0A@EA@thread_exception@boost@@8 ; boost::thread_exception::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@thread_exception@boost@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@thread_exception@boost@@8 DD FLAT:??_R0?AVthread_exception@boost@@@8 ; boost::thread_exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3thread_exception@boost@@8
rdata$r	ENDS
;	COMDAT ??_7DRAMsimWSSoapHttp@@6B@
CONST	SEGMENT
??_7DRAMsimWSSoapHttp@@6B@ DD FLAT:??_R4DRAMsimWSSoapHttp@@6B@ ; DRAMsimWSSoapHttp::`vftable'
	DD	FLAT:??_EDRAMsimWSSoapHttp@@UAEPAXI@Z
	DD	FLAT:?__ns1__getSessionID@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSessionIDElement@@PAV_ns2__getSessionIDResponseElement@@@Z
	DD	FLAT:?__ns1__getSettingsFile@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSettingsFileElement@@PAV_ns2__getSettingsFileResponseElement@@@Z
	DD	FLAT:?__ns1__submitEpochResult@DRAMsimWSSoapHttp@@UAEHPAV_ns2__submitEpochResultElement@@PAV_ns2__submitEpochResultResponseElement@@@Z
CONST	ENDS
;	COMDAT ??_R4DRAMsimWSSoapHttp@@6B@
rdata$r	SEGMENT
??_R4DRAMsimWSSoapHttp@@6B@ DD 00H			; DRAMsimWSSoapHttp::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDRAMsimWSSoapHttp@@@8
	DD	FLAT:??_R3DRAMsimWSSoapHttp@@8
rdata$r	ENDS
;	COMDAT ??_R3DRAMsimWSSoapHttp@@8
rdata$r	SEGMENT
??_R3DRAMsimWSSoapHttp@@8 DD 00H			; DRAMsimWSSoapHttp::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DRAMsimWSSoapHttp@@8
rdata$r	ENDS
;	COMDAT ??_R2DRAMsimWSSoapHttp@@8
rdata$r	SEGMENT
??_R2DRAMsimWSSoapHttp@@8 DD FLAT:??_R1A@?0A@EA@DRAMsimWSSoapHttp@@8 ; DRAMsimWSSoapHttp::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@DRAMsimWSSoapHttp@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DRAMsimWSSoapHttp@@8 DD FLAT:??_R0?AVDRAMsimWSSoapHttp@@@8 ; DRAMsimWSSoapHttp::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DRAMsimWSSoapHttp@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDRAMsimWSSoapHttp@@@8
_DATA	SEGMENT
??_R0?AVDRAMsimWSSoapHttp@@@8 DD FLAT:??_7type_info@@6B@ ; DRAMsimWSSoapHttp `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDRAMsimWSSoapHttp@@', 00H
_DATA	ENDS
;	COMDAT ??_7_ns2__submitEpochResultResponseElement@@6B@
CONST	SEGMENT
??_7_ns2__submitEpochResultResponseElement@@6B@ DD FLAT:??_R4_ns2__submitEpochResultResponseElement@@6B@ ; _ns2__submitEpochResultResponseElement::`vftable'
	DD	FLAT:?soap_type@_ns2__submitEpochResultResponseElement@@UBEHXZ
	DD	FLAT:?soap_default@_ns2__submitEpochResultResponseElement@@UAEXPAUsoap@@@Z
	DD	FLAT:?soap_serialize@_ns2__submitEpochResultResponseElement@@UBEXPAUsoap@@@Z
	DD	FLAT:?soap_put@_ns2__submitEpochResultResponseElement@@UBEHPAUsoap@@PBD1@Z
	DD	FLAT:?soap_out@_ns2__submitEpochResultResponseElement@@UBEHPAUsoap@@PBDH1@Z
	DD	FLAT:?soap_get@_ns2__submitEpochResultResponseElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:?soap_in@_ns2__submitEpochResultResponseElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:??_E_ns2__submitEpochResultResponseElement@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4_ns2__submitEpochResultResponseElement@@6B@
rdata$r	SEGMENT
??_R4_ns2__submitEpochResultResponseElement@@6B@ DD 00H	; _ns2__submitEpochResultResponseElement::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_ns2__submitEpochResultResponseElement@@@8
	DD	FLAT:??_R3_ns2__submitEpochResultResponseElement@@8
rdata$r	ENDS
;	COMDAT ??_R3_ns2__submitEpochResultResponseElement@@8
rdata$r	SEGMENT
??_R3_ns2__submitEpochResultResponseElement@@8 DD 00H	; _ns2__submitEpochResultResponseElement::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_ns2__submitEpochResultResponseElement@@8
rdata$r	ENDS
;	COMDAT ??_R2_ns2__submitEpochResultResponseElement@@8
rdata$r	SEGMENT
??_R2_ns2__submitEpochResultResponseElement@@8 DD FLAT:??_R1A@?0A@EA@_ns2__submitEpochResultResponseElement@@8 ; _ns2__submitEpochResultResponseElement::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_ns2__submitEpochResultResponseElement@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_ns2__submitEpochResultResponseElement@@8 DD FLAT:??_R0?AV_ns2__submitEpochResultResponseElement@@@8 ; _ns2__submitEpochResultResponseElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_ns2__submitEpochResultResponseElement@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_ns2__submitEpochResultResponseElement@@@8
_DATA	SEGMENT
??_R0?AV_ns2__submitEpochResultResponseElement@@@8 DD FLAT:??_7type_info@@6B@ ; _ns2__submitEpochResultResponseElement `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_ns2__submitEpochResultResponseElement@@', 00H
_DATA	ENDS
;	COMDAT ??_7_ns2__submitEpochResultElement@@6B@
CONST	SEGMENT
??_7_ns2__submitEpochResultElement@@6B@ DD FLAT:??_R4_ns2__submitEpochResultElement@@6B@ ; _ns2__submitEpochResultElement::`vftable'
	DD	FLAT:?soap_type@_ns2__submitEpochResultElement@@UBEHXZ
	DD	FLAT:?soap_default@_ns2__submitEpochResultElement@@UAEXPAUsoap@@@Z
	DD	FLAT:?soap_serialize@_ns2__submitEpochResultElement@@UBEXPAUsoap@@@Z
	DD	FLAT:?soap_put@_ns2__submitEpochResultElement@@UBEHPAUsoap@@PBD1@Z
	DD	FLAT:?soap_out@_ns2__submitEpochResultElement@@UBEHPAUsoap@@PBDH1@Z
	DD	FLAT:?soap_get@_ns2__submitEpochResultElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:?soap_in@_ns2__submitEpochResultElement@@UAEPAXPAUsoap@@PBD1@Z
	DD	FLAT:??_E_ns2__submitEpochResultElement@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4_ns2__submitEpochResultElement@@6B@
rdata$r	SEGMENT
??_R4_ns2__submitEpochResultElement@@6B@ DD 00H		; _ns2__submitEpochResultElement::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_ns2__submitEpochResultElement@@@8
	DD	FLAT:??_R3_ns2__submitEpochResultElement@@8
rdata$r	ENDS
;	COMDAT ??_R3_ns2__submitEpochResultElement@@8
rdata$r	SEGMENT
??_R3_ns2__submitEpochResultElement@@8 DD 00H		; _ns2__submitEpochResultElement::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_ns2__submitEpochResultElement@@8
rdata$r	ENDS
;	COMDAT ??_R2_ns2__submitEpochResultElement@@8
rdata$r	SEGMENT
??_R2_ns2__submitEpochResultElement@@8 DD FLAT:??_R1A@?0A@EA@_ns2__submitEpochResultElement@@8 ; _ns2__submitEpochResultElement::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_ns2__submitEpochResultElement@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_ns2__submitEpochResultElement@@8 DD FLAT:??_R0?AV_ns2__submitEpochResultElement@@@8 ; _ns2__submitEpochResultElement::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_ns2__submitEpochResultElement@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_ns2__submitEpochResultElement@@@8
_DATA	SEGMENT
??_R0?AV_ns2__submitEpochResultElement@@@8 DD FLAT:??_7type_info@@6B@ ; _ns2__submitEpochResultElement `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_ns2__submitEpochResultElement@@', 00H
_DATA	ENDS
;	COMDAT ??_7Channel@DRAMsimII@@6B@
CONST	SEGMENT
??_7Channel@DRAMsimII@@6B@ DD FLAT:??_R4Channel@DRAMsimII@@6B@ ; DRAMsimII::Channel::`vftable'
	DD	FLAT:?readNextCommand@Channel@DRAMsimII@@MBEPBVCommand@2@XZ
	DD	FLAT:?minProtocolGap@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z
	DD	FLAT:?earliestExecuteTime@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z
	DD	FLAT:?earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z
	DD	FLAT:??_EChannel@DRAMsimII@@UAEPAXI@Z
	DD	FLAT:?nextTick@Channel@DRAMsimII@@UBE_JXZ
	DD	FLAT:?moveToTime@Channel@DRAMsimII@@UAEX_J@Z
CONST	ENDS
;	COMDAT ??_R4Channel@DRAMsimII@@6B@
rdata$r	SEGMENT
??_R4Channel@DRAMsimII@@6B@ DD 00H			; DRAMsimII::Channel::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVChannel@DRAMsimII@@@8
	DD	FLAT:??_R3Channel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R3Channel@DRAMsimII@@8
rdata$r	SEGMENT
??_R3Channel@DRAMsimII@@8 DD 00H			; DRAMsimII::Channel::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Channel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R2Channel@DRAMsimII@@8
rdata$r	SEGMENT
??_R2Channel@DRAMsimII@@8 DD FLAT:??_R1A@?0A@EA@Channel@DRAMsimII@@8 ; DRAMsimII::Channel::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Channel@DRAMsimII@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Channel@DRAMsimII@@8 DD FLAT:??_R0?AVChannel@DRAMsimII@@@8 ; DRAMsimII::Channel::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Channel@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVChannel@DRAMsimII@@@8
_DATA	SEGMENT
??_R0?AVChannel@DRAMsimII@@@8 DD FLAT:??_7type_info@@6B@ ; DRAMsimII::Channel `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVChannel@DRAMsimII@@', 00H
_DATA	ENDS
;	COMDAT ??_7Event@DRAMsimII@@6B@
CONST	SEGMENT
??_7Event@DRAMsimII@@6B@ DD FLAT:??_R4Event@DRAMsimII@@6B@ ; DRAMsimII::Event::`vftable'
	DD	FLAT:??_EEvent@DRAMsimII@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4Event@DRAMsimII@@6B@
rdata$r	SEGMENT
??_R4Event@DRAMsimII@@6B@ DD 00H			; DRAMsimII::Event::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVEvent@DRAMsimII@@@8
	DD	FLAT:??_R3Event@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R3Event@DRAMsimII@@8
rdata$r	SEGMENT
??_R3Event@DRAMsimII@@8 DD 00H				; DRAMsimII::Event::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Event@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R2Event@DRAMsimII@@8
rdata$r	SEGMENT
??_R2Event@DRAMsimII@@8 DD FLAT:??_R1A@?0A@EA@Event@DRAMsimII@@8 ; DRAMsimII::Event::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Event@DRAMsimII@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Event@DRAMsimII@@8 DD FLAT:??_R0?AVEvent@DRAMsimII@@@8 ; DRAMsimII::Event::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Event@DRAMsimII@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVEvent@DRAMsimII@@@8
_DATA	SEGMENT
??_R0?AVEvent@DRAMsimII@@@8 DD FLAT:??_7type_info@@6B@	; DRAMsimII::Event `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVEvent@DRAMsimII@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCEECEBO@T?$FL?$AA@
CONST	SEGMENT
??_C@_02DCEECEBO@T?$FL?$AA@ DB 'T[', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JPECMJL@?$FN?5ch?$FL?$AA@
CONST	SEGMENT
??_C@_05JPECMJL@?$FN?5ch?$FL?$AA@ DB '] ch[', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EJENEINP@precharge?7?$CI?$AA@
CONST	SEGMENT
??_C@_0M@EJENEINP@precharge?7?$CI?$AA@ DB 'precharge', 09H, '(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MCOFLILF@refresh?$CI?$AA@
CONST	SEGMENT
??_C@_08MCOFLILF@refresh?$CI?$AA@ DB 'refresh(', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LJALELK@?$CJ?$DL?$AA@
CONST	SEGMENT
??_C@_02LJALELK@?$CJ?$DL?$AA@ DB ');', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EDCPHMCE@activate?7?$CI?$AA@
CONST	SEGMENT
??_C@_0L@EDCPHMCE@activate?7?$CI?$AA@ DB 'activate', 09H, '(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JDIKLHND@write?7?7?$CI?$AA@
CONST	SEGMENT
??_C@_08JDIKLHND@write?7?7?$CI?$AA@ DB 'write', 09H, 09H, '(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCHNCKN@?0?70?0?710?$CJ?$DL?5?1?1?$AA@
CONST	SEGMENT
??_C@_0N@DCHNCKN@?0?70?0?710?$CJ?$DL?5?1?1?$AA@ DB ',', 09H, '0,', 09H, '1'
	DB	'0); //', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNLIACOE@read?7?7?$CI?$AA@
CONST	SEGMENT
??_C@_07CNLIACOE@read?7?7?$CI?$AA@ DB 'read', 09H, 09H, '(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02OACLCCCA@?0?7?$AA@
CONST	SEGMENT
??_C@_02OACLCCCA@?0?7?$AA@ DB ',', 09H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HFDGOAGB@nop?$CI?$AA@
CONST	SEGMENT
??_C@_04HFDGOAGB@nop?$CI?$AA@ DB 'nop(', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DJFABFLL@?$CJ?$DL?5?1?1?$AA@
CONST	SEGMENT
??_C@_05DJFABFLL@?$CJ?$DL?5?1?1?$AA@ DB '); //', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JLFGGPAL@Unsupported?5command?5encountered?4@
CONST	SEGMENT
??_C@_0CB@JLFGGPAL@Unsupported?5command?5encountered?4@ DB 'Unsupported c'
	DB	'ommand encountered.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IGPJINBF@Unknown?5command?5type?$AA@
CONST	SEGMENT
??_C@_0BF@IGPJINBF@Unknown?5command?5type?$AA@ DB 'Unknown command type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@ENOGKDBL@This?5configuration?5and?5algorithm@
CONST	SEGMENT
??_C@_0DO@ENOGKDBL@This?5configuration?5and?5algorithm@ DB 'This configur'
	DB	'ation and algorithm combination is not supported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DBBBPOIP@warn?3?5unhandled?5command?5type?$AA@
CONST	SEGMENT
??_C@_0BN@DBBBPOIP@warn?3?5unhandled?5command?5type?$AA@ DB 'warn: unhand'
	DB	'led command type', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@LMCLJHD@error?3?5row?5activate?5command?5not?5@
CONST	SEGMENT
??_C@_0DO@LMCLJHD@error?3?5row?5activate?5command?5not?5@ DB 'error: row '
	DB	'activate command not followed by a column command.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IIOHHIBJ@warn?3?5Unhandled?5command?5type?4?$AA@
CONST	SEGMENT
??_C@_0BO@IIOHHIBJ@warn?3?5Unhandled?5command?5type?4?$AA@ DB 'warn: Unha'
	DB	'ndled command type.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@NJGLEKNI@error?3?5Found?5a?5row?5activate?5not?5@
CONST	SEGMENT
??_C@_0DO@NJGLEKNI@error?3?5Found?5a?5row?5activate?5not?5@ DB 'error: Fo'
	DB	'und a row activate not followed by a column command.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PMAPFHOL@Unhandled?5row?5buffer?5management?5@
CONST	SEGMENT
??_C@_0CH@PMAPFHOL@Unhandled?5row?5buffer?5management?5@ DB 'Unhandled ro'
	DB	'w buffer management policy', 00H		; `string'
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@3@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@3@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_impl<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &,boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_basic_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@3@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_basic_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@3@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_basic_impl<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &,boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
CONST	ENDS
;	COMDAT ?value@?$is_abstract_imp@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_abstract_imp@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_abstract_imp<boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@U?$thread_move_t@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > > >::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &>::value
CONST	ENDS
;	COMDAT ??_C@_0O@JDGPKHMJ@?9Psys?$CIWR?$CJ?5ch?$FL?$AA@
CONST	SEGMENT
??_C@_0O@JDGPKHMJ@?9Psys?$CIWR?$CJ?5ch?$FL?$AA@ DB '-Psys(WR) ch[', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NPIBAAFJ@?9Psys?$CIRD?$CJ?5ch?$FL?$AA@
CONST	SEGMENT
??_C@_0O@NPIBAAFJ@?9Psys?$CIRD?$CJ?5ch?$FL?$AA@ DB '-Psys(RD) ch[', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OPIKMKPA@?9Psys?$CIPRE_STBY?$CJ?5ch?$FL?$AA@
CONST	SEGMENT
??_C@_0BE@OPIKMKPA@?9Psys?$CIPRE_STBY?$CJ?5ch?$FL?$AA@ DB '-Psys(PRE_STBY'
	DB	') ch[', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JAGAIFBA@?9Psys?$CIACT?$CJ?5ch?$FL?$AA@
CONST	SEGMENT
??_C@_0P@JAGAIFBA@?9Psys?$CIACT?$CJ?5ch?$FL?$AA@ DB '-Psys(ACT) ch[', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EOFJECFB@?$HN?5mW?5tRRD?$FL?$AA@
CONST	SEGMENT
??_C@_0L@EOFJECFB@?$HN?5mW?5tRRD?$FL?$AA@ DB '} mW tRRD[', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OKBLMJCG@?9Psys?$CIACT_STBY?$CJ?5ch?$FL?$AA@
CONST	SEGMENT
??_C@_0BE@OKBLMJCG@?9Psys?$CIACT_STBY?$CJ?5ch?$FL?$AA@ DB '-Psys(ACT_STBY'
	DB	') ch[', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@
CONST	SEGMENT
??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@ DB '] {', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CNFIBAEC@?$HN?5mW?$AA@
CONST	SEGMENT
??_C@_04CNFIBAEC@?$HN?5mW?$AA@ DB '} mW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CNIHCHBK@Unknown?5transaction?5ordering?5alg@
CONST	SEGMENT
??_C@_0CI@CNIHCHBK@Unknown?5transaction?5ordering?5alg@ DB 'Unknown trans'
	DB	'action ordering algorithm.', 00H		; `string'
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@AAVthread@boost@@U?$thread_move_t@Vthread@boost@@@detail@2@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@AAVthread@boost@@U?$thread_move_t@Vthread@boost@@@detail@2@@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_impl<boost::thread &,boost::detail::thread_move_t<boost::thread> >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_basic_impl@AAVthread@boost@@U?$thread_move_t@Vthread@boost@@@detail@2@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_basic_impl@AAVthread@boost@@U?$thread_move_t@Vthread@boost@@@detail@2@@detail@boost@@2_NB DB 01H ; boost::detail::is_convertible_basic_impl<boost::thread &,boost::detail::thread_move_t<boost::thread> >::value
CONST	ENDS
;	COMDAT ?value@?$is_abstract_imp@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_abstract_imp@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_abstract_imp<boost::detail::thread_move_t<boost::thread> >::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::thread> >::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@AAVthread@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@AAVthread@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::thread &>::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::thread> &>::value
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_arithmetic_impl<boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
CONST	ENDS
;	COMDAT ?value@?$is_abstract_imp@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_abstract_imp@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@detail@boost@@@detail@boost@@2_NB DB 00H ; boost::detail::is_abstract_imp<boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_basic_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@23@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_basic_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@23@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_basic_impl<boost::detail::thread_move_t<boost::thread> &,boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
CONST	ENDS
;	COMDAT ?value@?$is_convertible_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@23@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_convertible_impl@AAU?$thread_move_t@Vthread@boost@@@detail@boost@@U?$thread_move_t@U?$thread_move_t@Vthread@boost@@@detail@boost@@@23@@detail@boost@@2_NB DB 00H ; boost::detail::is_convertible_impl<boost::detail::thread_move_t<boost::thread> &,boost::detail::thread_move_t<boost::detail::thread_move_t<boost::thread> > >::value
CONST	ENDS
;	COMDAT ?event_set_flag_value@basic_timed_mutex@detail@boost@@2JB
CONST	SEGMENT
?event_set_flag_value@basic_timed_mutex@detail@boost@@2JB DD 040000000H ; boost::detail::basic_timed_mutex::event_set_flag_value
CONST	ENDS
;	COMDAT ?lock_flag_value@basic_timed_mutex@detail@boost@@2JB
CONST	SEGMENT
?lock_flag_value@basic_timed_mutex@detail@boost@@2JB DD 080000000H ; boost::detail::basic_timed_mutex::lock_flag_value
CONST	ENDS
;	COMDAT ?event_set_flag_bit@basic_timed_mutex@detail@boost@@2EB
CONST	SEGMENT
?event_set_flag_bit@basic_timed_mutex@detail@boost@@2EB DB 01eH ; boost::detail::basic_timed_mutex::event_set_flag_bit
CONST	ENDS
;	COMDAT ?lock_flag_bit@basic_timed_mutex@detail@boost@@2EB
CONST	SEGMENT
?lock_flag_bit@basic_timed_mutex@detail@boost@@2EB DB 01fH ; boost::detail::basic_timed_mutex::lock_flag_bit
CONST	ENDS
;	COMDAT ?max_non_infinite_wait@timeout@detail@boost@@2KB
CONST	SEGMENT
?max_non_infinite_wait@timeout@detail@boost@@2KB DD 0fffffffeH ; boost::detail::timeout::max_non_infinite_wait
CONST	ENDS
;	COMDAT __TI3?AVthread_resource_error@boost@@
xdata$x	SEGMENT
__TI3?AVthread_resource_error@boost@@ DD 00H
	DD	FLAT:??1thread_resource_error@boost@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVthread_resource_error@boost@@
xdata$x	ENDS
;	COMDAT __CTA3?AVthread_resource_error@boost@@
xdata$x	SEGMENT
__CTA3?AVthread_resource_error@boost@@ DD 03H
	DD	FLAT:__CT??_R0?AVthread_resource_error@boost@@@8??0thread_resource_error@boost@@QAE@ABV01@@Z16
	DD	FLAT:__CT??_R0?AVthread_exception@boost@@@8??0thread_exception@boost@@QAE@ABV01@@Z16
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVthread_exception@boost@@@8??0thread_exception@boost@@QAE@ABV01@@Z16
xdata$x	SEGMENT
__CT??_R0?AVthread_exception@boost@@@8??0thread_exception@boost@@QAE@ABV01@@Z16 DD 00H
	DD	FLAT:??_R0?AVthread_exception@boost@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	010H
	DD	FLAT:??0thread_exception@boost@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVthread_resource_error@boost@@@8??0thread_resource_error@boost@@QAE@ABV01@@Z16
xdata$x	SEGMENT
__CT??_R0?AVthread_resource_error@boost@@@8??0thread_resource_error@boost@@QAE@ABV01@@Z16 DD 00H
	DD	FLAT:??_R0?AVthread_resource_error@boost@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	010H
	DD	FLAT:??0thread_resource_error@boost@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVthread_exception@boost@@@8
_DATA	SEGMENT
??_R0?AVthread_exception@boost@@@8 DD FLAT:??_7type_info@@6B@ ; boost::thread_exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVthread_exception@boost@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVthread_resource_error@boost@@@8
_DATA	SEGMENT
??_R0?AVthread_resource_error@boost@@@8 DD FLAT:??_7type_info@@6B@ ; boost::thread_resource_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVthread_resource_error@boost@@', 00H
_DATA	ENDS
;	COMDAT ?tick_per_second@millisec_posix_time_system_config@posix_time@boost@@2_JB
CONST	SEGMENT
?tick_per_second@millisec_posix_time_system_config@posix_time@boost@@2_JB DQ 00000000000f4240H ; boost::posix_time::millisec_posix_time_system_config::tick_per_second
CONST	ENDS
;	COMDAT ?ticks_per_second@?$time_resolution_traits@Utime_resolution_traits_adapted64_impl@date_time@boost@@$04$0PECEA@$05J@date_time@boost@@2_JB
CONST	SEGMENT
?ticks_per_second@?$time_resolution_traits@Utime_resolution_traits_adapted64_impl@date_time@boost@@$04$0PECEA@$05J@date_time@boost@@2_JB DQ 00000000000f4240H ; boost::date_time::time_resolution_traits<boost::date_time::time_resolution_traits_adapted64_impl,5,1000000,6,long>::ticks_per_second
CONST	ENDS
;	COMDAT ?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_day_of_year@gregorian@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_day_of_year@gregorian@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_day_of_year>::value
CONST	ENDS
;	COMDAT ?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_month@gregorian@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_month@gregorian@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_month>::value
CONST	ENDS
;	COMDAT ?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_year@gregorian@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_year@gregorian@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_year>::value
CONST	ENDS
;	COMDAT ?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_day_of_month@gregorian@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_day_of_month@gregorian@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_day_of_month>::value
CONST	ENDS
;	COMDAT ?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_weekday@gregorian@boost@@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_base_and_derived_impl@Vexception@std@@Ubad_weekday@gregorian@boost@@@detail@boost@@2_NB DB 01H ; boost::detail::is_base_and_derived_impl<std::exception,boost::gregorian::bad_weekday>::value
CONST	ENDS
;	COMDAT ?namespaces@?4???0DRAMsimWSSoapHttp@@QAE@XZ@4QBUNamespace@@B
CONST	SEGMENT
?namespaces@?4???0DRAMsimWSSoapHttp@@QAE@XZ@4QBUNamespace@@B DD FLAT:??_C@_08EPBICJDL@SOAP?9ENV?$AA@ ; `DRAMsimWSSoapHttp::DRAMsimWSSoapHttp'::`5'::namespaces
	DD	FLAT:??_C@_0CK@KLFMLHIL@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
	DD	FLAT:??_C@_0CC@LBIMFHBE@http?3?1?1www?4w3?4org?1?$CK?1soap?9envelop@
	DD	00H
	DD	FLAT:??_C@_08HIKNMPCP@SOAP?9ENC?$AA@
	DD	FLAT:??_C@_0CK@OLCGFEIF@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
	DD	FLAT:??_C@_0CC@BEGEDPPO@http?3?1?1www?4w3?4org?1?$CK?1soap?9encodin@
	DD	00H
	DD	FLAT:??_C@_03JCLIKOHH@xsi?$AA@
	DD	FLAT:??_C@_0CK@FAJBIKFJ@http?3?1?1www?4w3?4org?12001?1XMLSchema@
	DD	FLAT:??_C@_0CH@GIPGGJFA@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?9in@
	DD	00H
	DD	FLAT:??_C@_03CHBGNADK@xsd?$AA@
	DD	FLAT:??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchema@
	DD	FLAT:??_C@_0BO@GGEJJCPG@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?$AA@
	DD	00H
	DD	FLAT:??_C@_03JFKIHBGI@ns1?$AA@
	DD	FLAT:??_C@_0BI@BIJMMJIB@http?3?1?1DRAMsimReporter?1?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_03LOIFCCKL@ns2?$AA@
	DD	FLAT:??_C@_0BO@FBMBEAKI@http?3?1?1DRAMsimReporter?1types?1?$AA@
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ??_C@_0BO@FBMBEAKI@http?3?1?1DRAMsimReporter?1types?1?$AA@
CONST	SEGMENT
??_C@_0BO@FBMBEAKI@http?3?1?1DRAMsimReporter?1types?1?$AA@ DB 'http://DRA'
	DB	'MsimReporter/types/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LOIFCCKL@ns2?$AA@
CONST	SEGMENT
??_C@_03LOIFCCKL@ns2?$AA@ DB 'ns2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BIJMMJIB@http?3?1?1DRAMsimReporter?1?$AA@
CONST	SEGMENT
??_C@_0BI@BIJMMJIB@http?3?1?1DRAMsimReporter?1?$AA@ DB 'http://DRAMsimRep'
	DB	'orter/', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03JFKIHBGI@ns1?$AA@
CONST	SEGMENT
??_C@_03JFKIHBGI@ns1?$AA@ DB 'ns1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GGEJJCPG@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?$AA@
CONST	SEGMENT
??_C@_0BO@GGEJJCPG@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?$AA@ DB 'http:'
	DB	'//www.w3.org/*/XMLSchema', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchema@
CONST	SEGMENT
??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchema@ DB 'http://ww'
	DB	'w.w3.org/2001/XMLSchema', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CHBGNADK@xsd?$AA@
CONST	SEGMENT
??_C@_03CHBGNADK@xsd?$AA@ DB 'xsd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GIPGGJFA@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?9in@
CONST	SEGMENT
??_C@_0CH@GIPGGJFA@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?9in@ DB 'http:'
	DB	'//www.w3.org/*/XMLSchema-instance', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FAJBIKFJ@http?3?1?1www?4w3?4org?12001?1XMLSchema@
CONST	SEGMENT
??_C@_0CK@FAJBIKFJ@http?3?1?1www?4w3?4org?12001?1XMLSchema@ DB 'http://ww'
	DB	'w.w3.org/2001/XMLSchema-instance', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JCLIKOHH@xsi?$AA@
CONST	SEGMENT
??_C@_03JCLIKOHH@xsi?$AA@ DB 'xsi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BEGEDPPO@http?3?1?1www?4w3?4org?1?$CK?1soap?9encodin@
CONST	SEGMENT
??_C@_0CC@BEGEDPPO@http?3?1?1www?4w3?4org?1?$CK?1soap?9encodin@ DB 'http:'
	DB	'//www.w3.org/*/soap-encoding', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OLCGFEIF@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
CONST	SEGMENT
??_C@_0CK@OLCGFEIF@http?3?1?1schemas?4xmlsoap?4org?1soap?1@ DB 'http://sc'
	DB	'hemas.xmlsoap.org/soap/encoding/', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HIKNMPCP@SOAP?9ENC?$AA@
CONST	SEGMENT
??_C@_08HIKNMPCP@SOAP?9ENC?$AA@ DB 'SOAP-ENC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LBIMFHBE@http?3?1?1www?4w3?4org?1?$CK?1soap?9envelop@
CONST	SEGMENT
??_C@_0CC@LBIMFHBE@http?3?1?1www?4w3?4org?1?$CK?1soap?9envelop@ DB 'http:'
	DB	'//www.w3.org/*/soap-envelope', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KLFMLHIL@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
CONST	SEGMENT
??_C@_0CK@KLFMLHIL@http?3?1?1schemas?4xmlsoap?4org?1soap?1@ DB 'http://sc'
	DB	'hemas.xmlsoap.org/soap/envelope/', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPBICJDL@SOAP?9ENV?$AA@
CONST	SEGMENT
??_C@_08EPBICJDL@SOAP?9ENV?$AA@ DB 'SOAP-ENV', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LMOMBNJL@http?3?1?1id2?4gentag?4com?37777?1DRAMs@
CONST	SEGMENT
??_C@_0DJ@LMOMBNJL@http?3?1?1id2?4gentag?4com?37777?1DRAMs@ DB 'http://id'
	DB	'2.gentag.com:7777/DRAMsim/DRAMsimWSSoapHttpPort', 00H ; `string'
CONST	ENDS
;	COMDAT ?_EEM_DS@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@2HB DD 01H ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_EEM_DS
CONST	ENDS
;	COMDAT ?value@?$is_arithmetic_impl@_J@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_arithmetic_impl@_J@detail@boost@@2_NB DB 01H ; boost::detail::is_arithmetic_impl<__int64>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_impl@_J@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_impl@_J@detail@boost@@2_NB DB 00H	; boost::detail::is_pointer_impl<__int64>::value
CONST	ENDS
;	COMDAT ?value@?$result_@_J@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB
CONST	SEGMENT
?value@?$result_@_J@?$is_mem_fun_pointer_select@$0A@@detail@boost@@2_NB DB 00H ; boost::detail::is_mem_fun_pointer_select<0>::result_<__int64>::value
CONST	ENDS
;	COMDAT ?value@?$is_pointer_helper@_J@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_pointer_helper@_J@detail@boost@@2_NB DB 00H	; boost::detail::is_pointer_helper<__int64>::value
CONST	ENDS
;	COMDAT ?is_volatile@?$cv_traits_imp@PA_J@detail@boost@@2_NB
CONST	SEGMENT
?is_volatile@?$cv_traits_imp@PA_J@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<__int64 *>::is_volatile
CONST	ENDS
;	COMDAT ?is_const@?$cv_traits_imp@PA_J@detail@boost@@2_NB
CONST	SEGMENT
?is_const@?$cv_traits_imp@PA_J@detail@boost@@2_NB DB 00H ; boost::detail::cv_traits_imp<__int64 *>::is_const
CONST	ENDS
;	COMDAT ?value@?$not_satisfied@U?$SGIAssignableConcept@_J@boost@@@concept@boost@@2_NB
CONST	SEGMENT
?value@?$not_satisfied@U?$SGIAssignableConcept@_J@boost@@@concept@boost@@2_NB DB 00H ; boost::concept::not_satisfied<boost::SGIAssignableConcept<__int64> >::value
CONST	ENDS
;	COMDAT ?value@?$not_satisfied@U?$usage_requirements@U?$SGIAssignable@_J@boost@@@concept@boost@@@concept@boost@@2_NB
CONST	SEGMENT
?value@?$not_satisfied@U?$usage_requirements@U?$SGIAssignable@_J@boost@@@concept@boost@@@concept@boost@@2_NB DB 00H ; boost::concept::not_satisfied<boost::concept::usage_requirements<boost::SGIAssignable<__int64> > >::value
CONST	ENDS
;	COMDAT ?value@?$is_empty_impl@$$CDX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_empty_impl@$$CDX@detail@boost@@2_NB DB 00H	; boost::detail::is_empty_impl<void const volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_empty_impl@$$CCX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_empty_impl@$$CCX@detail@boost@@2_NB DB 00H	; boost::detail::is_empty_impl<void volatile >::value
CONST	ENDS
;	COMDAT ?value@?$is_empty_impl@$$CBX@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_empty_impl@$$CBX@detail@boost@@2_NB DB 00H	; boost::detail::is_empty_impl<void const >::value
CONST	ENDS
;	COMDAT ?value@?$is_empty_impl@X@detail@boost@@2_NB
CONST	SEGMENT
?value@?$is_empty_impl@X@detail@boost@@2_NB DB 00H	; boost::detail::is_empty_impl<void>::value
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_namespaces DD	FLAT:??_C@_08EPBICJDL@SOAP?9ENV?$AA@
	DD	FLAT:??_C@_0CK@KLFMLHIL@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
	DD	FLAT:??_C@_0CC@LBIMFHBE@http?3?1?1www?4w3?4org?1?$CK?1soap?9envelop@
	DD	00H
	DD	FLAT:??_C@_08HIKNMPCP@SOAP?9ENC?$AA@
	DD	FLAT:??_C@_0CK@OLCGFEIF@http?3?1?1schemas?4xmlsoap?4org?1soap?1@
	DD	FLAT:??_C@_0CC@BEGEDPPO@http?3?1?1www?4w3?4org?1?$CK?1soap?9encodin@
	DD	00H
	DD	FLAT:??_C@_03JCLIKOHH@xsi?$AA@
	DD	FLAT:??_C@_0CK@FAJBIKFJ@http?3?1?1www?4w3?4org?12001?1XMLSchema@
	DD	FLAT:??_C@_0CH@GIPGGJFA@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?9in@
	DD	00H
	DD	FLAT:??_C@_03CHBGNADK@xsd?$AA@
	DD	FLAT:??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchema@
	DD	FLAT:??_C@_0BO@GGEJJCPG@http?3?1?1www?4w3?4org?1?$CK?1XMLSchema?$AA@
	DD	00H
	DD	FLAT:??_C@_03JFKIHBGI@ns1?$AA@
	DD	FLAT:??_C@_0BI@BIJMMJIB@http?3?1?1DRAMsimReporter?1?$AA@
	DD	00H
	DD	00H
	DD	FLAT:??_C@_03LOIFCCKL@ns2?$AA@
	DD	FLAT:??_C@_0BO@FBMBEAKI@http?3?1?1DRAMsimReporter?1types?1?$AA@
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
PUBLIC	?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Channel::doPowerCalculation
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\get_pointer.hpp
;	COMDAT ??$get_pointer@VChannel@DRAMsimII@@@boost@@YAPAVChannel@DRAMsimII@@PAV12@@Z
_TEXT	SEGMENT
??$get_pointer@VChannel@DRAMsimII@@@boost@@YAPAVChannel@DRAMsimII@@PAV12@@Z PROC ; boost::get_pointer<DRAMsimII::Channel>, COMDAT
; _p$ = eax

; 20   :     return p;
; 21   : }

	ret	0
??$get_pointer@VChannel@DRAMsimII@@@boost@@YAPAVChannel@DRAMsimII@@PAV12@@Z ENDP ; boost::get_pointer<DRAMsimII::Channel>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n@5
	push	esi
	npad	7
$LL3@Fill_n@5:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@5
	pop	esi
$LN1@Fill_n@5:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PANPANV?$allocator@N@std@@@std@@YAPANPAN00AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PANPANV?$allocator@N@std@@@std@@YAPANPAN00AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<double *,double *,std::allocator<double> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PANPANV?$allocator@N@std@@@std@@YAPANPAN00AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<double *,double *,std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAMIM@std@@YAXPAMIABMU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAMIM@std@@YAXPAMIABMU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<float *,unsigned int,float>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n@6
$LL3@Fill_n@6:

; 3198 : 		*_First = _Val;

	fld	DWORD PTR [edx]
	dec	eax
	fstp	DWORD PTR [ecx]
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@6
$LN1@Fill_n@6:

; 3199 : 	}

	ret	0
??$_Fill_n@PAMIM@std@@YAXPAMIABMU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<float *,unsigned int,float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n@7
	push	esi
	npad	7
$LL3@Fill_n@7:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@7
	pop	esi
$LN1@Fill_n@7:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<__int64 *,unsigned int,__int64>, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	eax, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	ecx, ecx
	jbe	SHORT $LN1@Fill_n@8
	push	esi
	npad	7
$LL3@Fill_n@8:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL3@Fill_n@8
	pop	esi
$LN1@Fill_n@8:

; 3199 : 	}

	ret	0
??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<__int64 *,unsigned int,__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PANIN@std@@YAXPANIABNU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PANIN@std@@YAXPANIABNU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<double *,unsigned int,double>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n@9
$LL3@Fill_n@9:

; 3198 : 		*_First = _Val;

	fld	QWORD PTR [edx]
	dec	eax
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	test	eax, eax
	ja	SHORT $LL3@Fill_n@9
$LN1@Fill_n@9:

; 3199 : 	}

	ret	0
??$_Fill_n@PANIN@std@@YAXPANIABNU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<double *,unsigned int,double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n@10
	push	esi
	npad	7
$LL3@Fill_n@10:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@10
	pop	esi
$LN1@Fill_n@10:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEPBNXZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEPBNXZ PROC ; std::_Vector_const_iterator<double,std::allocator<double> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEPBNXZ ENDP ; std::_Vector_const_iterator<double,std::allocator<double> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEPBHXZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEPBHXZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEPBHXZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEPAPAVTransaction@DRAMsimII@@XZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEPAPAVTransaction@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 305  : 		return (this->_Myptr);

	mov	eax, DWORD PTR [eax+4]

; 306  : 		}

	ret	0
?_Checked_iterator_base@?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEPAPAVTransaction@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
_TEXT	ENDS
;	COMDAT ?get@?$value@_J@_bi@boost@@QAEAA_JXZ
_TEXT	SEGMENT
?get@?$value@_J@_bi@boost@@QAEAA_JXZ PROC		; boost::_bi::value<__int64>::get, COMDAT
; _this$ = eax

; 118  :     T & get() { return t_; }

	ret	0
?get@?$value@_J@_bi@boost@@QAEAA_JXZ ENDP		; boost::_bi::value<__int64>::get
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get@?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAEAAV?$vector@NV?$allocator@N@std@@@std@@XZ
_TEXT	SEGMENT
?get@?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAEAAV?$vector@NV?$allocator@N@std@@@std@@XZ PROC ; boost::_bi::value<std::vector<double,std::allocator<double> > >::get, COMDAT
; _this$ = eax

; 118  :     T & get() { return t_; }

	ret	0
?get@?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAEAAV?$vector@NV?$allocator@N@std@@@std@@XZ ENDP ; boost::_bi::value<std::vector<double,std::allocator<double> > >::get
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get@?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@XZ
_TEXT	SEGMENT
?get@?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@XZ PROC ; boost::_bi::value<std::vector<int,std::allocator<int> > >::get, COMDAT
; _this$ = eax

; 118  :     T & get() { return t_; }

	ret	0
?get@?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@XZ ENDP ; boost::_bi::value<std::vector<int,std::allocator<int> > >::get
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get@?$value@N@_bi@boost@@QAEAANXZ
_TEXT	SEGMENT
?get@?$value@N@_bi@boost@@QAEAANXZ PROC			; boost::_bi::value<double>::get, COMDAT
; _this$ = eax

; 118  :     T & get() { return t_; }

	ret	0
?get@?$value@N@_bi@boost@@QAEAANXZ ENDP			; boost::_bi::value<double>::get
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get@?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAEAAPAVChannel@DRAMsimII@@XZ
_TEXT	SEGMENT
?get@?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAEAAPAVChannel@DRAMsimII@@XZ PROC ; boost::_bi::value<DRAMsimII::Channel *>::get, COMDAT
; _this$ = eax

; 118  :     T & get() { return t_; }

	ret	0
?get@?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAEAAPAVChannel@DRAMsimII@@XZ ENDP ; boost::_bi::value<DRAMsimII::Channel *>::get
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
_TEXT	ENDS
;	COMDAT ??$?A_J@list0@_bi@boost@@QBEAA_JAAV?$value@_J@12@@Z
_TEXT	SEGMENT
??$?A_J@list0@_bi@boost@@QBEAA_JAAV?$value@_J@12@@Z PROC ; boost::_bi::list0::operator[]<__int64>, COMDAT
; _v$ = eax

; 170  :     template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

	ret	0
??$?A_J@list0@_bi@boost@@QBEAA_JAAV?$value@_J@12@@Z ENDP ; boost::_bi::list0::operator[]<__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?AV?$vector@NV?$allocator@N@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@NV?$allocator@N@std@@@std@@AAV?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z
_TEXT	SEGMENT
??$?AV?$vector@NV?$allocator@N@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@NV?$allocator@N@std@@@std@@AAV?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z PROC ; boost::_bi::list0::operator[]<std::vector<double,std::allocator<double> > >, COMDAT
; _v$ = eax

; 170  :     template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

	ret	0
??$?AV?$vector@NV?$allocator@N@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@NV?$allocator@N@std@@@std@@AAV?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z ENDP ; boost::_bi::list0::operator[]<std::vector<double,std::allocator<double> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?AV?$vector@HV?$allocator@H@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@HV?$allocator@H@std@@@std@@AAV?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z
_TEXT	SEGMENT
??$?AV?$vector@HV?$allocator@H@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@HV?$allocator@H@std@@@std@@AAV?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z PROC ; boost::_bi::list0::operator[]<std::vector<int,std::allocator<int> > >, COMDAT
; _v$ = eax

; 170  :     template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

	ret	0
??$?AV?$vector@HV?$allocator@H@std@@@std@@@list0@_bi@boost@@QBEAAV?$vector@HV?$allocator@H@std@@@std@@AAV?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z ENDP ; boost::_bi::list0::operator[]<std::vector<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?AN@list0@_bi@boost@@QBEAANAAV?$value@N@12@@Z
_TEXT	SEGMENT
??$?AN@list0@_bi@boost@@QBEAANAAV?$value@N@12@@Z PROC	; boost::_bi::list0::operator[]<double>, COMDAT
; _v$ = eax

; 170  :     template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

	ret	0
??$?AN@list0@_bi@boost@@QBEAANAAV?$value@N@12@@Z ENDP	; boost::_bi::list0::operator[]<double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?APAVChannel@DRAMsimII@@@list0@_bi@boost@@QBEAAPAVChannel@DRAMsimII@@AAV?$value@PAVChannel@DRAMsimII@@@12@@Z
_TEXT	SEGMENT
??$?APAVChannel@DRAMsimII@@@list0@_bi@boost@@QBEAAPAVChannel@DRAMsimII@@AAV?$value@PAVChannel@DRAMsimII@@@12@@Z PROC ; boost::_bi::list0::operator[]<DRAMsimII::Channel *>, COMDAT
; _v$ = eax

; 170  :     template<class T> T & operator[] (_bi::value<T> & v) const { return v.get(); }

	ret	0
??$?APAVChannel@DRAMsimII@@@list0@_bi@boost@@QBEAAPAVChannel@DRAMsimII@@AAV?$value@PAVChannel@DRAMsimII@@@12@@Z ENDP ; boost::_bi::list0::operator[]<DRAMsimII::Channel *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z
_TEXT	SEGMENT
??$_Iter_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z PROC ; std::_Iter_cat<DRAMsimII::Transaction * *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z ENDP ; std::_Iter_cat<DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z
_TEXT	SEGMENT
??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z PROC ; std::_Iter_cat<float *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z ENDP ; std::_Iter_cat<float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAU?$pair@I_J@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAU?$pair@I_J@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@PAPAU?$pair@I_J@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAU?$pair@I_J@0@@Z PROC ; std::_Iter_cat<std::pair<unsigned int,__int64> * *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAPAU?$pair@I_J@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAU?$pair@I_J@0@@Z ENDP ; std::_Iter_cat<std::pair<unsigned int,__int64> * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J@Z
_TEXT	SEGMENT
??$_Iter_cat@PA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J@Z PROC ; std::_Iter_cat<__int64 *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J@Z ENDP ; std::_Iter_cat<__int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN@Z
_TEXT	SEGMENT
??$_Iter_cat@PAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN@Z PROC ; std::_Iter_cat<double *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN@Z ENDP ; std::_Iter_cat<double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<double,std::allocator<double> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<double,std::allocator<double> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<int,std::allocator<int> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<int,std::allocator<int> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Equal@PB_JPB_JUforward_iterator_tag@std@@@std@@YA_NPB_J00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Equal@PB_JPB_JUforward_iterator_tag@std@@@std@@YA_NPB_J00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<__int64 const *,__int64 const *,std::forward_iterator_tag>, COMDAT
; __Last1$ = edx
; __First2$ = ecx

; 2991 : 	{	// compare [_First1, _Last1) to [First2, ...)

	mov	eax, DWORD PTR __First1$[esp-4]
	push	esi

; 2992 : 	for (; _First1 != _Last1; ++_First1, ++_First2)

	cmp	eax, edx
	je	SHORT $LN2@Equal@3
	npad	7
$LL4@Equal@3:

; 2993 : 		if (!(*_First1 == *_First2))

	mov	esi, DWORD PTR [eax]
	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN8@Equal@3
	mov	esi, DWORD PTR [eax+4]
	cmp	esi, DWORD PTR [ecx+4]
	jne	SHORT $LN8@Equal@3
	add	eax, 8
	add	ecx, 8
	cmp	eax, edx
	jne	SHORT $LL4@Equal@3
$LN2@Equal@3:

; 2995 : 	return (true);

	mov	al, 1
	pop	esi

; 2996 : 	}

	ret	0
$LN8@Equal@3:

; 2994 : 			return (false);

	xor	al, al
	pop	esi

; 2996 : 	}

	ret	0
??$_Equal@PB_JPB_JUforward_iterator_tag@std@@@std@@YA_NPB_J00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<__int64 const *,__int64 const *,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
_TEXT	ENDS
;	COMDAT ?unwrap@?$unwrapper@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@@_bi@boost@@SAAAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@3@AAV453@J@Z
_TEXT	SEGMENT
?unwrap@?$unwrapper@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@@_bi@boost@@SAAAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@3@AAV453@J@Z PROC ; boost::_bi::unwrapper<boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64> >::unwrap, COMDAT
; _f$ = eax

; 148  :         return f;
; 149  :     }

	ret	0
?unwrap@?$unwrapper@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@@_bi@boost@@SAAAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@3@AAV453@J@Z ENDP ; boost::_bi::unwrapper<boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64> >::unwrap
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEPB_JXZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEPB_JXZ PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEPB_JXZ ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;
; 2711 : 	if (_Off > 0)
; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H

; 2713 : 	return _Result;

	mov	eax, esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<DRAMsimII::Transaction * *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<double *,double *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;
; 2711 : 	if (_Off > 0)
; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H

; 2713 : 	return _Result;

	mov	eax, esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<double *,double *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAN@std@@YAPANAAPANU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAN@std@@YAPANAAPANU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<double *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAN@std@@YAPANAAPANU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;
; 2711 : 	if (_Off > 0)
; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H

; 2713 : 	return _Result;

	mov	eax, esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::pair<unsigned int,__int64> * *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::pair<unsigned int,__int64> * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@std@@YAPAPAVTransaction@DRAMsimII@@AAV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBNPANV?$allocator@N@std@@@std@@YAPANPBN0PANAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PBNPANV?$allocator@N@std@@@std@@YAPANPBN0PANAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<double const *,double *,std::allocator<double> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PBNPANV?$allocator@N@std@@@std@@YAPANPBN0PANAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<double const *,double *,std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@AAPAN@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@AAPAN@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<double,std::allocator<double> >,double *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@AAPAN@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<double,std::allocator<double> >,double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<double,std::allocator<double> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@std@@YAPBNAAV?$_Vector_const_iterator@NV?$allocator@N@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<double,std::allocator<double> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAMPAMV?$allocator@M@std@@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAMPAMV?$allocator@M@std@@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<float *,float *,std::allocator<float> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PAMPAMV?$allocator@M@std@@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<float *,float *,std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAM@std@@YAPAMAAPAMU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAM@std@@YAPAMAAPAMU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<float *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAM@std@@YAPAMAAPAMU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<float *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<int *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<int *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBHPAHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PBHPAHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int const *,int *,std::allocator<int> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PBHPAHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int const *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@AAPAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@AAPAH@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<int,std::allocator<int> >,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@AAPAH@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<int,std::allocator<int> >,int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<int,std::allocator<int> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@std@@YAPBHAAV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<DRAMsimII::Rank *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@AAPAVRank@DRAMsimII@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@AAPAVRank@DRAMsimII@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,DRAMsimII::Rank *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@AAPAVRank@DRAMsimII@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<__int64 *,__int64 *,std::allocator<__int64> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<__int64 *,__int64 *,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PA_J@std@@YAPA_JAAPA_JU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PA_J@std@@YAPA_JAAPA_JU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<__int64 *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PA_J@std@@YAPA_JAAPA_JU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<__int64 *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PB_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPB_J0PA_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PB_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPB_J0PA_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<__int64 const *,__int64 *,std::allocator<__int64> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PB_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPB_J0PA_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<__int64 const *,__int64 *,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@AAPA_J@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@AAPA_J@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@AAPA_J@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@0@Z
_TEXT	SEGMENT
??$_Iter_random@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Iter_random@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YAPBVRank@DRAMsimII@@AAV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_assign_from_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEXPB_J@Z
_TEXT	SEGMENT
?_Checked_iterator_assign_from_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEXPB_J@Z PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_assign_from_base, COMDAT
; _this$ = eax
; __Base$ = ecx

; 52   : 		this->_Myptr = const_cast<_Tptr>(_Base);

	mov	DWORD PTR [eax+4], ecx

; 53   : 	}

	ret	0
?_Checked_iterator_assign_from_base@?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEXPB_J@Z ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Checked_iterator_assign_from_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z PROC ; std::_Move_cat<DRAMsimII::Transaction * *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAPAVTransaction@DRAMsimII@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVTransaction@DRAMsimII@@@Z ENDP ; std::_Move_cat<DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z PROC ; std::_Fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>, COMDAT
; __First$ = eax
; __Last$ = edx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	cmp	eax, edx
	je	SHORT $LN1@Fill@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	npad	6
$LL3@Fill@4:

; 3159 : 		*_First = _Val;

	mov	DWORD PTR [eax], ecx
	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL3@Fill@4
$LN1@Fill@4:

; 3160 : 	}

	ret	0
??$_Fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z ENDP ; std::_Fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Copy_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@0@Z
_TEXT	SEGMENT
??$_Iter_random@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@0@Z PROC ; std::_Iter_random<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTransaction@DRAMsimII@@0@Z ENDP ; std::_Iter_random<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@@Z
_TEXT	SEGMENT
??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@@Z PROC ; std::_Checked_base<DRAMsimII::Transaction * *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAPAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@AAPAPAV12@@Z ENDP ; std::_Checked_base<DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAN@std@@YA?AU_Undefined_move_tag@0@ABQAN@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAN@std@@YA?AU_Undefined_move_tag@0@ABQAN@Z PROC ; std::_Move_cat<double *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAN@std@@YA?AU_Undefined_move_tag@0@ABQAN@Z ENDP ; std::_Move_cat<double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PANPAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN0@Z
_TEXT	SEGMENT
??$_Iter_random@PANPAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN0@Z PROC ; std::_Iter_random<double *,double *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PANPAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN0@Z ENDP ; std::_Iter_random<double *,double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PANN@std@@YAXPAN0ABN@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Fill@PANN@std@@YAXPAN0ABN@Z PROC			; std::_Fill<double *,double>, COMDAT
; __First$ = eax
; __Last$ = ecx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	cmp	eax, ecx
	je	SHORT $LN1@Fill@5
	mov	edx, DWORD PTR __Val$[esp-4]
	movsd	xmm0, QWORD PTR [edx]
	npad	4
$LL3@Fill@5:

; 3159 : 		*_First = _Val;

	movsd	QWORD PTR [eax], xmm0
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@5
$LN1@Fill@5:

; 3160 : 	}

	ret	0
??$_Fill@PANN@std@@YAXPAN0ABN@Z ENDP			; std::_Fill<double *,double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAN@std@@YAPANAAPAN@Z
_TEXT	SEGMENT
??$_Checked_base@PAN@std@@YAPANAAPAN@Z PROC		; std::_Checked_base<double *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAN@std@@YAPANAAPAN@Z ENDP		; std::_Checked_base<double *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<double> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT
; __First$ = eax
; __Last$ = edx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	cmp	eax, edx
	je	SHORT $LN1@Fill@6
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	npad	6
$LL3@Fill@6:

; 3159 : 		*_First = _Val;

	mov	DWORD PTR [eax], ecx
	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL3@Fill@6
$LN1@Fill@6:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<unsigned int,__int64> *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<unsigned int,__int64> *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAPAPAU?$pair@I_J@0@PAPAU10@00AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAPAPAU?$pair@I_J@0@PAPAU10@00AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *,std::allocator<std::pair<unsigned int,__int64> *> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAPAPAU?$pair@I_J@0@PAPAU10@00AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *,std::allocator<std::pair<unsigned int,__int64> *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAU?$pair@I_J@std@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAU?$pair@I_J@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAPAU?$pair@I_J@std@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAU?$pair@I_J@0@0@Z PROC ; std::_Ptr_cat<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAU?$pair@I_J@std@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAU?$pair@I_J@0@0@Z ENDP ; std::_Ptr_cat<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@@Z
_TEXT	SEGMENT
??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@@Z PROC ; std::_Checked_base<std::pair<unsigned int,__int64> * *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAPAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@AAPAPAU10@@Z ENDP ; std::_Checked_base<std::pair<unsigned int,__int64> * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVBank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVBank@DRAMsimII@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAVBank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVBank@DRAMsimII@@0@Z PROC ; std::_Ptr_cat<DRAMsimII::Bank *,DRAMsimII::Bank *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVBank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVBank@DRAMsimII@@0@Z ENDP ; std::_Ptr_cat<DRAMsimII::Bank *,DRAMsimII::Bank *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::Transaction *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVTransaction@DRAMsimII@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVTransaction@DRAMsimII@@0@Z PROC ; std::_Ptr_cat<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVTransaction@DRAMsimII@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVTransaction@DRAMsimII@@0@Z ENDP ; std::_Ptr_cat<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PANPAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAN0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PANPAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAN0@Z PROC ; std::_Ptr_cat<double *,double *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PANPAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAN0@Z ENDP ; std::_Ptr_cat<double *,double *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<float> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<__int64> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PANV?$allocator@N@2@@stdext@@YAPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@0PANAAV?$allocator@N@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PANV?$allocator@N@2@@stdext@@YAPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@0PANAAV?$allocator@N@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<double,std::allocator<double> >,double *,std::allocator<double> >, COMDAT
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN20@unchecked_@5
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN20@unchecked_@5:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@PANV?$allocator@N@2@@stdext@@YAPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@0PANAAV?$allocator@N@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<double,std::allocator<double> >,double *,std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Copy_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<float *,float *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 2508 : 	}

	ret	0
??$_Copy_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<float *,float *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z PROC ; std::_Ptr_cat<float *,float *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z ENDP ; std::_Ptr_cat<float *,float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAMPAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM0@Z
_TEXT	SEGMENT
??$_Iter_random@PAMPAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM0@Z PROC ; std::_Iter_random<float *,float *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PAMPAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM0@Z ENDP ; std::_Iter_random<float *,float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAM@std@@YAPAMAAPAM@Z
_TEXT	SEGMENT
??$_Checked_base@PAM@std@@YAPAMAAPAM@Z PROC		; std::_Checked_base<float *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAM@std@@YAPAMAAPAM@Z ENDP		; std::_Checked_base<float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 2508 : 	}

	ret	0
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAH@std@@YAPAHAAPAH@Z
_TEXT	SEGMENT
??$_Checked_base@PAH@std@@YAPAHAAPAH@Z PROC		; std::_Checked_base<int *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAH@std@@YAPAHAAPAH@Z ENDP		; std::_Checked_base<int *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >, COMDAT
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN20@unchecked_@6
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN20@unchecked_@6:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVRank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVRank@DRAMsimII@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAVRank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVRank@DRAMsimII@@0@Z PROC ; std::_Ptr_cat<DRAMsimII::Rank *,DRAMsimII::Rank *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVRank@DRAMsimII@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVRank@DRAMsimII@@0@Z ENDP ; std::_Ptr_cat<DRAMsimII::Rank *,DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAVRank@DRAMsimII@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVRank@DRAMsimII@@0@Z
_TEXT	SEGMENT
??$_Iter_random@PAVRank@DRAMsimII@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVRank@DRAMsimII@@0@Z PROC ; std::_Iter_random<DRAMsimII::Rank *,DRAMsimII::Rank *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PAVRank@DRAMsimII@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVRank@DRAMsimII@@0@Z ENDP ; std::_Iter_random<DRAMsimII::Rank *,DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@@Z
_TEXT	SEGMENT
??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@@Z PROC ; std::_Checked_base<DRAMsimII::Rank *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAVRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@AAPAV12@@Z ENDP ; std::_Checked_base<DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PA_JPA_JUrandom_access_iterator_tag@std@@@std@@YAPA_JPA_J00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Copy_opt@PA_JPA_JUrandom_access_iterator_tag@std@@@std@@YAPA_JPA_J00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<__int64 *,__int64 *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 2508 : 	}

	ret	0
??$_Copy_opt@PA_JPA_JUrandom_access_iterator_tag@std@@@std@@YAPA_JPA_J00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<__int64 *,__int64 *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PA_JPA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPA_J0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PA_JPA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPA_J0@Z PROC ; std::_Ptr_cat<__int64 *,__int64 *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PA_JPA_J@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPA_J0@Z ENDP ; std::_Ptr_cat<__int64 *,__int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PA_JPA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J0@Z
_TEXT	SEGMENT
??$_Iter_random@PA_JPA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J0@Z PROC ; std::_Iter_random<__int64 *,__int64 *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PA_JPA_J@std@@YA?AUrandom_access_iterator_tag@0@ABQA_J0@Z ENDP ; std::_Iter_random<__int64 *,__int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PA_J@std@@YAPA_JAAPA_J@Z
_TEXT	SEGMENT
??$_Checked_base@PA_J@std@@YAPA_JAAPA_J@Z PROC		; std::_Checked_base<__int64 *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PA_J@std@@YAPA_JAAPA_J@Z ENDP		; std::_Checked_base<__int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@I@std@@YA?AU_Int_iterator_tag@0@ABI@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Iter_cat@I@std@@YA?AU_Int_iterator_tag@0@ABI@Z PROC	; std::_Iter_cat<unsigned int>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 955  : 	}

	pop	ecx
	ret	0
??$_Iter_cat@I@std@@YA?AU_Int_iterator_tag@0@ABI@Z ENDP	; std::_Iter_cat<unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_assign_from_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PB_J@std@@YAXAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@ABQB_J@Z
_TEXT	SEGMENT
??$_Checked_assign_from_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PB_J@std@@YAXAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@ABQB_J@Z PROC ; std::_Checked_assign_from_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 const *>, COMDAT
; __Dest$ = edx
; __Src$ = eax

; 1174 : 		_Dest._Checked_iterator_assign_from_base(_Src);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], ecx

; 1175 : 	}

	ret	0
??$_Checked_assign_from_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PB_J@std@@YAXAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@ABQB_J@Z ENDP ; std::_Checked_assign_from_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 const *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Min_element@PB_J@std@@YAPB_JPB_J0@Z
_TEXT	SEGMENT
??$_Min_element@PB_J@std@@YAPB_JPB_J0@Z PROC		; std::_Min_element<__int64 const *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4437 : 	_DEBUG_RANGE(_First, _Last);
; 4438 : 	_FwdIt _Found = _First;

	mov	eax, ecx

; 4439 : 	if (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN2@Min_elemen

; 4440 : 		for (; ++_First != _Last; )

	add	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN2@Min_elemen
	push	esi
	npad	2
$LL3@Min_elemen:

; 4441 : 			if (_DEBUG_LT(*_First, *_Found))

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LN1@Min_elemen
	jl	SHORT $LN8@Min_elemen
	mov	esi, DWORD PTR [ecx]
	cmp	esi, DWORD PTR [eax]
	jae	SHORT $LN1@Min_elemen
$LN8@Min_elemen:

; 4442 : 				_Found = _First;

	mov	eax, ecx
$LN1@Min_elemen:

; 4440 : 		for (; ++_First != _Last; )

	add	ecx, 8
	cmp	ecx, edx
	jne	SHORT $LL3@Min_elemen
	pop	esi
$LN2@Min_elemen:

; 4443 : 	return (_Found);
; 4444 : 	}

	ret	0
??$_Min_element@PB_J@std@@YAPB_JPB_J0@Z ENDP		; std::_Min_element<__int64 const *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YAPB_JAAV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\storage.hpp
_TEXT	ENDS
;	COMDAT ??0?$storage1@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@@Z
_TEXT	SEGMENT
_a1$ = 8						; size = 4
??0?$storage1@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@@Z PROC ; boost::_bi::storage1<boost::_bi::value<DRAMsimII::Channel *> >::storage1<boost::_bi::value<DRAMsimII::Channel *> >, COMDAT
; _this$ = eax

; 42   :     explicit storage1( A1 a1 ): a1_( a1 ) {}

	mov	ecx, DWORD PTR _a1$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	4
??0?$storage1@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@@Z ENDP ; boost::_bi::storage1<boost::_bi::value<DRAMsimII::Channel *> >::storage1<boost::_bi::value<DRAMsimII::Channel *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$storage2@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@@Z
_TEXT	SEGMENT
_a1$ = 8						; size = 4
_a2$ = 12						; size = 8
??0?$storage2@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@@Z PROC ; boost::_bi::storage2<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double> >::storage2<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double> >, COMDAT
; _this$ = eax

; 80   :     storage2( A1 a1, A2 a2 ): storage1<A1>( a1 ), a2_( a2 ) {}

	mov	ecx, DWORD PTR _a1$[esp-4]
	mov	edx, DWORD PTR _a2$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _a2$[esp]
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], ecx
	ret	12					; 0000000cH
??0?$storage2@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@@Z ENDP ; boost::_bi::storage2<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double> >::storage2<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$storage3@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1@Z
_TEXT	SEGMENT
_a1$ = 8						; size = 4
_a2$ = 12						; size = 8
_a3$ = 20						; size = 8
??0?$storage3@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1@Z PROC ; boost::_bi::storage3<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double> >::storage3<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double> >, COMDAT
; _this$ = eax

; 129  :     storage3( A1 a1, A2 a2, A3 a3 ): storage2<A1, A2>( a1, a2 ), a3_( a3 ) {}

	mov	ecx, DWORD PTR _a1$[esp-4]
	mov	edx, DWORD PTR _a2$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _a2$[esp]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR _a3$[esp-4]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR _a3$[esp]
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], ecx
	ret	20					; 00000014H
??0?$storage3@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1@Z ENDP ; boost::_bi::storage3<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double> >::storage3<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double> >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
_TEXT	ENDS
;	COMDAT ??0?$value@_J@_bi@boost@@QAE@AB_J@Z
_TEXT	SEGMENT
??0?$value@_J@_bi@boost@@QAE@AB_J@Z PROC		; boost::_bi::value<__int64>::value<__int64>, COMDAT
; _this$ = eax
; _t$ = ecx

; 116  :     value(T const & t): t_(t) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	ret	0
??0?$value@_J@_bi@boost@@QAE@AB_J@Z ENDP		; boost::_bi::value<__int64>::value<__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$value@N@_bi@boost@@QAE@ABN@Z
_TEXT	SEGMENT
??0?$value@N@_bi@boost@@QAE@ABN@Z PROC			; boost::_bi::value<double>::value<double>, COMDAT
; _this$ = eax
; _t$ = ecx

; 116  :     value(T const & t): t_(t) {}

	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [eax]
	ret	0
??0?$value@N@_bi@boost@@QAE@ABN@Z ENDP			; boost::_bi::value<double>::value<double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAE@ABQAVChannel@DRAMsimII@@@Z
_TEXT	SEGMENT
??0?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAE@ABQAVChannel@DRAMsimII@@@Z PROC ; boost::_bi::value<DRAMsimII::Channel *>::value<DRAMsimII::Channel *>, COMDAT
; _this$ = eax
; _t$ = ecx

; 116  :     value(T const & t): t_(t) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	ret	0
??0?$value@PAVChannel@DRAMsimII@@@_bi@boost@@QAE@ABQAVChannel@DRAMsimII@@@Z ENDP ; boost::_bi::value<DRAMsimII::Channel *>::value<DRAMsimII::Channel *>
_TEXT	ENDS
PUBLIC	?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z ; DRAMsimII::Channel::sendPower
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\mem_fn_template.hpp
;	COMDAT ??0?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QAE@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@Z@Z
_TEXT	SEGMENT
??0?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QAE@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@Z@Z PROC ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>, COMDAT
; _this$ = eax

; 772  :     explicit BOOST_MEM_FN_NAME(cmf6)(F f): f_(f) {}

	mov	DWORD PTR [eax], OFFSET ?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z ; DRAMsimII::Channel::sendPower
	ret	0
??0?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QAE@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@Z@Z ENDP ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@I_J@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@I_J@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int,__int64> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@I_J@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int,__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@_J@std@@YAXPA_J@Z
_TEXT	SEGMENT
??$_Destroy@_J@std@@YAXPA_J@Z PROC			; std::_Destroy<__int64>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@_J@std@@YAXPA_J@Z ENDP			; std::_Destroy<__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@I_J@std@@@?$allocator@PAU?$pair@I_J@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@I_J@std@@@?$allocator@PAU?$pair@I_J@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z PROC ; std::allocator<std::pair<unsigned int,__int64> *>::allocator<std::pair<unsigned int,__int64> *><std::pair<unsigned int,__int64> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@I_J@std@@@?$allocator@PAU?$pair@I_J@std@@@std@@QAE@ABV?$allocator@U?$pair@I_J@std@@@1@@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> *>::allocator<std::pair<unsigned int,__int64> *><std::pair<unsigned int,__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0PAVTransaction@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVTransaction@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
??$?0PAVTransaction@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVTransaction@DRAMsimII@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Transaction *>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0PAVTransaction@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVTransaction@DRAMsimII@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z PROC ; std::fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>, COMDAT
; __First$ = eax
; __Last$ = ecx

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	cmp	eax, ecx
	je	SHORT $LN11@fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
	npad	6
$LL13@fill@3:
	mov	DWORD PTR [eax], edx
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL13@fill@3
$LN11@fill@3:

; 3188 : 	}

	ret	0
??$fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z ENDP ; std::fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN18@unchecked_@7
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@unchecked_@7:
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0N@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@N@1@@Z
_TEXT	SEGMENT
??$?0N@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@N@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><double>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0N@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@N@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><double>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PANN@std@@YAXPAN0ABN@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$fill@PANN@std@@YAXPAN0ABN@Z PROC			; std::fill<double *,double>, COMDAT
; __First$ = eax
; __Last$ = ecx

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	cmp	eax, ecx
	je	SHORT $LN11@fill@4
	mov	edx, DWORD PTR __Val$[esp-4]
	movsd	xmm0, QWORD PTR [edx]
	npad	4
$LL13@fill@4:
	movsd	QWORD PTR [eax], xmm0
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL13@fill@4
$LN11@fill@4:

; 3188 : 	}

	ret	0
??$fill@PANN@std@@YAXPAN0ABN@Z ENDP			; std::fill<double *,double>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z PROC ; std::_Destroy_range<std::allocator<double> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z ENDP ; std::_Destroy_range<std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0M@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@M@1@@Z
_TEXT	SEGMENT
??$?0M@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@M@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><float>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0M@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@M@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0H@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
??$?0H@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><int>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0H@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT
; __First$ = eax
; __Last$ = ecx

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	cmp	eax, ecx
	je	SHORT $LN11@fill@5
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
	npad	6
$LL13@fill@5:
	mov	DWORD PTR [eax], edx
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL13@fill@5
$LN11@fill@5:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU?$pair@I_J@std@@@std@@YAXPAPAU?$pair@I_J@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU?$pair@I_J@std@@@std@@YAXPAPAU?$pair@I_J@0@@Z PROC ; std::_Destroy<std::pair<unsigned int,__int64> *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU?$pair@I_J@std@@@std@@YAXPAPAU?$pair@I_J@0@@Z ENDP ; std::_Destroy<std::pair<unsigned int,__int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U?$pair@I_J@std@@@std@@YAXPAU?$pair@I_J@0@@Z
_TEXT	SEGMENT
??$_Destroy@U?$pair@I_J@std@@@std@@YAXPAU?$pair@I_J@0@@Z PROC ; std::_Destroy<std::pair<unsigned int,__int64> >, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U?$pair@I_J@std@@@std@@YAXPAU?$pair@I_J@0@@Z ENDP ; std::_Destroy<std::pair<unsigned int,__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<unsigned int,__int64> *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAU?$pair@I_J@std@@@std@@@std@@YAXPAPAU?$pair@I_J@0@0AAV?$allocator@PAU?$pair@I_J@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<unsigned int,__int64> *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAPAPAU?$pair@I_J@std@@PAPAU12@00AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAPAPAU?$pair@I_J@std@@PAPAU12@00AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *,std::allocator<std::pair<unsigned int,__int64> *> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@8
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@8:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAU?$pair@I_J@std@@PAPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAPAPAU?$pair@I_J@std@@PAPAU12@00AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::pair<unsigned int,__int64> * *,std::pair<unsigned int,__int64> * *,std::allocator<std::pair<unsigned int,__int64> *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0VRank@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VRank@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
??$?0VRank@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VRank@DRAMsimII@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Rank>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0VRank@DRAMsimII@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VRank@DRAMsimII@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><DRAMsimII::Rank>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0_J@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_J@1@@Z
_TEXT	SEGMENT
??$?0_J@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_J@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><__int64>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0_J@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_J@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><__int64>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ??$increment@PA_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPA_J@Z
_TEXT	SEGMENT
??$increment@PA_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPA_J@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::increment<__int64 *>, COMDAT
; _this$ = edx
; _p$ = eax

; 1981 :         if (++p == m_end)

	add	DWORD PTR [eax], 8
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN1@increment@2

; 1982 :             p = m_buff;

	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN1@increment@2:

; 1983 :     }

	ret	0
??$increment@PA_J@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@ABEXAAPA_J@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::increment<__int64 *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::Transaction *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@0AAV?$allocator@PAVTransaction@DRAMsimII@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z PROC ; std::_Destroy_range<std::allocator<float> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z ENDP ; std::_Destroy_range<std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@@Z PROC ; std::_Destroy_range<std::allocator<__int64> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@_J@std@@@std@@YAXPA_J0AAV?$allocator@_J@0@@Z ENDP ; std::_Destroy_range<std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@?$vector@NV?$allocator@N@std@@@std@@IAEPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@1@0PAN@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Ucopy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@?$vector@NV?$allocator@N@std@@@std@@IAEPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@1@0PAN@Z PROC ; std::vector<double,std::allocator<double> >::_Ucopy<std::_Vector_const_iterator<double,std::allocator<double> > >, COMDAT
; __Ptr$ = edx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN22@Ucopy
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Ucopy:

; 1142 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Ucopy@V?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@@?$vector@NV?$allocator@N@std@@@std@@IAEPANV?$_Vector_const_iterator@NV?$allocator@N@std@@@1@0PAN@Z ENDP ; std::vector<double,std::allocator<double> >::_Ucopy<std::_Vector_const_iterator<double,std::allocator<double> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAMPAM@stdext@@YAPAMPAM00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAMPAM@stdext@@YAPAMPAM00@Z PROC	; stdext::unchecked_copy<float *,float *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN18@unchecked_@9
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@unchecked_@9:
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAMPAM@stdext@@YAPAMPAM00@Z ENDP	; stdext::unchecked_copy<float *,float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN18@unchecked_@10
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@unchecked_@10:
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@0PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Ucopy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@0PAH@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<int,std::allocator<int> > >, COMDAT
; __Ptr$ = edx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN22@Ucopy@2
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Ucopy@2:

; 1142 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Ucopy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@0PAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PA_JPA_J@stdext@@YAPA_JPA_J00@Z
_TEXT	SEGMENT
??$unchecked_copy@PA_JPA_J@stdext@@YAPA_JPA_J00@Z PROC	; stdext::unchecked_copy<__int64 *,__int64 *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN18@unchecked_@11
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@unchecked_@11:
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PA_JPA_J@stdext@@YAPA_JPA_J00@Z ENDP	; stdext::unchecked_copy<__int64 *,__int64 *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$min_element@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@V10@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$min_element@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@V10@0@Z PROC ; std::min_element<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >, COMDAT
; ___$ReturnUdt$ = eax

; 4449 : 	_ASSIGN_FROM_BASE(_First,

	mov	edx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	edx, esi
	je	SHORT $LN16@min_elemen
	lea	ecx, DWORD PTR [edx+8]
	cmp	ecx, esi
	je	SHORT $LN16@min_elemen
	push	edi
$LL17@min_elemen:
	mov	edi, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [edx+4]
	jg	SHORT $LN15@min_elemen
	jl	SHORT $LN26@min_elemen
	mov	edi, DWORD PTR [ecx]
	cmp	edi, DWORD PTR [edx]
	jae	SHORT $LN15@min_elemen
$LN26@min_elemen:
	mov	edx, ecx
$LN15@min_elemen:
	add	ecx, 8
	cmp	ecx, esi
	jne	SHORT $LL17@min_elemen
	pop	edi
$LN16@min_elemen:

; 4450 : 		_Min_element(_CHECKED_BASE(_First), _CHECKED_BASE(_Last)));
; 4451 : 	return (_First);

	mov	ecx, DWORD PTR __First$[esp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 4452 : 	}

	ret	0
??$min_element@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@V10@0@Z ENDP ; std::min_element<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@I_J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@I_J@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned int,__int64> >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 268435455				; 0fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@I_J@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int,__int64> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@_J@std@@QAEXPA_J@Z
_TEXT	SEGMENT
?destroy@?$allocator@_J@std@@QAEXPA_J@Z PROC		; std::allocator<__int64>::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@_J@std@@QAEXPA_J@Z ENDP		; std::allocator<__int64>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@N@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@N@std@@QBEIXZ PROC		; std::allocator<double>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@N@std@@QBEIXZ ENDP		; std::allocator<double>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@M@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@M@std@@QBEIXZ PROC		; std::allocator<float>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@M@std@@QBEIXZ ENDP		; std::allocator<float>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@I_J@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@I_J@std@@@std@@QAE@ABV01@@Z PROC	; std::allocator<std::pair<unsigned int,__int64> >::allocator<std::pair<unsigned int,__int64> >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@U?$pair@I_J@std@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<std::pair<unsigned int,__int64> >::allocator<std::pair<unsigned int,__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?max_size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::max_size, COMDAT

; 729  : 		return (this->_Alval.max_size());

	mov	eax, 268435455				; 0fffffffH

; 730  : 		}

	ret	0
?max_size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VRank@DRAMsimII@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VRank@DRAMsimII@@@std@@QBEIXZ PROC ; std::allocator<DRAMsimII::Rank>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 21474836				; 0147ae14H

; 167  : 		}

	ret	0
?max_size@?$allocator@VRank@DRAMsimII@@@std@@QBEIXZ ENDP ; std::allocator<DRAMsimII::Rank>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_J@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@_J@std@@QBEIXZ PROC		; std::allocator<__int64>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@_J@std@@QBEIXZ ENDP		; std::allocator<__int64>::max_size
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?destroy_item@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_J@Z
_TEXT	SEGMENT
?destroy_item@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_J@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy_item, COMDAT

; 2054 :         m_alloc.destroy(p);
; 2055 : #if BOOST_CB_ENABLE_DEBUG
; 2056 :         invalidate_iterators(iterator(this, p));
; 2057 :         ::memset(p, cb_details::UNINITIALIZED, sizeof(value_type));
; 2058 : #endif
; 2059 :     }

	ret	0
?destroy_item@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_J@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy_item
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ
_TEXT	SEGMENT
?size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::size, COMDAT
; _this$ = eax

; 752  :     size_type size() const { return m_size; }

	mov	eax, DWORD PTR [eax+16]
	ret	0
?size@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVTransaction@DRAMsimII@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVTransaction@DRAMsimII@@@std@@QBEIXZ PROC ; std::allocator<DRAMsimII::Transaction *>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVTransaction@DRAMsimII@@@std@@QBEIXZ ENDP ; std::allocator<DRAMsimII::Transaction *>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@ABV01@@Z PROC ; std::allocator<DRAMsimII::Transaction *>::allocator<DRAMsimII::Transaction *>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<DRAMsimII::Transaction *>::allocator<DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@N@std@@QAEXPANI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@N@std@@QAEXPANI@Z PROC		; std::allocator<double>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@N@std@@QAEXPANI@Z ENDP		; std::allocator<double>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@NV?$allocator@N@std@@@std@@IAEXPAN0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@NV?$allocator@N@std@@@std@@IAEXPAN0@Z PROC ; std::vector<double,std::allocator<double> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	0
?_Destroy@?$vector@NV?$allocator@N@std@@@std@@IAEXPAN0@Z ENDP ; std::vector<double,std::allocator<double> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ PROC ; std::vector<double,std::allocator<double> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ENDP ; std::vector<double,std::allocator<double> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@M@std@@QAE@ABV01@@Z PROC			; std::allocator<float>::allocator<float>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@M@std@@QAE@ABV01@@Z ENDP			; std::allocator<float>::allocator<float>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC ; std::vector<float,std::allocator<float> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP ; std::vector<float,std::allocator<float> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@@Z PROC ; std::allocator<std::pair<unsigned int,__int64> *>::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> *>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@I@Z PROC ; std::allocator<std::pair<unsigned int,__int64> *>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEXPAPAU?$pair@I_J@2@I@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> *>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@@Z PROC ; std::allocator<std::pair<unsigned int,__int64> >::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> >::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@I@Z PROC ; std::allocator<std::pair<unsigned int,__int64> >::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@I@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> >::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@I_J@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@I_J@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<unsigned int,__int64> >::allocator<std::pair<unsigned int,__int64> >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@I_J@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<unsigned int,__int64> >::allocator<std::pair<unsigned int,__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?empty@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBE_NXZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::empty, COMDAT
; _this$ = ecx

; 734  : 		return (_Mysize == 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+28], eax
	sete	al

; 735  : 		}

	ret	0
?empty@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBE_NXZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::empty
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 21474836				; 0147ae14H

; 732  : 		}

	ret	0
?max_size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ PROC ; std::vector<__int64,std::allocator<__int64> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ENDP ; std::vector<__int64,std::allocator<__int64> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::Bank>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::Bank>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?destroy_content@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ
_TEXT	SEGMENT
?destroy_content@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy_content, COMDAT
; _this$ = eax

; 2069 :         for (size_type ii = 0; ii < size(); ++ii, increment(m_first))

	xor	edx, edx
	cmp	DWORD PTR [eax+16], edx
	jbe	SHORT $LN1@destroy_co
$LL6@destroy_co:
	add	DWORD PTR [eax+8], 8
	mov	ecx, DWORD PTR [eax+8]
	inc	edx
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN12@destroy_co
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+8], ecx
$LN12@destroy_co:
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LL6@destroy_co
$LN1@destroy_co:

; 2070 :             destroy_item(m_first);
; 2071 :     }

	ret	0
?destroy_content@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy_content
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::capacity, COMDAT
; _this$ = ecx

; 827  :     capacity_type capacity() const { return m_end - m_buff; }

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	ret	0
?capacity@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEIXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEXPAPAVTransaction@DRAMsimII@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEXPAPAVTransaction@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::Transaction *>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEXPAPAVTransaction@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::Transaction *>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@XZ PROC ; std::allocator<DRAMsimII::Transaction *>::allocator<DRAMsimII::Transaction *>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVTransaction@DRAMsimII@@@std@@QAE@XZ ENDP ; std::allocator<DRAMsimII::Transaction *>::allocator<DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXPAPAVTransaction@DRAMsimII@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXPAPAVTransaction@DRAMsimII@@0@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	0
?_Destroy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXPAPAVTransaction@DRAMsimII@@0@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@9
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@9:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocnum
_TEXT	ENDS
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
__Dest$ = 12						; size = 8
__Val$ = 20						; size = 8
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi
; __Fill$ = edx

; 1105 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	fld	QWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	mov	edx, DWORD PTR __Iosbase$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	edx
	push	esi
	call	eax
	mov	eax, esi

; 1106 : 		}

	ret	20					; 00000014H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@N@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@N@std@@QAE@ABV01@@Z PROC			; std::allocator<double>::allocator<double>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@N@std@@QAE@ABV01@@Z ENDP			; std::allocator<double>::allocator<double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@N@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@N@std@@QAE@XZ PROC			; std::allocator<double>::allocator<double>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@N@std@@QAE@XZ ENDP			; std::allocator<double>::allocator<double>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@NV?$allocator@N@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@NV?$allocator@N@std@@@std@@IAEXXZ PROC	; std::vector<double,std::allocator<double> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@Tidy@7

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@7:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 1135 : 		}

	ret	0
?_Tidy@?$vector@NV?$allocator@N@std@@@std@@IAEXXZ ENDP	; std::vector<double,std::allocator<double> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ PROC ; std::vector<double,std::allocator<double> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@10
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@10:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ENDP ; std::vector<double,std::allocator<double> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@M@std@@QAEXPAMI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@M@std@@QAEXPAMI@Z PROC		; std::allocator<float>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@M@std@@QAEXPAMI@Z ENDP		; std::allocator<float>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@M@std@@QAE@XZ PROC			; std::allocator<float>::allocator<float>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@M@std@@QAE@XZ ENDP			; std::allocator<float>::allocator<float>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z PROC ; std::vector<float,std::allocator<float> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	0
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ENDP ; std::vector<float,std::allocator<float> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC	; std::vector<float,std::allocator<float> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP	; std::vector<float,std::allocator<float> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC ; std::vector<float,std::allocator<float> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@11
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@11:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP ; std::vector<float,std::allocator<float> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	0
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@12
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@12:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?pop_front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::pop_front, COMDAT
; _this$ = eax

; 820  : 
; 821  :  #if _HAS_ITERATOR_DEBUGGING
; 822  : 		if (empty())
; 823  : 			_DEBUG_ERROR("deque empty before pop");
; 824  : 		else
; 825  : 			{	// something to erase, do it
; 826  : 			_Orphan_off(_Myoff);
; 827  : 
; 828  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 829  : 		if (!empty())

	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN1@pop_front

; 830  : 			{	// something to erase, do it
; 831  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 832  : 
; 833  : 			size_type _Block = _Myoff / _DEQUESIZ;
; 834  : 			this->_Alval.destroy(_Map[_Block] + _Myoff % _DEQUESIZ);
; 835  : 			if (_Mapsize * _DEQUESIZ <= ++_Myoff)

	inc	DWORD PTR [eax+24]
	mov	edx, DWORD PTR [eax+24]
	cmp	DWORD PTR [eax+20], edx
	ja	SHORT $LN2@pop_front

; 836  : 				_Myoff = 0;

	mov	DWORD PTR [eax+24], 0
$LN2@pop_front:

; 837  : 			if (--_Mysize == 0)

	add	ecx, -1
	mov	DWORD PTR [eax+28], ecx
	jne	SHORT $LN1@pop_front

; 838  : 				_Myoff = 0;

	mov	DWORD PTR [eax+24], 0
$LN1@pop_front:

; 839  : 			}
; 840  : 			}

	ret	0
?pop_front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::pop_front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::size, COMDAT
; _this$ = eax

; 724  : 		return (_Mysize);

	mov	eax, DWORD PTR [eax+28]

; 725  : 		}

	ret	0
?size@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QBEIXZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::Rank>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::Rank>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@VRank@DRAMsimII@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@VRank@DRAMsimII@@@std@@QAE@ABV01@@Z PROC	; std::allocator<DRAMsimII::Rank>::allocator<DRAMsimII::Rank>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@VRank@DRAMsimII@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<DRAMsimII::Rank>::allocator<DRAMsimII::Rank>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@VRank@DRAMsimII@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VRank@DRAMsimII@@@std@@QAE@XZ PROC	; std::allocator<DRAMsimII::Rank>::allocator<DRAMsimII::Rank>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VRank@DRAMsimII@@@std@@QAE@XZ ENDP	; std::allocator<DRAMsimII::Rank>::allocator<DRAMsimII::Rank>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	jne	SHORT $LN3@capacity@13

; 636  : 		}

	ret	0
$LN3@capacity@13:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	0
?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ PROC ; std::vector<__int64,std::allocator<__int64> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@14
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@14:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ENDP ; std::vector<__int64,std::allocator<__int64> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::size, COMDAT
; _this$ = eax

; 726  : 		return (_Mylast - _Myfirst);

	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_J@std@@QAEXPA_JI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@_J@std@@QAEXPA_JI@Z PROC	; std::allocator<__int64>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@_J@std@@QAEXPA_JI@Z ENDP	; std::allocator<__int64>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@_J@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@_J@std@@QAE@ABV01@@Z PROC		; std::allocator<__int64>::allocator<__int64>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@_J@std@@QAE@ABV01@@Z ENDP		; std::allocator<__int64>::allocator<__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@_J@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_J@std@@QAE@XZ PROC			; std::allocator<__int64>::allocator<__int64>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@_J@std@@QAE@XZ ENDP			; std::allocator<__int64>::allocator<__int64>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ PROC	; std::vector<double,std::allocator<double> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ENDP	; std::vector<double,std::allocator<double> >::size
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\arg.hpp
_TEXT	ENDS
;	COMDAT ??0?$arg@$08@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$08@boost@@QAE@XZ PROC				; boost::arg<9>::arg<9>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$08@boost@@QAE@XZ ENDP				; boost::arg<9>::arg<9>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$07@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$07@boost@@QAE@XZ PROC				; boost::arg<8>::arg<8>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$07@boost@@QAE@XZ ENDP				; boost::arg<8>::arg<8>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$06@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$06@boost@@QAE@XZ PROC				; boost::arg<7>::arg<7>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$06@boost@@QAE@XZ ENDP				; boost::arg<7>::arg<7>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$05@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$05@boost@@QAE@XZ PROC				; boost::arg<6>::arg<6>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$05@boost@@QAE@XZ ENDP				; boost::arg<6>::arg<6>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$04@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$04@boost@@QAE@XZ PROC				; boost::arg<5>::arg<5>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$04@boost@@QAE@XZ ENDP				; boost::arg<5>::arg<5>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$03@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$03@boost@@QAE@XZ PROC				; boost::arg<4>::arg<4>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$03@boost@@QAE@XZ ENDP				; boost::arg<4>::arg<4>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$02@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$02@boost@@QAE@XZ PROC				; boost::arg<3>::arg<3>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$02@boost@@QAE@XZ ENDP				; boost::arg<3>::arg<3>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$01@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$01@boost@@QAE@XZ PROC				; boost::arg<2>::arg<2>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$01@boost@@QAE@XZ ENDP				; boost::arg<2>::arg<2>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$arg@$00@boost@@QAE@XZ
_TEXT	SEGMENT
??0?$arg@$00@boost@@QAE@XZ PROC				; boost::arg<1>::arg<1>, COMDAT
; _this$ = ecx

; 30   :     arg()

	mov	eax, ecx

; 31   :     {
; 32   :     }

	ret	0
??0?$arg@$00@boost@@QAE@XZ ENDP				; boost::arg<1>::arg<1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z
_TEXT	SEGMENT
??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z PROC	; std::vector<float,std::allocator<float> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@17
	call	__invalid_parameter_noinfo
$LN1@operator@17:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 786  : 		}

	ret	0
??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z ENDP	; std::vector<float,std::allocator<float> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@I_J@std@@QAE@ABIAB_J@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
??0?$pair@I_J@std@@QAE@ABIAB_J@Z PROC			; std::pair<unsigned int,__int64>::pair<unsigned int,__int64>, COMDAT
; _this$ = eax
; __Val2$ = ecx

; 50   : 		{	// construct from specified values

	mov	edx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], ecx

; 51   : 		}

	ret	4
??0?$pair@I_J@std@@QAE@ABIAB_J@Z ENDP			; std::pair<unsigned int,__int64>::pair<unsigned int,__int64>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\queue
_TEXT	ENDS
;	COMDAT ?pop@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?pop@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXXZ PROC ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::pop, COMDAT
; _this$ = eax

; 76   : 		c.pop_front();

	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN3@pop
	inc	DWORD PTR [eax+24]
	mov	edx, DWORD PTR [eax+24]
	cmp	DWORD PTR [eax+20], edx
	ja	SHORT $LN4@pop
	mov	DWORD PTR [eax+24], 0
$LN4@pop:
	add	ecx, -1
	mov	DWORD PTR [eax+28], ecx
	jne	SHORT $LN3@pop
	mov	DWORD PTR [eax+24], 0
$LN3@pop:

; 77   : 		}

	ret	0
?pop@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXXZ ENDP ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::pop
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QBEIXZ PROC ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::size, COMDAT
; _this$ = eax

; 46   : 		return (c.size());

	mov	eax, DWORD PTR [eax+28]

; 47   : 		}

	ret	0
?size@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QBEIXZ ENDP ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::size, COMDAT
; _this$ = eax

; 726  : 		return (_Mylast - _Myfirst);

	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEIXZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ PROC	; std::vector<__int64,std::allocator<__int64> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ENDP	; std::vector<__int64,std::allocator<__int64> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAVBank@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAVBank@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN1@operator@18
	call	__invalid_parameter_noinfo
$LN1@operator@18:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, edi
	imul	eax, 152				; 00000098H
	add	eax, DWORD PTR [esi+12]

; 786  : 		}

	ret	0
??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAVBank@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN1@operator@19
	call	__invalid_parameter_noinfo
$LN1@operator@19:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, edi
	imul	eax, 152				; 00000098H
	add	eax, DWORD PTR [esi+12]

; 771  : 		}

	ret	0
??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ
_TEXT	SEGMENT
?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::back, COMDAT
; _this$ = eax

; 490  :         BOOST_CB_ASSERT(!empty()); // check for empty buffer (back element not available)
; 491  :         return *((m_last == m_buff ? m_end : m_last) - 1);

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN3@back
	mov	eax, DWORD PTR [eax+4]
	add	eax, -8					; fffffff8H

; 492  :     }

	ret	0
$LN3@back:

; 490  :         BOOST_CB_ASSERT(!empty()); // check for empty buffer (back element not available)
; 491  :         return *((m_last == m_buff ? m_end : m_last) - 1);

	lea	eax, DWORD PTR [ecx-8]

; 492  :     }

	ret	0
?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?front@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ
_TEXT	SEGMENT
?front@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::front, COMDAT
; _this$ = eax

; 472  :         BOOST_CB_ASSERT(!empty()); // check for empty buffer (front element not available)
; 473  :         return *m_first;

	mov	eax, DWORD PTR [eax+8]

; 474  :     }

	ret	0
?front@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QBEAB_JXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAA_JXZ
_TEXT	SEGMENT
?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAA_JXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::back, COMDAT
; _this$ = eax

; 454  :         BOOST_CB_ASSERT(!empty()); // check for empty buffer (back element not available)
; 455  :         return *((m_last == m_buff ? m_end : m_last) - 1);

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN3@back@2
	mov	eax, DWORD PTR [eax+4]
	add	eax, -8					; fffffff8H

; 456  :     }

	ret	0
$LN3@back@2:

; 454  :         BOOST_CB_ASSERT(!empty()); // check for empty buffer (back element not available)
; 455  :         return *((m_last == m_buff ? m_end : m_last) - 1);

	lea	eax, DWORD PTR [ecx-8]

; 456  :     }

	ret	0
?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAA_JXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::back
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?isEmpty@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isEmpty@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::isEmpty, COMDAT
; _this$ = ecx

; 375  : 			return (count == 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	sete	al

; 376  : 		}

	ret	0
?isEmpty@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::isEmpty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isFull@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isFull@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::isFull, COMDAT
; _this$ = eax

; 369  : 			return (entry.size() == count);

	mov	ecx, DWORD PTR [eax+28]
	sub	ecx, DWORD PTR [eax+24]
	xor	edx, edx
	sar	ecx, 2
	cmp	ecx, DWORD PTR [eax]
	sete	dl
	mov	al, dl

; 370  : 		}

	ret	0
?isFull@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NXZ ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::isFull
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?size@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::size, COMDAT
; _this$ = eax

; 244  : 			return count;

	mov	eax, DWORD PTR [eax]

; 245  : 		}

	ret	0
?size@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::size
_TEXT	ENDS
PUBLIC	?nextCommandExecuteTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextCommandExecuteTime
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
?nextCommandExecuteTime@Channel@DRAMsimII@@IBE_JXZ PROC	; DRAMsimII::Channel::nextCommandExecuteTime
; _this$ = esi

; 324  : 	// then check to see when the next command occurs
; 325  : 	if (const Command *tempCommand = readNextCommand())

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN2@nextComman

; 326  : 	{
; 327  : 		tick tempCommandExecuteTime = earliestExecuteTime(tempCommand);

	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax

; 340  : }

	ret	0
$LN2@nextComman:

; 328  : #ifndef NDEBUG
; 329  : 		int tempGap = minProtocolGap(tempCommand);
; 330  : 
; 331  : 		if (time + tempGap != tempCommandExecuteTime)
; 332  : 			cerr << time << " " << tempGap << " " << tempCommandExecuteTime << " " << tempCommand->getCommandType() << " " << tempCommand->getAddress() << endl;
; 333  : 		;
; 334  : 		assert(time + tempGap == tempCommandExecuteTime);
; 335  : #endif
; 336  : 		return tempCommandExecuteTime;
; 337  : 	}
; 338  : 	else
; 339  : 		return TICK_MAX;

	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH

; 340  : }

	ret	0
?nextCommandExecuteTime@Channel@DRAMsimII@@IBE_JXZ ENDP	; DRAMsimII::Channel::nextCommandExecuteTime
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
_TEXT	ENDS
;	COMDAT ??0list0@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??0list0@_bi@boost@@QAE@XZ PROC				; boost::_bi::list0::list0, COMDAT
; _this$ = eax

; 168  :     list0() {}

	ret	0
??0list0@_bi@boost@@QAE@XZ ENDP				; boost::_bi::list0::list0
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\basic_timed_mutex.hpp
_TEXT	ENDS
;	COMDAT ?destroy@basic_timed_mutex@detail@boost@@QAEXXZ
_TEXT	SEGMENT
?destroy@basic_timed_mutex@detail@boost@@QAEXXZ PROC	; boost::detail::basic_timed_mutex::destroy, COMDAT
; _this$ = ecx

; 42   : #ifdef BOOST_MSVC
; 43   : #pragma warning(push)
; 44   : #pragma warning(disable:4312)
; 45   : #endif
; 46   :                 void* const old_event=BOOST_INTERLOCKED_EXCHANGE_POINTER(&event,0);

	xor	eax, eax
	add	ecx, 4
	xchg	DWORD PTR [ecx], eax

; 47   : #ifdef BOOST_MSVC
; 48   : #pragma warning(pop)
; 49   : #endif
; 50   :                 if(old_event)

	test	eax, eax
	je	SHORT $LN1@destroy@2

; 51   :                 {
; 52   :                     win32::CloseHandle(old_event);

	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN1@destroy@2:

; 53   :                 }
; 54   :             }

	ret	0
?destroy@basic_timed_mutex@detail@boost@@QAEXXZ ENDP	; boost::detail::basic_timed_mutex::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?initialize@basic_timed_mutex@detail@boost@@QAEXXZ
_TEXT	SEGMENT
?initialize@basic_timed_mutex@detail@boost@@QAEXXZ PROC	; boost::detail::basic_timed_mutex::initialize, COMDAT
; _this$ = ecx

; 36   :                 active_count=0;

	mov	DWORD PTR [ecx], 0

; 37   :                 event=0;

	mov	DWORD PTR [ecx+4], 0

; 38   :             }

	ret	0
?initialize@basic_timed_mutex@detail@boost@@QAEXXZ ENDP	; boost::detail::basic_timed_mutex::initialize
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_data.hpp
_TEXT	ENDS
;	COMDAT ?intrusive_ptr_add_ref@@YAXPAUthread_data_base@detail@boost@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?intrusive_ptr_add_ref@@YAXPAUthread_data_base@detail@boost@@@Z PROC ; intrusive_ptr_add_ref, COMDAT

; 49   :                 BOOST_INTERLOCKED_INCREMENT(&p->count);

	mov	eax, DWORD PTR _p$[esp-4]
	add	eax, 4
	mov	ecx, 1
	lock	 xadd	 DWORD PTR [eax], ecx

; 50   :             }

	ret	0
?intrusive_ptr_add_ref@@YAXPAUthread_data_base@detail@boost@@@Z ENDP ; intrusive_ptr_add_ref
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_heap_alloc.hpp
_TEXT	ENDS
;	COMDAT ?free_raw_heap_memory@detail@boost@@YAXPAX@Z
_TEXT	SEGMENT
_heap_memory$ = 8					; size = 4
?free_raw_heap_memory@detail@boost@@YAXPAX@Z PROC	; boost::detail::free_raw_heap_memory, COMDAT

; 70   :             BOOST_VERIFY(detail::win32::HeapFree(detail::win32::GetProcessHeap(),0,heap_memory)!=0);

	mov	eax, DWORD PTR _heap_memory$[esp-4]
	push	eax
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapFree@12

; 71   :         }

	ret	0
?free_raw_heap_memory@detail@boost@@YAXPAX@Z ENDP	; boost::detail::free_raw_heap_memory
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_primitives.hpp
_TEXT	ENDS
;	COMDAT ??0handle_manager@win32@detail@boost@@QAE@PAX@Z
_TEXT	SEGMENT
_handle_to_manage_$ = 8					; size = 4
??0handle_manager@win32@detail@boost@@QAE@PAX@Z PROC	; boost::detail::win32::handle_manager::handle_manager, COMDAT
; _this$ = ecx

; 235  :                 {}

	mov	eax, ecx
	mov	ecx, DWORD PTR _handle_to_manage_$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	4
??0handle_manager@win32@detail@boost@@QAE@PAX@Z ENDP	; boost::detail::win32::handle_manager::handle_manager
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?cleanup@handle_manager@win32@detail@boost@@AAEXXZ
_TEXT	SEGMENT
?cleanup@handle_manager@win32@detail@boost@@AAEXXZ PROC	; boost::detail::win32::handle_manager::cleanup, COMDAT
; _this$ = ecx

; 226  :                     if(handle_to_manage && handle_to_manage!=invalid_handle_value)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN1@cleanup
	cmp	eax, -1
	je	SHORT $LN1@cleanup

; 227  :                     {
; 228  :                         BOOST_VERIFY(CloseHandle(handle_to_manage));

	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN1@cleanup:

; 229  :                     }
; 230  :                 }

	ret	0
?cleanup@handle_manager@win32@detail@boost@@AAEXXZ ENDP	; boost::detail::win32::handle_manager::cleanup
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gthread_exception@boost@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gthread_exception@boost@@UAEPAXI@Z PROC		; boost::thread_exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1thread_exception@boost@@UAE@XZ	; boost::thread_exception::~thread_exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Gthread_exception@boost@@UAEPAXI@Z ENDP		; boost::thread_exception::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gthread_resource_error@boost@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gthread_resource_error@boost@@UAEPAXI@Z PROC		; boost::thread_resource_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1thread_resource_error@boost@@UAE@XZ	; boost::thread_resource_error::~thread_resource_error
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Gthread_resource_error@boost@@UAEPAXI@Z ENDP		; boost::thread_resource_error::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0thread_exception@boost@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0thread_exception@boost@@QAE@ABV01@@Z PROC		; boost::thread_exception::thread_exception, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	push	edi
	mov	esi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7thread_exception@boost@@6B@
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??0thread_exception@boost@@QAE@ABV01@@Z ENDP		; boost::thread_exception::thread_exception
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0thread_resource_error@boost@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0thread_resource_error@boost@@QAE@ABV01@@Z PROC	; boost::thread_resource_error::thread_resource_error, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	push	edi
	mov	esi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7thread_exception@boost@@6B@
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	pop	edi
	mov	DWORD PTR [esi], OFFSET ??_7thread_resource_error@boost@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0thread_resource_error@boost@@QAE@ABV01@@Z ENDP	; boost::thread_resource_error::thread_resource_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?create_anonymous_event@win32@detail@boost@@YAPAXW4event_type@123@W4initial_event_state@123@@Z
_TEXT	SEGMENT
$T315911 = -20						; size = 16
_type$ = 8						; size = 4
_state$ = 12						; size = 4
?create_anonymous_event@win32@detail@boost@@YAPAXW4event_type@123@W4initial_event_state@123@@Z PROC ; boost::detail::win32::create_anonymous_event, COMDAT

; 173  : #if !defined(BOOST_NO_ANSI_APIS)  
; 174  :                 handle const res=win32::CreateEventA(0,type,state,0);

	mov	eax, DWORD PTR _state$[esp-4]
	mov	ecx, DWORD PTR _type$[esp-4]
	sub	esp, 20					; 00000014H
	push	0
	push	eax
	push	ecx
	push	0
	call	DWORD PTR __imp__CreateEventA@16

; 175  : #else
; 176  :                 handle const res=win32::CreateEventW(0,type,state,0);
; 177  : #endif                
; 178  :                 if(!res)

	test	eax, eax
	jne	SHORT $LN2@create_ano

; 179  :                 {
; 180  :                     throw thread_resource_error();

	lea	ecx, DWORD PTR $T315911[esp+20]
	call	??0thread_resource_error@boost@@QAE@XZ	; boost::thread_resource_error::thread_resource_error
	push	OFFSET __TI3?AVthread_resource_error@boost@@
	lea	edx, DWORD PTR $T315911[esp+24]
	push	edx
	call	__CxxThrowException@8
$LN5@create_ano:
$LN2@create_ano:

; 181  :                 }
; 182  :                 return res;
; 183  :             }

	add	esp, 20					; 00000014H
	ret	0
$LN4@create_ano:
?create_anonymous_event@win32@detail@boost@@YAPAXW4event_type@123@W4initial_event_state@123@@Z ENDP ; boost::detail::win32::create_anonymous_event
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapstub.h
_TEXT	ENDS
;	COMDAT ??1_ns2__submitEpochResultResponseElement@@UAE@XZ
_TEXT	SEGMENT
??1_ns2__submitEpochResultResponseElement@@UAE@XZ PROC	; _ns2__submitEpochResultResponseElement::~_ns2__submitEpochResultResponseElement, COMDAT
; _this$ = ecx

; 285  : 	virtual ~_ns2__submitEpochResultResponseElement() { }

	mov	DWORD PTR [ecx], OFFSET ??_7_ns2__submitEpochResultResponseElement@@6B@
	ret	0
??1_ns2__submitEpochResultResponseElement@@UAE@XZ ENDP	; _ns2__submitEpochResultResponseElement::~_ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_ns2__submitEpochResultResponseElement@@QAE@XZ
_TEXT	SEGMENT
??0_ns2__submitEpochResultResponseElement@@QAE@XZ PROC	; _ns2__submitEpochResultResponseElement::_ns2__submitEpochResultResponseElement, COMDAT
; _this$ = ecx

; 284  : 	_ns2__submitEpochResultResponseElement() : result((bool)0), soap(NULL) { }

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7_ns2__submitEpochResultResponseElement@@6B@
	mov	BYTE PTR [eax+4], cl
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0_ns2__submitEpochResultResponseElement@@QAE@XZ ENDP	; _ns2__submitEpochResultResponseElement::_ns2__submitEpochResultResponseElement
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?soap_type@_ns2__submitEpochResultResponseElement@@UBEHXZ
_TEXT	SEGMENT
?soap_type@_ns2__submitEpochResultResponseElement@@UBEHXZ PROC ; _ns2__submitEpochResultResponseElement::soap_type, COMDAT
; _this$ = ecx

; 277  : 	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE__ns2__submitEpochResultResponseElement */

	mov	eax, 24					; 00000018H
	ret	0
?soap_type@_ns2__submitEpochResultResponseElement@@UBEHXZ ENDP ; _ns2__submitEpochResultResponseElement::soap_type
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?soap_type@_ns2__submitEpochResultElement@@UBEHXZ
_TEXT	SEGMENT
?soap_type@_ns2__submitEpochResultElement@@UBEHXZ PROC	; _ns2__submitEpochResultElement::soap_type, COMDAT
; _this$ = ecx

; 256  : 	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE__ns2__submitEpochResultElement */

	mov	eax, 23					; 00000017H
	ret	0
?soap_type@_ns2__submitEpochResultElement@@UBEHXZ ENDP	; _ns2__submitEpochResultElement::soap_type
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\statistics.h
_TEXT	ENDS
;	COMDAT ?reportMiss@Statistics@DRAMsimII@@QAEXXZ
_TEXT	SEGMENT
?reportMiss@Statistics@DRAMsimII@@QAEXXZ PROC		; DRAMsimII::Statistics::reportMiss, COMDAT
; _this$ = eax

; 159  : 			//#pragma omp atomic
; 160  : 			rowMisses++;

	inc	DWORD PTR [eax+60]

; 161  : 		}

	ret	0
?reportMiss@Statistics@DRAMsimII@@QAEXXZ ENDP		; DRAMsimII::Statistics::reportMiss
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?reportHit@Statistics@DRAMsimII@@QAEXXZ
_TEXT	SEGMENT
?reportHit@Statistics@DRAMsimII@@QAEXXZ PROC		; DRAMsimII::Statistics::reportHit, COMDAT
; _this$ = eax

; 153  : 			//#pragma omp atomic
; 154  : 			rowHits++;

	inc	DWORD PTR [eax+56]

; 155  : 		}

	ret	0
?reportHit@Statistics@DRAMsimII@@QAEXXZ ENDP		; DRAMsimII::Statistics::reportHit
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?reportTFawCommand@Statistics@DRAMsimII@@QAEXXZ
_TEXT	SEGMENT
?reportTFawCommand@Statistics@DRAMsimII@@QAEXXZ PROC	; DRAMsimII::Statistics::reportTFawCommand, COMDAT
; _this$ = eax

; 150  : 		inline void reportTFawCommand() { issuedAtTFAW++; }

	inc	DWORD PTR [eax+64]
	ret	0
?reportTFawCommand@Statistics@DRAMsimII@@QAEXXZ ENDP	; DRAMsimII::Statistics::reportTFawCommand
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\powerconfig.h
_TEXT	ENDS
;	COMDAT ?setLastCalculation@PowerConfig@DRAMsimII@@QAEX_J@Z
_TEXT	SEGMENT
_lastTime$ = 8						; size = 8
?setLastCalculation@PowerConfig@DRAMsimII@@QAEX_J@Z PROC ; DRAMsimII::PowerConfig::setLastCalculation, COMDAT
; _this$ = eax

; 117  : 		void setLastCalculation(const tick lastTime) { lastCalculation = lastTime; }

	mov	ecx, DWORD PTR _lastTime$[esp-4]
	mov	edx, DWORD PTR _lastTime$[esp]
	mov	DWORD PTR [eax+168], ecx
	mov	DWORD PTR [eax+172], edx
	ret	8
?setLastCalculation@PowerConfig@DRAMsimII@@QAEX_J@Z ENDP ; DRAMsimII::PowerConfig::setLastCalculation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resetToTime@PowerConfig@DRAMsimII@@QAEX_J@Z
_TEXT	SEGMENT
_newTime$ = 8						; size = 8
?resetToTime@PowerConfig@DRAMsimII@@QAEX_J@Z PROC	; DRAMsimII::PowerConfig::resetToTime, COMDAT
; _this$ = eax

; 114  : 		void resetToTime(const tick newTime) { lastCalculation = newTime; }

	mov	ecx, DWORD PTR _newTime$[esp-4]
	mov	edx, DWORD PTR _newTime$[esp]
	mov	DWORD PTR [eax+168], ecx
	mov	DWORD PTR [eax+172], edx
	ret	8
?resetToTime@PowerConfig@DRAMsimII@@QAEX_J@Z ENDP	; DRAMsimII::PowerConfig::resetToTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getFrequencyScaleFactor@PowerConfig@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getFrequencyScaleFactor@PowerConfig@DRAMsimII@@QBENXZ PROC ; DRAMsimII::PowerConfig::getFrequencyScaleFactor, COMDAT
; _this$ = eax

; 113  : 		double getFrequencyScaleFactor() const { return frequencyScaleFactor; }

	movsd	xmm0, QWORD PTR [eax+80]
	ret	0
?getFrequencyScaleFactor@PowerConfig@DRAMsimII@@QBENXZ ENDP ; DRAMsimII::PowerConfig::getFrequencyScaleFactor
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getVoltageScaleFactor@PowerConfig@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getVoltageScaleFactor@PowerConfig@DRAMsimII@@QBENXZ PROC ; DRAMsimII::PowerConfig::getVoltageScaleFactor, COMDAT
; _this$ = eax

; 112  : 		double getVoltageScaleFactor() const { return voltageScaleFactor;}

	movsd	xmm0, QWORD PTR [eax+72]
	ret	0
?getVoltageScaleFactor@PowerConfig@DRAMsimII@@QBENXZ ENDP ; DRAMsimII::PowerConfig::getVoltageScaleFactor
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getIDD3P@PowerConfig@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?getIDD3P@PowerConfig@DRAMsimII@@QBEHXZ PROC		; DRAMsimII::PowerConfig::getIDD3P, COMDAT
; _this$ = eax

; 106  : 		int getIDD3P() const { return IDD3P; }

	mov	eax, DWORD PTR [eax+20]
	ret	0
?getIDD3P@PowerConfig@DRAMsimII@@QBEHXZ ENDP		; DRAMsimII::PowerConfig::getIDD3P
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getIDD3N@PowerConfig@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?getIDD3N@PowerConfig@DRAMsimII@@QBEHXZ PROC		; DRAMsimII::PowerConfig::getIDD3N, COMDAT
; _this$ = eax

; 105  : 		int getIDD3N() const { return IDD3N; }

	mov	eax, DWORD PTR [eax+24]
	ret	0
?getIDD3N@PowerConfig@DRAMsimII@@QBEHXZ ENDP		; DRAMsimII::PowerConfig::getIDD3N
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getIDD2P@PowerConfig@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?getIDD2P@PowerConfig@DRAMsimII@@QBEHXZ PROC		; DRAMsimII::PowerConfig::getIDD2P, COMDAT
; _this$ = eax

; 104  : 		int getIDD2P() const { return IDD2P; }		

	mov	eax, DWORD PTR [eax+12]
	ret	0
?getIDD2P@PowerConfig@DRAMsimII@@QBEHXZ ENDP		; DRAMsimII::PowerConfig::getIDD2P
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getIDD2N@PowerConfig@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?getIDD2N@PowerConfig@DRAMsimII@@QBEHXZ PROC		; DRAMsimII::PowerConfig::getIDD2N, COMDAT
; _this$ = eax

; 103  : 		int getIDD2N() const { return IDD2N; }

	mov	eax, DWORD PTR [eax+16]
	ret	0
?getIDD2N@PowerConfig@DRAMsimII@@QBEHXZ ENDP		; DRAMsimII::PowerConfig::getIDD2N
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getDevicesPerRank@PowerConfig@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getDevicesPerRank@PowerConfig@DRAMsimII@@QBEIXZ PROC	; DRAMsimII::PowerConfig::getDevicesPerRank, COMDAT
; _this$ = eax

; 101  : 		unsigned getDevicesPerRank() const { return DQperRank; }

	mov	eax, DWORD PTR [eax+140]
	ret	0
?getDevicesPerRank@PowerConfig@DRAMsimII@@QBEIXZ ENDP	; DRAMsimII::PowerConfig::getDevicesPerRank
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?gettRC@PowerConfig@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?gettRC@PowerConfig@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::PowerConfig::gettRC, COMDAT
; _this$ = eax

; 97   : 		unsigned gettRC() const { return tRC; }

	mov	eax, DWORD PTR [eax+156]
	ret	0
?gettRC@PowerConfig@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::PowerConfig::gettRC
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getPdsWR@PowerConfig@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getPdsWR@PowerConfig@DRAMsimII@@QBENXZ PROC		; DRAMsimII::PowerConfig::getPdsWR, COMDAT
; _this$ = eax

; 94   : 		double getPdsWR() const { return PdsWR; }

	movsd	xmm0, QWORD PTR [eax+64]
	ret	0
?getPdsWR@PowerConfig@DRAMsimII@@QBENXZ ENDP		; DRAMsimII::PowerConfig::getPdsWR
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getPdsRD@PowerConfig@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getPdsRD@PowerConfig@DRAMsimII@@QBENXZ PROC		; DRAMsimII::PowerConfig::getPdsRD, COMDAT
; _this$ = eax

; 93   : 		double getPdsRD() const { return PdsRD; }

	movsd	xmm0, QWORD PTR [eax+56]
	ret	0
?getPdsRD@PowerConfig@DRAMsimII@@QBENXZ ENDP		; DRAMsimII::PowerConfig::getPdsRD
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getPdsACT@PowerConfig@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getPdsACT@PowerConfig@DRAMsimII@@QBENXZ PROC		; DRAMsimII::PowerConfig::getPdsACT, COMDAT
; _this$ = eax

; 90   : 		double getPdsACT() const { return PdsACT; }

	movsd	xmm0, QWORD PTR [eax+40]
	ret	0
?getPdsACT@PowerConfig@DRAMsimII@@QBENXZ ENDP		; DRAMsimII::PowerConfig::getPdsACT
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastCalculation@PowerConfig@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastCalculation@PowerConfig@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::PowerConfig::getLastCalculation, COMDAT
; _this$ = ecx

; 89   : 		tick getLastCalculation() const { return lastCalculation; }

	mov	eax, DWORD PTR [ecx+168]
	mov	edx, DWORD PTR [ecx+172]
	ret	0
?getLastCalculation@PowerConfig@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::PowerConfig::getLastCalculation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getVDDmax@PowerConfig@DRAMsimII@@QBEMXZ
_TEXT	SEGMENT
?getVDDmax@PowerConfig@DRAMsimII@@QBEMXZ PROC		; DRAMsimII::PowerConfig::getVDDmax, COMDAT
; _this$ = eax

; 86   : 		float getVDDmax() const { return VDDmax; }

	movss	xmm0, DWORD PTR [eax+4]
	ret	0
?getVDDmax@PowerConfig@DRAMsimII@@QBEMXZ ENDP		; DRAMsimII::PowerConfig::getVDDmax
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\rank.h
_TEXT	ENDS
;	COMDAT ?resetCycleCounts@Rank@DRAMsimII@@QAEXXZ
_TEXT	SEGMENT
?resetCycleCounts@Rank@DRAMsimII@@QAEXXZ PROC		; DRAMsimII::Rank::resetCycleCounts, COMDAT
; _this$ = eax

; 120  : 		void resetCycleCounts() { CASLength = CASWLength = 0; }

	xor	ecx, ecx
	mov	DWORD PTR [eax+132], ecx
	mov	DWORD PTR [eax+128], ecx
	ret	0
?resetCycleCounts@Rank@DRAMsimII@@QAEXXZ ENDP		; DRAMsimII::Rank::resetCycleCounts
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setLastBankID@Rank@DRAMsimII@@QAEXI@Z
_TEXT	SEGMENT
?setLastBankID@Rank@DRAMsimII@@QAEXI@Z PROC		; DRAMsimII::Rank::setLastBankID, COMDAT
; _this$ = eax
; _value$ = ecx

; 118  : 		void setLastBankID(const unsigned value) { lastBankID = value; }

	mov	DWORD PTR [eax+140], ecx
	ret	0
?setLastBankID@Rank@DRAMsimII@@QAEXI@Z ENDP		; DRAMsimII::Rank::setLastBankID
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setRankID@Rank@DRAMsimII@@QAEXI@Z
_TEXT	SEGMENT
?setRankID@Rank@DRAMsimII@@QAEXI@Z PROC			; DRAMsimII::Rank::setRankID, COMDAT
; _this$ = eax
; _value$ = ecx

; 117  : 		void setRankID(const unsigned value) { rankID = value; }

	mov	DWORD PTR [eax+136], ecx
	ret	0
?setRankID@Rank@DRAMsimII@@QAEXI@Z ENDP			; DRAMsimII::Rank::setRankID
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getWriteCycles@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getWriteCycles@Rank@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Rank::getWriteCycles, COMDAT
; _this$ = eax

; 112  : 		unsigned getWriteCycles() const { return CASWLength; }

	mov	eax, DWORD PTR [eax+132]
	ret	0
?getWriteCycles@Rank@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Rank::getWriteCycles
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getReadCycles@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getReadCycles@Rank@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Rank::getReadCycles, COMDAT
; _this$ = eax

; 111  : 		unsigned getReadCycles() const { return CASLength; }

	mov	eax, DWORD PTR [eax+128]
	ret	0
?getReadCycles@Rank@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Rank::getReadCycles
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getOtherLastCASWLength@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getOtherLastCASWLength@Rank@DRAMsimII@@QBEIXZ PROC	; DRAMsimII::Rank::getOtherLastCASWLength, COMDAT
; _this$ = eax

; 110  : 		unsigned getOtherLastCASWLength() const { return otherLastCASWLength; }

	mov	eax, DWORD PTR [eax+124]
	ret	0
?getOtherLastCASWLength@Rank@DRAMsimII@@QBEIXZ ENDP	; DRAMsimII::Rank::getOtherLastCASWLength
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getOtherLastCASLength@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getOtherLastCASLength@Rank@DRAMsimII@@QBEIXZ PROC	; DRAMsimII::Rank::getOtherLastCASLength, COMDAT
; _this$ = eax

; 109  : 		unsigned getOtherLastCASLength() const { return otherLastCASLength; }

	mov	eax, DWORD PTR [eax+120]
	ret	0
?getOtherLastCASLength@Rank@DRAMsimII@@QBEIXZ ENDP	; DRAMsimII::Rank::getOtherLastCASLength
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastCASWLength@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getLastCASWLength@Rank@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Rank::getLastCASWLength, COMDAT
; _this$ = eax

; 108  : 		unsigned getLastCASWLength() const { return lastCASWLength; }

	mov	eax, DWORD PTR [eax+116]
	ret	0
?getLastCASWLength@Rank@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Rank::getLastCASWLength
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastCASLength@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getLastCASLength@Rank@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Rank::getLastCASLength, COMDAT
; _this$ = eax

; 107  : 		unsigned getLastCASLength() const { return lastCASLength; }

	mov	eax, DWORD PTR [eax+112]
	ret	0
?getLastCASLength@Rank@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Rank::getLastCASLength
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastPrechargeTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastPrechargeTime@Rank@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Rank::getLastPrechargeTime, COMDAT
; _this$ = ecx

; 105  : 		tick getLastPrechargeTime() const { return lastPrechargeAnyBankTime; }

	mov	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR [ecx+20]
	ret	0
?getLastPrechargeTime@Rank@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Rank::getLastPrechargeTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getOtherLastCASWTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getOtherLastCASWTime@Rank@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Rank::getOtherLastCASWTime, COMDAT
; _this$ = ecx

; 104  : 		tick getOtherLastCASWTime() const { return otherLastCASWTime; }

	mov	eax, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR [ecx+52]
	ret	0
?getOtherLastCASWTime@Rank@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Rank::getOtherLastCASWTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getOtherLastCASTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getOtherLastCASTime@Rank@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Rank::getOtherLastCASTime, COMDAT
; _this$ = ecx

; 103  : 		tick getOtherLastCASTime() const { return otherLastCASTime; }

	mov	eax, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR [ecx+44]
	ret	0
?getOtherLastCASTime@Rank@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Rank::getOtherLastCASTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastCASWTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastCASWTime@Rank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Rank::getLastCASWTime, COMDAT
; _this$ = ecx

; 102  : 		tick getLastCASWTime() const { return lastCASWTime; }

	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]
	ret	0
?getLastCASWTime@Rank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Rank::getLastCASWTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastCASTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastCASTime@Rank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Rank::getLastCASTime, COMDAT
; _this$ = ecx

; 101  : 		tick getLastCASTime() const { return lastCASTime; }

	mov	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [ecx+28]
	ret	0
?getLastCASTime@Rank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Rank::getLastCASTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastRefreshTime@Rank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastRefreshTime@Rank@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Rank::getLastRefreshTime, COMDAT
; _this$ = ecx

; 100  : 		tick getLastRefreshTime() const { return lastRefreshTime; }

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	ret	0
?getLastRefreshTime@Rank@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Rank::getLastRefreshTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getRankID@Rank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getRankID@Rank@DRAMsimII@@QBEIXZ PROC			; DRAMsimII::Rank::getRankID, COMDAT
; _this$ = eax

; 97   : 		unsigned getRankID() const { return rankID; }		

	mov	eax, DWORD PTR [eax+136]
	ret	0
?getRankID@Rank@DRAMsimII@@QBEIXZ ENDP			; DRAMsimII::Rank::getRankID
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.h
_TEXT	ENDS
;	COMDAT ?getRASCount@Bank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getRASCount@Bank@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Bank::getRASCount, COMDAT
; _this$ = eax

; 94   : 		unsigned getRASCount() const { return RASCount; }

	mov	eax, DWORD PTR [eax+128]
	ret	0
?getRASCount@Bank@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Bank::getRASCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isActivated@Bank@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isActivated@Bank@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Bank::isActivated, COMDAT
; _this$ = eax

; 92   : 		bool isActivated() const { return activated; }

	mov	al, BYTE PTR [eax+124]
	ret	0
?isActivated@Bank@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Bank::isActivated
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastPrechargeTime@Bank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastPrechargeTime@Bank@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Bank::getLastPrechargeTime, COMDAT
; _this$ = ecx

; 86   : 		tick getLastPrechargeTime() const { return lastPrechargeTime; }

	mov	eax, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR [ecx+76]
	ret	0
?getLastPrechargeTime@Bank@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Bank::getLastPrechargeTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastCASWTime@Bank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastCASWTime@Bank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Bank::getLastCASWTime, COMDAT
; _this$ = ecx

; 84   : 		tick getLastCASWTime() const {return lastCASWTime; }

	mov	eax, DWORD PTR [ecx+64]
	mov	edx, DWORD PTR [ecx+68]
	ret	0
?getLastCASWTime@Bank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Bank::getLastCASWTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastCASTime@Bank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastCASTime@Bank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Bank::getLastCASTime, COMDAT
; _this$ = ecx

; 83   : 		tick getLastCASTime() const { return lastCASTime; }

	mov	eax, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR [ecx+60]
	ret	0
?getLastCASTime@Bank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Bank::getLastCASTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Bank::getLastRASTime, COMDAT
; _this$ = ecx

; 82   : 		tick getLastRASTime() const { return lastRASTime; }

	mov	eax, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR [ecx+52]
	ret	0
?getLastRASTime@Bank@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Bank::getLastRASTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?accumulateAndResetCounts@Bank@DRAMsimII@@QAEXXZ
_TEXT	SEGMENT
?accumulateAndResetCounts@Bank@DRAMsimII@@QAEXXZ PROC	; DRAMsimII::Bank::accumulateAndResetCounts, COMDAT
; _this$ = eax

; 77   : 		void accumulateAndResetCounts() { totalRASCount += RASCount; totalCASCount += CASCount; totalCASWCount += CASWCount; RASCount = CASWCount = CASCount = 0; }

	mov	ecx, DWORD PTR [eax+128]
	add	DWORD PTR [eax+132], ecx
	mov	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR [eax+136]
	add	DWORD PTR [eax+148], ecx
	add	DWORD PTR [eax+140], edx
	xor	ecx, ecx
	mov	DWORD PTR [eax+136], ecx
	mov	DWORD PTR [eax+144], ecx
	mov	DWORD PTR [eax+128], ecx
	ret	0
?accumulateAndResetCounts@Bank@DRAMsimII@@QAEXXZ ENDP	; DRAMsimII::Bank::accumulateAndResetCounts
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\systemconfiguration.h
_TEXT	ENDS
;	COMDAT ?getDecodeWindow@SystemConfiguration@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getDecodeWindow@SystemConfiguration@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::SystemConfiguration::getDecodeWindow, COMDAT
; _this$ = eax

; 113  : 		unsigned getDecodeWindow() const { return decodeWindow; }

	mov	eax, DWORD PTR [eax+376]
	ret	0
?getDecodeWindow@SystemConfiguration@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::SystemConfiguration::getDecodeWindow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getSessionID@SystemConfiguration@DRAMsimII@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
?getSessionID@SystemConfiguration@DRAMsimII@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; DRAMsimII::SystemConfiguration::getSessionID, COMDAT
; _this$ = eax

; 112  : 		const std::string &getSessionID() const { return sessionID; }

	add	eax, 400				; 00000190H
	ret	0
?getSessionID@SystemConfiguration@DRAMsimII@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; DRAMsimII::SystemConfiguration::getSessionID
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isReadWriteGrouping@SystemConfiguration@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isReadWriteGrouping@SystemConfiguration@DRAMsimII@@QBE_NXZ PROC ; DRAMsimII::SystemConfiguration::isReadWriteGrouping, COMDAT
; _this$ = eax

; 107  : 		bool isReadWriteGrouping() const { return readWriteGrouping; }

	mov	al, BYTE PTR [eax+345]
	ret	0
?isReadWriteGrouping@SystemConfiguration@DRAMsimII@@QBE_NXZ ENDP ; DRAMsimII::SystemConfiguration::isReadWriteGrouping
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getRefreshPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RefreshPolicy@2@XZ
_TEXT	SEGMENT
?getRefreshPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RefreshPolicy@2@XZ PROC ; DRAMsimII::SystemConfiguration::getRefreshPolicy, COMDAT
; _this$ = eax

; 104  : 		RefreshPolicy getRefreshPolicy() const { return refreshPolicy; }

	mov	eax, DWORD PTR [eax+304]
	ret	0
?getRefreshPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RefreshPolicy@2@XZ ENDP ; DRAMsimII::SystemConfiguration::getRefreshPolicy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getDatarate@SystemConfiguration@DRAMsimII@@QBENXZ
_TEXT	SEGMENT
?getDatarate@SystemConfiguration@DRAMsimII@@QBENXZ PROC	; DRAMsimII::SystemConfiguration::getDatarate, COMDAT
; _this$ = eax

; 103  : 		double getDatarate() const { return datarate; }

	movsd	xmm0, QWORD PTR [eax+336]
	ret	0
?getDatarate@SystemConfiguration@DRAMsimII@@QBENXZ ENDP	; DRAMsimII::SystemConfiguration::getDatarate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getTransactionOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4TransactionOrderingAlgorithm@2@XZ
_TEXT	SEGMENT
?getTransactionOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4TransactionOrderingAlgorithm@2@XZ PROC ; DRAMsimII::SystemConfiguration::getTransactionOrderingAlgorithm, COMDAT
; _this$ = eax

; 91   : 		TransactionOrderingAlgorithm getTransactionOrderingAlgorithm() const { return transactionOrderingAlgorithm; }

	mov	eax, DWORD PTR [eax+292]
	ret	0
?getTransactionOrderingAlgorithm@SystemConfiguration@DRAMsimII@@QBE?AW4TransactionOrderingAlgorithm@2@XZ ENDP ; DRAMsimII::SystemConfiguration::getTransactionOrderingAlgorithm
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getRowBufferManagementPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RowBufferPolicy@2@XZ
_TEXT	SEGMENT
?getRowBufferManagementPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RowBufferPolicy@2@XZ PROC ; DRAMsimII::SystemConfiguration::getRowBufferManagementPolicy, COMDAT
; _this$ = eax

; 88   : 		RowBufferPolicy getRowBufferManagementPolicy() const { return rowBufferManagementPolicy; }

	mov	eax, DWORD PTR [eax+328]
	ret	0
?getRowBufferManagementPolicy@SystemConfiguration@DRAMsimII@@QBE?AW4RowBufferPolicy@2@XZ ENDP ; DRAMsimII::SystemConfiguration::getRowBufferManagementPolicy
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\timingspecification.h
_TEXT	ENDS
;	COMDAT ?tOST@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tOST@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tOST, COMDAT
; _this$ = eax

; 83   : 		int tOST() const { return t_ost; }

	mov	eax, DWORD PTR [eax+68]
	ret	0
?tOST@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tOST
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tRTRS@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tRTRS@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRTRS, COMDAT
; _this$ = eax

; 81   : 		int tRTRS() const { return t_rtrs; }

	mov	eax, DWORD PTR [eax+56]
	ret	0
?tRTRS@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRTRS
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tRFC@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tRFC@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRFC, COMDAT
; _this$ = eax

; 79   : 		int tRFC() const { return t_rfc; }

	mov	eax, DWORD PTR [eax+40]
	ret	0
?tRFC@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRFC
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tFAW@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tFAW@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tFAW, COMDAT
; _this$ = eax

; 78   : 		int tFAW() const { return t_faw; }

	mov	eax, DWORD PTR [eax+24]
	ret	0
?tFAW@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tFAW
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tRRD@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tRRD@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tRRD, COMDAT
; _this$ = eax

; 77   : 		int tRRD() const { return t_rrd; }

	mov	eax, DWORD PTR [eax+48]
	ret	0
?tRRD@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tRRD
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tREFI@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tREFI@TimingSpecification@DRAMsimII@@QBEHXZ PROC	; DRAMsimII::TimingSpecification::tREFI, COMDAT
; _this$ = eax

; 74   : 		int tREFI() const { return t_refi; }

	mov	eax, DWORD PTR [eax+80]
	ret	0
?tREFI@TimingSpecification@DRAMsimII@@QBEHXZ ENDP	; DRAMsimII::TimingSpecification::tREFI
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?tBufferDelay@TimingSpecification@DRAMsimII@@QBEHXZ
_TEXT	SEGMENT
?tBufferDelay@TimingSpecification@DRAMsimII@@QBEHXZ PROC ; DRAMsimII::TimingSpecification::tBufferDelay, COMDAT
; _this$ = eax

; 72   : 		int tBufferDelay() const { return t_buffer_delay; }

	mov	eax, DWORD PTR [eax+76]
	ret	0
?tBufferDelay@TimingSpecification@DRAMsimII@@QBEHXZ ENDP ; DRAMsimII::TimingSpecification::tBufferDelay
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\command.h
_TEXT	ENDS
;	COMDAT ?removeHost@Command@DRAMsimII@@QAEPAVTransaction@2@XZ
_TEXT	SEGMENT
?removeHost@Command@DRAMsimII@@QAEPAVTransaction@2@XZ PROC ; DRAMsimII::Command::removeHost, COMDAT
; _this$ = ecx

; 91   : 		Transaction *removeHost() { Transaction* host = hostTransaction; hostTransaction = NULL; return host; }

	mov	eax, DWORD PTR [ecx+84]
	mov	DWORD PTR [ecx+84], 0
	ret	0
?removeHost@Command@DRAMsimII@@QAEPAVTransaction@2@XZ ENDP ; DRAMsimII::Command::removeHost
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isActivate@Command@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isActivate@Command@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Command::isActivate, COMDAT
; _this$ = eax

; 82   : 		bool isActivate() const { return ((commandType == ACTIVATE) || (commandType == ACTIVATE_ALL)); }

	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN3@isActivate
	cmp	eax, 8
	je	SHORT $LN3@isActivate
	xor	eax, eax
	ret	0
$LN3@isActivate:
	mov	eax, 1
	ret	0
?isActivate@Command@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Command::isActivate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getHost@Command@DRAMsimII@@QBEPAVTransaction@2@XZ
_TEXT	SEGMENT
?getHost@Command@DRAMsimII@@QBEPAVTransaction@2@XZ PROC	; DRAMsimII::Command::getHost, COMDAT
; _this$ = eax

; 80   : 		Transaction *getHost() const { return hostTransaction; }

	mov	eax, DWORD PTR [eax+84]
	ret	0
?getHost@Command@DRAMsimII@@QBEPAVTransaction@2@XZ ENDP	; DRAMsimII::Command::getHost
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\transaction.h
_TEXT	ENDS
;	COMDAT ?setDecodeTime@Transaction@DRAMsimII@@QAEX_J@Z
_TEXT	SEGMENT
_value$ = 8						; size = 8
?setDecodeTime@Transaction@DRAMsimII@@QAEX_J@Z PROC	; DRAMsimII::Transaction::setDecodeTime, COMDAT
; _this$ = eax

; 71   : 		void setDecodeTime(const tick value) { decodeTime = value; }

	mov	ecx, DWORD PTR _value$[esp-4]
	mov	edx, DWORD PTR _value$[esp]
	mov	DWORD PTR [eax+88], ecx
	mov	DWORD PTR [eax+92], edx
	ret	8
?setDecodeTime@Transaction@DRAMsimII@@QAEX_J@Z ENDP	; DRAMsimII::Transaction::setDecodeTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isRefresh@Transaction@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isRefresh@Transaction@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Transaction::isRefresh, COMDAT
; _this$ = ecx

; 68   : 		bool isRefresh() const { return (type == AUTO_REFRESH_TRANSACTION); }

	xor	eax, eax
	cmp	DWORD PTR [ecx+80], 4
	sete	al
	ret	0
?isRefresh@Transaction@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Transaction::isRefresh
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isRead@Transaction@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isRead@Transaction@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Transaction::isRead, COMDAT
; _this$ = eax

; 66   : 		bool isRead() const { return ((type == IFETCH_TRANSACTION) || (type == READ_TRANSACTION) || (type == PREFETCH_TRANSACTION)); }

	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN3@isRead
	cmp	eax, 2
	je	SHORT $LN3@isRead
	cmp	eax, 3
	je	SHORT $LN3@isRead
	xor	eax, eax
	ret	0
$LN3@isRead:
	mov	eax, 1
	ret	0
?isRead@Transaction@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Transaction::isRead
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getOriginalTransaction@Transaction@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getOriginalTransaction@Transaction@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::Transaction::getOriginalTransaction, COMDAT
; _this$ = eax

; 65   : 		unsigned getOriginalTransaction() const { return originalTransaction; }		///< get the external transaction that this is a representation for

	mov	eax, DWORD PTR [eax+108]
	ret	0
?getOriginalTransaction@Transaction@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::Transaction::getOriginalTransaction
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\event.h
_TEXT	ENDS
;	COMDAT ?setCompletionTime@Event@DRAMsimII@@QAEX_J@Z
_TEXT	SEGMENT
_ct$ = 8						; size = 8
?setCompletionTime@Event@DRAMsimII@@QAEX_J@Z PROC	; DRAMsimII::Event::setCompletionTime, COMDAT
; _this$ = eax

; 100  : 		void setCompletionTime(const tick ct) { completionTime = ct; }

	mov	ecx, DWORD PTR _ct$[esp-4]
	mov	edx, DWORD PTR _ct$[esp]
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], edx
	ret	8
?setCompletionTime@Event@DRAMsimII@@QAEX_J@Z ENDP	; DRAMsimII::Event::setCompletionTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setStartTime@Event@DRAMsimII@@QAEX_J@Z
_TEXT	SEGMENT
_st$ = 8						; size = 8
?setStartTime@Event@DRAMsimII@@QAEX_J@Z PROC		; DRAMsimII::Event::setStartTime, COMDAT
; _this$ = eax

; 99   : 		void setStartTime(const tick st) { startTime = st; }

	mov	ecx, DWORD PTR _st$[esp-4]
	mov	edx, DWORD PTR _st$[esp]
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], edx
	ret	8
?setStartTime@Event@DRAMsimII@@QAEX_J@Z ENDP		; DRAMsimII::Event::setStartTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setEnqueueTime@Event@DRAMsimII@@QAEX_J@Z
_TEXT	SEGMENT
_et$ = 8						; size = 8
?setEnqueueTime@Event@DRAMsimII@@QAEX_J@Z PROC		; DRAMsimII::Event::setEnqueueTime, COMDAT
; _this$ = eax

; 98   : 		void setEnqueueTime(const tick et) { enqueueTime = et; }

	mov	ecx, DWORD PTR _et$[esp-4]
	mov	edx, DWORD PTR _et$[esp]
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], edx
	ret	8
?setEnqueueTime@Event@DRAMsimII@@QAEX_J@Z ENDP		; DRAMsimII::Event::setEnqueueTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCompletionTime@Event@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getCompletionTime@Event@DRAMsimII@@QBE_JXZ PROC	; DRAMsimII::Event::getCompletionTime, COMDAT
; _this$ = ecx

; 88   : 		tick getCompletionTime() const { return completionTime; }

	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]
	ret	0
?getCompletionTime@Event@DRAMsimII@@QBE_JXZ ENDP	; DRAMsimII::Event::getCompletionTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getStartTime@Event@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getStartTime@Event@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Event::getStartTime, COMDAT
; _this$ = ecx

; 87   : 		tick getStartTime() const { return startTime; }

	mov	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [ecx+28]
	ret	0
?getStartTime@Event@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Event::getStartTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getArrivalTime@Event@DRAMsimII@@QBE_JXZ
_TEXT	SEGMENT
?getArrivalTime@Event@DRAMsimII@@QBE_JXZ PROC		; DRAMsimII::Event::getArrivalTime, COMDAT
; _this$ = ecx

; 85   : 		tick getArrivalTime() const { return arrivalTime; }

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	ret	0
?getArrivalTime@Event@DRAMsimII@@QBE_JXZ ENDP		; DRAMsimII::Event::getArrivalTime
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1Event@DRAMsimII@@UAE@XZ
_TEXT	SEGMENT
??1Event@DRAMsimII@@UAE@XZ PROC				; DRAMsimII::Event::~Event, COMDAT
; _this$ = ecx

; 82   : 		virtual ~Event() {}

	mov	DWORD PTR [ecx], OFFSET ??_7Event@DRAMsimII@@6B@
	ret	0
??1Event@DRAMsimII@@UAE@XZ ENDP				; DRAMsimII::Event::~Event
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.h
_TEXT	ENDS
;	COMDAT ?setBank@Address@DRAMsimII@@QAEXI@Z
_TEXT	SEGMENT
?setBank@Address@DRAMsimII@@QAEXI@Z PROC		; DRAMsimII::Address::setBank, COMDAT
; _this$ = eax
; _value$ = ecx

; 98   : 		void setBank(const unsigned value) { bank = value; }

	mov	DWORD PTR [eax+24], ecx
	ret	0
?setBank@Address@DRAMsimII@@QAEXI@Z ENDP		; DRAMsimII::Address::setBank
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getColumn@Address@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getColumn@Address@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Address::getColumn, COMDAT
; _this$ = eax

; 90   : 		unsigned getColumn() const { return column; }

	mov	eax, DWORD PTR [eax+32]
	ret	0
?getColumn@Address@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Address::getColumn
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getRank@Address@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?getRank@Address@DRAMsimII@@QBEIXZ PROC			; DRAMsimII::Address::getRank, COMDAT
; _this$ = eax

; 87   : 		unsigned getRank() const { return rank; }

	mov	eax, DWORD PTR [eax+20]
	ret	0
?getRank@Address@DRAMsimII@@QBEIXZ ENDP			; DRAMsimII::Address::getRank
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\noncopyable.hpp
_TEXT	ENDS
;	COMDAT ??1noncopyable@noncopyable_@boost@@IAE@XZ
_TEXT	SEGMENT
??1noncopyable@noncopyable_@boost@@IAE@XZ PROC		; boost::noncopyable_::noncopyable::~noncopyable, COMDAT
; _this$ = ecx

; 25   :       ~noncopyable() {}

	ret	0
??1noncopyable@noncopyable_@boost@@IAE@XZ ENDP		; boost::noncopyable_::noncopyable::~noncopyable
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0noncopyable@noncopyable_@boost@@IAE@XZ
_TEXT	SEGMENT
??0noncopyable@noncopyable_@boost@@IAE@XZ PROC		; boost::noncopyable_::noncopyable::noncopyable, COMDAT
; _this$ = ecx

; 24   :       noncopyable() {}

	mov	eax, ecx
	ret	0
??0noncopyable@noncopyable_@boost@@IAE@XZ ENDP		; boost::noncopyable_::noncopyable::noncopyable
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_alloc@std@@QAE@XZ PROC				; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 376  : 		{	// construct from message string with no memory allocation

	push	esi
	push	1
	push	OFFSET __bad_alloc_Message
	mov	esi, ecx
	call	??0exception@std@@QAE@ABQBDH@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 377  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0bad_alloc@std@@QAE@XZ ENDP				; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@12
	push	esi
	npad	7
$LL9@Fill_n@12:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@12
	pop	esi
$LN7@Fill_n@12:

; 3255 : 	}

	ret	0
??$_Fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<double *,double *,std::allocator<double> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@20
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@20:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<double *,double *,std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAMIM@std@@YAXPAMIABMUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAMIM@std@@YAXPAMIABMUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<float *,unsigned int,float>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@13
$LL9@Fill_n@13:
	fld	DWORD PTR [edx]
	dec	eax
	fstp	DWORD PTR [ecx]
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@13
$LN7@Fill_n@13:

; 3255 : 	}

	ret	0
??$_Fill_n@PAMIM@std@@YAXPAMIABMUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<float *,unsigned int,float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@14
	push	esi
	npad	7
$LL9@Fill_n@14:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@14
	pop	esi
$LN7@Fill_n@14:

; 3255 : 	}

	ret	0
??$_Fill_n@PAPAU?$pair@I_J@std@@IPAU12@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<__int64 *,unsigned int,__int64>, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	eax, DWORD PTR __First$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN7@Fill_n@15
	push	esi
	npad	7
$LL9@Fill_n@15:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL9@Fill_n@15
	pop	esi
$LN7@Fill_n@15:

; 3255 : 	}

	ret	0
??$_Fill_n@PA_JI_J@std@@YAXPA_JIAB_JUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<__int64 *,unsigned int,__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PANIN@std@@YAXPANIABNUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PANIN@std@@YAXPANIABNUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<double *,unsigned int,double>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@16
$LL9@Fill_n@16:
	fld	QWORD PTR [edx]
	dec	eax
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	test	eax, eax
	ja	SHORT $LL9@Fill_n@16
$LN7@Fill_n@16:

; 3255 : 	}

	ret	0
??$_Fill_n@PANIN@std@@YAXPANIABNUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<double *,unsigned int,double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@17
	push	esi
	npad	7
$LL9@Fill_n@17:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@17
	pop	esi
$LN7@Fill_n@17:

; 3255 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@21
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@21:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@@Z PROC ; stdext::unchecked_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@22
	push	esi
	npad	7
$LL13@unchecked_@22:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_@22
	pop	esi
$LN11@unchecked_@22:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@@Z ENDP ; stdext::unchecked_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PANPANV?$allocator@N@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00AAV?$allocator@N@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PANPANV?$allocator@N@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00AAV?$allocator@N@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<double *,double *,std::allocator<double>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Uninit_mov@3
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Uninit_mov@3:
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PANPANV?$allocator@N@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00AAV?$allocator@N@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<double *,double *,std::allocator<double>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAMIM@stdext@@YAXPAMIABM@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAMIM@stdext@@YAXPAMIABM@Z PROC	; stdext::unchecked_fill_n<float *,unsigned int,float>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@23
$LL13@unchecked_@23:
	fld	DWORD PTR [edx]
	dec	eax
	fstp	DWORD PTR [ecx]
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_@23
$LN11@unchecked_@23:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAMIM@stdext@@YAXPAMIABM@Z ENDP	; stdext::unchecked_fill_n<float *,unsigned int,float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAPAU?$pair@I_J@std@@IPAU12@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAPAU?$pair@I_J@std@@IPAU12@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@@Z PROC ; stdext::unchecked_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@24
	push	esi
	npad	7
$LL13@unchecked_@24:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_@24
	pop	esi
$LN11@unchecked_@24:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPAU?$pair@I_J@std@@IPAU12@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@@Z ENDP ; stdext::unchecked_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PA_JI_J@stdext@@YAXPA_JIAB_J@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PA_JI_J@stdext@@YAXPA_JIAB_J@Z PROC	; stdext::unchecked_fill_n<__int64 *,unsigned int,__int64>, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __First$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN11@unchecked_@25
	push	esi
	npad	7
$LL13@unchecked_@25:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL13@unchecked_@25
	pop	esi
$LN11@unchecked_@25:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PA_JI_J@stdext@@YAXPA_JIAB_J@Z ENDP	; stdext::unchecked_fill_n<__int64 *,unsigned int,__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PANIN@stdext@@YAXPANIABN@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PANIN@stdext@@YAXPANIABN@Z PROC	; stdext::unchecked_fill_n<double *,unsigned int,double>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@26
$LL13@unchecked_@26:
	fld	QWORD PTR [edx]
	dec	eax
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	test	eax, eax
	ja	SHORT $LL13@unchecked_@26
$LN11@unchecked_@26:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PANIN@stdext@@YAXPANIABN@Z ENDP	; stdext::unchecked_fill_n<double *,unsigned int,double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@27
	push	esi
	npad	7
$LL13@unchecked_@27:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_@27
	pop	esi
$LN11@unchecked_@27:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Uninit_mov@4
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Uninit_mov@4:
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\smart_ptr\intrusive_ptr.hpp
_TEXT	ENDS
;	COMDAT ??0?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@PAUthread_data_base@detail@1@_N@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_add_ref$ = 12						; size = 1
??0?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@PAUthread_data_base@detail@1@_N@Z PROC ; boost::intrusive_ptr<boost::detail::thread_data_base>::intrusive_ptr<boost::detail::thread_data_base>, COMDAT
; _this$ = ecx

; 71   :     {

	mov	eax, ecx
	mov	ecx, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx

; 72   :         if( px != 0 && add_ref ) intrusive_ptr_add_ref( px );

	test	ecx, ecx
	je	SHORT $LN4@intrusive_
	cmp	BYTE PTR _add_ref$[esp-4], 0
	je	SHORT $LN4@intrusive_
	add	ecx, 4
	mov	edx, 1
	lock	 xadd	 DWORD PTR [ecx], edx
$LN4@intrusive_:

; 73   :     }

	ret	8
??0?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@PAUthread_data_base@detail@1@_N@Z ENDP ; boost::intrusive_ptr<boost::detail::thread_data_base>::intrusive_ptr<boost::detail::thread_data_base>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil@5
	push	esi
	npad	7
$LL15@Uninit_fil@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil@5
	pop	esi
$LN13@Uninit_fil@5:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@4
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@4:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAPAVTransaction@DRAMsimII@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN30@Unchecked_@6
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN30@Unchecked_@6:
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAPAVTransaction@DRAMsimII@@PAPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PANPANUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PANPANUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<double *,double *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	sub	eax, edi
	sar	eax, 3
	lea	edx, DWORD PTR [eax*8]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@5
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@5:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PANPANUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<double *,double *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<double *,double *,std::allocator<double> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN30@Unchecked_@7
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN30@Unchecked_@7:
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<double *,double *,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAMIMV?$allocator@M@std@@@std@@YAXPAMIABMAAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAMIMV?$allocator@M@std@@@std@@YAXPAMIABMAAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<float *,unsigned int,float,std::allocator<float> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil@6
$LL15@Uninit_fil@6:
	fld	DWORD PTR [edx]
	dec	eax
	fstp	DWORD PTR [ecx]
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil@6
$LN13@Uninit_fil@6:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAMIMV?$allocator@M@std@@@std@@YAXPAMIABMAAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<float *,unsigned int,float,std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@6
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@6:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *,std::allocator<std::pair<unsigned int,__int64> *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil@7
	push	esi
	npad	7
$LL15@Uninit_fil@7:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil@7
	pop	esi
$LN13@Uninit_fil@7:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@std@@YAXPAPAU?$pair@I_J@0@IABQAU10@AAV?$allocator@PAU?$pair@I_J@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *,std::allocator<std::pair<unsigned int,__int64> *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PA_JI_JV?$allocator@_J@std@@@std@@YAXPA_JIAB_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PA_JI_JV?$allocator@_J@std@@@std@@YAXPA_JIAB_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<__int64 *,unsigned int,__int64,std::allocator<__int64> >, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN13@Uninit_fil@8
	push	esi
	npad	7
$LL15@Uninit_fil@8:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL15@Uninit_fil@8
	pop	esi
$LN13@Uninit_fil@8:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PA_JI_JV?$allocator@_J@std@@@std@@YAXPA_JIAB_JAAV?$allocator@_J@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<__int64 *,unsigned int,__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PANINV?$allocator@N@std@@@std@@YAXPANIABNAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PANINV?$allocator@N@std@@@std@@YAXPANIABNAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<double *,unsigned int,double,std::allocator<double> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil@9
$LL15@Uninit_fil@9:
	fld	QWORD PTR [edx]
	dec	eax
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil@9
$LN13@Uninit_fil@9:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PANINV?$allocator@N@std@@@std@@YAXPANIABNAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<double *,unsigned int,double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil@10
	push	esi
	npad	7
$LL15@Uninit_fil@10:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil@10
	pop	esi
$LN13@Uninit_fil@10:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@PAPAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@2@@stdext@@YAPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@4@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@PAPAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@2@@stdext@@YAPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@4@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN34@Unchecked_@8
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN34@Unchecked_@8:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@PAPAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@2@@stdext@@YAPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@4@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >,DRAMsimII::Transaction * *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<float *,float *,std::allocator<float> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@28
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@28:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<float *,float *,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@29
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@29:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PA_JPA_JV?$allocator@_J@std@@@stdext@@YAPA_JPA_J00AAV?$allocator@_J@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PA_JPA_JV?$allocator@_J@std@@@stdext@@YAPA_JPA_J00AAV?$allocator@_J@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<__int64 *,__int64 *,std::allocator<__int64> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@30
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@30:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PA_JPA_JV?$allocator@_J@std@@@stdext@@YAPA_JPA_J00AAV?$allocator@_J@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<__int64 *,__int64 *,std::allocator<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 *,std::allocator<__int64> >, COMDAT
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN20@unchecked_@31
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN20@unchecked_@31:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@PA_JV?$allocator@_J@2@@stdext@@YAPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@0PA_JAAV?$allocator@_J@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,__int64 *,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@IPAPAU10@@Z
_TEXT	SEGMENT
$T339756 = -16						; size = 4
$T339748 = -12						; size = 12
??$_Allocate@PAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@IPAPAU10@@Z PROC ; std::_Allocate<std::pair<unsigned int,__int64> *>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@17

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T339756[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T339748[esp+20]
	mov	DWORD PTR $T339756[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T339748[esp+20]
	push	ecx
	mov	DWORD PTR $T339748[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@17:
$LN1@Allocate@17:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@17:
??$_Allocate@PAU?$pair@I_J@std@@@std@@YAPAPAU?$pair@I_J@0@IPAPAU10@@Z ENDP ; std::_Allocate<std::pair<unsigned int,__int64> *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@32
	push	esi
	npad	7
$LL19@unchecked_@32:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@32
	pop	esi
$LN17@unchecked_@32:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPAVTransaction@DRAMsimII@@IPAV12@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@stdext@@YAXPAPAVTransaction@DRAMsimII@@IABQAV12@AAV?$allocator@PAVTransaction@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Transaction * *,unsigned int,DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z PROC ; stdext::_Unchecked_move_backward<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN22@Unchecked_@9
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Unchecked_@9:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAPAVTransaction@DRAMsimII@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV23@00@Z
_TEXT	SEGMENT
??$_Umove@PAPAVTransaction@DRAMsimII@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV23@00@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<DRAMsimII::Transaction * *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN32@Umove@3
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@Umove@3:
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	0
??$_Umove@PAPAVTransaction@DRAMsimII@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV23@00@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<DRAMsimII::Transaction * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@N@std@@YAPANIPAN@Z
_TEXT	SEGMENT
$T340102 = -16						; size = 4
$T340094 = -12						; size = 12
??$_Allocate@N@std@@YAPANIPAN@Z PROC			; std::_Allocate<double>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 8
	jae	SHORT $LN1@Allocate@18

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T340102[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T340094[esp+20]
	mov	DWORD PTR $T340102[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T340094[esp+20]
	push	ecx
	mov	DWORD PTR $T340094[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@18:
$LN1@Allocate@18:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@18:
??$_Allocate@N@std@@YAPANIPAN@Z ENDP			; std::_Allocate<double>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PANPAN@stdext@@YAPANPAN00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PANPAN@stdext@@YAPANPAN00@Z PROC ; stdext::_Unchecked_move_backward<double *,double *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 3
	lea	edx, DWORD PTR [eax*8]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN22@Unchecked_@10
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Unchecked_@10:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PANPAN@stdext@@YAPANPAN00@Z ENDP ; stdext::_Unchecked_move_backward<double *,double *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z
_TEXT	SEGMENT
??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z PROC ; std::vector<double,std::allocator<double> >::_Umove<double *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN32@Umove@4
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@Umove@4:
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	0
??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z ENDP ; std::vector<double,std::allocator<double> >::_Umove<double *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@M@std@@YAPAMIPAM@Z
_TEXT	SEGMENT
$T340345 = -16						; size = 4
$T340337 = -12						; size = 12
??$_Allocate@M@std@@YAPAMIPAM@Z PROC			; std::_Allocate<float>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@19

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T340345[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T340337[esp+20]
	mov	DWORD PTR $T340345[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T340337[esp+20]
	push	ecx
	mov	DWORD PTR $T340337[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@19:
$LN1@Allocate@19:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@19:
??$_Allocate@M@std@@YAPAMIPAM@Z ENDP			; std::_Allocate<float>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAMIMV?$allocator@M@std@@@stdext@@YAXPAMIABMAAV?$allocator@M@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAMIMV?$allocator@M@std@@@stdext@@YAXPAMIABMAAV?$allocator@M@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<float *,unsigned int,float,std::allocator<float> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@33
$LL19@unchecked_@33:
	fld	DWORD PTR [edx]
	dec	eax
	fstp	DWORD PTR [ecx]
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@33
$LN17@unchecked_@33:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAMIMV?$allocator@M@std@@@stdext@@YAXPAMIABMAAV?$allocator@M@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<float *,unsigned int,float,std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T340462 = -16						; size = 4
$T340454 = -12						; size = 12
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@20

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T340462[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T340454[esp+20]
	mov	DWORD PTR $T340462[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T340454[esp+20]
	push	ecx
	mov	DWORD PTR $T340454[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@20:
$LN1@Allocate@20:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@20:
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN22@Unchecked_@11
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Unchecked_@11:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@U?$pair@I_J@std@@U12@@std@@YAXPAU?$pair@I_J@0@ABU10@@Z
_TEXT	SEGMENT
??$_Construct@U?$pair@I_J@std@@U12@@std@@YAXPAU?$pair@I_J@0@ABU10@@Z PROC ; std::_Construct<std::pair<unsigned int,__int64>,std::pair<unsigned int,__int64> >, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct@14
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR [eax+8], xmm0
$LN3@Construct@14:

; 53   : 	}

	ret	0
??$_Construct@U?$pair@I_J@std@@U12@@std@@YAXPAU?$pair@I_J@0@ABU10@@Z ENDP ; std::_Construct<std::pair<unsigned int,__int64>,std::pair<unsigned int,__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U?$pair@I_J@std@@@std@@YAPAU?$pair@I_J@0@IPAU10@@Z
_TEXT	SEGMENT
$T340552 = -16						; size = 4
$T340544 = -12						; size = 12
??$_Allocate@U?$pair@I_J@std@@@std@@YAPAU?$pair@I_J@0@IPAU10@@Z PROC ; std::_Allocate<std::pair<unsigned int,__int64> >, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN1@Allocate@21

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T340552[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T340544[esp+20]
	mov	DWORD PTR $T340552[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T340544[esp+20]
	push	ecx
	mov	DWORD PTR $T340544[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@21:
$LN1@Allocate@21:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@21:
??$_Allocate@U?$pair@I_J@std@@@std@@YAPAU?$pair@I_J@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<unsigned int,__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *,std::allocator<std::pair<unsigned int,__int64> *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@34
	push	esi
	npad	7
$LL19@unchecked_@34:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@34
	pop	esi
$LN17@unchecked_@34:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPAU?$pair@I_J@std@@IPAU12@V?$allocator@PAU?$pair@I_J@std@@@2@@stdext@@YAXPAPAU?$pair@I_J@std@@IABQAU12@AAV?$allocator@PAU?$pair@I_J@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned int,__int64> * *,unsigned int,std::pair<unsigned int,__int64> *,std::allocator<std::pair<unsigned int,__int64> *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@VRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@IPAV12@@Z
_TEXT	SEGMENT
$T340669 = -16						; size = 4
$T340661 = -12						; size = 12
??$_Allocate@VRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@IPAV12@@Z PROC ; std::_Allocate<DRAMsimII::Rank>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 200				; 000000c8H
	jae	SHORT $LN1@Allocate@22

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T340669[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T340661[esp+20]
	mov	DWORD PTR $T340669[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T340661[esp+20]
	push	ecx
	mov	DWORD PTR $T340661[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@22:
$LN1@Allocate@22:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	imul	ecx, 200				; 000000c8H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@22:
??$_Allocate@VRank@DRAMsimII@@@std@@YAPAVRank@DRAMsimII@@IPAV12@@Z ENDP ; std::_Allocate<DRAMsimII::Rank>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PA_JI_JV?$allocator@_J@std@@@stdext@@YAXPA_JIAB_JAAV?$allocator@_J@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PA_JI_JV?$allocator@_J@std@@@stdext@@YAXPA_JIAB_JAAV?$allocator@_J@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<__int64 *,unsigned int,__int64,std::allocator<__int64> >, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __First$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN17@unchecked_@35
	push	esi
	npad	7
$LL19@unchecked_@35:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL19@unchecked_@35
	pop	esi
$LN17@unchecked_@35:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PA_JI_JV?$allocator@_J@std@@@stdext@@YAXPA_JIAB_JAAV?$allocator@_J@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<__int64 *,unsigned int,__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@_J@std@@YAPA_JIPA_J@Z
_TEXT	SEGMENT
$T340786 = -16						; size = 4
$T340778 = -12						; size = 12
??$_Allocate@_J@std@@YAPA_JIPA_J@Z PROC			; std::_Allocate<__int64>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 8
	jae	SHORT $LN1@Allocate@23

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T340786[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T340778[esp+20]
	mov	DWORD PTR $T340786[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T340778[esp+20]
	push	ecx
	mov	DWORD PTR $T340778[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@23:
$LN1@Allocate@23:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@23:
??$_Allocate@_J@std@@YAPA_JIPA_J@Z ENDP			; std::_Allocate<__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@IPAPAV12@@Z
_TEXT	SEGMENT
$T340800 = -16						; size = 4
$T340792 = -12						; size = 12
??$_Allocate@PAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@IPAPAV12@@Z PROC ; std::_Allocate<DRAMsimII::Transaction *>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@24

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T340800[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T340792[esp+20]
	mov	DWORD PTR $T340800[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T340792[esp+20]
	push	ecx
	mov	DWORD PTR $T340792[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@24:
$LN1@Allocate@24:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@24:
??$_Allocate@PAVTransaction@DRAMsimII@@@std@@YAPAPAVTransaction@DRAMsimII@@IPAPAV12@@Z ENDP ; std::_Allocate<DRAMsimII::Transaction *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PANINV?$allocator@N@std@@@stdext@@YAXPANIABNAAV?$allocator@N@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PANINV?$allocator@N@std@@@stdext@@YAXPANIABNAAV?$allocator@N@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<double *,unsigned int,double,std::allocator<double> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@36
$LL19@unchecked_@36:
	fld	QWORD PTR [edx]
	dec	eax
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	test	eax, eax
	ja	SHORT $LL19@unchecked_@36
$LN17@unchecked_@36:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PANINV?$allocator@N@std@@@stdext@@YAXPANIABNAAV?$allocator@N@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<double *,unsigned int,double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@37
	push	esi
	npad	7
$LL19@unchecked_@37:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@37
	pop	esi
$LN17@unchecked_@37:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Umove@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> > >, COMDAT
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN36@Umove@5
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN36@Umove@5:

; 1149 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Umove@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@V?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z
_TEXT	SEGMENT
??$_Ucopy@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z PROC ; std::vector<float,std::allocator<float> >::_Ucopy<float *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Ucopy@4
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Ucopy@4:
	mov	eax, esi
	pop	esi

; 1142 : 		}

	ret	0
??$_Ucopy@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ENDP ; std::vector<float,std::allocator<float> >::_Ucopy<float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<int *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Ucopy@5
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Ucopy@5:
	mov	eax, esi
	pop	esi

; 1142 : 		}

	ret	0
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z
_TEXT	SEGMENT
??$_Ucopy@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<__int64 *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Ucopy@6
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Ucopy@6:
	mov	eax, esi
	pop	esi

; 1142 : 		}

	ret	0
??$_Ucopy@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<__int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Ucopy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >, COMDAT
; __Ptr$ = edx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN22@Ucopy@7
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Ucopy@7:

; 1142 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	16					; 00000010H
??$_Ucopy@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@1@0PA_J@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_heap_alloc.hpp
_TEXT	ENDS
;	COMDAT ??$heap_delete@Uthread_data_base@detail@boost@@@detail@boost@@YAXPAUthread_data_base@01@@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
??$heap_delete@Uthread_data_base@detail@boost@@@detail@boost@@YAXPAUthread_data_base@01@@Z PROC ; boost::detail::heap_delete<boost::detail::thread_data_base>, COMDAT

; 378  :         {

	push	esi

; 379  :             data->~T();

	mov	esi, DWORD PTR _data$[esp]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	0
	mov	ecx, esi
	call	edx

; 380  :             free_raw_heap_memory(data);

	push	esi
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapFree@12
	pop	esi

; 381  :         }

	ret	0
??$heap_delete@Uthread_data_base@detail@boost@@@detail@boost@@YAXPAUthread_data_base@01@@Z ENDP ; boost::detail::heap_delete<boost::detail::thread_data_base>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@MHPBMABMV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@MHPBMABMV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@MHPBMABMV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@I_J@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@I_J@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@I_J@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@MHPBMABM@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@MHPBMABM@std@@QAE@XZ PROC			; std::_Ranit<float,int,float const *,float const &>::_Ranit<float,int,float const *,float const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@MHPBMABM@std@@QAE@XZ ENDP			; std::_Ranit<float,int,float const *,float const &>::_Ranit<float,int,float const *,float const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@U?$pair@I_J@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@U?$pair@I_J@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Ranit<std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &>::_Ranit<std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@U?$pair@I_J@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Ranit<std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &>::_Ranit<std::pair<unsigned int,__int64>,int,std::pair<unsigned int,__int64> const *,std::pair<unsigned int,__int64> const &>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<float,std::allocator<float> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@92
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@92
$LN1@operator@92:
	call	__invalid_parameter_noinfo
$LN2@operator@92:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<float,std::allocator<float> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<float,std::allocator<float> >::_Vector_const_iterator<float,std::allocator<float> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@8
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@8
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@8
$LN1@Vector_con@8:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@8:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<float,std::allocator<float> >::_Vector_const_iterator<float,std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??0?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>, COMDAT
; _this$ = edi
; __Pdeque$ = esi

; 125  : 		_Deque_const_iterator(size_type _Off, const _Mydequebase *_Pdeque)

	push	ebx
	mov	ebx, DWORD PTR __Off$[esp]
	mov	DWORD PTR [edi], 0

; 126  : 			{	// construct with offset _Off in *_Pdeque
; 127  : 			_SCL_SECURE_TRAITS_VALIDATE(
; 128  : 				_Pdeque != NULL &&
; 129  : 				((_Mydeque *)_Pdeque)->_Myoff <= _Off && _Off <= (((_Mydeque *)_Pdeque)->_Myoff + ((_Mydeque *)_Pdeque)->_Mysize));

	test	esi, esi
	je	SHORT $LN1@Deque_cons
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	ja	SHORT $LN1@Deque_cons
	mov	ecx, DWORD PTR [esi+28]
	add	ecx, eax
	cmp	ebx, ecx
	jbe	SHORT $LN2@Deque_cons
$LN1@Deque_cons:
	call	__invalid_parameter_noinfo
$LN2@Deque_cons:

; 130  : 				
; 131  : 			this->_Set_container(_Pdeque);

	mov	edx, DWORD PTR [esi]

; 132  : 			_Myoff = _Off;

	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi], edx

; 133  : 			}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@93
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@93
$LN1@operator@93:
	call	__invalid_parameter_noinfo
$LN2@operator@93:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVTransaction@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVTransaction@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVTransaction@DRAMsimII@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@PAVTransaction@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@PAVTransaction@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &>::_Ranit<DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@PAVTransaction@DRAMsimII@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &>::_Ranit<DRAMsimII::Transaction *,int,DRAMsimII::Transaction * const *,DRAMsimII::Transaction * const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<float,std::allocator<float> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@94
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@94
$LN3@operator@94:
	call	__invalid_parameter_noinfo
$LN4@operator@94:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<float,std::allocator<float> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<float,std::allocator<float> >::_Vector_iterator<float,std::allocator<float> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@5
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@5
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@5
$LN3@Vector_ite@5:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@5:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<float,std::allocator<float> >::_Vector_iterator<float,std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??0?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>, COMDAT
; _this$ = edi
; __Pdeque$ = esi

; 381  : 		{	// construct with offset _Off in *_Pdeque

	push	ebx
	mov	ebx, DWORD PTR __Off$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Deque_iter
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	ja	SHORT $LN3@Deque_iter
	mov	ecx, DWORD PTR [esi+28]
	add	ecx, eax
	cmp	ebx, ecx
	jbe	SHORT $LN4@Deque_iter
$LN3@Deque_iter:
	call	__invalid_parameter_noinfo
$LN4@Deque_iter:
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi], edx

; 382  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@95
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@95
$LN3@operator@95:
	call	__invalid_parameter_noinfo
$LN4@operator@95:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@9
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@9
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@9
$LN1@Vector_con@9:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@9:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@@Z PROC ; std::vector<float,std::allocator<float> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN5@Make_iter@7
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN5@Make_iter@7
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN6@Make_iter@7
$LN5@Make_iter@7:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN6@Make_iter@7:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@@Z ENDP ; std::vector<float,std::allocator<float> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEPAPAU?$pair@I_J@2@I@Z
_TEXT	SEGMENT
$T341763 = -16						; size = 4
$T341765 = -12						; size = 12
?allocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEPAPAU?$pair@I_J@2@I@Z PROC ; std::allocator<std::pair<unsigned int,__int64> *>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@8
	xor	ecx, ecx
$LN3@allocate@8:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@8:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate@8
	lea	eax, DWORD PTR $T341763[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T341765[esp+20]
	mov	DWORD PTR $T341763[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T341765[esp+20]
	push	ecx
	mov	DWORD PTR $T341765[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@8:
$LN11@allocate@8:
	int	3
?allocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEPAPAU?$pair@I_J@2@I@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV34@IABQAV34@@Z
_TEXT	SEGMENT
?_Ufill@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV34@IABQAV34@@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill@3
	push	ebx
	npad	7
$LL21@Ufill@3:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL21@Ufill@3
	pop	ebx
$LN26@Ufill@3:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]

; 1256 : 		}

	ret	0
?_Ufill@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV34@IABQAV34@@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEABQAVTransaction@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEABQAVTransaction@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@96
	call	__invalid_parameter_noinfo
$LN1@operator@96:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 771  : 		}

	ret	0
??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBEABQAVTransaction@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@NHPBNABNV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@NHPBNABNV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@NHPBNABNV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@HHPBHABHV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@HHPBHABHV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@HHPBHABHV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@NHPBNABN@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@NHPBNABN@std@@QAE@XZ PROC			; std::_Ranit<double,int,double const *,double const &>::_Ranit<double,int,double const *,double const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@NHPBNABN@std@@QAE@XZ ENDP			; std::_Ranit<double,int,double const *,double const &>::_Ranit<double,int,double const *,double const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@HHPBHABH@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@HHPBHABH@std@@QAE@XZ PROC			; std::_Ranit<int,int,int const *,int const &>::_Ranit<int,int,int const *,int const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@HHPBHABH@std@@QAE@XZ ENDP			; std::_Ranit<int,int,int const *,int const &>::_Ranit<int,int,int const *,int const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
??G?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<double,std::allocator<double> >::operator-, COMDAT
; _this$ = edi
; __Right$ = esi

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@97
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@97
$LN1@operator@97:
	call	__invalid_parameter_noinfo
$LN2@operator@97:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [esi+4]
	sar	eax, 3

; 195  : 		}

	ret	0
??G?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<double,std::allocator<double> >::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<double,std::allocator<double> >::_Vector_const_iterator<double,std::allocator<double> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@10
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@10
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@10
$LN1@Vector_con@10:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@10:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<double,std::allocator<double> >::_Vector_const_iterator<double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = edi
; __Right$ = esi

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@98
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@98
$LN1@operator@98:
	call	__invalid_parameter_noinfo
$LN2@operator@98:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [esi+4]
	sar	eax, 2

; 195  : 		}

	ret	0
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@11
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@11
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@11
$LN1@Vector_con@11:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@11:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@99
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@99
$LN1@operator@99:
	call	__invalid_parameter_noinfo
$LN2@operator@99:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@6
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@6
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@6
$LN3@Vector_ite@6:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@6:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@PAPAVTransaction@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@N@std@@QAEPANI@Z
_TEXT	SEGMENT
$T342064 = -16						; size = 4
$T342066 = -12						; size = 12
?allocate@?$allocator@N@std@@QAEPANI@Z PROC		; std::allocator<double>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@9
	xor	ecx, ecx
$LN3@allocate@9:
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@9:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN3@allocate@9
	lea	eax, DWORD PTR $T342064[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T342066[esp+20]
	mov	DWORD PTR $T342064[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T342066[esp+20]
	push	ecx
	mov	DWORD PTR $T342066[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@9:
$LN11@allocate@9:
	int	3
?allocate@?$allocator@N@std@@QAEPANI@Z ENDP		; std::allocator<double>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@M@std@@QAEPAMI@Z
_TEXT	SEGMENT
$T342086 = -16						; size = 4
$T342088 = -12						; size = 12
?allocate@?$allocator@M@std@@QAEPAMI@Z PROC		; std::allocator<float>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@10
	xor	ecx, ecx
$LN3@allocate@10:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@10:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate@10
	lea	eax, DWORD PTR $T342086[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T342088[esp+20]
	mov	DWORD PTR $T342086[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T342088[esp+20]
	push	ecx
	mov	DWORD PTR $T342088[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@10:
$LN11@allocate@10:
	int	3
?allocate@?$allocator@M@std@@QAEPAMI@Z ENDP		; std::allocator<float>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAMIABM@Z
_TEXT	SEGMENT
?_Ufill@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAMIABM@Z PROC ; std::vector<float,std::allocator<float> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill@4
$LL21@Ufill@4:
	fld	DWORD PTR [edx]
	dec	eax
	fstp	DWORD PTR [ecx]
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL21@Ufill@4
$LN26@Ufill@4:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]

; 1256 : 		}

	ret	0
?_Ufill@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAMIABM@Z ENDP ; std::vector<float,std::allocator<float> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z PROC ; std::vector<float,std::allocator<float> >::erase, COMDAT
; _this$ = esi

; 1028 : 		{	// erase [_First, _Last)

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp
	push	edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	DWORD PTR [ebx], 0
	test	esi, esi
	je	SHORT $LN8@erase@3
	mov	eax, DWORD PTR __First_arg$[esp+12]
	cmp	DWORD PTR [esi+12], eax
	ja	SHORT $LN8@erase@3
	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN9@erase@3
$LN8@erase@3:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+12]
$LN9@erase@3:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	edi, DWORD PTR __Last_arg$[esp+12]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [esi+12], edi
	ja	SHORT $LN24@erase@3
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN25@erase@3
$LN24@erase@3:
	call	__invalid_parameter_noinfo
	mov	edi, DWORD PTR __Last_arg$[esp+12]
$LN25@erase@3:

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN38@erase@3
	cmp	eax, ecx
	je	SHORT $LN39@erase@3
$LN38@erase@3:
	call	__invalid_parameter_noinfo
$LN39@erase@3:
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, edi
	je	SHORT $LN63@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [esi+16]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN60@erase@3
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN60@erase@3:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+16], ebp
$LN63@erase@3:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	pop	edi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	20					; 00000014H
?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z ENDP ; std::vector<float,std::allocator<float> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ PROC ; std::vector<float,std::allocator<float> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@9
	call	__invalid_parameter_noinfo
$LN6@end@9:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ ENDP ; std::vector<float,std::allocator<float> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ PROC ; std::vector<float,std::allocator<float> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@11
	call	__invalid_parameter_noinfo
$LN6@begin@11:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ ENDP ; std::vector<float,std::allocator<float> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
$T342570 = -16						; size = 4
$T342576 = -12						; size = 12
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@11
	xor	ecx, ecx
$LN3@allocate@11:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@11:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate@11
	lea	eax, DWORD PTR $T342570[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T342576[esp+20]
	mov	DWORD PTR $T342570[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T342576[esp+20]
	push	ecx
	mov	DWORD PTR $T342576[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@11:
$LN11@allocate@11:
	int	3
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@ABU32@@Z
_TEXT	SEGMENT
?construct@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@ABU32@@Z PROC ; std::allocator<std::pair<unsigned int,__int64> >::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@14
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR [eax+8], xmm0
$LN5@construct@14:

; 156  : 		}

	ret	0
?construct@?$allocator@U?$pair@I_J@std@@@std@@QAEXPAU?$pair@I_J@2@ABU32@@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> >::construct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U?$pair@I_J@std@@@std@@QAEPAU?$pair@I_J@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U?$pair@I_J@std@@@std@@QAEPAU?$pair@I_J@2@I@Z PROC ; std::allocator<std::pair<unsigned int,__int64> >::allocate, COMDAT

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	ret	0
?allocate@?$allocator@U?$pair@I_J@std@@@std@@QAEPAU?$pair@I_J@2@I@Z ENDP ; std::allocator<std::pair<unsigned int,__int64> >::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::pop_back, COMDAT
; _this$ = ecx

; 864  : 
; 865  :  #if _HAS_ITERATOR_DEBUGGING
; 866  : 		if (empty())
; 867  : 			_DEBUG_ERROR("deque empty before pop");
; 868  : 		else
; 869  : 			{	// something to erase, do it
; 870  : 			_Orphan_off(_Myoff + _Mysize - 1);
; 871  : 
; 872  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 873  : 		if (!empty())

	mov	eax, DWORD PTR [ecx+28]
	test	eax, eax
	je	SHORT $LN1@pop_back

; 874  : 			{	// something to erase, do it
; 875  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 876  : 
; 877  : 			size_type _Newoff = _Mysize + _Myoff - 1;
; 878  : 			size_type _Block = _Newoff / _DEQUESIZ;
; 879  : 			if (_Mapsize <= _Block)
; 880  : 				_Block -= _Mapsize;
; 881  : 			this->_Alval.destroy(_Map[_Block] + _Newoff % _DEQUESIZ);
; 882  : 			if (--_Mysize == 0)

	add	eax, -1
	mov	DWORD PTR [ecx+28], eax
	jne	SHORT $LN1@pop_back

; 883  : 				_Myoff = 0;

	mov	DWORD PTR [ecx+24], 0
$LN1@pop_back:

; 884  : 			}
; 885  : 			}

	ret	0
?pop_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXXZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::pop_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE?AV?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@2@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?begin@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE?AV?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@2@XZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::begin, COMDAT
; ___$ReturnUdt$ = esi

; 665  : 		{	// return iterator for beginning of mutable sequence

	push	ebx
	mov	ebx, DWORD PTR _this$[esp]

; 666  : 		return (iterator(_Myoff, this));

	mov	eax, DWORD PTR [ebx+28]
	push	edi
	mov	edi, DWORD PTR [ebx+24]
	add	eax, edi
	mov	DWORD PTR [esi], 0
	cmp	edi, eax
	jbe	SHORT $LN6@begin@12
	call	__invalid_parameter_noinfo
$LN6@begin@12:
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [esi+4], edi
	pop	edi
	mov	DWORD PTR [esi], ecx
	mov	eax, esi
	pop	ebx

; 667  : 		}

	ret	4
?begin@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE?AV?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@2@XZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@VRank@DRAMsimII@@@std@@QAEPAVRank@DRAMsimII@@I@Z
_TEXT	SEGMENT
$T342688 = -16						; size = 4
$T342690 = -12						; size = 12
?allocate@?$allocator@VRank@DRAMsimII@@@std@@QAEPAVRank@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::Rank>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@12
	xor	ecx, ecx
$LN3@allocate@12:
	imul	ecx, 200				; 000000c8H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@12:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 200				; 000000c8H
	jae	SHORT $LN3@allocate@12
	lea	eax, DWORD PTR $T342688[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T342690[esp+20]
	mov	DWORD PTR $T342688[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T342690[esp+20]
	push	ecx
	mov	DWORD PTR $T342690[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@12:
$LN11@allocate@12:
	int	3
?allocate@?$allocator@VRank@DRAMsimII@@@std@@QAEPAVRank@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::Rank>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_JIAB_J@Z
_TEXT	SEGMENT
?_Ufill@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_JIAB_J@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	ecx, esi
	mov	eax, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill@5
	push	ebx
	npad	7
$LL21@Ufill@5:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ebx
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL21@Ufill@5
	pop	ebx
$LN26@Ufill@5:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]

; 1256 : 		}

	ret	0
?_Ufill@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_JIAB_J@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_J@std@@QAEPA_JI@Z
_TEXT	SEGMENT
$T342846 = -16						; size = 4
$T342852 = -12						; size = 12
?allocate@?$allocator@_J@std@@QAEPA_JI@Z PROC		; std::allocator<__int64>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@13
	xor	ecx, ecx
$LN3@allocate@13:
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@13:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN3@allocate@13
	lea	eax, DWORD PTR $T342846[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T342852[esp+20]
	mov	DWORD PTR $T342846[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T342852[esp+20]
	push	ecx
	mov	DWORD PTR $T342852[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@13:
$LN11@allocate@13:
	int	3
?allocate@?$allocator@_J@std@@QAEPA_JI@Z ENDP		; std::allocator<__int64>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?deallocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_JI@Z
_TEXT	SEGMENT
?deallocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_JI@Z PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::deallocate, COMDAT
; _p$ = eax

; 2023 :         if (p != 0)

	test	eax, eax
	je	SHORT $LN4@deallocate

; 2024 :             m_alloc.deallocate(p, n);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN4@deallocate:

; 2025 :     }

	ret	0
?deallocate@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXPA_JI@Z ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::deallocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z
_TEXT	SEGMENT
$T342874 = -16						; size = 4
$T342880 = -12						; size = 12
?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z PROC ; std::allocator<DRAMsimII::Transaction *>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@14
	xor	ecx, ecx
$LN3@allocate@14:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@14:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate@14
	lea	eax, DWORD PTR $T342874[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T342880[esp+20]
	mov	DWORD PTR $T342874[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T342880[esp+20]
	push	ecx
	mov	DWORD PTR $T342880[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@14:
$LN11@allocate@14:
	int	3
?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z ENDP ; std::allocator<DRAMsimII::Transaction *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXXZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@Tidy@14

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@14:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXXZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?read@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPAVTransaction@2@H@Z
_TEXT	SEGMENT
?read@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPAVTransaction@2@H@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::read, COMDAT
; _this$ = esi
; _offset$ = ecx

; 256  : 			if ((offset >= (int)count) || (offset < 0))

	cmp	ecx, DWORD PTR [esi]
	jge	SHORT $LN2@read@7
	test	ecx, ecx
	jl	SHORT $LN2@read@7

; 258  : 			else
; 259  : 				return entry[(head + offset) % entry.size()];

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi+28]
	sub	edi, DWORD PTR [esi+24]
	add	eax, ecx
	sar	edi, 2
	xor	edx, edx
	div	edi
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN8@read@7
	call	__invalid_parameter_noinfo
$LN8@read@7:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 260  : 		}

	ret	0
$LN2@read@7:

; 257  : 				return NULL;

	xor	eax, eax

; 260  : 		}

	ret	0
?read@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPAVTransaction@2@H@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VRank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VBank@DRAMsimII@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_JHPB_JAB_JV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_JHPB_JAB_JV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,__int64,int,__int64 const *,__int64 const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,__int64,int,__int64 const *,__int64 const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_JHPB_JAB_JV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,__int64,int,__int64 const *,__int64 const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,__int64,int,__int64 const *,__int64 const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@VRank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>::_Ranit<DRAMsimII::Rank,int,DRAMsimII::Rank const *,DRAMsimII::Rank const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@VBank@DRAMsimII@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>::_Ranit<DRAMsimII::Bank,int,DRAMsimII::Bank const *,DRAMsimII::Bank const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@_JHPB_JAB_J@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@_JHPB_JAB_J@std@@QAE@XZ PROC		; std::_Ranit<__int64,int,__int64 const *,__int64 const &>::_Ranit<__int64,int,__int64 const *,__int64 const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@_JHPB_JAB_J@std@@QAE@XZ ENDP		; std::_Ranit<__int64,int,__int64 const *,__int64 const &>::_Ranit<__int64,int,__int64 const *,__int64 const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@100
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@100
$LN3@operator@100:
	call	__invalid_parameter_noinfo
$LN4@operator@100:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@12
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@12
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@12
$LN1@Vector_con@12:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@12:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@7
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@7
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@7
$LN3@Vector_ite@7:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@7:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@PAVRank@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<double> >::~_Container_base_aux_alloc_real<std::allocator<double> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<double> >::~_Container_base_aux_alloc_real<std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@NV?$allocator@N@std@@@std@@IAEPANPANIABN@Z
_TEXT	SEGMENT
?_Ufill@?$vector@NV?$allocator@N@std@@@std@@IAEPANPANIABN@Z PROC ; std::vector<double,std::allocator<double> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill@6
$LL21@Ufill@6:
	fld	QWORD PTR [edx]
	dec	eax
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	test	eax, eax
	ja	SHORT $LL21@Ufill@6
$LN26@Ufill@6:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]

; 1256 : 		}

	ret	0
?_Ufill@?$vector@NV?$allocator@N@std@@@std@@IAEPANPANIABN@Z ENDP ; std::vector<double,std::allocator<double> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ PROC ; std::vector<double,std::allocator<double> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@10
	call	__invalid_parameter_noinfo
$LN4@end@10:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ ENDP ; std::vector<double,std::allocator<double> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ PROC ; std::vector<double,std::allocator<double> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@13
	call	__invalid_parameter_noinfo
$LN4@begin@13:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@XZ ENDP ; std::vector<double,std::allocator<double> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@13
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@13
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@13
$LN1@Vector_con@13:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@13:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@101
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@101
$LN1@operator@101:
	call	__invalid_parameter_noinfo
$LN2@operator@101:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Vector_const_iterator<__int64,std::allocator<__int64> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN1@Vector_con@14
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN1@Vector_con@14
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN2@Vector_con@14
$LN1@Vector_con@14:
	call	__invalid_parameter_noinfo
$LN2@Vector_con@14:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::_Vector_const_iterator<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<float> >::~_Container_base_aux_alloc_real<std::allocator<float> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<float> >::~_Container_base_aux_alloc_real<std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ PROC	; std::vector<float,std::allocator<float> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@Tidy@15

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@15:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 1135 : 		}

	ret	0
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ENDP	; std::vector<float,std::allocator<float> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T343406 = -8						; size = 4
$T343358 = -8						; size = 8
?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ PROC	; std::vector<float,std::allocator<float> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, eax

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	DWORD PTR $T343406[esp+24], eax
	cmp	DWORD PTR [esi+12], eax
	jbe	SHORT $LN8@clear@12
	call	__invalid_parameter_noinfo
$LN8@clear@12:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN24@clear@12
	call	__invalid_parameter_noinfo
$LN24@clear@12:
	mov	ecx, DWORD PTR $T343406[esp+24]
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	ebx
	push	edi
	push	eax
	lea	edx, DWORD PTR $T343358[esp+40]
	push	edx
	call	?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z ; std::vector<float,std::allocator<float> >::erase

; 1061 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ ENDP	; std::vector<float,std::allocator<float> >::clear
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<int> >::~_Container_base_aux_alloc_real<std::allocator<int> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<int> >::~_Container_base_aux_alloc_real<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill@7
	push	ebx
	npad	7
$LL21@Ufill@7:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL21@Ufill@7
	pop	ebx
$LN26@Ufill@7:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]

; 1256 : 		}

	ret	0
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@Tidy@16

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@16:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@11
	call	__invalid_parameter_noinfo
$LN4@end@11:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@14
	call	__invalid_parameter_noinfo
$LN4@begin@14:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXXZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Tidy, COMDAT
; _this$ = esi

; 1268 : 		{	// free all storage

	push	ebx

; 1269 : 		while (!empty())

	xor	ebx, ebx
	cmp	DWORD PTR [esi+28], ebx
	je	SHORT $LN5@Tidy@17
$LL6@Tidy@17:

; 1270 : 			pop_back();

	mov	eax, DWORD PTR [esi+28]
	cmp	eax, ebx
	je	SHORT $LN11@Tidy@17
	dec	eax
	mov	DWORD PTR [esi+28], eax
	cmp	eax, ebx
	jne	SHORT $LN11@Tidy@17
	mov	DWORD PTR [esi+24], ebx
$LN11@Tidy@17:

; 1269 : 		while (!empty())

	cmp	DWORD PTR [esi+28], ebx
	jne	SHORT $LL6@Tidy@17
$LN5@Tidy@17:
	push	edi

; 1271 : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	mov	edi, DWORD PTR [esi+20]
	cmp	edi, ebx
	jbe	SHORT $LN3@Tidy@17
$LL4@Tidy@17:
	mov	eax, DWORD PTR [esi+16]

; 1272 : 			{	// free storage for a block and destroy pointer
; 1273 : 			if (*(_Map + --_Count) != 0)

	dec	edi
	cmp	DWORD PTR [eax+edi*4], ebx
	lea	eax, DWORD PTR [eax+edi*4]
	je	SHORT $LN18@Tidy@17

; 1274 : 				this->_Alval.deallocate(*(_Map + _Count), _DEQUESIZ);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN18@Tidy@17:

; 1271 : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	cmp	edi, ebx
	ja	SHORT $LL4@Tidy@17
$LN3@Tidy@17:

; 1275 : 			this->_Almap.destroy(_Map + _Count);
; 1276 : 			}
; 1277 : 
; 1278 : 		if (_Map)

	mov	eax, DWORD PTR [esi+16]
	pop	edi
	cmp	eax, ebx
	je	SHORT $LN25@Tidy@17

; 1279 : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for map

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Tidy@17:

; 1280 : 		_Mapsize = 0;
; 1281 : 		_Map = 0;

	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	pop	ebx

; 1282 : 		}

	ret	0
?_Tidy@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXXZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<__int64> >::~_Container_base_aux_alloc_real<std::allocator<__int64> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<__int64> >::~_Container_base_aux_alloc_real<std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXXZ PROC ; std::vector<__int64,std::allocator<__int64> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@Tidy@18

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@18:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 1135 : 		}

	ret	0
?_Tidy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXXZ ENDP ; std::vector<__int64,std::allocator<__int64> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >::~_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ?destroy@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ
_TEXT	SEGMENT
?destroy@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy, COMDAT
; _this$ = eax

; 2075 :         destroy_content();

	xor	edx, edx
	cmp	DWORD PTR [eax+16], edx
	jbe	SHORT $LN3@destroy@3
$LL8@destroy@3:
	add	DWORD PTR [eax+8], 8
	mov	ecx, DWORD PTR [eax+8]
	inc	edx
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN21@destroy@3
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+8], ecx
$LN21@destroy@3:
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LL8@destroy@3
$LN3@destroy@3:

; 2076 :         deallocate(m_buff, capacity());

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN18@destroy@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN18@destroy@3:

; 2077 : #if BOOST_CB_ENABLE_DEBUG
; 2078 :         m_buff = 0;
; 2079 :         m_first = 0;
; 2080 :         m_last = 0;
; 2081 :         m_end = 0;
; 2082 : #endif
; 2083 :     }

	ret	0
?destroy@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@AAEXXZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::destroy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAPAVTransaction@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAPAVTransaction@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN1@operator@102
	call	__invalid_parameter_noinfo
$LN1@operator@102:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*4]

; 786  : 		}

	ret	0
??A?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAPAVTransaction@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@12
	call	__invalid_parameter_noinfo
$LN6@end@12:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@15
	call	__invalid_parameter_noinfo
$LN6@begin@15:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; _this$ = esi

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@vector@12
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@12:

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z
_TEXT	SEGMENT
?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::at, COMDAT
; _this$ = esi
; _value$ = ecx

; 380  : 			assert(value < count);
; 381  : 			return read(value);

	cmp	ecx, DWORD PTR [esi]
	jge	SHORT $LN4@at@2
	test	ecx, ecx
	jl	SHORT $LN4@at@2
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi+28]
	sub	edi, DWORD PTR [esi+24]
	add	eax, ecx
	sar	edi, 2
	xor	edx, edx
	div	edi
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN10@at@2
	call	__invalid_parameter_noinfo
$LN10@at@2:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 382  : 		}

	ret	0

; 380  : 			assert(value < count);
; 381  : 			return read(value);

$LN4@at@2:
	xor	eax, eax

; 382  : 		}

	ret	0
?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pop@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ
_TEXT	SEGMENT
?pop@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::pop, COMDAT
; _this$ = esi

; 189  : 			if (count == 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN2@pop@3

; 202  : 			}
; 203  : 		}

	ret	0
$LN2@pop@3:

; 190  : 				return NULL;
; 191  : 			else
; 192  : 			{
; 193  : 				count--;

	dec	eax
	mov	DWORD PTR [esi], eax

; 194  : 
; 195  : 				T *item = entry[head];

	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	push	ebx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN5@pop@3
	call	__invalid_parameter_noinfo
$LN5@pop@3:
	mov	ecx, DWORD PTR [esi+24]

; 196  : 
; 197  : 				entry[head] = NULL; // ensure this item isn't rhs part of the queue anymore

	mov	edx, DWORD PTR [esi+28]
	mov	ebx, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR [esi+4]
	sub	edx, ecx
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN10@pop@3
	call	__invalid_parameter_noinfo
$LN10@pop@3:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], 0

; 198  : 
; 199  : 				head = (head + 1) % entry.size();	//advance head_ptr

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	inc	eax
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	pop	edi

; 200  : 
; 201  : 				return item;

	mov	eax, ebx
	pop	ebx
	mov	DWORD PTR [esi+4], edx

; 202  : 			}
; 203  : 		}

	ret	0
?pop@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::pop
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ PROC ; std::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ENDP ; std::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ PROC	; std::_Vector_val<double,std::allocator<double> >::~_Vector_val<double,std::allocator<double> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<double,std::allocator<double> >::~_Vector_val<double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ PROC ; std::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ENDP ; std::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@_JV?$allocator@_J@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@_JV?$allocator@_J@std@@@std@@QAE@XZ PROC ; std::_Vector_val<__int64,std::allocator<__int64> >::~_Vector_val<__int64,std::allocator<__int64> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@_JV?$allocator@_J@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<__int64,std::allocator<__int64> >::~_Vector_val<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~_Vector_val<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@103
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@103
$LN1@operator@103:
	call	__invalid_parameter_noinfo
$LN2@operator@103:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z
_TEXT	SEGMENT
??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z PROC	; std::vector<double,std::allocator<double> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 3
	cmp	edi, eax
	jb	SHORT $LN1@operator@104
	call	__invalid_parameter_noinfo
$LN1@operator@104:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*8]

; 786  : 		}

	ret	0
??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z ENDP	; std::vector<double,std::allocator<double> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ PROC	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >, COMDAT
; _this$ = esi

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@vector@13
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@13:

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ENDP	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@operator@105
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN2@operator@105
$LN1@operator@105:
	call	__invalid_parameter_noinfo
$LN2@operator@105:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@106
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@106
$LN3@operator@106:
	call	__invalid_parameter_noinfo
$LN4@operator@106:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@vector@14
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@14:

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
	ret	0
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@vector@15
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@15:

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??1?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = eax

; 640  : 		{	// destroy the deque

	push	esi
	mov	esi, eax

; 641  : 		_Tidy();

	call	?_Tidy@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Tidy

; 642  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
	ret	0
??1?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::~deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAVRank@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAVRank@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN1@operator@107
	call	__invalid_parameter_noinfo
$LN1@operator@107:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, edi
	imul	eax, 200				; 000000c8H
	add	eax, DWORD PTR [esi+12]

; 786  : 		}

	ret	0
??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAVRank@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z
_TEXT	SEGMENT
??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN1@operator@108
	call	__invalid_parameter_noinfo
$LN1@operator@108:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, edi
	imul	eax, 200				; 000000c8H
	add	eax, DWORD PTR [esi+12]

; 771  : 		}

	ret	0
??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@13
	call	__invalid_parameter_noinfo
$LN4@end@13:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@14
	call	__invalid_parameter_noinfo
$LN6@end@14:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@16
	call	__invalid_parameter_noinfo
$LN4@begin@16:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@17
	call	__invalid_parameter_noinfo
$LN6@begin@17:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@_JV?$allocator@_J@std@@@std@@QAEAA_JI@Z
_TEXT	SEGMENT
??A?$vector@_JV?$allocator@_J@std@@@std@@QAEAA_JI@Z PROC ; std::vector<__int64,std::allocator<__int64> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 3
	cmp	edi, eax
	jb	SHORT $LN1@operator@109
	call	__invalid_parameter_noinfo
$LN1@operator@109:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*8]

; 786  : 		}

	ret	0
??A?$vector@_JV?$allocator@_J@std@@@std@@QAEAA_JI@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@_JV?$allocator@_J@std@@@std@@QBEAB_JI@Z
_TEXT	SEGMENT
??A?$vector@_JV?$allocator@_J@std@@@std@@QBEAB_JI@Z PROC ; std::vector<__int64,std::allocator<__int64> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 3
	cmp	edi, eax
	jb	SHORT $LN1@operator@110
	call	__invalid_parameter_noinfo
$LN1@operator@110:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [ecx+edi*8]

; 771  : 		}

	ret	0
??A?$vector@_JV?$allocator@_J@std@@@std@@QBEAB_JI@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ PROC ; std::vector<__int64,std::allocator<__int64> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@15
	call	__invalid_parameter_noinfo
$LN4@end@15:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ ENDP ; std::vector<__int64,std::allocator<__int64> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ PROC ; std::vector<__int64,std::allocator<__int64> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@18
	call	__invalid_parameter_noinfo
$LN4@begin@18:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@XZ ENDP ; std::vector<__int64,std::allocator<__int64> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ PROC	; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >, COMDAT
; _this$ = esi

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@vector@16
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@16:

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ENDP	; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN4@end@16
	call	__invalid_parameter_noinfo
$LN4@end@16:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN4@begin@19
	call	__invalid_parameter_noinfo
$LN4@begin@19:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\circular_buffer\base.hpp
_TEXT	ENDS
;	COMDAT ??1?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@XZ PROC ; boost::circular_buffer<__int64,std::allocator<__int64> >::~circular_buffer<__int64,std::allocator<__int64> >, COMDAT
; _this$ = eax

; 1172 :         destroy();

	xor	edx, edx
	cmp	DWORD PTR [eax+16], edx
	jbe	SHORT $LN5@circular_b
$LL10@circular_b:
	add	DWORD PTR [eax+8], 8
	mov	ecx, DWORD PTR [eax+8]
	inc	edx
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN23@circular_b
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+8], ecx
$LN23@circular_b:
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LL10@circular_b
$LN5@circular_b:
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN20@circular_b
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN20@circular_b:

; 1173 : #if BOOST_CB_ENABLE_DEBUG
; 1174 :         invalidate_all_iterators();
; 1175 : #endif
; 1176 :     }

	ret	0
??1?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@XZ ENDP ; boost::circular_buffer<__int64,std::allocator<__int64> >::~circular_buffer<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?depth@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?depth@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ PROC ; DRAMsimII::Queue<DRAMsimII::Command>::depth, COMDAT
; _this$ = ecx

; 250  : 			return entry.size();

	mov	eax, DWORD PTR [ecx+28]
	sub	eax, DWORD PTR [ecx+24]
	sar	eax, 2

; 251  : 		}

	ret	0
?depth@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEIXZ ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::depth
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@1@I@Z
_TEXT	SEGMENT
??A?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@1@I@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator[], COMDAT
; _this$ = esi
; _value$ = ecx

; 386  : 			return at(value);

	cmp	ecx, DWORD PTR [esi]
	jge	SHORT $LN6@operator@111
	test	ecx, ecx
	jl	SHORT $LN6@operator@111
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi+28]
	sub	edi, DWORD PTR [esi+24]
	add	eax, ecx
	sar	edi, 2
	xor	edx, edx
	div	edi
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN12@operator@111
	call	__invalid_parameter_noinfo
$LN12@operator@111:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 387  : 		}

	ret	0

; 386  : 			return at(value);

$LN6@operator@111:
	xor	eax, eax

; 387  : 		}

	ret	0
??A?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@1@I@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?remove@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@H@Z
_TEXT	SEGMENT
_item$ = -4						; size = 4
?remove@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@H@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::remove, COMDAT
; _this$ = esi
; _offset$ = eax

; 339  : 		{

	push	ecx

; 340  : 			assert(offset <= (int)count && offset >= 0);
; 341  : 
; 342  : 			// first get the item
; 343  : 			T *item = entry[(head + offset) % entry.size()];

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	push	ebx
	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR [esi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	ebx, edx
	jb	SHORT $LN8@remove
	call	__invalid_parameter_noinfo
$LN8@remove:
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [eax+ebx*4]

; 344  : 			count--;

	dec	DWORD PTR [esi]

; 345  : 
; 346  : 			tail = (head + count) % entry.size();

	mov	ebx, DWORD PTR [esi+28]
	sub	ebx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _item$[esp+12], ecx
	mov	ecx, DWORD PTR [esi]
	sar	ebx, 2
	add	eax, ecx
	xor	edx, edx
	div	ebx
	mov	DWORD PTR [esi+8], edx

; 347  : 
; 348  : 			// then shift the other items up
; 349  : 			for (unsigned i = (unsigned)offset; i < count; i++)

	cmp	edi, ecx
	jae	SHORT $LN1@remove
	push	ebp
$LL3@remove:

; 350  : 			{
; 351  : 				entry[(head + i) % entry.size()] = entry[(head + i + 1) % entry.size()];

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [edx+edi+1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	ebx, edx
	cmp	ebx, eax
	jb	SHORT $LN17@remove
	call	__invalid_parameter_noinfo
$LN17@remove:
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	lea	ebp, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	ebx, edx
	jb	SHORT $LN24@remove
	call	__invalid_parameter_noinfo
$LN24@remove:
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ebp]
	inc	edi
	mov	DWORD PTR [eax+ebx*4], ecx
	cmp	edi, DWORD PTR [esi]
	jb	SHORT $LL3@remove
	pop	ebp
$LN1@remove:

; 352  : 			}
; 353  : 
; 354  : 
; 355  : 			entry[(head + count) % entry.size()] = NULL;

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	add	eax, DWORD PTR [esi]
	xor	edx, edx
	sar	ecx, 2
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN31@remove
	call	__invalid_parameter_noinfo
$LN31@remove:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], 0

; 356  : 
; 357  : 			return item;

	mov	eax, DWORD PTR _item$[esp+12]
	pop	edi
	pop	ebx

; 358  : 		}

	pop	ecx
	ret	0
?remove@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@H@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::remove
_TEXT	ENDS
PUBLIC	?getNextCPRHValues@Channel@DRAMsimII@@IBEXAAI0_N@Z ; DRAMsimII::Channel::getNextCPRHValues
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
_nextRank$ = 8						; size = 4
_nextBank$ = 12						; size = 4
_isActivate$ = 16					; size = 1
?getNextCPRHValues@Channel@DRAMsimII@@IBEXAAI0_N@Z PROC	; DRAMsimII::Channel::getNextCPRHValues
; _this$ = eax

; 2190 : 	unsigned oldBank = nextBank;
; 2191 : 	unsigned oldRank = nextRank;
; 2192 : 
; 2193 : 	if (isActivate)

	cmp	BYTE PTR _isActivate$[esp-4], 0
	push	ebx
	mov	ebx, DWORD PTR _nextBank$[esp]
	mov	ecx, DWORD PTR [ebx]
	push	ebp
	mov	ebp, DWORD PTR _nextRank$[esp+4]
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR [ebp]
	push	edi
	je	SHORT $LN4@getNextCPR

; 2194 : 	{
; 2195 : 		// set the rank of the next CAS
; 2196 : 		nextBank = 2 * (oldBank % (systemConfig.getBankCount() / 2)) + !(oldBank / (systemConfig.getBankCount() / 2));

	mov	eax, DWORD PTR [esi+176]
	mov	edi, DWORD PTR [eax+364]
	xor	edx, edx
	shr	edi, 1
	mov	eax, ecx
	div	edi

; 2197 : 		nextRank = (systemConfig.getRankCount() - ((2 * (oldBank % (systemConfig.getBankCount() / 2)) + !(oldBank / (systemConfig.getBankCount() / 2))) % systemConfig.getRankCount()) + oldRank) % systemConfig.getRankCount();

	mov	esi, DWORD PTR [esi+176]
	mov	edi, edx
	xor	edx, edx
	test	eax, eax
	sete	dl
	lea	eax, DWORD PTR [edx+edi*2]
	mov	edi, DWORD PTR [esi+364]
	mov	DWORD PTR [ebx], eax
	xor	edx, edx
	shr	edi, 1
	mov	eax, ecx
	div	edi
	mov	ecx, DWORD PTR [esi+360]
	mov	edi, eax
	xor	eax, eax
	test	edi, edi
	sete	al
	pop	edi
	pop	esi
	lea	eax, DWORD PTR [eax+edx*2]
	xor	edx, edx
	div	ecx
	mov	eax, ecx
	sub	eax, edx
	add	eax, DWORD PTR [ebp]
	xor	edx, edx
	div	ecx

; 2209 : 			nextRank = (oldRank + oldBank + 1) % systemConfig.getRankCount();

	mov	DWORD PTR [ebp], edx
	pop	ebp
	pop	ebx

; 2210 : 		}
; 2211 : 	}
; 2212 : 
; 2213 : }

	ret	12					; 0000000cH
$LN4@getNextCPR:

; 2198 : 	}
; 2199 : 	else
; 2200 : 	{
; 2201 : 		if (oldBank == systemConfig.getBankCount() - 1)

	mov	edx, DWORD PTR [esi+176]
	mov	edx, DWORD PTR [edx+364]

; 2202 : 		{
; 2203 : 			nextRank = (oldRank + 1) % systemConfig.getRankCount();

	mov	esi, DWORD PTR [esi+176]
	dec	edx
	cmp	ecx, edx
	jne	SHORT $LN2@getNextCPR
	inc	eax
	xor	edx, edx
	div	DWORD PTR [esi+360]

; 2204 : 			nextBank = systemConfig.getBankCount() / 2;

	mov	eax, DWORD PTR [esi+364]
	pop	edi
	pop	esi
	shr	eax, 1
	mov	DWORD PTR [ebx], eax

; 2209 : 			nextRank = (oldRank + oldBank + 1) % systemConfig.getRankCount();

	mov	DWORD PTR [ebp], edx
	pop	ebp
	pop	ebx

; 2210 : 		}
; 2211 : 	}
; 2212 : 
; 2213 : }

	ret	12					; 0000000cH
$LN2@getNextCPR:

; 2205 : 		}
; 2206 : 		else
; 2207 : 		{				
; 2208 : 			nextBank = (oldBank % 2) * (systemConfig.getBankCount() / 2) + ((oldBank + 1) / 2);

	mov	edx, DWORD PTR [esi+364]
	shr	edx, 1
	mov	edi, ecx
	and	edi, 1
	imul	edx, edi
	lea	edi, DWORD PTR [ecx+1]
	shr	edi, 1
	add	edx, edi
	mov	DWORD PTR [ebx], edx

; 2209 : 			nextRank = (oldRank + oldBank + 1) % systemConfig.getRankCount();

	lea	eax, DWORD PTR [eax+ecx+1]
	xor	edx, edx
	div	DWORD PTR [esi+360]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebp], edx
	pop	ebp
	pop	ebx

; 2210 : 		}
; 2211 : 	}
; 2212 : 
; 2213 : }

	ret	12					; 0000000cH
?getNextCPRHValues@Channel@DRAMsimII@@IBEXAAI0_N@Z ENDP	; DRAMsimII::Channel::getNextCPRHValues
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1Transaction@DRAMsimII@@UAE@XZ
_TEXT	SEGMENT
??1Transaction@DRAMsimII@@UAE@XZ PROC			; DRAMsimII::Transaction::~Transaction, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], OFFSET ??_7Event@DRAMsimII@@6B@
	ret	0
??1Transaction@DRAMsimII@@UAE@XZ ENDP			; DRAMsimII::Transaction::~Transaction
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ PROC ; boost::_bi::value<std::vector<int,std::allocator<int> > >::~value<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN8@value
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@value:
	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::value<std::vector<int,std::allocator<int> > >::~value<std::vector<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@XZ PROC ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::~storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN10@storage4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@storage4:
	mov	eax, DWORD PTR [esi+24]
	push	eax
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::~storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ PROC ; boost::_bi::value<std::vector<double,std::allocator<double> > >::~value<std::vector<double,std::allocator<double> > >, COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN8@value@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@value@2:
	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::value<std::vector<double,std::allocator<double> > >::~value<std::vector<double,std::allocator<double> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@XZ PROC ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::~storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >, COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+60]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN10@storage5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@storage5:
	mov	eax, DWORD PTR [esi+48]
	push	eax
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+68], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN29@storage5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN29@storage5:
	mov	ecx, DWORD PTR [esi+24]
	push	ecx
	mov	DWORD PTR [esi+36], edi
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
	ret	0
??1?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::~storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ PROC ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::~storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >, COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+84]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN10@storage6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@storage6:
	mov	eax, DWORD PTR [esi+72]
	push	eax
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+88], edi
	mov	DWORD PTR [esi+92], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR [esi+60]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN29@storage6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN29@storage6:
	mov	ecx, DWORD PTR [esi+48]
	push	ecx
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+68], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN48@storage6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN48@storage6:
	mov	edx, DWORD PTR [esi+24]
	push	edx
	mov	DWORD PTR [esi+36], edi
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
	ret	0
??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::~storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ PROC ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::~storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >, COMDAT
; _this$ = esi
	jmp	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
??1?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::~storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ PROC ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::~list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >, COMDAT
; _this$ = esi
	jmp	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
??1?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::~list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@XZ PROC ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::~bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >, COMDAT
; _this$ = eax
	push	esi
	mov	esi, eax
	add	esi, 8
	call	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
	pop	esi
	ret	0
??1?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@XZ ENDP ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::~bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ PROC ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::~queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >, COMDAT
; _this$ = eax
	push	esi
	mov	esi, eax
	call	?_Tidy@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Tidy
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
	ret	0
??1?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ ENDP ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::~queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\mutex.hpp
_TEXT	ENDS
;	COMDAT ??1mutex@boost@@QAE@XZ
_TEXT	SEGMENT
??1mutex@boost@@QAE@XZ PROC				; boost::mutex::~mutex, COMDAT
; _this$ = ecx

; 33   :             destroy();

	xor	eax, eax
	add	ecx, 4
	xchg	DWORD PTR [ecx], eax
	test	eax, eax
	je	SHORT $LN3@mutex
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN3@mutex:

; 34   :         }

	ret	0
??1mutex@boost@@QAE@XZ ENDP				; boost::mutex::~mutex
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0mutex@boost@@QAE@XZ
_TEXT	SEGMENT
??0mutex@boost@@QAE@XZ PROC				; boost::mutex::mutex, COMDAT
; _this$ = ecx

; 27   :         mutex()

	mov	eax, ecx

; 28   :         {
; 29   :             initialize();

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 30   :         }

	ret	0
??0mutex@boost@@QAE@XZ ENDP				; boost::mutex::mutex
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_data.hpp
_TEXT	ENDS
;	COMDAT ?intrusive_ptr_release@@YAXPAUthread_data_base@detail@boost@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?intrusive_ptr_release@@YAXPAUthread_data_base@detail@boost@@@Z PROC ; intrusive_ptr_release, COMDAT

; 53   :             {

	push	esi

; 54   :                 if(!BOOST_INTERLOCKED_DECREMENT(&p->count))

	mov	esi, DWORD PTR _p$[esp]
	lea	eax, DWORD PTR [esi+4]
	or	ecx, -1
	lock	 xadd	 DWORD PTR [eax], ecx
	jne	SHORT $LN6@intrusive_@2

; 55   :                 {
; 56   :                     detail::heap_delete(p);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	0
	mov	ecx, esi
	call	eax
	push	esi
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapFree@12
$LN6@intrusive_@2:
	pop	esi

; 57   :                 }
; 58   :             }

	ret	0
?intrusive_ptr_release@@YAXPAUthread_data_base@detail@boost@@@Z ENDP ; intrusive_ptr_release
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_heap_alloc.hpp
_TEXT	ENDS
;	COMDAT ?allocate_raw_heap_memory@detail@boost@@YAPAXI@Z
_TEXT	SEGMENT
$T345698 = -12						; size = 12
_size$ = 8						; size = 4
?allocate_raw_heap_memory@detail@boost@@YAPAXI@Z PROC	; boost::detail::allocate_raw_heap_memory, COMDAT

; 60   :             void* const heap_memory=detail::win32::HeapAlloc(detail::win32::GetProcessHeap(),0,size);

	mov	eax, DWORD PTR _size$[esp-4]
	sub	esp, 12					; 0000000cH
	push	eax
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapAlloc@12

; 61   :             if(!heap_memory)

	test	eax, eax
	jne	SHORT $LN2@allocate_r

; 62   :             {
; 63   :                 throw std::bad_alloc();

	push	1
	push	OFFSET __bad_alloc_Message
	lea	ecx, DWORD PTR $T345698[esp+20]
	call	??0exception@std@@QAE@ABQBDH@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T345698[esp+16]
	push	ecx
	mov	DWORD PTR $T345698[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN7@allocate_r:
$LN2@allocate_r:

; 64   :             }
; 65   :             return heap_memory;
; 66   :         }

	add	esp, 12					; 0000000cH
	ret	0
$LN6@allocate_r:
?allocate_raw_heap_memory@detail@boost@@YAPAXI@Z ENDP	; boost::detail::allocate_raw_heap_memory
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_primitives.hpp
_TEXT	ENDS
;	COMDAT ??1handle_manager@win32@detail@boost@@QAE@XZ
_TEXT	SEGMENT
??1handle_manager@win32@detail@boost@@QAE@XZ PROC	; boost::detail::win32::handle_manager::~handle_manager, COMDAT
; _this$ = ecx

; 276  :                     cleanup();

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@handle_man
	cmp	eax, -1
	je	SHORT $LN3@handle_man
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN3@handle_man:

; 277  :                 }

	ret	0
??1handle_manager@win32@detail@boost@@QAE@XZ ENDP	; boost::detail::win32::handle_manager::~handle_manager
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G_ns2__submitEpochResultResponseElement@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_ns2__submitEpochResultResponseElement@@UAEPAXI@Z PROC ; _ns2__submitEpochResultResponseElement::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_ns2__submitEpochResultResponseElement@@6B@
	je	SHORT $LN6@scalar@19
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@19:
	mov	eax, esi
	pop	esi
	ret	4
??_G_ns2__submitEpochResultResponseElement@@UAEPAXI@Z ENDP ; _ns2__submitEpochResultResponseElement::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapstub.h
_TEXT	ENDS
;	COMDAT ??1_ns2__submitEpochResultElement@@UAE@XZ
_TEXT	SEGMENT
??1_ns2__submitEpochResultElement@@UAE@XZ PROC		; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement, COMDAT
; _this$ = ecx

; 264  : 	virtual ~_ns2__submitEpochResultElement() { }

	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR [esi], OFFSET ??_7_ns2__submitEpochResultElement@@6B@
	mov	eax, DWORD PTR [esi+108]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN8@ns2__submi
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@ns2__submi:
	mov	eax, DWORD PTR [esi+96]
	push	eax
	mov	DWORD PTR [esi+108], edi
	mov	DWORD PTR [esi+112], edi
	mov	DWORD PTR [esi+116], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR [esi+84]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN23@ns2__submi
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN23@ns2__submi:
	mov	ecx, DWORD PTR [esi+72]
	push	ecx
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+88], edi
	mov	DWORD PTR [esi+92], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR [esi+60]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN38@ns2__submi
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN38@ns2__submi:
	mov	edx, DWORD PTR [esi+48]
	push	edx
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+68], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR [esi+36]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN53@ns2__submi
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN53@ns2__submi:
	mov	eax, DWORD PTR [esi+24]
	push	eax
	mov	DWORD PTR [esi+36], edi
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
	pop	esi
	ret	0
??1_ns2__submitEpochResultElement@@UAE@XZ ENDP		; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.h
_TEXT	ENDS
;	COMDAT ?isHighUtilization@Bank@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isHighUtilization@Bank@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Bank::isHighUtilization, COMDAT
; _this$ = eax

; 118  : 		bool isHighUtilization() const { return perBankQueue.size() > (perBankQueue.depth() / 2);}

	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, DWORD PTR [eax+32]
	sar	ecx, 2
	shr	ecx, 1
	cmp	ecx, DWORD PTR [eax+8]
	sbb	eax, eax
	neg	eax
	ret	0
?isHighUtilization@Bank@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Bank::isHighUtilization
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isFull@Bank@DRAMsimII@@QBE_NXZ
_TEXT	SEGMENT
?isFull@Bank@DRAMsimII@@QBE_NXZ PROC			; DRAMsimII::Bank::isFull, COMDAT
; _this$ = eax

; 115  : 		bool isFull() const { return perBankQueue.isFull(); }

	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, DWORD PTR [eax+32]
	xor	edx, edx
	sar	ecx, 2
	cmp	ecx, DWORD PTR [eax+8]
	sete	dl
	mov	al, dl
	ret	0
?isFull@Bank@DRAMsimII@@QBE_NXZ ENDP			; DRAMsimII::Bank::isFull
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?freeCommandSlots@Bank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?freeCommandSlots@Bank@DRAMsimII@@QBEIXZ PROC		; DRAMsimII::Bank::freeCommandSlots, COMDAT
; _this$ = ecx

; 111  : 		unsigned freeCommandSlots() const { return perBankQueue.freecount(); }

	mov	eax, DWORD PTR [ecx+36]
	sub	eax, DWORD PTR [ecx+32]
	sar	eax, 2
	sub	eax, DWORD PTR [ecx+8]
	ret	0
?freeCommandSlots@Bank@DRAMsimII@@QBEIXZ ENDP		; DRAMsimII::Bank::freeCommandSlots
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@Bank@DRAMsimII@@QBEIXZ
_TEXT	SEGMENT
?size@Bank@DRAMsimII@@QBEIXZ PROC			; DRAMsimII::Bank::size, COMDAT
; _this$ = eax

; 108  : 		unsigned size() const { return perBankQueue.size(); }

	mov	eax, DWORD PTR [eax+8]
	ret	0
?size@Bank@DRAMsimII@@QBEIXZ ENDP			; DRAMsimII::Bank::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GEvent@DRAMsimII@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GEvent@DRAMsimII@@UAEPAXI@Z PROC			; DRAMsimII::Event::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7Event@DRAMsimII@@6B@
	je	SHORT $LN6@scalar@20
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@20:
	mov	eax, esi
	pop	esi
	ret	4
??_GEvent@DRAMsimII@@UAEPAXI@Z ENDP			; DRAMsimII::Event::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN20@operator@192
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@operator@192
$LN20@operator@192:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@192
$LN10@operator@192:
	xor	edx, edx
$LN11@operator@192:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@192
	test	eax, eax
	je	SHORT $LN16@operator@192
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@192
$LN16@operator@192:
	xor	eax, eax
$LN17@operator@192:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@192
$LN1@operator@192:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@192:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [esi+4], edi

; 165  : 		return (*this);

	mov	eax, esi
	pop	edi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator+, COMDAT
; _this$ = eax

; 169  : 		{	// return this + integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 170  : 		_Myt _Tmp = *this;

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 171  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN22@operator@193
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN13@operator@193:
	mov	ecx, DWORD PTR __Off$[esp+8]
	lea	edi, DWORD PTR [edi+ecx*8]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN3@operator@193
	test	esi, esi
	je	SHORT $LN18@operator@193
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN19@operator@193
$LN22@operator@193:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN13@operator@193
$LN18@operator@193:
	xor	eax, eax
$LN19@operator@193:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN4@operator@193
$LN3@operator@193:
	call	__invalid_parameter_noinfo
$LN4@operator@193:
	mov	DWORD PTR [ebx+4], edi
	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 172  : 		}

	ret	8
??H?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Uninit_mov@8
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Uninit_mov@8:
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Equal@PB_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA_NPB_J0V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 8
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Equal@PB_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA_NPB_J0V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<__int64 const *,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >, COMDAT

; 3043 : 	// for range checked iterators, this will make sure there is enough space
; 3044 : 	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);

	mov	edx, DWORD PTR __Last1$[esp-4]
	mov	eax, DWORD PTR __First2$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First1$[esp]
	push	ebp
	push	esi
	mov	esi, edx
	sub	esi, ebx
	sar	esi, 3
	push	edi
	mov	edi, DWORD PTR __First2$[esp+16]
	mov	ebp, eax
	test	eax, eax
	jne	SHORT $LN39@Equal@7
	call	__invalid_parameter_noinfo
	mov	edx, DWORD PTR __Last1$[esp+12]
	xor	eax, eax
$LN15@Equal@7:
	lea	esi, DWORD PTR [edi+esi*8]
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN5@Equal@7
	test	ebp, ebp
	je	SHORT $LN20@Equal@7
	mov	ebp, DWORD PTR [ebp]
	jmp	SHORT $LN21@Equal@7
$LN39@Equal@7:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN15@Equal@7
$LN20@Equal@7:
	xor	ebp, ebp
$LN21@Equal@7:
	cmp	esi, DWORD PTR [ebp+12]
	jae	SHORT $LN6@Equal@7
$LN5@Equal@7:
	call	__invalid_parameter_noinfo
	mov	edx, DWORD PTR __Last1$[esp+12]
$LN6@Equal@7:

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	mov	eax, ebx
	cmp	ebx, edx
	je	SHORT $LN31@Equal@7
	mov	ecx, DWORD PTR __First2$[esp+16]
	sub	ecx, ebx
	npad	3
$LL33@Equal@7:
	mov	esi, DWORD PTR [eax]
	cmp	esi, DWORD PTR [ecx+eax]
	jne	SHORT $LN37@Equal@7
	mov	esi, DWORD PTR [eax+4]
	cmp	esi, DWORD PTR [ecx+eax+4]
	jne	SHORT $LN37@Equal@7
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL33@Equal@7
$LN31@Equal@7:
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx

; 3047 : 	}

	ret	0
$LN37@Equal@7:
	pop	edi
	pop	esi
	pop	ebp

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	xor	al, al
	pop	ebx

; 3047 : 	}

	ret	0
??$_Equal@PB_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA_NPB_J0V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<__int64 const *,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN30@Unchecked_@17
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN30@Unchecked_@17:
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$equal@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@00@Z
_TEXT	SEGMENT
$T391192 = -4						; size = 1
__First1$ = 8						; size = 8
$T391193 = 16						; size = 1
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
??$equal@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@00@Z PROC ; std::equal<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >, COMDAT

; 3055 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ecx

; 3056 : 	return _Equal(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _First2,
; 3057 : 		_Iter_random(_First1, _First2), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T391193[esp]
	mov	edx, DWORD PTR __First2$[esp+4]
	mov	BYTE PTR $T391192[esp+4], 0
	mov	eax, DWORD PTR $T391192[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+16]
	push	eax
	push	ecx
	push	edx
	call	??$_Equal@PB_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA_NPB_J0V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<__int64 const *,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >

; 3058 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$equal@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@00@Z ENDP ; std::equal<std::_Vector_const_iterator<__int64,std::allocator<__int64> >,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN32@Umove@10
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@Umove@10:
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	0
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?8_JV?$allocator@_J@std@@@std@@YA_NABV?$vector@_JV?$allocator@_J@std@@@0@0@Z
_TEXT	SEGMENT
$T391397 = -8						; size = 8
$T391591 = 8						; size = 1
$T391592 = 8						; size = 1
__Right$ = 8						; size = 4
??$?8_JV?$allocator@_J@std@@@std@@YA_NABV?$vector@_JV?$allocator@_J@std@@@0@0@Z PROC ; std::operator==<__int64,std::allocator<__int64> >, COMDAT
; __Left$ = esi

; 1308 : 	return (_Left.size() == _Right.size()
; 1309 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	mov	edx, DWORD PTR [esi+16]
	sub	edx, DWORD PTR [esi+12]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Right$[esp+8]
	mov	eax, DWORD PTR [ebx+16]
	push	edi
	mov	edi, DWORD PTR [ebx+12]
	mov	ecx, eax
	sub	ecx, edi
	xor	ecx, edx
	test	ecx, -8					; fffffff8H
	jne	SHORT $LN3@operator@194
	cmp	edi, eax
	jbe	SHORT $LN12@operator@194
	call	__invalid_parameter_noinfo
$LN12@operator@194:
	mov	eax, DWORD PTR [ebx]
	push	ebp
	mov	ebp, DWORD PTR [esi+16]
	mov	DWORD PTR $T391397[esp+20], eax
	cmp	DWORD PTR [esi+12], ebp
	jbe	SHORT $LN26@operator@194
	call	__invalid_parameter_noinfo
$LN26@operator@194:
	mov	ebx, DWORD PTR [esi+12]
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN40@operator@194
	call	__invalid_parameter_noinfo
$LN40@operator@194:
	mov	eax, DWORD PTR $T391397[esp+20]
	mov	BYTE PTR $T391591[esp+16], 0
	mov	ecx, DWORD PTR $T391591[esp+16]
	mov	edx, DWORD PTR $T391592[esp+16]
	push	ecx
	push	edx
	push	edi
	push	eax
	push	ebp
	push	ebx
	call	??$_Equal@PB_JV?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@@std@@YA_NPB_J0V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<__int64 const *,std::_Vector_const_iterator<__int64,std::allocator<__int64> > >
	add	esp, 24					; 00000018H
	pop	ebp
	test	al, al
	je	SHORT $LN3@operator@194
	pop	edi
	mov	eax, 1
	pop	ebx

; 1310 : 	}

	add	esp, 8
	ret	0
$LN3@operator@194:
	pop	edi

; 1308 : 	return (_Left.size() == _Right.size()
; 1309 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	xor	eax, eax
	pop	ebx

; 1310 : 	}

	add	esp, 8
	ret	0
??$?8_JV?$allocator@_J@std@@@std@@YA_NABV?$vector@_JV?$allocator@_J@std@@@0@0@Z ENDP ; std::operator==<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN20@operator@195
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@operator@195
$LN20@operator@195:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@195
$LN10@operator@195:
	xor	edx, edx
$LN11@operator@195:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@195
	test	eax, eax
	je	SHORT $LN16@operator@195
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@195
$LN16@operator@195:
	xor	eax, eax
$LN17@operator@195:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@195
$LN1@operator@195:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@195:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [esi+4], edi

; 165  : 		return (*this);

	mov	eax, esi
	pop	edi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<double,std::allocator<double> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN20@operator@196
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@operator@196
$LN20@operator@196:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@196
$LN10@operator@196:
	xor	edx, edx
$LN11@operator@196:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@196
	test	eax, eax
	je	SHORT $LN16@operator@196
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@196
$LN16@operator@196:
	xor	eax, eax
$LN17@operator@196:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@196
$LN1@operator@196:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@196:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [esi+4], edi

; 165  : 		return (*this);

	mov	eax, esi
	pop	edi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<double,std::allocator<double> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN20@operator@197
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@operator@197
$LN20@operator@197:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@197
$LN10@operator@197:
	xor	edx, edx
$LN11@operator@197:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@197
	test	eax, eax
	je	SHORT $LN16@operator@197
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@197
$LN16@operator@197:
	xor	eax, eax
$LN17@operator@197:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@197
$LN1@operator@197:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@197:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [esi+4], edi

; 165  : 		return (*this);

	mov	eax, esi
	pop	edi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN22@operator@198
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN12@operator@198
$LN22@operator@198:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN13@operator@198
$LN12@operator@198:
	xor	edx, edx
$LN13@operator@198:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN3@operator@198
	test	eax, eax
	je	SHORT $LN18@operator@198
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@198
$LN18@operator@198:
	xor	eax, eax
$LN19@operator@198:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN23@operator@198
$LN3@operator@198:
	call	__invalid_parameter_noinfo
$LN23@operator@198:
	add	DWORD PTR [esi+4], edi

; 376  : 		return (*this);

	mov	eax, esi
	pop	edi

; 377  : 		}

	ret	4
??Y?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@18
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@18:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@I_J@std@@@std@@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN5@Make_iter@14
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN5@Make_iter@14
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN6@Make_iter@14
$LN5@Make_iter@14:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN6@Make_iter@14:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??D?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEABU?$pair@I_J@1@XZ
_TEXT	SEGMENT
??D?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEABU?$pair@I_J@1@XZ PROC ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*, COMDAT
; _this$ = esi

; 137  : 			size_type _Block = _Myoff / _DEQUESIZ;
; 138  : 			size_type _Off = _Myoff & (_DEQUESIZ - 1);	// assume power of 2
; 139  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN38@operator@199
	call	__invalid_parameter_noinfo

; 140  : 			_SCL_SECURE_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN10@operator@199
$LN38@operator@199:
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@199
$LN10@operator@199:
	xor	ecx, ecx
$LN11@operator@199:
	test	eax, eax
	je	SHORT $LN16@operator@199
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@199
$LN16@operator@199:
	xor	eax, eax
$LN17@operator@199:
	mov	eax, DWORD PTR [eax+28]
	add	eax, DWORD PTR [ecx+24]
	cmp	DWORD PTR [esi+4], eax
	jb	SHORT $LN2@operator@199
	call	__invalid_parameter_noinfo
$LN2@operator@199:

; 141  : 			if (static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize <= _Block)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN22@operator@199
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN23@operator@199
$LN22@operator@199:
	xor	ecx, ecx
$LN23@operator@199:
	cmp	DWORD PTR [ecx+20], edi
	ja	SHORT $LN1@operator@199

; 142  : 				_Block -= static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize;

	test	eax, eax
	je	SHORT $LN28@operator@199
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN29@operator@199
$LN28@operator@199:
	xor	ecx, ecx
$LN29@operator@199:
	sub	edi, DWORD PTR [ecx+20]
$LN1@operator@199:

; 143  : 			return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);

	test	eax, eax
	je	SHORT $LN34@operator@199
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 144  : 			}

	ret	0

; 143  : 			return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);

$LN34@operator@199:
	xor	eax, eax
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [edx+edi*4]
	pop	edi

; 144  : 			}

	ret	0
??D?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEABU?$pair@I_J@1@XZ ENDP ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<double,std::allocator<double> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN22@operator@200
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN12@operator@200
$LN22@operator@200:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN13@operator@200
$LN12@operator@200:
	xor	edx, edx
$LN13@operator@200:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN3@operator@200
	test	eax, eax
	je	SHORT $LN18@operator@200
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@200
$LN18@operator@200:
	xor	eax, eax
$LN19@operator@200:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN23@operator@200
$LN3@operator@200:
	call	__invalid_parameter_noinfo
$LN23@operator@200:
	add	DWORD PTR [esi+4], edi

; 376  : 		return (*this);

	mov	eax, esi
	pop	edi

; 377  : 		}

	ret	4
??Y?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<double,std::allocator<double> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN22@operator@201
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN12@operator@201
$LN22@operator@201:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN13@operator@201
$LN12@operator@201:
	xor	edx, edx
$LN13@operator@201:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN3@operator@201
	test	eax, eax
	je	SHORT $LN18@operator@201
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@201
$LN18@operator@201:
	xor	eax, eax
$LN19@operator@201:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN23@operator@201
$LN3@operator@201:
	call	__invalid_parameter_noinfo
$LN23@operator@201:
	add	DWORD PTR [esi+4], edi

; 376  : 		return (*this);

	mov	eax, esi
	pop	edi

; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@202
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@202
$LN13@operator@202:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@202
$LN9@operator@202:
	xor	eax, eax
$LN10@operator@202:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@202
	call	__invalid_parameter_noinfo
$LN14@operator@202:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 4

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+, COMDAT
; _this$ = eax

; 380  : 		{	// return this + integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 381  : 		_Myt _Tmp = *this;

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN24@operator@203
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN15@operator@203:
	mov	ecx, DWORD PTR __Off$[esp+8]
	lea	edi, DWORD PTR [edi+ecx*4]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN5@operator@203
	test	esi, esi
	je	SHORT $LN20@operator@203
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN21@operator@203
$LN24@operator@203:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN15@operator@203
$LN20@operator@203:
	xor	eax, eax
$LN21@operator@203:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN6@operator@203
$LN5@operator@203:
	call	__invalid_parameter_noinfo
$LN6@operator@203:
	mov	DWORD PTR [ebx+4], edi
	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z PROC ; std::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = esi

; 478  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Deque_map
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 479  : 		}

	mov	eax, esi
	ret	4

; 478  : 		{	// construct allocator from _Al

$LN8@Deque_map:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 479  : 		}

	mov	eax, esi
	ret	4
??0?$_Deque_map@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z ENDP ; std::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Deque_map<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN5@Make_iter@15
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN5@Make_iter@15
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN6@Make_iter@15
$LN5@Make_iter@15:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN6@Make_iter@15:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@19
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@19:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@0@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::erase, COMDAT
; _this$ = esi

; 1028 : 		{	// erase [_First, _Last)

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	DWORD PTR [ebx], 0
	test	esi, esi
	je	SHORT $LN8@erase@7
	mov	eax, DWORD PTR __First_arg$[esp+8]
	cmp	DWORD PTR [esi+12], eax
	ja	SHORT $LN8@erase@7
	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN9@erase@7
$LN8@erase@7:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+8]
$LN9@erase@7:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	edi, DWORD PTR __Last_arg$[esp+8]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [esi+12], edi
	ja	SHORT $LN24@erase@7
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN25@erase@7
$LN24@erase@7:
	call	__invalid_parameter_noinfo
	mov	edi, DWORD PTR __Last_arg$[esp+8]
$LN25@erase@7:

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN38@erase@7
	cmp	eax, ecx
	je	SHORT $LN39@erase@7
$LN38@erase@7:
	call	__invalid_parameter_noinfo
$LN39@erase@7:
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, edi
	je	SHORT $LN63@erase@7

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [esi+16]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebp
	lea	ebp, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN60@erase@7
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN60@erase@7:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+16], ebp
	pop	ebp
$LN63@erase@7:
	pop	edi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebx
	pop	ebx

; 1055 : #endif
; 1056 : 		}

	ret	20					; 00000014H
?erase@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@0@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::erase
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??D?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEAAU?$pair@I_J@1@XZ
_TEXT	SEGMENT
??D?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEAAU?$pair@I_J@1@XZ PROC ; std::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*, COMDAT
; _this$ = esi

; 386  : 		return ((reference)**(_Mybase *)this);

	jmp	??D?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEABU?$pair@I_J@1@XZ ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*
??D?$_Deque_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEAAU?$pair@I_J@1@XZ ENDP ; std::_Deque_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@NV?$allocator@N@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@NV?$allocator@N@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<double,std::allocator<double> >::operator+, COMDAT
; _this$ = eax

; 380  : 		{	// return this + integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 381  : 		_Myt _Tmp = *this;

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN24@operator@204
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN15@operator@204:
	mov	ecx, DWORD PTR __Off$[esp+8]
	lea	edi, DWORD PTR [edi+ecx*8]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN5@operator@204
	test	esi, esi
	je	SHORT $LN20@operator@204
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN21@operator@204
$LN24@operator@204:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN15@operator@204
$LN20@operator@204:
	xor	eax, eax
$LN21@operator@204:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN6@operator@204
$LN5@operator@204:
	call	__invalid_parameter_noinfo
$LN6@operator@204:
	mov	DWORD PTR [ebx+4], edi

; 383  : 		}

	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	mov	eax, ebx
	pop	ebx
	ret	8
??H?$_Vector_iterator@NV?$allocator@N@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<double,std::allocator<double> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<double,std::allocator<double> >::_Vector_iterator<double,std::allocator<double> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@12
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@12
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@12
$LN3@Vector_ite@12:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@12:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<double,std::allocator<double> >::_Vector_iterator<double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = eax

; 380  : 		{	// return this + integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 381  : 		_Myt _Tmp = *this;

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN24@operator@205
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN15@operator@205:
	mov	ecx, DWORD PTR __Off$[esp+8]
	lea	edi, DWORD PTR [edi+ecx*4]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN5@operator@205
	test	esi, esi
	je	SHORT $LN20@operator@205
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN21@operator@205
$LN24@operator@205:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN15@operator@205
$LN20@operator@205:
	xor	eax, eax
$LN21@operator@205:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN6@operator@205
$LN5@operator@205:
	call	__invalid_parameter_noinfo
$LN6@operator@205:
	mov	DWORD PTR [ebx+4], edi

; 383  : 		}

	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	mov	eax, ebx
	pop	ebx
	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@13
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@13
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@13
$LN3@Vector_ite@13:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@13:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@206
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@206
$LN15@operator@206:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@206
$LN11@operator@206:
	xor	eax, eax
$LN12@operator@206:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@206
	call	__invalid_parameter_noinfo
$LN16@operator@206:
	add	DWORD PTR [esi+4], 4

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<double> >::_Container_base_aux_alloc_real<std::allocator<double> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@20
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@20:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<double> >::_Container_base_aux_alloc_real<std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ PROC ; std::vector<double,std::allocator<double> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@26
	call	__invalid_parameter_noinfo
$LN6@begin@26:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ ENDP ; std::vector<double,std::allocator<double> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<float> >::_Container_base_aux_alloc_real<std::allocator<float> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@21
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@21:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<float> >::_Container_base_aux_alloc_real<std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<int> >::_Container_base_aux_alloc_real<std::allocator<int> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@22
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@22:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<int> >::_Container_base_aux_alloc_real<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@27
	call	__invalid_parameter_noinfo
$LN6@begin@27:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z PROC ; std::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = esi

; 500  : 		{	// construct allocator and base from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@Deque_val
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 501  : 		}

	mov	eax, esi
	ret	4

; 500  : 		{	// construct allocator and base from _Al

$LN13@Deque_val:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 501  : 		}

	mov	eax, esi
	ret	4
??0?$_Deque_val@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAE@V?$allocator@U?$pair@I_J@std@@@1@@Z ENDP ; std::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Deque_val<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@23
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@23:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >::_Container_base_aux_alloc_real<std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<__int64> >::_Container_base_aux_alloc_real<std::allocator<__int64> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@24
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@24:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<__int64> >::_Container_base_aux_alloc_real<std::allocator<__int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z PROC ; std::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@11
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@11:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE@V?$allocator@PAVTransaction@DRAMsimII@@@1@@Z ENDP ; std::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Vector_val<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@207
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@207
$LN17@operator@207:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@207
$LN13@operator@207:
	xor	eax, eax
$LN14@operator@207:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@207
	call	__invalid_parameter_noinfo
$LN18@operator@207:
	add	DWORD PTR [esi+4], 4

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<__int64,std::allocator<__int64> >::_Vector_iterator<__int64,std::allocator<__int64> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@14
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@14
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@14
$LN3@Vector_ite@14:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@14:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE@PA_JPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<__int64,std::allocator<__int64> >::_Vector_iterator<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN3@Vector_ite@15
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN3@Vector_ite@15
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN4@Vector_ite@15
$LN3@Vector_ite@15:
	call	__invalid_parameter_noinfo
$LN4@Vector_ite@15:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@PAVBank@DRAMsimII@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+=, COMDAT
; _this$ = edi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN20@operator@208
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN10@operator@208
$LN20@operator@208:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@208
$LN10@operator@208:
	xor	edx, edx
$LN11@operator@208:
	mov	ecx, DWORD PTR [edi+4]
	push	esi
	mov	esi, DWORD PTR __Off$[esp]
	imul	esi, 200				; 000000c8H
	add	ecx, esi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@208
	test	eax, eax
	je	SHORT $LN16@operator@208
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@208
$LN16@operator@208:
	xor	eax, eax
$LN17@operator@208:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@208
$LN1@operator@208:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@208:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [edi+4], esi

; 165  : 		return (*this);

	mov	eax, edi
	pop	esi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@209
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@209
$LN13@operator@209:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@209
$LN9@operator@209:
	xor	eax, eax
$LN10@operator@209:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@209
	call	__invalid_parameter_noinfo
$LN14@operator@209:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 200			; 000000c8H

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@210
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@210
$LN13@operator@210:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@210
$LN9@operator@210:
	xor	eax, eax
$LN10@operator@210:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@210
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN14@operator@210:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+=, COMDAT
; _this$ = edi

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN22@operator@211
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN12@operator@211
$LN22@operator@211:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN13@operator@211
$LN12@operator@211:
	xor	edx, edx
$LN13@operator@211:
	mov	ecx, DWORD PTR [edi+4]
	push	esi
	mov	esi, DWORD PTR __Off$[esp]
	imul	esi, 200				; 000000c8H
	add	ecx, esi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN3@operator@211
	test	eax, eax
	je	SHORT $LN18@operator@211
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@211
$LN18@operator@211:
	xor	eax, eax
$LN19@operator@211:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN23@operator@211
$LN3@operator@211:
	call	__invalid_parameter_noinfo
$LN23@operator@211:
	add	DWORD PTR [edi+4], esi

; 376  : 		return (*this);

	mov	eax, edi
	pop	esi

; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@212
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@212
$LN15@operator@212:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@212
$LN11@operator@212:
	xor	eax, eax
$LN12@operator@212:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@212
	call	__invalid_parameter_noinfo
$LN16@operator@212:
	add	DWORD PTR [esi+4], 200			; 000000c8H

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z PROC ; std::_Vector_val<double,std::allocator<double> >::_Vector_val<double,std::allocator<double> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@12
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@12:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z ENDP ; std::_Vector_val<double,std::allocator<double> >::_Vector_val<double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ PROC ; std::vector<double,std::allocator<double> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@23
	call	__invalid_parameter_noinfo
$LN6@end@23:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ ENDP ; std::vector<double,std::allocator<double> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+=, COMDAT
; _this$ = edi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN20@operator@213
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN10@operator@213
$LN20@operator@213:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN11@operator@213
$LN10@operator@213:
	xor	edx, edx
$LN11@operator@213:
	mov	ecx, DWORD PTR [edi+4]
	push	esi
	mov	esi, DWORD PTR __Off$[esp]
	imul	esi, 152				; 00000098H
	add	ecx, esi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN1@operator@213
	test	eax, eax
	je	SHORT $LN16@operator@213
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@213
$LN16@operator@213:
	xor	eax, eax
$LN17@operator@213:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN21@operator@213
$LN1@operator@213:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN21@operator@213:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [edi+4], esi

; 165  : 		return (*this);

	mov	eax, edi
	pop	esi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@214
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@214
$LN13@operator@214:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@214
$LN9@operator@214:
	xor	eax, eax
$LN10@operator@214:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@214
	call	__invalid_parameter_noinfo
$LN14@operator@214:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 152			; 00000098H

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@215
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@215
$LN13@operator@215:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@215
$LN9@operator@215:
	xor	eax, eax
$LN10@operator@215:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@215
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN14@operator@215:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@216
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@216
$LN13@operator@216:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@216
$LN9@operator@216:
	xor	eax, eax
$LN10@operator@216:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@216
	call	__invalid_parameter_noinfo
$LN14@operator@216:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 8

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z PROC ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@13
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@13:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ENDP ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@14
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@14:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@24
	call	__invalid_parameter_noinfo
$LN6@end@24:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEAAU?$pair@I_J@2@XZ
_TEXT	SEGMENT
$T394116 = -8						; size = 8
?front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEAAU?$pair@I_J@2@XZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::front, COMDAT
; _this$ = edi

; 780  : 		return (*begin());

	mov	eax, DWORD PTR [edi+28]
	sub	esp, 8
	push	esi
	mov	esi, DWORD PTR [edi+24]
	add	eax, esi
	cmp	esi, eax
	jbe	SHORT $LN8@front@4
	call	__invalid_parameter_noinfo
$LN8@front@4:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR $T394116[esp+16], esi
	lea	esi, DWORD PTR $T394116[esp+12]
	mov	DWORD PTR $T394116[esp+12], ecx
	call	??D?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEABU?$pair@I_J@1@XZ ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*
	pop	esi

; 781  : 		}

	add	esp, 8
	ret	0
?front@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEAAU?$pair@I_J@2@XZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >, COMDAT
; _this$ = esi

; 554  : 		{	// construct empty deque

	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN18@deque
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 555  : 		}

	mov	eax, esi
	ret	0

; 554  : 		{	// construct empty deque

$LN18@deque:
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 555  : 		}

	mov	eax, esi
	ret	0
??0?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAE@XZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z PROC ; std::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@15
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@15:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE@V?$allocator@VRank@DRAMsimII@@@1@@Z ENDP ; std::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Vector_val<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@_JV?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@_JV?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z PROC ; std::_Vector_val<__int64,std::allocator<__int64> >::_Vector_val<__int64,std::allocator<__int64> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@16
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@16:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@_JV?$allocator@_J@std@@@std@@IAE@V?$allocator@_J@1@@Z ENDP ; std::_Vector_val<__int64,std::allocator<__int64> >::_Vector_val<__int64,std::allocator<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@217
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@217
$LN3@operator@217:
	call	__invalid_parameter_noinfo
$LN4@operator@217:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+, COMDAT
; _this$ = eax
; __Off$ = ecx

; 169  : 		{	// return this + integer

	push	ebx

; 170  : 		_Myt _Tmp = *this;

	mov	ebx, DWORD PTR [eax+4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, ecx

; 171  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN22@operator@218
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN13@operator@218:
	imul	edi, 200				; 000000c8H
	add	edi, ebx
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN3@operator@218
	test	esi, esi
	je	SHORT $LN18@operator@218
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN19@operator@218
$LN22@operator@218:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN13@operator@218
$LN18@operator@218:
	xor	eax, eax
$LN19@operator@218:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN4@operator@218
$LN3@operator@218:
	call	__invalid_parameter_noinfo
$LN4@operator@218:
	mov	DWORD PTR [ebp+4], edi

; 172  : 		}

	pop	edi
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	4
??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 131  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 132  : 		++*this;

	test	eax, eax
	jne	SHORT $LN15@operator@219
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@219
$LN15@operator@219:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@219
$LN11@operator@219:
	xor	eax, eax
$LN12@operator@219:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@219
	call	__invalid_parameter_noinfo
$LN16@operator@219:
	add	DWORD PTR [esi+4], 200			; 000000c8H

; 133  : 		return (_Tmp);

	mov	eax, edi

; 134  : 		}

	ret	0
??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ
_TEXT	SEGMENT
??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->, COMDAT
; _this$ = esi

; 111  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@220
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@220
$LN15@operator@220:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@220
$LN11@operator@220:
	xor	eax, eax
$LN12@operator@220:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@220
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 112  : 		}

	ret	0
$LN16@operator@220:

; 111  : 		return (&**this);

	mov	eax, ecx

; 112  : 		}

	ret	0
??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??H?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+, COMDAT
; _this$ = eax
; __Off$ = ecx

; 380  : 		{	// return this + integer

	push	ebx

; 381  : 		_Myt _Tmp = *this;

	mov	ebx, DWORD PTR [eax+4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, ecx

; 382  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN24@operator@221
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN15@operator@221:
	imul	edi, 200				; 000000c8H
	add	edi, ebx
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN5@operator@221
	test	esi, esi
	je	SHORT $LN20@operator@221
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN21@operator@221
$LN24@operator@221:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN15@operator@221
$LN20@operator@221:
	xor	eax, eax
$LN21@operator@221:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN6@operator@221
$LN5@operator@221:
	call	__invalid_parameter_noinfo
$LN6@operator@221:
	mov	DWORD PTR [ebp+4], edi

; 383  : 		}

	pop	edi
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	4
??H?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@222
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@222
$LN17@operator@222:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@222
$LN13@operator@222:
	xor	eax, eax
$LN14@operator@222:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@222
	call	__invalid_parameter_noinfo
$LN18@operator@222:
	add	DWORD PTR [esi+4], 200			; 000000c8H

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEAAVRank@DRAMsimII@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEAAVRank@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*, COMDAT
; _this$ = esi

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@223
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@223
$LN15@operator@223:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@223
$LN11@operator@223:
	xor	eax, eax
$LN12@operator@223:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@223
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 340  : 		}

	ret	0
$LN16@operator@223:

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 340  : 		}

	ret	0
??D?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEAAVRank@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@operator@224
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN4@operator@224
$LN3@operator@224:
	call	__invalid_parameter_noinfo
$LN4@operator@224:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+, COMDAT
; _this$ = eax
; __Off$ = ecx

; 169  : 		{	// return this + integer

	push	ebx

; 170  : 		_Myt _Tmp = *this;

	mov	ebx, DWORD PTR [eax+4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, ecx

; 171  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN22@operator@225
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN13@operator@225:
	imul	edi, 152				; 00000098H
	add	edi, ebx
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN3@operator@225
	test	esi, esi
	je	SHORT $LN18@operator@225
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN19@operator@225
$LN22@operator@225:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN13@operator@225
$LN18@operator@225:
	xor	eax, eax
$LN19@operator@225:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN4@operator@225
$LN3@operator@225:
	call	__invalid_parameter_noinfo
$LN4@operator@225:
	mov	DWORD PTR [ebp+4], edi

; 172  : 		}

	pop	edi
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	4
??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 131  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 132  : 		++*this;

	test	eax, eax
	jne	SHORT $LN15@operator@226
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@226
$LN15@operator@226:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@226
$LN11@operator@226:
	xor	eax, eax
$LN12@operator@226:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@226
	call	__invalid_parameter_noinfo
$LN16@operator@226:
	add	DWORD PTR [esi+4], 152			; 00000098H

; 133  : 		return (_Tmp);

	mov	eax, edi

; 134  : 		}

	ret	0
??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ
_TEXT	SEGMENT
??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ PROC ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->, COMDAT
; _this$ = esi

; 111  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@227
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@227
$LN15@operator@227:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@227
$LN11@operator@227:
	xor	eax, eax
$LN12@operator@227:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@227
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 112  : 		}

	ret	0
$LN16@operator@227:

; 111  : 		return (&**this);

	mov	eax, ecx

; 112  : 		}

	ret	0
??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ENDP ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 131  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 132  : 		++*this;

	test	eax, eax
	jne	SHORT $LN15@operator@228
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@228
$LN15@operator@228:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@228
$LN11@operator@228:
	xor	eax, eax
$LN12@operator@228:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@228
	call	__invalid_parameter_noinfo
$LN16@operator@228:
	add	DWORD PTR [esi+4], 8

; 133  : 		return (_Tmp);

	mov	eax, edi

; 134  : 		}

	ret	0
??E?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEAB_JXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEAB_JXZ PROC ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN13@operator@229
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@operator@229
$LN13@operator@229:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN10@operator@229
$LN9@operator@229:
	xor	eax, eax
$LN10@operator@229:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@operator@229
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN14@operator@229:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@_JV?$allocator@_J@std@@@std@@QBEAB_JXZ ENDP ; std::_Vector_const_iterator<__int64,std::allocator<__int64> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\smart_ptr\intrusive_ptr.hpp
_TEXT	ENDS
;	COMDAT ??1?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@XZ
_TEXT	SEGMENT
??1?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@XZ PROC ; boost::intrusive_ptr<boost::detail::thread_data_base>::~intrusive_ptr<boost::detail::thread_data_base>, COMDAT
; _this$ = ecx

; 100  :     {

	push	esi

; 101  :         if( px != 0 ) intrusive_ptr_release( px );

	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	je	SHORT $LN9@intrusive_@3
	lea	eax, DWORD PTR [esi+4]
	or	ecx, -1
	lock	 xadd	 DWORD PTR [eax], ecx
	jne	SHORT $LN9@intrusive_@3
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	0
	mov	ecx, esi
	call	eax
	push	esi
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapFree@12
$LN9@intrusive_@3:
	pop	esi

; 102  :     }

	ret	0
??1?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@XZ ENDP ; boost::intrusive_ptr<boost::detail::thread_data_base>::~intrusive_ptr<boost::detail::thread_data_base>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\queue
_TEXT	ENDS
;	COMDAT ?front@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEAAU?$pair@I_J@2@XZ
_TEXT	SEGMENT
$T395121 = -8						; size = 8
?front@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEAAU?$pair@I_J@2@XZ PROC ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::front, COMDAT
; _this$ = edi

; 51   : 		return (c.front());

	mov	eax, DWORD PTR [edi+28]
	sub	esp, 8
	push	esi
	mov	esi, DWORD PTR [edi+24]
	add	eax, esi
	cmp	esi, eax
	jbe	SHORT $LN10@front@5
	call	__invalid_parameter_noinfo
$LN10@front@5:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR $T395121[esp+16], esi
	lea	esi, DWORD PTR $T395121[esp+12]
	mov	DWORD PTR $T395121[esp+12], ecx
	call	??D?$_Deque_const_iterator@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@$00@std@@QBEABU?$pair@I_J@1@XZ ; std::_Deque_const_iterator<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> >,1>::operator*
	pop	esi

; 52   : 		}

	add	esp, 8
	ret	0
?front@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEAAU?$pair@I_J@2@XZ ENDP ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ PROC ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >, COMDAT
; _this$ = esi

; 31   : 		{	// construct with empty container

	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN21@queue
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 32   : 		}

	mov	eax, esi
	ret	0

; 31   : 		{	// construct with empty container

$LN21@queue:
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 32   : 		}

	mov	eax, esi
	ret	0
??0?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ ENDP ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?end@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ PROC ; std::vector<__int64,std::allocator<__int64> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@25
	call	__invalid_parameter_noinfo
$LN6@end@25:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ ENDP ; std::vector<__int64,std::allocator<__int64> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ PROC ; std::vector<__int64,std::allocator<__int64> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@28
	call	__invalid_parameter_noinfo
$LN6@begin@28:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@XZ ENDP ; std::vector<__int64,std::allocator<__int64> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN6@end@26
	call	__invalid_parameter_noinfo
$LN6@end@26:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN6@begin@29
	call	__invalid_parameter_noinfo
$LN6@begin@29:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
_TEXT	ENDS
;	COMDAT ?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ
_TEXT	SEGMENT
?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ PROC ; DRAMsimII::Queue<DRAMsimII::Command>::front, COMDAT
; _this$ = esi

; 228  : #ifdef DEBUG
; 229  : 			assert(count > 0 ? entry[head] != NULL : entry[head] == NULL);
; 230  : #endif
; 231  : 			return entry[head];

	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN8@front@6
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi

; 232  : 			//return count ? entry[head] : NULL;
; 233  : 		}

	ret	0
$LN8@front@6:

; 228  : #ifdef DEBUG
; 229  : 			assert(count > 0 ? entry[head] != NULL : entry[head] == NULL);
; 230  : #endif
; 231  : 			return entry[head];

	mov	edx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [edx+edi*4]
	pop	edi

; 232  : 			//return count ? entry[head] : NULL;
; 233  : 		}

	ret	0
?front@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QBEPBVCommand@2@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::Command>::front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_rhs$ = 12						; size = 4
??8?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator==, COMDAT

; 391  : 		{

	push	ebp
	mov	ebp, DWORD PTR _this$[esp]

; 392  : 			if (count == rhs.count && entry.size() == rhs.entry.size() &&
; 393  : 				head == rhs.head && tail == rhs.tail && pool == rhs.pool)

	mov	eax, DWORD PTR [ebp]
	push	edi
	mov	edi, DWORD PTR _rhs$[esp+4]
	cmp	eax, DWORD PTR [edi]
	jne	$LN11@operator@230
	mov	ecx, DWORD PTR [edi+28]
	mov	edx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [edi+24]
	sub	edx, DWORD PTR [ebp+24]
	xor	ecx, edx
	test	ecx, -4					; fffffffcH
	jne	$LN11@operator@230
	mov	ecx, DWORD PTR [ebp+4]
	cmp	ecx, DWORD PTR [edi+4]
	jne	$LN11@operator@230
	mov	edx, DWORD PTR [ebp+8]
	cmp	edx, DWORD PTR [edi+8]
	jne	$LN11@operator@230
	mov	cl, BYTE PTR [ebp+36]
	cmp	cl, BYTE PTR [edi+36]
	jne	$LN11@operator@230
	push	ebx

; 394  : 			{
; 395  : 				for (unsigned i = 0; i < count; i++)

	xor	ebx, ebx
	push	esi
	test	eax, eax
	jbe	SHORT $LN8@operator@230
	npad	5
$LL10@operator@230:

; 396  : 				{
; 397  : 					if (at(i) && rhs.at(i))

	mov	ecx, ebx
	mov	esi, ebp
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	test	eax, eax
	je	SHORT $LN7@operator@230
	mov	ecx, ebx
	mov	esi, edi
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	test	eax, eax
	je	SHORT $LN7@operator@230

; 398  : 					{
; 399  : 						if (!(*(at(i)) == *(rhs.at(i))))

	mov	ecx, ebx
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	mov	ecx, ebx
	mov	esi, ebp
	mov	edi, eax
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	mov	esi, edi
	mov	edi, eax
	call	??8Transaction@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Transaction::operator==
	test	al, al
	je	SHORT $LN21@operator@230

; 400  : 							return false;
; 401  : 					}

	mov	edi, DWORD PTR _rhs$[esp+12]
	jmp	SHORT $LN9@operator@230
$LN7@operator@230:

; 402  : 					else if (at(i) != NULL && rhs.at(i) == NULL)

	mov	ecx, ebx
	mov	esi, ebp
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	test	eax, eax
	je	SHORT $LN4@operator@230
	mov	ecx, ebx
	mov	esi, edi
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	test	eax, eax
	je	SHORT $LN21@operator@230
$LN4@operator@230:

; 403  : 						return false;
; 404  : 					else if (at(i) == NULL && rhs.at(i) != NULL)

	mov	ecx, ebx
	mov	esi, ebp
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	test	eax, eax
	jne	SHORT $LN9@operator@230
	mov	ecx, ebx
	mov	esi, edi
	call	?at@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@2@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::at
	test	eax, eax
	jne	SHORT $LN21@operator@230
$LN9@operator@230:

; 394  : 			{
; 395  : 				for (unsigned i = 0; i < count; i++)

	inc	ebx
	cmp	ebx, DWORD PTR [ebp]
	jb	SHORT $LL10@operator@230
$LN8@operator@230:
	pop	esi
	pop	ebx
	pop	edi

; 406  : 				}	
; 407  : 				return true;

	mov	al, 1
	pop	ebp

; 411  : 		}

	ret	8
$LN21@operator@230:
	pop	esi
	pop	ebx
	pop	edi

; 405  : 						return false;

	xor	al, al
	pop	ebp

; 411  : 		}

	ret	8
$LN11@operator@230:
	pop	edi

; 408  : 			}
; 409  : 			else
; 410  : 				return false;

	xor	al, al
	pop	ebp

; 411  : 		}

	ret	8
??8?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator==
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ$0
__ehfuncinfo$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
xdata$x	ENDS
;	COMDAT ??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>, COMDAT

; 103  : 		{

	push	-1
	push	__ehhandler$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+28]
	mov	DWORD PTR __$EHRec$[esp+40], 0
$LL7@Queue@2:

; 104  : 			while (T* value = pop())

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN107@Queue@2
	mov	edi, DWORD PTR [esi+4]
	dec	eax
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN19@Queue@2
	call	__invalid_parameter_noinfo
$LN19@Queue@2:
	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi+28]
	mov	ebp, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [ecx+edi*4]
	sub	edx, ecx
	sar	edx, 2
	cmp	ebp, edx
	jb	SHORT $LN24@Queue@2
	call	__invalid_parameter_noinfo
$LN24@Queue@2:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+ebp*4], 0
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	sar	ecx, 2
	inc	eax
	xor	edx, edx
	div	ecx
	mov	DWORD PTR [esi+4], edx
	test	edi, edi
	je	SHORT $LN107@Queue@2

; 105  : 			{
; 106  : 				if (pool)

	cmp	BYTE PTR [esi+36], 0

; 107  : 					::delete value;

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, edi
	je	SHORT $LN5@Queue@2
	push	0
	call	eax
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 108  : 				else

	jmp	SHORT $LL7@Queue@2
$LN5@Queue@2:

; 109  : 					delete value;			

	push	1
	call	eax

; 110  : 			}

	jmp	SHORT $LL7@Queue@2
$LN107@Queue@2:

; 111  : 			for (typename std::vector<T*>::iterator i = entry.begin(); i != entry.end(); i++)

	mov	ebp, DWORD PTR [esi+24]
	cmp	ebp, DWORD PTR [esi+28]
	jbe	SHORT $LN36@Queue@2
	call	__invalid_parameter_noinfo
$LN36@Queue@2:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, ebp
	npad	3
$LL53@Queue@2:
	mov	ebp, DWORD PTR [esi+28]
	cmp	DWORD PTR [esi+24], ebp
	jbe	SHORT $LN68@Queue@2
	call	__invalid_parameter_noinfo
$LN68@Queue@2:
	mov	eax, DWORD PTR [esi+12]
	test	edi, edi
	je	SHORT $LN81@Queue@2
	cmp	edi, eax
	je	SHORT $LN82@Queue@2
$LN81@Queue@2:
	call	__invalid_parameter_noinfo
$LN82@Queue@2:
	cmp	ebx, ebp
	je	SHORT $LN1@Queue@2
	test	edi, edi
	jne	SHORT $LN106@Queue@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN60@Queue@2:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN51@Queue@2
	call	__invalid_parameter_noinfo
$LN51@Queue@2:
	add	ebx, 4
	jmp	SHORT $LL53@Queue@2
$LN106@Queue@2:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN60@Queue@2
$LN1@Queue@2:

; 112  : 				assert(*i == NULL);
; 113  : 		}	

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN94@Queue@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN94@Queue@2:
	mov	ecx, DWORD PTR [esi+12]
	xor	eax, eax
	push	ecx
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 12					; 0000000cH
	jmp	??1?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
__ehhandler$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
tv904 = -36						; size = 4
$T396071 = -36						; size = 4
tv162 = -32						; size = 8
_this$ = -32						; size = 4
$T396346 = -24						; size = 4
$T396240 = -24						; size = 4
tv893 = -20						; size = 4
$T396444 = -20						; size = 4
__Tmp$396064 = -16					; size = 8
__Tmp$396216 = -8					; size = 8
_currentCommand$ = 8					; size = 4
?earliestExecuteTime@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z PROC ; DRAMsimII::Channel::earliestExecuteTime
; _this$ = ecx

; 2605 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 36					; 00000024H

; 2606 : 
; 2607 : 	tick nextTime;	
; 2608 : 
; 2609 : 	const vector<Rank>::const_iterator currentRank = rank.begin() + currentCommand->getAddress().getRank();

	mov	eax, DWORD PTR _currentCommand$[ebp]
	push	ebx
	mov	ebx, DWORD PTR [eax+60]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+380]
	mov	DWORD PTR _this$[esp+48], esi
	cmp	edi, DWORD PTR [esi+384]
	jbe	SHORT $LN16@earliestEx
	call	__invalid_parameter_noinfo
$LN16@earliestEx:
	mov	esi, DWORD PTR [esi+368]
	mov	DWORD PTR __Tmp$396064[esp+48], esi
	mov	DWORD PTR __Tmp$396064[esp+52], edi
	test	esi, esi
	jne	SHORT $LN213@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN39@earliestEx:
	imul	ebx, 200				; 000000c8H
	add	edi, ebx
	mov	DWORD PTR tv893[esp+48], edi
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN29@earliestEx
	test	esi, esi
	je	SHORT $LN44@earliestEx
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN45@earliestEx
$LN213@earliestEx:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN39@earliestEx
$LN44@earliestEx:
	xor	esi, esi
$LN45@earliestEx:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN30@earliestEx
$LN29@earliestEx:
	call	__invalid_parameter_noinfo
$LN30@earliestEx:

; 2610 : 
; 2611 : 	const vector<Bank>::const_iterator currentBank = currentRank->bank.begin() + currentCommand->getAddress().getBank();

	mov	ecx, DWORD PTR _currentCommand$[ebp]
	mov	eax, DWORD PTR __Tmp$396064[esp+48]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR $T396071[esp+48], edx
	test	eax, eax
	jne	SHORT $LN212@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN63@earliestEx:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN54@earliestEx
	call	__invalid_parameter_noinfo
$LN54@earliestEx:
	mov	ebx, DWORD PTR [edi+184]
	cmp	ebx, DWORD PTR [edi+188]
	jbe	SHORT $LN69@earliestEx
	call	__invalid_parameter_noinfo
$LN69@earliestEx:
	mov	esi, DWORD PTR [edi+172]
	mov	edi, esi
	mov	DWORD PTR __Tmp$396216[esp+48], edi
	mov	DWORD PTR __Tmp$396216[esp+52], ebx
	test	esi, esi
	jne	SHORT $LN211@earliestEx
	call	__invalid_parameter_noinfo
	xor	ecx, ecx
$LN92@earliestEx:
	mov	eax, DWORD PTR $T396071[esp+48]
	imul	eax, 152				; 00000098H
	add	ebx, eax
	mov	DWORD PTR tv904[esp+48], ebx
	cmp	ebx, DWORD PTR [ecx+16]
	ja	SHORT $LN82@earliestEx
	test	esi, esi
	je	SHORT $LN97@earliestEx
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN98@earliestEx
$LN212@earliestEx:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN63@earliestEx
$LN211@earliestEx:
	mov	ecx, DWORD PTR [esi]
	jmp	SHORT $LN92@earliestEx
$LN97@earliestEx:
	xor	esi, esi
$LN98@earliestEx:
	cmp	ebx, DWORD PTR [esi+12]
	jae	SHORT $LN83@earliestEx
$LN82@earliestEx:
	call	__invalid_parameter_noinfo
$LN83@earliestEx:

; 2612 : 
; 2613 : #ifndef NDEBUG
; 2614 : 	switch(currentCommand->getCommandType())
; 2615 : 	{
; 2616 : 	case Command::ACTIVATE:
; 2617 : 		{
; 2618 : 			// refer to Table 11.4 in Memory Systems: Cache, DRAM, Disk
; 2619 : 
; 2620 : 			// respect the row cycle time limitation
; 2621 : 			tick tRCLimit = currentBank->getLastRASTime() + timingSpecification.tRC();
; 2622 : 
; 2623 : 			// respect the row-to-row activation delay for different banks within a rank
; 2624 : 			tick tRRDLimit = currentRank->lastActivateTimes.front() + timingSpecification.tRRD();				
; 2625 : 
; 2626 : 			// respect tRP of same bank
; 2627 : 			tick tRPLimit = currentBank->getLastPrechargeTime() + timingSpecification.tRP();
; 2628 : 
; 2629 : 			// respect the t_faw value for DDR2 and beyond, look at the fourth activate ago
; 2630 : 			tick tFAWLimit = currentRank->lastActivateTimes.back() + timingSpecification.tFAW();
; 2631 : 
; 2632 : 			// respect tRFC, refresh cycle time
; 2633 : 			tick tRFCLimit = currentRank->getLastRefreshTime() + timingSpecification.tRFC();
; 2634 : 
; 2635 : 			nextTime = max(max(max(tRFCLimit,tRCLimit) , tRPLimit) , max(tRRDLimit , tFAWLimit));
; 2636 : 
; 2637 : 			assert(nextTime >= currentBank->getLastPrechargeTime() + timingSpecification.tRP());
; 2638 : 			//DEBUG_TIMING_LOG(currentCommand->getCommandType() << " ras[" << setw(2) << t_ras_gap << "] rrd[" << setw(2) << t_rrd_gap << "] faw[" << setw(2) << t_faw_gap << "] cas[" << setw(2) << t_cas_gap << "] rrd[" << setw(2) << t_rrd_gap << "] rp[" << setw(2) << t_rp_gap << "] min[" << setw(2) << min_gap << "]");
; 2639 : 		}
; 2640 : 		break;
; 2641 : 
; 2642 : 	case Command::READ_AND_PRECHARGE:
; 2643 : 		// Auto precharge will be issued as part of command,
; 2644 : 		// but DRAM devices are intelligent enough to delay the prec command
; 2645 : 		// until tRAS timing is met (thanks to tAL), so no need to check tRAS timing requirement here.
; 2646 : 
; 2647 : 	case Command::READ:
; 2648 : 		{
; 2649 : 			//respect last RAS of same rank
; 2650 : 			tick tRCDLimit = currentBank->getLastRASTime() + (timingSpecification.tRCD() - timingSpecification.tAL());
; 2651 : 
; 2652 : 			// ensure that if no other rank has issued a CAS command that it will treat
; 2653 : 			// this as if a CAS command was issued long ago
; 2654 : 
; 2655 : 			// respect last CAS of same rank
; 2656 : 			// DW 3/9/2006 add these two lines
; 2657 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2658 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2659 : 			// DW 3/9/2006 replace the line after next with the next line
; 2660 : 			//t_cas_gap = max(0,(int)(this_r.last_cas_time + cas_length - now));
; 2661 : 			tick tCASLimit = currentRank->getLastCASTime() + timingSpecification.tBurst();
; 2662 : 
; 2663 : 			// respect last CASW of same rank
; 2664 : 			// DW 3/9/2006 replace the line after next with the next line
; 2665 : 			//t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + timing_specification.t_cwd + casw_length + timing_specification.t_wtr - now));
; 2666 : 			tCASLimit = max(tCASLimit,currentRank->getLastCASWTime() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWTR());
; 2667 : 
; 2668 : 			//if (rank->size() > 1)
; 2669 : 			{
; 2670 : 				//respect most recent CAS of different rank
; 2671 : 				tCASLimit = max(tCASLimit, currentRank->getOtherLastCASTime() + currentRank->getOtherLastCASLength() + timingSpecification.tRTRS());
; 2672 : 				//respect timing of READ follow WRITE, different ranks
; 2673 : 				tCASLimit = max(tCASLimit, currentRank->getOtherLastCASWTime() + timingSpecification.tCWD() + currentRank->getOtherLastCASWLength() + timingSpecification.tRTRS() - timingSpecification.tCAS());
; 2674 : 			}
; 2675 : 
; 2676 : 			nextTime = max(tRCDLimit,tCASLimit);
; 2677 : 
; 2678 : 			//fprintf(stderr," [%8d] [%8d] [%8d] [%8d] [%8d] [%2d]\n",(int)now,(int)this_r_last_cas_time,(int)this_r_last_casw_time,(int)other_r_last_cas_time,(int)other_r_last_casw_time,min_gap);
; 2679 : 		}
; 2680 : 		break;
; 2681 : 
; 2682 : 	case Command::WRITE_AND_PRECHARGE:
; 2683 : 		// Auto precharge will be issued as part of command, so
; 2684 : 		// Since commodity DRAM devices are write-cycle limited, we don't have to worry if
; 2685 : 		// the precharge will meet tRAS timing or not. So WRITE_AND_PRECHARGE
; 2686 : 		// has the exact same timing requirements as a simple WRITE.
; 2687 : 
; 2688 : 	case Command::WRITE:
; 2689 : 		{
; 2690 : 			//respect last RAS of same rank
; 2691 : 			tick tRASLimit = currentBank->getLastRASTime() + timingSpecification.tRCD() - timingSpecification.tAL();
; 2692 : 
; 2693 : 			// DW 3/9/2006 add these two lines
; 2694 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2695 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2696 : 
; 2697 : 			// respect last cas to same rank
; 2698 : 			// DW 3/9/2006 replace the line after next with the next line
; 2699 : 			// t_cas_gap = max(0,(int)(this_r.last_cas_time + timing_specification.t_cas + cas_length + timing_specification.t_rtrs - timing_specification.t_cwd - now));
; 2700 : 			tick tCASLimit = currentRank->getLastCASTime() + timingSpecification.tCAS() + timingSpecification.tBurst() + timingSpecification.tRTRS() - timingSpecification.tCWD();
; 2701 : 
; 2702 : 			// respect last cas to different ranks
; 2703 : 			tCASLimit = max(tCASLimit,currentRank->getOtherLastCASTime() + timingSpecification.tCAS() + currentRank->getOtherLastCASLength() + timingSpecification.tRTRS() - timingSpecification.tCWD());
; 2704 : 
; 2705 : 			// respect last cas write to same rank
; 2706 : 			// DW 3/9/2006 replace the line after next with the next line			
; 2707 : 			// t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + casw_length - now));
; 2708 : 			tCASLimit = max(tCASLimit,currentRank->getLastCASWTime() + currentRank->getLastCASWLength());
; 2709 : 
; 2710 : 			// respect last CASW to different ranks
; 2711 : 			// TODO: should this not also be -tAL?
; 2712 : 			tCASLimit = max(tCASLimit,currentRank->getOtherLastCASWTime() + currentRank->getOtherLastCASWLength() + timingSpecification.tOST());
; 2713 : 
; 2714 : 			nextTime = max(tRASLimit,tCASLimit);
; 2715 : 		}
; 2716 : 		break;
; 2717 : 
; 2718 : 	case Command::PRECHARGE:
; 2719 : 		{
; 2720 : 			// respect t_ras of same bank
; 2721 : 			tick tRASLimit = currentBank->getLastRASTime() + timingSpecification.tRAS();
; 2722 : 
; 2723 : 			// respect t_cas of same bank
; 2724 : 			//tick tCASLimit = max(time,currentBank->getLastCASTime() + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD()));
; 2725 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 2726 : 			tick tCASLimit = currentBank->getLastCASTime() + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD());
; 2727 : 
; 2728 : 			// respect t_casw of same bank
; 2729 : 			//tCASLimit = max(tCASLimit,currentBank->getLastCASWTime() + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2730 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 2731 : 			tCASLimit = max(tCASLimit,currentBank->getLastCASWTime() + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2732 : 
; 2733 : 			nextTime = max(tRASLimit,tCASLimit);
; 2734 : 		}
; 2735 : 		break;
; 2736 : 
; 2737 : 	case Command::REFRESH_ALL:
; 2738 : 		// respect tRFC and tRP
; 2739 : 		nextTime = max(currentRank->getLastRefreshTime() + timingSpecification.tRFC(), currentRank->getLastPrechargeTime() + timingSpecification.tRP());
; 2740 : 		break;
; 2741 : 
; 2742 : 	case Command::RETIRE_COMMAND:
; 2743 : 	case Command::PRECHARGE_ALL:
; 2744 : 	case Command::ACTIVATE_ALL:
; 2745 : 	case Command::DRIVE_COMMAND:
; 2746 : 	case Command::DATA_COMMAND:
; 2747 : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 2748 : 	case Command::SELF_REFRESH:
; 2749 : 	case Command::DESELECT:
; 2750 : 	case Command::NOOP:
; 2751 : 	case Command::INVALID_COMMAND:
; 2752 : 	default:
; 2753 : 		cerr << "Unsupported command encountered." << endl;
; 2754 : 		nextTime = 0;
; 2755 : 		break;
; 2756 : 	}
; 2757 : 
; 2758 : 	//return max(nextTime, time + timingSpecification.tCMD());
; 2759 : 	//return max(nextTime, max(time, lastCommandIssueTime + timingSpecification.tCMD()));
; 2760 : 	tick actualNext = max(nextTime, lastCommandIssueTime + timingSpecification.tCMD());
; 2761 : 	tick predictedNext = max(currentRank->next(currentCommand->getCommandType()), 
; 2762 : 		max(currentBank->next(currentCommand->getCommandType()), lastCommandIssueTime + timingSpecification.tCMD()));
; 2763 : 	if (actualNext != predictedNext )
; 2764 : 		assert(actualNext == predictedNext);
; 2765 : #endif
; 2766 : 
; 2767 : 	return max(currentRank->next(currentCommand->getCommandType()), 
; 2768 : 		max(currentBank->next(currentCommand->getCommandType()), lastCommandIssueTime + timingSpecification.tCMD()));

	mov	eax, DWORD PTR _currentCommand$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR $T396240[esp+48], ecx
	test	edi, edi
	jne	SHORT $LN210@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN114@earliestEx:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN105@earliestEx
	call	__invalid_parameter_noinfo
$LN105@earliestEx:
	mov	ebx, DWORD PTR _this$[esp+48]
	mov	eax, DWORD PTR [ebx+44]
	mov	ecx, DWORD PTR tv904[esp+48]
	cdq
	mov	edi, eax
	add	edi, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR $T396240[esp+48]
	mov	esi, edx
	adc	esi, DWORD PTR [ebx+20]
	call	?next@Bank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ; DRAMsimII::Bank::next
	cmp	edx, esi
	jl	SHORT $LN3@earliestEx
	jg	SHORT $LN214@earliestEx
	cmp	eax, edi
	jbe	SHORT $LN3@earliestEx
$LN214@earliestEx:
	mov	eax, DWORD PTR __Tmp$396216[esp+48]
	mov	edx, DWORD PTR _currentCommand$[ebp]
	mov	esi, DWORD PTR [edx+80]
	test	eax, eax
	jne	SHORT $LN209@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN132@earliestEx:
	mov	edi, DWORD PTR tv904[esp+48]
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN123@earliestEx
	call	__invalid_parameter_noinfo
$LN123@earliestEx:
	mov	eax, esi
	mov	ecx, edi
	call	?next@Bank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ; DRAMsimII::Bank::next
	mov	DWORD PTR tv162[esp+48], eax
	mov	esi, edx
	jmp	SHORT $LN4@earliestEx
$LN210@earliestEx:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN114@earliestEx
$LN209@earliestEx:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN132@earliestEx
$LN3@earliestEx:
	mov	DWORD PTR tv162[esp+48], edi
$LN4@earliestEx:
	mov	eax, DWORD PTR _currentCommand$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	eax, DWORD PTR __Tmp$396064[esp+48]
	mov	DWORD PTR $T396346[esp+48], ecx
	test	eax, eax
	jne	SHORT $LN208@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN150@earliestEx:
	mov	edi, DWORD PTR tv893[esp+48]
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN141@earliestEx
	call	__invalid_parameter_noinfo
$LN141@earliestEx:
	mov	eax, DWORD PTR $T396346[esp+48]
	mov	ecx, edi
	call	?next@Rank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ; DRAMsimII::Rank::next
	cmp	edx, esi
	jl	SHORT $LN7@earliestEx
	jg	SHORT $LN215@earliestEx
	cmp	eax, DWORD PTR tv162[esp+48]
	jbe	SHORT $LN7@earliestEx
$LN215@earliestEx:
	mov	eax, DWORD PTR __Tmp$396064[esp+48]
	mov	edx, DWORD PTR _currentCommand$[ebp]
	mov	esi, DWORD PTR [edx+80]
	test	eax, eax
	jne	SHORT $LN207@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN166@earliestEx:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN157@earliestEx
	call	__invalid_parameter_noinfo
$LN157@earliestEx:
	mov	eax, esi
	mov	ecx, edi
	call	?next@Rank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ; DRAMsimII::Rank::next

; 2769 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN208@earliestEx:

; 2612 : 
; 2613 : #ifndef NDEBUG
; 2614 : 	switch(currentCommand->getCommandType())
; 2615 : 	{
; 2616 : 	case Command::ACTIVATE:
; 2617 : 		{
; 2618 : 			// refer to Table 11.4 in Memory Systems: Cache, DRAM, Disk
; 2619 : 
; 2620 : 			// respect the row cycle time limitation
; 2621 : 			tick tRCLimit = currentBank->getLastRASTime() + timingSpecification.tRC();
; 2622 : 
; 2623 : 			// respect the row-to-row activation delay for different banks within a rank
; 2624 : 			tick tRRDLimit = currentRank->lastActivateTimes.front() + timingSpecification.tRRD();				
; 2625 : 
; 2626 : 			// respect tRP of same bank
; 2627 : 			tick tRPLimit = currentBank->getLastPrechargeTime() + timingSpecification.tRP();
; 2628 : 
; 2629 : 			// respect the t_faw value for DDR2 and beyond, look at the fourth activate ago
; 2630 : 			tick tFAWLimit = currentRank->lastActivateTimes.back() + timingSpecification.tFAW();
; 2631 : 
; 2632 : 			// respect tRFC, refresh cycle time
; 2633 : 			tick tRFCLimit = currentRank->getLastRefreshTime() + timingSpecification.tRFC();
; 2634 : 
; 2635 : 			nextTime = max(max(max(tRFCLimit,tRCLimit) , tRPLimit) , max(tRRDLimit , tFAWLimit));
; 2636 : 
; 2637 : 			assert(nextTime >= currentBank->getLastPrechargeTime() + timingSpecification.tRP());
; 2638 : 			//DEBUG_TIMING_LOG(currentCommand->getCommandType() << " ras[" << setw(2) << t_ras_gap << "] rrd[" << setw(2) << t_rrd_gap << "] faw[" << setw(2) << t_faw_gap << "] cas[" << setw(2) << t_cas_gap << "] rrd[" << setw(2) << t_rrd_gap << "] rp[" << setw(2) << t_rp_gap << "] min[" << setw(2) << min_gap << "]");
; 2639 : 		}
; 2640 : 		break;
; 2641 : 
; 2642 : 	case Command::READ_AND_PRECHARGE:
; 2643 : 		// Auto precharge will be issued as part of command,
; 2644 : 		// but DRAM devices are intelligent enough to delay the prec command
; 2645 : 		// until tRAS timing is met (thanks to tAL), so no need to check tRAS timing requirement here.
; 2646 : 
; 2647 : 	case Command::READ:
; 2648 : 		{
; 2649 : 			//respect last RAS of same rank
; 2650 : 			tick tRCDLimit = currentBank->getLastRASTime() + (timingSpecification.tRCD() - timingSpecification.tAL());
; 2651 : 
; 2652 : 			// ensure that if no other rank has issued a CAS command that it will treat
; 2653 : 			// this as if a CAS command was issued long ago
; 2654 : 
; 2655 : 			// respect last CAS of same rank
; 2656 : 			// DW 3/9/2006 add these two lines
; 2657 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2658 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2659 : 			// DW 3/9/2006 replace the line after next with the next line
; 2660 : 			//t_cas_gap = max(0,(int)(this_r.last_cas_time + cas_length - now));
; 2661 : 			tick tCASLimit = currentRank->getLastCASTime() + timingSpecification.tBurst();
; 2662 : 
; 2663 : 			// respect last CASW of same rank
; 2664 : 			// DW 3/9/2006 replace the line after next with the next line
; 2665 : 			//t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + timing_specification.t_cwd + casw_length + timing_specification.t_wtr - now));
; 2666 : 			tCASLimit = max(tCASLimit,currentRank->getLastCASWTime() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWTR());
; 2667 : 
; 2668 : 			//if (rank->size() > 1)
; 2669 : 			{
; 2670 : 				//respect most recent CAS of different rank
; 2671 : 				tCASLimit = max(tCASLimit, currentRank->getOtherLastCASTime() + currentRank->getOtherLastCASLength() + timingSpecification.tRTRS());
; 2672 : 				//respect timing of READ follow WRITE, different ranks
; 2673 : 				tCASLimit = max(tCASLimit, currentRank->getOtherLastCASWTime() + timingSpecification.tCWD() + currentRank->getOtherLastCASWLength() + timingSpecification.tRTRS() - timingSpecification.tCAS());
; 2674 : 			}
; 2675 : 
; 2676 : 			nextTime = max(tRCDLimit,tCASLimit);
; 2677 : 
; 2678 : 			//fprintf(stderr," [%8d] [%8d] [%8d] [%8d] [%8d] [%2d]\n",(int)now,(int)this_r_last_cas_time,(int)this_r_last_casw_time,(int)other_r_last_cas_time,(int)other_r_last_casw_time,min_gap);
; 2679 : 		}
; 2680 : 		break;
; 2681 : 
; 2682 : 	case Command::WRITE_AND_PRECHARGE:
; 2683 : 		// Auto precharge will be issued as part of command, so
; 2684 : 		// Since commodity DRAM devices are write-cycle limited, we don't have to worry if
; 2685 : 		// the precharge will meet tRAS timing or not. So WRITE_AND_PRECHARGE
; 2686 : 		// has the exact same timing requirements as a simple WRITE.
; 2687 : 
; 2688 : 	case Command::WRITE:
; 2689 : 		{
; 2690 : 			//respect last RAS of same rank
; 2691 : 			tick tRASLimit = currentBank->getLastRASTime() + timingSpecification.tRCD() - timingSpecification.tAL();
; 2692 : 
; 2693 : 			// DW 3/9/2006 add these two lines
; 2694 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2695 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2696 : 
; 2697 : 			// respect last cas to same rank
; 2698 : 			// DW 3/9/2006 replace the line after next with the next line
; 2699 : 			// t_cas_gap = max(0,(int)(this_r.last_cas_time + timing_specification.t_cas + cas_length + timing_specification.t_rtrs - timing_specification.t_cwd - now));
; 2700 : 			tick tCASLimit = currentRank->getLastCASTime() + timingSpecification.tCAS() + timingSpecification.tBurst() + timingSpecification.tRTRS() - timingSpecification.tCWD();
; 2701 : 
; 2702 : 			// respect last cas to different ranks
; 2703 : 			tCASLimit = max(tCASLimit,currentRank->getOtherLastCASTime() + timingSpecification.tCAS() + currentRank->getOtherLastCASLength() + timingSpecification.tRTRS() - timingSpecification.tCWD());
; 2704 : 
; 2705 : 			// respect last cas write to same rank
; 2706 : 			// DW 3/9/2006 replace the line after next with the next line			
; 2707 : 			// t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + casw_length - now));
; 2708 : 			tCASLimit = max(tCASLimit,currentRank->getLastCASWTime() + currentRank->getLastCASWLength());
; 2709 : 
; 2710 : 			// respect last CASW to different ranks
; 2711 : 			// TODO: should this not also be -tAL?
; 2712 : 			tCASLimit = max(tCASLimit,currentRank->getOtherLastCASWTime() + currentRank->getOtherLastCASWLength() + timingSpecification.tOST());
; 2713 : 
; 2714 : 			nextTime = max(tRASLimit,tCASLimit);
; 2715 : 		}
; 2716 : 		break;
; 2717 : 
; 2718 : 	case Command::PRECHARGE:
; 2719 : 		{
; 2720 : 			// respect t_ras of same bank
; 2721 : 			tick tRASLimit = currentBank->getLastRASTime() + timingSpecification.tRAS();
; 2722 : 
; 2723 : 			// respect t_cas of same bank
; 2724 : 			//tick tCASLimit = max(time,currentBank->getLastCASTime() + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD()));
; 2725 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 2726 : 			tick tCASLimit = currentBank->getLastCASTime() + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD());
; 2727 : 
; 2728 : 			// respect t_casw of same bank
; 2729 : 			//tCASLimit = max(tCASLimit,currentBank->getLastCASWTime() + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2730 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 2731 : 			tCASLimit = max(tCASLimit,currentBank->getLastCASWTime() + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2732 : 
; 2733 : 			nextTime = max(tRASLimit,tCASLimit);
; 2734 : 		}
; 2735 : 		break;
; 2736 : 
; 2737 : 	case Command::REFRESH_ALL:
; 2738 : 		// respect tRFC and tRP
; 2739 : 		nextTime = max(currentRank->getLastRefreshTime() + timingSpecification.tRFC(), currentRank->getLastPrechargeTime() + timingSpecification.tRP());
; 2740 : 		break;
; 2741 : 
; 2742 : 	case Command::RETIRE_COMMAND:
; 2743 : 	case Command::PRECHARGE_ALL:
; 2744 : 	case Command::ACTIVATE_ALL:
; 2745 : 	case Command::DRIVE_COMMAND:
; 2746 : 	case Command::DATA_COMMAND:
; 2747 : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 2748 : 	case Command::SELF_REFRESH:
; 2749 : 	case Command::DESELECT:
; 2750 : 	case Command::NOOP:
; 2751 : 	case Command::INVALID_COMMAND:
; 2752 : 	default:
; 2753 : 		cerr << "Unsupported command encountered." << endl;
; 2754 : 		nextTime = 0;
; 2755 : 		break;
; 2756 : 	}
; 2757 : 
; 2758 : 	//return max(nextTime, time + timingSpecification.tCMD());
; 2759 : 	//return max(nextTime, max(time, lastCommandIssueTime + timingSpecification.tCMD()));
; 2760 : 	tick actualNext = max(nextTime, lastCommandIssueTime + timingSpecification.tCMD());
; 2761 : 	tick predictedNext = max(currentRank->next(currentCommand->getCommandType()), 
; 2762 : 		max(currentBank->next(currentCommand->getCommandType()), lastCommandIssueTime + timingSpecification.tCMD()));
; 2763 : 	if (actualNext != predictedNext )
; 2764 : 		assert(actualNext == predictedNext);
; 2765 : #endif
; 2766 : 
; 2767 : 	return max(currentRank->next(currentCommand->getCommandType()), 
; 2768 : 		max(currentBank->next(currentCommand->getCommandType()), lastCommandIssueTime + timingSpecification.tCMD()));

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN150@earliestEx
$LN207@earliestEx:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN166@earliestEx
$LN7@earliestEx:
	mov	eax, DWORD PTR _currentCommand$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	eax, DWORD PTR __Tmp$396216[esp+48]
	mov	DWORD PTR $T396444[esp+48], ecx
	test	eax, eax
	jne	SHORT $LN206@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN182@earliestEx:
	mov	edx, DWORD PTR tv904[esp+48]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN173@earliestEx
	call	__invalid_parameter_noinfo
$LN173@earliestEx:
	mov	eax, DWORD PTR [ebx+44]
	cdq
	mov	edi, eax
	add	edi, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR $T396444[esp+48]
	mov	esi, edx
	adc	esi, DWORD PTR [ebx+20]
	mov	ebx, DWORD PTR tv904[esp+48]
	mov	ecx, ebx
	call	?next@Bank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ; DRAMsimII::Bank::next
	cmp	edx, esi
	jl	SHORT $LN5@earliestEx
	jg	SHORT $LN216@earliestEx
	cmp	eax, edi
	jbe	SHORT $LN5@earliestEx
$LN216@earliestEx:
	mov	eax, DWORD PTR _currentCommand$[ebp]
	mov	esi, DWORD PTR [eax+80]
	mov	eax, DWORD PTR __Tmp$396216[esp+48]
	test	eax, eax
	jne	SHORT $LN205@earliestEx
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN200@earliestEx:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN191@earliestEx
	call	__invalid_parameter_noinfo
$LN191@earliestEx:
	mov	eax, esi
	mov	ecx, ebx
	call	?next@Bank@DRAMsimII@@QBE_JW4CommandType@Command@2@@Z ; DRAMsimII::Bank::next

; 2769 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN206@earliestEx:

; 2612 : 
; 2613 : #ifndef NDEBUG
; 2614 : 	switch(currentCommand->getCommandType())
; 2615 : 	{
; 2616 : 	case Command::ACTIVATE:
; 2617 : 		{
; 2618 : 			// refer to Table 11.4 in Memory Systems: Cache, DRAM, Disk
; 2619 : 
; 2620 : 			// respect the row cycle time limitation
; 2621 : 			tick tRCLimit = currentBank->getLastRASTime() + timingSpecification.tRC();
; 2622 : 
; 2623 : 			// respect the row-to-row activation delay for different banks within a rank
; 2624 : 			tick tRRDLimit = currentRank->lastActivateTimes.front() + timingSpecification.tRRD();				
; 2625 : 
; 2626 : 			// respect tRP of same bank
; 2627 : 			tick tRPLimit = currentBank->getLastPrechargeTime() + timingSpecification.tRP();
; 2628 : 
; 2629 : 			// respect the t_faw value for DDR2 and beyond, look at the fourth activate ago
; 2630 : 			tick tFAWLimit = currentRank->lastActivateTimes.back() + timingSpecification.tFAW();
; 2631 : 
; 2632 : 			// respect tRFC, refresh cycle time
; 2633 : 			tick tRFCLimit = currentRank->getLastRefreshTime() + timingSpecification.tRFC();
; 2634 : 
; 2635 : 			nextTime = max(max(max(tRFCLimit,tRCLimit) , tRPLimit) , max(tRRDLimit , tFAWLimit));
; 2636 : 
; 2637 : 			assert(nextTime >= currentBank->getLastPrechargeTime() + timingSpecification.tRP());
; 2638 : 			//DEBUG_TIMING_LOG(currentCommand->getCommandType() << " ras[" << setw(2) << t_ras_gap << "] rrd[" << setw(2) << t_rrd_gap << "] faw[" << setw(2) << t_faw_gap << "] cas[" << setw(2) << t_cas_gap << "] rrd[" << setw(2) << t_rrd_gap << "] rp[" << setw(2) << t_rp_gap << "] min[" << setw(2) << min_gap << "]");
; 2639 : 		}
; 2640 : 		break;
; 2641 : 
; 2642 : 	case Command::READ_AND_PRECHARGE:
; 2643 : 		// Auto precharge will be issued as part of command,
; 2644 : 		// but DRAM devices are intelligent enough to delay the prec command
; 2645 : 		// until tRAS timing is met (thanks to tAL), so no need to check tRAS timing requirement here.
; 2646 : 
; 2647 : 	case Command::READ:
; 2648 : 		{
; 2649 : 			//respect last RAS of same rank
; 2650 : 			tick tRCDLimit = currentBank->getLastRASTime() + (timingSpecification.tRCD() - timingSpecification.tAL());
; 2651 : 
; 2652 : 			// ensure that if no other rank has issued a CAS command that it will treat
; 2653 : 			// this as if a CAS command was issued long ago
; 2654 : 
; 2655 : 			// respect last CAS of same rank
; 2656 : 			// DW 3/9/2006 add these two lines
; 2657 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2658 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2659 : 			// DW 3/9/2006 replace the line after next with the next line
; 2660 : 			//t_cas_gap = max(0,(int)(this_r.last_cas_time + cas_length - now));
; 2661 : 			tick tCASLimit = currentRank->getLastCASTime() + timingSpecification.tBurst();
; 2662 : 
; 2663 : 			// respect last CASW of same rank
; 2664 : 			// DW 3/9/2006 replace the line after next with the next line
; 2665 : 			//t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + timing_specification.t_cwd + casw_length + timing_specification.t_wtr - now));
; 2666 : 			tCASLimit = max(tCASLimit,currentRank->getLastCASWTime() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWTR());
; 2667 : 
; 2668 : 			//if (rank->size() > 1)
; 2669 : 			{
; 2670 : 				//respect most recent CAS of different rank
; 2671 : 				tCASLimit = max(tCASLimit, currentRank->getOtherLastCASTime() + currentRank->getOtherLastCASLength() + timingSpecification.tRTRS());
; 2672 : 				//respect timing of READ follow WRITE, different ranks
; 2673 : 				tCASLimit = max(tCASLimit, currentRank->getOtherLastCASWTime() + timingSpecification.tCWD() + currentRank->getOtherLastCASWLength() + timingSpecification.tRTRS() - timingSpecification.tCAS());
; 2674 : 			}
; 2675 : 
; 2676 : 			nextTime = max(tRCDLimit,tCASLimit);
; 2677 : 
; 2678 : 			//fprintf(stderr," [%8d] [%8d] [%8d] [%8d] [%8d] [%2d]\n",(int)now,(int)this_r_last_cas_time,(int)this_r_last_casw_time,(int)other_r_last_cas_time,(int)other_r_last_casw_time,min_gap);
; 2679 : 		}
; 2680 : 		break;
; 2681 : 
; 2682 : 	case Command::WRITE_AND_PRECHARGE:
; 2683 : 		// Auto precharge will be issued as part of command, so
; 2684 : 		// Since commodity DRAM devices are write-cycle limited, we don't have to worry if
; 2685 : 		// the precharge will meet tRAS timing or not. So WRITE_AND_PRECHARGE
; 2686 : 		// has the exact same timing requirements as a simple WRITE.
; 2687 : 
; 2688 : 	case Command::WRITE:
; 2689 : 		{
; 2690 : 			//respect last RAS of same rank
; 2691 : 			tick tRASLimit = currentBank->getLastRASTime() + timingSpecification.tRCD() - timingSpecification.tAL();
; 2692 : 
; 2693 : 			// DW 3/9/2006 add these two lines
; 2694 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2695 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2696 : 
; 2697 : 			// respect last cas to same rank
; 2698 : 			// DW 3/9/2006 replace the line after next with the next line
; 2699 : 			// t_cas_gap = max(0,(int)(this_r.last_cas_time + timing_specification.t_cas + cas_length + timing_specification.t_rtrs - timing_specification.t_cwd - now));
; 2700 : 			tick tCASLimit = currentRank->getLastCASTime() + timingSpecification.tCAS() + timingSpecification.tBurst() + timingSpecification.tRTRS() - timingSpecification.tCWD();
; 2701 : 
; 2702 : 			// respect last cas to different ranks
; 2703 : 			tCASLimit = max(tCASLimit,currentRank->getOtherLastCASTime() + timingSpecification.tCAS() + currentRank->getOtherLastCASLength() + timingSpecification.tRTRS() - timingSpecification.tCWD());
; 2704 : 
; 2705 : 			// respect last cas write to same rank
; 2706 : 			// DW 3/9/2006 replace the line after next with the next line			
; 2707 : 			// t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + casw_length - now));
; 2708 : 			tCASLimit = max(tCASLimit,currentRank->getLastCASWTime() + currentRank->getLastCASWLength());
; 2709 : 
; 2710 : 			// respect last CASW to different ranks
; 2711 : 			// TODO: should this not also be -tAL?
; 2712 : 			tCASLimit = max(tCASLimit,currentRank->getOtherLastCASWTime() + currentRank->getOtherLastCASWLength() + timingSpecification.tOST());
; 2713 : 
; 2714 : 			nextTime = max(tRASLimit,tCASLimit);
; 2715 : 		}
; 2716 : 		break;
; 2717 : 
; 2718 : 	case Command::PRECHARGE:
; 2719 : 		{
; 2720 : 			// respect t_ras of same bank
; 2721 : 			tick tRASLimit = currentBank->getLastRASTime() + timingSpecification.tRAS();
; 2722 : 
; 2723 : 			// respect t_cas of same bank
; 2724 : 			//tick tCASLimit = max(time,currentBank->getLastCASTime() + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD()));
; 2725 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 2726 : 			tick tCASLimit = currentBank->getLastCASTime() + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD());
; 2727 : 
; 2728 : 			// respect t_casw of same bank
; 2729 : 			//tCASLimit = max(tCASLimit,currentBank->getLastCASWTime() + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2730 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 2731 : 			tCASLimit = max(tCASLimit,currentBank->getLastCASWTime() + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2732 : 
; 2733 : 			nextTime = max(tRASLimit,tCASLimit);
; 2734 : 		}
; 2735 : 		break;
; 2736 : 
; 2737 : 	case Command::REFRESH_ALL:
; 2738 : 		// respect tRFC and tRP
; 2739 : 		nextTime = max(currentRank->getLastRefreshTime() + timingSpecification.tRFC(), currentRank->getLastPrechargeTime() + timingSpecification.tRP());
; 2740 : 		break;
; 2741 : 
; 2742 : 	case Command::RETIRE_COMMAND:
; 2743 : 	case Command::PRECHARGE_ALL:
; 2744 : 	case Command::ACTIVATE_ALL:
; 2745 : 	case Command::DRIVE_COMMAND:
; 2746 : 	case Command::DATA_COMMAND:
; 2747 : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 2748 : 	case Command::SELF_REFRESH:
; 2749 : 	case Command::DESELECT:
; 2750 : 	case Command::NOOP:
; 2751 : 	case Command::INVALID_COMMAND:
; 2752 : 	default:
; 2753 : 		cerr << "Unsupported command encountered." << endl;
; 2754 : 		nextTime = 0;
; 2755 : 		break;
; 2756 : 	}
; 2757 : 
; 2758 : 	//return max(nextTime, time + timingSpecification.tCMD());
; 2759 : 	//return max(nextTime, max(time, lastCommandIssueTime + timingSpecification.tCMD()));
; 2760 : 	tick actualNext = max(nextTime, lastCommandIssueTime + timingSpecification.tCMD());
; 2761 : 	tick predictedNext = max(currentRank->next(currentCommand->getCommandType()), 
; 2762 : 		max(currentBank->next(currentCommand->getCommandType()), lastCommandIssueTime + timingSpecification.tCMD()));
; 2763 : 	if (actualNext != predictedNext )
; 2764 : 		assert(actualNext == predictedNext);
; 2765 : #endif
; 2766 : 
; 2767 : 	return max(currentRank->next(currentCommand->getCommandType()), 
; 2768 : 		max(currentBank->next(currentCommand->getCommandType()), lastCommandIssueTime + timingSpecification.tCMD()));

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN182@earliestEx
$LN205@earliestEx:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN200@earliestEx
$LN5@earliestEx:
	mov	eax, edi

; 2769 : }

	pop	edi
	mov	edx, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?earliestExecuteTime@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z ENDP ; DRAMsimII::Channel::earliestExecuteTime
; Function compile flags: /Ogtpy
tv1964 = -80						; size = 4
_t_cas_gap$220158 = -80					; size = 8
_otherRankLastCASLength$220120 = -80			; size = 4
tv1664 = -72						; size = 8
tv466 = -72						; size = 4
tv418 = -72						; size = 4
_currentRank$ = -72					; size = 4
tv387 = -60						; size = 4
_otherRankLastCASLength$220148 = -60			; size = 4
_otherRankLastCASWLength$220122 = -60			; size = 4
tv478 = -56						; size = 4
_otherRankLastCASWLength$220150 = -56			; size = 4
_tRRDGap$220104 = -56					; size = 8
tv1152 = -48						; size = 4
tv531 = -48						; size = 8
tv421 = -48						; size = 4
tv389 = -48						; size = 4
_t_ras_gap$220172 = -48					; size = 8
_tRCDGap$220118 = -48					; size = 4
_tRPGap$220106 = -48					; size = 8
_currentRankID$ = -48					; size = 4
tv1555 = -40						; size = 8
tv1529 = -40						; size = 8
tv924 = -40						; size = 8
tv605 = -40						; size = 4
_t_ras_gap$220146 = -40					; size = 4
_thisRank$220127 = -40					; size = 8
_tRCGap$220102 = -40					; size = 8
_min_gap$ = -32						; size = 8
tv1738 = -24						; size = 8
_otherRankLastCASTime$220147 = -24			; size = 8
_otherRankLastCASTime$220119 = -24			; size = 8
_tFAWGap$220108 = -24					; size = 8
tv1710 = -16						; size = 8
tv175 = -16						; size = 8
_otherRankLastCASWTime$220149 = -16			; size = 8
_otherRankLastCASWTime$220121 = -16			; size = 8
tv1714 = -8						; size = 8
tv1656 = -8						; size = 8
tv1520 = -8						; size = 8
tv177 = -8						; size = 8
tv171 = -8						; size = 8
_currentCommand$ = 8					; size = 4
?minProtocolGap@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z PROC ; DRAMsimII::Channel::minProtocolGap
; _this$ = ecx

; 2396 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 84					; 00000054H

; 2397 : 	tick min_gap = 0;

	xor	eax, eax
	push	ebx
	mov	ebx, ecx

; 2398 : 
; 2399 : 	const unsigned currentRankID = currentCommand->getAddress().getRank();
; 2400 : 
; 2401 : 	const Rank &currentRank = rank[currentRankID];

	mov	ecx, DWORD PTR [ebx+384]
	sub	ecx, DWORD PTR [ebx+380]
	mov	DWORD PTR _min_gap$[esp+88], eax
	mov	DWORD PTR _min_gap$[esp+92], eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	push	esi
	mov	eax, edx
	push	edi
	mov	edi, DWORD PTR _currentCommand$[ebp]
	mov	esi, DWORD PTR [edi+60]
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _currentRankID$[esp+96], esi
	cmp	esi, eax
	jb	SHORT $LN79@minProtoco@2
	call	__invalid_parameter_noinfo
$LN79@minProtoco@2:
	imul	esi, 200				; 000000c8H
	add	esi, DWORD PTR [ebx+380]

; 2402 : 
; 2403 : 	const Bank &currentBank = currentRank.bank[currentCommand->getAddress().getBank()];

	mov	edi, DWORD PTR [edi+64]
	mov	ecx, DWORD PTR [esi+188]
	sub	ecx, DWORD PTR [esi+184]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR _currentRank$[esp+96], esi
	cmp	edi, ecx
	jb	SHORT $LN88@minProtoco@2
	call	__invalid_parameter_noinfo
$LN88@minProtoco@2:

; 2404 : 
; 2405 : 	switch(currentCommand->getCommandType())

	mov	edx, DWORD PTR _currentCommand$[ebp]
	imul	edi, 152				; 00000098H
	mov	eax, DWORD PTR [edx+80]
	add	edi, DWORD PTR [esi+184]
	cmp	eax, 12					; 0000000cH
	ja	$LN1@minProtoco@2
	movzx	eax, BYTE PTR $LN410@minProtoco@2[eax]
	jmp	DWORD PTR $LN456@minProtoco@2[eax*4]
$LN26@minProtoco@2:

; 2406 : 	{
; 2407 : 	case Command::ACTIVATE:
; 2408 : 		{
; 2409 : 			// refer to Table 11.4 in Memory Systems: Cache, DRAM, Disk
; 2410 : 
; 2411 : 			// respect the row cycle time limitation
; 2412 : 			tick tRCGap = (tick)(currentBank.getLastRASTime() - time) + timingSpecification.tRC();

	mov	eax, DWORD PTR [ebx+60]
	mov	ecx, DWORD PTR [ebx+8]
	cdq
	add	eax, DWORD PTR [edi+48]
	adc	edx, DWORD PTR [edi+52]
	sub	eax, ecx
	sbb	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR _tRCGap$220102[esp+96], eax

; 2413 : 
; 2414 : 			// respect tRRD and tRC of all other banks of same rank
; 2415 : 			tick tRRDGap = (tick)(currentRank.lastActivateTimes.front() - time) + timingSpecification.tRRD();

	mov	eax, DWORD PTR [ebx+76]
	mov	DWORD PTR _tRCGap$220102[esp+100], edx
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+156]
	add	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	adc	eax, edx
	sub	ecx, DWORD PTR [ebx+8]
	sbb	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR _tRRDGap$220104[esp+100], eax

; 2416 : 
; 2417 : 			// respect tRP of same bank
; 2418 : 			tick tRPGap = (tick)(currentBank.getLastPrechargeTime() - time) + timingSpecification.tRP();

	mov	eax, DWORD PTR [ebx+72]
	cdq
	add	eax, DWORD PTR [edi+72]
	adc	edx, DWORD PTR [edi+76]
	sub	eax, DWORD PTR [ebx+8]
	sbb	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR _tRPGap$220106[esp+96], eax

; 2419 : 
; 2420 : 			// respect the t_faw value for DDR2 and beyond
; 2421 : 			tick tFAWGap = (tick)(currentRank.lastActivateTimes.back() - time) + timingSpecification.tFAW();

	mov	eax, DWORD PTR [esi+160]
	mov	DWORD PTR _tRPGap$220106[esp+100], edx
	cmp	eax, DWORD PTR [esi+148]
	jne	SHORT $LN109@minProtoco@2
	mov	edi, DWORD PTR [esi+152]
	jmp	SHORT $LN110@minProtoco@2
$LN109@minProtoco@2:
	mov	edi, eax
$LN110@minProtoco@2:
	mov	eax, DWORD PTR [ebx+52]
	cdq
	add	eax, DWORD PTR [edi-8]
	adc	edx, DWORD PTR [edi-4]
	mov	edi, DWORD PTR [ebx+8]
	sub	eax, edi
	sbb	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR _tFAWGap$220108[esp+96], eax

; 2422 : 
; 2423 : 			// respect tRFC
; 2424 : 			tick tRFCGap = (tick)(currentRank.getLastRefreshTime() - time) + timingSpecification.tRFC();

	mov	eax, DWORD PTR [ebx+68]
	mov	DWORD PTR _tFAWGap$220108[esp+100], edx
	cdq
	add	eax, DWORD PTR [esi+8]
	adc	edx, DWORD PTR [esi+12]

; 2425 : 
; 2426 : 			min_gap = max(max(max(tRFCGap,tRCGap) , tRPGap) , max(tRRDGap , tFAWGap));

	mov	esi, DWORD PTR _tRCGap$220102[esp+100]
	sub	eax, edi
	sbb	edx, DWORD PTR [ebx+12]
	cmp	edx, esi
	jl	SHORT $LN31@minProtoco@2
	jg	SHORT $LN411@minProtoco@2
	cmp	eax, DWORD PTR _tRCGap$220102[esp+96]
	jbe	SHORT $LN31@minProtoco@2
$LN411@minProtoco@2:
	mov	DWORD PTR tv171[esp+96], eax
	mov	esi, edx
	jmp	SHORT $LN32@minProtoco@2
$LN31@minProtoco@2:
	mov	edi, DWORD PTR _tRCGap$220102[esp+96]
	mov	DWORD PTR tv171[esp+96], edi
$LN32@minProtoco@2:
	cmp	esi, DWORD PTR _tRPGap$220106[esp+100]
	jl	SHORT $LN35@minProtoco@2
	jg	SHORT $LN412@minProtoco@2
	mov	esi, DWORD PTR tv171[esp+96]
	cmp	esi, DWORD PTR _tRPGap$220106[esp+96]
	jbe	SHORT $LN35@minProtoco@2
$LN412@minProtoco@2:
	mov	esi, DWORD PTR _tRCGap$220102[esp+100]
	cmp	edx, esi
	jl	SHORT $LN33@minProtoco@2
	jg	SHORT $LN413@minProtoco@2
	cmp	eax, DWORD PTR _tRCGap$220102[esp+96]
	jbe	SHORT $LN33@minProtoco@2
$LN413@minProtoco@2:
	mov	DWORD PTR tv175[esp+96], eax
	mov	DWORD PTR tv175[esp+100], edx
	jmp	SHORT $LN36@minProtoco@2
$LN33@minProtoco@2:
	mov	edi, DWORD PTR _tRCGap$220102[esp+96]
	mov	DWORD PTR tv175[esp+96], edi
	jmp	SHORT $LN454@minProtoco@2
$LN35@minProtoco@2:
	mov	esi, DWORD PTR _tRPGap$220106[esp+96]
	mov	DWORD PTR tv175[esp+96], esi
	mov	esi, DWORD PTR _tRPGap$220106[esp+100]
$LN454@minProtoco@2:
	mov	DWORD PTR tv175[esp+100], esi
$LN36@minProtoco@2:
	mov	esi, DWORD PTR _tRRDGap$220104[esp+100]
	mov	edi, DWORD PTR _tFAWGap$220108[esp+100]
	cmp	esi, edi
	jl	SHORT $LN37@minProtoco@2
	jg	SHORT $LN414@minProtoco@2
	cmp	ecx, DWORD PTR _tFAWGap$220108[esp+96]
	jbe	SHORT $LN37@minProtoco@2
$LN414@minProtoco@2:
	mov	DWORD PTR tv177[esp+96], ecx
	jmp	SHORT $LN38@minProtoco@2
$LN37@minProtoco@2:
	mov	esi, DWORD PTR _tFAWGap$220108[esp+96]
	mov	DWORD PTR tv177[esp+96], esi
	mov	esi, edi
$LN38@minProtoco@2:
	cmp	DWORD PTR tv175[esp+100], esi
	jl	SHORT $LN47@minProtoco@2
	jg	SHORT $LN415@minProtoco@2
	mov	esi, DWORD PTR tv177[esp+96]
	cmp	DWORD PTR tv175[esp+96], esi
	jbe	SHORT $LN47@minProtoco@2
$LN415@minProtoco@2:
	mov	ecx, DWORD PTR _tRCGap$220102[esp+100]
	cmp	edx, ecx
	mov	edi, DWORD PTR _tRCGap$220102[esp+96]
	jl	SHORT $LN39@minProtoco@2
	jg	SHORT $LN416@minProtoco@2
	cmp	eax, edi
	jbe	SHORT $LN39@minProtoco@2
$LN416@minProtoco@2:
	mov	esi, eax
	mov	ecx, edx
	jmp	SHORT $LN40@minProtoco@2
$LN39@minProtoco@2:
	mov	esi, edi
$LN40@minProtoco@2:
	cmp	ecx, DWORD PTR _tRPGap$220106[esp+100]
	jl	SHORT $LN43@minProtoco@2
	jg	SHORT $LN417@minProtoco@2
	cmp	esi, DWORD PTR _tRPGap$220106[esp+96]
	jbe	SHORT $LN43@minProtoco@2
$LN417@minProtoco@2:
	mov	ecx, DWORD PTR _tRCGap$220102[esp+100]
	cmp	edx, ecx
	jl	SHORT $LN41@minProtoco@2
	jg	SHORT $LN418@minProtoco@2
	cmp	eax, edi
	jbe	SHORT $LN41@minProtoco@2
$LN418@minProtoco@2:
	mov	DWORD PTR _min_gap$[esp+100], edx
	jmp	$LN455@minProtoco@2
$LN41@minProtoco@2:
	mov	DWORD PTR _min_gap$[esp+96], edi
	mov	DWORD PTR _min_gap$[esp+100], ecx
	jmp	$LN1@minProtoco@2
$LN43@minProtoco@2:
	mov	ecx, DWORD PTR _tRPGap$220106[esp+96]
	mov	edx, DWORD PTR _tRPGap$220106[esp+100]
	mov	DWORD PTR _min_gap$[esp+96], ecx
	mov	DWORD PTR _min_gap$[esp+100], edx
	jmp	$LN1@minProtoco@2
$LN47@minProtoco@2:
	mov	eax, DWORD PTR _tRRDGap$220104[esp+100]
	mov	edx, DWORD PTR _tFAWGap$220108[esp+100]
	cmp	eax, edx
	jl	SHORT $LN45@minProtoco@2
	jg	SHORT $LN419@minProtoco@2
	cmp	ecx, DWORD PTR _tFAWGap$220108[esp+96]
	jbe	SHORT $LN45@minProtoco@2
$LN419@minProtoco@2:
	mov	DWORD PTR _min_gap$[esp+96], ecx
	mov	DWORD PTR _min_gap$[esp+100], eax
	jmp	$LN1@minProtoco@2
$LN45@minProtoco@2:
	mov	eax, DWORD PTR _tFAWGap$220108[esp+96]
	mov	DWORD PTR _min_gap$[esp+100], edx

; 2427 : 		}
; 2428 : 		break;

	jmp	$LN455@minProtoco@2
$LN25@minProtoco@2:

; 2429 : 
; 2430 : 	case Command::READ_AND_PRECHARGE:
; 2431 : 		// Auto precharge will be issued as part of command,
; 2432 : 		// but DRAM devices are intelligent enough to delay the prec command
; 2433 : 		// until tRAS timing is met (thanks to tAL), so no need to check tRAS timing requirement here.
; 2434 : 
; 2435 : 	case Command::READ:
; 2436 : 		{
; 2437 : 			//respect last ras of same rank
; 2438 : 			int tRCDGap = ((currentBank.getLastRASTime() - time) + timingSpecification.tRCD() - timingSpecification.tAL());

	mov	edi, DWORD PTR [edi+48]
	sub	edi, DWORD PTR [ebx+28]

; 2439 : 
; 2440 : 			// ensure that if no other rank has issued a CAS command that it will treat
; 2441 : 			// this as if a CAS command was issued long ago
; 2442 : 			tick otherRankLastCASTime = time - 10000000;

	mov	eax, DWORD PTR [ebx+8]
	add	edi, DWORD PTR [ebx+64]
	mov	ecx, DWORD PTR [ebx+12]
	sub	edi, DWORD PTR [ebx+8]

; 2443 : 			int otherRankLastCASLength = timingSpecification.tBurst();

	mov	edx, DWORD PTR [ebx+32]
	sub	eax, 10000000				; 00989680H
	mov	DWORD PTR _tRCDGap$220118[esp+96], edi

; 2444 : 			tick otherRankLastCASWTime = time - 10000000;
; 2445 : 			int otherRankLastCASWLength = timingSpecification.tBurst();
; 2446 : 
; 2447 : 			// find the most recent cas(w) time and length
; 2448 : 			for (vector<Rank>::const_iterator thisRank = rank.begin(); thisRank != rank.end(); thisRank++)

	mov	edi, DWORD PTR [ebx+380]
	sbb	ecx, 0
	mov	DWORD PTR _otherRankLastCASTime$220119[esp+96], eax
	mov	DWORD PTR _otherRankLastCASTime$220119[esp+100], ecx
	mov	DWORD PTR _otherRankLastCASLength$220120[esp+96], edx
	mov	DWORD PTR _otherRankLastCASWTime$220121[esp+96], eax
	mov	DWORD PTR _otherRankLastCASWTime$220121[esp+100], ecx
	mov	DWORD PTR _otherRankLastCASWLength$220122[esp+96], edx
	cmp	edi, DWORD PTR [ebx+384]
	jbe	SHORT $LN130@minProtoco@2
	call	__invalid_parameter_noinfo
$LN130@minProtoco@2:
	mov	ecx, DWORD PTR [ebx+368]
	mov	DWORD PTR _thisRank$220127[esp+96], ecx
	mov	DWORD PTR _thisRank$220127[esp+100], edi
	npad	1
$LL145@minProtoco@2:
	mov	edi, DWORD PTR [ebx+384]
	cmp	DWORD PTR [ebx+380], edi
	jbe	SHORT $LN158@minProtoco@2
	call	__invalid_parameter_noinfo
$LN158@minProtoco@2:
	mov	ecx, DWORD PTR _thisRank$220127[esp+96]
	mov	eax, DWORD PTR [ebx+368]
	test	ecx, ecx
	je	SHORT $LN171@minProtoco@2
	cmp	ecx, eax
	je	SHORT $LN172@minProtoco@2
$LN171@minProtoco@2:
	call	__invalid_parameter_noinfo
$LN172@minProtoco@2:
	cmp	DWORD PTR _thisRank$220127[esp+100], edi
	je	$LN22@minProtoco@2

; 2449 : 			{
; 2450 : 				if (thisRank->getRankID() != currentRank.getRankID())

	mov	eax, DWORD PTR _thisRank$220127[esp+96]
	test	eax, eax
	jne	$LN409@minProtoco@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN190@minProtoco@2:
	mov	edx, DWORD PTR _thisRank$220127[esp+100]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN181@minProtoco@2
	call	__invalid_parameter_noinfo
$LN181@minProtoco@2:
	mov	eax, DWORD PTR _thisRank$220127[esp+100]
	mov	ecx, DWORD PTR [eax+136]
	cmp	ecx, DWORD PTR [esi+136]
	je	$LN23@minProtoco@2

; 2451 : 				{
; 2452 : 					if (thisRank->getLastCASTime() > otherRankLastCASTime)

	mov	eax, DWORD PTR _thisRank$220127[esp+96]
	test	eax, eax
	jne	$LN408@minProtoco@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN208@minProtoco@2:
	mov	edx, DWORD PTR _thisRank$220127[esp+100]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN199@minProtoco@2
	call	__invalid_parameter_noinfo
$LN199@minProtoco@2:
	mov	eax, DWORD PTR _thisRank$220127[esp+100]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _otherRankLastCASTime$220119[esp+100]
	jl	SHORT $LN20@minProtoco@2
	jg	SHORT $LN420@minProtoco@2
	mov	edx, DWORD PTR [eax+24]
	cmp	edx, DWORD PTR _otherRankLastCASTime$220119[esp+96]
	jbe	SHORT $LN20@minProtoco@2
$LN420@minProtoco@2:

; 2453 : 					{
; 2454 : 						otherRankLastCASTime = thisRank->getLastCASTime();

	lea	esi, DWORD PTR _thisRank$220127[esp+96]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [eax+28]
	mov	DWORD PTR _otherRankLastCASTime$220119[esp+96], ecx
	mov	DWORD PTR _otherRankLastCASTime$220119[esp+100], edx

; 2455 : 						otherRankLastCASLength = thisRank->getLastCASLength();

	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	eax, DWORD PTR [eax+112]
	mov	esi, DWORD PTR _currentRank$[esp+96]
	mov	DWORD PTR _otherRankLastCASLength$220120[esp+96], eax
$LN20@minProtoco@2:

; 2456 : 					}
; 2457 : 					if (thisRank->getLastCASWTime() > otherRankLastCASWTime)

	mov	eax, DWORD PTR _thisRank$220127[esp+96]
	test	eax, eax
	jne	$LN407@minProtoco@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN228@minProtoco@2:
	mov	ecx, DWORD PTR _thisRank$220127[esp+100]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN219@minProtoco@2
	call	__invalid_parameter_noinfo
$LN219@minProtoco@2:
	mov	eax, DWORD PTR _thisRank$220127[esp+100]
	mov	edx, DWORD PTR [eax+36]
	cmp	edx, DWORD PTR _otherRankLastCASWTime$220121[esp+100]
	jl	SHORT $LN23@minProtoco@2
	jg	SHORT $LN421@minProtoco@2
	mov	eax, DWORD PTR [eax+32]
	cmp	eax, DWORD PTR _otherRankLastCASWTime$220121[esp+96]
	jbe	SHORT $LN23@minProtoco@2
$LN421@minProtoco@2:

; 2458 : 					{
; 2459 : 						otherRankLastCASWTime = thisRank->getLastCASWTime();

	lea	esi, DWORD PTR _thisRank$220127[esp+96]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _otherRankLastCASWTime$220121[esp+96], ecx
	mov	DWORD PTR _otherRankLastCASWTime$220121[esp+100], edx

; 2460 : 						otherRankLastCASWLength = thisRank->getLastCASWLength();

	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	eax, DWORD PTR [eax+116]
	mov	esi, DWORD PTR _currentRank$[esp+96]
	mov	DWORD PTR _otherRankLastCASWLength$220122[esp+96], eax
$LN23@minProtoco@2:
	mov	eax, DWORD PTR _thisRank$220127[esp+96]
	test	eax, eax
	jne	SHORT $LN406@minProtoco@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN152@minProtoco@2:
	mov	ecx, DWORD PTR _thisRank$220127[esp+100]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN143@minProtoco@2

; 2444 : 			tick otherRankLastCASWTime = time - 10000000;
; 2445 : 			int otherRankLastCASWLength = timingSpecification.tBurst();
; 2446 : 
; 2447 : 			// find the most recent cas(w) time and length
; 2448 : 			for (vector<Rank>::const_iterator thisRank = rank.begin(); thisRank != rank.end(); thisRank++)

	call	__invalid_parameter_noinfo
$LN143@minProtoco@2:
	add	DWORD PTR _thisRank$220127[esp+100], 200 ; 000000c8H
	jmp	$LL145@minProtoco@2
$LN409@minProtoco@2:

; 2449 : 			{
; 2450 : 				if (thisRank->getRankID() != currentRank.getRankID())

	mov	eax, DWORD PTR [eax]
	jmp	$LN190@minProtoco@2
$LN408@minProtoco@2:

; 2451 : 				{
; 2452 : 					if (thisRank->getLastCASTime() > otherRankLastCASTime)

	mov	eax, DWORD PTR [eax]
	jmp	$LN208@minProtoco@2
$LN407@minProtoco@2:

; 2456 : 					}
; 2457 : 					if (thisRank->getLastCASWTime() > otherRankLastCASWTime)

	mov	eax, DWORD PTR [eax]
	jmp	$LN228@minProtoco@2
$LN406@minProtoco@2:

; 2444 : 			tick otherRankLastCASWTime = time - 10000000;
; 2445 : 			int otherRankLastCASWLength = timingSpecification.tBurst();
; 2446 : 
; 2447 : 			// find the most recent cas(w) time and length
; 2448 : 			for (vector<Rank>::const_iterator thisRank = rank.begin(); thisRank != rank.end(); thisRank++)

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN152@minProtoco@2
$LN22@minProtoco@2:

; 2461 : 					}
; 2462 : 				}
; 2463 : 			}			
; 2464 : 
; 2465 : 			//respect last cas of same rank
; 2466 : 			// DW 3/9/2006 add these two lines
; 2467 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2468 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2469 : 			// DW 3/9/2006 replace the line after next with the next line
; 2470 : 			//t_cas_gap = max(0,(int)(this_r.last_cas_time + cas_length - now));
; 2471 : 			int t_cas_gap = ((currentRank.getLastCASTime() - time) + timingSpecification.tBurst());

	mov	ecx, DWORD PTR [esi+24]
	sub	ecx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+32]

; 2472 : 
; 2473 : 			//respect last cas write of same rank
; 2474 : 			// DW 3/9/2006 replace the line after next with the next line
; 2475 : 			//t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + timing_specification.t_cwd + casw_length + timing_specification.t_wtr - now));
; 2476 : 			t_cas_gap = max((tick)t_cas_gap,((currentRank.getLastCASWTime() - time) + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWTR()));

	mov	edi, DWORD PTR [ebx+92]
	add	ecx, eax
	mov	eax, DWORD PTR [ebx+48]
	cdq
	mov	DWORD PTR tv1520[esp+96], eax
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR tv1529[esp+100], eax
	mov	DWORD PTR tv1520[esp+100], edx
	mov	edx, DWORD PTR [esi+32]
	mov	eax, edi
	mov	DWORD PTR tv1529[esp+96], edx
	cdq
	mov	edi, eax
	sub	edi, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+32]
	mov	esi, edx
	sbb	esi, DWORD PTR [ebx+12]
	cdq
	add	edi, eax
	adc	esi, edx
	add	edi, DWORD PTR tv1529[esp+96]
	mov	eax, ecx
	adc	esi, DWORD PTR tv1529[esp+100]
	add	edi, DWORD PTR tv1520[esp+96]
	cdq
	adc	esi, DWORD PTR tv1520[esp+100]
	cmp	edx, esi
	jg	SHORT $LN50@minProtoco@2
	jl	SHORT $LN422@minProtoco@2
	cmp	eax, edi
	ja	SHORT $LN50@minProtoco@2
$LN422@minProtoco@2:
	mov	ecx, DWORD PTR tv1529[esp+96]
	sub	ecx, DWORD PTR [ebx+8]
	add	ecx, DWORD PTR [ebx+48]
	add	ecx, DWORD PTR [ebx+92]
	add	ecx, DWORD PTR [ebx+32]
$LN50@minProtoco@2:

; 2477 : 
; 2478 : 			if (rank.size() > 1)

	mov	edx, DWORD PTR [ebx+384]
	sub	edx, DWORD PTR [ebx+380]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 1
	jbe	$LN54@minProtoco@2

; 2479 : 			{
; 2480 : 				//respect most recent cas of different rank
; 2481 : 				t_cas_gap = max((tick)t_cas_gap, (otherRankLastCASTime - time) + otherRankLastCASLength + timingSpecification.tRTRS());

	mov	eax, DWORD PTR [ebx+84]
	cdq
	mov	DWORD PTR tv1555[esp+96], eax
	mov	eax, DWORD PTR _otherRankLastCASLength$220120[esp+96]
	mov	DWORD PTR tv1555[esp+100], edx
	cdq
	mov	edi, eax
	sub	edi, DWORD PTR [ebx+8]
	mov	esi, edx
	sbb	esi, DWORD PTR [ebx+12]
	add	edi, DWORD PTR tv1555[esp+96]
	mov	eax, ecx
	adc	esi, DWORD PTR tv1555[esp+100]
	add	edi, DWORD PTR _otherRankLastCASTime$220119[esp+96]
	cdq
	adc	esi, DWORD PTR _otherRankLastCASTime$220119[esp+100]
	cmp	edx, esi
	jg	SHORT $LN52@minProtoco@2
	jl	SHORT $LN423@minProtoco@2
	cmp	eax, edi
	ja	SHORT $LN52@minProtoco@2
$LN423@minProtoco@2:
	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR _otherRankLastCASTime$220119[esp+96]
	sub	ecx, eax
	add	ecx, DWORD PTR [ebx+84]
	add	ecx, DWORD PTR _otherRankLastCASLength$220120[esp+96]
$LN52@minProtoco@2:

; 2482 : 				//respect timing of READ follow WRITE, different ranks
; 2483 : 				t_cas_gap = max((tick)t_cas_gap, (otherRankLastCASWTime - time) + timingSpecification.tCWD() + otherRankLastCASWLength + timingSpecification.tRTRS() - timingSpecification.tCAS());

	mov	eax, DWORD PTR [ebx+36]
	cdq
	mov	DWORD PTR tv478[esp+96], eax
	mov	eax, DWORD PTR _otherRankLastCASWLength$220122[esp+96]
	mov	DWORD PTR tv466[esp+96], edx
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR tv478[esp+96]
	sub	edi, eax
	mov	eax, DWORD PTR tv466[esp+96]
	mov	esi, edx
	sbb	esi, eax
	sub	edi, DWORD PTR [ebx+8]
	mov	eax, ecx
	sbb	esi, DWORD PTR [ebx+12]
	add	edi, DWORD PTR tv1555[esp+96]
	cdq
	adc	esi, DWORD PTR tv1555[esp+100]
	add	edi, DWORD PTR tv1520[esp+96]
	adc	esi, DWORD PTR tv1520[esp+100]
	add	edi, DWORD PTR _otherRankLastCASWTime$220121[esp+96]
	adc	esi, DWORD PTR _otherRankLastCASWTime$220121[esp+100]
	cmp	edx, esi
	jg	SHORT $LN54@minProtoco@2
	jl	SHORT $LN424@minProtoco@2
	cmp	eax, edi
	ja	SHORT $LN54@minProtoco@2
$LN424@minProtoco@2:
	mov	ecx, DWORD PTR _otherRankLastCASWTime$220121[esp+96]
	sub	ecx, DWORD PTR [ebx+36]
	sub	ecx, DWORD PTR [ebx+8]
	add	ecx, DWORD PTR [ebx+84]
	add	ecx, DWORD PTR [ebx+48]
	add	ecx, DWORD PTR _otherRankLastCASWLength$220122[esp+96]
$LN54@minProtoco@2:

; 2484 : 			}
; 2485 : 			min_gap = max(tRCDGap,t_cas_gap);

	mov	eax, DWORD PTR _tRCDGap$220118[esp+96]
	cmp	eax, ecx
	jg	SHORT $LN56@minProtoco@2
	mov	eax, ecx
$LN56@minProtoco@2:
	cdq
	mov	DWORD PTR _min_gap$[esp+100], edx

; 2486 : 
; 2487 : 			//fprintf(stderr," [%8d] [%8d] [%8d] [%8d] [%8d] [%2d]\n",(int)now,(int)this_r_last_cas_time,(int)this_r_last_casw_time,(int)other_r_last_cas_time,(int)other_r_last_casw_time,min_gap);
; 2488 : 		}
; 2489 : 		break;

	jmp	$LN455@minProtoco@2
$LN17@minProtoco@2:

; 2490 : 
; 2491 : 	case Command::WRITE_AND_PRECHARGE:
; 2492 : 		// Auto precharge will be issued as part of command, so
; 2493 : 		// Since commodity DRAM devices are write-cycle limited, we don't have to worry if
; 2494 : 		// the precharge will met tRAS timing or not. So WRITE_AND_PRECHARGE
; 2495 : 		// has the exact same timing requirements as a simple CAS COMMAND.
; 2496 : 
; 2497 : 	case Command::WRITE:
; 2498 : 		{
; 2499 : 			//respect last ras of same rank
; 2500 : 			int t_ras_gap = ((currentBank.getLastRASTime() - time) + timingSpecification.tRCD() - timingSpecification.tAL());

	mov	edi, DWORD PTR [edi+48]
	sub	edi, DWORD PTR [ebx+28]

; 2501 : 
; 2502 : 			tick otherRankLastCASTime = time - 10000000;

	mov	eax, DWORD PTR [ebx+8]
	add	edi, DWORD PTR [ebx+64]
	mov	ecx, DWORD PTR [ebx+12]
	sub	edi, DWORD PTR [ebx+8]

; 2503 : 			int otherRankLastCASLength = timingSpecification.tBurst();

	mov	edx, DWORD PTR [ebx+32]
	sub	eax, 10000000				; 00989680H
	mov	DWORD PTR _t_ras_gap$220146[esp+96], edi
	mov	edi, 0
	sbb	ecx, edi
	mov	DWORD PTR _otherRankLastCASTime$220147[esp+100], ecx

; 2504 : 			tick otherRankLastCASWTime = time - 10000000;

	mov	DWORD PTR _otherRankLastCASWTime$220149[esp+100], ecx

; 2505 : 			int otherRankLastCASWLength = timingSpecification.tBurst();
; 2506 : 
; 2507 : 			// find the most recent CAS/CASW time and length
; 2508 : 			// FIXME: change to use iterators
; 2509 : 			for (unsigned rank_id = 0; rank_id < rank.size() ; rank_id++)

	mov	ecx, DWORD PTR [ebx+384]
	sub	ecx, DWORD PTR [ebx+380]
	mov	DWORD PTR _otherRankLastCASTime$220147[esp+96], eax
	mov	DWORD PTR _otherRankLastCASWTime$220149[esp+96], eax
	mov	DWORD PTR _otherRankLastCASLength$220148[esp+96], edx
	mov	DWORD PTR _otherRankLastCASWLength$220150[esp+96], edx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	je	$LN14@minProtoco@2

; 2490 : 
; 2491 : 	case Command::WRITE_AND_PRECHARGE:
; 2492 : 		// Auto precharge will be issued as part of command, so
; 2493 : 		// Since commodity DRAM devices are write-cycle limited, we don't have to worry if
; 2494 : 		// the precharge will met tRAS timing or not. So WRITE_AND_PRECHARGE
; 2495 : 		// has the exact same timing requirements as a simple CAS COMMAND.
; 2496 : 
; 2497 : 	case Command::WRITE:
; 2498 : 		{
; 2499 : 			//respect last ras of same rank
; 2500 : 			int t_ras_gap = ((currentBank.getLastRASTime() - time) + timingSpecification.tRCD() - timingSpecification.tAL());

	mov	DWORD PTR tv1964[esp+96], edi
$LN16@minProtoco@2:

; 2510 : 			{
; 2511 : 				if (rank_id != currentRankID)

	cmp	edi, DWORD PTR _currentRankID$[esp+96]
	je	$LN15@minProtoco@2

; 2512 : 				{
; 2513 : 					if (rank[rank_id].getLastCASTime() > otherRankLastCASTime)

	mov	ecx, DWORD PTR [ebx+384]
	sub	ecx, DWORD PTR [ebx+380]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN287@minProtoco@2
	call	__invalid_parameter_noinfo
$LN287@minProtoco@2:
	mov	eax, DWORD PTR [ebx+380]
	mov	ecx, DWORD PTR tv1964[esp+96]
	mov	edx, DWORD PTR [ecx+eax+28]
	cmp	edx, DWORD PTR _otherRankLastCASTime$220147[esp+100]
	jl	SHORT $LN12@minProtoco@2
	jg	SHORT $LN425@minProtoco@2
	mov	eax, DWORD PTR [ecx+eax+24]
	cmp	eax, DWORD PTR _otherRankLastCASTime$220147[esp+96]
	jbe	SHORT $LN12@minProtoco@2
$LN425@minProtoco@2:

; 2514 : 					{
; 2515 : 						otherRankLastCASTime = rank[rank_id].getLastCASTime();

	lea	esi, DWORD PTR [ebx+368]
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [eax+28]

; 2516 : 						otherRankLastCASLength = rank[rank_id].getLastCASLength();

	lea	esi, DWORD PTR [ebx+368]
	mov	DWORD PTR _otherRankLastCASTime$220147[esp+96], ecx
	mov	DWORD PTR _otherRankLastCASTime$220147[esp+100], edx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	eax, DWORD PTR [eax+112]
	mov	esi, DWORD PTR _currentRank$[esp+96]
	mov	DWORD PTR _otherRankLastCASLength$220148[esp+96], eax
$LN12@minProtoco@2:

; 2517 : 					}
; 2518 : 					if (rank[rank_id].getLastCASWTime() > otherRankLastCASWTime)

	mov	ecx, DWORD PTR [ebx+384]
	sub	ecx, DWORD PTR [ebx+380]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	edi, ecx
	jb	SHORT $LN298@minProtoco@2
	call	__invalid_parameter_noinfo
$LN298@minProtoco@2:
	mov	eax, DWORD PTR [ebx+380]
	mov	edx, DWORD PTR tv1964[esp+96]
	mov	ecx, DWORD PTR [edx+eax+36]
	cmp	ecx, DWORD PTR _otherRankLastCASWTime$220149[esp+100]
	jl	SHORT $LN15@minProtoco@2
	jg	SHORT $LN426@minProtoco@2
	mov	eax, DWORD PTR [edx+eax+32]
	cmp	eax, DWORD PTR _otherRankLastCASWTime$220149[esp+96]
	jbe	SHORT $LN15@minProtoco@2
$LN426@minProtoco@2:

; 2519 : 					{
; 2520 : 						otherRankLastCASWTime = rank[rank_id].getLastCASWTime();

	lea	esi, DWORD PTR [ebx+368]
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [eax+36]

; 2521 : 						otherRankLastCASWLength = rank[rank_id].getLastCASWLength();

	lea	esi, DWORD PTR [ebx+368]
	mov	DWORD PTR _otherRankLastCASWTime$220149[esp+96], ecx
	mov	DWORD PTR _otherRankLastCASWTime$220149[esp+100], edx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	eax, DWORD PTR [eax+116]
	mov	esi, DWORD PTR _currentRank$[esp+96]
	mov	DWORD PTR _otherRankLastCASWLength$220150[esp+96], eax
$LN15@minProtoco@2:
	mov	ecx, DWORD PTR [ebx+384]
	sub	ecx, DWORD PTR [ebx+380]
	add	DWORD PTR tv1964[esp+96], 200		; 000000c8H
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	inc	edi
	add	ecx, edx
	cmp	edi, ecx
	jb	$LN16@minProtoco@2
$LN14@minProtoco@2:

; 2522 : 					}
; 2523 : 				}
; 2524 : 			}
; 2525 : 			// DW 3/9/2006 add these two lines
; 2526 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2527 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2528 : 
; 2529 : 			// respect last cas to same rank
; 2530 : 			// DW 3/9/2006 replace the line after next with the next line
; 2531 : 			// t_cas_gap = max(0,(int)(this_r.last_cas_time + timing_specification.t_cas + cas_length + timing_specification.t_rtrs - timing_specification.t_cwd - now));
; 2532 : 			tick t_cas_gap = (tick)(currentRank.getLastCASTime() - time) + timingSpecification.tCAS() + timingSpecification.tBurst() + timingSpecification.tRTRS() - timingSpecification.tCWD();

	mov	eax, DWORD PTR [ebx+48]
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+84]
	mov	edi, edx
	cdq
	sub	eax, ecx
	sbb	edx, edi
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+36]
	mov	edi, edx
	cdq
	add	ecx, eax
	mov	eax, edi
	mov	edi, DWORD PTR [esi+24]
	adc	eax, edx
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR tv1656[esp+100], eax
	mov	eax, DWORD PTR [ebx+8]
	sub	edi, eax
	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR tv1656[esp+96], ecx
	mov	ecx, DWORD PTR [esi+28]
	sbb	ecx, edx
	cdq
	add	edi, eax
	mov	eax, DWORD PTR _otherRankLastCASLength$220148[esp+96]
	adc	ecx, edx
	add	edi, DWORD PTR tv1656[esp+96]
	cdq
	adc	ecx, DWORD PTR tv1656[esp+100]
	mov	DWORD PTR tv1664[esp+96], eax

; 2533 : 
; 2534 : 			// respect last cas to different ranks
; 2535 : 			t_cas_gap = max((tick)t_cas_gap,(otherRankLastCASTime - time) + timingSpecification.tCAS() + otherRankLastCASLength + timingSpecification.tRTRS() - timingSpecification.tCWD());

	sub	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR tv1664[esp+100], edx
	mov	DWORD PTR tv531[esp+96], eax
	mov	eax, edx
	sbb	eax, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR tv1656[esp+96]
	add	DWORD PTR tv531[esp+96], edx
	mov	edx, DWORD PTR tv531[esp+96]
	mov	DWORD PTR tv531[esp+100], eax
	adc	eax, DWORD PTR tv1656[esp+100]
	add	edx, DWORD PTR _otherRankLastCASTime$220147[esp+96]
	mov	DWORD PTR _t_cas_gap$220158[esp+96], edi
	adc	eax, DWORD PTR _otherRankLastCASTime$220147[esp+100]
	cmp	ecx, eax
	jg	SHORT $LN58@minProtoco@2
	jl	SHORT $LN427@minProtoco@2
	cmp	edi, edx
	ja	SHORT $LN58@minProtoco@2
$LN427@minProtoco@2:
	mov	eax, DWORD PTR [ebx+48]
	cdq
	mov	DWORD PTR tv1152[esp+96], eax
	mov	eax, DWORD PTR [ebx+84]
	mov	ecx, edx
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR tv1152[esp+96]
	sub	edi, eax
	mov	eax, ecx
	mov	ecx, edx
	sbb	ecx, eax
	sub	edi, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+36]
	sbb	ecx, DWORD PTR [ebx+12]
	cdq
	add	edi, eax
	adc	ecx, edx
	add	edi, DWORD PTR tv1664[esp+96]
	adc	ecx, DWORD PTR tv1664[esp+100]
	add	edi, DWORD PTR _otherRankLastCASTime$220147[esp+96]
	adc	ecx, DWORD PTR _otherRankLastCASTime$220147[esp+100]
	mov	DWORD PTR _t_cas_gap$220158[esp+96], edi
$LN58@minProtoco@2:

; 2536 : 
; 2537 : 			// respect last cas write to same rank
; 2538 : 			// DW 3/9/2006 replace the line after next with the next line			
; 2539 : 			// t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + casw_length - now));
; 2540 : 			t_cas_gap = max((tick)t_cas_gap,(currentRank.getLastCASWTime() - time) + currentRank.getLastCASWLength());

	mov	edx, DWORD PTR [esi+116]
	xor	eax, eax
	add	edx, DWORD PTR [esi+32]
	adc	eax, DWORD PTR [esi+36]
	sub	edx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+12]
	sbb	eax, esi
	cmp	ecx, eax
	jg	SHORT $LN60@minProtoco@2
	jl	SHORT $LN428@minProtoco@2
	cmp	edi, edx
	ja	SHORT $LN60@minProtoco@2
$LN428@minProtoco@2:
	mov	DWORD PTR _t_cas_gap$220158[esp+96], edx
	mov	ecx, eax
$LN60@minProtoco@2:

; 2541 : 
; 2542 : 			// respect last cas write to different ranks
; 2543 : 			t_cas_gap = max((tick)t_cas_gap,(otherRankLastCASWTime - time) + otherRankLastCASWLength + timingSpecification.tOST());

	mov	eax, DWORD PTR [ebx+96]
	cdq
	mov	edi, eax
	sub	edi, DWORD PTR [ebx+8]
	mov	eax, edx
	sbb	eax, esi
	mov	DWORD PTR tv389[esp+96], eax
	mov	eax, DWORD PTR _otherRankLastCASWLength$220150[esp+96]
	cdq
	add	edi, eax
	mov	eax, DWORD PTR tv389[esp+96]
	adc	eax, edx
	mov	edx, edi
	add	edx, DWORD PTR _otherRankLastCASWTime$220149[esp+96]
	adc	eax, DWORD PTR _otherRankLastCASWTime$220149[esp+100]
	cmp	ecx, eax
	jg	SHORT $LN436@minProtoco@2
	jl	SHORT $LN429@minProtoco@2
	mov	esi, DWORD PTR _t_cas_gap$220158[esp+96]
	cmp	esi, edx
	ja	SHORT $LN62@minProtoco@2
$LN429@minProtoco@2:
	mov	esi, edx
	mov	ecx, eax
	jmp	SHORT $LN62@minProtoco@2
$LN436@minProtoco@2:
	mov	esi, DWORD PTR _t_cas_gap$220158[esp+96]
$LN62@minProtoco@2:

; 2544 : 
; 2545 : 			min_gap = max((tick)t_ras_gap,(tick)t_cas_gap);

	mov	eax, DWORD PTR _t_ras_gap$220146[esp+96]
	cdq
	cmp	edx, ecx
	jl	SHORT $LN63@minProtoco@2
	jg	SHORT $LN430@minProtoco@2
	cmp	eax, esi
	jbe	SHORT $LN63@minProtoco@2
$LN430@minProtoco@2:
	mov	DWORD PTR _min_gap$[esp+100], edx
	jmp	$LN455@minProtoco@2
$LN63@minProtoco@2:
	mov	DWORD PTR _min_gap$[esp+96], esi
	mov	DWORD PTR _min_gap$[esp+100], ecx

; 2546 : 		}
; 2547 : 		break;

	jmp	$LN1@minProtoco@2
$LN9@minProtoco@2:

; 2548 : 
; 2549 : 	case Command::RETIRE_COMMAND:
; 2550 : 		break;
; 2551 : 
; 2552 : 	case Command::PRECHARGE:
; 2553 : 		{
; 2554 : 			// respect t_ras of same bank
; 2555 : 			tick t_ras_gap = (currentBank.getLastRASTime() - time) + timingSpecification.tRAS();

	mov	eax, DWORD PTR [ebx+56]
	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+12]
	cdq
	add	eax, DWORD PTR [edi+48]
	adc	edx, DWORD PTR [edi+52]
	sub	eax, ecx
	sbb	edx, esi
	mov	DWORD PTR _t_ras_gap$220172[esp+96], eax

; 2556 : 
; 2557 : 			// respect t_cas of same bank
; 2558 : 			tick t_cas_gap = ((tick)(currentBank.getLastCASTime() - time) + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD()));

	mov	eax, DWORD PTR [ebx+80]
	sub	eax, DWORD PTR [ebx+44]
	mov	ecx, 0
	sets	cl
	mov	DWORD PTR _t_ras_gap$220172[esp+100], edx
	dec	ecx
	and	ecx, eax
	mov	eax, DWORD PTR [ebx+32]
	cdq
	mov	DWORD PTR tv1710[esp+96], eax
	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR tv1710[esp+100], edx
	cdq
	mov	DWORD PTR tv1714[esp+96], eax
	mov	eax, DWORD PTR [ebx+36]
	mov	DWORD PTR tv1714[esp+100], edx
	cdq
	mov	esi, eax
	add	esi, DWORD PTR [edi+56]
	mov	eax, ecx
	mov	ecx, edx
	adc	ecx, DWORD PTR [edi+60]
	sub	esi, DWORD PTR [ebx+8]
	cdq
	sbb	ecx, DWORD PTR [ebx+12]
	add	esi, eax

; 2559 : 
; 2560 : 			// respect t_casw of same bank
; 2561 : 			t_cas_gap = max((tick)t_cas_gap,((currentBank.getLastCASWTime() - time) + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR()));

	mov	eax, DWORD PTR [edi+68]
	adc	ecx, edx
	add	esi, DWORD PTR tv1714[esp+96]
	mov	edx, DWORD PTR [edi+64]
	adc	ecx, DWORD PTR tv1714[esp+100]
	add	esi, DWORD PTR tv1710[esp+96]
	mov	DWORD PTR tv1738[esp+100], eax
	adc	ecx, DWORD PTR tv1710[esp+100]
	mov	eax, DWORD PTR [ebx+88]
	mov	DWORD PTR tv1738[esp+96], edx
	cdq
	mov	edi, eax
	sub	edi, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+48]
	sbb	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR tv924[esp+100], edx
	cdq
	add	edi, eax
	mov	eax, DWORD PTR tv924[esp+100]
	adc	eax, edx
	add	edi, DWORD PTR tv1738[esp+96]
	adc	eax, DWORD PTR tv1738[esp+100]
	add	edi, DWORD PTR tv1714[esp+96]
	adc	eax, DWORD PTR tv1714[esp+100]
	add	edi, DWORD PTR tv1710[esp+96]
	adc	eax, DWORD PTR tv1710[esp+100]
	cmp	ecx, eax
	jg	SHORT $LN68@minProtoco@2
	jl	SHORT $LN431@minProtoco@2
	cmp	esi, edi
	ja	SHORT $LN68@minProtoco@2
$LN431@minProtoco@2:
	mov	eax, DWORD PTR [ebx+28]
	cdq
	mov	esi, eax
	sub	esi, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+88]
	mov	ecx, edx
	sbb	ecx, DWORD PTR [ebx+12]
	cdq
	add	esi, eax
	mov	eax, DWORD PTR [ebx+48]
	adc	ecx, edx
	cdq
	add	esi, eax
	mov	eax, DWORD PTR [ebx+32]
	adc	ecx, edx
	cdq
	add	esi, eax
	adc	ecx, edx
	add	esi, DWORD PTR tv1738[esp+96]
	adc	ecx, DWORD PTR tv1738[esp+100]
$LN68@minProtoco@2:

; 2562 : 
; 2563 : 			min_gap = max(t_ras_gap,t_cas_gap);

	mov	eax, DWORD PTR _t_ras_gap$220172[esp+100]
	cmp	eax, ecx
	jl	$LN63@minProtoco@2
	jg	SHORT $LN432@minProtoco@2
	cmp	DWORD PTR _t_ras_gap$220172[esp+96], esi
	jbe	$LN63@minProtoco@2
$LN432@minProtoco@2:
	mov	ecx, DWORD PTR _t_ras_gap$220172[esp+96]
	mov	DWORD PTR _min_gap$[esp+96], ecx
	mov	DWORD PTR _min_gap$[esp+100], eax
	jmp	SHORT $LN1@minProtoco@2
$LN3@minProtoco@2:

; 2564 : 		}
; 2565 : 		break;
; 2566 : 
; 2567 : 	case Command::PRECHARGE_ALL:
; 2568 : 		break;
; 2569 : 
; 2570 : 	case Command::ACTIVATE_ALL:
; 2571 : 		break;
; 2572 : 
; 2573 : 	case Command::DRIVE_COMMAND:
; 2574 : 		break;
; 2575 : 
; 2576 : 	case Command::DATA_COMMAND:
; 2577 : 		break;
; 2578 : 
; 2579 : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 2580 : 		break;
; 2581 : 
; 2582 : 	case Command::REFRESH_ALL:
; 2583 : 		// respect tRFC and tRP
; 2584 : 		min_gap = max((currentRank.getLastRefreshTime() + timingSpecification.tRFC()),(currentRank.getLastPrechargeTime() + timingSpecification.tRP())) - time;

	mov	eax, DWORD PTR [ebx+72]
	cdq
	mov	edi, eax
	add	edi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ebx+68]
	mov	ecx, edx
	adc	ecx, DWORD PTR [esi+20]
	cdq
	add	eax, DWORD PTR [esi+8]
	adc	edx, DWORD PTR [esi+12]
	cmp	edx, ecx
	jl	SHORT $LN71@minProtoco@2
	jg	SHORT $LN433@minProtoco@2
	cmp	eax, edi
	jbe	SHORT $LN71@minProtoco@2
$LN433@minProtoco@2:
	mov	ecx, edx
	jmp	SHORT $LN72@minProtoco@2
$LN71@minProtoco@2:
	mov	eax, edi
$LN72@minProtoco@2:
	sub	eax, DWORD PTR [ebx+8]
	sbb	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR _min_gap$[esp+100], ecx
$LN455@minProtoco@2:
	mov	DWORD PTR _min_gap$[esp+96], eax
$LN1@minProtoco@2:

; 2585 : 		break;
; 2586 : 
; 2587 : 	case Command::INVALID_COMMAND:
; 2588 : 		break;
; 2589 : 
; 2590 : 	default:
; 2591 : 		break;
; 2592 : 	}
; 2593 : 
; 2594 : 	//return max(min_gap,timingSpecification.tCMD());
; 2595 : 	//return max(min_gap,max(lastCommandIssueTime - time + (tick)timingSpecification.tCMD(),(tick)0));
; 2596 : 	return max(min_gap, lastCommandIssueTime + (tick)(timingSpecification.tCMD()) - time);

	mov	eax, DWORD PTR [ebx+44]
	cdq
	sub	eax, DWORD PTR [ebx+8]
	sbb	edx, DWORD PTR [ebx+12]
	add	eax, DWORD PTR [ebx+16]
	mov	ecx, edx
	adc	ecx, DWORD PTR [ebx+20]
	mov	edx, DWORD PTR _min_gap$[esp+100]
	cmp	edx, ecx
	jl	SHORT $LN73@minProtoco@2
	jg	SHORT $LN434@minProtoco@2
	cmp	DWORD PTR _min_gap$[esp+96], eax
	jbe	SHORT $LN73@minProtoco@2
$LN434@minProtoco@2:
	mov	eax, DWORD PTR _min_gap$[esp+96]

; 2597 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN73@minProtoco@2:
	pop	edi
	pop	esi
	mov	edx, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN456@minProtoco@2:
	DD	$LN26@minProtoco@2
	DD	$LN25@minProtoco@2
	DD	$LN17@minProtoco@2
	DD	$LN9@minProtoco@2
	DD	$LN3@minProtoco@2
	DD	$LN1@minProtoco@2
$LN410@minProtoco@2:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	2
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
?minProtocolGap@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z ENDP ; DRAMsimII::Channel::minProtocolGap
_TEXT	ENDS
PUBLIC	?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ	; DRAMsimII::Channel::nextRefreshTime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T397613 = -8						; size = 8
?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ PROC	; DRAMsimII::Channel::nextRefreshTime
; _this$ = eax

; 349  : {

	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	edi, eax

; 350  : 	assert(rank.size() >= 1);
; 351  : 
; 352  : 	if (systemConfig.getRefreshPolicy() != NO_REFRESH)

	mov	eax, DWORD PTR [edi+176]
	cmp	DWORD PTR [eax+304], 0
	je	SHORT $LN2@nextRefres

; 353  : 		return *(std::min_element(refreshCounter.begin(), refreshCounter.end()));

	mov	ebx, DWORD PTR [edi+168]
	cmp	DWORD PTR [edi+164], ebx
	jbe	SHORT $LN10@nextRefres
	call	__invalid_parameter_noinfo
$LN10@nextRefres:
	mov	esi, DWORD PTR [edi+164]
	cmp	esi, DWORD PTR [edi+168]
	jbe	SHORT $LN24@nextRefres
	call	__invalid_parameter_noinfo
$LN24@nextRefres:
	mov	edi, DWORD PTR [edi+152]
	mov	DWORD PTR $T397613[esp+24], esi
	cmp	esi, ebx
	je	SHORT $LN50@nextRefres
	lea	eax, DWORD PTR [esi+8]
	cmp	eax, ebx
	je	SHORT $LN50@nextRefres
$LL51@nextRefres:
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [esi+4]
	jg	SHORT $LN49@nextRefres
	jl	SHORT $LN73@nextRefres
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [esi]
	jae	SHORT $LN49@nextRefres
$LN73@nextRefres:
	mov	esi, eax
$LN49@nextRefres:
	add	eax, 8
	cmp	eax, ebx
	jne	SHORT $LL51@nextRefres
$LN50@nextRefres:
	test	edi, edi
	jne	SHORT $LN72@nextRefres
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN68@nextRefres:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN59@nextRefres
	call	__invalid_parameter_noinfo
$LN59@nextRefres:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]

; 354  : 	else
; 355  : 		return TICK_MAX;
; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 8
	ret	0
$LN72@nextRefres:

; 353  : 		return *(std::min_element(refreshCounter.begin(), refreshCounter.end()));

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN68@nextRefres
$LN2@nextRefres:

; 354  : 	else
; 355  : 		return TICK_MAX;
; 356  : }

	pop	edi
	pop	esi
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
	pop	ebx
	add	esp, 8
	ret	0
?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ ENDP	; DRAMsimII::Channel::nextRefreshTime
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_data.hpp
_TEXT	ENDS
;	COMDAT ??1thread_data_base@detail@boost@@UAE@XZ
_TEXT	SEGMENT
??1thread_data_base@detail@boost@@UAE@XZ PROC		; boost::detail::thread_data_base::~thread_data_base, COMDAT
; _this$ = ecx

; 45   :             {}

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7thread_data_base@detail@boost@@6B@
	mov	eax, DWORD PTR [esi+12]
	push	edi
	mov	edi, DWORD PTR __imp__CloseHandle@4
	test	eax, eax
	je	SHORT $LN5@thread_dat
	cmp	eax, -1
	je	SHORT $LN5@thread_dat
	push	eax
	call	edi
$LN5@thread_dat:
	mov	esi, DWORD PTR [esi+8]
	test	esi, esi
	je	SHORT $LN10@thread_dat
	cmp	esi, -1
	je	SHORT $LN10@thread_dat
	push	esi
	call	edi
$LN10@thread_dat:
	pop	edi
	pop	esi
	ret	0
??1thread_data_base@detail@boost@@UAE@XZ ENDP		; boost::detail::thread_data_base::~thread_data_base
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_primitives.hpp
xdata$x	SEGMENT
__unwindtable$??0thread_data_base@detail@boost@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0thread_data_base@detail@boost@@QAE@XZ$0
__ehfuncinfo$??0thread_data_base@detail@boost@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0thread_data_base@detail@boost@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_data.hpp
xdata$x	ENDS
;	COMDAT ??0thread_data_base@detail@boost@@QAE@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T397686 = -28						; size = 16
__$EHRec$ = -12						; size = 12
??0thread_data_base@detail@boost@@QAE@XZ PROC		; boost::detail::thread_data_base::thread_data_base, COMDAT
; _this$ = ecx

; 43   :             {}

	push	-1
	push	__ehhandler$??0thread_data_base@detail@boost@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+44], esi
	xor	edi, edi
	mov	DWORD PTR [esi], OFFSET ??_7thread_data_base@detail@boost@@6B@
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], -1
	push	edi
	push	edi
	push	1
	push	edi
	mov	DWORD PTR __$EHRec$[esp+68], edi
	call	DWORD PTR __imp__CreateEventA@16
	cmp	eax, edi
	jne	SHORT $LN7@thread_dat@2
	lea	ecx, DWORD PTR $T397686[esp+44]
	call	??0thread_resource_error@boost@@QAE@XZ	; boost::thread_resource_error::thread_resource_error
	push	OFFSET __TI3?AVthread_resource_error@boost@@
	lea	eax, DWORD PTR $T397686[esp+48]
	push	eax
	call	__CxxThrowException@8
$LN15@thread_dat@2:
$LN7@thread_dat@2:
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], edi
	mov	BYTE PTR [esi+24], 1
	mov	DWORD PTR [esi+28], edi
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 32					; 00000020H
	ret	0
$LN14@thread_dat@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0thread_data_base@detail@boost@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1handle_manager@win32@detail@boost@@QAE@XZ ; boost::detail::win32::handle_manager::~handle_manager
__ehhandler$??0thread_data_base@detail@boost@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-28]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0thread_data_base@detail@boost@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0thread_data_base@detail@boost@@QAE@XZ ENDP		; boost::detail::thread_data_base::thread_data_base
; Function compile flags: /Ogtpy
;	COMDAT ??_G_ns2__submitEpochResultElement@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_ns2__submitEpochResultElement@@UAEPAXI@Z PROC	; _ns2__submitEpochResultElement::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1_ns2__submitEpochResultElement@@UAE@XZ ; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@47
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@47:
	mov	eax, esi
	pop	esi
	ret	4
??_G_ns2__submitEpochResultElement@@UAEPAXI@Z ENDP	; _ns2__submitEpochResultElement::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.h
_TEXT	ENDS
;	COMDAT ?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ
_TEXT	SEGMENT
?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ PROC		; DRAMsimII::Bank::back, COMDAT
; _this$ = esi

; 107  : 		const Command *back() const { return perBankQueue.back(); }

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN5@back@4
	mov	ecx, DWORD PTR [esi+36]
	sub	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [edx+eax-1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	push	edi
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN9@back@4
	call	__invalid_parameter_noinfo
$LN9@back@4:
	mov	ecx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi
	ret	0
$LN5@back@4:
	xor	eax, eax
	ret	0
?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ENDP		; DRAMsimII::Bank::back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ
_TEXT	SEGMENT
?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ PROC		; DRAMsimII::Bank::front, COMDAT
; _this$ = esi

; 106  : 		const inline Command *front() const { return perBankQueue.front(); }

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	push	edi
	mov	edi, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN10@front@7
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi
	ret	0
$LN10@front@7:
	mov	edx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [edx+edi*4]
	pop	edi
	ret	0
?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ENDP		; DRAMsimII::Bank::front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z
_TEXT	SEGMENT
?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z PROC		; DRAMsimII::Bank::read, COMDAT
; _this$ = esi

; 105  : 		const Command *read(const unsigned value) const { return perBankQueue.read(value); }

	cmp	DWORD PTR [esi+8], 1
	jle	SHORT $LN4@read@9
	mov	ecx, DWORD PTR [esi+36]
	sub	ecx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [esi+12]
	xor	edx, edx
	sar	ecx, 2
	inc	eax
	div	ecx
	push	edi
	mov	edi, edx
	mov	edx, DWORD PTR [esi+36]
	sub	edx, DWORD PTR [esi+32]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN10@read@9
	call	__invalid_parameter_noinfo
$LN10@read@9:
	mov	eax, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [eax+edi*4]
	pop	edi
	ret	0
$LN4@read@9:
	xor	eax, eax
	ret	0
?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z ENDP		; DRAMsimII::Bank::read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pop@Bank@DRAMsimII@@QAEPAVCommand@2@XZ
_TEXT	SEGMENT
?pop@Bank@DRAMsimII@@QAEPAVCommand@2@XZ PROC		; DRAMsimII::Bank::pop, COMDAT
; _this$ = eax

; 102  : 		Command *pop() { return perBankQueue.pop(); }

	push	esi
	mov	esi, eax
	add	esi, 8
	call	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop
	pop	esi
	ret	0
?pop@Bank@DRAMsimII@@QAEPAVCommand@2@XZ ENDP		; DRAMsimII::Bank::pop
; Function compile flags: /Ogtpy
;	COMDAT ??1?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAE@XZ
_TEXT	SEGMENT
??1?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAE@XZ PROC ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::~thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >, COMDAT
; _this$ = eax
	push	esi
	push	edi
	mov	edi, eax
	lea	esi, DWORD PTR [edi+40]
	call	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
	mov	esi, DWORD PTR __imp__CloseHandle@4
	mov	DWORD PTR [edi], OFFSET ??_7thread_data_base@detail@boost@@6B@
	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN13@thread_dat@3
	cmp	eax, -1
	je	SHORT $LN13@thread_dat@3
	push	eax
	call	esi
$LN13@thread_dat@3:
	mov	edi, DWORD PTR [edi+8]
	test	edi, edi
	je	SHORT $LN18@thread_dat@3
	cmp	edi, -1
	je	SHORT $LN18@thread_dat@3
	push	edi
	call	esi
$LN18@thread_dat@3:
	pop	edi
	pop	esi
	ret	0
??1?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAE@XZ ENDP ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::~thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEPAXI@Z PROC ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, ecx
	lea	esi, DWORD PTR [edi+40]
	call	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
	mov	esi, DWORD PTR __imp__CloseHandle@4
	mov	DWORD PTR [edi], OFFSET ??_7thread_data_base@detail@boost@@6B@
	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN16@scalar@65
	cmp	eax, -1
	je	SHORT $LN16@scalar@65
	push	eax
	call	esi
$LN16@scalar@65:
	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN21@scalar@65
	cmp	eax, -1
	je	SHORT $LN21@scalar@65
	push	eax
	call	esi
$LN21@scalar@65:
	test	BYTE PTR ___flags$[esp+4], 1
	je	SHORT $LN24@scalar@65
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@scalar@65:
	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??_G?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEPAXI@Z ENDP ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Equal@PBVRank@DRAMsimII@@PBV12@Uforward_iterator_tag@std@@@std@@YA_NPBVRank@DRAMsimII@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Last1$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Equal@PBVRank@DRAMsimII@@PBV12@Uforward_iterator_tag@std@@@std@@YA_NPBVRank@DRAMsimII@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<DRAMsimII::Rank const *,DRAMsimII::Rank const *,std::forward_iterator_tag>, COMDAT
; __First1$ = ecx
; __First2$ = eax

; 2991 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ebx
	mov	ebx, DWORD PTR __Last1$[esp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, eax

; 2992 : 	for (; _First1 != _Last1; ++_First1, ++_First2)

	cmp	esi, ebx
	je	SHORT $LN2@Equal@13
	npad	1
$LL4@Equal@13:

; 2993 : 		if (!(*_First1 == *_First2))

	push	esi
	call	??8Rank@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Rank::operator==
	test	al, al
	je	SHORT $LN8@Equal@13
	add	esi, 200				; 000000c8H
	add	edi, 200				; 000000c8H
	cmp	esi, ebx
	jne	SHORT $LL4@Equal@13
$LN2@Equal@13:
	pop	edi
	pop	esi

; 2995 : 	return (true);

	mov	al, 1
	pop	ebx

; 2996 : 	}

	ret	0
$LN8@Equal@13:
	pop	edi
	pop	esi

; 2994 : 			return (false);

	xor	al, al
	pop	ebx

; 2996 : 	}

	ret	0
??$_Equal@PBVRank@DRAMsimII@@PBV12@Uforward_iterator_tag@std@@@std@@YA_NPBVRank@DRAMsimII@@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<DRAMsimII::Rank const *,DRAMsimII::Rank const *,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1Bank@DRAMsimII@@QAE@XZ
_TEXT	SEGMENT
??1Bank@DRAMsimII@@QAE@XZ PROC				; DRAMsimII::Bank::~Bank, COMDAT
; _this$ = eax
	push	ecx
	add	eax, 8
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	pop	ecx
	ret	0
??1Bank@DRAMsimII@@QAE@XZ ENDP				; DRAMsimII::Bank::~Bank
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GBank@DRAMsimII@@QAEPAXI@Z
_TEXT	SEGMENT
??_GBank@DRAMsimII@@QAEPAXI@Z PROC			; DRAMsimII::Bank::`scalar deleting destructor', COMDAT
; _this$ = esi
	push	ecx
	lea	eax, DWORD PTR [esi+8]
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	mov	eax, esi
	pop	ecx
	ret	0
??_GBank@DRAMsimII@@QAEPAXI@Z ENDP			; DRAMsimII::Bank::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@VBank@DRAMsimII@@@std@@YAXPAVBank@DRAMsimII@@@Z
_TEXT	SEGMENT
??$_Destroy@VBank@DRAMsimII@@@std@@YAXPAVBank@DRAMsimII@@@Z PROC ; std::_Destroy<DRAMsimII::Bank>, COMDAT
; __Ptr$ = eax

; 58   : 	{	// destroy object at _Ptr

	push	ecx

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	add	eax, 8
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	pop	ecx

; 60   : 	}

	ret	0
??$_Destroy@VBank@DRAMsimII@@@std@@YAXPAVBank@DRAMsimII@@@Z ENDP ; std::_Destroy<DRAMsimII::Bank>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Equal@PBVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVRank@DRAMsimII@@0V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Tmp$426654 = -8					; size = 8
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 8
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Equal@PBVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVRank@DRAMsimII@@0V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<DRAMsimII::Rank const *,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >, COMDAT

; 3042 : 	{

	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Last1$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR __First1$[esp+12]

; 3043 : 	// for range checked iterators, this will make sure there is enough space
; 3044 : 	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);

	mov	ecx, ebx
	sub	ecx, ebp
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	mov	eax, DWORD PTR __First2$[esp+12]
	push	esi
	sar	edx, 6
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	ecx, eax
	push	edi
	mov	edi, DWORD PTR __First2$[esp+24]
	mov	DWORD PTR __Tmp$426654[esp+24], ecx
	test	eax, eax
	jne	SHORT $LN39@Equal@14
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR __Tmp$426654[esp+24]
	xor	eax, eax
$LN15@Equal@14:
	imul	esi, 200				; 000000c8H
	add	esi, edi
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN5@Equal@14
	test	ecx, ecx
	je	SHORT $LN20@Equal@14
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN21@Equal@14
$LN39@Equal@14:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN15@Equal@14
$LN20@Equal@14:
	xor	ecx, ecx
$LN21@Equal@14:
	cmp	esi, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Equal@14
$LN5@Equal@14:
	call	__invalid_parameter_noinfo
$LN6@Equal@14:

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	mov	edi, DWORD PTR __First2$[esp+24]
	mov	esi, ebp
	cmp	ebp, ebx
	je	SHORT $LN31@Equal@14
$LL33@Equal@14:
	push	esi
	call	??8Rank@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Rank::operator==
	test	al, al
	je	SHORT $LN37@Equal@14
	add	esi, 200				; 000000c8H
	add	edi, 200				; 000000c8H
	cmp	esi, ebx
	jne	SHORT $LL33@Equal@14
$LN31@Equal@14:
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx

; 3047 : 	}

	add	esp, 8
	ret	0
$LN37@Equal@14:
	pop	edi
	pop	esi
	pop	ebp

; 3045 : 	return _Equal(_First1, _Last1, _CHECKED_BASE(_First2),
; 3046 : 		forward_iterator_tag(), _Range_checked_iterator_tag());

	xor	al, al
	pop	ebx

; 3047 : 	}

	add	esp, 8
	ret	0
??$_Equal@PBVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVRank@DRAMsimII@@0V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<DRAMsimII::Rank const *,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@@Z PROC ; std::allocator<DRAMsimII::Bank>::destroy, COMDAT
; __Ptr$ = eax

; 159  : 		{	// destroy object at _Ptr

	push	ecx

; 160  : 		_Destroy(_Ptr);

	add	eax, 8
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	pop	ecx

; 161  : 		}

	ret	0
?destroy@?$allocator@VBank@DRAMsimII@@@std@@QAEXPAVBank@DRAMsimII@@@Z ENDP ; std::allocator<DRAMsimII::Bank>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::Bank> >, COMDAT
; __First$ = eax
; __Last$ = edi

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ecx
	push	esi
	mov	esi, eax

; 233  : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra@10
	npad	8
$LL3@Destroy_ra@10:
	lea	eax, DWORD PTR [esi+8]

; 234  : 		_Al.destroy(_First);

	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	add	esi, 152				; 00000098H
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra@10
$LN1@Destroy_ra@10:

; 235  : 	}

	pop	esi
	pop	ecx
	ret	0
??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$equal@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@00@Z
_TEXT	SEGMENT
$T426745 = -4						; size = 1
__First1$ = 8						; size = 8
$T426746 = 16						; size = 1
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
??$equal@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@00@Z PROC ; std::equal<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >, COMDAT

; 3055 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ecx

; 3056 : 	return _Equal(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _First2,
; 3057 : 		_Iter_random(_First1, _First2), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T426746[esp]
	mov	edx, DWORD PTR __First2$[esp+4]
	mov	BYTE PTR $T426745[esp+4], 0
	mov	eax, DWORD PTR $T426745[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+16]
	push	eax
	push	ecx
	push	edx
	call	??$_Equal@PBVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVRank@DRAMsimII@@0V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<DRAMsimII::Rank const *,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >

; 3058 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$equal@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@V12@@std@@YA_NV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@00@Z ENDP ; std::equal<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::Bank> >, COMDAT
; __First$ = eax
; __Last$ = edi

; 224  : 	{	// destroy [_First, _Last)

	push	esi
	mov	esi, eax

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	cmp	esi, edi
	je	SHORT $LN5@Destroy_ra@11
$LL7@Destroy_ra@11:
	lea	eax, DWORD PTR [esi+8]
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	add	esi, 152				; 00000098H
	cmp	esi, edi
	jne	SHORT $LL7@Destroy_ra@11
$LN5@Destroy_ra@11:

; 226  : 	}

	pop	esi
	ret	0
??$_Destroy_range@V?$allocator@VBank@DRAMsimII@@@std@@@std@@YAXPAVBank@DRAMsimII@@0AAV?$allocator@VBank@DRAMsimII@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::Bank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$?8VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z
_TEXT	SEGMENT
$T426843 = -8						; size = 8
tv284 = 8						; size = 4
$T427052 = 8						; size = 1
$T427053 = 8						; size = 1
__Right$ = 8						; size = 4
??$?8VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z PROC ; std::operator==<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; __Left$ = esi

; 1307 : 	{	// test for vector equality

	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Right$[esp+8]
	push	ebp

; 1308 : 	return (_Left.size() == _Right.size()
; 1309 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	mov	ebp, DWORD PTR [ebx+16]
	push	edi
	mov	edi, DWORD PTR [ebx+12]
	mov	ecx, ebp
	sub	ecx, edi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR tv284[esp+16], eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	mov	ecx, DWORD PTR tv284[esp+16]
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jne	SHORT $LN3@operator@260
	cmp	edi, ebp
	jbe	SHORT $LN12@operator@260
	call	__invalid_parameter_noinfo
$LN12@operator@260:
	mov	ebp, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR $T426843[esp+20], ecx
	cmp	DWORD PTR [esi+12], ebp
	jbe	SHORT $LN26@operator@260
	call	__invalid_parameter_noinfo
$LN26@operator@260:
	mov	ebx, DWORD PTR [esi+12]
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN40@operator@260
	call	__invalid_parameter_noinfo
$LN40@operator@260:
	mov	ecx, DWORD PTR $T426843[esp+20]
	mov	BYTE PTR $T427052[esp+16], 0
	mov	edx, DWORD PTR $T427052[esp+16]
	mov	eax, DWORD PTR $T427053[esp+16]
	push	edx
	push	eax
	push	edi
	push	ecx
	push	ebp
	push	ebx
	call	??$_Equal@PBVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@std@@YA_NPBVRank@DRAMsimII@@0V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<DRAMsimII::Rank const *,std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
	add	esp, 24					; 00000018H
	test	al, al
	je	SHORT $LN3@operator@260
	pop	edi
	pop	ebp
	mov	eax, 1
	pop	ebx

; 1310 : 	}

	add	esp, 8
	ret	0
$LN3@operator@260:
	pop	edi
	pop	ebp

; 1308 : 	return (_Left.size() == _Right.size()
; 1309 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	xor	eax, eax
	pop	ebx

; 1310 : 	}

	add	esp, 8
	ret	0
??$?8VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z ENDP ; std::operator==<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN5@Make_iter@20
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN5@Make_iter@20
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN6@Make_iter@20
$LN5@Make_iter@20:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN6@Make_iter@20:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN5@Make_iter@21
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN5@Make_iter@21
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN6@Make_iter@21
$LN5@Make_iter@21:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN6@Make_iter@21:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Make_iter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = esi

; 1028 : 		{	// erase [_First, _Last)

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp
	push	edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	DWORD PTR [ebx], 0
	test	esi, esi
	je	SHORT $LN8@erase@12
	mov	eax, DWORD PTR __First_arg$[esp+12]
	cmp	DWORD PTR [esi+12], eax
	ja	SHORT $LN8@erase@12
	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN9@erase@12
$LN8@erase@12:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+12]
$LN9@erase@12:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	edi, DWORD PTR __Last_arg$[esp+12]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [esi+12], edi
	ja	SHORT $LN24@erase@12
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN25@erase@12
$LN24@erase@12:
	call	__invalid_parameter_noinfo
	mov	edi, DWORD PTR __Last_arg$[esp+12]
$LN25@erase@12:

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN38@erase@12
	cmp	eax, ecx
	je	SHORT $LN39@erase@12
$LN38@erase@12:
	call	__invalid_parameter_noinfo
$LN39@erase@12:
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, edi
	je	SHORT $LN63@erase@12

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [esi+16]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN60@erase@12
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN60@erase@12:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+16], ebp
$LN63@erase@12:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	pop	edi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	20					; 00000014H
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@0@Z PROC ; std::vector<__int64,std::allocator<__int64> >::erase, COMDAT
; _this$ = esi

; 1028 : 		{	// erase [_First, _Last)

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	DWORD PTR [ebx], 0
	test	esi, esi
	je	SHORT $LN8@erase@13
	mov	eax, DWORD PTR __First_arg$[esp+8]
	cmp	DWORD PTR [esi+12], eax
	ja	SHORT $LN8@erase@13
	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN9@erase@13
$LN8@erase@13:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+8]
$LN9@erase@13:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	edi, DWORD PTR __Last_arg$[esp+8]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [esi+12], edi
	ja	SHORT $LN24@erase@13
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN25@erase@13
$LN24@erase@13:
	call	__invalid_parameter_noinfo
	mov	edi, DWORD PTR __Last_arg$[esp+8]
$LN25@erase@13:

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN38@erase@13
	cmp	eax, ecx
	je	SHORT $LN39@erase@13
$LN38@erase@13:
	call	__invalid_parameter_noinfo
$LN39@erase@13:
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, edi
	je	SHORT $LN63@erase@13

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [esi+16]
	sub	eax, edi
	sar	eax, 3
	lea	ecx, DWORD PTR [eax*8]
	push	ebp
	lea	ebp, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN60@erase@13
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN60@erase@13:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+16], ebp
	pop	ebp
$LN63@erase@13:
	pop	edi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebx
	pop	ebx

; 1055 : #endif
; 1056 : 		}

	ret	20					; 00000014H
?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@0@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXPAVBank@DRAMsimII@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXPAVBank@DRAMsimII@@0@Z PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Destroy, COMDAT
; __First$ = eax
; __Last$ = edi

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	esi
	mov	esi, eax

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	cmp	esi, edi
	je	SHORT $LN7@Destroy@10
$LL9@Destroy@10:
	lea	eax, DWORD PTR [esi+8]
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	add	esi, 152				; 00000098H
	cmp	esi, edi
	jne	SHORT $LL9@Destroy@10
$LN7@Destroy@10:

; 1120 : 		}

	pop	esi
	ret	0
?_Destroy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXPAVBank@DRAMsimII@@0@Z ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@261
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@261
$LN15@operator@261:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@261
$LN11@operator@261:
	xor	eax, eax
$LN12@operator@261:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@261
	call	__invalid_parameter_noinfo
$LN16@operator@261:
	add	DWORD PTR [esi+4], 8

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+=, COMDAT
; _this$ = edi

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN22@operator@262
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN12@operator@262
$LN22@operator@262:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN13@operator@262
$LN12@operator@262:
	xor	edx, edx
$LN13@operator@262:
	mov	ecx, DWORD PTR [edi+4]
	push	esi
	mov	esi, DWORD PTR __Off$[esp]
	imul	esi, 152				; 00000098H
	add	ecx, esi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN3@operator@262
	test	eax, eax
	je	SHORT $LN18@operator@262
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@262
$LN18@operator@262:
	xor	eax, eax
$LN19@operator@262:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN23@operator@262
$LN3@operator@262:
	call	__invalid_parameter_noinfo
$LN23@operator@262:
	add	DWORD PTR [edi+4], esi

; 376  : 		return (*this);

	mov	eax, edi
	pop	esi

; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@263
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@263
$LN15@operator@263:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@263
$LN11@operator@263:
	xor	eax, eax
$LN12@operator@263:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@263
	call	__invalid_parameter_noinfo
$LN16@operator@263:
	add	DWORD PTR [esi+4], 152			; 00000098H

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEAAVBank@DRAMsimII@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEAAVBank@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*, COMDAT
; _this$ = esi

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@264
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@264
$LN15@operator@264:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@264
$LN11@operator@264:
	xor	eax, eax
$LN12@operator@264:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@264
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 340  : 		}

	ret	0
$LN16@operator@264:

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 340  : 		}

	ret	0
??D?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEAAVBank@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T427905 = -8						; size = 4
$T427857 = -8						; size = 8
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, eax

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	DWORD PTR $T427905[esp+24], eax
	cmp	DWORD PTR [esi+12], eax
	jbe	SHORT $LN8@clear@13
	call	__invalid_parameter_noinfo
$LN8@clear@13:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN24@clear@13
	call	__invalid_parameter_noinfo
$LN24@clear@13:
	mov	ecx, DWORD PTR $T427905[esp+24]
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	ebx
	push	edi
	push	eax
	lea	edx, DWORD PTR $T427857[esp+40]
	push	edx
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 1061 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T427992 = -8						; size = 8
?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ PROC ; std::vector<__int64,std::allocator<__int64> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 1060 : 		erase(begin(), end());

	mov	ebp, DWORD PTR [esi+16]
	push	edi
	cmp	DWORD PTR [esi+12], ebp
	jbe	SHORT $LN8@clear@14
	call	__invalid_parameter_noinfo
$LN8@clear@14:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN24@clear@14
	call	__invalid_parameter_noinfo
$LN24@clear@14:
	mov	eax, DWORD PTR [esi]
	push	ebp
	push	ebx
	push	edi
	push	eax
	lea	eax, DWORD PTR $T427992[esp+40]
	push	eax
	call	?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@_JV?$allocator@_J@std@@@2@V?$_Vector_const_iterator@_JV?$allocator@_J@std@@@2@0@Z ; std::vector<__int64,std::allocator<__int64> >::erase
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1061 : 		}

	add	esp, 8
	ret	0
?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ ENDP ; std::vector<__int64,std::allocator<__int64> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Tidy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXXZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Tidy, COMDAT

; 1123 : 		{	// free all storage

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]
	push	esi

; 1124 : 		if (_Myfirst != 0)

	mov	esi, DWORD PTR [ebx+12]
	push	edi
	test	esi, esi
	je	SHORT $LN25@Tidy@25

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [ebx+16]
	cmp	esi, edi
	je	SHORT $LN10@Tidy@25
$LL12@Tidy@25:
	lea	eax, DWORD PTR [esi+8]
	push	eax
	call	??1?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::~Queue<DRAMsimII::Command>
	add	esi, 152				; 00000098H
	cmp	esi, edi
	jne	SHORT $LL12@Tidy@25
$LN10@Tidy@25:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Tidy@25:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1135 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+20], 0
	pop	ebx
	pop	ecx
	ret	4
?_Tidy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXXZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@265
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@265
$LN17@operator@265:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@265
$LN13@operator@265:
	xor	eax, eax
$LN14@operator@265:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@265
	call	__invalid_parameter_noinfo
$LN18@operator@265:
	add	DWORD PTR [esi+4], 8

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEAA_JXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEAA_JXZ PROC ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator*, COMDAT
; _this$ = esi

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN15@operator@266
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@operator@266
$LN15@operator@266:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@operator@266
$LN11@operator@266:
	xor	eax, eax
$LN12@operator@266:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN16@operator@266
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 340  : 		}

	ret	0
$LN16@operator@266:

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 340  : 		}

	ret	0
??D?$_Vector_iterator@_JV?$allocator@_J@std@@@std@@QBEAA_JXZ ENDP ; std::_Vector_iterator<__int64,std::allocator<__int64> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??H?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+, COMDAT
; _this$ = eax
; __Off$ = ecx

; 380  : 		{	// return this + integer

	push	ebx

; 381  : 		_Myt _Tmp = *this;

	mov	ebx, DWORD PTR [eax+4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, ecx

; 382  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN24@operator@267
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN15@operator@267:
	imul	edi, 152				; 00000098H
	add	edi, ebx
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN5@operator@267
	test	esi, esi
	je	SHORT $LN20@operator@267
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN21@operator@267
$LN24@operator@267:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN15@operator@267
$LN20@operator@267:
	xor	eax, eax
$LN21@operator@267:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN6@operator@267
$LN5@operator@267:
	call	__invalid_parameter_noinfo
$LN6@operator@267:
	mov	DWORD PTR [ebp+4], edi

; 383  : 		}

	pop	edi
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	4
??H?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN17@operator@268
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@268
$LN17@operator@268:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@268
$LN13@operator@268:
	xor	eax, eax
$LN14@operator@268:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@268
	call	__invalid_parameter_noinfo
$LN18@operator@268:
	add	DWORD PTR [esi+4], 152			; 00000098H

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->, COMDAT
; _this$ = esi

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@269
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@269
$LN17@operator@269:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@269
$LN13@operator@269:
	xor	eax, eax
$LN14@operator@269:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@269
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 345  : 		}

	ret	0
$LN18@operator@269:

; 344  : 		return (&**this);

	mov	eax, ecx

; 345  : 		}

	ret	0
??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ PROC ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->, COMDAT
; _this$ = esi

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN17@operator@270
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@operator@270
$LN17@operator@270:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@operator@270
$LN13@operator@270:
	xor	eax, eax
$LN14@operator@270:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN18@operator@270
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 345  : 		}

	ret	0
$LN18@operator@270:

; 344  : 		return (&**this);

	mov	eax, ecx

; 345  : 		}

	ret	0
??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ ENDP ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >, COMDAT

; 558  : 		{	// destroy the object

	push	-1
	push	__ehhandler$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]

; 559  : 		_Tidy();

	push	esi
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	?_Tidy@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::_Tidy

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
PUBLIC	?isEmpty@Channel@DRAMsimII@@QBE_NXZ		; DRAMsimII::Channel::isEmpty
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
?isEmpty@Channel@DRAMsimII@@QBE_NXZ PROC		; DRAMsimII::Channel::isEmpty

; 2772 : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]
	push	esi
	push	edi

; 2773 : 	for (vector<Rank>::const_iterator i = rank.begin(); i != rank.end(); i++)

	mov	edi, DWORD PTR [ebp+380]
	cmp	edi, DWORD PTR [ebp+384]
	jbe	SHORT $LN10@isEmpty@2
	call	__invalid_parameter_noinfo
$LN10@isEmpty@2:
	mov	esi, DWORD PTR [ebp+368]
$LL25@isEmpty@2:
	mov	ebx, DWORD PTR [ebp+384]
	cmp	DWORD PTR [ebp+380], ebx
	jbe	SHORT $LN38@isEmpty@2
	call	__invalid_parameter_noinfo
$LN38@isEmpty@2:
	mov	eax, DWORD PTR [ebp+368]
	test	esi, esi
	je	SHORT $LN51@isEmpty@2
	cmp	esi, eax
	je	SHORT $LN52@isEmpty@2
$LN51@isEmpty@2:
	call	__invalid_parameter_noinfo
$LN52@isEmpty@2:
	cmp	edi, ebx
	je	SHORT $LN2@isEmpty@2

; 2774 : 	{
; 2775 : 		if (!i->isEmpty())

	test	esi, esi
	jne	SHORT $LN78@isEmpty@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN70@isEmpty@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN61@isEmpty@2
	call	__invalid_parameter_noinfo
$LN61@isEmpty@2:
	push	edi
	call	?isEmpty@Rank@DRAMsimII@@QBE_NXZ	; DRAMsimII::Rank::isEmpty
	test	al, al
	je	SHORT $LN76@isEmpty@2

; 2773 : 	for (vector<Rank>::const_iterator i = rank.begin(); i != rank.end(); i++)

	test	esi, esi
	jne	SHORT $LN77@isEmpty@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN32@isEmpty@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN23@isEmpty@2
	call	__invalid_parameter_noinfo
$LN23@isEmpty@2:
	add	edi, 200				; 000000c8H
	jmp	SHORT $LL25@isEmpty@2
$LN78@isEmpty@2:

; 2774 : 	{
; 2775 : 		if (!i->isEmpty())

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN70@isEmpty@2
$LN77@isEmpty@2:

; 2773 : 	for (vector<Rank>::const_iterator i = rank.begin(); i != rank.end(); i++)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN32@isEmpty@2
$LN76@isEmpty@2:
	pop	edi
	pop	esi
	pop	ebp

; 2776 : 			return false;

	xor	al, al
	pop	ebx

; 2779 : }

	ret	4
$LN2@isEmpty@2:
	pop	edi

; 2777 : 	}
; 2778 : 	return transactionQueue.isEmpty();

	xor	eax, eax
	cmp	DWORD PTR [ebp+112], eax
	pop	esi
	pop	ebp
	sete	al
	pop	ebx

; 2779 : }

	ret	4
?isEmpty@Channel@DRAMsimII@@QBE_NXZ ENDP		; DRAMsimII::Channel::isEmpty
_TEXT	ENDS
PUBLIC	?getNextCommand@Channel@DRAMsimII@@IAEPAVCommand@2@PBV32@@Z ; DRAMsimII::Channel::getNextCommand
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T429216 = -16						; size = 4
__Tmp$428952 = -16					; size = 8
_currentBank$219489 = -16				; size = 8
$T428802 = -8						; size = 8
_bankEnd$219466 = -8					; size = 8
_this$ = 8						; size = 4
_useThisCommand$ = 12					; size = 4
?getNextCommand@Channel@DRAMsimII@@IAEPAVCommand@2@PBV32@@Z PROC ; DRAMsimII::Channel::getNextCommand

; 1368 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	mov	eax, DWORD PTR _useThisCommand$[ebp]
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	esi, DWORD PTR _this$[ebp]
	push	edi

; 1369 : 	// populate the cache if need be
; 1370 : 	if (useThisCommand == NULL)

	test	eax, eax
	jne	SHORT $LN343@getNextCom

; 1371 : 		useThisCommand = readNextCommand();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	mov	ecx, esi
	call	edx
	mov	DWORD PTR _useThisCommand$[ebp], eax

; 1372 : 
; 1373 : 	if (useThisCommand)

	test	eax, eax
	je	$LN11@getNextCom
$LN343@getNextCom:

; 1374 : 	{
; 1375 : 		vector<Rank>::iterator currentRank = rank.begin() + useThisCommand->getAddress().getRank();

	mov	ebx, DWORD PTR [esi+380]
	mov	edi, DWORD PTR [eax+60]
	cmp	ebx, DWORD PTR [esi+384]
	jbe	SHORT $LN26@getNextCom
	call	__invalid_parameter_noinfo
$LN26@getNextCom:
	mov	esi, DWORD PTR [esi+368]
	mov	DWORD PTR __Tmp$428952[esp+32], esi
	mov	DWORD PTR __Tmp$428952[esp+36], ebx
	test	esi, esi
	jne	SHORT $LN342@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN51@getNextCom:
	imul	edi, 200				; 000000c8H
	add	edi, ebx
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN41@getNextCom
	test	esi, esi
	je	SHORT $LN56@getNextCom
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN57@getNextCom
$LN342@getNextCom:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN51@getNextCom
$LN56@getNextCom:
	xor	esi, esi
$LN57@getNextCom:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN42@getNextCom
$LN41@getNextCom:
	call	__invalid_parameter_noinfo
$LN42@getNextCom:

; 1376 : 
; 1377 : 		if (rank[useThisCommand->getAddress().getRank()].bank[useThisCommand->getAddress().getBank()].front() != useThisCommand)

	mov	eax, DWORD PTR _useThisCommand$[ebp]
	mov	esi, DWORD PTR [eax+60]
	mov	ebx, DWORD PTR [eax+64]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+384]
	sub	ecx, DWORD PTR [eax+380]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jb	SHORT $LN68@getNextCom
	call	__invalid_parameter_noinfo
$LN68@getNextCom:
	mov	ecx, DWORD PTR _this$[ebp]
	imul	esi, 200				; 000000c8H
	mov	edx, DWORD PTR [ecx+380]
	mov	ecx, DWORD PTR [esi+edx+188]
	sub	ecx, DWORD PTR [esi+edx+184]
	lea	esi, DWORD PTR [esi+edx+172]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	jb	SHORT $LN73@getNextCom
	call	__invalid_parameter_noinfo
$LN73@getNextCom:
	mov	ecx, DWORD PTR [esi+12]
	imul	ebx, 152				; 00000098H
	mov	edx, DWORD PTR [ebx+ecx+36]
	sub	edx, DWORD PTR [ebx+ecx+32]
	lea	eax, DWORD PTR [ebx+ecx+8]
	sar	edx, 2
	cmp	DWORD PTR [eax+4], edx
	jb	SHORT $LN82@getNextCom
	call	__invalid_parameter_noinfo
$LN82@getNextCom:

; 1378 : 			assert(rank[useThisCommand->getAddress().getRank()].bank[useThisCommand->getAddress().getBank()].front() == useThisCommand);
; 1379 : 
; 1380 : 		// if it was a refresh all command, then dequeue all n banks worth of commands
; 1381 : 		if (useThisCommand->isRefresh())

	mov	eax, DWORD PTR _useThisCommand$[ebp]
	cmp	DWORD PTR [eax+80], 12			; 0000000cH
	jne	$LN9@getNextCom

; 1382 : 		{		
; 1383 : 			if (!currentRank->refreshAllReady())

	mov	eax, DWORD PTR __Tmp$428952[esp+32]
	test	eax, eax
	jne	$LN341@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN102@getNextCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN93@getNextCom
	call	__invalid_parameter_noinfo
$LN93@getNextCom:
	push	edi
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady

; 1384 : 				assert(currentRank->refreshAllReady());
; 1385 : 
; 1386 : 			vector<Bank>::iterator bankEnd = currentRank->bank.end();

	mov	ebx, DWORD PTR __Tmp$428952[esp+32]
	test	ebx, ebx
	jne	$LN340@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN118@getNextCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN109@getNextCom
	call	__invalid_parameter_noinfo
$LN109@getNextCom:
	mov	esi, DWORD PTR [edi+188]
	mov	DWORD PTR $T429216[esp+32], esi
	cmp	DWORD PTR [edi+184], esi
	jbe	SHORT $LN126@getNextCom
	call	__invalid_parameter_noinfo
$LN126@getNextCom:
	mov	eax, DWORD PTR [edi+172]
	mov	DWORD PTR _bankEnd$219466[esp+32], eax

; 1387 : 
; 1388 : 			vector<Bank>::iterator currentBank = currentRank->bank.begin();

	test	ebx, ebx
	jne	$LN339@getNextCom
	call	__invalid_parameter_noinfo
$LN150@getNextCom:
	cmp	edi, DWORD PTR [ebx+16]
	jb	SHORT $LN141@getNextCom
	call	__invalid_parameter_noinfo
$LN141@getNextCom:
	mov	ebx, DWORD PTR [edi+184]
	cmp	ebx, DWORD PTR [edi+188]
	jbe	SHORT $LN158@getNextCom
	call	__invalid_parameter_noinfo
$LN158@getNextCom:
	mov	edi, DWORD PTR [edi+172]
	npad	3

; 1389 : 
; 1390 : 			assert(currentBank->front() == useThisCommand);
; 1391 : 
; 1392 : 			//Command *tempCommand = const_cast<Command*>(currentBank->front());
; 1393 : 
; 1394 : 			for (;currentBank != bankEnd;currentBank++)

$LL175@getNextCom:
	test	edi, edi
	je	SHORT $LN187@getNextCom
	cmp	edi, DWORD PTR _bankEnd$219466[esp+32]
	je	SHORT $LN188@getNextCom
$LN187@getNextCom:
	call	__invalid_parameter_noinfo
$LN188@getNextCom:
	cmp	ebx, esi
	je	$LN5@getNextCom

; 1395 : 			{				
; 1396 : 				assert(currentBank->front() != NULL);
; 1397 : 				if (!currentBank->front()->isRefresh())

	test	edi, edi
	jne	SHORT $LN338@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN208@getNextCom:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN199@getNextCom
	call	__invalid_parameter_noinfo
$LN199@getNextCom:
	mov	ecx, DWORD PTR [ebx+36]
	sub	ecx, DWORD PTR [ebx+32]
	sar	ecx, 2
	cmp	DWORD PTR [ebx+12], ecx
	jb	SHORT $LN215@getNextCom
	call	__invalid_parameter_noinfo
$LN215@getNextCom:

; 1398 : 					assert(currentBank->front()->isRefresh());
; 1399 : 
; 1400 : 				currentBank->pop();

	test	edi, edi
	jne	SHORT $LN337@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN235@getNextCom:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN226@getNextCom
	call	__invalid_parameter_noinfo
$LN226@getNextCom:
	lea	esi, DWORD PTR [ebx+8]
	call	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop
	test	edi, edi
	jne	SHORT $LN336@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN182@getNextCom:

; 1389 : 
; 1390 : 			assert(currentBank->front() == useThisCommand);
; 1391 : 
; 1392 : 			//Command *tempCommand = const_cast<Command*>(currentBank->front());
; 1393 : 
; 1394 : 			for (;currentBank != bankEnd;currentBank++)

	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN173@getNextCom
	call	__invalid_parameter_noinfo
$LN173@getNextCom:
	mov	esi, DWORD PTR $T429216[esp+32]
	add	ebx, 152				; 00000098H
	jmp	SHORT $LL175@getNextCom
$LN341@getNextCom:

; 1382 : 		{		
; 1383 : 			if (!currentRank->refreshAllReady())

	mov	eax, DWORD PTR [eax]
	jmp	$LN102@getNextCom
$LN340@getNextCom:

; 1384 : 				assert(currentRank->refreshAllReady());
; 1385 : 
; 1386 : 			vector<Bank>::iterator bankEnd = currentRank->bank.end();

	mov	eax, DWORD PTR [ebx]
	jmp	$LN118@getNextCom
$LN339@getNextCom:

; 1387 : 
; 1388 : 			vector<Bank>::iterator currentBank = currentRank->bank.begin();

	mov	ebx, DWORD PTR [ebx]
	jmp	$LN150@getNextCom
$LN338@getNextCom:

; 1395 : 			{				
; 1396 : 				assert(currentBank->front() != NULL);
; 1397 : 				if (!currentBank->front()->isRefresh())

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN208@getNextCom
$LN337@getNextCom:

; 1398 : 					assert(currentBank->front()->isRefresh());
; 1399 : 
; 1400 : 				currentBank->pop();

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN235@getNextCom
$LN336@getNextCom:

; 1389 : 
; 1390 : 			assert(currentBank->front() == useThisCommand);
; 1391 : 
; 1392 : 			//Command *tempCommand = const_cast<Command*>(currentBank->front());
; 1393 : 
; 1394 : 			for (;currentBank != bankEnd;currentBank++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN182@getNextCom
$LN5@getNextCom:

; 1401 : 			}
; 1402 : 
; 1403 : 			return const_cast<Command*>(useThisCommand);

	mov	eax, DWORD PTR _useThisCommand$[ebp]

; 1431 : 		}
; 1432 : 	}
; 1433 : 	else
; 1434 : 	{
; 1435 : 		return NULL;
; 1436 : 	}
; 1437 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN9@getNextCom:

; 1404 : 		}
; 1405 : 		else
; 1406 : 		{			
; 1407 : 			assert((useThisCommand->isPrecharge() && systemConfig.getRowBufferManagementPolicy() == OPEN_PAGE) ||
; 1408 : 				(currentRank->bank[useThisCommand->getAddress().getBank()].front() == useThisCommand));
; 1409 : 
; 1410 : 			vector<Bank>::iterator currentBank = currentRank->bank.begin() + useThisCommand->getAddress().getBank();

	mov	ebx, DWORD PTR [eax+64]
	mov	eax, DWORD PTR __Tmp$428952[esp+32]
	test	eax, eax
	jne	$LN335@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN257@getNextCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN248@getNextCom
	call	__invalid_parameter_noinfo
$LN248@getNextCom:
	mov	esi, DWORD PTR [edi+184]
	cmp	esi, DWORD PTR [edi+188]
	jbe	SHORT $LN265@getNextCom
	call	__invalid_parameter_noinfo
$LN265@getNextCom:
	mov	edx, DWORD PTR [edi+172]
	lea	eax, DWORD PTR _currentBank$219489[esp+32]
	push	eax
	mov	ecx, ebx
	lea	eax, DWORD PTR $T428802[esp+36]
	mov	DWORD PTR $T428802[esp+36], edx
	mov	DWORD PTR $T428802[esp+40], esi
	call	??H?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+

; 1411 : 
; 1412 : 			assert(currentBank->front() == useThisCommand);
; 1413 : 
; 1414 : 			Command *tempCommand = currentBank->pop();

	mov	eax, DWORD PTR _currentBank$219489[esp+32]
	test	eax, eax
	jne	$LN334@getNextCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN289@getNextCom:
	mov	esi, DWORD PTR _currentBank$219489[esp+36]
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN280@getNextCom
	call	__invalid_parameter_noinfo
$LN280@getNextCom:
	add	esi, 8
	call	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop

; 1415 : 
; 1416 : 			assert(tempCommand && tempCommand == useThisCommand);
; 1417 : 
; 1418 : 			if ((systemConfig.getRowBufferManagementPolicy() == OPEN_PAGE_AGGRESSIVE) &&
; 1419 : 				useThisCommand->isReadOrWrite() &&
; 1420 : 				!currentBank->isEmpty() && 
; 1421 : 				currentBank->isHighUtilization() &&
; 1422 : 				currentBank->front()->isBasicPrecharge())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	cmp	DWORD PTR [edx+328], 2
	mov	edi, eax
	jne	$LN15@getNextCom
	mov	eax, DWORD PTR _useThisCommand$[ebp]
	mov	eax, DWORD PTR [eax+80]
	cmp	eax, 1
	je	SHORT $LN298@getNextCom
	cmp	eax, 2
	je	SHORT $LN298@getNextCom
	cmp	eax, 3
	je	SHORT $LN298@getNextCom
	cmp	eax, 4
	jne	$LN15@getNextCom
$LN298@getNextCom:
	lea	esi, DWORD PTR _currentBank$219489[esp+32]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN15@getNextCom
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, DWORD PTR [eax+32]
	sar	ecx, 2
	shr	ecx, 1
	cmp	DWORD PTR [eax+8], ecx
	jbe	SHORT $LN15@getNextCom
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	cmp	DWORD PTR [eax+80], 6
	jne	SHORT $LN15@getNextCom

; 1423 : 			{
; 1424 : 				assert(!tempCommand->isPrecharge());
; 1425 : 				tempCommand->setAutoPrecharge(true);

	mov	eax, DWORD PTR [edi+80]
	lea	ecx, DWORD PTR [eax-1]
	cmp	ecx, 3
	ja	SHORT $LN323@getNextCom
	jmp	DWORD PTR $LN347@getNextCom[ecx*4]
$LN335@getNextCom:

; 1404 : 		}
; 1405 : 		else
; 1406 : 		{			
; 1407 : 			assert((useThisCommand->isPrecharge() && systemConfig.getRowBufferManagementPolicy() == OPEN_PAGE) ||
; 1408 : 				(currentRank->bank[useThisCommand->getAddress().getBank()].front() == useThisCommand));
; 1409 : 
; 1410 : 			vector<Bank>::iterator currentBank = currentRank->bank.begin() + useThisCommand->getAddress().getBank();

	mov	eax, DWORD PTR [eax]
	jmp	$LN257@getNextCom
$LN334@getNextCom:

; 1411 : 
; 1412 : 			assert(currentBank->front() == useThisCommand);
; 1413 : 
; 1414 : 			Command *tempCommand = currentBank->pop();

	mov	eax, DWORD PTR [eax]
	jmp	$LN289@getNextCom

; 1423 : 			{
; 1424 : 				assert(!tempCommand->isPrecharge());
; 1425 : 				tempCommand->setAutoPrecharge(true);

$LN324@getNextCom:
	xor	edx, edx
	cmp	eax, 3
	sete	dl
	lea	edx, DWORD PTR [edx+edx+2]
	mov	DWORD PTR [edi+80], edx
$LN323@getNextCom:

; 1426 : 				assert(currentBank->front()->isBasicPrecharge());
; 1427 : 				delete currentBank->pop();

	lea	esi, DWORD PTR _currentBank$219489[esp+32]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	lea	esi, DWORD PTR [eax+8]
	call	?pop@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::pop
	test	eax, eax
	je	SHORT $LN15@getNextCom
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx]
	push	1
	call	eax
$LN15@getNextCom:

; 1428 : 			}
; 1429 : 
; 1430 : 			return tempCommand;

	mov	eax, edi

; 1431 : 		}
; 1432 : 	}
; 1433 : 	else
; 1434 : 	{
; 1435 : 		return NULL;
; 1436 : 	}
; 1437 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN11@getNextCom:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN347@getNextCom:
	DD	$LN324@getNextCom
	DD	$LN323@getNextCom
	DD	$LN324@getNextCom
	DD	$LN323@getNextCom
?getNextCommand@Channel@DRAMsimII@@IAEPAVCommand@2@PBV32@@Z ENDP ; DRAMsimII::Channel::getNextCommand
_TEXT	ENDS
PUBLIC	?setReadWriteType@Channel@DRAMsimII@@QBE?AW4TransactionType@Transaction@2@H@Z ; DRAMsimII::Channel::setReadWriteType
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_readCount$ = -20					; size = 4
$T429951 = -16						; size = 4
$T430009 = -12						; size = 4
_bankEnd$ = -8						; size = 8
_writeCount$ = 8					; size = 4
_rankID$ = 8						; size = 4
?setReadWriteType@Channel@DRAMsimII@@QBE?AW4TransactionType@Transaction@2@H@Z PROC ; DRAMsimII::Channel::setReadWriteType
; _this$ = eax

; 470  : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _rankID$[esp+24]
	push	esi
	mov	esi, eax

; 471  : 	unsigned readCount = 0;
; 472  : 	unsigned writeCount = 0;
; 473  : 	unsigned emptyCount = 0;
; 474  : 
; 475  : 	vector<Bank>::const_iterator currentBank = rank[rankID].bank.begin();

	mov	ecx, DWORD PTR [esi+384]
	sub	ecx, DWORD PTR [esi+380]
	xor	eax, eax
	mov	DWORD PTR _readCount$[esp+32], eax
	mov	DWORD PTR _writeCount$[esp+28], eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	edi
	cmp	ebp, eax
	jb	SHORT $LN13@setReadWri
	call	__invalid_parameter_noinfo
$LN13@setReadWri:
	mov	ecx, DWORD PTR [esi+380]
	mov	ebx, ebp
	imul	ebx, 200				; 000000c8H
	mov	eax, DWORD PTR [ecx+ebx+184]
	lea	edi, DWORD PTR [ecx+ebx+172]
	mov	DWORD PTR $T429951[esp+36], eax
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN21@setReadWri
	call	__invalid_parameter_noinfo
$LN21@setReadWri:

; 476  : 	vector<Bank>::const_iterator bankEnd = rank[rankID].bank.end();

	mov	ecx, DWORD PTR [esi+384]
	sub	ecx, DWORD PTR [esi+380]
	mov	edi, DWORD PTR [edi]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	jb	SHORT $LN32@setReadWri
	call	__invalid_parameter_noinfo
$LN32@setReadWri:
	mov	ecx, DWORD PTR [esi+380]
	mov	eax, DWORD PTR [ebx+ecx+188]
	lea	esi, DWORD PTR [ebx+ecx+172]
	mov	DWORD PTR $T430009[esp+36], eax
	cmp	DWORD PTR [esi+12], eax
	jbe	SHORT $LN40@setReadWri
	call	__invalid_parameter_noinfo
$LN40@setReadWri:
	mov	edx, DWORD PTR [esi]
	mov	ebx, DWORD PTR $T429951[esp+36]
	mov	DWORD PTR _bankEnd$[esp+36], edx
	add	ebx, 32					; 00000020H
	npad	2

; 477  : 
; 478  : 	for(; currentBank != bankEnd; currentBank++)

$LL55@setReadWri:
	test	edi, edi
	je	SHORT $LN67@setReadWri
	cmp	edi, DWORD PTR _bankEnd$[esp+36]
	je	SHORT $LN68@setReadWri
$LN67@setReadWri:
	call	__invalid_parameter_noinfo
$LN68@setReadWri:
	lea	ebp, DWORD PTR [ebx-32]
	cmp	ebp, DWORD PTR $T430009[esp+36]
	je	$LN8@setReadWri

; 479  : 	{
; 480  : 		if (const Command *currentCommand = currentBank->front())

	test	edi, edi
	jne	SHORT $LN137@setReadWri
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN86@setReadWri:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN77@setReadWri
	call	__invalid_parameter_noinfo
$LN77@setReadWri:
	mov	eax, DWORD PTR [ebx+4]
	sub	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR [ebx-20]
	sar	eax, 2
	cmp	esi, eax
	jb	SHORT $LN93@setReadWri
	call	__invalid_parameter_noinfo
$LN93@setReadWri:
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+esi*4]
	test	eax, eax
	je	SHORT $LN9@setReadWri

; 481  : 		{
; 482  : 			if (currentCommand->isActivate())

	mov	ecx, DWORD PTR [eax+80]
	test	ecx, ecx
	je	SHORT $LN100@setReadWri
	cmp	ecx, 8
	jne	SHORT $LN140@setReadWri
$LN100@setReadWri:

; 483  : 			{
; 484  : 				currentCommand = currentBank->read(1);

	test	edi, edi
	jne	SHORT $LN136@setReadWri
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN113@setReadWri:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN104@setReadWri
	call	__invalid_parameter_noinfo
$LN104@setReadWri:
	cmp	DWORD PTR [ebx-24], 1
	jle	SHORT $LN119@setReadWri
	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx-20]
	sar	ecx, 2
	inc	eax
	xor	edx, edx
	div	ecx
	mov	esi, edx
	cmp	esi, ecx
	jb	SHORT $LN125@setReadWri
	call	__invalid_parameter_noinfo
$LN125@setReadWri:
	mov	edx, DWORD PTR [ebx]
	mov	esi, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN118@setReadWri
$LN137@setReadWri:

; 479  : 	{
; 480  : 		if (const Command *currentCommand = currentBank->front())

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN86@setReadWri
$LN136@setReadWri:

; 483  : 			{
; 484  : 				currentCommand = currentBank->read(1);

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN113@setReadWri
$LN119@setReadWri:
	xor	esi, esi
$LN118@setReadWri:
	mov	eax, esi
$LN140@setReadWri:

; 485  : 				assert(currentCommand && currentCommand->isReadOrWrite());
; 486  : 			}
; 487  : 
; 488  : 			if (currentCommand->isRead())

	mov	eax, DWORD PTR [eax+80]
	mov	ecx, 1
	cmp	eax, ecx
	je	SHORT $LN132@setReadWri
	cmp	eax, 2
	jne	SHORT $LN5@setReadWri
$LN132@setReadWri:

; 489  : 			{
; 490  : 				readCount++;

	add	DWORD PTR _readCount$[esp+36], ecx

; 491  : 			}
; 492  : 			else

	jmp	SHORT $LN9@setReadWri
$LN5@setReadWri:

; 493  : 			{
; 494  : 				writeCount++;

	add	DWORD PTR _writeCount$[esp+32], ecx
$LN9@setReadWri:

; 477  : 
; 478  : 	for(; currentBank != bankEnd; currentBank++)

	test	edi, edi
	jne	SHORT $LN135@setReadWri
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN62@setReadWri:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN53@setReadWri
	call	__invalid_parameter_noinfo
$LN53@setReadWri:
	add	ebx, 152				; 00000098H
	jmp	$LL55@setReadWri
$LN135@setReadWri:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN62@setReadWri
$LN8@setReadWri:

; 495  : 			}
; 496  : 		}
; 497  : 		else
; 498  : 		{
; 499  : 			emptyCount++;
; 500  : 		}
; 501  : 	}
; 502  : 
; 503  : 	DEBUG_LOG("Rank[" << rankID << "] Read[" << readCount << "] Write[" << writeCount << "] Empty[" << emptyCount << "]");
; 504  : 
; 505  : 	if (readCount >= writeCount)

	mov	eax, DWORD PTR _writeCount$[esp+32]
	cmp	DWORD PTR _readCount$[esp+36], eax
	pop	edi
	pop	esi
	sbb	eax, eax
	pop	ebp
	add	eax, 2
	pop	ebx

; 506  : 		return Transaction::READ_TRANSACTION;
; 507  : 	else
; 508  : 		return Transaction::WRITE_TRANSACTION;
; 509  : }

	add	esp, 20					; 00000014H
	ret	4
?setReadWriteType@Channel@DRAMsimII@@QBE?AW4TransactionType@Transaction@2@H@Z ENDP ; DRAMsimII::Channel::setReadWriteType
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Rank@DRAMsimII@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Rank@DRAMsimII@@QAE@XZ$0
__ehfuncinfo$??1Rank@DRAMsimII@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1Rank@DRAMsimII@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1Rank@DRAMsimII@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1Rank@DRAMsimII@@QAE@XZ PROC				; DRAMsimII::Rank::~Rank, COMDAT
	push	-1
	push	__ehhandler$??1Rank@DRAMsimII@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	lea	eax, DWORD PTR [esi+172]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	??1?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::~vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >
	xor	ecx, ecx
	cmp	DWORD PTR [esi+164], ecx
	jbe	SHORT $LN9@Rank
	mov	edx, 8
	npad	7
$LL14@Rank:
	add	DWORD PTR [esi+156], edx
	mov	eax, DWORD PTR [esi+156]
	inc	ecx
	cmp	eax, DWORD PTR [esi+152]
	jne	SHORT $LN27@Rank
	mov	eax, DWORD PTR [esi+148]
	mov	DWORD PTR [esi+156], eax
$LN27@Rank:
	cmp	ecx, DWORD PTR [esi+164]
	jb	SHORT $LL14@Rank
$LN9@Rank:
	mov	esi, DWORD PTR [esi+148]
	test	esi, esi
	je	SHORT $LN24@Rank
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Rank:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Rank@DRAMsimII@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 148				; 00000094H
	jmp	??1?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAE@XZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::~circular_buffer<__int64,std::allocator<__int64> >
__ehhandler$??1Rank@DRAMsimII@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Rank@DRAMsimII@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Rank@DRAMsimII@@QAE@XZ ENDP				; DRAMsimII::Rank::~Rank
; Function compile flags: /Ogtpy
;	COMDAT ??_Gthread_data_base@detail@boost@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gthread_data_base@detail@boost@@UAEPAXI@Z PROC	; boost::detail::thread_data_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7thread_data_base@detail@boost@@6B@
	mov	eax, DWORD PTR [esi+12]
	push	edi
	mov	edi, DWORD PTR __imp__CloseHandle@4
	test	eax, eax
	je	SHORT $LN8@scalar@66
	cmp	eax, -1
	je	SHORT $LN8@scalar@66
	push	eax
	call	edi
$LN8@scalar@66:
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN13@scalar@66
	cmp	eax, -1
	je	SHORT $LN13@scalar@66
	push	eax
	call	edi
$LN13@scalar@66:
	test	BYTE PTR ___flags$[esp+4], 1
	je	SHORT $LN16@scalar@66
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN16@scalar@66:
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??_Gthread_data_base@detail@boost@@UAEPAXI@Z ENDP	; boost::detail::thread_data_base::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GRank@DRAMsimII@@QAEPAXI@Z
_TEXT	SEGMENT
??_GRank@DRAMsimII@@QAEPAXI@Z PROC			; DRAMsimII::Rank::`scalar deleting destructor', COMDAT
; _this$ = esi
	push	ecx
	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	mov	eax, esi
	pop	ecx
	ret	0
??_GRank@DRAMsimII@@QAEPAXI@Z ENDP			; DRAMsimII::Rank::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@VRank@DRAMsimII@@@std@@YAXPAVRank@DRAMsimII@@@Z
_TEXT	SEGMENT
??$_Destroy@VRank@DRAMsimII@@@std@@YAXPAVRank@DRAMsimII@@@Z PROC ; std::_Destroy<DRAMsimII::Rank>, COMDAT
; __Ptr$ = eax

; 58   : 	{	// destroy object at _Ptr

	push	ecx

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	push	eax
	call	??1Rank@DRAMsimII@@QAE@XZ
	pop	ecx

; 60   : 	}

	ret	0
??$_Destroy@VRank@DRAMsimII@@@std@@YAXPAVRank@DRAMsimII@@@Z ENDP ; std::_Destroy<DRAMsimII::Rank>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@@Z PROC ; std::allocator<DRAMsimII::Rank>::destroy, COMDAT
; __Ptr$ = eax

; 159  : 		{	// destroy object at _Ptr

	push	ecx

; 160  : 		_Destroy(_Ptr);

	push	eax
	call	??1Rank@DRAMsimII@@QAE@XZ
	pop	ecx

; 161  : 		}

	ret	0
?destroy@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@@Z ENDP ; std::allocator<DRAMsimII::Rank>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::Rank> >, COMDAT
; __First$ = eax
; __Last$ = edi

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ecx
	push	esi
	mov	esi, eax

; 233  : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra@12
$LL3@Destroy_ra@12:

; 234  : 		_Al.destroy(_First);

	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	esi, 200				; 000000c8H
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra@12
$LN1@Destroy_ra@12:

; 235  : 	}

	pop	esi
	pop	ecx
	ret	0
??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@@Z PROC ; std::_Destroy_range<std::allocator<DRAMsimII::Rank> >, COMDAT
; __First$ = eax
; __Last$ = edi

; 224  : 	{	// destroy [_First, _Last)

	push	esi
	mov	esi, eax

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	cmp	esi, edi
	je	SHORT $LN5@Destroy_ra@13
$LL7@Destroy_ra@13:
	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	esi, 200				; 000000c8H
	cmp	esi, edi
	jne	SHORT $LL7@Destroy_ra@13
$LN5@Destroy_ra@13:

; 226  : 	}

	pop	esi
	ret	0
??$_Destroy_range@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@0AAV?$allocator@VRank@DRAMsimII@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXPAVRank@DRAMsimII@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXPAVRank@DRAMsimII@@0@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Destroy, COMDAT
; __First$ = eax
; __Last$ = edi

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	esi
	mov	esi, eax

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	cmp	esi, edi
	je	SHORT $LN7@Destroy@11
$LL9@Destroy@11:
	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	esi, 200				; 000000c8H
	cmp	esi, edi
	jne	SHORT $LL9@Destroy@11
$LN7@Destroy@11:

; 1120 : 		}

	pop	esi
	ret	0
?_Destroy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXPAVRank@DRAMsimII@@0@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Destroy
_TEXT	ENDS
PUBLIC	??8Channel@DRAMsimII@@QBE_NABV01@@Z		; DRAMsimII::Channel::operator==
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
_rhs$ = 12						; size = 4
??8Channel@DRAMsimII@@QBE_NABV01@@Z PROC		; DRAMsimII::Channel::operator==

; 3046 : {

	push	ebx
	mov	ebx, DWORD PTR _rhs$[esp]
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]

; 3047 : 	return (time == rhs.time && lastCommandIssueTime == rhs.lastCommandIssueTime && 
; 3048 : 		timingSpecification == rhs.timingSpecification && transactionQueue == rhs.transactionQueue && 
; 3049 : 		((lastCommand == NULL && rhs.lastCommand == NULL) || (*lastCommand == *(rhs.lastCommand)) )
; 3050 : 		&& systemConfig == rhs.systemConfig && 
; 3051 : 		statistics == rhs.statistics && powerModel == rhs.powerModel && channelID == rhs.channelID 
; 3052 : 		&& rank == rhs.rank && refreshCounter == rhs.refreshCounter);

	mov	eax, DWORD PTR [ebp+8]
	push	esi
	push	edi
	cmp	eax, DWORD PTR [ebx+8]
	jne	$LN7@operator@287
	mov	ecx, DWORD PTR [ebp+12]
	cmp	ecx, DWORD PTR [ebx+12]
	jne	$LN7@operator@287
	mov	edx, DWORD PTR [ebp+16]
	cmp	edx, DWORD PTR [ebx+16]
	jne	$LN7@operator@287
	mov	eax, DWORD PTR [ebp+20]
	cmp	eax, DWORD PTR [ebx+20]
	jne	$LN7@operator@287
	lea	eax, DWORD PTR [ebx+28]
	lea	ecx, DWORD PTR [ebp+28]
	call	??8TimingSpecification@DRAMsimII@@QBE_NABV01@@Z ; DRAMsimII::TimingSpecification::operator==
	test	al, al
	je	$LN7@operator@287
	lea	ecx, DWORD PTR [ebx+112]
	push	ecx
	lea	edx, DWORD PTR [ebp+112]
	push	edx
	call	??8?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBE_NABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator==
	test	al, al
	je	$LN7@operator@287
	mov	ecx, DWORD PTR [ebp+24]
	test	ecx, ecx
	jne	SHORT $LN4@operator@287
	cmp	DWORD PTR [ebx+24], ecx
	je	SHORT $LN5@operator@287
$LN4@operator@287:
	mov	eax, DWORD PTR [ebx+24]
	call	??8Command@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Command::operator==
	test	al, al
	je	$LN7@operator@287
$LN5@operator@287:
	mov	eax, DWORD PTR [ebx+176]
	mov	ecx, DWORD PTR [ebp+176]
	call	??8SystemConfiguration@DRAMsimII@@QBE_NABV01@@Z ; DRAMsimII::SystemConfiguration::operator==
	test	al, al
	je	SHORT $LN7@operator@287
	mov	eax, DWORD PTR [ebp+180]
	mov	edi, DWORD PTR [ebx+180]
	push	eax
	call	??8Statistics@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Statistics::operator==
	test	al, al
	je	SHORT $LN7@operator@287
	lea	esi, DWORD PTR [ebx+184]
	lea	edi, DWORD PTR [ebp+184]
	call	??8PowerConfig@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::PowerConfig::operator==
	test	al, al
	je	SHORT $LN7@operator@287
	mov	ecx, DWORD PTR [ebp+360]
	cmp	ecx, DWORD PTR [ebx+360]
	jne	SHORT $LN7@operator@287
	lea	edx, DWORD PTR [ebx+368]
	push	edx
	lea	esi, DWORD PTR [ebp+368]
	call	??$?8VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YA_NABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@0@0@Z ; std::operator==<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	add	esp, 4
	test	al, al
	je	SHORT $LN7@operator@287
	add	ebx, 152				; 00000098H
	push	ebx
	lea	esi, DWORD PTR [ebp+152]
	call	??$?8_JV?$allocator@_J@std@@@std@@YA_NABV?$vector@_JV?$allocator@_J@std@@@0@0@Z ; std::operator==<__int64,std::allocator<__int64> >
	add	esp, 4
	test	al, al
	je	SHORT $LN7@operator@287
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1
	pop	ebx

; 3053 : }

	ret	8
$LN7@operator@287:
	pop	edi
	pop	esi
	pop	ebp

; 3047 : 	return (time == rhs.time && lastCommandIssueTime == rhs.lastCommandIssueTime && 
; 3048 : 		timingSpecification == rhs.timingSpecification && transactionQueue == rhs.transactionQueue && 
; 3049 : 		((lastCommand == NULL && rhs.lastCommand == NULL) || (*lastCommand == *(rhs.lastCommand)) )
; 3050 : 		&& systemConfig == rhs.systemConfig && 
; 3051 : 		statistics == rhs.statistics && powerModel == rhs.powerModel && channelID == rhs.channelID 
; 3052 : 		&& rank == rhs.rank && refreshCounter == rhs.refreshCounter);

	xor	eax, eax
	pop	ebx

; 3053 : }

	ret	8
??8Channel@DRAMsimII@@QBE_NABV01@@Z ENDP		; DRAMsimII::Channel::operator==
_TEXT	ENDS
PUBLIC	?resetToTime@Channel@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Channel::resetToTime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_this$ = 8						; size = 4
_time$ = 12						; size = 8
?resetToTime@Channel@DRAMsimII@@QAEX_J@Z PROC		; DRAMsimII::Channel::resetToTime

; 914  : 	lastCommandIssueTime = time - timingSpecification.tCMD();

	mov	ecx, DWORD PTR _time$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _this$[esp]
	mov	eax, DWORD PTR [ebx+44]
	push	ebp
	push	esi
	cdq
	mov	esi, ecx
	sub	esi, eax
	mov	eax, DWORD PTR _time$[esp+12]
	push	edi
	mov	edi, eax
	sbb	edi, edx
	mov	DWORD PTR [ebx+16], esi
	mov	DWORD PTR [ebx+20], edi

; 915  : 	this->time = time;

	mov	DWORD PTR [ebx+8], ecx
	mov	DWORD PTR [ebx+12], eax

; 916  : 	powerModel.resetToTime(time);

	mov	DWORD PTR [ebx+352], ecx
	mov	DWORD PTR [ebx+356], eax

; 917  : 	// adjust the start time of the refreshes to match the new time
; 918  : 	for (vector<tick>::iterator i = refreshCounter.begin(); i != refreshCounter.end(); i++)

	mov	esi, DWORD PTR [ebx+164]
	cmp	esi, DWORD PTR [ebx+168]
	jbe	SHORT $LN18@resetToTim@3
	call	__invalid_parameter_noinfo
$LN18@resetToTim@3:
	mov	edi, DWORD PTR [ebx+152]
	npad	3
$LL35@resetToTim@3:
	mov	ebp, DWORD PTR [ebx+168]
	cmp	DWORD PTR [ebx+164], ebp
	jbe	SHORT $LN50@resetToTim@3
	call	__invalid_parameter_noinfo
$LN50@resetToTim@3:
	mov	eax, DWORD PTR [ebx+152]
	test	edi, edi
	je	SHORT $LN63@resetToTim@3
	cmp	edi, eax
	je	SHORT $LN64@resetToTim@3
$LN63@resetToTim@3:
	call	__invalid_parameter_noinfo
$LN64@resetToTim@3:
	cmp	esi, ebp
	je	SHORT $LN4@resetToTim@3

; 919  : 	{
; 920  : 		*i = *i + time;

	test	edi, edi
	jne	SHORT $LN179@resetToTim@3
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN82@resetToTim@3:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN73@resetToTim@3
	call	__invalid_parameter_noinfo
$LN73@resetToTim@3:
	test	edi, edi
	jne	SHORT $LN178@resetToTim@3
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN96@resetToTim@3:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN87@resetToTim@3
	call	__invalid_parameter_noinfo
$LN87@resetToTim@3:
	mov	eax, DWORD PTR _time$[esp+12]
	add	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR _time$[esp+16]
	adc	DWORD PTR [esi+4], ecx
	test	edi, edi
	jne	SHORT $LN177@resetToTim@3
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN42@resetToTim@3:

; 917  : 	// adjust the start time of the refreshes to match the new time
; 918  : 	for (vector<tick>::iterator i = refreshCounter.begin(); i != refreshCounter.end(); i++)

	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN33@resetToTim@3
	call	__invalid_parameter_noinfo
$LN33@resetToTim@3:
	add	esi, 8
	jmp	SHORT $LL35@resetToTim@3
$LN179@resetToTim@3:

; 919  : 	{
; 920  : 		*i = *i + time;

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN82@resetToTim@3
$LN178@resetToTim@3:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN96@resetToTim@3
$LN177@resetToTim@3:

; 917  : 	// adjust the start time of the refreshes to match the new time
; 918  : 	for (vector<tick>::iterator i = refreshCounter.begin(); i != refreshCounter.end(); i++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN42@resetToTim@3
$LN4@resetToTim@3:

; 921  : 	}
; 922  : 	for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	mov	edi, DWORD PTR [ebx+380]
	cmp	edi, DWORD PTR [ebx+384]
	jbe	SHORT $LN104@resetToTim@3
	call	__invalid_parameter_noinfo
$LN104@resetToTim@3:
	mov	esi, DWORD PTR [ebx+368]
$LL121@resetToTim@3:
	mov	ebp, DWORD PTR [ebx+384]
	cmp	DWORD PTR [ebx+380], ebp
	jbe	SHORT $LN136@resetToTim@3
	call	__invalid_parameter_noinfo
$LN136@resetToTim@3:
	mov	eax, DWORD PTR [ebx+368]
	test	esi, esi
	je	SHORT $LN149@resetToTim@3
	cmp	esi, eax
	je	SHORT $LN150@resetToTim@3
$LN149@resetToTim@3:
	call	__invalid_parameter_noinfo
$LN150@resetToTim@3:
	cmp	edi, ebp
	je	SHORT $LN1@resetToTim@3

; 923  : 	{
; 924  : 		i->resetToTime(time);

	test	esi, esi
	jne	SHORT $LN176@resetToTim@3
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN170@resetToTim@3:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN161@resetToTim@3
	call	__invalid_parameter_noinfo
$LN161@resetToTim@3:
	mov	edx, DWORD PTR _time$[esp+16]
	mov	eax, DWORD PTR _time$[esp+12]
	push	edx
	push	eax
	call	?resetToTime@Rank@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Rank::resetToTime
	test	esi, esi
	jne	SHORT $LN175@resetToTim@3
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN128@resetToTim@3:

; 921  : 	}
; 922  : 	for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN119@resetToTim@3
	call	__invalid_parameter_noinfo
$LN119@resetToTim@3:
	add	edi, 200				; 000000c8H
	jmp	SHORT $LL121@resetToTim@3
$LN176@resetToTim@3:

; 923  : 	{
; 924  : 		i->resetToTime(time);

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN170@resetToTim@3
$LN175@resetToTim@3:

; 921  : 	}
; 922  : 	for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN128@resetToTim@3
$LN1@resetToTim@3:

; 925  : 	}
; 926  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	12					; 0000000cH
?resetToTime@Channel@DRAMsimII@@QAEX_J@Z ENDP		; DRAMsimII::Channel::resetToTime
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
xdata$x	ENDS
;	COMDAT ?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T534496 = -80						; size = 28
$T534495 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Xlen, COMDAT

; 1210 : 		{	// report length error

	push	-1
	push	__ehhandler$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1211 : 		_THROW(length_error, "deque<T> too long");

	push	17					; 00000011H
	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T534496[esp+92]
	mov	DWORD PTR $T534496[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T534496[esp+112], 0
	mov	BYTE PTR $T534496[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T534496[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T534495[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T534495[esp+88]
	push	ecx
	mov	DWORD PTR $T534495[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@10:
$LN44@Xlen@10:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T534496[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T534657 = -80						; size = 28
$T534656 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ PROC	; std::vector<double,std::allocator<double> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T534657[esp+92]
	mov	DWORD PTR $T534657[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T534657[esp+112], 0
	mov	BYTE PTR $T534657[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T534657[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T534656[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T534656[esp+88]
	push	ecx
	mov	DWORD PTR $T534656[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@11:
$LN44@Xlen@11:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T534657[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ ENDP	; std::vector<double,std::allocator<double> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z
_TEXT	SEGMENT
__Tmp$227441 = -12					; size = 8
__Tmp$227431 = -12					; size = 8
_this$ = 8						; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z PROC ; std::vector<double,std::allocator<double> >::_Insert_n, COMDAT

; 1153 : 		{	// insert _Count * _Val at _Where

	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+12]

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR [ebx+12]
	push	ebp
	push	esi
	push	edi
	test	ecx, ecx
	jne	SHORT $LN29@Insert_n
	xor	ebp, ebp
	jmp	SHORT $LN205@Insert_n
$LN29@Insert_n:
	mov	ebp, DWORD PTR [ebx+20]
	sub	ebp, ecx
	sar	ebp, 3
$LN205@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)
; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	esi, DWORD PTR [ebx+16]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	mov	ecx, 536870911				; 1fffffffH
	sub	ecx, eax
	cmp	ecx, 1
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ ; std::vector<double,std::allocator<double> >::_Xlen
$LN208@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	inc	eax
	cmp	ebp, eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, ebp
	shr	ecx, 1
	mov	edx, 536870911				; 1fffffffH
	sub	edx, ecx
	cmp	edx, ebp
	jae	SHORT $LN17@Insert_n
	xor	ebp, ebp
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ebp, ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ebp, eax

; 1172 : 				_Capacity = size() + _Count;

	cmovb	ebp, eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, ebp
	call	?allocate@?$allocator@N@std@@QAEPANI@Z	; std::allocator<double>::allocate

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	esi, DWORD PTR __Where$[esp+28]
	sub	esi, DWORD PTR [ebx+12]
	mov	edi, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+24]
	fld	QWORD PTR [eax]
	sar	esi, 3
	fstp	QWORD PTR [edi+esi*8]

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+28]
	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 3
	test	eax, eax
	jbe	SHORT $LN102@Insert_n
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edi
	call	_memmove_s
	mov	edx, DWORD PTR __Where$[esp+44]
	add	esp, 16					; 00000010H
$LN102@Insert_n:

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [ebx+16]
	sub	eax, edx
	sar	eax, 3
	test	eax, eax
	jbe	SHORT $LN133@Insert_n
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	edx
	push	eax
	lea	ecx, DWORD PTR [edi+esi*8+8]
	push	ecx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN133@Insert_n:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [ebx+12]
	mov	esi, DWORD PTR [ebx+16]
	sub	esi, eax
	sar	esi, 3
	inc	esi

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN140@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN140@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	lea	edx, DWORD PTR [edi+ebp*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	eax, DWORD PTR [edi+esi*8]
	mov	DWORD PTR [ebx+20], edx
	mov	DWORD PTR [ebx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [ebx+12], edi

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edi, DWORD PTR __Where$[esp+28]
	mov	ecx, esi
	sub	ecx, edi
	sar	ecx, 3
	cmp	ecx, 1
	jae	SHORT $LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[esp+24]
	movsd	xmm0, QWORD PTR [edx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	edx, DWORD PTR [edi+8]
	mov	eax, esi
	movsd	QWORD PTR __Tmp$227431[esp+28], xmm0
	call	??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z ; std::vector<double,std::allocator<double> >::_Umove<double *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	esi, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR __Where$[esp+28]
	movsd	xmm0, QWORD PTR __Tmp$227431[esp+28]
	mov	edx, esi
	sub	edx, ecx
	sar	edx, 3
	mov	eax, 1
	sub	eax, edx
	je	SHORT $LN162@Insert_n
	lea	ecx, DWORD PTR [eax*8-5]
	shr	ecx, 2
	movsd	QWORD PTR [esi], xmm0
	lea	edi, DWORD PTR [esi+8]
	rep movsd
	mov	ecx, DWORD PTR __Where$[esp+28]
$LN162@Insert_n:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [ebx+16], 8
	mov	ebx, DWORD PTR [ebx+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR [ebx-8]
	mov	eax, ecx
	cmp	ecx, edx
	je	SHORT $LN190@Insert_n
$LL177@Insert_n:
	movsd	QWORD PTR [eax], xmm0
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL177@Insert_n

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[esp+24]
	movsd	xmm0, QWORD PTR [eax]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [esi-8]
	mov	edx, esi
	mov	eax, esi
	movsd	QWORD PTR __Tmp$227441[esp+28], xmm0
	call	??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z ; std::vector<double,std::allocator<double> >::_Umove<double *>
	mov	DWORD PTR [ebx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, edi
	mov	edi, DWORD PTR __Where$[esp+28]
	mov	ecx, esi
	call	??$_Unchecked_move_backward@PANPAN@stdext@@YAPANPAN00@Z ; stdext::_Unchecked_move_backward<double *,double *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR [eax+8]
	cmp	eax, ecx
	je	SHORT $LN190@Insert_n
	movsd	xmm0, QWORD PTR __Tmp$227441[esp+28]
$LL192@Insert_n:
	movsd	QWORD PTR [eax], xmm0
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL192@Insert_n
$LN190@Insert_n:

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
$LN207@Insert_n:
?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z ENDP ; std::vector<double,std::allocator<double> >::_Insert_n
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T535736 = -84						; size = 28
$T535735 = -56						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ PROC	; std::vector<float,std::allocator<float> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T535736[esp+100]
	mov	DWORD PTR $T535736[esp+124], 15		; 0000000fH
	mov	DWORD PTR $T535736[esp+120], 0
	mov	BYTE PTR $T535736[esp+104], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T535736[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T535735[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T535735[esp+96]
	push	ecx
	mov	DWORD PTR $T535735[esp+100], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@12:
$LN44@Xlen@12:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T535736[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-76]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ENDP	; std::vector<float,std::allocator<float> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T535896 = -84						; size = 28
$T535895 = -56						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T535896[esp+100]
	mov	DWORD PTR $T535896[esp+124], 15		; 0000000fH
	mov	DWORD PTR $T535896[esp+120], 0
	mov	BYTE PTR $T535896[esp+104], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T535896[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T535895[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T535895[esp+96]
	push	ecx
	mov	DWORD PTR $T535895[esp+100], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@13:
$LN44@Xlen@13:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T535896[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-76]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Newvec$226970 = -4					; size = 4
__Tmp$226995 = 8					; size = 4
__Tmp$226985 = 8					; size = 4
__Capacity$ = 8						; size = 4
_this$ = 8						; size = 4
__Where$ = 12						; size = 8
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; __Val$ = eax

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [ebx+12]
	push	ebp
	push	esi
	push	edi
	mov	esi, eax
	test	edx, edx
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN121@Insert_n@2
$LN29@Insert_n@2:
	mov	eax, DWORD PTR [ebx+20]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN121@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)
; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebp, DWORD PTR [ebx+16]
	mov	eax, ebp
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, 1
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN125@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	inc	eax
	cmp	ecx, eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	edx, ecx
	shr	edx, 1
	mov	edi, 1073741823				; 3fffffffH
	sub	edi, edx
	cmp	edi, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[esp+16], 0
	mov	ecx, DWORD PTR __Capacity$[esp+16]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, edx
	mov	DWORD PTR __Capacity$[esp+16], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, eax
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+16], eax
	mov	ecx, eax
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebp, DWORD PTR __Where$[esp+20]
	sub	ebp, DWORD PTR [ebx+12]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, esi
	sar	ebp, 2
	lea	edi, DWORD PTR [eax+ebp*4]
	mov	esi, 1
	mov	DWORD PTR __Newvec$226970[esp+20], eax
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+20]
	mov	ecx, DWORD PTR [ebx+12]
	mov	edi, DWORD PTR __Newvec$226970[esp+20]
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN79@Insert_n@2
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edi
	call	_memmove_s
	mov	edx, DWORD PTR __Where$[esp+36]
	add	esp, 16					; 00000010H
$LN79@Insert_n@2:

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [ebx+16]
	sub	eax, edx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN110@Insert_n@2
	add	eax, eax
	add	eax, eax
	push	eax
	push	edx
	push	eax
	lea	eax, DWORD PTR [edi+ebp*4+4]
	push	eax
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN110@Insert_n@2:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [ebx+12]
	mov	esi, DWORD PTR [ebx+16]
	sub	esi, eax
	sar	esi, 2
	inc	esi

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN117@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN117@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[esp+16]
	lea	edx, DWORD PTR [edi+ecx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	eax, DWORD PTR [edi+esi*4]
	mov	DWORD PTR [ebx+20], edx
	mov	DWORD PTR [ebx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [ebx+12], edi

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edi, DWORD PTR __Where$[esp+20]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR [esi]
	mov	ecx, ebp
	sub	ecx, edi
	sar	ecx, 2

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, ebp
	mov	DWORD PTR __Tmp$226985[esp+16], edx
	cmp	ecx, 1
	jae	SHORT $LN3@Insert_n@2
	lea	edx, DWORD PTR [edi+4]
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edi, DWORD PTR [ebx+16]
	mov	eax, edi
	sub	eax, DWORD PTR __Where$[esp+20]
	mov	esi, 1
	sar	eax, 2
	sub	esi, eax
	lea	edx, DWORD PTR __Tmp$226985[esp+16]
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [ebx+16], 4
	mov	ebx, DWORD PTR [ebx+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+20]
	lea	ecx, DWORD PTR __Tmp$226985[esp+16]
	push	ecx
	lea	ecx, DWORD PTR [ebx-4]

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 4

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [ebp-4]
	mov	edx, ebp
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
	mov	DWORD PTR [ebx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, edi
	mov	edi, DWORD PTR __Where$[esp+20]
	mov	ecx, ebp
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$226995[esp+16]
	push	eax
	mov	eax, DWORD PTR __Where$[esp+24]
	lea	ecx, DWORD PTR [eax+4]
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 4

; 1249 : 			}
; 1250 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	12					; 0000000cH
$LN123@Insert_n@2:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?_Growmap@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Myboff$ = -8						; size = 4
__Newmap$ = -4						; size = 4
__Count$ = 8						; size = 4
_this$ = 8						; size = 4
?_Growmap@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXI@Z PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Growmap, COMDAT

; 1225 : 		{	// grow map by _Count pointers

	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+8]

; 1226 : 		if (max_size() / _DEQUESIZ - _Mapsize < _Count)

	mov	eax, DWORD PTR [ebx+20]
	push	ebp
	mov	ecx, 268435455				; 0fffffffH
	mov	edx, 1
	sub	ecx, eax
	push	esi
	push	edi

; 1236 : 		_Mapptr _Myptr = _Newmap + _Myboff;
; 1237 : 
; 1238 : 		_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Myboff,
; 1239 : 			_Map + _Mapsize, _Myptr, this->_Almap);	// copy initial to end

	mov	DWORD PTR __Count$[esp+20], edx
	cmp	ecx, edx
	jae	SHORT $LN6@Growmap

; 1227 : 			_Xlen();	// result too long

	call	?_Xlen@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@KAXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Xlen
$LN157@Growmap:
$LN6@Growmap:

; 1228 : 
; 1229 : 		size_type _Inc = _Mapsize / 2;	// try to grow by 50%

	mov	ecx, eax
	shr	ecx, 1

; 1230 : 		if (_Inc < _DEQUEMAPSIZ)

	cmp	ecx, 8
	jae	SHORT $LN5@Growmap

; 1231 : 			_Inc = _DEQUEMAPSIZ;

	mov	ecx, 8

; 1232 : 		if (_Count < _Inc && _Mapsize <= max_size() / _DEQUESIZ - _Inc)

	jmp	SHORT $LN152@Growmap
$LN5@Growmap:
	cmp	ecx, 1
	jbe	SHORT $LN4@Growmap
$LN152@Growmap:
	mov	esi, 268435455				; 0fffffffH
	sub	esi, ecx
	cmp	eax, esi
	ja	SHORT $LN4@Growmap

; 1233 : 			_Count = _Inc;

	mov	edx, ecx
	mov	DWORD PTR __Count$[esp+20], ecx
$LN4@Growmap:

; 1234 : 		size_type _Myboff = _Myoff / _DEQUESIZ;

	mov	esi, DWORD PTR [ebx+24]

; 1235 : 		_Mapptr _Newmap = this->_Almap.allocate(_Mapsize + _Count);

	lea	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR __Myboff$[esp+24], esi
	call	?allocate@?$allocator@PAU?$pair@I_J@std@@@std@@QAEPAPAU?$pair@I_J@2@I@Z ; std::allocator<std::pair<unsigned int,__int64> *>::allocate

; 1236 : 		_Mapptr _Myptr = _Newmap + _Myboff;
; 1237 : 
; 1238 : 		_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Myboff,
; 1239 : 			_Map + _Mapsize, _Myptr, this->_Almap);	// copy initial to end

	mov	ecx, DWORD PTR [ebx+16]
	mov	DWORD PTR __Newmap$[esp+24], eax
	add	esi, esi
	add	esi, esi
	lea	edi, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ebx+20]
	add	eax, eax
	add	eax, eax
	lea	edx, DWORD PTR [esi+ecx]
	sub	eax, edx
	add	eax, ecx
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN33@Growmap
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN33@Growmap:

; 1240 : 		if (_Myboff <= _Count)

	mov	edx, DWORD PTR __Myboff$[esp+24]
	mov	eax, DWORD PTR __Count$[esp+20]
	cmp	edx, eax
	ja	SHORT $LN3@Growmap

; 1241 : 			{	// increment greater than offset of initial block
; 1242 : 			_Myptr = _STDEXT unchecked_uninitialized_copy(_Map,
; 1243 : 				_Map + _Myboff, _Myptr, this->_Almap);	// copy rest of old

	mov	eax, DWORD PTR [ebx+16]
	sar	esi, 2
	lea	ecx, DWORD PTR [esi*4]
	lea	edi, DWORD PTR [ecx+ebp]
	test	esi, esi
	jbe	SHORT $LN48@Growmap
	push	ecx
	push	eax
	push	ecx
	push	ebp
	call	_memmove_s
	mov	edx, DWORD PTR __Myboff$[esp+40]
	add	esp, 16					; 00000010H
$LN48@Growmap:

; 1244 : 			_STDEXT unchecked_uninitialized_fill_n(_Myptr, _Count - _Myboff,
; 1245 : 				(_Tptr)0, this->_Almap);	// clear suffix of new

	mov	ecx, DWORD PTR __Count$[esp+20]
	sub	ecx, edx
	je	SHORT $LN69@Growmap
	mov	edx, DWORD PTR __Myboff$[esp+24]
	xor	eax, eax
	rep stosd
$LN69@Growmap:

; 1246 : 			_STDEXT unchecked_uninitialized_fill_n(_Newmap, _Myboff,
; 1247 : 				(_Tptr)0, this->_Almap);	// clear prefix of new

	mov	ebp, DWORD PTR __Newmap$[esp+24]
	test	edx, edx
	jbe	SHORT $LN141@Growmap
	mov	ecx, edx
	mov	edi, ebp

; 1248 : 			}
; 1249 : 		else

	jmp	SHORT $LN156@Growmap
$LN3@Growmap:

; 1250 : 			{	// increment not greater than offset of initial block
; 1251 : 			_STDEXT unchecked_uninitialized_copy(_Map,
; 1252 : 				_Map + _Count, _Myptr, this->_Almap);	// copy more old

	mov	ecx, DWORD PTR [ebx+16]
	lea	edi, DWORD PTR [eax*4]
	mov	eax, edi
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN105@Growmap
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	ebp
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN105@Growmap:

; 1253 : 			_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Count,
; 1254 : 				_Map + _Myboff, _Newmap, this->_Almap);	// copy rest of old

	mov	eax, DWORD PTR [ebx+16]
	mov	ebp, DWORD PTR __Newmap$[esp+24]
	lea	ecx, DWORD PTR [edi+eax]
	sub	esi, ecx
	add	esi, eax
	sar	esi, 2
	lea	eax, DWORD PTR [esi*4]
	lea	edi, DWORD PTR [eax+ebp]
	test	esi, esi
	jbe	SHORT $LN120@Growmap
	push	eax
	push	ecx
	push	eax
	push	ebp
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN120@Growmap:

; 1255 : 			_STDEXT unchecked_uninitialized_fill_n(_Myptr, _Count,
; 1256 : 				(_Tptr)0, this->_Almap);	// clear rest to initial block

	mov	ecx, DWORD PTR __Count$[esp+20]
	test	ecx, ecx
	jbe	SHORT $LN141@Growmap
$LN156@Growmap:
	xor	eax, eax
	rep stosd
$LN141@Growmap:

; 1257 : 			}
; 1258 : 
; 1259 : 		_Destroy_range(_Map + _Myboff, _Map + _Mapsize, this->_Almap);
; 1260 : 		if (_Map)

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	SHORT $LN144@Growmap

; 1261 : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for old

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN144@Growmap:

; 1262 : 
; 1263 : 		_Map = _Newmap;	// point at new
; 1264 : 		_Mapsize += _Count;

	mov	edx, DWORD PTR __Count$[esp+20]
	add	DWORD PTR [ebx+20], edx

; 1265 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+16], ebp
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
$LN155@Growmap:
?_Growmap@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXI@Z ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Growmap
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T537232 = -80						; size = 28
$T537231 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T537232[esp+92]
	mov	DWORD PTR $T537232[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T537232[esp+112], 0
	mov	BYTE PTR $T537232[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T537232[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T537231[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T537231[esp+88]
	push	ecx
	mov	DWORD PTR $T537231[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@14:
$LN44@Xlen@14:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T537232[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T537393 = -80						; size = 28
$T537392 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ PROC	; std::vector<__int64,std::allocator<__int64> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T537393[esp+92]
	mov	DWORD PTR $T537393[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T537393[esp+112], 0
	mov	BYTE PTR $T537393[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T537393[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T537392[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T537392[esp+88]
	push	ecx
	mov	DWORD PTR $T537392[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@15:
$LN44@Xlen@15:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T537393[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-68]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ ENDP	; std::vector<__int64,std::allocator<__int64> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T537554 = -84						; size = 28
$T537553 = -56						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T537554[esp+100]
	mov	DWORD PTR $T537554[esp+124], 15		; 0000000fH
	mov	DWORD PTR $T537554[esp+120], 0
	mov	BYTE PTR $T537554[esp+104], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T537554[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T537553[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T537553[esp+96]
	push	ecx
	mov	DWORD PTR $T537553[esp+100], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@16:
$LN44@Xlen@16:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T537554[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-76]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@NV?$allocator@N@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@NV?$allocator@N@std@@@std@@IAE_NI@Z PROC	; std::vector<double,std::allocator<double> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1102 : 		{	// allocate array with _Capacity elements

	push	ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy@8

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ ; std::vector<double,std::allocator<double> >::_Xlen
$LN18@Buy@8:
$LN2@Buy@8:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@N@std@@QAEPANI@Z	; std::allocator<double>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	ecx

; 1115 : 		}

	ret	0
$LN17@Buy@8:
?_Buy@?$vector@NV?$allocator@N@std@@@std@@IAE_NI@Z ENDP	; std::vector<double,std::allocator<double> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@ABN@Z
_TEXT	SEGMENT
__Tmp$537962 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?insert@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@ABN@Z PROC ; std::vector<double,std::allocator<double> >::insert, COMDAT
; _this$ = eax

; 875  : 		{	// insert _Val at _Where

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR [esi+12]
	mov	ecx, eax
	sub	ecx, edi
	test	ecx, -8					; fffffff8H
	jne	SHORT $LN3@insert@12
	xor	ebx, ebx
	jmp	SHORT $LN4@insert@12
$LN3@insert@12:
	cmp	edi, eax
	jbe	SHORT $LN12@insert@12
	call	__invalid_parameter_noinfo
$LN12@insert@12:
	mov	ecx, DWORD PTR __Where$[esp+24]
	mov	eax, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN23@insert@12
	cmp	ecx, eax
	je	SHORT $LN24@insert@12
$LN23@insert@12:
	call	__invalid_parameter_noinfo
$LN24@insert@12:
	mov	ebx, DWORD PTR __Where$[esp+28]
	sub	ebx, edi
	sar	ebx, 3
$LN4@insert@12:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Where$[esp+28]
	mov	eax, DWORD PTR __Where$[esp+24]
	mov	ecx, DWORD PTR __Val$[esp+24]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z ; std::vector<double,std::allocator<double> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edi, DWORD PTR [esi+12]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN36@insert@12
	call	__invalid_parameter_noinfo
$LN36@insert@12:
	mov	esi, DWORD PTR [esi]
	mov	ebp, esi
	mov	DWORD PTR __Tmp$537962[esp+32], edi
	test	esi, esi
	jne	SHORT $LN70@insert@12
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN61@insert@12:
	lea	edi, DWORD PTR [edi+ebx*8]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN51@insert@12
	test	esi, esi
	je	SHORT $LN66@insert@12
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN67@insert@12
$LN70@insert@12:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN61@insert@12
$LN66@insert@12:
	xor	esi, esi
$LN67@insert@12:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN52@insert@12
$LN51@insert@12:
	call	__invalid_parameter_noinfo
$LN52@insert@12:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax+4], edi

; 879  : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
?insert@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@ABN@Z ENDP ; std::vector<double,std::allocator<double> >::insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z PROC	; std::vector<float,std::allocator<float> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@9

; 1107 : 			_Xlen();	// result too long

	jmp	?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ; std::vector<float,std::allocator<float> >::_Xlen
$LN2@Buy@9:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@M@std@@QAEPAMI@Z	; std::allocator<float>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1

; 1115 : 		}

	ret	0
?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z ENDP	; std::vector<float,std::allocator<float> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Construct_n@?$vector@MV?$allocator@M@std@@@std@@QAEXIABM@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Construct_n@?$vector@MV?$allocator@M@std@@@std@@QAEXIABM@Z PROC ; std::vector<float,std::allocator<float> >::_Construct_n, COMDAT
; _this$ = esi
; __Count$ = edi

; 545  : 		{	// construct from _Count * _Val

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+4]

; 546  : 		if (_Buy(_Count))

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	test	edi, edi
	je	SHORT $LN5@Construct_
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN10@Construct_
	call	?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ; std::vector<float,std::allocator<float> >::_Xlen
$LN50@Construct_:
$LN10@Construct_:
	mov	ecx, edi
	call	?allocate@?$allocator@M@std@@QAEPAMI@Z	; std::allocator<float>::allocate
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	ecx, edi
	mov	edx, eax
	test	edi, edi
	jbe	SHORT $LN40@Construct_
$LL42@Construct_:
	fld	DWORD PTR [ebx]
	dec	ecx
	fstp	DWORD PTR [edx]
	add	edx, 4
	test	ecx, ecx
	ja	SHORT $LL42@Construct_
$LN40@Construct_:
	lea	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+16], edx
$LN5@Construct_:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();
; 552  : 			_RERAISE;
; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	pop	ebx
	pop	ecx
	ret	4
$LN49@Construct_:
?_Construct_n@?$vector@MV?$allocator@M@std@@@std@@QAEXIABM@Z ENDP ; std::vector<float,std::allocator<float> >::_Construct_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@10

; 1107 : 			_Xlen();	// result too long

	jmp	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN2@Buy@10:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1

; 1115 : 		}

	ret	0
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
__Tmp$538470 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = eax

; 875  : 		{	// insert _Val at _Where

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR [esi+12]
	mov	ecx, eax
	sub	ecx, edi
	test	ecx, -4					; fffffffcH
	jne	SHORT $LN3@insert@13
	xor	ebx, ebx
	jmp	SHORT $LN4@insert@13
$LN3@insert@13:
	cmp	edi, eax
	jbe	SHORT $LN12@insert@13
	call	__invalid_parameter_noinfo
$LN12@insert@13:
	mov	ecx, DWORD PTR __Where$[esp+24]
	mov	eax, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN23@insert@13
	cmp	ecx, eax
	je	SHORT $LN24@insert@13
$LN23@insert@13:
	call	__invalid_parameter_noinfo
$LN24@insert@13:
	mov	ebx, DWORD PTR __Where$[esp+28]
	sub	ebx, edi
	sar	ebx, 2
$LN4@insert@13:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Where$[esp+28]
	mov	eax, DWORD PTR __Where$[esp+24]
	push	edx
	push	eax
	mov	eax, DWORD PTR __Val$[esp+32]
	push	esi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edi, DWORD PTR [esi+12]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN36@insert@13
	call	__invalid_parameter_noinfo
$LN36@insert@13:
	mov	esi, DWORD PTR [esi]
	mov	ebp, esi
	mov	DWORD PTR __Tmp$538470[esp+32], edi
	test	esi, esi
	jne	SHORT $LN70@insert@13
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN61@insert@13:
	lea	edi, DWORD PTR [edi+ebx*4]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN51@insert@13
	test	esi, esi
	je	SHORT $LN66@insert@13
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN67@insert@13
$LN70@insert@13:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN61@insert@13
$LN66@insert@13:
	xor	esi, esi
$LN67@insert@13:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN52@insert@13
$LN51@insert@13:
	call	__invalid_parameter_noinfo
$LN52@insert@13:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax+4], edi

; 879  : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?push_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXABU?$pair@I_J@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXABU?$pair@I_J@2@@Z PROC ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::push_back, COMDAT
; _this$ = esi

; 844  : 
; 845  :  #if _HAS_ITERATOR_DEBUGGING
; 846  : 		this->_Orphan_all();
; 847  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 848  : 
; 849  : 		if ((_Myoff + _Mysize) % _DEQUESIZ == 0
; 850  : 			&& _Mapsize <= (_Mysize + _DEQUESIZ) / _DEQUESIZ)

	mov	eax, DWORD PTR [esi+28]
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	inc	eax
	push	edi
	cmp	DWORD PTR [esi+20], eax
	ja	SHORT $LN3@push_back

; 851  : 			_Growmap(1);

	push	esi
	call	?_Growmap@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXI@Z ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Growmap
$LN3@push_back:

; 852  : 		size_type _Newoff = _Myoff + _Mysize;

	mov	edi, DWORD PTR [esi+24]
	add	edi, DWORD PTR [esi+28]

; 853  : 		size_type _Block = _Newoff / _DEQUESIZ;
; 854  : 		if (_Mapsize <= _Block)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	ja	SHORT $LN2@push_back

; 855  : 			_Block -= _Mapsize;

	sub	edi, eax
$LN2@push_back:

; 856  : 		if (_Map[_Block] == 0)

	mov	ecx, DWORD PTR [esi+16]
	cmp	DWORD PTR [ecx+edi*4], 0
	jne	SHORT $LN1@push_back

; 857  : 			_Map[_Block] = this->_Alval.allocate(_DEQUESIZ);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, DWORD PTR [esi+16]
	add	esp, 4
	mov	DWORD PTR [edx+edi*4], eax
$LN1@push_back:

; 858  : 		this->_Alval.construct(_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	eax, DWORD PTR [esi+16]
	mov	edi, DWORD PTR [eax+edi*4]
	test	edi, edi
	je	SHORT $LN25@push_back
	movq	xmm0, QWORD PTR [ebx]
	movq	QWORD PTR [edi], xmm0
	movq	xmm0, QWORD PTR [ebx+8]
	movq	QWORD PTR [edi+8], xmm0
$LN25@push_back:

; 859  : 		++_Mysize;

	inc	DWORD PTR [esi+28]

; 860  : 		}

	pop	edi
	pop	ebx
	ret	4
?push_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXABU?$pair@I_J@2@@Z ENDP ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::push_back
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Tidy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXXZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Tidy, COMDAT

; 1123 : 		{	// free all storage

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]
	push	esi

; 1124 : 		if (_Myfirst != 0)

	mov	esi, DWORD PTR [ebx+12]
	push	edi
	test	esi, esi
	je	SHORT $LN22@Tidy@26

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [ebx+16]
	cmp	esi, edi
	je	SHORT $LN10@Tidy@26
$LL12@Tidy@26:
	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	esi, 200				; 000000c8H
	cmp	esi, edi
	jne	SHORT $LL12@Tidy@26
$LN10@Tidy@26:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [ebx+12]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN22@Tidy@26:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1135 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+20], 0
	pop	ebx
	pop	ecx
	ret	4
?_Tidy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXXZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE_NI@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = eax

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi
	mov	esi, eax

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	esi, eax
	jne	SHORT $LN4@Buy@11

; 1105 : 			return (false);

	xor	al, al

; 1115 : 		}

	pop	esi
	ret	0
$LN4@Buy@11:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	esi, 21474836				; 0147ae14H
	jbe	SHORT $LN2@Buy@11

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Xlen
$LN14@Buy@11:
$LN2@Buy@11:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, esi
	call	?allocate@?$allocator@VRank@DRAMsimII@@@std@@QAEPAVRank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Rank>::allocate

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	imul	esi, 200				; 000000c8H
	add	esi, eax
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], esi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1

; 1115 : 		}

	pop	esi
	ret	0
$LN13@Buy@11:
?_Buy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@_JV?$allocator@_J@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@_JV?$allocator@_J@std@@@std@@IAE_NI@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1102 : 		{	// allocate array with _Capacity elements

	push	ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@12

; 1105 : 			return (false);

	xor	al, al
	pop	ecx

; 1115 : 		}

	ret	0
$LN4@Buy@12:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy@12

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ ; std::vector<__int64,std::allocator<__int64> >::_Xlen
$LN14@Buy@12:
$LN2@Buy@12:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@_J@std@@QAEPA_JI@Z ; std::allocator<__int64>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	ecx

; 1115 : 		}

	ret	0
$LN13@Buy@12:
?_Buy@?$vector@_JV?$allocator@_J@std@@@std@@IAE_NI@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Construct_n@?$vector@_JV?$allocator@_J@std@@@std@@QAEXIAB_J@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Construct_n@?$vector@_JV?$allocator@_J@std@@@std@@QAEXIAB_J@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Construct_n, COMDAT
; _this$ = esi
; __Count$ = edi

; 545  : 		{	// construct from _Count * _Val

	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	push	ebp

; 546  : 		if (_Buy(_Count))

	xor	ebp, ebp
	mov	DWORD PTR [esi+12], ebp
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebp
	cmp	edi, ebp
	je	SHORT $LN5@Construct_@2
	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN10@Construct_@2
	call	?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ ; std::vector<__int64,std::allocator<__int64> >::_Xlen
$LN50@Construct_@2:
$LN10@Construct_@2:
	mov	ecx, edi
	call	?allocate@?$allocator@_J@std@@QAEPA_JI@Z ; std::allocator<__int64>::allocate
	lea	ecx, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	edx, edi
	mov	ecx, eax
	cmp	edi, ebp
	jbe	SHORT $LN40@Construct_@2
	npad	3
$LL42@Construct_@2:
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [ecx+4], ebp
	dec	edx
	add	ecx, 8
	test	edx, edx
	ja	SHORT $LL42@Construct_@2
$LN40@Construct_@2:
	lea	edx, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+16], edx
$LN5@Construct_@2:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();
; 552  : 			_RERAISE;
; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	pop	ebp
	pop	ebx
	ret	4
$LN49@Construct_@2:
?_Construct_n@?$vector@_JV?$allocator@_J@std@@@std@@QAEXIAB_J@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Construct_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?reserve@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T539043 = -4						; size = 4
__Count$ = 8						; size = 4
?reserve@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::reserve, COMDAT
; _this$ = esi

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 603  : 		if (max_size() < _Count)

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	esp, 8
	push	ebx
	push	edi
	cmp	ecx, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@reserve@4

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Xlen
$LN97@reserve@4:
$LN5@reserve@4:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR [esi+12]
	test	edx, edx
	jne	SHORT $LN20@reserve@4
	xor	eax, eax
	jmp	SHORT $LN21@reserve@4
$LN20@reserve@4:
	mov	eax, DWORD PTR [esi+20]
	sub	eax, edx
	sar	eax, 2
$LN21@reserve@4:
	cmp	eax, ecx
	jae	SHORT $LN3@reserve@4

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	call	?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Transaction *>::allocate

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	edi, DWORD PTR [esi+16]
	mov	ebx, eax
	cmp	DWORD PTR [esi+12], edi
	jbe	SHORT $LN27@reserve@4
	call	__invalid_parameter_noinfo
$LN27@reserve@4:
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR $T539043[esp+16], ecx
	cmp	ecx, DWORD PTR [esi+16]
	jbe	SHORT $LN43@reserve@4
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR $T539043[esp+16]
$LN43@reserve@4:
	sub	edi, ecx
	sar	edi, 2
	test	edi, edi
	jbe	SHORT $LN86@reserve@4
	lea	eax, DWORD PTR [edi*4]
	push	eax
	push	ecx
	push	eax
	push	ebx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN86@reserve@4:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);
; 613  : 			_RERAISE;
; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+16]
	sub	edi, eax
	sar	edi, 2

; 617  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN93@reserve@4

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);
; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN93@reserve@4:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [ebx+eax*4]

; 628  : 			_Mylast = _Ptr + _Size;

	lea	edx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+16], edx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+12], ebx
$LN3@reserve@4:

; 630  : 			}
; 631  : 		}

	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN96@reserve@4:
?reserve@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::reserve
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@NV?$allocator@N@std@@@std@@QAEXABN@Z
_TEXT	SEGMENT
$T539306 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@NV?$allocator@N@std@@@std@@QAEXABN@Z PROC ; std::vector<double,std::allocator<double> >::push_back, COMDAT
; _this$ = edi

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [edi+12]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
	push	esi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@2
	xor	eax, eax
	jmp	SHORT $LN10@push_back@2
$LN9@push_back@2:
	mov	eax, DWORD PTR [edi+20]
	sub	eax, ecx
	sar	eax, 3
$LN10@push_back@2:
	mov	esi, DWORD PTR [edi+16]
	mov	edx, esi
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	fld	QWORD PTR [ebx]
	add	esi, 8
	fstp	QWORD PTR [esi-8]
	mov	DWORD PTR [edi+16], esi

; 824  : 		}

	pop	esi
	pop	ebx
	add	esp, 8
	ret	4
$LN2@push_back@2:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	cmp	ecx, esi
	jbe	SHORT $LN39@push_back@2
	call	__invalid_parameter_noinfo
$LN39@push_back@2:
	mov	eax, DWORD PTR [edi]
	push	esi
	push	eax
	push	ebx
	lea	eax, DWORD PTR $T539306[esp+28]
	push	eax
	mov	eax, edi
	call	?insert@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@ABN@Z ; std::vector<double,std::allocator<double> >::insert

; 824  : 		}

	pop	esi
	pop	ebx
	add	esp, 8
	ret	4
?push_back@?$vector@NV?$allocator@N@std@@@std@@QAEXABN@Z ENDP ; std::vector<double,std::allocator<double> >::push_back
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Right$ = 12						; size = 4
??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >, COMDAT

; 500  : 		{	// construct by copying _Right

	push	-1
	push	__ehhandler$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR __Right$[esp+32]
	mov	esi, DWORD PTR _this$[esp+32]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN19@vector@32
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN20@vector@32
$LN19@vector@32:
	xor	eax, eax
$LN20@vector@32:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+44], ecx

; 501  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+16]
	sub	edi, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+12], ecx
	sar	edi, 3
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	cmp	edi, ecx
	je	SHORT $LN5@vector@32
	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN46@vector@32
	call	?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ ; std::vector<double,std::allocator<double> >::_Xlen
$LN110@vector@32:
$LN46@vector@32:
	mov	ecx, edi
	call	?allocate@?$allocator@N@std@@QAEPANI@Z	; std::allocator<double>::allocate
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+20], eax

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edi, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], edi
	jbe	SHORT $LN60@vector@32
	call	__invalid_parameter_noinfo
$LN60@vector@32:
	mov	ebp, DWORD PTR [ebx+12]
	cmp	ebp, DWORD PTR [ebx+16]
	jbe	SHORT $LN74@vector@32
	call	__invalid_parameter_noinfo
$LN74@vector@32:
	mov	ecx, DWORD PTR [esi+12]
	sub	edi, ebp
	sar	edi, 3
	lea	eax, DWORD PTR [edi*8]
	lea	ebx, DWORD PTR [eax+ecx]
	test	edi, edi
	jbe	SHORT $LN103@vector@32
	push	eax
	push	ebp
	push	eax
	push	ecx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN103@vector@32:
	mov	DWORD PTR [esi+16], ebx
$LN5@vector@32:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();
; 506  : 			_RERAISE;
; 507  : 			_CATCH_END
; 508  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
$LN109@vector@32:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z$2:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ PROC	; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >, COMDAT

; 470  : 		{	// construct empty vector

	push	-1
	push	__ehhandler$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@33
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@33
$LN13@vector@33:
	xor	eax, eax
$LN14@vector@33:
	mov	DWORD PTR [esi], eax

; 471  : 		_Buy(0);

	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx

; 472  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ENDP	; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
; Function compile flags: /Ogtpy
;	COMDAT ??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<float,std::allocator<float> >::operator=, COMDAT
; _this$ = eax

; 563  : 		{	// assign _Right

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Right$[esp+4]
	push	esi
	mov	esi, eax
	push	edi

; 564  : 		if (this != &_Right)

	cmp	esi, ebp
	je	$LN1@operator@301

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR [ebp+16]
	mov	ebx, DWORD PTR [ebp+12]
	mov	eax, ecx
	sub	eax, ebx
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator@301

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	eax, esi
	call	?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ ; std::vector<float,std::allocator<float> >::clear

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN8@operator@301:

; 573  : 			else if (_Right.size() <= size())

	mov	edx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+16]
	sub	edi, edx
	sar	edi, 2
	cmp	eax, edi
	ja	SHORT $LN6@operator@301

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	sub	ecx, ebx
	sar	ecx, 2
	test	ecx, ecx
	jle	SHORT $LN32@operator@301
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	push	ebx
	push	eax
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@operator@301:

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	eax, DWORD PTR [ebp+16]
	sub	eax, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [esi+12]
	sar	eax, 2
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+16], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN6@operator@301:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	xor	ebx, ebx
	cmp	edx, ebx
	jne	SHORT $LN41@operator@301
	xor	ecx, ecx
	jmp	SHORT $LN42@operator@301
$LN41@operator@301:
	mov	ecx, DWORD PTR [esi+20]
	sub	ecx, edx
	sar	ecx, 2
$LN42@operator@301:
	cmp	eax, ecx
	ja	SHORT $LN4@operator@301

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR [ebp+12]
	lea	ebx, DWORD PTR [ecx+edi*4]

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, ebx
	mov	edi, ecx
	call	??$unchecked_copy@PAMPAM@stdext@@YAPAMPAM00@Z ; stdext::unchecked_copy<float *,float *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR [esi+16]

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	eax, DWORD PTR [ebp+16]
	mov	edi, ebx
	call	??$_Ucopy@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ; std::vector<float,std::allocator<float> >::_Ucopy<float *>
	mov	DWORD PTR [esi+16], eax

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN4@operator@301:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	cmp	edx, ebx
	je	SHORT $LN45@operator@301

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN45@operator@301:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebp+16]
	sub	edi, DWORD PTR [ebp+12]
	mov	DWORD PTR [esi+12], ebx
	sar	edi, 2
	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	cmp	edi, ebx
	je	SHORT $LN61@operator@301
	call	?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z ; std::vector<float,std::allocator<float> >::_Buy
	test	al, al
	je	SHORT $LN61@operator@301

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR [ebp+16]
	call	??$_Ucopy@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ; std::vector<float,std::allocator<float> >::_Ucopy<float *>
	mov	DWORD PTR [esi+16], eax
$LN61@operator@301:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
$LN1@operator@301:

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<float,std::allocator<float> >::operator=
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
$T540247 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z PROC	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT
; __Count$ = edi

; 482  : 		{	// construct from _Count * _Ty()

	push	-1
	push	__ehhandler$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@vector@34
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@34
$LN13@vector@34:
	xor	eax, eax
$LN14@vector@34:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0

; 483  : 		_Construct_n(_Count, _Ty());

	xorps	xmm0, xmm0
	lea	eax, DWORD PTR $T540247[esp+24]
	push	eax
	movss	DWORD PTR $T540247[esp+28], xmm0
	call	?_Construct_n@?$vector@MV?$allocator@M@std@@@std@@QAEXIABM@Z ; std::vector<float,std::allocator<float> >::_Construct_n

; 484  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z ENDP	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	-1
	push	__ehhandler$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@35
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@35
$LN13@vector@35:
	xor	eax, eax
$LN14@vector@35:
	mov	DWORD PTR [esi], eax

; 471  : 		_Buy(0);

	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx

; 472  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
$T540573 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = edi

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [edi+12]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
	push	esi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@3
	xor	eax, eax
	jmp	SHORT $LN10@push_back@3
$LN9@push_back@3:
	mov	eax, DWORD PTR [edi+20]
	sub	eax, ecx
	sar	eax, 2
$LN10@push_back@3:
	mov	esi, DWORD PTR [edi+16]
	mov	edx, esi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax
	add	esi, 4
	mov	DWORD PTR [edi+16], esi

; 824  : 		}

	pop	esi
	pop	ebx
	add	esp, 8
	ret	4
$LN2@push_back@3:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	cmp	ecx, esi
	jbe	SHORT $LN39@push_back@3
	call	__invalid_parameter_noinfo
$LN39@push_back@3:
	mov	eax, DWORD PTR [edi]
	push	esi
	push	eax
	push	ebx
	lea	ecx, DWORD PTR $T540573[esp+28]
	push	ecx
	mov	eax, edi
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert

; 824  : 		}

	pop	esi
	pop	ebx
	add	esp, 8
	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::operator=, COMDAT
; _this$ = eax

; 563  : 		{	// assign _Right

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Right$[esp+4]
	push	esi
	mov	esi, eax
	push	edi

; 564  : 		if (this != &_Right)

	cmp	esi, ebp
	je	$LN1@operator@302

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR [ebp+16]
	mov	ebx, DWORD PTR [ebp+12]
	mov	eax, ecx
	sub	eax, ebx
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator@302

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	eax, esi
	call	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN8@operator@302:

; 573  : 			else if (_Right.size() <= size())

	mov	edx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+16]
	sub	edi, edx
	sar	edi, 2
	cmp	eax, edi
	ja	SHORT $LN6@operator@302

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	sub	ecx, ebx
	sar	ecx, 2
	test	ecx, ecx
	jle	SHORT $LN32@operator@302
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	push	ebx
	push	eax
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@operator@302:

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	eax, DWORD PTR [ebp+16]
	sub	eax, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [esi+12]
	sar	eax, 2
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+16], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN6@operator@302:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	xor	ebx, ebx
	cmp	edx, ebx
	jne	SHORT $LN41@operator@302
	xor	ecx, ecx
	jmp	SHORT $LN42@operator@302
$LN41@operator@302:
	mov	ecx, DWORD PTR [esi+20]
	sub	ecx, edx
	sar	ecx, 2
$LN42@operator@302:
	cmp	eax, ecx
	ja	SHORT $LN4@operator@302

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR [ebp+12]
	lea	ebx, DWORD PTR [ecx+edi*4]

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, ebx
	mov	edi, ecx
	call	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy<int *,int *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR [esi+16]

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	eax, DWORD PTR [ebp+16]
	mov	edi, ebx
	call	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
	mov	DWORD PTR [esi+16], eax

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN4@operator@302:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	cmp	edx, ebx
	je	SHORT $LN45@operator@302

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN45@operator@302:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebp+16]
	sub	edi, DWORD PTR [ebp+12]
	mov	DWORD PTR [esi+12], ebx
	sar	edi, 2
	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	cmp	edi, ebx
	je	SHORT $LN61@operator@302
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
	test	al, al
	je	SHORT $LN61@operator@302

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR [ebp+16]
	call	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
	mov	DWORD PTR [esi+16], eax
$LN61@operator@302:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
$LN1@operator@302:

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::operator=
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Right$ = 12						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT

; 500  : 		{	// construct by copying _Right

	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR __Right$[esp+32]
	mov	esi, DWORD PTR _this$[esp+32]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN19@vector@36
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN20@vector@36
$LN19@vector@36:
	xor	eax, eax
$LN20@vector@36:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+44], ecx

; 501  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+16]
	sub	edi, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+12], ecx
	sar	edi, 2
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	cmp	edi, ecx
	je	SHORT $LN5@vector@36
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN46@vector@36
	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN110@vector@36:
$LN46@vector@36:
	mov	ecx, edi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], eax

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edi, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], edi
	jbe	SHORT $LN60@vector@36
	call	__invalid_parameter_noinfo
$LN60@vector@36:
	mov	ebp, DWORD PTR [ebx+12]
	cmp	ebp, DWORD PTR [ebx+16]
	jbe	SHORT $LN74@vector@36
	call	__invalid_parameter_noinfo
$LN74@vector@36:
	mov	ecx, DWORD PTR [esi+12]
	sub	edi, ebp
	sar	edi, 2
	lea	eax, DWORD PTR [edi*4]
	lea	ebx, DWORD PTR [eax+ecx]
	test	edi, edi
	jbe	SHORT $LN103@vector@36
	push	eax
	push	ebp
	push	eax
	push	ecx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN103@vector@36:
	mov	DWORD PTR [esi+16], ebx
$LN5@vector@36:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();
; 506  : 			_RERAISE;
; 507  : 			_CATCH_END
; 508  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
$LN109@vector@36:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$2:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@37
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@37
$LN13@vector@37:
	xor	eax, eax
$LN14@vector@37:
	mov	DWORD PTR [esi], eax

; 471  : 		_Buy(0);

	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx

; 472  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\queue
;	COMDAT ?push@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXABU?$pair@I_J@2@@Z
_TEXT	SEGMENT
?push@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXABU?$pair@I_J@2@@Z PROC ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::push, COMDAT
; _this$ = esi
; __Val$ = eax

; 70   : 		{	// insert element at beginning

	push	ecx

; 71   : 		c.push_back(_Val);

	push	eax
	call	?push_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXABU?$pair@I_J@2@@Z ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::push_back
	pop	ecx

; 72   : 		}

	ret	0
?push@?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAEXABU?$pair@I_J@2@@Z ENDP ; std::queue<std::pair<unsigned int,__int64>,std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > > >::push
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT

; 558  : 		{	// destroy the object

	push	-1
	push	__ehhandler$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]

; 559  : 		_Tidy();

	push	esi
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	?_Tidy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Tidy

; 560  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
;	COMDAT ??4?$vector@_JV?$allocator@_J@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@_JV?$allocator@_J@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<__int64,std::allocator<__int64> >::operator=, COMDAT
; _this$ = eax

; 563  : 		{	// assign _Right

	push	ebx
	mov	ebx, DWORD PTR __Right$[esp]
	push	esi
	mov	esi, eax

; 564  : 		if (this != &_Right)

	cmp	esi, ebx
	je	$LN1@operator@303

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR [ebx+16]
	push	edi
	mov	edi, DWORD PTR [ebx+12]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	test	eax, eax
	jne	SHORT $LN8@operator@303

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	eax, esi
	call	?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ ; std::vector<__int64,std::allocator<__int64> >::clear
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 599  : 		}

	ret	4
$LN8@operator@303:

; 573  : 			else if (_Right.size() <= size())

	mov	edx, DWORD PTR [esi+12]
	push	ebp
	mov	ebp, DWORD PTR [esi+16]
	sub	ebp, edx
	sar	ebp, 3
	cmp	eax, ebp
	ja	SHORT $LN6@operator@303

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	sub	ecx, edi
	sar	ecx, 3
	test	ecx, ecx
	jle	SHORT $LN32@operator@303
	lea	eax, DWORD PTR [ecx*8]
	push	eax
	push	edi
	push	eax
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@operator@303:

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	eax, DWORD PTR [ebx+16]
	sub	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [esi+12]
	sar	eax, 3
	pop	ebp
	lea	edx, DWORD PTR [ecx+eax*8]
	pop	edi
	mov	DWORD PTR [esi+16], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 599  : 		}

	ret	4
$LN6@operator@303:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	edx, edx
	jne	SHORT $LN41@operator@303
	xor	ecx, ecx
	jmp	SHORT $LN42@operator@303
$LN41@operator@303:
	mov	ecx, DWORD PTR [esi+20]
	sub	ecx, edx
	sar	ecx, 3
$LN42@operator@303:
	cmp	eax, ecx
	ja	SHORT $LN4@operator@303

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	lea	ebp, DWORD PTR [edi+ebp*8]

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, ebp
	call	??$unchecked_copy@PA_JPA_J@stdext@@YAPA_JPA_J00@Z ; stdext::unchecked_copy<__int64 *,__int64 *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR [esi+16]

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	eax, DWORD PTR [ebx+16]
	mov	edi, ebp
	call	??$_Ucopy@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<__int64 *>
	pop	ebp
	mov	DWORD PTR [esi+16], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 599  : 		}

	ret	4
$LN4@operator@303:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	edx, edx
	je	SHORT $LN45@operator@303

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN45@operator@303:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+16]
	sub	edi, DWORD PTR [ebx+12]
	sar	edi, 3
	call	?_Buy@?$vector@_JV?$allocator@_J@std@@@std@@IAE_NI@Z ; std::vector<__int64,std::allocator<__int64> >::_Buy
	test	al, al
	je	SHORT $LN49@operator@303

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+16]
	call	??$_Ucopy@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z ; std::vector<__int64,std::allocator<__int64> >::_Ucopy<__int64 *>
	mov	DWORD PTR [esi+16], eax
$LN49@operator@303:
	pop	ebp

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	edi
$LN1@operator@303:
	pop	esi
	pop	ebx

; 599  : 		}

	ret	4
??4?$vector@_JV?$allocator@_J@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::operator=
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Right$ = 12						; size = 4
??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >, COMDAT

; 500  : 		{	// construct by copying _Right

	push	-1
	push	__ehhandler$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR __Right$[esp+32]
	mov	esi, DWORD PTR _this$[esp+32]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN19@vector@38
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN20@vector@38
$LN19@vector@38:
	xor	eax, eax
$LN20@vector@38:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+44], ecx

; 501  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+16]
	sub	edi, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+12], ecx
	sar	edi, 3
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	cmp	edi, ecx
	je	SHORT $LN5@vector@38
	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN46@vector@38
	call	?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@KAXXZ ; std::vector<__int64,std::allocator<__int64> >::_Xlen
$LN110@vector@38:
$LN46@vector@38:
	mov	ecx, edi
	call	?allocate@?$allocator@_J@std@@QAEPA_JI@Z ; std::allocator<__int64>::allocate
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+20], eax

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edi, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], edi
	jbe	SHORT $LN60@vector@38
	call	__invalid_parameter_noinfo
$LN60@vector@38:
	mov	ebp, DWORD PTR [ebx+12]
	cmp	ebp, DWORD PTR [ebx+16]
	jbe	SHORT $LN74@vector@38
	call	__invalid_parameter_noinfo
$LN74@vector@38:
	mov	ecx, DWORD PTR [esi+12]
	sub	edi, ebp
	sar	edi, 3
	lea	eax, DWORD PTR [edi*8]
	lea	ebx, DWORD PTR [eax+ecx]
	test	edi, edi
	jbe	SHORT $LN103@vector@38
	push	eax
	push	ebp
	push	eax
	push	ecx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN103@vector@38:
	mov	DWORD PTR [esi+16], ebx
$LN5@vector@38:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();
; 506  : 			_RERAISE;
; 507  : 			_CATCH_END
; 508  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
$LN109@vector@38:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z$2:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@_JV?$allocator@_J@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
$T542039 = -24						; size = 8
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z PROC	; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >, COMDAT
; __Count$ = edi

; 482  : 		{	// construct from _Count * _Ty()

	push	-1
	push	__ehhandler$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+28]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@39
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@39
$LN13@vector@39:
	xor	eax, eax
$LN14@vector@39:
	mov	DWORD PTR [esi], eax

; 483  : 		_Construct_n(_Count, _Ty());

	lea	eax, DWORD PTR $T542039[esp+32]
	mov	DWORD PTR __$EHRec$[esp+40], ecx
	push	eax
	mov	DWORD PTR $T542039[esp+36], ecx
	mov	DWORD PTR $T542039[esp+40], ecx
	call	?_Construct_n@?$vector@_JV?$allocator@_J@std@@@std@@QAEXIAB_J@Z ; std::vector<__int64,std::allocator<__int64> >::_Construct_n

; 484  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@_JV?$allocator@_J@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z ENDP	; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
PUBLIC	?getPendingTransactions@Channel@DRAMsimII@@QAEXAAV?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@@Z ; DRAMsimII::Channel::getPendingTransactions
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
_outputQueue$ = 12					; size = 4
?getPendingTransactions@Channel@DRAMsimII@@QAEXAAV?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@@Z PROC ; DRAMsimII::Channel::getPendingTransactions

; 308  : {

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _outputQueue$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+8]

; 309  : 	while (finishedTransactions.size() > 0)

	cmp	DWORD PTR [ebp+420], 0
	push	esi
	push	edi
	jbe	$LN1@getPending
	npad	6
$LL2@getPending:

; 310  : 	{
; 311  : 		outputQueue.push(finishedTransactions.front());

	mov	edi, DWORD PTR [ebp+416]
	mov	eax, DWORD PTR [ebp+420]
	add	eax, edi
	cmp	edi, eax
	jbe	SHORT $LN18@getPending
	call	__invalid_parameter_noinfo
$LN18@getPending:
	mov	esi, DWORD PTR [ebp+392]
	test	esi, esi
	jne	SHORT $LN108@getPending
	call	__invalid_parameter_noinfo
	xor	eax, eax
	xor	ecx, ecx
$LN48@getPending:
	mov	ecx, DWORD PTR [ecx+28]
	add	ecx, DWORD PTR [eax+24]
	cmp	edi, ecx
	jb	SHORT $LN33@getPending
	call	__invalid_parameter_noinfo
$LN33@getPending:
	test	esi, esi
	je	SHORT $LN53@getPending
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN54@getPending
$LN108@getPending:
	mov	eax, DWORD PTR [esi]
	mov	ecx, eax
	jmp	SHORT $LN48@getPending
$LN53@getPending:
	xor	eax, eax
$LN54@getPending:
	cmp	DWORD PTR [eax+20], edi
	ja	SHORT $LN32@getPending
	test	esi, esi
	je	SHORT $LN59@getPending
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN60@getPending
$LN59@getPending:
	xor	eax, eax
$LN60@getPending:
	sub	edi, DWORD PTR [eax+20]
$LN32@getPending:
	test	esi, esi
	je	SHORT $LN65@getPending
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN66@getPending
$LN65@getPending:
	xor	esi, esi
$LN66@getPending:
	mov	eax, DWORD PTR [ebx+28]
	mov	edx, DWORD PTR [esi+16]
	mov	edi, DWORD PTR [edx+edi*4]
	inc	eax
	cmp	DWORD PTR [ebx+20], eax
	ja	SHORT $LN73@getPending
	push	ebx
	call	?_Growmap@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXI@Z ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Growmap
$LN73@getPending:
	mov	esi, DWORD PTR [ebx+28]
	add	esi, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, esi
	ja	SHORT $LN72@getPending
	sub	esi, eax
$LN72@getPending:
	mov	ecx, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ecx+esi*4], 0
	jne	SHORT $LN71@getPending
	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, DWORD PTR [ebx+16]
	add	esp, 4
	mov	DWORD PTR [edx+esi*4], eax
$LN71@getPending:
	mov	eax, DWORD PTR [ebx+16]
	mov	esi, DWORD PTR [eax+esi*4]
	xor	edx, edx
	cmp	esi, edx
	je	SHORT $LN91@getPending
	movq	xmm0, QWORD PTR [edi]
	movq	QWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edi+8]
	movq	QWORD PTR [esi+8], xmm0
$LN91@getPending:
	mov	ecx, 1
	add	DWORD PTR [ebx+28], ecx

; 312  : 		finishedTransactions.pop();

	mov	eax, DWORD PTR [ebp+420]
	cmp	eax, edx
	je	SHORT $LN99@getPending
	add	DWORD PTR [ebp+416], ecx
	mov	ecx, DWORD PTR [ebp+416]
	cmp	DWORD PTR [ebp+412], ecx
	ja	SHORT $LN100@getPending
	mov	DWORD PTR [ebp+416], edx
$LN100@getPending:
	dec	eax
	mov	DWORD PTR [ebp+420], eax
	cmp	eax, edx
	jne	SHORT $LN99@getPending
	mov	DWORD PTR [ebp+416], edx
$LN99@getPending:

; 309  : 	while (finishedTransactions.size() > 0)

	cmp	DWORD PTR [ebp+420], edx
	ja	$LL2@getPending
$LN1@getPending:

; 313  : 	}
; 314  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
?getPendingTransactions@Channel@DRAMsimII@@QAEXAAV?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@@Z ENDP ; DRAMsimII::Channel::getPendingTransactions
_TEXT	ENDS
PUBLIC	??1Channel@DRAMsimII@@UAE@XZ			; DRAMsimII::Channel::~Channel
__unwindtable$??1Channel@DRAMsimII@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$3
__ehfuncinfo$??1Channel@DRAMsimII@@UAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1Channel@DRAMsimII@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Channel@DRAMsimII@@UAE@XZ PROC			; DRAMsimII::Channel::~Channel
; _this$ = ecx

; 163  : {

	push	-1
	push	__ehhandler$??1Channel@DRAMsimII@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+36], edi
	mov	DWORD PTR [edi], OFFSET ??_7Channel@DRAMsimII@@6B@

; 164  : 	// must remove commands this way to prevent queues from being automatically deleted, thus creating double frees on refresh commands
; 165  : 	while (Command *cmd = getNextCommand())

	xor	ebx, ebx
	push	ebx
	push	edi
	mov	DWORD PTR __$EHRec$[esp+52], 3
	call	?getNextCommand@Channel@DRAMsimII@@IAEPAVCommand@2@PBV32@@Z ; DRAMsimII::Channel::getNextCommand
	mov	esi, eax
	cmp	esi, ebx
	je	SHORT $LN2@Channel
	npad	7
$LL3@Channel:

; 166  : 	{
; 167  : 		delete lastCommand;

	mov	ecx, DWORD PTR [edi+24]
	cmp	ecx, ebx
	je	SHORT $LN6@Channel
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN6@Channel:
	push	ebx
	push	edi

; 168  : 
; 169  : 		lastCommand = cmd;

	mov	DWORD PTR [edi+24], esi
	call	?getNextCommand@Channel@DRAMsimII@@IAEPAVCommand@2@PBV32@@Z ; DRAMsimII::Channel::getNextCommand
	mov	esi, eax
	cmp	esi, ebx
	jne	SHORT $LL3@Channel
$LN2@Channel:

; 170  : 	}
; 171  : 	if (lastCommand)

	mov	ecx, DWORD PTR [edi+24]
	cmp	ecx, ebx
	je	SHORT $LN1@Channel

; 172  : 	{
; 173  : 		delete lastCommand;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx

; 174  : 		lastCommand = NULL;

	mov	DWORD PTR [edi+24], ebx
$LN1@Channel:

; 175  : 	}
; 176  : }

	lea	esi, DWORD PTR [edi+392]
	call	?_Tidy@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@IAEXXZ ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::_Tidy
	mov	esi, DWORD PTR [esi]
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	lea	eax, DWORD PTR [edi+368]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+48], 1
	call	??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	mov	eax, DWORD PTR [edi+164]
	cmp	eax, ebx
	je	SHORT $LN35@Channel
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@Channel:
	mov	eax, DWORD PTR [edi+152]
	push	eax
	mov	DWORD PTR [edi+164], ebx
	mov	DWORD PTR [edi+168], ebx
	mov	DWORD PTR [edi+172], ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	add	edi, 112				; 00000070H
	push	edi
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	call	??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
	ret	0
__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$1:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 152				; 00000098H
	jmp	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$2:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 368				; 00000170H
	push	eax
	call	??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	ret	0
__unwindfunclet$??1Channel@DRAMsimII@@UAE@XZ$3:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 392				; 00000188H
	jmp	??1?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ
__ehhandler$??1Channel@DRAMsimII@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Channel@DRAMsimII@@UAE@XZ
	jmp	___CxxFrameHandler3
??1Channel@DRAMsimII@@UAE@XZ ENDP			; DRAMsimII::Channel::~Channel
; Function compile flags: /Ogtpy
;	COMDAT ??_GChannel@DRAMsimII@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GChannel@DRAMsimII@@UAEPAXI@Z PROC			; DRAMsimII::Channel::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1Channel@DRAMsimII@@UAE@XZ		; DRAMsimII::Channel::~Channel
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@93
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@93:
	mov	eax, esi
	pop	esi
	ret	4
??_GChannel@DRAMsimII@@UAEPAXI@Z ENDP			; DRAMsimII::Channel::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapstub.h
xdata$x	SEGMENT
__unwindtable$??0_ns2__submitEpochResultElement@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_ns2__submitEpochResultElement@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_ns2__submitEpochResultElement@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_ns2__submitEpochResultElement@@QAE@XZ$2
__ehfuncinfo$??0_ns2__submitEpochResultElement@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0_ns2__submitEpochResultElement@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0_ns2__submitEpochResultElement@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0_ns2__submitEpochResultElement@@QAE@XZ PROC		; _ns2__submitEpochResultElement::_ns2__submitEpochResultElement, COMDAT
; _this$ = ecx

; 263  : 	_ns2__submitEpochResultElement() : sessionID(NULL), epoch(0), PsysRD(0), PsysWR(0), soap(NULL) { }

	push	-1
	push	__ehhandler$??0_ns2__submitEpochResultElement@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	xor	edi, edi
	lea	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [esi], OFFSET ??_7_ns2__submitEpochResultElement@@6B@
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], edi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	lea	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR __$EHRec$[esp+36], edi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	lea	ecx, DWORD PTR [esi+72]
	mov	BYTE PTR __$EHRec$[esp+36], 1
	call	??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	lea	ecx, DWORD PTR [esi+96]
	mov	BYTE PTR __$EHRec$[esp+36], 2
	call	??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	xorps	xmm0, xmm0
	movss	DWORD PTR [esi+120], xmm0
	movss	DWORD PTR [esi+124], xmm0
	mov	DWORD PTR [esi+128], edi
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_ns2__submitEpochResultElement@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0_ns2__submitEpochResultElement@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0_ns2__submitEpochResultElement@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
__ehhandler$??0_ns2__submitEpochResultElement@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_ns2__submitEpochResultElement@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_ns2__submitEpochResultElement@@QAE@XZ ENDP		; _ns2__submitEpochResultElement::_ns2__submitEpochResultElement
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\get_pointer.hpp
xdata$x	SEGMENT
__unwindtable$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z$1
__ehfuncinfo$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\mem_fn_template.hpp
xdata$x	ENDS
;	COMDAT ??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_u$ = 12						; size = 4
_b1$ = 16						; size = 4
_b2$ = 20						; size = 4
_b3$ = 24						; size = 4
$T563928 = 28						; size = 4
_b4$ = 28						; size = 4
$T563927 = 32						; size = 4
_b5$ = 32						; size = 4
$T563926 = 36						; size = 4
_b6$ = 36						; size = 4
??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z PROC ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::call<DRAMsimII::Channel * const,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>, COMDAT

; 765  :     template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const

	push	-1
	push	__ehhandler$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	push	ecx
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _b6$[esp+16]

; 766  :     {
; 767  :         BOOST_MEM_FN_RETURN (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6);

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _b5$[esp+20]
	push	edx
	sub	esp, 24					; 00000018H
	mov	eax, esp
	mov	DWORD PTR $T563926[esp+48], esp
	push	ecx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	eax, DWORD PTR _b4$[esp+48]
	sub	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[esp+84], 0
	mov	edx, esp
	mov	DWORD PTR $T563927[esp+72], esp
	push	eax
	push	edx
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	edx, DWORD PTR _b3$[esp+72]
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR $T563928[esp+96], esp
	push	edx
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+116], 1
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, DWORD PTR _u$[esp+96]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _b2$[esp+96]
	fld	QWORD PTR [edx]
	mov	eax, DWORD PTR _b1$[esp+96]
	mov	edx, DWORD PTR _this$[esp+96]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [eax]
	mov	DWORD PTR __$EHRec$[esp+124], -1
	mov	eax, DWORD PTR [edx]
	fstp	QWORD PTR [esp]
	call	eax

; 768  :     }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 16					; 00000010H
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z$0:
	mov	esi, DWORD PTR $T563926[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z$1:
	mov	esi, DWORD PTR $T563927[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__ehhandler$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z ENDP ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::call<DRAMsimII::Channel * const,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z$2
__ehfuncinfo$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\mem_fn_template.hpp
xdata$x	ENDS
;	COMDAT ??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_u$ = 12						; size = 4
_a6$ = 16						; size = 8
_a1$ = 24						; size = 8
_a2$ = 32						; size = 8
_a3$ = 40						; size = 24
_a4$ = 64						; size = 24
_a5$ = 88						; size = 24
??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z PROC ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::operator()<DRAMsimII::Channel *>, COMDAT

; 774  :     template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const

	push	-1
	push	__ehhandler$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax

; 775  :     {
; 776  :         BOOST_MEM_FN_RETURN call(u, &u, a1, a2, a3, a4, a5, a6);

	lea	eax, DWORD PTR _a6$[esp+24]
	push	eax
	lea	ecx, DWORD PTR _a5$[esp+28]
	push	ecx
	lea	edx, DWORD PTR _a4$[esp+32]
	push	edx
	lea	eax, DWORD PTR _a3$[esp+36]
	push	eax
	mov	eax, DWORD PTR _u$[esp+40]
	lea	ecx, DWORD PTR _a2$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+44]
	lea	edx, DWORD PTR _a1$[esp+44]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+68], 2
	call	??$call@QAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@ABE_NABQAVChannel@DRAMsimII@@PBXAAN2AAV?$vector@HV?$allocator@H@std@@@std@@AAV?$vector@NV?$allocator@N@std@@@6@4AA_J@Z ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::call<DRAMsimII::Channel * const,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
	mov	bl, al
	mov	eax, DWORD PTR _a3$[esp+36]
	xor	esi, esi
	cmp	eax, esi
	je	SHORT $LN11@operator@314
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@operator@314:
	mov	edx, DWORD PTR _a3$[esp+24]
	push	edx
	mov	DWORD PTR _a3$[esp+40], esi
	mov	DWORD PTR _a3$[esp+44], esi
	mov	DWORD PTR _a3$[esp+48], esi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a4$[esp+40]
	add	esp, 4
	cmp	eax, esi
	je	SHORT $LN26@operator@314
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@operator@314:
	mov	eax, DWORD PTR _a4$[esp+24]
	push	eax
	mov	DWORD PTR _a4$[esp+40], esi
	mov	DWORD PTR _a4$[esp+44], esi
	mov	DWORD PTR _a4$[esp+48], esi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a5$[esp+40]
	add	esp, 4
	cmp	eax, esi
	je	SHORT $LN41@operator@314
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@operator@314:
	mov	ecx, DWORD PTR _a5$[esp+24]
	push	ecx
	mov	DWORD PTR _a5$[esp+40], esi
	mov	DWORD PTR _a5$[esp+44], esi
	mov	DWORD PTR _a5$[esp+48], esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	al, bl

; 777  :     }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	104					; 00000068H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z$0:
	lea	esi, DWORD PTR _a5$[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z$1:
	lea	esi, DWORD PTR _a4$[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z$2:
	lea	ecx, DWORD PTR _a3$[ebp-4]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z ENDP ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::operator()<DRAMsimII::Channel *>
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
xdata$x	SEGMENT
__unwindtable$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z$1
__ehfuncinfo$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z
_TEXT	SEGMENT
$T564108 = -76						; size = 4
$T564109 = -72						; size = 4
$T564110 = -68						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
_f$ = 12						; size = 4
??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z PROC ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::operator()<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list0>, COMDAT
; _this$ = esi

; 651  :     template<class R, class F, class A> R operator()(type<R>, F & f, A & a, long)

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	push	-1
	push	__ehhandler$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+132]
	mov	DWORD PTR fs:0, eax

; 652  :     {
; 653  :         return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);

	sub	esp, 24					; 00000018H
	lea	eax, DWORD PTR [esi+72]
	mov	ecx, esp
	mov	DWORD PTR $T564108[esp+156], esp
	push	eax
	push	ecx
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[esp+188], 0
	lea	edx, DWORD PTR [esi+48]
	mov	eax, esp
	mov	DWORD PTR $T564109[esp+180], esp
	push	edx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	lea	ecx, DWORD PTR [esi+24]
	mov	edx, esp
	mov	DWORD PTR $T564110[esp+204], esp
	push	ecx
	push	edx
	mov	BYTE PTR __$EHRec$[esp+220], 1
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	fld	QWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+100]
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR _f$[ebp]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+228], -1
	fstp	QWORD PTR [esp]
	push	eax
	push	ecx
	push	esi
	push	edx
	call	??$?RPAVChannel@DRAMsimII@@@?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@QBE_NABQAVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@2_J@Z ; boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>::operator()<DRAMsimII::Channel *>

; 654  :     }

	mov	ecx, DWORD PTR __$EHRec$[esp+132]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z$0:
	mov	esi, DWORD PTR $T564108[ebp]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z$1:
	mov	esi, DWORD PTR $T564109[ebp]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__ehhandler$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-116]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z ENDP ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::operator()<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list0>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind_template.hpp
;	COMDAT ??R?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE_NXZ
_TEXT	SEGMENT
$T564181 = -4						; size = 1
??R?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE_NXZ PROC ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::operator(), COMDAT
; _this$ = eax

; 18   :     {

	push	ecx
	push	esi

; 19   :         list0 a;
; 20   :         BOOST_BIND_RETURN l_(type<result_type>(), f_, a, 0);

	mov	BYTE PTR $T564181[esp+8], 0
	mov	ecx, DWORD PTR $T564181[esp+8]
	push	eax
	push	ecx
	lea	esi, DWORD PTR [eax+8]
	call	??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::operator()<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list0>
	pop	esi

; 21   :     }

	pop	ecx
	ret	0
??R?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE_NXZ ENDP ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::operator()
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\detail\thread.hpp
_TEXT	ENDS
;	COMDAT ?run@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEXXZ
_TEXT	SEGMENT
$T564196 = -4						; size = 1
?run@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEXXZ PROC ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::run, COMDAT
; _this$ = ecx

; 55   :             {

	push	ecx
	push	esi

; 56   :                 f();

	lea	eax, DWORD PTR [ecx+32]
	mov	BYTE PTR $T564196[esp+8], 0
	mov	ecx, DWORD PTR $T564196[esp+8]
	push	eax
	push	ecx
	lea	esi, DWORD PTR [eax+8]
	call	??$?R_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@Vlist0@_bi@2@@?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE_NV?$type@_N@12@AAV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@AAVlist0@12@J@Z ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::operator()<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list0>
	pop	esi

; 57   :             }

	pop	ecx
	ret	0
?run@?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@UAEXXZ ENDP ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::run
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Construct_n@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Construct_n@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Construct_n, COMDAT
; _this$ = esi
; __Count$ = edi

; 545  : 		{	// construct from _Count * _Val

	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	push	ebp

; 546  : 		if (_Buy(_Count))

	xor	ebp, ebp
	mov	DWORD PTR [esi+12], ebp
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebp
	cmp	edi, ebp
	je	SHORT $LN5@Construct_@5
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN10@Construct_@5
	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN50@Construct_@5:
$LN10@Construct_@5:
	mov	ecx, edi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	ecx, edi
	mov	edx, eax
	cmp	edi, ebp
	jbe	SHORT $LN40@Construct_@5
	npad	3
$LL42@Construct_@5:
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR [edx], ebp
	dec	ecx
	add	edx, 4
	test	ecx, ecx
	ja	SHORT $LL42@Construct_@5
$LN40@Construct_@5:
	lea	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+16], edx
$LN5@Construct_@5:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();
; 552  : 			_RERAISE;
; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	pop	ebp
	pop	ebx
	ret	4
$LN49@Construct_@5:
?_Construct_n@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Construct_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Construct@I@?$vector@HV?$allocator@H@std@@@std@@QAEXIIU_Int_iterator_tag@1@@Z
_TEXT	SEGMENT
$T564414 = -4						; size = 4
___formal$ = 8						; size = 1
??$_Construct@I@?$vector@HV?$allocator@H@std@@@std@@QAEXIIU_Int_iterator_tag@1@@Z PROC ; std::vector<int,std::allocator<int> >::_Construct<unsigned int>, COMDAT
; _this$ = esi
; __Count$ = edi
; __Val$ = eax

; 525  : 		void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)

	sub	esp, 8

; 526  : 		{	// initialize with _Count * _Val
; 527  : 		size_type _Size = (size_type)_Count;
; 528  : 		_Construct_n(_Size, (_Ty)_Val);

	lea	ecx, DWORD PTR $T564414[esp+8]
	push	ecx
	mov	DWORD PTR $T564414[esp+12], eax
	call	?_Construct_n@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z ; std::vector<int,std::allocator<int> >::_Construct_n

; 529  : 		}

	add	esp, 8
	ret	4
??$_Construct@I@?$vector@HV?$allocator@H@std@@@std@@QAEXIIU_Int_iterator_tag@1@@Z ENDP ; std::vector<int,std::allocator<int> >::_Construct<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
_TEXT	ENDS
;	COMDAT ??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV?$vector@NV?$allocator@N@std@@@std@@@Z
_TEXT	SEGMENT
??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV?$vector@NV?$allocator@N@std@@@std@@@Z PROC ; boost::_bi::value<std::vector<double,std::allocator<double> > >::value<std::vector<double,std::allocator<double> > >, COMDAT
; _this$ = esi
; _t$ = eax

; 116  :     value(T const & t): t_(t) {}

	push	ecx
	push	eax
	push	esi
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	eax, esi
	pop	ecx
	ret	0
??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV?$vector@NV?$allocator@N@std@@@std@@@Z ENDP ; boost::_bi::value<std::vector<double,std::allocator<double> > >::value<std::vector<double,std::allocator<double> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; boost::_bi::value<std::vector<int,std::allocator<int> > >::value<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = esi
; _t$ = eax

; 116  :     value(T const & t): t_(t) {}

	push	ecx
	push	eax
	push	esi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, esi
	pop	ecx
	ret	0
??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; boost::_bi::value<std::vector<int,std::allocator<int> > >::value<std::vector<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV012@@Z PROC ; boost::_bi::value<std::vector<int,std::allocator<int> > >::value<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = esi
; ___that$ = eax
	push	ecx
	push	eax
	push	esi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, esi
	pop	ecx
	ret	0
??0?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@ABV012@@Z ENDP ; boost::_bi::value<std::vector<int,std::allocator<int> > >::value<std::vector<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z
_TEXT	SEGMENT
??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z PROC ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = esi
; ___that$ = eax
	push	ecx
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [eax+8]
	movq	QWORD PTR [esi+8], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	add	eax, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR [esi+24]
	push	eax
	movq	QWORD PTR [esi+16], xmm0
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, esi
	pop	ecx
	ret	0
??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z ENDP ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV012@@Z PROC ; boost::_bi::value<std::vector<double,std::allocator<double> > >::value<std::vector<double,std::allocator<double> > >, COMDAT
; _this$ = esi
; ___that$ = eax
	push	ecx
	push	eax
	push	esi
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	eax, esi
	pop	ecx
	ret	0
??0?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@ABV012@@Z ENDP ; boost::_bi::value<std::vector<double,std::allocator<double> > >::value<std::vector<double,std::allocator<double> > >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z$0
__ehfuncinfo$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z PROC ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >, COMDAT
; ___that$ = ecx
	push	-1
	push	__ehhandler$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	esi, DWORD PTR _this$[esp+20]
	movq	xmm0, QWORD PTR [edi]
	movq	QWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edi+8]
	lea	ecx, DWORD PTR [edi+24]
	movq	QWORD PTR [esi+8], xmm0
	movq	xmm0, QWORD PTR [edi+16]
	lea	eax, DWORD PTR [esi+24]
	push	ecx
	push	eax
	movq	QWORD PTR [esi+16], xmm0
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	add	edi, 48					; 00000030H
	push	edi
	lea	edx, DWORD PTR [esi+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+40], 0
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	jmp	??1?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@XZ
__ehhandler$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z ENDP ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z$0
__ehfuncinfo$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z PROC ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >, COMDAT
; ___that$ = ecx
	push	-1
	push	__ehhandler$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	esi, DWORD PTR _this$[esp+20]
	push	esi
	call	??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@ABU012@@Z
	add	edi, 72					; 00000048H
	push	edi
	lea	eax, DWORD PTR [esi+72]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+40], 0
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	jmp	??1?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@XZ
__ehhandler$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z ENDP ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABU012@@Z
_TEXT	SEGMENT
??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABU012@@Z PROC ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >, COMDAT
; _this$ = esi
; ___that$ = edi
	push	ecx
	push	esi
	mov	ecx, edi
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], eax
	mov	ecx, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], ecx
	mov	eax, esi
	pop	ecx
	ret	0
??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABU012@@Z ENDP ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABV012@@Z PROC ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >, COMDAT
; _this$ = esi
; ___that$ = edi
	push	ecx
	push	esi
	mov	ecx, edi
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], eax
	mov	ecx, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], ecx
	mov	eax, esi
	pop	ecx
	ret	0
??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@ABV012@@Z ENDP ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@ABV012@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@ABV012@@Z PROC ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >, COMDAT
; ___that$ = eax
	push	ecx
	mov	ecx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]
	push	esi
	push	edi
	lea	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [ebx], ecx
	lea	edi, DWORD PTR [ebx+8]
	push	edi
	mov	ecx, esi
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	edx, DWORD PTR [esi+96]
	mov	DWORD PTR [edi+96], edx
	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [edi+100], eax
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ecx
	ret	4
??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@ABV012@@Z ENDP ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z$0
__ehfuncinfo$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T564640 = 12						; size = 4
__Last$ = 12						; size = 4
??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> ><unsigned int>, COMDAT
; __First$ = edi

; 513  : 		{	// construct from [_First, _Last)

	push	-1
	push	__ehhandler$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+16]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@allocator@5
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@allocator@5
$LN13@allocator@5:
	xor	eax, eax
$LN14@allocator@5:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[esp+28], 0

; 514  : 		_Construct(_First, _Last, _Iter_cat(_First));

	mov	eax, DWORD PTR __Last$[esp+16]
	lea	ecx, DWORD PTR $T564640[esp+16]
	push	ecx
	mov	DWORD PTR $T564640[esp+20], eax
	call	?_Construct_n@?$vector@HV?$allocator@H@std@@@std@@QAEXIABH@Z ; std::vector<int,std::allocator<int> >::_Construct_n

; 515  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> ><unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@IABQAVTransaction@DRAMsimII@@@Z
_TEXT	SEGMENT
__Newvec$227809 = -4					; size = 4
tv523 = 8						; size = 4
__Capacity$ = 8						; size = 4
_this$ = 8						; size = 4
__Where$ = 12						; size = 8
__Tmp$227834 = 20					; size = 4
__Tmp$227824 = 20					; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@IABQAVTransaction@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Insert_n, COMDAT
; __Count$ = eax

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [ebx+12]
	push	esi
	mov	esi, eax
	test	edx, edx
	jne	SHORT $LN29@Insert_n@7
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@7
$LN29@Insert_n@7:
	mov	eax, DWORD PTR [ebx+20]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@7:

; 1162 : 
; 1163 : 		if (_Count == 0)

	test	esi, esi
	je	$LN1@Insert_n@7
	push	ebp

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebp, DWORD PTR [ebx+16]
	mov	eax, ebp
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, esi
	jae	SHORT $LN12@Insert_n@7

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Xlen
$LN126@Insert_n@7:
$LN12@Insert_n@7:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+esi]
	push	edi
	cmp	ecx, edx
	jae	$LN10@Insert_n@7

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	edi, 1073741823				; 3fffffffH
	sub	edi, eax
	cmp	edi, ecx
	jae	SHORT $LN17@Insert_n@7
	mov	DWORD PTR __Capacity$[esp+16], 0
	mov	ecx, DWORD PTR __Capacity$[esp+16]
	jmp	SHORT $LN18@Insert_n@7
$LN17@Insert_n@7:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+16], ecx
$LN18@Insert_n@7:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@7

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+16], edx
	mov	ecx, edx
$LN9@Insert_n@7:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	call	?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Transaction *>::allocate

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebp, DWORD PTR __Where$[esp+20]
	sub	ebp, DWORD PTR [ebx+12]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[esp+16]
	sar	ebp, 2
	lea	edi, DWORD PTR [eax+ebp*4]
	mov	DWORD PTR __Newvec$227809[esp+20], eax
	call	?_Ufill@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV34@IABQAV34@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+20]
	mov	ecx, DWORD PTR [ebx+12]
	mov	edi, DWORD PTR __Newvec$227809[esp+20]
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN79@Insert_n@7
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edi
	call	_memmove_s
	mov	edx, DWORD PTR __Where$[esp+36]
	add	esp, 16					; 00000010H
$LN79@Insert_n@7:

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [ebx+16]
	sub	eax, edx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN110@Insert_n@7
	add	eax, eax
	add	eax, eax
	push	eax
	push	edx
	push	eax
	add	ebp, esi
	lea	eax, DWORD PTR [edi+ebp*4]
	push	eax
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN110@Insert_n@7:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [ebx+16]
	sub	ecx, eax
	sar	ecx, 2
	add	esi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN117@Insert_n@7

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN117@Insert_n@7:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+16]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi+esi*4]
	lea	eax, DWORD PTR [edi+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [ebx+12], edi
	pop	edi
	pop	ebp
	pop	esi
	mov	DWORD PTR [ebx+20], eax
	mov	DWORD PTR [ebx+16], ecx
	pop	ebx

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	16					; 00000010H
$LN10@Insert_n@7:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edi, DWORD PTR __Where$[esp+20]
	mov	edx, ebp
	sub	edx, edi
	sar	edx, 2
	cmp	edx, esi
	jae	SHORT $LN3@Insert_n@7

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[esp+16]
	mov	ecx, DWORD PTR [eax]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR tv523[esp+16], eax
	lea	edx, DWORD PTR [eax+edi]
	mov	eax, ebp
	mov	DWORD PTR __Tmp$227824[esp+16], ecx
	call	??$_Umove@PAPAVTransaction@DRAMsimII@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV23@00@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<DRAMsimII::Transaction * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edi, DWORD PTR [ebx+16]
	mov	edx, edi
	sub	edx, DWORD PTR __Where$[esp+20]
	sar	edx, 2
	sub	esi, edx
	lea	edx, DWORD PTR __Tmp$227824[esp+16]
	call	?_Ufill@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV34@IABQAV34@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv523[esp+16]
	add	DWORD PTR [ebx+16], eax
	mov	ebx, DWORD PTR [ebx+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	ecx, DWORD PTR __Tmp$227824[esp+16]
	push	ecx
	mov	ecx, ebx
	sub	ecx, eax
	mov	eax, DWORD PTR __Where$[esp+24]

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	call	??$fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z ; std::fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>
	add	esp, 4
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	16					; 00000010H
$LN3@Insert_n@7:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[esp+16]
	mov	eax, DWORD PTR [edx]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	add	esi, esi
	mov	DWORD PTR __Tmp$227834[esp+16], eax
	add	esi, esi
	mov	edi, ebp
	sub	edi, esi
	mov	edx, ebp
	mov	eax, ebp
	call	??$_Umove@PAPAVTransaction@DRAMsimII@@@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEPAPAVTransaction@DRAMsimII@@PAPAV23@00@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Umove<DRAMsimII::Transaction * *>
	mov	DWORD PTR [ebx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, edi
	mov	edi, DWORD PTR __Where$[esp+20]
	mov	ecx, ebp
	call	??$_Unchecked_move_backward@PAPAVTransaction@DRAMsimII@@PAPAV12@@stdext@@YAPAPAVTransaction@DRAMsimII@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<DRAMsimII::Transaction * *,DRAMsimII::Transaction * *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+20]
	lea	ecx, DWORD PTR __Tmp$227834[esp+16]
	push	ecx
	lea	ecx, DWORD PTR [esi+eax]
	call	??$fill@PAPAVTransaction@DRAMsimII@@PAV12@@std@@YAXPAPAVTransaction@DRAMsimII@@0ABQAV12@@Z ; std::fill<DRAMsimII::Transaction * *,DRAMsimII::Transaction *>
	add	esp, 4
	pop	edi
	pop	ebp
$LN1@Insert_n@7:
	pop	esi
	pop	ebx

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	16					; 00000010H
$LN124@Insert_n@7:
?_Insert_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@IABQAVTransaction@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Insert_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE_NI@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax

; 1104 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@15

; 1105 : 			return (false);

	xor	al, al

; 1115 : 		}

	ret	0
$LN4@Buy@15:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@15

; 1107 : 			_Xlen();	// result too long

	jmp	?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Xlen
$LN2@Buy@15:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Transaction *>::allocate
	mov	DWORD PTR [esi+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1

; 1115 : 		}

	ret	0
?_Buy@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIPAVTransaction@DRAMsimII@@@Z
_TEXT	SEGMENT
$T565169 = -24						; size = 8
$T565171 = -16						; size = 8
$T565167 = -16						; size = 8
$T565170 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 8						; size = 4
?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIPAVTransaction@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize, COMDAT
; _this$ = eax

; 717  : 		{	// determine new length, padding with _Val elements as needed

	sub	esp, 24					; 00000018H
	push	ebx
	mov	ebx, DWORD PTR __Newsize$[esp+24]
	push	esi
	mov	esi, eax

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR [esi+12]
	push	edi
	mov	edi, DWORD PTR [esi+16]
	mov	eax, edi
	sub	eax, ecx
	sar	eax, 2
	mov	DWORD PTR __Val$[esp+32], 0
	cmp	ebx, eax
	jbe	SHORT $LN60@resize@2

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	cmp	ecx, edi
	jbe	SHORT $LN13@resize@2
	call	__invalid_parameter_noinfo
$LN13@resize@2:
	mov	edx, DWORD PTR [esi+16]
	sub	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR __Val$[esp+32]
	push	eax
	push	edi
	sar	edx, 2
	push	ecx
	mov	eax, ebx
	sub	eax, edx
	push	esi
	call	?_Insert_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@IABQAVTransaction@DRAMsimII@@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Insert_n
	pop	edi
	pop	esi
	pop	ebx

; 722  : 		}

	add	esp, 24					; 00000018H
	ret	4
$LN60@resize@2:

; 720  : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize@2

; 721  : 			erase(begin() + _Newsize, end());

	cmp	ecx, edi
	jbe	SHORT $LN33@resize@2
	call	__invalid_parameter_noinfo
$LN33@resize@2:
	mov	eax, DWORD PTR [esi]
	push	ebp
	mov	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR $T565167[esp+40], eax
	cmp	ebp, DWORD PTR [esi+16]
	jbe	SHORT $LN49@resize@2
	call	__invalid_parameter_noinfo
$LN49@resize@2:
	mov	ecx, DWORD PTR [esi]
	push	ebx
	lea	edx, DWORD PTR $T565170[esp+44]
	push	edx
	lea	eax, DWORD PTR $T565169[esp+48]
	mov	DWORD PTR $T565169[esp+48], ecx
	mov	DWORD PTR $T565169[esp+52], ebp
	call	??H?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::operator+
	mov	ecx, DWORD PTR $T565167[esp+40]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	push	edi
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T565171[esp+56]
	push	ecx
	call	?erase@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@2@0@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::erase
	pop	ebp
$LN1@resize@2:
	pop	edi
	pop	esi
	pop	ebx

; 722  : 		}

	add	esp, 24					; 00000018H
	ret	4
?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIPAVTransaction@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Construct_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIABQAVTransaction@DRAMsimII@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Construct_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIABQAVTransaction@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Construct_n, COMDAT
; _this$ = esi
; __Count$ = edi

; 545  : 		{	// construct from _Count * _Val

	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	push	ebp

; 546  : 		if (_Buy(_Count))

	xor	ebp, ebp
	mov	DWORD PTR [esi+12], ebp
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebp
	cmp	edi, ebp
	je	SHORT $LN5@Construct_@6
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN10@Construct_@6
	call	?_Xlen@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Xlen
$LN50@Construct_@6:
$LN10@Construct_@6:
	mov	ecx, edi
	call	?allocate@?$allocator@PAVTransaction@DRAMsimII@@@std@@QAEPAPAVTransaction@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Transaction *>::allocate
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	ecx, edi
	mov	edx, eax
	cmp	edi, ebp
	jbe	SHORT $LN40@Construct_@6
	npad	3
$LL42@Construct_@6:
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR [edx], ebp
	dec	ecx
	add	edx, 4
	test	ecx, ecx
	ja	SHORT $LL42@Construct_@6
$LN40@Construct_@6:
	lea	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+16], edx
$LN5@Construct_@6:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();
; 552  : 			_RERAISE;
; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	pop	ebp
	pop	ebx
	ret	4
$LN49@Construct_@6:
?_Construct_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIABQAVTransaction@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Construct_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize, COMDAT
; __Newsize$ = eax

; 713  : 		resize(_Newsize, _Ty());

	push	eax
	mov	eax, DWORD PTR _this$[esp]
	call	?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIPAVTransaction@DRAMsimII@@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize

; 714  : 		}

	ret	4
?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
$T565592 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z PROC ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >, COMDAT
; __Count$ = edi

; 482  : 		{	// construct from _Count * _Ty()

	push	-1
	push	__ehhandler$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@43
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@43
$LN13@vector@43:
	xor	eax, eax
$LN14@vector@43:
	mov	DWORD PTR [esi], eax

; 483  : 		_Construct_n(_Count, _Ty());

	lea	eax, DWORD PTR $T565592[esp+24]
	mov	DWORD PTR __$EHRec$[esp+32], ecx
	push	eax
	mov	DWORD PTR $T565592[esp+28], ecx
	call	?_Construct_n@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIABQAVTransaction@DRAMsimII@@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::_Construct_n

; 484  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z ENDP ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
;	COMDAT xdata$x
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
xdata$x	SEGMENT
__unwindtable$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z$1
__ehfuncinfo$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\detail\thread.hpp
xdata$x	ENDS
;	COMDAT ??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_f_$ = 12						; size = 112
??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z PROC ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >, COMDAT

; 49   :             {}

	push	-1
	push	__ehhandler$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	edi, DWORD PTR _this$[esp+20]
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??0thread_data_base@detail@boost@@QAE@XZ ; boost::detail::thread_data_base::thread_data_base
	mov	BYTE PTR __$EHRec$[esp+32], 1
	mov	eax, DWORD PTR _f_$[esp+20]
	lea	esi, DWORD PTR [edi+40]
	mov	DWORD PTR [edi], OFFSET ??_7?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@6B@
	push	esi
	lea	ecx, DWORD PTR _f_$[esp+32]
	mov	DWORD PTR [edi+32], eax
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	ecx, DWORD PTR _f_$[esp+124]
	mov	edx, DWORD PTR _f_$[esp+128]
	mov	DWORD PTR [esi+96], ecx
	mov	DWORD PTR [esi+100], edx
	lea	esi, DWORD PTR _f_$[esp+28]
	call	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 12					; 0000000cH
	ret	116					; 00000074H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z$0:
	lea	eax, DWORD PTR _f_$[ebp-4]
	jmp	??1?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1thread_data_base@detail@boost@@UAE@XZ ; boost::detail::thread_data_base::~thread_data_base
__ehhandler$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z ENDP ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\list
xdata$x	SEGMENT
__unwindtable$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$2
	DD	0ffffffffH
	DD	00H
__catchsym$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$0
__tryblocktable$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$7
__ehfuncinfo$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\win32\thread_heap_alloc.hpp
xdata$x	ENDS
;	COMDAT ??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
_TEXT	SEGMENT
$T580897 = -44						; size = 12
$T580882 = -32						; size = 4
$T580881 = -28						; size = 4
_heap_memory$ = -24					; size = 4
_heap_memory$580901 = -20				; size = 4
__$EHRec$ = -16						; size = 16
??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z PROC ; boost::detail::heap_new_impl<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &>, COMDAT
; _a1$ = ecx

; 155  :         {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 156  :             void* const heap_memory=allocate_raw_heap_memory(sizeof(T));

	push	144					; 00000090H
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapAlloc@12
	mov	ebx, eax
	mov	DWORD PTR _heap_memory$580901[ebp], ebx
	test	ebx, ebx
	jne	SHORT $LN12@heap_new_i
	push	1
	push	OFFSET __bad_alloc_Message
	lea	ecx, DWORD PTR $T580897[ebp]
	call	??0exception@std@@QAE@ABQBDH@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T580897[ebp]
	push	eax
	mov	DWORD PTR $T580897[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN32@heap_new_i:
$LN12@heap_new_i:

; 157  :             try
; 158  :             {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR _heap_memory$[ebp], ebx

; 159  :                 T* const data=new (heap_memory) T(a1);

	mov	DWORD PTR $T580881[ebp], ebx
	sub	esp, 112				; 00000070H
	mov	eax, esp
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	mov	ecx, DWORD PTR [esi]
	lea	edi, DWORD PTR [eax+8]
	mov	DWORD PTR $T580882[ebp], esp
	mov	DWORD PTR [eax], ecx
	add	esi, 8
	push	edi
	mov	ecx, esi
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	edx, DWORD PTR [esi+96]
	mov	DWORD PTR [edi+96], edx
	mov	eax, DWORD PTR [esi+100]
	push	ebx
	mov	DWORD PTR [edi+100], eax
	call	??0?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@2@@Z ; boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >

; 166  :             }
; 167  :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$0:

; 160  :                 return data;
; 161  :             }
; 162  :             catch(...)
; 163  :             {
; 164  :                 free_raw_heap_memory(heap_memory);

	mov	ecx, DWORD PTR _heap_memory$580901[ebp]
	push	ecx
	call	?free_raw_heap_memory@detail@boost@@YAXPAX@Z ; boost::detail::free_raw_heap_memory
	add	esp, 4

; 165  :                 throw;

	push	0
	push	0
	call	__CxxThrowException@8
$LN33@heap_new_i:
$LN31@heap_new_i:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$2:
	mov	eax, DWORD PTR _heap_memory$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T580881[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ENDP ; boost::detail::heap_new_impl<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &>
; Function compile flags: /Ogtpy
;	COMDAT ??$heap_new@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
_TEXT	SEGMENT
??$heap_new@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z PROC ; boost::detail::heap_new<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >, COMDAT
; _a1$ = ecx

; 225  :         {

	push	ecx

; 226  :             return heap_new_impl<T,A1&>(a1);

	call	??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ; boost::detail::heap_new_impl<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &>
	pop	ecx

; 227  :         }

	ret	0
??$heap_new@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ENDP ; boost::detail::heap_new<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
xdata$x	SEGMENT
__unwindtable$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$0
__ehfuncinfo$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\detail\thread.hpp
xdata$x	ENDS
;	COMDAT ??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
_TEXT	SEGMENT
$T580947 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_f$ = 8							; size = 112
??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z PROC ; boost::thread::make_thread_info<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >, COMDAT
; ___$ReturnUdt$ = edi

; 135  :         {

	push	-1
	push	__ehhandler$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	xor	esi, esi
	mov	DWORD PTR $T580947[esp+28], esi

; 136  :             return detail::thread_data_ptr(detail::heap_new<detail::thread_data<F> >(f));

	lea	ecx, DWORD PTR _f$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], esi
	call	??$heap_new_impl@V?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@detail@boost@@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@3@@detail@boost@@YAPAV?$thread_data@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@01@AAV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ; boost::detail::heap_new_impl<boost::detail::thread_data<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >,boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > &>
	mov	DWORD PTR [edi], eax
	cmp	eax, esi
	je	SHORT $LN11@make_threa
	add	eax, 4
	mov	ecx, 1
	lock	 xadd	 DWORD PTR [eax], ecx
$LN11@make_threa:
	lea	esi, DWORD PTR _f$[esp+32]
	call	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
	mov	eax, edi

; 137  :         }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z$0:
	lea	eax, DWORD PTR _f$[ebp-4]
	jmp	??1?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@XZ
__ehhandler$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ENDP ; boost::thread::make_thread_info<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z$0
__ehfuncinfo$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\storage.hpp
xdata$x	ENDS
;	COMDAT ??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_a1$ = 8						; size = 4
_a2$ = 12						; size = 8
_a3$ = 20						; size = 8
_a4$ = 28						; size = 24
??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z PROC ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = esi

; 178  :     storage4( A1 a1, A2 a2, A3 a3, A4 a4 ): storage3<A1, A2, A3>( a1, a2, a3 ), a4_( a4 ) {}

	push	-1
	push	__ehhandler$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi
	mov	eax, DWORD PTR _a1$[esp+20]
	mov	edx, DWORD PTR _a2$[esp+24]
	mov	ecx, DWORD PTR _a2$[esp+20]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _a3$[esp+20]
	mov	DWORD PTR [esi+12], edx
	lea	edx, DWORD PTR _a4$[esp+20]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR _a3$[esp+24]
	push	edx
	lea	eax, DWORD PTR [esi+24]
	push	eax
	mov	DWORD PTR [esi+20], ecx
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, DWORD PTR _a4$[esp+32]
	cmp	eax, edi
	je	SHORT $LN21@storage4@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@storage4@2:
	mov	ecx, DWORD PTR _a4$[esp+20]
	push	ecx
	mov	DWORD PTR _a4$[esp+36], edi
	mov	DWORD PTR _a4$[esp+40], edi
	mov	DWORD PTR _a4$[esp+44], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	add	esp, 16					; 00000010H
	ret	44					; 0000002cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z$0:
	lea	esi, DWORD PTR _a4$[ebp-4]
	jmp	??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ
__ehhandler$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z ENDP ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z$3
__ehfuncinfo$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\storage.hpp
xdata$x	ENDS
;	COMDAT ??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z
_TEXT	SEGMENT
$T581086 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_a1$ = 12						; size = 4
_a2$ = 16						; size = 8
_a3$ = 24						; size = 8
_a4$ = 32						; size = 24
_a5$ = 56						; size = 24
??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z PROC ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >, COMDAT

; 227  :     storage5( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5 ): storage4<A1, A2, A3, A4>( a1, a2, a3, a4 ), a5_( a5 ) {}

	push	-1
	push	__ehhandler$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+24]
	sub	esp, 24					; 00000018H
	mov	DWORD PTR $T581086[esp+52], esp
	mov	eax, esp
	lea	ecx, DWORD PTR _a4$[esp+48]
	push	ecx
	push	eax
	mov	DWORD PTR __$EHRec$[esp+68], 1
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	edx, DWORD PTR _a3$[esp+52]
	mov	eax, DWORD PTR _a3$[esp+48]
	mov	ecx, DWORD PTR _a2$[esp+52]
	push	edx
	mov	edx, DWORD PTR _a2$[esp+52]
	push	eax
	mov	eax, DWORD PTR _a1$[esp+56]
	push	ecx
	push	edx
	push	eax
	call	??0?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@@Z ; boost::_bi::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >::storage4<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > > >
	lea	ecx, DWORD PTR _a5$[esp+24]
	push	ecx
	lea	edx, DWORD PTR [esi+48]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+44], 2
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	eax, DWORD PTR _a4$[esp+36]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN21@storage5@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@storage5@2:
	mov	eax, DWORD PTR _a4$[esp+24]
	push	eax
	mov	DWORD PTR _a4$[esp+40], edi
	mov	DWORD PTR _a4$[esp+44], edi
	mov	DWORD PTR _a4$[esp+48], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a5$[esp+40]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN38@storage5@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN38@storage5@2:
	mov	ecx, DWORD PTR _a5$[esp+24]
	push	ecx
	mov	DWORD PTR _a5$[esp+40], edi
	mov	DWORD PTR _a5$[esp+44], edi
	mov	DWORD PTR _a5$[esp+48], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	72					; 00000048H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z$0:
	lea	esi, DWORD PTR _a5$[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z$1:
	lea	esi, DWORD PTR _a4$[ebp-4]
	jmp	??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z$3:
	mov	esi, DWORD PTR _this$[ebp-4]
	jmp	??1?$storage4@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@@_bi@boost@@QAE@XZ
__ehhandler$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z ENDP ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$5
__ehfuncinfo$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\storage.hpp
xdata$x	ENDS
;	COMDAT ??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z
_TEXT	SEGMENT
$T581247 = -20						; size = 4
$T581248 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_a1$ = 12						; size = 4
_a2$ = 16						; size = 8
_a3$ = 24						; size = 8
_a4$ = 32						; size = 24
_a5$ = 56						; size = 24
_a6$ = 80						; size = 24
??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z PROC ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >, COMDAT

; 276  :     storage6( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6 ): storage5<A1, A2, A3, A4, A5>( a1, a2, a3, a4, a5 ), a6_( a6 ) {}

	push	-1
	push	__ehhandler$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+32]
	sub	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[esp+68], 2
	mov	DWORD PTR $T581247[esp+60], esp
	mov	eax, esp
	lea	ecx, DWORD PTR _a5$[esp+56]
	push	ecx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	DWORD PTR $T581248[esp+84], esp
	mov	eax, esp
	lea	edx, DWORD PTR _a4$[esp+80]
	push	edx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+100], 3
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, DWORD PTR _a3$[esp+84]
	mov	ecx, DWORD PTR _a3$[esp+80]
	mov	edx, DWORD PTR _a2$[esp+84]
	push	eax
	mov	eax, DWORD PTR _a2$[esp+84]
	push	ecx
	mov	ecx, DWORD PTR _a1$[esp+88]
	push	edx
	push	eax
	push	ecx
	push	esi
	mov	BYTE PTR __$EHRec$[esp+116], 2
	call	??0?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@@Z ; boost::_bi::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage5<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
	lea	edx, DWORD PTR _a6$[esp+32]
	push	edx
	lea	eax, DWORD PTR [esi+72]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+52], 4
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	eax, DWORD PTR _a4$[esp+44]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN26@storage6@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@storage6@2:
	mov	ecx, DWORD PTR _a4$[esp+32]
	push	ecx
	mov	DWORD PTR _a4$[esp+48], edi
	mov	DWORD PTR _a4$[esp+52], edi
	mov	DWORD PTR _a4$[esp+56], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a5$[esp+48]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN43@storage6@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN43@storage6@2:
	mov	edx, DWORD PTR _a5$[esp+32]
	push	edx
	mov	DWORD PTR _a5$[esp+48], edi
	mov	DWORD PTR _a5$[esp+52], edi
	mov	DWORD PTR _a5$[esp+56], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a6$[esp+48]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN60@storage6@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN60@storage6@2:
	mov	eax, DWORD PTR _a6$[esp+32]
	push	eax
	mov	DWORD PTR _a6$[esp+48], edi
	mov	DWORD PTR _a6$[esp+52], edi
	mov	DWORD PTR _a6$[esp+56], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 24					; 00000018H
	ret	96					; 00000060H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$0:
	lea	esi, DWORD PTR _a6$[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$1:
	lea	esi, DWORD PTR _a5$[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$2:
	lea	esi, DWORD PTR _a4$[ebp-4]
	jmp	??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$3:
	mov	esi, DWORD PTR $T581247[ebp]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z$5:
	mov	esi, DWORD PTR _this$[ebp-4]
	jmp	??1?$storage5@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@@_bi@boost@@QAE@XZ
__ehhandler$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z ENDP ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$4
__ehfuncinfo$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\storage.hpp
xdata$x	ENDS
;	COMDAT ??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
_TEXT	SEGMENT
$T581484 = -24						; size = 4
$T581485 = -20						; size = 4
$T581486 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_a1$ = 8						; size = 4
_a2$ = 12						; size = 8
_a3$ = 20						; size = 8
_a4$ = 28						; size = 24
_a5$ = 52						; size = 24
_a6$ = 76						; size = 24
_a7$ = 100						; size = 8
??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z PROC ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >, COMDAT
; _this$ = esi

; 325  :     storage7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7 ): storage6<A1, A2, A3, A4, A5, A6>( a1, a2, a3, a4, a5, a6 ), a7_( a7 ) {}

	push	-1
	push	__ehhandler$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	sub	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[esp+64], 2
	mov	DWORD PTR $T581484[esp+56], esp
	mov	eax, esp
	lea	ecx, DWORD PTR _a6$[esp+52]
	push	ecx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+88], 3
	mov	DWORD PTR $T581485[esp+80], esp
	mov	eax, esp
	lea	edx, DWORD PTR _a5$[esp+76]
	push	edx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	DWORD PTR $T581486[esp+104], esp
	mov	eax, esp
	lea	ecx, DWORD PTR _a4$[esp+100]
	push	ecx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+120], 4
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	edx, DWORD PTR _a3$[esp+104]
	mov	eax, DWORD PTR _a3$[esp+100]
	mov	ecx, DWORD PTR _a2$[esp+104]
	push	edx
	mov	edx, DWORD PTR _a2$[esp+104]
	push	eax
	mov	eax, DWORD PTR _a1$[esp+108]
	push	ecx
	push	edx
	push	eax
	push	esi
	mov	BYTE PTR __$EHRec$[esp+136], 2
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3@Z ; boost::_bi::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >::storage6<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > > >
	mov	eax, DWORD PTR _a4$[esp+40]
	mov	ecx, DWORD PTR _a7$[esp+28]
	mov	edx, DWORD PTR _a7$[esp+32]
	xor	edi, edi
	mov	DWORD PTR [esi+96], ecx
	mov	DWORD PTR [esi+100], edx
	cmp	eax, edi
	je	SHORT $LN26@storage7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@storage7:
	mov	eax, DWORD PTR _a4$[esp+28]
	push	eax
	mov	DWORD PTR _a4$[esp+44], edi
	mov	DWORD PTR _a4$[esp+48], edi
	mov	DWORD PTR _a4$[esp+52], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a5$[esp+44]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN43@storage7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN43@storage7:
	mov	ecx, DWORD PTR _a5$[esp+28]
	push	ecx
	mov	DWORD PTR _a5$[esp+44], edi
	mov	DWORD PTR _a5$[esp+48], edi
	mov	DWORD PTR _a5$[esp+52], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a6$[esp+44]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN60@storage7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN60@storage7:
	mov	edx, DWORD PTR _a6$[esp+28]
	push	edx
	mov	DWORD PTR _a6$[esp+44], edi
	mov	DWORD PTR _a6$[esp+48], edi
	mov	DWORD PTR _a6$[esp+52], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	add	esp, 24					; 00000018H
	ret	100					; 00000064H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$0:
	lea	esi, DWORD PTR _a6$[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$1:
	lea	esi, DWORD PTR _a5$[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$2:
	lea	esi, DWORD PTR _a4$[ebp-4]
	jmp	??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$3:
	mov	esi, DWORD PTR $T581484[ebp]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$4:
	mov	esi, DWORD PTR $T581485[ebp]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__ehhandler$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z ENDP ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$4
__ehfuncinfo$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind.hpp
xdata$x	ENDS
;	COMDAT ??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
_TEXT	SEGMENT
$T581722 = -24						; size = 4
$T581723 = -20						; size = 4
$T581724 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_a1$ = 8						; size = 4
_a2$ = 12						; size = 8
_a3$ = 20						; size = 8
_a4$ = 28						; size = 24
_a5$ = 52						; size = 24
_a6$ = 76						; size = 24
_a7$ = 100						; size = 8
??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z PROC ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >, COMDAT
; _this$ = ecx

; 623  :     list7( A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7 ): base_type( a1, a2, a3, a4, a5, a6, a7 ) {}

	push	-1
	push	__ehhandler$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[esp+48], 2
	mov	eax, DWORD PTR _a7$[esp+40]
	mov	ecx, DWORD PTR _a7$[esp+36]
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	mov	DWORD PTR $T581722[esp+72], esp
	mov	eax, esp
	lea	edx, DWORD PTR _a6$[esp+68]
	push	edx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+104], 3
	mov	DWORD PTR $T581723[esp+96], esp
	mov	eax, esp
	lea	ecx, DWORD PTR _a5$[esp+92]
	push	ecx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	DWORD PTR $T581724[esp+120], esp
	mov	eax, esp
	lea	edx, DWORD PTR _a4$[esp+116]
	push	edx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+136], 4
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, DWORD PTR _a3$[esp+120]
	mov	ecx, DWORD PTR _a3$[esp+116]
	mov	edx, DWORD PTR _a2$[esp+120]
	push	eax
	mov	eax, DWORD PTR _a2$[esp+120]
	push	ecx
	mov	ecx, DWORD PTR _a1$[esp+124]
	push	edx
	push	eax
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+148], 2
	call	??0?$storage7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z ; boost::_bi::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::storage7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
	mov	eax, DWORD PTR _a4$[esp+48]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN26@list7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@list7:
	mov	edx, DWORD PTR _a4$[esp+36]
	push	edx
	mov	DWORD PTR _a4$[esp+52], edi
	mov	DWORD PTR _a4$[esp+56], edi
	mov	DWORD PTR _a4$[esp+60], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a5$[esp+52]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN43@list7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN43@list7:
	mov	eax, DWORD PTR _a5$[esp+36]
	push	eax
	mov	DWORD PTR _a5$[esp+52], edi
	mov	DWORD PTR _a5$[esp+56], edi
	mov	DWORD PTR _a5$[esp+60], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a6$[esp+52]
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN60@list7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN60@list7:
	mov	ecx, DWORD PTR _a6$[esp+36]
	push	ecx
	mov	DWORD PTR _a6$[esp+52], edi
	mov	DWORD PTR _a6$[esp+56], edi
	mov	DWORD PTR _a6$[esp+60], edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 28					; 0000001cH
	ret	100					; 00000064H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$0:
	lea	esi, DWORD PTR _a6$[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$1:
	lea	esi, DWORD PTR _a5$[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$2:
	lea	esi, DWORD PTR _a4$[ebp-4]
	jmp	??1?$value@V?$vector@HV?$allocator@H@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$3:
	mov	esi, DWORD PTR $T581722[ebp]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z$4:
	mov	esi, DWORD PTR $T581723[ebp]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__ehhandler$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-24]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z ENDP ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@ABV?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@12@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_f$ = 12						; size = 4
??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@ABV?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@12@@Z PROC ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >, COMDAT
; _l$ = edi

; 859  :     bind_t(F f, L const & l): f_(f), l_(l) {}

	push	ecx
	mov	eax, DWORD PTR _f$[esp]
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]
	push	esi
	lea	esi, DWORD PTR [ebx+8]
	push	esi
	mov	ecx, edi
	mov	DWORD PTR [ebx], eax
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	ecx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], ecx
	mov	edx, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], edx
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ecx
	ret	8
??0?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@V?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@2@ABV?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@12@@Z ENDP ; boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
xdata$x	SEGMENT
__unwindtable$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z$3
__ehfuncinfo$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\thread\detail\thread.hpp
xdata$x	ENDS
;	COMDAT ??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z
_TEXT	SEGMENT
$T581975 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_f$ = 12						; size = 112
??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z PROC ; boost::thread::thread<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >, COMDAT

; 187  :         {

	push	-1
	push	__ehhandler$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR _this$[esp+28]
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+40], eax
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR [ebx+4], eax
	sub	esp, 112				; 00000070H
	mov	eax, esp
	mov	BYTE PTR __$EHRec$[esp+152], 1
	mov	ecx, DWORD PTR _f$[esp+140]
	lea	esi, DWORD PTR [eax+8]
	mov	DWORD PTR $T581975[esp+144], esp
	mov	DWORD PTR [eax], ecx
	push	esi
	lea	ecx, DWORD PTR _f$[esp+152]
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	edx, DWORD PTR _f$[esp+244]
	mov	DWORD PTR [esi+96], edx
	mov	eax, DWORD PTR _f$[esp+248]
	lea	edi, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+100], eax
	call	??$make_thread_info@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@CA?AV?$intrusive_ptr@Uthread_data_base@detail@boost@@@1@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@@Z ; boost::thread::make_thread_info<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
	add	esp, 112				; 00000070H

; 188  :             start_thread();

	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+40], 2
	call	?start_thread@thread@boost@@AAEXXZ	; boost::thread::start_thread

; 189  :         }

	lea	esi, DWORD PTR _f$[esp+36]
	call	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	116					; 00000074H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z$0:
	lea	eax, DWORD PTR _f$[ebp-4]
	jmp	??1?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@QAE@XZ
__unwindfunclet$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1mutex@boost@@QAE@XZ			; boost::mutex::~mutex
__unwindfunclet$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 8
	jmp	??1?$intrusive_ptr@Uthread_data_base@detail@boost@@@boost@@QAE@XZ ; boost::intrusive_ptr<boost::detail::thread_data_base>::~intrusive_ptr<boost::detail::thread_data_base>
__ehhandler$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z ENDP ; boost::thread::thread<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$6
__ehfuncinfo$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\boost\boost_1_40\boost\bind\bind_mf_cc.hpp
xdata$x	ENDS
;	COMDAT ??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z
_TEXT	SEGMENT
$T582037 = -124						; size = 4
$T582033 = -120						; size = 104
__$EHRec$ = -12						; size = 12
$T582050 = 8						; size = 4
$T582040 = 8						; size = 4
$T582039 = 8						; size = 4
$T582038 = 8						; size = 4
$T582035 = 8						; size = 4
$T582034 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_a1$ = 12						; size = 4
$T582036 = 16						; size = 4
_a7$ = 16						; size = 8
_a2$ = 24						; size = 8
_a3$ = 32						; size = 8
_a4$ = 40						; size = 24
_a5$ = 64						; size = 24
_a6$ = 88						; size = 24
??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z PROC ; boost::bind<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64,DRAMsimII::Channel *,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>, COMDAT

; 175  : {

	push	-1
	push	__ehhandler$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+148]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+144]
	xor	ebx, ebx
	mov	DWORD PTR $T582050[esp+144], ebx

; 176  :     typedef _mfi::BOOST_BIND_MF_NAME(cmf6)<R, T, B1, B2, B3, B4, B5, B6> F;
; 177  :     typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
; 178  :     return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));

	sub	esp, 8
	mov	DWORD PTR __$EHRec$[esp+164], 2
	mov	ecx, DWORD PTR _a7$[esp+152]
	mov	edx, DWORD PTR _a7$[esp+156]
	mov	eax, esp
	mov	DWORD PTR $T582034[esp+152], esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR $T582035[esp+176], esp
	mov	eax, esp
	lea	ecx, DWORD PTR _a6$[esp+176]
	push	ecx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+212], 3
	mov	DWORD PTR $T582036[esp+200], esp
	mov	eax, esp
	lea	edx, DWORD PTR _a5$[esp+200]
	push	edx
	push	eax
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	DWORD PTR $T582037[esp+228], esp
	mov	eax, esp
	lea	ecx, DWORD PTR _a4$[esp+224]
	push	ecx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+244], 4
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	movsd	xmm0, QWORD PTR _a3$[esp+224]
	mov	edx, DWORD PTR _a1$[esp+224]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T582038[esp+232], esp
	movsd	QWORD PTR [eax], xmm0
	movsd	xmm0, QWORD PTR _a2$[esp+232]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T582039[esp+240], esp
	push	ecx
	movsd	QWORD PTR [eax], xmm0
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	lea	ecx, DWORD PTR $T582033[esp+248]
	mov	DWORD PTR $T582040[esp+244], esp
	mov	BYTE PTR __$EHRec$[esp+256], 2
	call	??0?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@V?$value@PAVChannel@DRAMsimII@@@12@V?$value@N@12@1V?$value@V?$vector@HV?$allocator@H@std@@@std@@@12@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@12@3V?$value@_J@12@@Z ; boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> >
	mov	esi, eax
	lea	edi, DWORD PTR [ebp+8]
	mov	BYTE PTR __$EHRec$[esp+156], 5
	push	edi
	mov	ecx, esi
	mov	DWORD PTR [ebp], OFFSET ?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z ; DRAMsimII::Channel::sendPower
	call	??0?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@ABU012@@Z
	mov	eax, DWORD PTR [esi+96]
	mov	DWORD PTR [edi+96], eax
	mov	ecx, DWORD PTR [esi+100]
	lea	esi, DWORD PTR $T582033[esp+148]
	mov	DWORD PTR [edi+100], ecx
	call	??1?$storage6@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@@_bi@boost@@QAE@XZ
	mov	eax, DWORD PTR _a4$[esp+156]
	cmp	eax, ebx
	je	SHORT $LN49@bind
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@bind:
	mov	edx, DWORD PTR _a4$[esp+144]
	push	edx
	mov	DWORD PTR _a4$[esp+160], ebx
	mov	DWORD PTR _a4$[esp+164], ebx
	mov	DWORD PTR _a4$[esp+168], ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a5$[esp+160]
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN64@bind
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN64@bind:
	mov	eax, DWORD PTR _a5$[esp+144]
	push	eax
	mov	DWORD PTR _a5$[esp+160], ebx
	mov	DWORD PTR _a5$[esp+164], ebx
	mov	DWORD PTR _a5$[esp+168], ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _a6$[esp+160]
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN79@bind
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN79@bind:
	mov	ecx, DWORD PTR _a6$[esp+144]
	push	ecx
	mov	DWORD PTR _a6$[esp+160], ebx
	mov	DWORD PTR _a6$[esp+164], ebx
	mov	DWORD PTR _a6$[esp+168], ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, ebp

; 179  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+148]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 128				; 00000080H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$0:
	lea	esi, DWORD PTR _a6$[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$1:
	lea	esi, DWORD PTR _a5$[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$2:
	lea	ecx, DWORD PTR _a4$[ebp-4]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$3:
	mov	esi, DWORD PTR $T582035[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$4:
	mov	esi, DWORD PTR $T582036[ebp-4]
	jmp	??1?$value@V?$vector@NV?$allocator@N@std@@@std@@@_bi@boost@@QAE@XZ
__unwindfunclet$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z$6:
	lea	esi, DWORD PTR $T582033[ebp]
	jmp	??1?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@boost@@QAE@XZ
__ehhandler$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-132]
	mov	ecx, DWORD PTR [edx-136]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z ENDP ; boost::bind<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64,DRAMsimII::Channel *,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$11
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
_TEXT	SEGMENT
$T582277 = -52						; size = 8
__Ok$ = -44						; size = 8
__Nput_fac$220763 = -36					; size = 4
$T582326 = -32						; size = 1
__Lock$582312 = -32					; size = 4
$T582274 = -28						; size = 4
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
$T582278 = 12						; size = 8
__Val$ = 12						; size = 8
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT

; 411  : 		{	// insert a double

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR _this$[ebp]

; 412  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 413  : 		const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __State$[ebp], edi
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], edi

; 414  : 
; 415  : 		if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	je	$LN13@operator@325

; 416  : 			{	// state okay, use facet to insert
; 417  : 			const _Nput& _Nput_fac = _USE(ios_base::getloc(), _Nput);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T582274[ebp]
	push	eax
	add	ecx, esi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	ebx, DWORD PTR $T582274[ebp]
	mov	DWORD PTR __Nput_fac$220763[ebp], eax
	test	ebx, ebx
	je	SHORT $LN19@operator@325
	push	0
	lea	ecx, DWORD PTR __Lock$582312[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jbe	SHORT $LN21@operator@325
	cmp	eax, -1
	jae	SHORT $LN21@operator@325
	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN21@operator@325:
	mov	edi, DWORD PTR [ebx+4]
	neg	edi
	sbb	edi, edi
	not	edi
	lea	ecx, DWORD PTR __Lock$582312[ebp]
	and	edi, ebx
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	edi, edi
	je	SHORT $LN19@operator@325
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, edi
	call	eax
$LN19@operator@325:

; 418  : 
; 419  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 420  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 421  : 				_Myios::fill(), _Val).failed())

	fld	QWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+esi+40]
	add	ecx, esi
	mov	cl, BYTE PTR [ecx+48]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	BYTE PTR $T582326[ebp], cl
	mov	ebx, DWORD PTR $T582326[ebp]
	mov	ecx, DWORD PTR __Nput_fac$220763[ebp]
	mov	edi, DWORD PTR [ecx]
	push	ebx
	add	eax, esi
	push	eax
	push	edx
	mov	BYTE PTR $T582277[ebp], 0
	mov	edx, DWORD PTR $T582277[ebp]
	push	edx
	mov	edx, DWORD PTR [edi+12]
	lea	eax, DWORD PTR $T582278[ebp]
	push	eax
	call	edx
	cmp	BYTE PTR $T582278[ebp], 0
	je	SHORT $LN1@operator@325

; 422  : 				_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4
$LN1@operator@325:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN13@operator@325
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$0:

; 423  : 			_CATCH_IO_END

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	or	eax, 4
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN42@operator@325
	or	eax, 4
$LN42@operator@325:
	push	1
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN79@operator@325
	ret	0
$LN79@operator@325:
	mov	esi, DWORD PTR _this$[ebp]
$LN13@operator@325:

; 424  : 			}
; 425  : 
; 426  : 		_Myios::setstate(_State);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __State$[ebp]
	add	ecx, esi
	test	edx, edx
	je	SHORT $LN71@operator@325
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN73@operator@325
	or	eax, 4
$LN73@operator@325:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN71@operator@325:

; 427  : 		return (*this);

	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, esi

; 428  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$3:
	lea	ecx, DWORD PTR $T582274[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$11
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
_TEXT	SEGMENT
$T582424 = -48						; size = 8
$T582423 = -48						; size = 8
__Ok$ = -40						; size = 8
__Nput_fac$220749 = -32					; size = 4
$T582472 = -28						; size = 1
__Lock$582456 = -28					; size = 4
$T582420 = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Val$ = 12						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT

; 391  : 		{	// insert a float

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR _this$[ebp]

; 392  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 393  : 		const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __State$[ebp], edi
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], edi

; 394  : 
; 395  : 		if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	je	$LN13@operator@326

; 396  : 			{	// state okay, use facet to insert
; 397  : 			const _Nput& _Nput_fac = _USE(ios_base::getloc(), _Nput);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T582420[ebp]
	push	eax
	add	ecx, esi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	ebx, DWORD PTR $T582420[ebp]
	mov	DWORD PTR __Nput_fac$220749[ebp], eax
	test	ebx, ebx
	je	SHORT $LN19@operator@326
	push	0
	lea	ecx, DWORD PTR __Lock$582456[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jbe	SHORT $LN21@operator@326
	cmp	eax, -1
	jae	SHORT $LN21@operator@326
	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN21@operator@326:
	mov	edi, DWORD PTR [ebx+4]
	neg	edi
	sbb	edi, edi
	not	edi
	lea	ecx, DWORD PTR __Lock$582456[ebp]
	and	edi, ebx
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	edi, edi
	je	SHORT $LN19@operator@326
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, edi
	call	eax
$LN19@operator@326:

; 398  : 
; 399  : 			_TRY_IO_BEGIN
; 400  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 401  : 				_Myios::fill(), (double)_Val).failed())

	movss	xmm0, DWORD PTR __Val$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+esi+40]
	add	ecx, esi
	sub	esp, 8
	mov	BYTE PTR $T582423[ebp], 0
	mov	cl, BYTE PTR [ecx+48]
	mov	BYTE PTR $T582472[ebp], cl
	mov	ebx, DWORD PTR $T582472[ebp]
	mov	ecx, DWORD PTR __Nput_fac$220749[ebp]
	mov	edi, DWORD PTR [ecx]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	ebx
	add	eax, esi
	push	eax
	push	edx
	mov	edx, DWORD PTR $T582423[ebp]
	push	edx
	mov	edx, DWORD PTR [edi+12]
	lea	eax, DWORD PTR $T582424[ebp]
	push	eax
	call	edx
	cmp	BYTE PTR $T582424[ebp], 0
	je	SHORT $LN1@operator@326

; 402  : 				_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4
$LN1@operator@326:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN13@operator@326
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$0:

; 403  : 			_CATCH_IO_END

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	or	eax, 4
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN42@operator@326
	or	eax, 4
$LN42@operator@326:
	push	1
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN79@operator@326
	ret	0
$LN79@operator@326:
	mov	esi, DWORD PTR _this$[ebp]
$LN13@operator@326:

; 404  : 			}
; 405  : 
; 406  : 		_Myios::setstate(_State);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __State$[ebp]
	add	ecx, esi
	test	edx, edx
	je	SHORT $LN71@operator@326
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN73@operator@326
	or	eax, 4
$LN73@operator@326:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN71@operator@326:

; 407  : 		return (*this);

	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, esi

; 408  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$3:
	lea	ecx, DWORD PTR $T582420[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?retireCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::retireCommand
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
$T582566 = -16						; size = 16
_this$ = 8						; size = 4
?retireCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z PROC ; DRAMsimII::Channel::retireCommand
; _newestCommand$ = eax

; 364  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+20]
	push	esi
	push	edi
	mov	edi, eax

; 365  : 	statistics.collectCommandStats(newestCommand);

	mov	eax, DWORD PTR [ebp+180]
	push	eax
	call	?collectCommandStats@Statistics@DRAMsimII@@QAEXPBVCommand@2@@Z ; DRAMsimII::Statistics::collectCommandStats

; 366  : 
; 367  : 	assert(((newestCommand->isReadOrWrite() || newestCommand->isRefresh()) && newestCommand->getHost()) ||
; 368  : 		(!(newestCommand->isReadOrWrite() || newestCommand->isRefresh()) && !newestCommand->getHost()));
; 369  : 
; 370  : 	// transaction complete? if so, put incomingTransaction completion queue
; 371  : 	// note that the host transaction should only be pointed to by a CAS command
; 372  : 	// since this is when a transaction is done from the standpoint of the requester
; 373  : 	if (Transaction *completedTransaction = newestCommand->removeHost())

	mov	ebx, DWORD PTR [edi+84]
	mov	DWORD PTR [edi+84], 0
	test	ebx, ebx
	je	SHORT $LN7@retireComm

; 374  : 	{
; 375  : 		DEBUG_TRANSACTION_LOG("-T " << *completedTransaction);
; 376  : 
; 377  : 		if (!newestCommand->isRefresh())

	cmp	DWORD PTR [edi+80], 12			; 0000000cH
	je	SHORT $LN21@retireComm

; 378  : 		{
; 379  : 			statistics.collectTransactionStats(completedTransaction);

	mov	ecx, DWORD PTR [ebp+180]
	push	ebx
	push	ecx
	call	?collectTransactionStats@Statistics@DRAMsimII@@QAEXPBVTransaction@2@@Z ; DRAMsimII::Statistics::collectTransactionStats

; 380  : 
; 381  : 			assert(newestCommand->getEnqueueTime() >= completedTransaction->getEnqueueTime() && 
; 382  : 				newestCommand->getCompletionTime() <= completedTransaction->getCompletionTime());
; 383  : 
; 384  : 			const unsigned origTrans = completedTransaction->getOriginalTransaction();

	mov	eax, DWORD PTR [ebx+108]

; 385  : 
; 386  : 			M5_DEBUG(assert(origTrans < UINT_MAX));
; 387  : 
; 388  : 			if (origTrans < UINT_MAX)

	cmp	eax, -1
	jae	SHORT $LN21@retireComm

; 389  : 				finishedTransactions.push(std::pair<unsigned,tick>(origTrans, completedTransaction->getCompletionTime()));

	mov	edx, DWORD PTR [ebx+32]
	mov	DWORD PTR $T582566[esp+32], eax
	mov	eax, DWORD PTR [ebx+36]
	lea	ecx, DWORD PTR $T582566[esp+32]
	push	ecx
	lea	esi, DWORD PTR [ebp+392]
	mov	DWORD PTR $T582566[esp+44], edx
	mov	DWORD PTR $T582566[esp+48], eax
	call	?push_back@?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@std@@QAEXABU?$pair@I_J@2@@Z ; std::deque<std::pair<unsigned int,__int64>,std::allocator<std::pair<unsigned int,__int64> > >::push_back
$LN21@retireComm:

; 390  : 		}
; 391  : 		else
; 392  : 		{
; 393  : 			assert(systemConfig.getRefreshPolicy() != NO_REFRESH);
; 394  : 		}
; 395  : 
; 396  : 		delete completedTransaction;

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, ebx
	call	eax
$LN7@retireComm:

; 397  : 
; 398  : 	}
; 399  : 	assert(!newestCommand->getHost());
; 400  : 
; 401  : 	delete lastCommand;

	mov	ecx, DWORD PTR [ebp+24]
	test	ecx, ecx
	je	SHORT $LN23@retireComm
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	1
	call	eax
$LN23@retireComm:

; 402  : 
; 403  : 	lastCommand = newestCommand;

	mov	DWORD PTR [ebp+24], edi

; 404  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
?retireCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ENDP ; DRAMsimII::Channel::retireCommand
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
;	COMDAT ?insert@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@H@Z
_TEXT	SEGMENT
_item$ = 8						; size = 4
_offset$ = 12						; size = 4
?insert@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@H@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::insert, COMDAT
; _this$ = eax

; 310  : 		{

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 311  : 			assert(offset <= (int)count);
; 312  : 
; 313  : 			if (count == entry.size())

	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	push	edi
	mov	edi, DWORD PTR [esi]
	sar	eax, 2
	cmp	edi, eax

; 314  : 				return false;

	je	SHORT $LN41@insert@17

; 315  : 
; 316  : 			else if (item == NULL)

	cmp	DWORD PTR _item$[esp+16], 0
	jne	SHORT $LN5@insert@17

; 317  : 			{
; 318  : 				std::cerr << "Attempting to insert NULL into queue" << std::endl;

	push	OFFSET ??_C@_0CF@LLADOICC@Attempting?5to?5insert?5NULL?5into?5q@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN41@insert@17:

; 319  : 				return false;

	xor	al, al

; 333  : 
; 334  : 				return true;
; 335  : 			}
; 336  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
$LN5@insert@17:

; 320  : 				//_exit(2);
; 321  : 			}
; 322  : 			else
; 323  : 			{
; 324  : 				// move everything back by one unit
; 325  : 				for (int i = count - 1 ; i >= offset ; --i)

	dec	edi
	cmp	edi, DWORD PTR _offset$[esp+16]
	jl	SHORT $LN1@insert@17
$LL3@insert@17:

; 326  : 					entry[(head + i + 1) % entry.size()] = entry[(head + i) % entry.size()];

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	ebx, edx
	jb	SHORT $LN18@insert@17
	call	__invalid_parameter_noinfo
$LN18@insert@17:
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [esi+4]
	sub	ecx, eax
	lea	ebp, DWORD PTR [eax+ebx*4]
	lea	eax, DWORD PTR [edx+edi+1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+28]
	sub	eax, DWORD PTR [esi+24]
	sar	eax, 2
	mov	ebx, edx
	cmp	ebx, eax
	jb	SHORT $LN25@insert@17
	call	__invalid_parameter_noinfo
$LN25@insert@17:
	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [ebp]
	dec	edi
	cmp	edi, DWORD PTR _offset$[esp+16]
	mov	DWORD PTR [ecx+ebx*4], edx
	jge	SHORT $LL3@insert@17
$LN1@insert@17:

; 327  : 
; 328  : 				count++;

	inc	DWORD PTR [esi]

; 329  : 
; 330  : 				entry[(head + offset) % entry.size()] = item;

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	add	eax, DWORD PTR _offset$[esp+16]
	xor	edx, edx
	sar	ecx, 2
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN32@insert@17
	call	__invalid_parameter_noinfo
$LN32@insert@17:
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR _item$[esp+16]
	mov	DWORD PTR [eax+edi*4], ecx

; 331  : 
; 332  : 				tail = (tail + 1) % entry.size();	// advance tail_ptr

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+8]
	inc	eax
	sar	ecx, 2
	xor	edx, edx
	div	ecx

; 333  : 
; 334  : 				return true;
; 335  : 			}
; 336  : 		}

	pop	edi
	mov	al, 1
	mov	DWORD PTR [esi+8], edx
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
?insert@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@H@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_front@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z
_TEXT	SEGMENT
_item$ = 8						; size = 4
?push_front@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::push_front, COMDAT
; _this$ = eax

; 167  : 		{

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _item$[esp+4]
	push	esi
	mov	esi, eax

; 168  : 			assert(item != NULL);
; 169  : 			if (count == entry.size())

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi]
	sar	ecx, 2
	push	edi
	cmp	eax, ecx

; 170  : 				return false;

	je	SHORT $LN22@push_front@2

; 171  : 			else if (item == NULL)

	test	ebx, ebx
	jne	SHORT $LN2@push_front@2

; 172  : 			{
; 173  : 				std::cerr << "Input pointer is NULL" << std::endl;

	push	OFFSET ??_C@_0BG@KEOIJAJD@Input?5pointer?5is?5NULL?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN22@push_front@2:

; 174  : 				return false;

	xor	al, al

; 181  : 				return true;
; 182  : 			}
; 183  : 		}

	pop	edi
	pop	esi
	pop	ebx
	pop	ecx
	ret	4
$LN2@push_front@2:

; 175  : 			}
; 176  : 			else
; 177  : 			{
; 178  : 				count++;

	inc	eax
	mov	DWORD PTR [esi], eax

; 179  : 				head = ((int)head > 0) ? head - 1 : entry.size() - 1;

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jle	SHORT $LN7@push_front@2
	lea	edi, DWORD PTR [eax-1]
	jmp	SHORT $LN8@push_front@2
$LN7@push_front@2:
	mov	edi, DWORD PTR [esi+28]
	sub	edi, DWORD PTR [esi+24]
	sar	edi, 2
	dec	edi
$LN8@push_front@2:
	mov	DWORD PTR [esi+4], edi

; 180  : 				entry[head] = item;

	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN17@push_front@2
	call	__invalid_parameter_noinfo
$LN17@push_front@2:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], ebx

; 181  : 				return true;
; 182  : 			}
; 183  : 		}

	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx
	pop	ecx
	ret	4
?push_front@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::push_front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z
_TEXT	SEGMENT
_item$ = 8						; size = 4
?push@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::push, COMDAT
; _this$ = eax

; 147  : 		{

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _item$[esp+4]
	push	esi
	mov	esi, eax

; 148  : 			assert(item != NULL);
; 149  : 			if (count == entry.size())

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi]
	sar	ecx, 2
	push	edi
	cmp	eax, ecx

; 150  : 				return false;

	je	SHORT $LN20@push@2

; 151  : 			else if (item == NULL)

	test	ebx, ebx
	jne	SHORT $LN2@push@2

; 152  : 			{
; 153  : 				std::cerr << "Input pointer is NULL" << std::endl;

	push	OFFSET ??_C@_0BG@KEOIJAJD@Input?5pointer?5is?5NULL?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN20@push@2:

; 154  : 				return false;

	xor	al, al

; 161  : 				return true;
; 162  : 			}
; 163  : 		}

	pop	edi
	pop	esi
	pop	ebx
	pop	ecx
	ret	4
$LN2@push@2:

; 155  : 			}
; 156  : 			else
; 157  : 			{
; 158  : 				count++;
; 159  : 				entry[tail] = item;

	mov	edi, DWORD PTR [esi+8]
	inc	eax
	mov	DWORD PTR [esi], eax
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN13@push@2
	call	__invalid_parameter_noinfo
$LN13@push@2:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+edi*4], ebx

; 160  : 				tail = (tail + 1) % entry.size(); 	//advance tail_ptr

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+8]
	inc	eax
	sar	ecx, 2
	xor	edx, edx
	div	ecx

; 161  : 				return true;
; 162  : 			}
; 163  : 		}

	pop	edi
	mov	al, 1
	mov	DWORD PTR [esi+8], edx
	pop	esi
	pop	ebx
	pop	ecx
	ret	4
?push@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::push
_TEXT	ENDS
PUBLIC	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVChannel@0@@Z ; DRAMsimII::operator<<
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVChannel@0@@Z PROC ; DRAMsimII::operator<<
; _os$ = ecx
; _r$ = eax

; 3061 : {

	push	ebx
	push	esi
	push	edi
	mov	edi, eax

; 3062 : 	os << "T[" << r.time << "] ch[" << r.channelID << endl;

	mov	eax, DWORD PTR [edi+360]
	mov	edx, DWORD PTR [edi+8]
	push	eax
	mov	esi, ecx
	mov	ecx, DWORD PTR [edi+12]
	push	OFFSET ??_C@_05JPECMJL@?$FN?5ch?$FL?$AA@
	push	ecx
	push	edx
	push	OFFSET ??_C@_02DCEECEBO@T?$FL?$AA@
	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 3063 : 	os << r.timingSpecification << endl;

	mov	eax, DWORD PTR [edi+84]
	push	OFFSET ??_C@_02PBFOLPKM@?$FN?5?$AA@
	push	eax
	push	OFFSET ??_C@_05MKELIOBI@rtrs?$FL?$AA@
	push	esi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 3064 : 	os << r.powerModel << endl;

	lea	eax, DWORD PTR [edi+184]
	call	??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVPowerConfig@0@@Z ; DRAMsimII::operator<<
	mov	edi, eax
	push	10					; 0000000aH
	mov	ecx, edi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, edi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	pop	edi

; 3065 : 	return os;

	mov	eax, esi
	pop	esi
	pop	ebx

; 3066 : }

	ret	0
??6DRAMsimII@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVChannel@0@@Z ENDP ; DRAMsimII::operator<<
_TEXT	ENDS
PUBLIC	__real@41cdcd6500000000
PUBLIC	?printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@2@@Z ; DRAMsimII::Channel::printVerilogCommand
;	COMDAT ?lastTime@?1??printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@3@@Z@4_JA
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.h
_BSS	SEGMENT
?lastTime@?1??printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@3@@Z@4_JA DQ 01H DUP (?) ; `DRAMsimII::Channel::printVerilogCommand'::`2'::lastTime
_BSS	ENDS
;	COMDAT __real@41cdcd6500000000
CONST	SEGMENT
__real@41cdcd6500000000 DQ 041cdcd6500000000r	; 1e+009
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
CONST	ENDS
_TEXT	SEGMENT
tv588 = -12						; size = 8
tv237 = -12						; size = 4
tv146 = -12						; size = 4
?printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@2@@Z PROC ; DRAMsimII::Channel::printVerilogCommand
; _this$ = ecx
; _thisCommand$ = eax

; 2982 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, eax

; 2983 : 	static tick lastTime;
; 2984 : 
; 2985 : 	systemConfig.verilogOutStream << "nop(" << (time - lastTime) / systemConfig.getDatarate() * 1.0E9 << "); //" << time - lastTime << endl;

	mov	eax, DWORD PTR [edi+176]
	lea	ecx, DWORD PTR [eax+216]
	test	ecx, ecx
	je	SHORT $LN12@printVeril
	lea	edx, DWORD PTR [eax+224]
	jmp	SHORT $LN13@printVeril
$LN12@printVeril:
	xor	edx, edx
$LN13@printVeril:
	fld	QWORD PTR [eax+336]
	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR ?lastTime@?1??printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@3@@Z@4_JA
	mov	ecx, DWORD PTR [edi+12]
	sbb	ecx, DWORD PTR ?lastTime@?1??printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@3@@Z@4_JA+4
	mov	DWORD PTR tv588[esp+28], eax
	mov	DWORD PTR tv588[esp+32], ecx
	fild	QWORD PTR tv588[esp+28]
	push	ecx
	push	eax
	push	OFFSET ??_C@_05DJFABFLL@?$CJ?$DL?5?1?1?$AA@
	fdivrp	ST(1), ST(0)
	push	ecx
	sub	esp, 8
	fmul	QWORD PTR __real@41cdcd6500000000
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_04HFDGOAGB@nop?$CI?$AA@
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ebx, eax
	push	10					; 0000000aH
	mov	ecx, ebx
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 2986 : 
; 2987 : 	lastTime = time;
; 2988 : 
; 2989 : 	if (thisCommand->isRead())

	mov	edx, DWORD PTR [esi+80]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR ?lastTime@?1??printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@3@@Z@4_JA, eax
	mov	DWORD PTR ?lastTime@?1??printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@3@@Z@4_JA+4, ecx
	cmp	edx, 1
	je	SHORT $LN40@printVeril
	cmp	edx, 2
	jne	$LN9@printVeril
$LN40@printVeril:

; 2990 : 	{
; 2991 : 		systemConfig.verilogOutStream << "read\t\t(" << thisCommand->getAddress().getRank() << ",\t"
; 2992 : 			<< thisCommand->getAddress().getBank() << ",\t" << thisCommand->getAddress().getColumn() <<
; 2993 : 			",\t" << (thisCommand->isPrecharge() ? "1" : "0") << ",\t" <<
; 2994 : 			(thisCommand->getLength() < (timingSpecification.tBurst()) ? "1" : "0") << "); //" <<
; 2995 : 			time << endl;

	mov	ebx, DWORD PTR [esi+88]
	mov	ebp, OFFSET ??_C@_01GBGANLPD@0?$AA@
	mov	DWORD PTR tv146[esp+28], OFFSET ??_C@_01HIHLOKLC@1?$AA@
	cmp	ebx, DWORD PTR [edi+32]
	jb	SHORT $LN15@printVeril
	mov	DWORD PTR tv146[esp+28], ebp
$LN15@printVeril:
	cmp	edx, 2
	je	SHORT $LN48@printVeril
	cmp	edx, 4
	je	SHORT $LN48@printVeril
	cmp	edx, 6
	jne	SHORT $LN16@printVeril
$LN48@printVeril:
	mov	ebp, OFFSET ??_C@_01HIHLOKLC@1?$AA@
$LN16@printVeril:
	mov	edi, DWORD PTR [edi+176]
	lea	edx, DWORD PTR [edi+216]
	test	edx, edx
	je	SHORT $LN18@printVeril
	lea	ebx, DWORD PTR [edi+224]
	jmp	SHORT $LN19@printVeril
$LN18@printVeril:
	xor	ebx, ebx
$LN19@printVeril:
	push	ecx
	push	eax
	mov	eax, DWORD PTR tv146[esp+36]
	push	OFFSET ??_C@_05DJFABFLL@?$CJ?$DL?5?1?1?$AA@
	push	ecx
	mov	edx, DWORD PTR [esi+72]
	push	eax
	push	ecx
	mov	edi, DWORD PTR [esi+64]
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	ecx
	push	ebp
	mov	esi, DWORD PTR [esi+60]
	push	ecx
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	ecx
	push	edx
	push	ecx
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	ecx
	push	edi
	push	ecx
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	ecx
	push	esi
	push	ecx
	push	OFFSET ??_C@_07CNLIACOE@read?7?7?$CI?$AA@
$LN141@printVeril:
	push	ebx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
$LN142@printVeril:
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$LN143@printVeril:
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi

; 3017 : 	}
; 3018 : 
; 3019 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH

; 2990 : 	{
; 2991 : 		systemConfig.verilogOutStream << "read\t\t(" << thisCommand->getAddress().getRank() << ",\t"
; 2992 : 			<< thisCommand->getAddress().getBank() << ",\t" << thisCommand->getAddress().getColumn() <<
; 2993 : 			",\t" << (thisCommand->isPrecharge() ? "1" : "0") << ",\t" <<
; 2994 : 			(thisCommand->getLength() < (timingSpecification.tBurst()) ? "1" : "0") << "); //" <<
; 2995 : 			time << endl;

	jmp	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN9@printVeril:

; 2996 : 	}
; 2997 : 	else if (thisCommand->isWrite())

	cmp	edx, 3
	je	SHORT $LN68@printVeril
	cmp	edx, 4
	jne	$LN7@printVeril
$LN68@printVeril:

; 2998 : 	{
; 2999 : 		systemConfig.verilogOutStream << "write\t\t(" << thisCommand->getAddress().getRank() << ",\t" << thisCommand->getAddress().getBank() << ",\t" << thisCommand->getAddress().getColumn() << ",\t" << (thisCommand->isPrecharge() ? "1" : "0") << ",\t" << (thisCommand->getLength() < (timingSpecification.tBurst()) ? "1" : "0") <<
; 3000 : 			",\t0,\t10); //" << time << endl;

	mov	ebx, DWORD PTR [esi+88]
	mov	ebp, OFFSET ??_C@_01GBGANLPD@0?$AA@
	mov	DWORD PTR tv237[esp+28], OFFSET ??_C@_01HIHLOKLC@1?$AA@
	cmp	ebx, DWORD PTR [edi+32]
	jb	SHORT $LN21@printVeril
	mov	DWORD PTR tv237[esp+28], ebp
$LN21@printVeril:
	cmp	edx, 4
	je	SHORT $LN76@printVeril
	cmp	edx, 6
	jne	SHORT $LN22@printVeril
$LN76@printVeril:
	mov	ebp, OFFSET ??_C@_01HIHLOKLC@1?$AA@
$LN22@printVeril:
	mov	edi, DWORD PTR [edi+176]
	lea	edx, DWORD PTR [edi+216]
	test	edx, edx
	je	SHORT $LN24@printVeril
	lea	ebx, DWORD PTR [edi+224]
	jmp	SHORT $LN25@printVeril
$LN24@printVeril:
	xor	ebx, ebx
$LN25@printVeril:
	push	ecx
	push	eax
	mov	eax, DWORD PTR tv237[esp+36]
	push	OFFSET ??_C@_0N@DCHNCKN@?0?70?0?710?$CJ?$DL?5?1?1?$AA@
	push	ecx
	mov	edx, DWORD PTR [esi+72]
	push	eax
	push	ecx
	mov	edi, DWORD PTR [esi+64]
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	ecx
	push	ebp
	mov	esi, DWORD PTR [esi+60]
	push	ecx
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	ecx
	push	edx
	push	ecx
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	ecx
	push	edi
	push	ecx
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	ecx
	push	esi
	push	ecx
	push	OFFSET ??_C@_08JDIKLHND@write?7?7?$CI?$AA@
	jmp	$LN141@printVeril
$LN7@printVeril:

; 3001 : 	}
; 3002 : 	else if (thisCommand->isActivate())

	test	edx, edx
	je	SHORT $LN96@printVeril
	cmp	edx, 8
	jne	SHORT $LN5@printVeril
$LN96@printVeril:

; 3003 : 	{
; 3004 : 		systemConfig.verilogOutStream << "activate\t(" << thisCommand->getAddress().getRank() << ",\t" << 
; 3005 : 			thisCommand->getAddress().getBank() << ",\t" << thisCommand->getAddress().getRow() << "); //" <<
; 3006 : 			time << endl;

	mov	edi, DWORD PTR [edi+176]
	lea	edx, DWORD PTR [edi+216]
	test	edx, edx
	je	SHORT $LN26@printVeril
	lea	ebx, DWORD PTR [edi+224]
	jmp	SHORT $LN27@printVeril
$LN26@printVeril:
	xor	ebx, ebx
$LN27@printVeril:
	mov	edx, DWORD PTR [esi+68]
	mov	edi, DWORD PTR [esi+64]
	push	ecx
	push	eax
	mov	esi, DWORD PTR [esi+60]
	push	OFFSET ??_C@_05DJFABFLL@?$CJ?$DL?5?1?1?$AA@
	push	ecx
	push	edx
	push	ecx
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	ecx
	push	edi
	push	ecx
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	ecx
	push	esi
	push	ecx
	push	OFFSET ??_C@_0L@EDCPHMCE@activate?7?$CI?$AA@
	push	ebx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	jmp	$LN142@printVeril
$LN5@printVeril:

; 3007 : 	}
; 3008 : 	else if (thisCommand->isRefresh())

	cmp	edx, 12					; 0000000cH
	jne	SHORT $LN3@printVeril

; 3009 : 	{
; 3010 : 		systemConfig.verilogOutStream << "refresh(" << thisCommand->getAddress().getRank() << ");" << endl;

	mov	edi, DWORD PTR [edi+176]
	lea	eax, DWORD PTR [edi+216]
	test	eax, eax
	je	SHORT $LN28@printVeril
	lea	eax, DWORD PTR [edi+224]
	jmp	SHORT $LN29@printVeril
$LN28@printVeril:
	xor	eax, eax
$LN29@printVeril:
	mov	esi, DWORD PTR [esi+60]
	push	OFFSET ??_C@_02LJALELK@?$CJ?$DL?$AA@
	push	ecx
	push	esi
	push	ecx
	push	OFFSET ??_C@_08MCOFLILF@refresh?$CI?$AA@
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	jmp	$LN143@printVeril
$LN3@printVeril:

; 3011 : 	}
; 3012 : 	else if (thisCommand->isBasicPrecharge())

	cmp	edx, 6
	jne	$LN1@printVeril

; 3013 : 	{
; 3014 : 		systemConfig.verilogOutStream << "precharge\t(" << thisCommand->getAddress().getRank() << ",\t" <<
; 3015 : 			thisCommand->getAddress().getBank() << ",\t" << "0" << "); //" <<
; 3016 : 			time << endl;

	mov	edi, DWORD PTR [edi+176]
	lea	edx, DWORD PTR [edi+216]
	test	edx, edx
	je	SHORT $LN30@printVeril
	add	edi, 224				; 000000e0H
	jmp	SHORT $LN31@printVeril
$LN30@printVeril:
	xor	edi, edi
$LN31@printVeril:
	mov	edx, DWORD PTR [esi+64]
	push	ecx
	push	eax
	mov	esi, DWORD PTR [esi+60]
	push	OFFSET ??_C@_05DJFABFLL@?$CJ?$DL?5?1?1?$AA@
	push	ecx
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@
	push	ecx
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	ecx
	push	edx
	push	ecx
	push	OFFSET ??_C@_02OACLCCCA@?0?7?$AA@
	push	ecx
	push	esi
	push	ecx
	push	OFFSET ??_C@_0M@EJENEINP@precharge?7?$CI?$AA@
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$LN1@printVeril:

; 3017 : 	}
; 3018 : 
; 3019 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
?printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@2@@Z ENDP ; DRAMsimII::Channel::printVerilogCommand
_TEXT	ENDS
;	COMDAT ?tRAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\timingspecification.h
_BSS	SEGMENT
?tRAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tRAScount
_BSS	ENDS
;	COMDAT ?tCASWotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tCASWotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tCASWotherCount
_BSS	ENDS
;	COMDAT ?tCASotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tCASotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tCASotherCount
_BSS	ENDS
;	COMDAT ?tCASWcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tCASWcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tCASWcount
_BSS	ENDS
;	COMDAT ?tCAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tCAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tCAScount
_BSS	ENDS
;	COMDAT ?tRCDcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tRCDcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tRCDcount
_BSS	ENDS
;	COMDAT ?tRFCcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tRFCcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tRFCcount
_BSS	ENDS
;	COMDAT ?tFAWcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tFAWcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tFAWcount
_BSS	ENDS
;	COMDAT ?tRPcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tRPcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tRPcount
_BSS	ENDS
;	COMDAT ?tRRDcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tRRDcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tRRDcount
_BSS	ENDS
;	COMDAT ?tRCcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
_BSS	SEGMENT
?tRCcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::earliestExecuteTimeLog'::`2'::tRCcount
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_BSS	ENDS
_TEXT	SEGMENT
tv971 = -56						; size = 8
tv444 = -56						; size = 4
tv384 = -56						; size = 8
_nextTime$ = -56					; size = 8
_tCASWLimit$220292 = -48				; size = 8
_tCASOtherLimit$220276 = -48				; size = 8
_tRCLimit$220255 = -48					; size = 8
_tCASLimit$220290 = -40					; size = 8
_tRCDLimit$220273 = -40					; size = 8
_tFAWLimit$220259 = -40					; size = 8
tv1092 = -32						; size = 8
_tRASLimit$220289 = -32					; size = 8
_tCASLimit$220274 = -32					; size = 8
_tRRDLimit$220257 = -32					; size = 8
tv463 = -24						; size = 8
_tCASLimit$220306 = -24					; size = 8
_tCASOtherLimit$220291 = -24				; size = 8
_tCASWLimit$220275 = -24				; size = 8
_tRPLimit$220258 = -24					; size = 8
tv1046 = -16						; size = 8
tv957 = -16						; size = 8
tv382 = -16						; size = 8
tv256 = -16						; size = 8
_tRFCLimit$220260 = -16					; size = 8
tv945 = -8						; size = 8
tv569 = -8						; size = 8
tv307 = -8						; size = 8
tv262 = -8						; size = 8
tv181 = -8						; size = 8
tv85 = -8						; size = 8
_tRASLimit$220305 = -8					; size = 8
_tCASWOtherLimit$220293 = -8				; size = 8
_currentCommand$ = 8					; size = 4
?earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z PROC ; DRAMsimII::Channel::earliestExecuteTimeLog
; _this$ = ecx

; 2788 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 60					; 0000003cH
	push	ebx

; 2789 : 	static unsigned tRCcount, tRRDcount, tRPcount, tFAWcount, tRFCcount;
; 2790 : 	static unsigned tRCDcount, tCAScount, tCASWcount, tCASotherCount, tCASWotherCount;
; 2791 : 	static unsigned tRAScount;
; 2792 : 	tick nextTime;	
; 2793 : 
; 2794 : 	const Rank &currentRank = rank[currentCommand->getAddress().getRank()];

	mov	ebx, DWORD PTR _currentCommand$[ebp]
	push	esi
	mov	esi, DWORD PTR [ebx+60]
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi+384]
	sub	ecx, DWORD PTR [edi+380]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jb	SHORT $LN104@earliestEx@2
	call	__invalid_parameter_noinfo
$LN104@earliestEx@2:
	imul	esi, 200				; 000000c8H
	add	esi, DWORD PTR [edi+380]

; 2795 : 
; 2796 : 	const Bank &currentBank = currentRank.bank[currentCommand->getAddress().getBank()];

	mov	ebx, DWORD PTR [ebx+64]
	mov	ecx, DWORD PTR [esi+188]
	sub	ecx, DWORD PTR [esi+184]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ebx, ecx
	jb	SHORT $LN113@earliestEx@2
	call	__invalid_parameter_noinfo
$LN113@earliestEx@2:

; 2797 : 
; 2798 : 	switch(currentCommand->getCommandType())

	mov	edx, DWORD PTR _currentCommand$[ebp]
	imul	ebx, 152				; 00000098H
	add	ebx, DWORD PTR [esi+184]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, ebx
	cmp	eax, 12					; 0000000cH
	ja	$LN1@earliestEx@2
	movzx	eax, BYTE PTR $LN301@earliestEx@2[eax]
	jmp	DWORD PTR $LN395@earliestEx@2[eax*4]
$LN21@earliestEx@2:

; 2799 : 	{
; 2800 : 	case Command::ACTIVATE:
; 2801 : 		{
; 2802 : 			// refer to Table 11.4 in Memory Systems: Cache, DRAM, Disk
; 2803 : 
; 2804 : 			// respect the row cycle time limitation
; 2805 : 			tick tRCLimit = currentBank.getLastRASTime() + timingSpecification.tRC();

	mov	eax, DWORD PTR [edi+60]
	cdq
	add	eax, DWORD PTR [ecx+48]
	adc	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR _tRCLimit$220255[esp+72], eax

; 2806 : 
; 2807 : 			const tick lastRASTime = currentRank.lastActivateTimes.front();
; 2808 : 
; 2809 : 			// respect the row-to-row activation delay for different banks within a rank
; 2810 : 			tick tRRDLimit = lastRASTime + timingSpecification.tRRD();				

	mov	eax, DWORD PTR [edi+76]
	mov	DWORD PTR _tRCLimit$220255[esp+76], edx
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+156]
	add	ebx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	adc	eax, edx
	mov	DWORD PTR _tRRDLimit$220257[esp+76], eax

; 2811 : 
; 2812 : 			// respect tRP of same bank
; 2813 : 			tick tRPLimit = currentBank.getLastPrechargeTime() + timingSpecification.tRP();

	mov	eax, DWORD PTR [edi+72]
	cdq
	mov	DWORD PTR _tRRDLimit$220257[esp+72], ebx
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+72]

; 2814 : 
; 2815 : 			// respect the t_faw value for DDR2 and beyond, look at the fourth activate ago
; 2816 : 			tick tFAWLimit = currentRank.lastActivateTimes.back() + timingSpecification.tFAW();

	mov	eax, DWORD PTR [esi+160]
	adc	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR _tRPLimit$220258[esp+72], ebx
	mov	DWORD PTR _tRPLimit$220258[esp+76], edx
	cmp	eax, DWORD PTR [esi+148]
	jne	SHORT $LN134@earliestEx@2
	mov	ecx, DWORD PTR [esi+152]
	jmp	SHORT $LN135@earliestEx@2
$LN134@earliestEx@2:
	mov	ecx, eax
$LN135@earliestEx@2:
	mov	eax, DWORD PTR [edi+52]
	cdq
	add	eax, DWORD PTR [ecx-8]
	adc	edx, DWORD PTR [ecx-4]

; 2817 : 
; 2818 : 			// respect tRFC, refresh cycle time
; 2819 : 			tick tRFCLimit = currentRank.getLastRefreshTime() + timingSpecification.tRFC();
; 2820 : 
; 2821 : 			nextTime = max(max(max(tRFCLimit,tRCLimit) , tRPLimit) , max(tRRDLimit , tFAWLimit));

	mov	ecx, DWORD PTR _tRCLimit$220255[esp+76]
	mov	DWORD PTR _tFAWLimit$220259[esp+72], eax
	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR _tFAWLimit$220259[esp+76], edx
	cdq
	add	eax, DWORD PTR [esi+8]
	adc	edx, DWORD PTR [esi+12]
	mov	DWORD PTR _tRFCLimit$220260[esp+72], eax
	cmp	edx, ecx
	jl	SHORT $LN26@earliestEx@2
	jg	SHORT $LN302@earliestEx@2
	cmp	eax, DWORD PTR _tRCLimit$220255[esp+72]
	jbe	SHORT $LN26@earliestEx@2
$LN302@earliestEx@2:
	mov	esi, eax
	mov	ecx, edx
	jmp	SHORT $LN27@earliestEx@2
$LN26@earliestEx@2:
	mov	esi, DWORD PTR _tRCLimit$220255[esp+72]
$LN27@earliestEx@2:
	cmp	ecx, DWORD PTR _tRPLimit$220258[esp+76]
	jl	SHORT $LN30@earliestEx@2
	jg	SHORT $LN303@earliestEx@2
	cmp	esi, ebx
	jbe	SHORT $LN30@earliestEx@2
$LN303@earliestEx@2:
	cmp	edx, DWORD PTR _tRCLimit$220255[esp+76]
	jl	SHORT $LN28@earliestEx@2
	jg	SHORT $LN304@earliestEx@2
	cmp	eax, DWORD PTR _tRCLimit$220255[esp+72]
	jbe	SHORT $LN28@earliestEx@2
$LN304@earliestEx@2:
	mov	ebx, DWORD PTR _tRFCLimit$220260[esp+72]
	mov	esi, edx
	jmp	SHORT $LN31@earliestEx@2
$LN28@earliestEx@2:
	mov	ebx, DWORD PTR _tRCLimit$220255[esp+72]
	mov	esi, DWORD PTR _tRCLimit$220255[esp+76]
	jmp	SHORT $LN31@earliestEx@2
$LN30@earliestEx@2:
	mov	ebx, DWORD PTR _tRPLimit$220258[esp+72]
	mov	esi, DWORD PTR _tRPLimit$220258[esp+76]
$LN31@earliestEx@2:
	mov	ecx, DWORD PTR _tFAWLimit$220259[esp+76]
	cmp	DWORD PTR _tRRDLimit$220257[esp+76], ecx
	jl	SHORT $LN32@earliestEx@2
	jg	SHORT $LN305@earliestEx@2
	mov	eax, DWORD PTR _tFAWLimit$220259[esp+72]
	cmp	DWORD PTR _tRRDLimit$220257[esp+72], eax
	jbe	SHORT $LN32@earliestEx@2
$LN305@earliestEx@2:
	mov	eax, DWORD PTR _tRRDLimit$220257[esp+72]
	mov	ecx, DWORD PTR _tRRDLimit$220257[esp+76]
	jmp	SHORT $LN33@earliestEx@2
$LN32@earliestEx@2:
	mov	eax, DWORD PTR _tFAWLimit$220259[esp+72]
	mov	ecx, DWORD PTR _tFAWLimit$220259[esp+76]
$LN33@earliestEx@2:
	cmp	esi, ecx
	jl	SHORT $LN42@earliestEx@2
	jg	SHORT $LN306@earliestEx@2
	cmp	ebx, eax
	jbe	SHORT $LN42@earliestEx@2
$LN306@earliestEx@2:
	cmp	edx, DWORD PTR _tRCLimit$220255[esp+76]
	jl	SHORT $LN34@earliestEx@2
	jg	SHORT $LN307@earliestEx@2
	mov	ecx, DWORD PTR _tRCLimit$220255[esp+72]
	cmp	DWORD PTR _tRFCLimit$220260[esp+72], ecx
	jbe	SHORT $LN34@earliestEx@2
$LN307@earliestEx@2:
	mov	eax, DWORD PTR _tRFCLimit$220260[esp+72]
	mov	esi, eax
	mov	ecx, edx
	jmp	SHORT $LN35@earliestEx@2
$LN34@earliestEx@2:
	mov	esi, DWORD PTR _tRCLimit$220255[esp+72]
	mov	ecx, DWORD PTR _tRCLimit$220255[esp+76]
	mov	eax, DWORD PTR _tRFCLimit$220260[esp+72]
$LN35@earliestEx@2:
	mov	ebx, DWORD PTR _tRPLimit$220258[esp+76]
	cmp	ecx, ebx
	jl	SHORT $LN38@earliestEx@2
	jg	SHORT $LN308@earliestEx@2
	cmp	esi, DWORD PTR _tRPLimit$220258[esp+72]
	jbe	SHORT $LN38@earliestEx@2
$LN308@earliestEx@2:
	mov	ecx, DWORD PTR _tRCLimit$220255[esp+76]
	cmp	edx, ecx
	jl	SHORT $LN36@earliestEx@2
	jg	SHORT $LN309@earliestEx@2
	cmp	eax, DWORD PTR _tRCLimit$220255[esp+72]
	jbe	SHORT $LN36@earliestEx@2
$LN309@earliestEx@2:
	mov	esi, eax
	mov	eax, edx
	mov	DWORD PTR _nextTime$[esp+76], eax
	jmp	SHORT $LN41@earliestEx@2
$LN36@earliestEx@2:
	mov	esi, DWORD PTR _tRCLimit$220255[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], ecx
	mov	eax, ecx
	jmp	SHORT $LN298@earliestEx@2
$LN38@earliestEx@2:
	mov	esi, DWORD PTR _tRPLimit$220258[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], ebx
	jmp	SHORT $LN388@earliestEx@2
$LN42@earliestEx@2:
	mov	ecx, DWORD PTR _tRRDLimit$220257[esp+76]
	mov	eax, DWORD PTR _tFAWLimit$220259[esp+76]
	cmp	ecx, eax
	jl	SHORT $LN40@earliestEx@2
	jg	SHORT $LN310@earliestEx@2
	mov	esi, DWORD PTR _tRRDLimit$220257[esp+72]
	cmp	esi, DWORD PTR _tFAWLimit$220259[esp+72]
	jbe	SHORT $LN40@earliestEx@2
$LN310@earliestEx@2:
	mov	esi, DWORD PTR _tRRDLimit$220257[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], ecx
	jmp	SHORT $LN388@earliestEx@2
$LN40@earliestEx@2:
	mov	esi, DWORD PTR _tFAWLimit$220259[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], eax
$LN388@earliestEx@2:
	mov	eax, DWORD PTR _nextTime$[esp+76]
$LN41@earliestEx@2:

; 2822 : 
; 2823 : 			if (nextTime == tRCLimit)

	cmp	esi, DWORD PTR _tRCLimit$220255[esp+72]
	jne	SHORT $LN20@earliestEx@2
	cmp	eax, DWORD PTR _tRCLimit$220255[esp+76]
	jne	SHORT $LN20@earliestEx@2
$LN298@earliestEx@2:

; 2824 : 				tRCcount++;				

	inc	DWORD PTR ?tRCcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN20@earliestEx@2:

; 2825 : 			if (nextTime == tRRDLimit)

	cmp	esi, DWORD PTR _tRRDLimit$220257[esp+72]
	jne	SHORT $LN378@earliestEx@2
	cmp	eax, DWORD PTR _tRRDLimit$220257[esp+76]
	jne	SHORT $LN378@earliestEx@2

; 2826 : 				tRRDcount++;

	mov	ecx, 1
	add	DWORD PTR ?tRRDcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA, ecx
	jmp	SHORT $LN19@earliestEx@2
$LN378@earliestEx@2:
	mov	ecx, 1
$LN19@earliestEx@2:

; 2827 : 			if (nextTime == tRPLimit)

	cmp	esi, DWORD PTR _tRPLimit$220258[esp+72]
	jne	SHORT $LN18@earliestEx@2
	cmp	eax, DWORD PTR _tRPLimit$220258[esp+76]
	jne	SHORT $LN18@earliestEx@2

; 2828 : 				tRPcount++;

	add	DWORD PTR ?tRPcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA, ecx
$LN18@earliestEx@2:

; 2829 : 			if (nextTime == tFAWLimit)

	cmp	esi, DWORD PTR _tFAWLimit$220259[esp+72]
	jne	SHORT $LN17@earliestEx@2
	cmp	eax, DWORD PTR _tFAWLimit$220259[esp+76]
	jne	SHORT $LN17@earliestEx@2

; 2830 : 				tFAWcount++;

	add	DWORD PTR ?tFAWcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA, ecx
$LN17@earliestEx@2:

; 2831 : 			if (nextTime == tRFCLimit)

	cmp	esi, DWORD PTR _tRFCLimit$220260[esp+72]
	jne	$LN22@earliestEx@2
	cmp	eax, edx
	jne	$LN22@earliestEx@2

; 2832 : 				tRFCcount++;

	add	DWORD PTR ?tRFCcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA, ecx

; 2833 : 
; 2834 : 			assert(nextTime >= currentBank.getLastPrechargeTime() + timingSpecification.tRP());
; 2835 : 			//DEBUG_TIMING_LOG(currentCommand->getCommandType() << " ras[" << setw(2) << t_ras_gap << "] rrd[" << setw(2) << t_rrd_gap << "] faw[" << setw(2) << t_faw_gap << "] cas[" << setw(2) << t_cas_gap << "] rrd[" << setw(2) << t_rrd_gap << "] rp[" << setw(2) << t_rp_gap << "] min[" << setw(2) << min_gap << "]");
; 2836 : 		}
; 2837 : 		break;

	jmp	$LN22@earliestEx@2
$LN15@earliestEx@2:

; 2838 : 
; 2839 : 	case Command::READ_AND_PRECHARGE:
; 2840 : 		// Auto precharge will be issued as part of command,
; 2841 : 		// but DRAM devices are intelligent enough to delay the prec command
; 2842 : 		// until tRAS timing is met (thanks to tAL), so no need to check tRAS timing requirement here.
; 2843 : 
; 2844 : 	case Command::READ:
; 2845 : 		{
; 2846 : 			//respect last RAS of same rank
; 2847 : 			tick tRCDLimit = currentBank.getLastRASTime() + (timingSpecification.tRCD() - timingSpecification.tAL());

	mov	eax, DWORD PTR [edi+64]
	sub	eax, DWORD PTR [edi+28]
	cdq
	add	eax, DWORD PTR [ecx+48]
	adc	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR _tRCDLimit$220273[esp+72], eax

; 2848 : 
; 2849 : 			// ensure that if no other rank has issued a CAS command that it will treat
; 2850 : 			// this as if a CAS command was issued long ago
; 2851 : 
; 2852 : 			// respect last CAS of same rank
; 2853 : 			// DW 3/9/2006 add these two lines
; 2854 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2855 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2856 : 			// DW 3/9/2006 replace the line after next with the next line
; 2857 : 			//t_cas_gap = max(0,(int)(this_r.last_cas_time + cas_length - now));
; 2858 : 			tick tCASLimit = currentRank.getLastCASTime() + timingSpecification.tBurst();

	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR _tRCDLimit$220273[esp+76], edx
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+24]
	add	eax, ebx
	mov	DWORD PTR _tCASLimit$220274[esp+72], eax
	mov	eax, DWORD PTR [esi+28]
	adc	eax, edx
	mov	DWORD PTR _tCASLimit$220274[esp+76], eax

; 2859 : 
; 2860 : 			// respect last CASW of same rank
; 2861 : 			// DW 3/9/2006 replace the line after next with the next line
; 2862 : 			//t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + timing_specification.t_cwd + casw_length + timing_specification.t_wtr - now));
; 2863 : 			tick tCASWLimit = currentRank.getLastCASWTime() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWTR();

	mov	eax, DWORD PTR [edi+48]
	mov	DWORD PTR tv945[esp+76], edx
	cdq
	mov	DWORD PTR tv957[esp+72], eax
	mov	eax, DWORD PTR [edi+92]
	mov	DWORD PTR tv957[esp+76], edx
	cdq
	mov	ecx, eax
	add	ecx, DWORD PTR [esi+32]

; 2864 : 
; 2865 : 			//respect most recent CAS of different rank
; 2866 : 			tick tCASOtherLimit = currentRank.getOtherLastCASTime() + currentRank.getOtherLastCASLength() + timingSpecification.tRTRS();

	mov	eax, DWORD PTR [edi+84]
	adc	edx, DWORD PTR [esi+36]
	add	ecx, DWORD PTR tv957[esp+72]
	adc	edx, DWORD PTR tv957[esp+76]
	add	ecx, ebx
	adc	edx, DWORD PTR tv945[esp+76]
	mov	ebx, DWORD PTR [esi+120]
	mov	DWORD PTR _tCASWLimit$220275[esp+76], edx
	cdq
	mov	DWORD PTR tv971[esp+76], edx
	xor	edx, edx
	add	ebx, DWORD PTR [esi+40]
	mov	DWORD PTR tv971[esp+72], eax
	adc	edx, DWORD PTR [esi+44]
	add	ebx, eax
	adc	edx, DWORD PTR tv971[esp+76]

; 2867 : 			//respect timing of READ follow WRITE, different ranks
; 2868 : 			tick tCASWOtherLimit = currentRank.getOtherLastCASWTime() + timingSpecification.tCWD() + currentRank.getOtherLastCASWLength() + timingSpecification.tRTRS() - timingSpecification.tCAS();

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR _tCASOtherLimit$220276[esp+72], ebx
	mov	ebx, DWORD PTR [esi+124]
	mov	DWORD PTR _tCASOtherLimit$220276[esp+76], edx
	cdq
	sub	ebx, eax
	mov	DWORD PTR tv85[esp+76], 0
	mov	eax, DWORD PTR tv85[esp+76]
	sbb	eax, edx
	add	ebx, DWORD PTR [esi+48]

; 2869 : 
; 2870 : 			nextTime = max(max(tRCDLimit,tCASLimit),max(max(tCASWLimit,tCASOtherLimit),tCASWOtherLimit));

	mov	edx, DWORD PTR _tRCDLimit$220273[esp+76]
	adc	eax, DWORD PTR [esi+52]
	add	ebx, DWORD PTR tv971[esp+72]
	adc	eax, DWORD PTR tv971[esp+76]
	add	ebx, DWORD PTR tv957[esp+72]
	adc	eax, DWORD PTR tv957[esp+76]
	cmp	edx, DWORD PTR _tCASLimit$220274[esp+76]
	jl	SHORT $LN44@earliestEx@2
	jg	SHORT $LN311@earliestEx@2
	mov	edx, DWORD PTR _tRCDLimit$220273[esp+72]
	cmp	edx, DWORD PTR _tCASLimit$220274[esp+72]
	jbe	SHORT $LN44@earliestEx@2
$LN311@earliestEx@2:
	mov	edx, DWORD PTR _tRCDLimit$220273[esp+72]
	mov	DWORD PTR tv256[esp+72], edx
	mov	edx, DWORD PTR _tRCDLimit$220273[esp+76]
	jmp	SHORT $LN389@earliestEx@2
$LN44@earliestEx@2:
	mov	edx, DWORD PTR _tCASLimit$220274[esp+72]
	mov	DWORD PTR tv256[esp+72], edx
	mov	edx, DWORD PTR _tCASLimit$220274[esp+76]
$LN389@earliestEx@2:
	mov	esi, DWORD PTR _tCASWLimit$220275[esp+76]
	cmp	esi, DWORD PTR _tCASOtherLimit$220276[esp+76]
	mov	DWORD PTR tv256[esp+76], edx
	jl	SHORT $LN46@earliestEx@2
	jg	SHORT $LN312@earliestEx@2
	cmp	ecx, DWORD PTR _tCASOtherLimit$220276[esp+72]
	jbe	SHORT $LN46@earliestEx@2
$LN312@earliestEx@2:
	mov	edx, ecx
	jmp	SHORT $LN47@earliestEx@2
$LN46@earliestEx@2:
	mov	edx, DWORD PTR _tCASOtherLimit$220276[esp+72]
	mov	esi, DWORD PTR _tCASOtherLimit$220276[esp+76]
$LN47@earliestEx@2:
	cmp	esi, eax
	jl	SHORT $LN50@earliestEx@2
	jg	SHORT $LN313@earliestEx@2
	cmp	edx, ebx
	jbe	SHORT $LN50@earliestEx@2
$LN313@earliestEx@2:
	mov	edx, DWORD PTR _tCASWLimit$220275[esp+76]
	mov	esi, DWORD PTR _tCASOtherLimit$220276[esp+76]
	cmp	edx, esi
	jl	SHORT $LN48@earliestEx@2
	jg	SHORT $LN314@earliestEx@2
	cmp	ecx, DWORD PTR _tCASOtherLimit$220276[esp+72]
	jbe	SHORT $LN48@earliestEx@2
$LN314@earliestEx@2:
	mov	DWORD PTR tv262[esp+72], ecx
	jmp	SHORT $LN51@earliestEx@2
$LN48@earliestEx@2:
	mov	edx, DWORD PTR _tCASOtherLimit$220276[esp+72]
	mov	DWORD PTR tv262[esp+72], edx
	mov	edx, esi
	jmp	SHORT $LN51@earliestEx@2
$LN50@earliestEx@2:
	mov	DWORD PTR tv262[esp+72], ebx
	mov	edx, eax
$LN51@earliestEx@2:
	cmp	DWORD PTR tv256[esp+76], edx
	jl	SHORT $LN60@earliestEx@2
	jg	SHORT $LN315@earliestEx@2
	mov	edx, DWORD PTR tv262[esp+72]
	cmp	DWORD PTR tv256[esp+72], edx
	jbe	SHORT $LN60@earliestEx@2
$LN315@earliestEx@2:
	mov	edx, DWORD PTR _tRCDLimit$220273[esp+76]
	cmp	edx, DWORD PTR _tCASLimit$220274[esp+76]
	jl	SHORT $LN52@earliestEx@2
	jg	SHORT $LN316@earliestEx@2
	mov	edx, DWORD PTR _tRCDLimit$220273[esp+72]
	cmp	edx, DWORD PTR _tCASLimit$220274[esp+72]
	jbe	SHORT $LN52@earliestEx@2
$LN316@earliestEx@2:
	mov	esi, DWORD PTR _tRCDLimit$220273[esp+72]
	mov	edx, DWORD PTR _tRCDLimit$220273[esp+76]
	mov	DWORD PTR _nextTime$[esp+72], esi
	mov	DWORD PTR _nextTime$[esp+76], edx
	jmp	SHORT $LN299@earliestEx@2
$LN52@earliestEx@2:
	mov	edx, DWORD PTR _tCASLimit$220274[esp+76]
	mov	esi, DWORD PTR _tCASLimit$220274[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], edx
	jmp	SHORT $LN390@earliestEx@2
$LN60@earliestEx@2:
	mov	esi, DWORD PTR _tCASWLimit$220275[esp+76]
	cmp	esi, DWORD PTR _tCASOtherLimit$220276[esp+76]
	jl	SHORT $LN54@earliestEx@2
	jg	SHORT $LN317@earliestEx@2
	cmp	ecx, DWORD PTR _tCASOtherLimit$220276[esp+72]
	jbe	SHORT $LN54@earliestEx@2
$LN317@earliestEx@2:
	mov	edx, ecx
	jmp	SHORT $LN55@earliestEx@2
$LN54@earliestEx@2:
	mov	edx, DWORD PTR _tCASOtherLimit$220276[esp+72]
	mov	esi, DWORD PTR _tCASOtherLimit$220276[esp+76]
$LN55@earliestEx@2:
	cmp	esi, eax
	jl	SHORT $LN58@earliestEx@2
	jg	SHORT $LN318@earliestEx@2
	cmp	edx, ebx
	jbe	SHORT $LN58@earliestEx@2
$LN318@earliestEx@2:
	mov	edx, DWORD PTR _tCASWLimit$220275[esp+76]
	cmp	edx, DWORD PTR _tCASOtherLimit$220276[esp+76]
	jl	SHORT $LN56@earliestEx@2
	jg	SHORT $LN319@earliestEx@2
	cmp	ecx, DWORD PTR _tCASOtherLimit$220276[esp+72]
	jbe	SHORT $LN56@earliestEx@2
$LN319@earliestEx@2:
	mov	esi, ecx
	mov	DWORD PTR _nextTime$[esp+76], edx
	jmp	SHORT $LN390@earliestEx@2
$LN56@earliestEx@2:
	mov	edx, DWORD PTR _tCASOtherLimit$220276[esp+76]
	mov	esi, DWORD PTR _tCASOtherLimit$220276[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], edx
	jmp	SHORT $LN390@earliestEx@2
$LN58@earliestEx@2:
	mov	esi, ebx
	mov	DWORD PTR _nextTime$[esp+76], eax
$LN390@earliestEx@2:
	mov	DWORD PTR _nextTime$[esp+72], esi

; 2871 : 
; 2872 : 			if (nextTime == tRCDLimit)

	cmp	esi, DWORD PTR _tRCDLimit$220273[esp+72]
	jne	SHORT $LN14@earliestEx@2
	mov	edx, DWORD PTR _tRCDLimit$220273[esp+76]
	cmp	DWORD PTR _nextTime$[esp+76], edx
	jne	SHORT $LN14@earliestEx@2
$LN299@earliestEx@2:

; 2873 : 				tRCDcount++;				

	inc	DWORD PTR ?tRCDcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN14@earliestEx@2:

; 2874 : 			if (nextTime == tCASLimit)

	mov	edx, DWORD PTR _nextTime$[esp+76]
	cmp	esi, DWORD PTR _tCASLimit$220274[esp+72]
	jne	SHORT $LN13@earliestEx@2

; 2875 : 				tCAScount++;

	mov	esi, DWORD PTR _nextTime$[esp+72]
	cmp	edx, DWORD PTR _tCASLimit$220274[esp+76]
	jne	SHORT $LN13@earliestEx@2
	inc	DWORD PTR ?tCAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN13@earliestEx@2:

; 2876 : 			if (nextTime == tCASWLimit)

	cmp	esi, ecx
	jne	SHORT $LN12@earliestEx@2
	cmp	edx, DWORD PTR _tCASWLimit$220275[esp+76]
	jne	SHORT $LN12@earliestEx@2

; 2877 : 				tCASWcount++;

	inc	DWORD PTR ?tCASWcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN12@earliestEx@2:

; 2878 : 			if (nextTime == tCASOtherLimit)

	cmp	esi, DWORD PTR _tCASOtherLimit$220276[esp+72]
	jne	SHORT $LN11@earliestEx@2
	cmp	edx, DWORD PTR _tCASOtherLimit$220276[esp+76]
	jne	SHORT $LN11@earliestEx@2

; 2879 : 				tCASotherCount++;

	inc	DWORD PTR ?tCASotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN11@earliestEx@2:

; 2880 : 			if (nextTime == tCASWOtherLimit)

	cmp	esi, ebx
	jne	$LN22@earliestEx@2
	cmp	DWORD PTR _nextTime$[esp+76], eax
	jne	$LN22@earliestEx@2

; 2881 : 				tCASWotherCount++;

	inc	DWORD PTR ?tCASWotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA

; 2882 : 
; 2883 : 			//fprintf(stderr," [%8d] [%8d] [%8d] [%8d] [%8d] [%2d]\n",(int)now,(int)this_r_last_cas_time,(int)this_r_last_casw_time,(int)other_r_last_cas_time,(int)other_r_last_casw_time,min_gap);
; 2884 : 		}
; 2885 : 		break;

	jmp	$LN22@earliestEx@2
$LN9@earliestEx@2:

; 2886 : 
; 2887 : 	case Command::WRITE_AND_PRECHARGE:
; 2888 : 		// Auto precharge will be issued as part of command, so
; 2889 : 		// Since commodity DRAM devices are write-cycle limited, we don't have to worry if
; 2890 : 		// the precharge will meet tRAS timing or not. So WRITE_AND_PRECHARGE
; 2891 : 		// has the exact same timing requirements as a simple WRITE.
; 2892 : 
; 2893 : 	case Command::WRITE:
; 2894 : 		{
; 2895 : 			//respect last RAS of same rank
; 2896 : 			tick tRASLimit = currentBank.getLastRASTime() + timingSpecification.tRCD() - timingSpecification.tAL();

	mov	eax, DWORD PTR [edi+64]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR tv181[esp+76], edx
	cdq
	sub	ebx, eax
	mov	eax, DWORD PTR tv181[esp+76]
	sbb	eax, edx
	add	ebx, DWORD PTR [ecx+48]
	adc	eax, DWORD PTR [ecx+52]
	mov	DWORD PTR _tRASLimit$220289[esp+72], ebx
	mov	DWORD PTR _tRASLimit$220289[esp+76], eax

; 2897 : 
; 2898 : 			// DW 3/9/2006 add these two lines
; 2899 : 			//cas_length = max(timing_specification.t_int_burst,this_r.last_cas_length);
; 2900 : 			//casw_length = max(timing_specification.t_int_burst,this_r.last_casw_length);
; 2901 : 
; 2902 : 			// respect last cas to same rank
; 2903 : 			// DW 3/9/2006 replace the line after next with the next line
; 2904 : 			// t_cas_gap = max(0,(int)(this_r.last_cas_time + timing_specification.t_cas + cas_length + timing_specification.t_rtrs - timing_specification.t_cwd - now));
; 2905 : 			tick tCASLimit = max(time,currentRank.getLastCASTime() + timingSpecification.tCAS() + timingSpecification.tBurst() + timingSpecification.tRTRS() - timingSpecification.tCWD());

	mov	eax, DWORD PTR [edi+32]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+48]
	mov	ecx, edx
	cdq
	sub	ebx, eax
	mov	eax, DWORD PTR [edi+36]
	sbb	ecx, edx
	cdq
	add	ebx, eax
	mov	eax, DWORD PTR [edi+84]
	adc	ecx, edx
	cdq
	add	ebx, eax
	mov	eax, DWORD PTR [edi+12]
	adc	ecx, edx
	add	ebx, DWORD PTR [esi+24]
	adc	ecx, DWORD PTR [esi+28]
	cmp	eax, ecx
	jl	SHORT $LN62@earliestEx@2
	jg	SHORT $LN320@earliestEx@2
	cmp	DWORD PTR [edi+8], ebx
	jbe	SHORT $LN62@earliestEx@2
$LN320@earliestEx@2:
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR _tCASLimit$220290[esp+76], eax
	jmp	SHORT $LN391@earliestEx@2
$LN62@earliestEx@2:
	mov	eax, DWORD PTR [edi+32]
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [edi+48]
	mov	ebx, edx
	cdq
	sub	ecx, eax
	mov	eax, DWORD PTR [edi+36]
	sbb	ebx, edx
	cdq
	add	ecx, eax
	mov	eax, DWORD PTR [edi+84]
	adc	ebx, edx
	cdq
	add	ecx, eax
	adc	ebx, edx
	add	ecx, DWORD PTR [esi+24]
	adc	ebx, DWORD PTR [esi+28]
	mov	DWORD PTR _tCASLimit$220290[esp+76], ebx
$LN391@earliestEx@2:

; 2906 : 
; 2907 : 			// respect last cas to different ranks
; 2908 : 			tick tCASOtherLimit = currentRank.getOtherLastCASTime() + timingSpecification.tCAS() + currentRank.getOtherLastCASLength() + timingSpecification.tRTRS() - timingSpecification.tCWD();

	mov	eax, DWORD PTR [edi+48]
	xor	ebx, ebx
	cdq
	mov	DWORD PTR _tCASLimit$220290[esp+72], ecx
	mov	ecx, DWORD PTR [esi+120]
	add	ecx, DWORD PTR [esi+40]

; 2909 : 
; 2910 : 			// respect last cas write to same rank
; 2911 : 			// DW 3/9/2006 replace the line after next with the next line			
; 2912 : 			// t_cas_gap = max(t_cas_gap,(int)(this_r.last_casw_time + casw_length - now));
; 2913 : 			tick tCASWLimit = currentRank.getLastCASWTime() + currentRank.getLastCASWLength();
; 2914 : 
; 2915 : 			// respect last CASW to different ranks
; 2916 : 			// TODO: should this not also be -tAL?
; 2917 : 			tick tCASWOtherLimit = currentRank.getOtherLastCASWTime() + currentRank.getOtherLastCASWLength() + timingSpecification.tOST();

	mov	DWORD PTR tv307[esp+76], 0
	adc	ebx, DWORD PTR [esi+44]
	sub	ecx, eax
	mov	eax, DWORD PTR [edi+36]
	sbb	ebx, edx
	cdq
	add	ecx, eax
	mov	eax, DWORD PTR [edi+84]
	adc	ebx, edx
	cdq
	add	ecx, eax
	mov	eax, DWORD PTR [esi+116]
	adc	ebx, edx
	xor	edx, edx
	add	eax, DWORD PTR [esi+32]
	mov	DWORD PTR _tCASOtherLimit$220291[esp+76], ebx
	adc	edx, DWORD PTR [esi+36]
	mov	ebx, DWORD PTR [esi+124]
	mov	DWORD PTR _tCASWLimit$220292[esp+72], eax
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR _tCASWLimit$220292[esp+76], edx
	cdq
	add	ebx, eax
	mov	eax, DWORD PTR tv307[esp+76]
	adc	eax, edx
	add	ebx, DWORD PTR [esi+48]

; 2918 : 
; 2919 : 			nextTime = max(max(tRASLimit,tCASLimit), max(max(tCASOtherLimit,tCASWOtherLimit),tCASWLimit));

	mov	edx, DWORD PTR _tCASLimit$220290[esp+76]
	adc	eax, DWORD PTR [esi+52]
	cmp	DWORD PTR _tRASLimit$220289[esp+76], edx
	mov	DWORD PTR _tCASWOtherLimit$220293[esp+76], eax
	jl	SHORT $LN64@earliestEx@2
	jg	SHORT $LN321@earliestEx@2
	mov	esi, DWORD PTR _tRASLimit$220289[esp+72]
	cmp	esi, DWORD PTR _tCASLimit$220290[esp+72]
	jbe	SHORT $LN64@earliestEx@2
$LN321@earliestEx@2:
	mov	edx, DWORD PTR _tRASLimit$220289[esp+72]
	mov	DWORD PTR tv382[esp+72], edx
	mov	edx, DWORD PTR _tRASLimit$220289[esp+76]
	jmp	SHORT $LN392@earliestEx@2
$LN64@earliestEx@2:
	mov	esi, DWORD PTR _tCASLimit$220290[esp+72]
	mov	DWORD PTR tv382[esp+72], esi
$LN392@earliestEx@2:
	mov	esi, DWORD PTR _tCASOtherLimit$220291[esp+76]
	cmp	esi, eax
	mov	DWORD PTR tv382[esp+76], edx
	jl	SHORT $LN66@earliestEx@2
	jg	SHORT $LN322@earliestEx@2
	cmp	ecx, ebx
	jbe	SHORT $LN66@earliestEx@2
$LN322@earliestEx@2:
	mov	DWORD PTR tv384[esp+72], ecx
	jmp	SHORT $LN67@earliestEx@2
$LN66@earliestEx@2:
	mov	DWORD PTR tv384[esp+72], ebx
	mov	esi, eax
$LN67@earliestEx@2:
	mov	edx, DWORD PTR _tCASWLimit$220292[esp+76]
	cmp	esi, edx
	jl	SHORT $LN70@earliestEx@2
	jg	SHORT $LN323@earliestEx@2
	mov	esi, DWORD PTR tv384[esp+72]
	cmp	esi, DWORD PTR _tCASWLimit$220292[esp+72]
	jbe	SHORT $LN70@earliestEx@2
$LN323@earliestEx@2:
	mov	edx, DWORD PTR _tCASOtherLimit$220291[esp+76]
	cmp	edx, eax
	jl	SHORT $LN68@earliestEx@2
	jg	SHORT $LN324@earliestEx@2
	cmp	ecx, ebx
	jbe	SHORT $LN68@earliestEx@2
$LN324@earliestEx@2:
	mov	esi, ecx
	jmp	SHORT $LN393@earliestEx@2
$LN68@earliestEx@2:
	mov	esi, ebx
	jmp	SHORT $LN71@earliestEx@2
$LN70@earliestEx@2:
	mov	esi, DWORD PTR _tCASWLimit$220292[esp+72]
$LN393@earliestEx@2:
	mov	eax, edx
$LN71@earliestEx@2:
	cmp	DWORD PTR tv382[esp+76], eax
	jl	SHORT $LN80@earliestEx@2
	jg	SHORT $LN325@earliestEx@2
	cmp	DWORD PTR tv382[esp+72], esi
	jbe	SHORT $LN80@earliestEx@2
$LN325@earliestEx@2:
	mov	eax, DWORD PTR _tCASLimit$220290[esp+76]
	cmp	DWORD PTR _tRASLimit$220289[esp+76], eax
	jl	SHORT $LN72@earliestEx@2
	jg	SHORT $LN326@earliestEx@2
	mov	edx, DWORD PTR _tRASLimit$220289[esp+72]
	cmp	edx, DWORD PTR _tCASLimit$220290[esp+72]
	jbe	SHORT $LN72@earliestEx@2
$LN326@earliestEx@2:
	mov	eax, DWORD PTR _tRASLimit$220289[esp+76]
	mov	esi, DWORD PTR _tRASLimit$220289[esp+72]

; 2922 : 				tRAScount++;				

	inc	DWORD PTR ?tRAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
	mov	DWORD PTR _nextTime$[esp+76], eax
	jmp	$LN8@earliestEx@2
$LN72@earliestEx@2:

; 2918 : 
; 2919 : 			nextTime = max(max(tRASLimit,tCASLimit), max(max(tCASOtherLimit,tCASWOtherLimit),tCASWLimit));

	mov	esi, DWORD PTR _tCASLimit$220290[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], eax
	jmp	SHORT $LN79@earliestEx@2
$LN80@earliestEx@2:
	mov	eax, DWORD PTR _tCASOtherLimit$220291[esp+76]
	mov	esi, DWORD PTR _tCASWOtherLimit$220293[esp+76]
	cmp	eax, esi
	jl	SHORT $LN74@earliestEx@2
	jg	SHORT $LN327@earliestEx@2
	cmp	ecx, ebx
	jbe	SHORT $LN74@earliestEx@2
$LN327@earliestEx@2:
	mov	edx, ecx
	jmp	SHORT $LN75@earliestEx@2
$LN74@earliestEx@2:
	mov	edx, ebx
	mov	eax, esi
$LN75@earliestEx@2:
	cmp	eax, DWORD PTR _tCASWLimit$220292[esp+76]
	jl	SHORT $LN78@earliestEx@2
	jg	SHORT $LN328@earliestEx@2
	cmp	edx, DWORD PTR _tCASWLimit$220292[esp+72]
	jbe	SHORT $LN78@earliestEx@2
$LN328@earliestEx@2:
	mov	eax, DWORD PTR _tCASWOtherLimit$220293[esp+76]
	cmp	DWORD PTR _tCASOtherLimit$220291[esp+76], eax
	jl	SHORT $LN76@earliestEx@2
	jg	SHORT $LN329@earliestEx@2
	cmp	ecx, ebx
	jbe	SHORT $LN76@earliestEx@2
$LN329@earliestEx@2:
	mov	edx, DWORD PTR _tCASOtherLimit$220291[esp+76]
	mov	esi, ecx
	jmp	SHORT $LN394@earliestEx@2
$LN76@earliestEx@2:
	mov	eax, DWORD PTR _tCASWOtherLimit$220293[esp+76]
	mov	esi, ebx
	mov	DWORD PTR _nextTime$[esp+76], eax
	jmp	SHORT $LN79@earliestEx@2
$LN78@earliestEx@2:
	mov	esi, DWORD PTR _tCASWLimit$220292[esp+72]
	mov	edx, DWORD PTR _tCASWLimit$220292[esp+76]
$LN394@earliestEx@2:
	mov	DWORD PTR _nextTime$[esp+76], edx
$LN79@earliestEx@2:

; 2920 : 
; 2921 : 			if (nextTime == tRASLimit)

	cmp	esi, DWORD PTR _tRASLimit$220289[esp+72]
	jne	SHORT $LN358@earliestEx@2
	mov	eax, DWORD PTR _tRASLimit$220289[esp+76]
	cmp	DWORD PTR _nextTime$[esp+76], eax
	jne	SHORT $LN358@earliestEx@2
	mov	eax, DWORD PTR _nextTime$[esp+76]

; 2922 : 				tRAScount++;				

	inc	DWORD PTR ?tRAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
	jmp	SHORT $LN8@earliestEx@2
$LN358@earliestEx@2:
	mov	eax, DWORD PTR _nextTime$[esp+76]
$LN8@earliestEx@2:

; 2923 : 			if (nextTime == tCASLimit)

	cmp	esi, DWORD PTR _tCASLimit$220290[esp+72]
	jne	SHORT $LN7@earliestEx@2
	cmp	eax, DWORD PTR _tCASLimit$220290[esp+76]
	jne	SHORT $LN7@earliestEx@2

; 2924 : 				tCAScount++;

	inc	DWORD PTR ?tCAScount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN7@earliestEx@2:

; 2925 : 			if (nextTime == tCASWLimit)

	cmp	esi, DWORD PTR _tCASWLimit$220292[esp+72]
	jne	SHORT $LN6@earliestEx@2
	cmp	eax, DWORD PTR _tCASWLimit$220292[esp+76]
	jne	SHORT $LN6@earliestEx@2

; 2926 : 				tCASWcount++;

	inc	DWORD PTR ?tCASWcount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN6@earliestEx@2:

; 2927 : 			if (nextTime == tCASOtherLimit)

	cmp	esi, ecx
	jne	SHORT $LN5@earliestEx@2
	cmp	eax, DWORD PTR _tCASOtherLimit$220291[esp+76]
	jne	SHORT $LN5@earliestEx@2

; 2928 : 				tCASotherCount++;

	inc	DWORD PTR ?tCASotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA
$LN5@earliestEx@2:

; 2929 : 			if (nextTime == tCASWOtherLimit)

	cmp	esi, ebx
	jne	$LN22@earliestEx@2
	mov	ecx, DWORD PTR _nextTime$[esp+76]
	cmp	ecx, DWORD PTR _tCASWOtherLimit$220293[esp+76]
	jne	$LN22@earliestEx@2

; 2930 : 				tCASWotherCount++;

	inc	DWORD PTR ?tCASWotherCount@?1??earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@3@@Z@4IA

; 2931 : 		}
; 2932 : 		break;

	jmp	$LN22@earliestEx@2
$LN3@earliestEx@2:

; 2933 : 
; 2934 : 	case Command::PRECHARGE:
; 2935 : 		{
; 2936 : 			// respect t_ras of same bank
; 2937 : 			tick tRASLimit = currentBank.getLastRASTime() + timingSpecification.tRAS();

	mov	eax, DWORD PTR [edi+56]

; 2938 : 
; 2939 : 			// respect t_cas of same bank
; 2940 : 			// TODO: do not need tAL for these
; 2941 : 			//tick tCASLimit = max(time,currentBank.getLastCASTime() + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD()));
; 2942 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 2943 : 			tick tCASLimit = max(time,currentBank.getLastCASTime() + timingSpecification.tCAS() + timingSpecification.tBurst() + max(0,timingSpecification.tRTP() - timingSpecification.tCMD()));

	mov	esi, DWORD PTR [edi+80]
	cdq
	add	eax, DWORD PTR [ecx+48]
	adc	edx, DWORD PTR [ecx+52]
	sub	esi, DWORD PTR [edi+44]
	mov	DWORD PTR _tRASLimit$220305[esp+76], edx
	mov	edx, 0
	sets	dl
	mov	DWORD PTR _tRASLimit$220305[esp+72], eax
	mov	eax, DWORD PTR [edi+32]
	dec	edx
	and	edx, esi
	mov	DWORD PTR tv444[esp+72], edx
	cdq
	mov	DWORD PTR tv1046[esp+72], eax
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR tv1046[esp+76], edx
	cdq
	add	eax, DWORD PTR [ecx+56]
	adc	edx, DWORD PTR [ecx+60]
	mov	ebx, eax
	add	ebx, DWORD PTR tv1046[esp+72]
	mov	eax, edx
	adc	eax, DWORD PTR tv1046[esp+76]
	mov	DWORD PTR tv1092[esp+76], eax
	mov	eax, DWORD PTR tv444[esp+72]
	cdq
	add	eax, ebx
	adc	edx, DWORD PTR tv1092[esp+76]
	mov	DWORD PTR tv463[esp+72], eax
	cmp	DWORD PTR [edi+12], edx
	jl	SHORT $LN86@earliestEx@2
	jg	SHORT $LN330@earliestEx@2
	mov	eax, DWORD PTR [edi+8]
	cmp	eax, DWORD PTR tv463[esp+72]
	jbe	SHORT $LN86@earliestEx@2
$LN330@earliestEx@2:
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR _tCASLimit$220306[esp+72], eax
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR _tCASLimit$220306[esp+76], eax
	jmp	SHORT $LN87@earliestEx@2
$LN86@earliestEx@2:
	xor	eax, eax
	test	esi, esi
	setl	al
	dec	eax
	and	eax, esi
	cdq
	add	eax, ebx
	adc	edx, DWORD PTR tv1092[esp+76]
	mov	DWORD PTR _tCASLimit$220306[esp+72], eax
	mov	DWORD PTR _tCASLimit$220306[esp+76], edx
$LN87@earliestEx@2:

; 2944 : 
; 2945 : 			// respect t_casw of same bank
; 2946 : 			//tCASLimit = max(tCASLimit,currentBank.getLastCASWTime() + timingSpecification.tAL() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2947 : 			// tAL is accounted for by measuring the execution time internal to the DRAM
; 2948 : 			tCASLimit = max(tCASLimit,currentBank.getLastCASWTime() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());

	mov	eax, DWORD PTR [edi+88]
	cdq
	mov	esi, eax
	mov	eax, DWORD PTR [edi+48]
	mov	ebx, edx
	cdq
	add	esi, eax
	adc	ebx, edx
	add	esi, DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _tCASLimit$220306[esp+76]
	adc	ebx, DWORD PTR [ecx+68]
	mov	ecx, esi
	add	ecx, DWORD PTR tv1046[esp+72]
	mov	eax, ebx
	adc	eax, DWORD PTR tv1046[esp+76]
	cmp	edx, eax
	jg	SHORT $LN339@earliestEx@2
	jl	SHORT $LN331@earliestEx@2
	mov	esi, DWORD PTR _tCASLimit$220306[esp+72]
	cmp	esi, ecx
	ja	SHORT $LN89@earliestEx@2
$LN331@earliestEx@2:
	mov	esi, ecx
	mov	edx, eax
	jmp	SHORT $LN89@earliestEx@2
$LN339@earliestEx@2:
	mov	esi, DWORD PTR _tCASLimit$220306[esp+72]
$LN89@earliestEx@2:

; 2949 : 
; 2950 : 			nextTime = max(tRASLimit,tCASLimit);

	mov	eax, DWORD PTR _tRASLimit$220305[esp+76]
	cmp	eax, edx
	jl	SHORT $LN90@earliestEx@2
	jg	SHORT $LN332@earliestEx@2
	cmp	DWORD PTR _tRASLimit$220305[esp+72], esi
	jbe	SHORT $LN90@earliestEx@2
$LN332@earliestEx@2:
	mov	esi, DWORD PTR _tRASLimit$220305[esp+72]
	mov	DWORD PTR _nextTime$[esp+76], eax
	jmp	SHORT $LN22@earliestEx@2
$LN2@earliestEx@2:

; 2951 : 		}
; 2952 : 		break;
; 2953 : 
; 2954 : 	case Command::REFRESH_ALL:
; 2955 : 		// respect tRFC and tRP
; 2956 : 		nextTime = max(currentRank.getLastRefreshTime() + timingSpecification.tRFC(), currentRank.getLastPrechargeTime() + timingSpecification.tRP());

	mov	eax, DWORD PTR [edi+72]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [edi+68]
	mov	ecx, edx
	adc	ecx, DWORD PTR [esi+20]
	cdq
	add	eax, DWORD PTR [esi+8]
	adc	edx, DWORD PTR [esi+12]
	cmp	edx, ecx
	jl	SHORT $LN92@earliestEx@2
	jg	SHORT $LN333@earliestEx@2
	cmp	eax, ebx
	jbe	SHORT $LN92@earliestEx@2
$LN333@earliestEx@2:
	mov	esi, eax
$LN90@earliestEx@2:
	mov	DWORD PTR _nextTime$[esp+76], edx
	jmp	SHORT $LN22@earliestEx@2
$LN92@earliestEx@2:
	mov	esi, ebx
	mov	DWORD PTR _nextTime$[esp+76], ecx

; 2957 : 		break;

	jmp	SHORT $LN22@earliestEx@2
$LN1@earliestEx@2:

; 2958 : 
; 2959 : 	case Command::RETIRE_COMMAND:
; 2960 : 	case Command::PRECHARGE_ALL:
; 2961 : 	case Command::ACTIVATE_ALL:
; 2962 : 	case Command::DRIVE_COMMAND:
; 2963 : 	case Command::DATA_COMMAND:
; 2964 : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 2965 : 	case Command::SELF_REFRESH:
; 2966 : 	case Command::DESELECT:
; 2967 : 	case Command::NOOP:
; 2968 : 	case Command::INVALID_COMMAND:
; 2969 : 	default:
; 2970 : 		cerr << "Unsupported command encountered." << endl;

	push	OFFSET ??_C@_0CB@JLFGGPAL@Unsupported?5command?5encountered?4@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 2971 : 		nextTime = 0;

	xor	esi, esi
	mov	DWORD PTR _nextTime$[esp+76], esi
$LN22@earliestEx@2:

; 2972 : 		break;
; 2973 : 	}
; 2974 : 
; 2975 : 	//return max(nextTime, time + timingSpecification.tCMD());
; 2976 : 	//return max(nextTime, max(time, lastCommandIssueTime + timingSpecification.tCMD()));
; 2977 : 	return max(nextTime, max(time , lastCommandIssueTime + timingSpecification.tCMD()));

	mov	eax, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR [edi+8]
	cdq
	add	eax, DWORD PTR [edi+16]
	adc	edx, DWORD PTR [edi+20]
	mov	edi, DWORD PTR [edi+12]
	cmp	edi, edx
	jl	SHORT $LN94@earliestEx@2
	jg	SHORT $LN334@earliestEx@2
	cmp	ecx, eax
	jbe	SHORT $LN94@earliestEx@2
$LN334@earliestEx@2:
	mov	DWORD PTR tv569[esp+72], ecx
	mov	ebx, edi
	jmp	SHORT $LN95@earliestEx@2
$LN94@earliestEx@2:
	mov	DWORD PTR tv569[esp+72], eax
	mov	ebx, edx
$LN95@earliestEx@2:
	cmp	DWORD PTR _nextTime$[esp+76], ebx
	jl	SHORT $LN98@earliestEx@2
	jg	SHORT $LN335@earliestEx@2
	cmp	esi, DWORD PTR tv569[esp+72]
	jbe	SHORT $LN98@earliestEx@2
$LN335@earliestEx@2:
	mov	edx, DWORD PTR _nextTime$[esp+76]
	mov	eax, esi

; 2978 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN98@earliestEx@2:

; 2972 : 		break;
; 2973 : 	}
; 2974 : 
; 2975 : 	//return max(nextTime, time + timingSpecification.tCMD());
; 2976 : 	//return max(nextTime, max(time, lastCommandIssueTime + timingSpecification.tCMD()));
; 2977 : 	return max(nextTime, max(time , lastCommandIssueTime + timingSpecification.tCMD()));

	cmp	edi, edx
	jl	SHORT $LN97@earliestEx@2
	jg	SHORT $LN336@earliestEx@2
	cmp	ecx, eax
	jbe	SHORT $LN97@earliestEx@2
$LN336@earliestEx@2:
	mov	eax, ecx
	mov	edx, edi
$LN97@earliestEx@2:

; 2978 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN395@earliestEx@2:
	DD	$LN21@earliestEx@2
	DD	$LN15@earliestEx@2
	DD	$LN9@earliestEx@2
	DD	$LN3@earliestEx@2
	DD	$LN2@earliestEx@2
	DD	$LN1@earliestEx@2
$LN301@earliestEx@2:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	2
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
?earliestExecuteTimeLog@Channel@DRAMsimII@@MBE_JPBVCommand@2@@Z ENDP ; DRAMsimII::Channel::earliestExecuteTimeLog
; Function compile flags: /Ogtpy
_readSweep$219829 = -357				; size = 1
_readSweep$219718 = -357				; size = 1
_notAllRefresh$219693 = -357				; size = 1
_isRefreshCommand$219639 = -357				; size = 1
_isRefreshCommand$219581 = -357				; size = 1
tv7449 = -356						; size = 4
tv7199 = -356						; size = 4
_this$ = -356						; size = 4
tv7280 = -352						; size = 4
_isActivate$219954 = -352				; size = 1
$T608457 = -352						; size = 4
$T608412 = -352						; size = 4
_currentBankOffset$219773 = -352			; size = 4
_candidateCommand$219561 = -352				; size = 4
tv7523 = -348						; size = 4
tv7368 = -348						; size = 4
tv5223 = -348						; size = 4
$T606769 = -348						; size = 4
_nextBank$219956 = -348					; size = 4
_oldestCommand$219676 = -348				; size = 4
$T608515 = -344						; size = 4
$T607827 = -344						; size = 4
$T607177 = -344						; size = 4
$T606557 = -344						; size = 4
_originalBank$219962 = -344				; size = 4
_currentRank$219888 = -344				; size = 8
_currentRank$219778 = -344				; size = 8
_originalActivate$219963 = -333				; size = 1
_originalReadSweep$219922 = -333			; size = 1
_originalReadSweep$219797 = -333			; size = 1
$T607389 = -332						; size = 4
_nextRank$219955 = -332					; size = 4
_candidateCommand$219619 = -332				; size = 4
_candidateCommand$219509 = -332				; size = 4
_currentBank$219895 = -328				; size = 8
_oldestCommandTime$219673 = -328			; size = 8
_candidateExecuteTime$219620 = -328			; size = 8
_currentRank$219575 = -328				; size = 8
_bankEnd$219534 = -328					; size = 8
__Tmp$610919 = -320					; size = 8
_startingRank$219921 = -320				; size = 8
$T606498 = -320						; size = 8
$T606495 = -320						; size = 8
_startingRank$219796 = -320				; size = 8
$T606465 = -320						; size = 8
_currentRank$219633 = -320				; size = 8
_challengerExecuteTime$219610 = -320			; size = 8
_currentRank$219523 = -320				; size = 8
_currentRank$219687 = -312				; size = 8
_currentBank$219650 = -312				; size = 8
_candidateExecuteTime$219562 = -312			; size = 8
$T610063 = -304						; size = 4
$T609031 = -304						; size = 4
$T608727 = -304						; size = 4
$T608039 = -304						; size = 4
_originalRank$219961 = -304				; size = 4
_startingBankOffset$219791 = -304			; size = 4
_rankEnd$219569 = -304					; size = 8
_candidateExecuteTime$219510 = -304			; size = 8
$T606519 = -296						; size = 8
_startingBank$219916 = -296				; size = 8
$T606473 = -296						; size = 8
_challengerExecuteTime$219666 = -296			; size = 8
_currentBank$219592 = -296				; size = 8
_rankEnd$219517 = -296					; size = 8
__Tmp$610763 = -288					; size = 8
__Tmp$609404 = -288					; size = 8
_rankEnd$219910 = -288					; size = 8
$T606503 = -288						; size = 8
_rankEnd$219681 = -288					; size = 8
_bankEnd$219644 = -288					; size = 8
_bankEnd$219698 = -280					; size = 8
_rankEnd$219627 = -280					; size = 8
_bankEnd$219586 = -280					; size = 8
$T606460 = -272						; size = 8
$T606484 = -264						; size = 8
$T606452 = -256						; size = 8
$T606483 = -248						; size = 8
$T606453 = -240						; size = 8
$T606485 = -232						; size = 8
$T606456 = -224						; size = 8
$T606490 = -216						; size = 8
$T606457 = -208						; size = 8
$T606488 = -200						; size = 8
$T606454 = -192						; size = 8
$T606487 = -184						; size = 8
$T606461 = -176						; size = 8
$T606489 = -168						; size = 8
$T606470 = -160						; size = 8
$T606494 = -152						; size = 8
$T606477 = -144						; size = 8
$T606492 = -136						; size = 8
$T606451 = -128						; size = 8
$T606491 = -120						; size = 8
$T606455 = -112						; size = 8
$T606493 = -104						; size = 8
$T606459 = -96						; size = 8
$T606501 = -88						; size = 8
$T606474 = -80						; size = 8
$T606504 = -72						; size = 8
$T606458 = -64						; size = 8
$T606505 = -56						; size = 8
$T606468 = -48						; size = 8
$T606506 = -40						; size = 8
$T606462 = -32						; size = 8
$T606511 = -24						; size = 8
$T606486 = -16						; size = 8
$T606520 = -8						; size = 8
?readNextCommand@Channel@DRAMsimII@@MBEPBVCommand@2@XZ PROC ; DRAMsimII::Channel::readNextCommand
; _this$ = ecx

; 1448 : {	

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 360				; 00000168H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 1449 : 	switch (systemConfig.getCommandOrderingAlgorithm())

	mov	ecx, DWORD PTR [ebp+176]
	mov	eax, DWORD PTR [ecx+288]
	mov	DWORD PTR _this$[esp+376], ebp
	cmp	eax, 6
	ja	$LN1@readNextCo@2
	jmp	DWORD PTR $LN1843@readNextCo@2[eax*4]
$LN151@readNextCo@2:

; 1450 : 	{
; 1451 : 	case FIRST_AVAILABLE_AGE:
; 1452 : 		{
; 1453 : 			const Command *candidateCommand = NULL;
; 1454 : 
; 1455 : 			tick candidateExecuteTime = TICK_MAX;
; 1456 : 
; 1457 : 			vector<Rank>::const_iterator rankEnd = rank.end();

	mov	ebx, DWORD PTR [ebp+384]
	mov	DWORD PTR _candidateCommand$219509[esp+376], 0
	mov	DWORD PTR _candidateExecuteTime$219510[esp+376], -1
	mov	DWORD PTR _candidateExecuteTime$219510[esp+380], 2147483647 ; 7fffffffH
	mov	DWORD PTR $T606557[esp+376], ebx
	cmp	DWORD PTR [ebp+380], ebx
	jbe	SHORT $LN177@readNextCo@2
	call	__invalid_parameter_noinfo
$LN177@readNextCo@2:

; 1458 : 
; 1459 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	esi, DWORD PTR [ebp+380]
	mov	eax, DWORD PTR [ebp+368]
	mov	DWORD PTR _rankEnd$219517[esp+376], eax
	cmp	esi, DWORD PTR [ebp+384]
	jbe	SHORT $LN191@readNextCo@2
	call	__invalid_parameter_noinfo
$LN191@readNextCo@2:
	mov	edi, DWORD PTR [ebp+368]
	add	esi, 188				; 000000bcH
	mov	DWORD PTR _currentRank$219523[esp+376], edi
	mov	DWORD PTR tv7280[esp+376], esi
$LL206@readNextCo@2:
	test	edi, edi
	je	SHORT $LN218@readNextCo@2
	cmp	edi, DWORD PTR _rankEnd$219517[esp+376]
	je	SHORT $LN219@readNextCo@2
$LN218@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN219@readNextCo@2:
	lea	eax, DWORD PTR [esi-188]
	cmp	eax, ebx
	je	$LN148@readNextCo@2

; 1460 : 			{
; 1461 : 				bool isRefreshCommand = true;

	mov	bl, 1

; 1462 : 
; 1463 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	test	edi, edi
	jne	$LN1774@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN237@readNextCo@2:
	lea	ecx, DWORD PTR [esi-188]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN228@readNextCo@2
	call	__invalid_parameter_noinfo
$LN228@readNextCo@2:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T606769[esp+376], eax
	cmp	DWORD PTR [esi-4], eax
	jbe	SHORT $LN243@readNextCo@2
	call	__invalid_parameter_noinfo
$LN243@readNextCo@2:
	mov	ecx, DWORD PTR [esi-16]
	mov	DWORD PTR _bankEnd$219534[esp+376], ecx

; 1464 : 
; 1465 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	test	edi, edi
	jne	$LN1773@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN265@readNextCo@2:
	lea	ecx, DWORD PTR [esi-188]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN256@readNextCo@2
	call	__invalid_parameter_noinfo
$LN256@readNextCo@2:
	mov	esi, DWORD PTR [esi-4]
	mov	edx, DWORD PTR tv7280[esp+376]
	cmp	esi, DWORD PTR [edx]
	jbe	SHORT $LN271@readNextCo@2
	call	__invalid_parameter_noinfo
$LN271@readNextCo@2:
	mov	eax, DWORD PTR tv7280[esp+376]
	mov	edi, DWORD PTR [eax-16]
	lea	ecx, DWORD PTR [esi+32]
$LN1834@readNextCo@2:
	mov	DWORD PTR tv7199[esp+376], ecx
	test	edi, edi
	je	SHORT $LN298@readNextCo@2
	cmp	edi, DWORD PTR _bankEnd$219534[esp+376]
	je	SHORT $LN299@readNextCo@2
$LN298@readNextCo@2:
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR tv7199[esp+376]
$LN299@readNextCo@2:
	lea	eax, DWORD PTR [ecx-32]
	cmp	eax, DWORD PTR $T606769[esp+376]
	je	$LN149@readNextCo@2

; 1466 : 				{	
; 1467 : 					if (!currentBank->isEmpty())

	test	edi, edi
	jne	$LN1772@readNextCo@2
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR tv7199[esp+376]
	xor	eax, eax
$LN317@readNextCo@2:
	lea	edx, DWORD PTR [ecx-32]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN308@readNextCo@2
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR tv7199[esp+376]
$LN308@readNextCo@2:
	cmp	DWORD PTR [ecx-24], 0
	je	$LN138@readNextCo@2

; 1468 : 					{
; 1469 : 						const Command *challengerCommand = currentBank->front();

	test	edi, edi
	jne	$LN1771@readNextCo@2
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR tv7199[esp+376]
	xor	eax, eax
$LN335@readNextCo@2:
	lea	edx, DWORD PTR [ecx-32]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN326@readNextCo@2
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR tv7199[esp+376]
$LN326@readNextCo@2:
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [ecx-20]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN342@readNextCo@2
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR tv7199[esp+376]
$LN342@readNextCo@2:
	mov	eax, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax+esi*4]

; 1470 : 
; 1471 : 						assert(!challengerCommand || challengerCommand->isRefresh() || rank[challengerCommand->getAddress().getRank()].bank[challengerCommand->getAddress().getBank()].front() == challengerCommand);
; 1472 : 
; 1473 : 						// see if it is a refresh command
; 1474 : 						if (isRefreshCommand && challengerCommand->isRefresh() && currentRank->refreshAllReady())

	test	bl, bl
	je	$LN143@readNextCo@2
	cmp	DWORD PTR [esi+80], 12			; 0000000cH
	jne	$LN1833@readNextCo@2
	mov	eax, DWORD PTR _currentRank$219523[esp+376]
	test	eax, eax
	jne	$LN1770@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN360@readNextCo@2:
	mov	ecx, DWORD PTR tv7280[esp+376]
	add	ecx, -188				; ffffff44H
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN351@readNextCo@2
	call	__invalid_parameter_noinfo
$LN351@readNextCo@2:
	mov	ecx, DWORD PTR tv7280[esp+376]
	add	ecx, -188				; ffffff44H
	push	ecx
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	je	$LN143@readNextCo@2

; 1475 : 						{
; 1476 : 							tick challengerExecuteTime = earliestExecuteTime(challengerCommand);

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+8]
	push	esi
	mov	ecx, ebp
	call	eax

; 1477 : #ifndef NDEBUG
; 1478 : 							int minGap = minProtocolGap(challengerCommand);
; 1479 : 
; 1480 : 							if (time + minGap != challengerExecuteTime)
; 1481 : 							{
; 1482 : 								cerr << "cet " << challengerExecuteTime << ", mingap " << time+minGap << endl;
; 1483 : 								cerr << challengerCommand << endl;
; 1484 : 								assert(time + minGap == challengerExecuteTime);
; 1485 : 							}
; 1486 : #endif
; 1487 : 							if (challengerExecuteTime < candidateExecuteTime ||
; 1488 : 								(candidateExecuteTime == challengerExecuteTime && 
; 1489 : 								challengerCommand->getEnqueueTime() < candidateCommand->getEnqueueTime()))

	cmp	edx, DWORD PTR _candidateExecuteTime$219510[esp+380]
	jl	SHORT $LN1723@readNextCo@2
	jg	SHORT $LN1786@readNextCo@2
	cmp	eax, DWORD PTR _candidateExecuteTime$219510[esp+376]
	jb	SHORT $LN1723@readNextCo@2
$LN1786@readNextCo@2:
	cmp	DWORD PTR _candidateExecuteTime$219510[esp+376], eax
	jne	$LN138@readNextCo@2
	cmp	DWORD PTR _candidateExecuteTime$219510[esp+380], edx
	jne	$LN138@readNextCo@2
	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR _candidateCommand$219509[esp+376]
	cmp	ecx, DWORD PTR [eax+20]
	jl	SHORT $LN1723@readNextCo@2
	jg	$LN138@readNextCo@2
	mov	edx, DWORD PTR [esi+16]
	cmp	edx, DWORD PTR [eax+16]
	jae	$LN138@readNextCo@2
$LN1723@readNextCo@2:

; 1490 : 							{						
; 1491 : 								candidateCommand = challengerCommand;

	mov	DWORD PTR _candidateCommand$219509[esp+376], esi
$LN149@readNextCo@2:

; 1458 : 
; 1459 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	eax, DWORD PTR _currentRank$219523[esp+376]
	test	eax, eax
	jne	$LN1768@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN213@readNextCo@2:
	mov	ecx, DWORD PTR tv7280[esp+376]
	add	ecx, -188				; ffffff44H
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN204@readNextCo@2
	call	__invalid_parameter_noinfo
$LN204@readNextCo@2:
	add	DWORD PTR tv7280[esp+376], 200		; 000000c8H
	mov	edi, DWORD PTR _currentRank$219523[esp+376]
	mov	ebx, DWORD PTR $T606557[esp+376]
	mov	esi, DWORD PTR tv7280[esp+376]
	jmp	$LL206@readNextCo@2
$LN1774@readNextCo@2:

; 1462 : 
; 1463 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	mov	eax, DWORD PTR [edi]
	jmp	$LN237@readNextCo@2
$LN1773@readNextCo@2:

; 1464 : 
; 1465 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	mov	eax, DWORD PTR [edi]
	jmp	$LN265@readNextCo@2
$LN1772@readNextCo@2:

; 1466 : 				{	
; 1467 : 					if (!currentBank->isEmpty())

	mov	eax, DWORD PTR [edi]
	jmp	$LN317@readNextCo@2
$LN1771@readNextCo@2:

; 1468 : 					{
; 1469 : 						const Command *challengerCommand = currentBank->front();

	mov	eax, DWORD PTR [edi]
	jmp	$LN335@readNextCo@2
$LN1770@readNextCo@2:

; 1470 : 
; 1471 : 						assert(!challengerCommand || challengerCommand->isRefresh() || rank[challengerCommand->getAddress().getRank()].bank[challengerCommand->getAddress().getBank()].front() == challengerCommand);
; 1472 : 
; 1473 : 						// see if it is a refresh command
; 1474 : 						if (isRefreshCommand && challengerCommand->isRefresh() && currentRank->refreshAllReady())

	mov	eax, DWORD PTR [eax]
	jmp	$LN360@readNextCo@2
$LN143@readNextCo@2:

; 1492 : 								// stop searching since all the queues are proved to have refresh commands at the front
; 1493 : 								break;
; 1494 : 							}						
; 1495 : 						}
; 1496 : 						// can ignore refresh commands since it's known that not all the queues have a ref command at the front
; 1497 : 						else if (!challengerCommand->isRefresh())

	cmp	DWORD PTR [esi+80], 12			; 0000000cH
	je	SHORT $LN138@readNextCo@2
$LN1833@readNextCo@2:

; 1498 : 						{
; 1499 : 							tick challengerExecuteTime = earliestExecuteTime(challengerCommand);

	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+8]
	push	esi
	mov	ecx, ebp
	call	edx

; 1500 : #ifndef NDEBUG
; 1501 : 							int minGap = minProtocolGap(challengerCommand);
; 1502 : 
; 1503 : 							if (time + minGap != challengerExecuteTime)
; 1504 : 							{
; 1505 : 								cerr << time << " " << minGap << " " << challengerExecuteTime << " " << challengerCommand->getCommandType() << " " << challengerCommand->getAddress() << endl;
; 1506 : 
; 1507 : 								if (challengerCommand && (time + minGap != challengerExecuteTime))
; 1508 : 								{
; 1509 : 									minGap = minProtocolGap(challengerCommand);
; 1510 : 									assert(challengerCommand && (time + minGap == challengerExecuteTime));
; 1511 : 								}
; 1512 : 							}
; 1513 : #endif
; 1514 : 							// set a new candidate if the challenger can be executed sooner or execution times are the same but the challenger is older
; 1515 : 							if ((challengerExecuteTime < candidateExecuteTime) ||
; 1516 : 								(candidateExecuteTime == challengerExecuteTime &&
; 1517 : 								challengerCommand->getEnqueueTime() < candidateCommand->getEnqueueTime()))

	cmp	edx, DWORD PTR _candidateExecuteTime$219510[esp+380]
	jl	SHORT $LN1789@readNextCo@2
	jg	SHORT $LN1788@readNextCo@2
	cmp	eax, DWORD PTR _candidateExecuteTime$219510[esp+376]
	jb	SHORT $LN1789@readNextCo@2
$LN1788@readNextCo@2:
	cmp	DWORD PTR _candidateExecuteTime$219510[esp+376], eax
	jne	SHORT $LN138@readNextCo@2
	cmp	DWORD PTR _candidateExecuteTime$219510[esp+380], edx
	jne	SHORT $LN138@readNextCo@2
	mov	ecx, DWORD PTR [esi+20]
	mov	ebx, DWORD PTR _candidateCommand$219509[esp+376]
	cmp	ecx, DWORD PTR [ebx+20]
	jg	SHORT $LN138@readNextCo@2
	jl	SHORT $LN1789@readNextCo@2
	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, DWORD PTR [ebx+16]
	jae	SHORT $LN138@readNextCo@2
$LN1789@readNextCo@2:

; 1518 : 							{								
; 1519 : 								candidateExecuteTime = challengerExecuteTime;

	mov	DWORD PTR _candidateExecuteTime$219510[esp+376], eax
	mov	DWORD PTR _candidateExecuteTime$219510[esp+380], edx

; 1520 : 								candidateCommand = challengerCommand;															

	mov	DWORD PTR _candidateCommand$219509[esp+376], esi
$LN138@readNextCo@2:

; 1521 : 							}
; 1522 : 						}
; 1523 : 					}
; 1524 : 
; 1525 : 					// if it was a refresh command was chosen then it wouldn't make it this far, so it's not a refresh command
; 1526 : 					// if a refresh command wasn't chosen then there one can't be found later
; 1527 : 					isRefreshCommand = false;

	xor	bl, bl
	test	edi, edi
	jne	SHORT $LN1769@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN293@readNextCo@2:
	mov	ecx, DWORD PTR tv7199[esp+376]
	lea	edx, DWORD PTR [ecx-32]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN284@readNextCo@2
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR tv7199[esp+376]
$LN284@readNextCo@2:

; 1464 : 
; 1465 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	add	ecx, 152				; 00000098H
	jmp	$LN1834@readNextCo@2
$LN1769@readNextCo@2:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN293@readNextCo@2
$LN1768@readNextCo@2:

; 1458 : 
; 1459 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	eax, DWORD PTR [eax]
	jmp	$LN213@readNextCo@2
$LN148@readNextCo@2:

; 1528 : 				}				
; 1529 : 			}
; 1530 : 
; 1531 : 			if (candidateCommand)
; 1532 : 			{
; 1533 : 				assert(candidateCommand->isRefresh() || rank[candidateCommand->getAddress().getRank()].bank[candidateCommand->getAddress().getBank()].front() == candidateCommand);
; 1534 : 
; 1535 : #ifdef DEBUG_GREEDY
; 1536 : 				timingOutStream << "rk[" << candidateCommand->getAddress().rank << "] rk[" << candidateCommand->getAddress().bank << "]\tWinner: " << *candidateCommand << "gap[" << candidateGap << "] now[" << time << "]" << endl;
; 1537 : #endif
; 1538 : 			}
; 1539 : 
; 1540 : 			return candidateCommand;

	mov	eax, DWORD PTR _candidateCommand$219509[esp+376]

; 2182 : 		}
; 2183 : 		break;
; 2184 : 	}
; 2185 : 	return NULL;
; 2186 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN135@readNextCo@2:

; 1541 : 		}
; 1542 : 		break;
; 1543 : 
; 1544 : 	case FIRST_AVAILABLE_RIFF:
; 1545 : 		{
; 1546 : 			const Command *candidateCommand = NULL;
; 1547 : 
; 1548 : 			tick candidateExecuteTime = TICK_MAX;
; 1549 : 
; 1550 : 			vector<Rank>::const_iterator rankEnd = rank.end();

	mov	eax, DWORD PTR [ebp+384]
	mov	DWORD PTR _candidateCommand$219561[esp+376], 0
	mov	DWORD PTR _candidateExecuteTime$219562[esp+376], -1
	mov	DWORD PTR _candidateExecuteTime$219562[esp+380], 2147483647 ; 7fffffffH
	mov	DWORD PTR $T607177[esp+376], eax
	cmp	DWORD PTR [ebp+380], eax
	jbe	SHORT $LN376@readNextCo@2
	call	__invalid_parameter_noinfo
$LN376@readNextCo@2:

; 1551 : 
; 1552 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	esi, DWORD PTR [ebp+380]
	mov	edx, DWORD PTR [ebp+368]
	mov	DWORD PTR _rankEnd$219569[esp+376], edx
	cmp	esi, DWORD PTR [ebp+384]
	jbe	SHORT $LN390@readNextCo@2
	call	__invalid_parameter_noinfo
$LN390@readNextCo@2:
	mov	edi, DWORD PTR [ebp+368]
	lea	ebx, DWORD PTR [esi+188]
	mov	DWORD PTR _currentRank$219575[esp+376], edi
	mov	DWORD PTR tv7449[esp+376], ebx
$LL405@readNextCo@2:
	test	edi, edi
	je	SHORT $LN417@readNextCo@2
	cmp	edi, DWORD PTR _rankEnd$219569[esp+376]
	je	SHORT $LN418@readNextCo@2
$LN417@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN418@readNextCo@2:
	lea	esi, DWORD PTR [ebx-188]
	cmp	esi, DWORD PTR $T607177[esp+376]
	je	$LN132@readNextCo@2

; 1553 : 			{
; 1554 : 				bool isRefreshCommand = true;

	mov	BYTE PTR _isRefreshCommand$219581[esp+376], 1

; 1555 : 
; 1556 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	test	edi, edi
	jne	$LN1767@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN436@readNextCo@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN427@readNextCo@2
	call	__invalid_parameter_noinfo
$LN427@readNextCo@2:
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR $T607389[esp+376], eax
	cmp	DWORD PTR [ebx-4], eax
	jbe	SHORT $LN442@readNextCo@2
	call	__invalid_parameter_noinfo
$LN442@readNextCo@2:
	mov	eax, DWORD PTR [ebx-16]
	mov	DWORD PTR _bankEnd$219586[esp+376], eax

; 1557 : 
; 1558 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	test	edi, edi
	jne	$LN1766@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN464@readNextCo@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN455@readNextCo@2
	call	__invalid_parameter_noinfo
$LN455@readNextCo@2:
	mov	esi, DWORD PTR [ebx-4]
	cmp	esi, DWORD PTR [ebx]
	jbe	SHORT $LN470@readNextCo@2
	call	__invalid_parameter_noinfo
$LN470@readNextCo@2:
	mov	ecx, DWORD PTR tv7449[esp+376]
	mov	edi, DWORD PTR [ecx-16]
	lea	ebx, DWORD PTR [esi+32]
	mov	DWORD PTR _currentBank$219592[esp+376], edi
	mov	DWORD PTR tv7368[esp+376], ebx
$LL485@readNextCo@2:
	test	edi, edi
	je	SHORT $LN497@readNextCo@2
	cmp	edi, DWORD PTR _bankEnd$219586[esp+376]
	je	SHORT $LN498@readNextCo@2
$LN497@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN498@readNextCo@2:
	lea	esi, DWORD PTR [ebx-32]
	cmp	esi, DWORD PTR $T607389[esp+376]
	je	$LN133@readNextCo@2

; 1559 : 				{	
; 1560 : 					if (!currentBank->isEmpty())

	test	edi, edi
	jne	$LN1765@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN516@readNextCo@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN507@readNextCo@2
	call	__invalid_parameter_noinfo
$LN507@readNextCo@2:
	cmp	DWORD PTR [ebx-24], 0
	je	$LN119@readNextCo@2

; 1561 : 					{
; 1562 : 						const Command *challengerCommand = currentBank->front();

	mov	eax, DWORD PTR _currentBank$219592[esp+376]
	test	eax, eax
	jne	$LN1764@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN534@readNextCo@2:
	mov	edi, DWORD PTR tv7368[esp+376]
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN525@readNextCo@2
	call	__invalid_parameter_noinfo
$LN525@readNextCo@2:
	mov	edx, DWORD PTR [edi+4]
	sub	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR [edi-20]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN541@readNextCo@2
	call	__invalid_parameter_noinfo
$LN541@readNextCo@2:

; 1563 : 
; 1564 : 						assert(challengerCommand == NULL || challengerCommand->isRefresh() || rank[challengerCommand->getAddress().getRank()].bank[challengerCommand->getAddress().getBank()].front() == challengerCommand);
; 1565 : 
; 1566 : 						// see if it is a refresh command
; 1567 : 						if (isRefreshCommand && challengerCommand->isRefresh() && currentRank->refreshAllReady())

	cmp	BYTE PTR _isRefreshCommand$219581[esp+376], 0
	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax+esi*4]
	je	$LN127@readNextCo@2
	cmp	DWORD PTR [esi+80], 12			; 0000000cH
	jne	$LN1836@readNextCo@2
	mov	eax, DWORD PTR _currentRank$219575[esp+376]
	test	eax, eax
	jne	$LN1763@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN559@readNextCo@2:
	mov	ecx, DWORD PTR tv7449[esp+376]
	add	ecx, -188				; ffffff44H
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN550@readNextCo@2
	call	__invalid_parameter_noinfo
$LN550@readNextCo@2:
	mov	ecx, DWORD PTR tv7449[esp+376]
	add	ecx, -188				; ffffff44H
	push	ecx
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	je	$LN127@readNextCo@2

; 1568 : 						{
; 1569 : 							tick challengerExecuteTime = earliestExecuteTime(challengerCommand);

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+8]
	push	esi
	mov	ecx, ebp
	call	eax

; 1570 : #ifndef NDEBUG
; 1571 : 							int minGap = minProtocolGap(challengerCommand);
; 1572 : 
; 1573 : 							if (time + minGap != challengerExecuteTime)
; 1574 : 								assert(time + minGap == challengerExecuteTime);
; 1575 : #endif
; 1576 : 							if ((challengerExecuteTime < candidateExecuteTime) ||
; 1577 : 								(candidateExecuteTime == challengerExecuteTime && ((challengerCommand->isRead() && candidateCommand->isWrite()) ||
; 1578 : 								(challengerCommand->isRead() && candidateCommand->isRead() && challengerCommand->getEnqueueTime() < candidateCommand->getEnqueueTime()))) ||
; 1579 : 								(time - challengerCommand->getEnqueueTime() > 12 * systemConfig.getSeniorityAgeLimit()))

	mov	ecx, DWORD PTR _candidateExecuteTime$219562[esp+380]
	cmp	edx, ecx
	jl	$LN1724@readNextCo@2
	jg	SHORT $LN1790@readNextCo@2
	cmp	eax, DWORD PTR _candidateExecuteTime$219562[esp+376]
	jb	SHORT $LN1724@readNextCo@2
$LN1790@readNextCo@2:
	cmp	DWORD PTR _candidateExecuteTime$219562[esp+376], eax
	jne	SHORT $LN1791@readNextCo@2
	cmp	ecx, edx
	jne	SHORT $LN1791@readNextCo@2
	mov	eax, esi
	call	?isRead@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isRead
	mov	edi, DWORD PTR _candidateCommand$219561[esp+376]
	test	al, al
	je	SHORT $LN123@readNextCo@2
	mov	eax, edi
	call	?isWrite@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isWrite
	test	al, al
	jne	SHORT $LN1724@readNextCo@2
$LN123@readNextCo@2:
	mov	eax, esi
	call	?isRead@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isRead
	test	al, al
	je	SHORT $LN1791@readNextCo@2
	mov	eax, edi
	call	?isRead@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isRead
	test	al, al
	je	SHORT $LN1791@readNextCo@2
	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, DWORD PTR [edi+20]
	jl	SHORT $LN1724@readNextCo@2
	jg	SHORT $LN1791@readNextCo@2
	mov	edx, DWORD PTR [esi+16]
	cmp	edx, DWORD PTR [edi+16]
	jb	SHORT $LN1724@readNextCo@2
$LN1791@readNextCo@2:
	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [ebp+176]
	mov	edx, DWORD PTR [edx+320]
	sub	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ebp+12]
	sbb	eax, DWORD PTR [esi+20]
	lea	edx, DWORD PTR [edx+edx*2]
	add	edx, edx
	xor	edi, edi
	add	edx, edx
	cmp	eax, edi
	jg	SHORT $LN1724@readNextCo@2
	jl	$LN119@readNextCo@2
	cmp	ecx, edx
	jbe	$LN119@readNextCo@2
$LN1724@readNextCo@2:

; 1580 : 							{						
; 1581 : 								candidateCommand = challengerCommand;

	mov	DWORD PTR _candidateCommand$219561[esp+376], esi
$LN133@readNextCo@2:

; 1551 : 
; 1552 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	eax, DWORD PTR _currentRank$219575[esp+376]
	test	eax, eax
	jne	$LN1761@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN412@readNextCo@2:
	mov	ecx, DWORD PTR tv7449[esp+376]
	add	ecx, -188				; ffffff44H
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN403@readNextCo@2
	call	__invalid_parameter_noinfo
$LN403@readNextCo@2:
	add	DWORD PTR tv7449[esp+376], 200		; 000000c8H
	mov	edi, DWORD PTR _currentRank$219575[esp+376]
	mov	ebx, DWORD PTR tv7449[esp+376]
	jmp	$LL405@readNextCo@2
$LN1767@readNextCo@2:

; 1555 : 
; 1556 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	mov	eax, DWORD PTR [edi]
	jmp	$LN436@readNextCo@2
$LN1766@readNextCo@2:

; 1557 : 
; 1558 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	mov	eax, DWORD PTR [edi]
	jmp	$LN464@readNextCo@2
$LN1765@readNextCo@2:

; 1559 : 				{	
; 1560 : 					if (!currentBank->isEmpty())

	mov	eax, DWORD PTR [edi]
	jmp	$LN516@readNextCo@2
$LN1764@readNextCo@2:

; 1561 : 					{
; 1562 : 						const Command *challengerCommand = currentBank->front();

	mov	eax, DWORD PTR [eax]
	jmp	$LN534@readNextCo@2
$LN1763@readNextCo@2:

; 1563 : 
; 1564 : 						assert(challengerCommand == NULL || challengerCommand->isRefresh() || rank[challengerCommand->getAddress().getRank()].bank[challengerCommand->getAddress().getBank()].front() == challengerCommand);
; 1565 : 
; 1566 : 						// see if it is a refresh command
; 1567 : 						if (isRefreshCommand && challengerCommand->isRefresh() && currentRank->refreshAllReady())

	mov	eax, DWORD PTR [eax]
	jmp	$LN559@readNextCo@2
$LN127@readNextCo@2:

; 1582 : 								// stop searching since all the queues are proved to have refresh commands at the front
; 1583 : 								break;
; 1584 : 							}						
; 1585 : 						}
; 1586 : 						// can ignore refresh commands since it's known that not all the queues have a ref command at the front
; 1587 : 						else if (!challengerCommand->isRefresh())

	cmp	DWORD PTR [esi+80], 12			; 0000000cH
	je	$LN119@readNextCo@2
$LN1836@readNextCo@2:

; 1588 : 						{
; 1589 : 							tick challengerExecuteTime = earliestExecuteTime(challengerCommand);

	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+8]
	push	esi
	mov	ecx, ebp
	call	edx
	mov	ebx, edx

; 1590 : #ifndef NDEBUG
; 1591 : 							int minGap = minProtocolGap(challengerCommand);
; 1592 : 
; 1593 : 							if (time + minGap != challengerExecuteTime)
; 1594 : 							{
; 1595 : 								cerr << time << " " << minGap << " " << challengerExecuteTime;
; 1596 : 
; 1597 : 								assert(time + minGap == challengerExecuteTime);
; 1598 : 							}
; 1599 : #endif
; 1600 : 							// set a new candidate if the challenger can be executed sooner or execution times are the same but the challenger is older
; 1601 : 							if ((challengerExecuteTime < candidateExecuteTime) ||
; 1602 : 								(candidateExecuteTime == challengerExecuteTime && ((challengerCommand->isRead() && candidateCommand->isWrite()) ||
; 1603 : 								(challengerCommand->isRead() && candidateCommand->isRead() && challengerCommand->getEnqueueTime() < candidateCommand->getEnqueueTime()))) ||
; 1604 : 								(time - challengerCommand->getEnqueueTime() > 12 *systemConfig.getSeniorityAgeLimit()))

	cmp	ebx, DWORD PTR _candidateExecuteTime$219562[esp+380]
	mov	DWORD PTR _challengerExecuteTime$219610[esp+376], eax
	jl	$LN1795@readNextCo@2
	jg	SHORT $LN1793@readNextCo@2
	mov	eax, DWORD PTR _candidateExecuteTime$219562[esp+376]
	cmp	DWORD PTR _challengerExecuteTime$219610[esp+376], eax
	jb	$LN1795@readNextCo@2
$LN1793@readNextCo@2:
	mov	ecx, DWORD PTR _challengerExecuteTime$219610[esp+376]
	cmp	DWORD PTR _candidateExecuteTime$219562[esp+376], ecx
	jne	SHORT $LN1794@readNextCo@2
	cmp	DWORD PTR _candidateExecuteTime$219562[esp+380], ebx
	jne	SHORT $LN1794@readNextCo@2
	mov	edi, DWORD PTR [esi+80]
	cmp	edi, 1
	je	SHORT $LN574@readNextCo@2
	cmp	edi, 2
	jne	SHORT $LN116@readNextCo@2
$LN574@readNextCo@2:
	mov	eax, DWORD PTR _candidateCommand$219561[esp+376]
	call	?isWrite@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isWrite
	test	al, al
	jne	SHORT $LN1795@readNextCo@2
$LN116@readNextCo@2:
	cmp	edi, 1
	je	SHORT $LN578@readNextCo@2
	cmp	edi, 2
	jne	SHORT $LN1794@readNextCo@2
$LN578@readNextCo@2:
	mov	edi, DWORD PTR _candidateCommand$219561[esp+376]
	mov	eax, edi
	call	?isRead@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isRead
	test	al, al
	je	SHORT $LN1794@readNextCo@2
	mov	edx, DWORD PTR [esi+20]
	cmp	edx, DWORD PTR [edi+20]
	jl	SHORT $LN1795@readNextCo@2
	jg	SHORT $LN1794@readNextCo@2
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, edi
	cmp	eax, DWORD PTR [ecx+16]
	jb	SHORT $LN1795@readNextCo@2
$LN1794@readNextCo@2:
	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [ebp+176]
	mov	edx, DWORD PTR [edx+320]
	sub	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ebp+12]
	sbb	eax, DWORD PTR [esi+20]
	lea	edx, DWORD PTR [edx+edx*2]
	add	edx, edx
	xor	edi, edi
	add	edx, edx
	cmp	eax, edi
	jl	SHORT $LN119@readNextCo@2
	jg	SHORT $LN1795@readNextCo@2
	cmp	ecx, edx
	jbe	SHORT $LN119@readNextCo@2
$LN1795@readNextCo@2:

; 1605 : 							{								
; 1606 : 								candidateExecuteTime = challengerExecuteTime;

	mov	eax, DWORD PTR _challengerExecuteTime$219610[esp+376]
	mov	DWORD PTR _candidateExecuteTime$219562[esp+376], eax
	mov	DWORD PTR _candidateExecuteTime$219562[esp+380], ebx

; 1607 : 								candidateCommand = challengerCommand;															

	mov	DWORD PTR _candidateCommand$219561[esp+376], esi
$LN119@readNextCo@2:
	mov	eax, DWORD PTR _currentBank$219592[esp+376]

; 1608 : 							}
; 1609 : 						}
; 1610 : 					}
; 1611 : 
; 1612 : 					// if it was a refresh command was chosen then it wouldn't make it this far, so it's not a refresh command
; 1613 : 					// if a refresh command wasn't chosen then there one can't be found later
; 1614 : 					isRefreshCommand = false;

	mov	BYTE PTR _isRefreshCommand$219581[esp+376], 0
	test	eax, eax
	jne	SHORT $LN1762@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN492@readNextCo@2:
	mov	ecx, DWORD PTR tv7368[esp+376]
	add	ecx, -32				; ffffffe0H
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN483@readNextCo@2

; 1557 : 
; 1558 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	call	__invalid_parameter_noinfo
$LN483@readNextCo@2:
	add	DWORD PTR tv7368[esp+376], 152		; 00000098H
	mov	ebx, DWORD PTR tv7368[esp+376]
	mov	edi, DWORD PTR _currentBank$219592[esp+376]
	jmp	$LL485@readNextCo@2
$LN1762@readNextCo@2:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN492@readNextCo@2
$LN1761@readNextCo@2:

; 1551 : 
; 1552 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	eax, DWORD PTR [eax]
	jmp	$LN412@readNextCo@2
$LN132@readNextCo@2:

; 1615 : 				}				
; 1616 : 			}
; 1617 : 
; 1618 : 			if (candidateCommand)
; 1619 : 			{
; 1620 : 				assert(candidateCommand->isRefresh() || rank[candidateCommand->getAddress().getRank()].bank[candidateCommand->getAddress().getBank()].front() == candidateCommand);
; 1621 : 
; 1622 : #ifdef DEBUG_GREEDY
; 1623 : 				timingOutStream << "rk[" << candidateCommand->getAddress().rank << "] rk[" << candidateCommand->getAddress().bank << "]\tWinner: " << *candidateCommand << "gap[" << candidateGap << "] now[" << time << "]" << endl;
; 1624 : #endif
; 1625 : 			}
; 1626 : 
; 1627 : 			return candidateCommand;

	mov	eax, DWORD PTR _candidateCommand$219561[esp+376]

; 2182 : 		}
; 2183 : 		break;
; 2184 : 	}
; 2185 : 	return NULL;
; 2186 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN113@readNextCo@2:

; 1628 : 		}
; 1629 : 		break;
; 1630 : 
; 1631 : 	case FIRST_AVAILABLE_QUEUE:
; 1632 : 		{
; 1633 : 			const Command *candidateCommand = NULL;
; 1634 : 
; 1635 : 			tick candidateExecuteTime = TICK_MAX;
; 1636 : 
; 1637 : 			vector<Rank>::const_iterator rankEnd = rank.end();

	mov	eax, DWORD PTR [ebp+384]
	lea	esi, DWORD PTR [ebp+368]
	mov	DWORD PTR _candidateCommand$219619[esp+376], 0
	mov	DWORD PTR _candidateExecuteTime$219620[esp+376], -1
	mov	DWORD PTR _candidateExecuteTime$219620[esp+380], 2147483647 ; 7fffffffH
	mov	DWORD PTR $T607827[esp+376], eax
	cmp	DWORD PTR [esi+12], eax
	jbe	SHORT $LN591@readNextCo@2
	call	__invalid_parameter_noinfo
$LN591@readNextCo@2:

; 1638 : 
; 1639 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	edi, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _rankEnd$219627[esp+376], ecx
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN605@readNextCo@2
	call	__invalid_parameter_noinfo
$LN605@readNextCo@2:
	mov	ebp, DWORD PTR [esi]
	mov	DWORD PTR _currentRank$219633[esp+376], ebp
	lea	ebx, DWORD PTR [edi+188]
$LN1839@readNextCo@2:
	mov	DWORD PTR tv7523[esp+376], ebx
	test	ebp, ebp
	je	SHORT $LN632@readNextCo@2
	cmp	ebp, DWORD PTR _rankEnd$219627[esp+376]
	je	SHORT $LN633@readNextCo@2
$LN632@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN633@readNextCo@2:
	lea	esi, DWORD PTR [ebx-188]
	cmp	esi, DWORD PTR $T607827[esp+376]
	je	$LN148@readNextCo@2

; 1640 : 			{
; 1641 : 				bool isRefreshCommand = true;

	mov	BYTE PTR _isRefreshCommand$219639[esp+376], 1

; 1642 : 
; 1643 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	test	ebp, ebp
	jne	$LN1760@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN651@readNextCo@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN642@readNextCo@2
	call	__invalid_parameter_noinfo
$LN642@readNextCo@2:
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR $T608039[esp+376], ebp
	cmp	DWORD PTR [ebx-4], ebp
	jbe	SHORT $LN657@readNextCo@2
	call	__invalid_parameter_noinfo
$LN657@readNextCo@2:

; 1644 : 
; 1645 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	mov	eax, DWORD PTR _currentRank$219633[esp+376]
	mov	edx, DWORD PTR [ebx-16]
	mov	DWORD PTR _bankEnd$219644[esp+376], edx
	test	eax, eax
	jne	$LN1759@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN679@readNextCo@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN670@readNextCo@2
	call	__invalid_parameter_noinfo
$LN670@readNextCo@2:
	mov	edi, DWORD PTR [ebx-4]
	cmp	edi, DWORD PTR [ebx]
	jbe	SHORT $LN685@readNextCo@2
	call	__invalid_parameter_noinfo
$LN685@readNextCo@2:
	mov	esi, DWORD PTR [ebx-16]
	mov	DWORD PTR _currentBank$219650[esp+376], esi
	mov	DWORD PTR _currentBank$219650[esp+380], edi
$LL700@readNextCo@2:
	test	esi, esi
	je	SHORT $LN712@readNextCo@2
	cmp	esi, DWORD PTR _bankEnd$219644[esp+376]
	je	SHORT $LN713@readNextCo@2
$LN712@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN713@readNextCo@2:
	cmp	edi, ebp
	je	$LN111@readNextCo@2

; 1646 : 				{	
; 1647 : 					if (!currentBank->isEmpty())

	test	esi, esi
	jne	$LN1758@readNextCo@2
	call	__invalid_parameter_noinfo
$LN731@readNextCo@2:
	cmp	edi, DWORD PTR [esi+16]
	jb	SHORT $LN722@readNextCo@2
	call	__invalid_parameter_noinfo
$LN722@readNextCo@2:
	cmp	DWORD PTR [edi+8], 0
	je	$LN99@readNextCo@2

; 1648 : 					{
; 1649 : 						const Command *challengerCommand = currentBank->front();

	mov	eax, DWORD PTR _currentBank$219650[esp+376]
	test	eax, eax
	jne	$LN1757@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN749@readNextCo@2:
	mov	esi, DWORD PTR _currentBank$219650[esp+380]
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN740@readNextCo@2
	call	__invalid_parameter_noinfo
$LN740@readNextCo@2:
	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	mov	edi, DWORD PTR [esi+12]
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LN756@readNextCo@2
	call	__invalid_parameter_noinfo
$LN756@readNextCo@2:

; 1650 : 
; 1651 : 						assert(challengerCommand == NULL || challengerCommand->isRefresh() || rank[challengerCommand->getAddress().getRank()].bank[challengerCommand->getAddress().getBank()].front() == challengerCommand);
; 1652 : 
; 1653 : 						// see if it is a refresh command
; 1654 : 						if (isRefreshCommand && challengerCommand->isRefresh() && currentRank->refreshAllReady())

	cmp	BYTE PTR _isRefreshCommand$219639[esp+376], 0
	mov	ecx, DWORD PTR [esi+32]
	mov	ebp, DWORD PTR [ecx+edi*4]
	je	$LN105@readNextCo@2
	cmp	DWORD PTR [ebp+80], 12			; 0000000cH
	jne	$LN1838@readNextCo@2
	mov	eax, DWORD PTR _currentRank$219633[esp+376]
	test	eax, eax
	jne	$LN1756@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN774@readNextCo@2:
	mov	ebx, DWORD PTR tv7523[esp+376]
	lea	ecx, DWORD PTR [ebx-188]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN765@readNextCo@2
	call	__invalid_parameter_noinfo
$LN765@readNextCo@2:
	lea	edx, DWORD PTR [ebx-188]
	push	edx
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	je	$LN105@readNextCo@2

; 1655 : 						{
; 1656 : 							tick challengerExecuteTime = earliestExecuteTime(challengerCommand);

	mov	esi, DWORD PTR _this$[esp+376]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+8]
	push	ebp
	mov	ecx, esi
	call	edx

; 1657 : #ifndef NDEBUG
; 1658 : 							int minGap = minProtocolGap(challengerCommand);
; 1659 : 
; 1660 : 							if (time + minGap!= max(challengerExecuteTime,time))
; 1661 : 								assert(time + minGap == challengerExecuteTime);
; 1662 : #endif
; 1663 : 							// if it can execute earlier, at the same time and has greater queue pressure or it is starving
; 1664 : 							if ((challengerExecuteTime < candidateExecuteTime) ||
; 1665 : 								(candidateExecuteTime == challengerExecuteTime && currentBank->size() > rank[candidateCommand->getAddress().getRank()].bank[candidateCommand->getAddress().getBank()].size()) ||
; 1666 : 								(time - challengerCommand->getEnqueueTime() > systemConfig.getSeniorityAgeLimit()))

	mov	ecx, DWORD PTR _candidateExecuteTime$219620[esp+380]
	cmp	edx, ecx
	jl	$LN1725@readNextCo@2
	jg	SHORT $LN1796@readNextCo@2
	cmp	eax, DWORD PTR _candidateExecuteTime$219620[esp+376]
	jb	SHORT $LN1725@readNextCo@2
$LN1796@readNextCo@2:
	cmp	DWORD PTR _candidateExecuteTime$219620[esp+376], eax
	jne	SHORT $LN102@readNextCo@2
	cmp	ecx, edx
	jne	SHORT $LN102@readNextCo@2
	lea	esi, DWORD PTR _currentBank$219650[esp+376]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ebx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _candidateCommand$219619[esp+376]
	mov	ecx, DWORD PTR [eax+64]
	mov	esi, DWORD PTR _this$[esp+376]
	mov	edi, DWORD PTR [eax+60]
	add	esi, 368				; 00000170H
	mov	DWORD PTR $T608412[esp+376], ecx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	edi, DWORD PTR $T608412[esp+376]
	mov	esi, eax
	add	esi, 172				; 000000acH
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	cmp	ebx, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR tv7523[esp+376]
	ja	SHORT $LN1725@readNextCo@2
	mov	esi, DWORD PTR _this$[esp+376]
$LN102@readNextCo@2:
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [ebp+16]
	mov	eax, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+176]
	sbb	eax, DWORD PTR [ebp+20]
	mov	esi, DWORD PTR [edx+320]
	xor	edx, edx
	cmp	eax, edx
	jg	SHORT $LN1725@readNextCo@2
	jl	$LN99@readNextCo@2
	cmp	ecx, esi
	jbe	$LN99@readNextCo@2
$LN1725@readNextCo@2:

; 1667 : 							{						
; 1668 : 								candidateCommand = challengerCommand;

	mov	DWORD PTR _candidateCommand$219619[esp+376], ebp
$LN111@readNextCo@2:

; 1638 : 
; 1639 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	eax, DWORD PTR _currentRank$219633[esp+376]
	test	eax, eax
	jne	$LN1754@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN627@readNextCo@2:
	lea	ecx, DWORD PTR [ebx-188]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN618@readNextCo@2
	call	__invalid_parameter_noinfo
$LN618@readNextCo@2:
	mov	ebp, DWORD PTR _currentRank$219633[esp+376]
	add	ebx, 200				; 000000c8H
	jmp	$LN1839@readNextCo@2
$LN1760@readNextCo@2:

; 1642 : 
; 1643 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	mov	eax, DWORD PTR [ebp]
	jmp	$LN651@readNextCo@2
$LN1759@readNextCo@2:

; 1644 : 
; 1645 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	mov	eax, DWORD PTR [eax]
	jmp	$LN679@readNextCo@2
$LN1758@readNextCo@2:

; 1646 : 				{	
; 1647 : 					if (!currentBank->isEmpty())

	mov	esi, DWORD PTR [esi]
	jmp	$LN731@readNextCo@2
$LN1757@readNextCo@2:

; 1648 : 					{
; 1649 : 						const Command *challengerCommand = currentBank->front();

	mov	eax, DWORD PTR [eax]
	jmp	$LN749@readNextCo@2
$LN1756@readNextCo@2:

; 1650 : 
; 1651 : 						assert(challengerCommand == NULL || challengerCommand->isRefresh() || rank[challengerCommand->getAddress().getRank()].bank[challengerCommand->getAddress().getBank()].front() == challengerCommand);
; 1652 : 
; 1653 : 						// see if it is a refresh command
; 1654 : 						if (isRefreshCommand && challengerCommand->isRefresh() && currentRank->refreshAllReady())

	mov	eax, DWORD PTR [eax]
	jmp	$LN774@readNextCo@2
$LN105@readNextCo@2:

; 1669 : 								// stop searching since all the queues are proved to have refresh commands at the front
; 1670 : 								break;
; 1671 : 							}						
; 1672 : 						}
; 1673 : 						// can ignore refresh commands since it's known that not all the queues have a ref command at the front
; 1674 : 						else if (!challengerCommand->isRefresh())

	cmp	DWORD PTR [ebp+80], 12			; 0000000cH
	je	$LN99@readNextCo@2
$LN1838@readNextCo@2:

; 1675 : 						{
; 1676 : 							tick challengerExecuteTime = earliestExecuteTime(challengerCommand);

	mov	ecx, DWORD PTR _this$[esp+376]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	ebp
	call	edx

; 1677 : #ifndef NDEBUG
; 1678 : 							int minGap = minProtocolGap(challengerCommand);
; 1679 : 
; 1680 : 							if (time + minGap != challengerExecuteTime)
; 1681 : 							{
; 1682 : 								cerr << time << " " << minGap << " " << challengerExecuteTime;
; 1683 : 
; 1684 : 								assert(time + minGap == challengerExecuteTime);
; 1685 : 							}
; 1686 : #endif
; 1687 : 							// if it can execute earlier, at the same time and has greater queue pressure or it is starving
; 1688 : 							if ((challengerExecuteTime < candidateExecuteTime) ||
; 1689 : 								(candidateExecuteTime == challengerExecuteTime && currentBank->size() > rank[candidateCommand->getAddress().getRank()].bank[candidateCommand->getAddress().getBank()].size()) ||
; 1690 : 								(time - challengerCommand->getEnqueueTime() > systemConfig.getSeniorityAgeLimit()))

	cmp	edx, DWORD PTR _candidateExecuteTime$219620[esp+380]
	mov	edi, eax
	mov	DWORD PTR _challengerExecuteTime$219666[esp+376], edi
	mov	DWORD PTR _challengerExecuteTime$219666[esp+380], edx
	jl	$LN1799@readNextCo@2
	jg	SHORT $LN1798@readNextCo@2
	cmp	edi, DWORD PTR _candidateExecuteTime$219620[esp+376]
	jb	$LN1799@readNextCo@2
$LN1798@readNextCo@2:
	cmp	DWORD PTR _candidateExecuteTime$219620[esp+376], edi
	jne	SHORT $LN97@readNextCo@2
	cmp	DWORD PTR _candidateExecuteTime$219620[esp+380], edx
	jne	SHORT $LN97@readNextCo@2
	lea	esi, DWORD PTR _currentBank$219650[esp+376]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ebx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _candidateCommand$219619[esp+376]
	mov	ecx, DWORD PTR [eax+64]
	mov	esi, DWORD PTR _this$[esp+376]
	mov	edi, DWORD PTR [eax+60]
	add	esi, 368				; 00000170H
	mov	DWORD PTR $T608457[esp+376], ecx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]
	mov	edi, DWORD PTR $T608457[esp+376]
	mov	esi, eax
	add	esi, 172				; 000000acH
	call	??A?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEABVBank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator[]
	mov	edi, DWORD PTR _challengerExecuteTime$219666[esp+376]
	mov	edx, DWORD PTR _challengerExecuteTime$219666[esp+380]
	cmp	ebx, DWORD PTR [eax+8]
	ja	SHORT $LN1799@readNextCo@2
$LN97@readNextCo@2:
	mov	esi, DWORD PTR _this$[esp+376]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+12]
	sub	ecx, DWORD PTR [ebp+16]
	mov	esi, DWORD PTR [esi+176]
	sbb	eax, DWORD PTR [ebp+20]
	mov	ebx, DWORD PTR [esi+320]
	xor	esi, esi
	cmp	eax, esi
	jl	SHORT $LN99@readNextCo@2
	jg	SHORT $LN1799@readNextCo@2
	cmp	ecx, ebx
	jbe	SHORT $LN99@readNextCo@2
$LN1799@readNextCo@2:

; 1691 : 							{								
; 1692 : 								candidateExecuteTime = challengerExecuteTime;

	mov	DWORD PTR _candidateExecuteTime$219620[esp+376], edi
	mov	DWORD PTR _candidateExecuteTime$219620[esp+380], edx

; 1693 : 								candidateCommand = challengerCommand;															

	mov	DWORD PTR _candidateCommand$219619[esp+376], ebp
$LN99@readNextCo@2:
	mov	eax, DWORD PTR _currentBank$219650[esp+376]

; 1694 : 							}
; 1695 : 						}
; 1696 : 					}
; 1697 : 
; 1698 : 					// if it was a refresh command was chosen then it wouldn't make it this far, so it's not a refresh command
; 1699 : 					// if a refresh command wasn't chosen then there one can't be found later
; 1700 : 					isRefreshCommand = false;

	mov	BYTE PTR _isRefreshCommand$219639[esp+376], 0
	test	eax, eax
	jne	SHORT $LN1755@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN707@readNextCo@2:
	mov	edx, DWORD PTR _currentBank$219650[esp+380]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN698@readNextCo@2

; 1644 : 
; 1645 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	call	__invalid_parameter_noinfo
$LN698@readNextCo@2:
	add	DWORD PTR _currentBank$219650[esp+380], 152 ; 00000098H
	mov	ebx, DWORD PTR tv7523[esp+376]
	mov	edi, DWORD PTR _currentBank$219650[esp+380]
	mov	esi, DWORD PTR _currentBank$219650[esp+376]
	mov	ebp, DWORD PTR $T608039[esp+376]
	jmp	$LL700@readNextCo@2
$LN1755@readNextCo@2:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN707@readNextCo@2
$LN1754@readNextCo@2:

; 1638 : 
; 1639 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	eax, DWORD PTR [eax]
	jmp	$LN627@readNextCo@2
$LN95@readNextCo@2:

; 1701 : 				}				
; 1702 : 			}
; 1703 : 
; 1704 : 			if (candidateCommand)
; 1705 : 			{
; 1706 : 				assert(candidateCommand->isRefresh() || rank[candidateCommand->getAddress().getRank()].bank[candidateCommand->getAddress().getBank()].front() == candidateCommand);
; 1707 : 
; 1708 : #ifdef DEBUG_GREEDY
; 1709 : 				timingOutStream << "rk[" << candidateCommand->getAddress().rank << "] rk[" << candidateCommand->getAddress().bank << "]\tWinner: " << *candidateCommand << "gap[" << candidateGap << "] now[" << time << "]" << endl;
; 1710 : #endif
; 1711 : 			}
; 1712 : 
; 1713 : 			return candidateCommand;
; 1714 : 		}
; 1715 : 		break;
; 1716 : 
; 1717 : 		// this strategy executes all commands in the order they were entered
; 1718 : 	case STRICT_ORDER:
; 1719 : 		{
; 1720 : 			tick oldestCommandTime = TICK_MAX;
; 1721 : 			const Command *oldestCommand = NULL;
; 1722 : 
; 1723 : 			vector<Rank>::const_iterator rankEnd = rank.end();

	mov	ebx, DWORD PTR [ebp+384]
	mov	DWORD PTR _oldestCommandTime$219673[esp+376], -1
	mov	DWORD PTR _oldestCommandTime$219673[esp+380], 2147483647 ; 7fffffffH
	mov	DWORD PTR _oldestCommand$219676[esp+376], 0
	mov	DWORD PTR $T608515[esp+376], ebx
	cmp	DWORD PTR [ebp+380], ebx
	jbe	SHORT $LN822@readNextCo@2
	call	__invalid_parameter_noinfo
$LN822@readNextCo@2:

; 1724 : 
; 1725 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	esi, DWORD PTR [ebp+380]
	mov	eax, DWORD PTR [ebp+368]
	mov	DWORD PTR _rankEnd$219681[esp+376], eax
	cmp	esi, DWORD PTR [ebp+384]
	jbe	SHORT $LN836@readNextCo@2
	call	__invalid_parameter_noinfo
$LN836@readNextCo@2:
	mov	ebp, DWORD PTR [ebp+368]
	mov	DWORD PTR _currentRank$219687[esp+376], ebp
	mov	edi, esi
$LN1840@readNextCo@2:
	mov	DWORD PTR _currentRank$219687[esp+380], edi
	test	ebp, ebp
	je	SHORT $LN863@readNextCo@2
	cmp	ebp, DWORD PTR _rankEnd$219681[esp+376]
	je	SHORT $LN864@readNextCo@2
$LN863@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN864@readNextCo@2:
	cmp	edi, ebx
	je	$LN92@readNextCo@2

; 1726 : 			{
; 1727 : 				bool notAllRefresh = false;

	mov	BYTE PTR _notAllRefresh$219693[esp+376], 0

; 1728 : 
; 1729 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	test	ebp, ebp
	jne	$LN1753@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN882@readNextCo@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN873@readNextCo@2
	call	__invalid_parameter_noinfo
$LN873@readNextCo@2:
	mov	eax, DWORD PTR [edi+188]
	mov	DWORD PTR $T608727[esp+376], eax
	cmp	DWORD PTR [edi+184], eax
	jbe	SHORT $LN888@readNextCo@2
	call	__invalid_parameter_noinfo
$LN888@readNextCo@2:
	mov	ecx, DWORD PTR [edi+172]
	mov	DWORD PTR _bankEnd$219698[esp+376], ecx

; 1730 : 
; 1731 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	test	ebp, ebp
	jne	$LN1752@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN910@readNextCo@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN901@readNextCo@2
	call	__invalid_parameter_noinfo
$LN901@readNextCo@2:
	mov	esi, DWORD PTR [edi+184]
	cmp	esi, DWORD PTR [edi+188]
	jbe	SHORT $LN916@readNextCo@2
	call	__invalid_parameter_noinfo
$LN916@readNextCo@2:
	mov	ebp, DWORD PTR [edi+172]
	lea	ebx, DWORD PTR [esi+32]
$LL931@readNextCo@2:
	test	ebp, ebp
	je	SHORT $LN943@readNextCo@2
	cmp	ebp, DWORD PTR _bankEnd$219698[esp+376]
	je	SHORT $LN944@readNextCo@2
$LN943@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN944@readNextCo@2:
	lea	esi, DWORD PTR [ebx-32]
	cmp	esi, DWORD PTR $T608727[esp+376]
	je	$LN93@readNextCo@2

; 1732 : 				{
; 1733 : 					if (const Command *challengerCommand = currentBank->front())

	test	ebp, ebp
	jne	$LN1751@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN962@readNextCo@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN953@readNextCo@2
	call	__invalid_parameter_noinfo
$LN953@readNextCo@2:
	mov	edx, DWORD PTR [ebx+4]
	sub	edx, DWORD PTR [ebx]
	mov	esi, DWORD PTR [ebx-20]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN969@readNextCo@2
	call	__invalid_parameter_noinfo
$LN969@readNextCo@2:
	mov	eax, DWORD PTR [ebx]
	mov	edi, DWORD PTR [eax+esi*4]
	test	edi, edi
	je	$LN83@readNextCo@2

; 1734 : 					{
; 1735 : #ifndef NDEBUG
; 1736 : 						{
; 1737 : 							const tick executeTime = earliestExecuteTime(challengerCommand);
; 1738 : 							if (executeTime != time + minProtocolGap(challengerCommand))
; 1739 : 							{							
; 1740 : 								assert(executeTime == time + minProtocolGap(challengerCommand));
; 1741 : 							}
; 1742 : 						}						
; 1743 : #endif
; 1744 : 						// choose the oldest command that can be executed
; 1745 : 						if (challengerCommand->getEnqueueTime() < oldestCommandTime)

	mov	eax, DWORD PTR [edi+20]
	cmp	eax, DWORD PTR _oldestCommandTime$219673[esp+380]
	mov	ecx, DWORD PTR [edi+16]
	jg	$LN83@readNextCo@2
	jl	SHORT $LN1800@readNextCo@2
	cmp	ecx, DWORD PTR _oldestCommandTime$219673[esp+376]
	jae	$LN83@readNextCo@2
$LN1800@readNextCo@2:

; 1746 : 						{
; 1747 : 							// if it's a refresh command and
; 1748 : 							// we haven't proved that all the queues aren't refresh_all commands, search
; 1749 : 							if (challengerCommand->isRefresh())

	cmp	DWORD PTR [edi+80], 12			; 0000000cH
	jne	SHORT $LN86@readNextCo@2

; 1750 : 							{
; 1751 : 								if (!notAllRefresh)

	cmp	BYTE PTR _notAllRefresh$219693[esp+376], 0
	jne	SHORT $LN83@readNextCo@2

; 1752 : 								{
; 1753 : 									// if all are known now to be refresh commands
; 1754 : 									if (currentRank->refreshAllReady())

	lea	esi, DWORD PTR _currentRank$219687[esp+376]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	push	eax
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	je	SHORT $LN83@readNextCo@2

; 1755 : 									{
; 1756 : 										oldestCommandTime = challengerCommand->getEnqueueTime();

	mov	ecx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+20]

; 1757 : 										oldestCommand = challengerCommand;

	mov	DWORD PTR _oldestCommand$219676[esp+376], edi
	mov	edi, DWORD PTR _currentRank$219687[esp+380]
	mov	DWORD PTR _oldestCommandTime$219673[esp+376], ecx
	mov	DWORD PTR _oldestCommandTime$219673[esp+380], edx
$LN93@readNextCo@2:
	mov	eax, DWORD PTR _currentRank$219687[esp+376]
	test	eax, eax
	jne	SHORT $LN1749@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN858@readNextCo@2:

; 1724 : 
; 1725 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN849@readNextCo@2
	call	__invalid_parameter_noinfo
$LN849@readNextCo@2:
	mov	ebx, DWORD PTR $T608515[esp+376]
	mov	ebp, DWORD PTR _currentRank$219687[esp+376]
	add	edi, 200				; 000000c8H
	jmp	$LN1840@readNextCo@2
$LN1753@readNextCo@2:

; 1728 : 
; 1729 : 				vector<Bank>::const_iterator bankEnd = currentRank->bank.end();

	mov	eax, DWORD PTR [ebp]
	jmp	$LN882@readNextCo@2
$LN1752@readNextCo@2:

; 1730 : 
; 1731 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	mov	eax, DWORD PTR [ebp]
	jmp	$LN910@readNextCo@2
$LN1751@readNextCo@2:

; 1732 : 				{
; 1733 : 					if (const Command *challengerCommand = currentBank->front())

	mov	eax, DWORD PTR [ebp]
	jmp	$LN962@readNextCo@2
$LN86@readNextCo@2:

; 1758 : 										// don't need to check other banks again
; 1759 : 										break;
; 1760 : 									}
; 1761 : 								}
; 1762 : 							}
; 1763 : 							else
; 1764 : 							{
; 1765 : 								oldestCommandTime = challengerCommand->getEnqueueTime();

	mov	DWORD PTR _oldestCommandTime$219673[esp+376], ecx
	mov	DWORD PTR _oldestCommandTime$219673[esp+380], eax

; 1766 : 								oldestCommand = challengerCommand;

	mov	DWORD PTR _oldestCommand$219676[esp+376], edi
$LN83@readNextCo@2:

; 1767 : 							}
; 1768 : 						}
; 1769 : 					}
; 1770 : 
; 1771 : 					notAllRefresh = true;

	mov	BYTE PTR _notAllRefresh$219693[esp+376], 1
	test	ebp, ebp
	jne	SHORT $LN1750@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN938@readNextCo@2:
	lea	ecx, DWORD PTR [ebx-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN929@readNextCo@2

; 1730 : 
; 1731 : 				for (vector<Bank>::const_iterator currentBank = currentRank->bank.begin(); currentBank != bankEnd; currentBank++)

	call	__invalid_parameter_noinfo
$LN929@readNextCo@2:
	mov	edi, DWORD PTR _currentRank$219687[esp+380]
	add	ebx, 152				; 00000098H
	jmp	$LL931@readNextCo@2
$LN1750@readNextCo@2:
	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN938@readNextCo@2
$LN1749@readNextCo@2:

; 1724 : 
; 1725 : 			for (vector<Rank>::const_iterator currentRank = rank.begin(); currentRank != rankEnd; currentRank++)

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN858@readNextCo@2
$LN92@readNextCo@2:

; 1772 : 				}
; 1773 : 			}
; 1774 : 
; 1775 : 			// if any executable command was found, prioritize it over those which must wait
; 1776 : 
; 1777 : 			return oldestCommand;

	mov	eax, DWORD PTR _oldestCommand$219676[esp+376]

; 2182 : 		}
; 2183 : 		break;
; 2184 : 	}
; 2185 : 	return NULL;
; 2186 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN82@readNextCo@2:

; 1778 : 		}
; 1779 : 		break;
; 1780 : 
; 1781 : 		// alternate ranks as we go down banks
; 1782 : 	case RANK_ROUND_ROBIN:
; 1783 : 		{
; 1784 : 			// the command type to look for first
; 1785 : 			bool readSweep = true;
; 1786 : 
; 1787 : 			// look at the most recently retired command in this channel's history
; 1788 : 			//const unsigned lastBankOffset = lastCommand ? lastCommand->getAddress().getBank() : 0;
; 1789 : 			//const vector<Rank>::const_iterator lastRank = rank.begin() + (lastCommand ? lastCommand->getAddress().getRank() : 0);
; 1790 : 			const Command::CommandType lastCommandType = lastCommand ? (lastCommand->getCommandType()) : Command::READ;

	mov	eax, DWORD PTR [ebp+24]
	test	eax, eax
	je	SHORT $LN156@readNextCo@2
	mov	ecx, DWORD PTR [eax+80]

; 1791 : 
; 1792 : 			// attempt to group RAS/CAS pairs together
; 1793 : 			switch (lastCommandType)

	cmp	ecx, 12					; 0000000cH
	ja	$LN66@readNextCo@2
$LN1784@readNextCo@2:
	movzx	ecx, BYTE PTR $LN1801@readNextCo@2[ecx]
	jmp	DWORD PTR $LN1844@readNextCo@2[ecx*4]
$LN156@readNextCo@2:

; 1778 : 		}
; 1779 : 		break;
; 1780 : 
; 1781 : 		// alternate ranks as we go down banks
; 1782 : 	case RANK_ROUND_ROBIN:
; 1783 : 		{
; 1784 : 			// the command type to look for first
; 1785 : 			bool readSweep = true;
; 1786 : 
; 1787 : 			// look at the most recently retired command in this channel's history
; 1788 : 			//const unsigned lastBankOffset = lastCommand ? lastCommand->getAddress().getBank() : 0;
; 1789 : 			//const vector<Rank>::const_iterator lastRank = rank.begin() + (lastCommand ? lastCommand->getAddress().getRank() : 0);
; 1790 : 			const Command::CommandType lastCommandType = lastCommand ? (lastCommand->getCommandType()) : Command::READ;

	mov	ecx, 1

; 1791 : 
; 1792 : 			// attempt to group RAS/CAS pairs together
; 1793 : 			switch (lastCommandType)

	jmp	SHORT $LN1784@readNextCo@2
$LN79@readNextCo@2:

; 1794 : 			{
; 1795 : 				// if it was RAS before and you want to finish doing the read/write
; 1796 : 			case Command::ACTIVATE:
; 1797 : 				{
; 1798 : 					// look at the command just after the RAS, it should be some sort of CAS
; 1799 : 
; 1800 : 					const Command *nextCommand = ((rank.begin() + lastCommand->getAddress().getRank())->bank.begin() + lastCommand->getAddress().getBank())->front();

	mov	ecx, ebp
	mov	eax, DWORD PTR [ecx+24]
	mov	ebx, DWORD PTR [eax+64]
	mov	ebp, DWORD PTR [eax+60]
	lea	edx, DWORD PTR $T606454[esp+376]
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T606452[esp+384]
	push	eax
	lea	edi, DWORD PTR [ecx+368]
	lea	esi, DWORD PTR $T606451[esp+388]
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	ecx, ebp
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	add	esp, 4
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 172				; 000000acH
	lea	esi, DWORD PTR $T606453[esp+380]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	ecx, ebx
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	esi, eax

; 1801 : 
; 1802 : 					if (nextCommand && nextCommand->isReadOrWrite())

	test	esi, esi
	je	SHORT $LN78@readNextCo@2
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al
	je	SHORT $LN78@readNextCo@2
$LN73@readNextCo@2:

; 1803 : 					{
; 1804 : 						return nextCommand;

	mov	eax, esi

; 2182 : 		}
; 2183 : 		break;
; 2184 : 	}
; 2185 : 	return NULL;
; 2186 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN78@readNextCo@2:

; 1805 : 					}
; 1806 : 					else
; 1807 : 					{
; 1808 : 						cerr << "error: Found a row activate not followed by a column command." << endl;

	push	OFFSET ??_C@_0DO@NJGLEKNI@error?3?5Found?5a?5row?5activate?5not?5@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 1809 : 						exit(2);

	push	2
	call	_exit
$LN1846@readNextCo@2:
$LN76@readNextCo@2:

; 1810 : 					}
; 1811 : 				}
; 1812 : 				break;
; 1813 : 
; 1814 : 			case Command::READ:
; 1815 : 				// try to reuse open rows
; 1816 : 				if (lastCommand)

	test	eax, eax
	je	$LN74@readNextCo@2

; 1817 : 				{
; 1818 : 					const Command *nextCommand = ((rank.begin() + lastCommand->getAddress().getRank())->bank.begin() + lastCommand->getAddress().getBank())->front();

	mov	eax, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [eax+60]
	mov	ebx, DWORD PTR [eax+64]
	lea	edx, DWORD PTR $T606458[esp+376]
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T606456[esp+384]
	push	eax
	lea	edi, DWORD PTR [ebp+368]
	lea	esi, DWORD PTR $T606455[esp+388]
	mov	DWORD PTR $T609031[esp+388], ecx
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	ecx, DWORD PTR $T609031[esp+388]
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	add	esp, 4
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 172				; 000000acH
	lea	esi, DWORD PTR $T606457[esp+380]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	ecx, ebx
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	esi, eax

; 1819 : 
; 1820 : 					if (nextCommand && (nextCommand->isReadOrWrite() || nextCommand->isBasicPrecharge()))

	test	esi, esi
	je	SHORT $LN74@readNextCo@2
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al
	jne	$LN73@readNextCo@2
	cmp	DWORD PTR [esi+80], 6

; 1821 : 					{
; 1822 : 						return nextCommand;

	je	$LN73@readNextCo@2
$LN74@readNextCo@2:

; 1823 : 					}
; 1824 : 					assert(!nextCommand || !nextCommand->isBasicPrecharge());
; 1825 : 				}	
; 1826 : 			case Command::READ_AND_PRECHARGE:
; 1827 : 			case Command::PRECHARGE:
; 1828 : 			case Command::REFRESH_ALL:
; 1829 : 				readSweep = true;

	mov	BYTE PTR _readSweep$219718[esp+376], 1

; 1830 : 				break;

	jmp	$LN80@readNextCo@2
$LN71@readNextCo@2:

; 1831 : 
; 1832 : 			case Command::WRITE:
; 1833 : 				// try to reuse open rows
; 1834 : 				if (lastCommand)

	test	eax, eax
	je	$LN69@readNextCo@2

; 1835 : 				{
; 1836 : 					const Command *nextCommand = ((rank.begin() + lastCommand->getAddress().getRank())->bank.begin() + lastCommand->getAddress().getBank())->front();

	mov	ecx, ebp
	mov	eax, DWORD PTR [ecx+24]
	mov	ebx, DWORD PTR [eax+64]
	mov	ebp, DWORD PTR [eax+60]
	lea	edx, DWORD PTR $T606462[esp+376]
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T606460[esp+384]
	push	eax
	lea	edi, DWORD PTR [ecx+368]
	lea	esi, DWORD PTR $T606459[esp+388]
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	ecx, ebp
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	add	esp, 4
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 172				; 000000acH
	lea	esi, DWORD PTR $T606461[esp+380]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	ecx, ebx
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	esi, eax

; 1837 : 
; 1838 : 					if (nextCommand && (nextCommand->isReadOrWrite() || nextCommand->isBasicPrecharge()))

	test	esi, esi
	je	SHORT $LN69@readNextCo@2
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al
	jne	$LN73@readNextCo@2
	cmp	DWORD PTR [esi+80], 6

; 1839 : 					{
; 1840 : 						return nextCommand;

	je	$LN73@readNextCo@2
$LN69@readNextCo@2:

; 1841 : 					}
; 1842 : 					assert(!nextCommand || !nextCommand->isBasicPrecharge());
; 1843 : 				}		
; 1844 : 			case Command::WRITE_AND_PRECHARGE:
; 1845 : 
; 1846 : 				readSweep = false;
; 1847 : 				break;	

	mov	ebp, DWORD PTR _this$[esp+376]
	mov	BYTE PTR _readSweep$219718[esp+376], 0
	jmp	SHORT $LN80@readNextCo@2
$LN66@readNextCo@2:

; 1848 : 
; 1849 : 			default:
; 1850 : 				readSweep = true;
; 1851 : 				cerr << "warn: Unhandled command type." << endl;

	push	OFFSET ??_C@_0BO@IIOHHIBJ@warn?3?5Unhandled?5command?5type?4?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	mov	BYTE PTR _readSweep$219718[esp+384], 1
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN80@readNextCo@2:

; 1852 : 				break;
; 1853 : 			}
; 1854 : 
; 1855 : 			unsigned currentBankOffset = lastCommand ? lastCommand->getAddress().getBank() : 0;

	mov	eax, DWORD PTR [ebp+24]
	test	eax, eax
	je	SHORT $LN158@readNextCo@2
	mov	ecx, DWORD PTR [eax+64]
	jmp	SHORT $LN159@readNextCo@2
$LN158@readNextCo@2:
	xor	ecx, ecx
$LN159@readNextCo@2:
	mov	DWORD PTR _currentBankOffset$219773[esp+376], ecx

; 1856 : 
; 1857 : 			vector<Rank>::const_iterator currentRank = rank.begin() + (lastCommand ? lastCommand->getAddress().getRank() : 0) + 1;

	test	eax, eax
	je	SHORT $LN160@readNextCo@2
	mov	edi, DWORD PTR [eax+60]
	jmp	SHORT $LN161@readNextCo@2
$LN160@readNextCo@2:
	xor	edi, edi
$LN161@readNextCo@2:
	mov	esi, DWORD PTR [ebp+380]
	lea	ebx, DWORD PTR [ebp+368]
	mov	DWORD PTR tv5223[esp+376], ebx
	cmp	esi, DWORD PTR [ebx+16]
	jbe	SHORT $LN1027@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1027@readNextCo@2:
	mov	ecx, DWORD PTR [ebx]
	lea	edx, DWORD PTR _currentRank$219778[esp+376]
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T606468[esp+384]
	mov	DWORD PTR $T606465[esp+384], ecx
	push	eax
	mov	ecx, edi
	lea	eax, DWORD PTR $T606465[esp+388]
	mov	DWORD PTR $T606465[esp+392], esi
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	add	esp, 4
	mov	ecx, 1
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+

; 1858 : 			if (currentRank == rank.end())

	mov	esi, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], esi
	jbe	SHORT $LN1041@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1041@readNextCo@2:
	mov	ecx, DWORD PTR _currentRank$219778[esp+376]
	mov	eax, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN1052@readNextCo@2
	cmp	ecx, eax
	je	SHORT $LN1053@readNextCo@2
$LN1052@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1053@readNextCo@2:
	mov	ebx, DWORD PTR _currentRank$219778[esp+380]
	cmp	ebx, esi
	jne	SHORT $LN65@readNextCo@2

; 1859 : 			{
; 1860 : 				currentBankOffset = (currentBankOffset + 1) % systemConfig.getBankCount();

	mov	eax, DWORD PTR _currentBankOffset$219773[esp+376]
	mov	ecx, DWORD PTR [ebp+176]
	inc	eax
	xor	edx, edx
	div	DWORD PTR [ecx+364]

; 1861 : 				currentRank = rank.begin();

	mov	edi, DWORD PTR tv5223[esp+376]
	lea	esi, DWORD PTR $T606470[esp+376]
	mov	DWORD PTR _currentBankOffset$219773[esp+376], edx
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	edx, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR _currentRank$219778[esp+376], edx
	mov	DWORD PTR _currentRank$219778[esp+380], ebx
$LN65@readNextCo@2:

; 1862 : 			}
; 1863 : 
; 1864 : 			// set original values to know when a full sweep is finished
; 1865 : 			const vector<Rank>::const_iterator rankEnd = rank.end();

	mov	ecx, DWORD PTR tv5223[esp+376]
	mov	eax, DWORD PTR [ecx+16]
	cmp	DWORD PTR [ecx+12], eax
	jbe	SHORT $LN1065@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1065@readNextCo@2:

; 1866 : 			const unsigned startingBankOffset = currentBankOffset;

	mov	eax, DWORD PTR _currentBankOffset$219773[esp+376]

; 1867 : 			const vector<Rank>::const_iterator startingRank = currentRank;

	mov	ecx, DWORD PTR _currentRank$219778[esp+376]

; 1868 : 			const bool originalReadSweep = readSweep;

	mov	dl, BYTE PTR _readSweep$219718[esp+376]
	mov	DWORD PTR _startingBankOffset$219791[esp+376], eax
	mov	DWORD PTR _startingRank$219796[esp+376], ecx
	mov	DWORD PTR _startingRank$219796[esp+380], ebx
	mov	BYTE PTR _originalReadSweep$219797[esp+376], dl
$LN64@readNextCo@2:

; 1869 : 
; 1870 : 			while (true)
; 1871 : 			{		
; 1872 : 				const Command *potentialCommand = (currentRank->bank.begin() + currentBankOffset)->front();

	mov	eax, DWORD PTR _currentRank$219778[esp+376]
	test	eax, eax
	jne	SHORT $LN1748@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1087@readNextCo@2:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1078@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1078@readNextCo@2:
	mov	ebp, DWORD PTR [ebx+184]
	cmp	ebp, DWORD PTR [ebx+188]
	jbe	SHORT $LN1093@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1093@readNextCo@2:
	mov	esi, DWORD PTR [ebx+172]
	mov	edi, esi
	mov	DWORD PTR __Tmp$609404[esp+380], ebp
	test	esi, esi
	jne	SHORT $LN1747@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1116@readNextCo@2:
	mov	ecx, DWORD PTR _currentBankOffset$219773[esp+376]
	imul	ecx, 152				; 00000098H
	add	ebp, ecx
	cmp	ebp, DWORD PTR [eax+16]
	ja	SHORT $LN1106@readNextCo@2
	test	esi, esi
	je	SHORT $LN1121@readNextCo@2
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN1122@readNextCo@2
$LN1748@readNextCo@2:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1087@readNextCo@2
$LN1747@readNextCo@2:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN1116@readNextCo@2
$LN1121@readNextCo@2:
	xor	esi, esi
$LN1122@readNextCo@2:
	cmp	ebp, DWORD PTR [esi+12]
	jae	SHORT $LN1107@readNextCo@2
$LN1106@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1107@readNextCo@2:
	test	edi, edi
	jne	$LN1746@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1136@readNextCo@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN1127@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1127@readNextCo@2:
	mov	edx, DWORD PTR [ebp+36]
	sub	edx, DWORD PTR [ebp+32]
	mov	esi, DWORD PTR [ebp+12]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN1143@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1143@readNextCo@2:
	mov	eax, DWORD PTR [ebp+32]
	mov	edi, DWORD PTR [eax+esi*4]

; 1873 : 
; 1874 : 				// refresh commands are considered elsewhere
; 1875 : 				if (potentialCommand && !potentialCommand->isRefresh() )

	test	edi, edi
	je	$LN59@readNextCo@2
	mov	eax, DWORD PTR [edi+80]
	cmp	eax, 12					; 0000000cH
	je	$LN59@readNextCo@2

; 1876 : 				{
; 1877 : 					// group reads and writes with each other
; 1878 : 					if (systemConfig.isReadWriteGrouping())

	mov	ecx, DWORD PTR _this$[esp+376]
	mov	edx, DWORD PTR [ecx+176]
	cmp	BYTE PTR [edx+345], 0
	je	$LN58@readNextCo@2

; 1879 : 					{
; 1880 : 						if (potentialCommand->isActivate())
; 1881 : 							assert((currentRank->bank.begin() + currentBankOffset)->read(1));
; 1882 : 
; 1883 : 						const Command *secondCommand = potentialCommand->isActivate() ? (currentRank->bank.begin() + currentBankOffset)->read(1) : potentialCommand;

	test	eax, eax
	je	SHORT $LN1158@readNextCo@2
	cmp	eax, 8
	jne	SHORT $LN162@readNextCo@2
$LN1158@readNextCo@2:
	lea	esi, DWORD PTR _currentRank$219778[esp+376]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	esi, eax
	mov	ebp, DWORD PTR [esi+184]
	add	esi, 172				; 000000acH
	cmp	ebp, DWORD PTR [esi+16]
	jbe	SHORT $LN1163@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1163@readNextCo@2:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T606474[esp+376]
	mov	DWORD PTR $T606473[esp+376], eax
	push	ecx
	mov	ecx, DWORD PTR _currentBankOffset$219773[esp+380]
	lea	eax, DWORD PTR $T606473[esp+380]
	mov	DWORD PTR $T606473[esp+384], ebp
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Bank::read
	jmp	SHORT $LN163@readNextCo@2
$LN1746@readNextCo@2:

; 1869 : 
; 1870 : 			while (true)
; 1871 : 			{		
; 1872 : 				const Command *potentialCommand = (currentRank->bank.begin() + currentBankOffset)->front();

	mov	eax, DWORD PTR [edi]
	jmp	$LN1136@readNextCo@2
$LN162@readNextCo@2:

; 1879 : 					{
; 1880 : 						if (potentialCommand->isActivate())
; 1881 : 							assert((currentRank->bank.begin() + currentBankOffset)->read(1));
; 1882 : 
; 1883 : 						const Command *secondCommand = potentialCommand->isActivate() ? (currentRank->bank.begin() + currentBankOffset)->read(1) : potentialCommand;

	mov	eax, edi
$LN163@readNextCo@2:

; 1884 : 						assert(secondCommand->isReadOrWrite() || secondCommand->isBasicPrecharge());
; 1885 : 
; 1886 : 						if ((secondCommand->isRead() && readSweep) ||
; 1887 : 							(secondCommand->isWrite() && !readSweep) ||
; 1888 : 							secondCommand->isBasicPrecharge())

	mov	eax, DWORD PTR [eax+80]
	cmp	eax, 1
	je	SHORT $LN1176@readNextCo@2
	cmp	eax, 2
	jne	SHORT $LN57@readNextCo@2
$LN1176@readNextCo@2:
	cmp	BYTE PTR _readSweep$219718[esp+376], 0
	jne	$LN58@readNextCo@2
$LN57@readNextCo@2:
	cmp	eax, 3
	je	SHORT $LN1180@readNextCo@2
	cmp	eax, 4
	jne	SHORT $LN56@readNextCo@2
$LN1180@readNextCo@2:
	cmp	BYTE PTR _readSweep$219718[esp+376], 0
	je	$LN58@readNextCo@2
$LN56@readNextCo@2:
	cmp	eax, 6
	je	$LN58@readNextCo@2
$LN59@readNextCo@2:

; 1892 : 						}
; 1893 : 					}
; 1894 : 					else // don't have to follow read_write grouping considerations
; 1895 : 					{
; 1896 : 						return potentialCommand;
; 1897 : 					}
; 1898 : 				}
; 1899 : 
; 1900 : 				// before switching to the next rank, see if all the queues are refreshes in any rank
; 1901 : 				if (currentRank->refreshAllReady())

	mov	eax, DWORD PTR _currentRank$219778[esp+376]
	test	eax, eax
	jne	$LN1745@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1195@readNextCo@2:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1186@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1186@readNextCo@2:
	push	ebx
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	jne	$LN1727@readNextCo@2

; 1904 : 				}
; 1905 : 
; 1906 : 				// move on to the next rank
; 1907 : 				currentRank++;

	mov	ebp, DWORD PTR _currentRank$219778[esp+376]
	test	ebp, ebp
	jne	$LN1744@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1209@readNextCo@2:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN1200@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1200@readNextCo@2:

; 1908 : 
; 1909 : 				if (currentRank == rank.end())

	mov	edi, DWORD PTR tv5223[esp+376]
	mov	esi, DWORD PTR [edi+16]
	add	ebx, 200				; 000000c8H
	mov	DWORD PTR _currentRank$219778[esp+380], ebx
	cmp	DWORD PTR [edi+12], esi
	jbe	SHORT $LN1215@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1215@readNextCo@2:
	mov	eax, DWORD PTR [edi]
	test	ebp, ebp
	je	SHORT $LN1226@readNextCo@2
	cmp	ebp, eax
	je	SHORT $LN1227@readNextCo@2
$LN1226@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1227@readNextCo@2:
	cmp	ebx, esi
	jne	SHORT $LN53@readNextCo@2

; 1910 : 				{
; 1911 : 					currentRank = rank.begin();

	mov	esi, DWORD PTR [edi+12]
	cmp	esi, DWORD PTR [edi+16]
	jbe	SHORT $LN1237@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1237@readNextCo@2:
	mov	edx, DWORD PTR [edi]

; 1912 : 
; 1913 : 					// select the next bank
; 1914 : 					currentBankOffset = (currentBankOffset + 1) % systemConfig.getBankCount();

	mov	eax, DWORD PTR _currentBankOffset$219773[esp+376]
	mov	ecx, DWORD PTR _this$[esp+376]
	mov	ecx, DWORD PTR [ecx+176]
	mov	DWORD PTR _currentRank$219778[esp+376], edx
	inc	eax
	xor	edx, edx
	div	DWORD PTR [ecx+364]
	mov	ebx, esi
	mov	DWORD PTR _currentRank$219778[esp+380], ebx
	mov	DWORD PTR _currentBankOffset$219773[esp+376], edx
$LN53@readNextCo@2:

; 1915 : 				}
; 1916 : 
; 1917 : 				// swap R/W for W/R when doing read/write grouping
; 1918 : 				if (currentBankOffset == startingBankOffset && currentRank == startingRank)

	mov	edx, DWORD PTR _currentBankOffset$219773[esp+376]
	cmp	edx, DWORD PTR _startingBankOffset$219791[esp+376]
	jne	$LN64@readNextCo@2
	mov	eax, DWORD PTR _currentRank$219778[esp+376]
	test	eax, eax
	je	SHORT $LN1250@readNextCo@2
	cmp	eax, DWORD PTR _startingRank$219796[esp+376]
	je	SHORT $LN1251@readNextCo@2
$LN1250@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1251@readNextCo@2:
	cmp	ebx, DWORD PTR _startingRank$219796[esp+380]
	jne	$LN64@readNextCo@2

; 1919 : 				{				
; 1920 : 					if (systemConfig.isReadWriteGrouping())

	mov	eax, DWORD PTR _this$[esp+376]
	mov	ecx, DWORD PTR [eax+176]
	cmp	BYTE PTR [ecx+345], 0
	je	SHORT $LN1728@readNextCo@2

; 1921 : 					{
; 1922 : 						// try other types
; 1923 : 						readSweep = !readSweep;

	cmp	BYTE PTR _readSweep$219718[esp+376], 0
	sete	al
	mov	BYTE PTR _readSweep$219718[esp+376], al

; 1924 : 
; 1925 : 						if (readSweep == originalReadSweep)

	cmp	al, BYTE PTR _originalReadSweep$219797[esp+376]
	jne	$LN64@readNextCo@2
$LN1728@readNextCo@2:

; 1926 : 						{
; 1927 : #ifndef NDEBUG
; 1928 : 							for (vector<Rank>::const_iterator i = rank.begin(); i != rankEnd; i++)
; 1929 : 							{
; 1930 : 								for (vector<Bank>::const_iterator j = i->bank.begin(); j != i->bank.end(); j++)
; 1931 : 								{
; 1932 : 									assert(j->isEmpty());
; 1933 : 								}
; 1934 : 							}
; 1935 : #endif
; 1936 : 							return NULL;

	xor	eax, eax

; 2182 : 		}
; 2183 : 		break;
; 2184 : 	}
; 2185 : 	return NULL;
; 2186 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1745@readNextCo@2:

; 1892 : 						}
; 1893 : 					}
; 1894 : 					else // don't have to follow read_write grouping considerations
; 1895 : 					{
; 1896 : 						return potentialCommand;
; 1897 : 					}
; 1898 : 				}
; 1899 : 
; 1900 : 				// before switching to the next rank, see if all the queues are refreshes in any rank
; 1901 : 				if (currentRank->refreshAllReady())

	mov	eax, DWORD PTR [eax]
	jmp	$LN1195@readNextCo@2
$LN1744@readNextCo@2:

; 1904 : 				}
; 1905 : 
; 1906 : 				// move on to the next rank
; 1907 : 				currentRank++;

	mov	eax, DWORD PTR [ebp]
	jmp	$LN1209@readNextCo@2
$LN58@readNextCo@2:

; 1889 : 						{
; 1890 : 							assert((currentRank->bank.begin() + currentBankOffset)->front() == potentialCommand);
; 1891 : 							return potentialCommand;

	mov	eax, edi

; 2182 : 		}
; 2183 : 		break;
; 2184 : 	}
; 2185 : 	return NULL;
; 2186 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1727@readNextCo@2:

; 1902 : 				{
; 1903 : 					return currentRank->bank.begin()->front();

	lea	esi, DWORD PTR _currentRank$219778[esp+376]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	lea	esi, DWORD PTR $T606477[esp+376]
$LN1842@readNextCo@2:
	mov	edi, eax
	add	edi, 172				; 000000acH
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front

; 2182 : 		}
; 2183 : 		break;
; 2184 : 	}
; 2185 : 	return NULL;
; 2186 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@readNextCo@2:

; 1937 : 						}						
; 1938 : 					}
; 1939 : 					else
; 1940 : 					{
; 1941 : 						return NULL;
; 1942 : 					}
; 1943 : 				}
; 1944 : 			}
; 1945 : 		}
; 1946 : 		break;
; 1947 : 
; 1948 : 		// keep rank id as long as possible, go round robin down a given rank
; 1949 : 	case BANK_ROUND_ROBIN:
; 1950 : 		{			
; 1951 : 			bool readSweep = true;
; 1952 : 
; 1953 : 			// look at the most recently retired command in this channel's history
; 1954 : 			const Command::CommandType lastCommandType = lastCommand ? (lastCommand->getCommandType()) : Command::READ;

	mov	eax, DWORD PTR [ebp+24]
	test	eax, eax
	je	SHORT $LN164@readNextCo@2
	mov	ecx, DWORD PTR [eax+80]

; 1955 : 
; 1956 : 			// attempt to issue RAS and CAS together
; 1957 : 			switch (lastCommandType)

	cmp	ecx, 12					; 0000000cH
	ja	$LN32@readNextCo@2
$LN1785@readNextCo@2:
	movzx	edx, BYTE PTR $LN1802@readNextCo@2[ecx]
	jmp	DWORD PTR $LN1845@readNextCo@2[edx*4]
$LN164@readNextCo@2:

; 1937 : 						}						
; 1938 : 					}
; 1939 : 					else
; 1940 : 					{
; 1941 : 						return NULL;
; 1942 : 					}
; 1943 : 				}
; 1944 : 			}
; 1945 : 		}
; 1946 : 		break;
; 1947 : 
; 1948 : 		// keep rank id as long as possible, go round robin down a given rank
; 1949 : 	case BANK_ROUND_ROBIN:
; 1950 : 		{			
; 1951 : 			bool readSweep = true;
; 1952 : 
; 1953 : 			// look at the most recently retired command in this channel's history
; 1954 : 			const Command::CommandType lastCommandType = lastCommand ? (lastCommand->getCommandType()) : Command::READ;

	mov	ecx, 1

; 1955 : 
; 1956 : 			// attempt to issue RAS and CAS together
; 1957 : 			switch (lastCommandType)

	jmp	SHORT $LN1785@readNextCo@2
$LN45@readNextCo@2:

; 1958 : 			{
; 1959 : 			case Command::ACTIVATE:
; 1960 : 				{
; 1961 : 					// look at the command just after the RAS, it should be some sort of CAS
; 1962 : 
; 1963 : 					const Command *nextCommand = ((rank.begin() + lastCommand->getAddress().getRank())->bank.begin() + lastCommand->getAddress().getBank())->front();

	mov	ecx, ebp
	mov	eax, DWORD PTR [ecx+24]
	mov	ebx, DWORD PTR [eax+64]
	mov	ebp, DWORD PTR [eax+60]
	lea	eax, DWORD PTR $T606486[esp+376]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T606484[esp+384]
	push	edx
	lea	edi, DWORD PTR [ecx+368]
	lea	esi, DWORD PTR $T606483[esp+388]
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	ecx, ebp
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	add	esp, 4
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 172				; 000000acH
	lea	esi, DWORD PTR $T606485[esp+380]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	ecx, ebx
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	esi, eax

; 1964 : 
; 1965 : 					if (nextCommand && nextCommand->isReadOrWrite())

	test	esi, esi
	je	SHORT $LN44@readNextCo@2
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al

; 1966 : 					{
; 1967 : 						return nextCommand;

	jne	$LN73@readNextCo@2
$LN44@readNextCo@2:

; 1968 : 					}
; 1969 : 					else
; 1970 : 					{
; 1971 : 						cerr << "error: row activate command not followed by a column command." << endl;

	push	OFFSET ??_C@_0DO@LMCLJHD@error?3?5row?5activate?5command?5not?5@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 1972 : 						exit(2);

	push	2
	call	_exit
$LN1847@readNextCo@2:
$LN42@readNextCo@2:

; 1973 : 					}
; 1974 : 				}
; 1975 : 				break;
; 1976 : 				// doing read sweeping
; 1977 : 			case Command::READ:
; 1978 : 				// try to reuse open rows
; 1979 : 				if (lastCommand)

	test	eax, eax
	je	$LN40@readNextCo@2

; 1980 : 				{
; 1981 : 					const Command *nextCommand = ((rank.begin() + lastCommand->getAddress().getRank())->bank.begin() + lastCommand->getAddress().getBank())->front();

	mov	ecx, ebp
	mov	eax, DWORD PTR [ecx+24]
	mov	ebx, DWORD PTR [eax+64]
	mov	ebp, DWORD PTR [eax+60]
	lea	eax, DWORD PTR $T606490[esp+376]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T606488[esp+384]
	push	edx
	lea	edi, DWORD PTR [ecx+368]
	lea	esi, DWORD PTR $T606487[esp+388]
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	ecx, ebp
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	add	esp, 4
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 172				; 000000acH
	lea	esi, DWORD PTR $T606489[esp+380]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	ecx, ebx
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	esi, eax

; 1982 : 
; 1983 : 					if (nextCommand && (nextCommand->isReadOrWrite() || nextCommand->isBasicPrecharge()))

	test	esi, esi
	je	SHORT $LN40@readNextCo@2
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al
	jne	$LN73@readNextCo@2
	cmp	DWORD PTR [esi+80], 6

; 1984 : 					{
; 1985 : 						return nextCommand;

	je	$LN73@readNextCo@2
$LN40@readNextCo@2:

; 1986 : 					}
; 1987 : 					assert(!nextCommand || !nextCommand->isBasicPrecharge());
; 1988 : 				}			
; 1989 : 			case Command::REFRESH_ALL:
; 1990 : 			case Command::READ_AND_PRECHARGE:
; 1991 : 			case Command::PRECHARGE:
; 1992 : 				readSweep = true;

	mov	BYTE PTR _readSweep$219829[esp+376], 1

; 1993 : 				break;

	jmp	$LN46@readNextCo@2
$LN37@readNextCo@2:

; 1994 : 
; 1995 : 				// doing write sweeping
; 1996 : 			case Command::WRITE:
; 1997 : 				// try to reuse open rows
; 1998 : 				if (lastCommand)

	test	eax, eax
	je	$LN35@readNextCo@2

; 1999 : 				{
; 2000 : 					const Command *nextCommand = ((rank.begin() + lastCommand->getAddress().getRank())->bank.begin() + lastCommand->getAddress().getBank())->front();

	mov	ecx, ebp
	mov	eax, DWORD PTR [ecx+24]
	mov	ebx, DWORD PTR [eax+64]
	mov	ebp, DWORD PTR [eax+60]
	lea	eax, DWORD PTR $T606494[esp+376]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T606492[esp+384]
	push	edx
	lea	edi, DWORD PTR [ecx+368]
	lea	esi, DWORD PTR $T606491[esp+388]
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	ecx, ebp
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	add	esp, 4
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 172				; 000000acH
	lea	esi, DWORD PTR $T606493[esp+380]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	ecx, ebx
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	mov	esi, eax
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?front@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::front
	mov	esi, eax

; 2001 : 
; 2002 : 					if (nextCommand && (nextCommand->isReadOrWrite() || nextCommand->isBasicPrecharge()))

	test	esi, esi
	je	SHORT $LN35@readNextCo@2
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al
	jne	$LN73@readNextCo@2
	cmp	DWORD PTR [esi+80], 6

; 2003 : 					{
; 2004 : 						return nextCommand;

	je	$LN73@readNextCo@2
$LN35@readNextCo@2:

; 2005 : 					}
; 2006 : 					assert(!nextCommand || !nextCommand->isBasicPrecharge());
; 2007 : 				}			
; 2008 : 			case Command::WRITE_AND_PRECHARGE:
; 2009 : 				readSweep = false;

	mov	BYTE PTR _readSweep$219829[esp+376], 0

; 2010 : 				break;

	jmp	SHORT $LN46@readNextCo@2
$LN32@readNextCo@2:

; 2011 : 
; 2012 : 			default:
; 2013 : 				readSweep = true; // FIXME: added this to ensure no uninit vars
; 2014 : 				cerr << "warn: unhandled command type" << endl;

	push	OFFSET ??_C@_0BN@DBBBPOIP@warn?3?5unhandled?5command?5type?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	mov	BYTE PTR _readSweep$219829[esp+384], 1
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN46@readNextCo@2:

; 2015 : 				break;
; 2016 : 			}
; 2017 : 
; 2018 : 			vector<Rank>::const_iterator currentRank = rank.begin() + (lastCommand ? lastCommand->getAddress().getRank() : 0);

	mov	ebx, DWORD PTR _this$[esp+376]
	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN166@readNextCo@2
	mov	edi, DWORD PTR [eax+60]
	jmp	SHORT $LN167@readNextCo@2
$LN166@readNextCo@2:
	xor	edi, edi
$LN167@readNextCo@2:
	mov	esi, DWORD PTR [ebx+380]
	cmp	esi, DWORD PTR [ebx+384]
	jbe	SHORT $LN1301@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1301@readNextCo@2:
	mov	eax, DWORD PTR [ebx+368]
	lea	ecx, DWORD PTR _currentRank$219888[esp+376]
	mov	DWORD PTR $T606495[esp+376], eax
	push	ecx
	mov	ecx, edi
	lea	eax, DWORD PTR $T606495[esp+380]
	mov	DWORD PTR $T606495[esp+384], esi
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+

; 2019 : 			vector<Bank>::const_iterator currentBank = currentRank->bank.begin() + (lastCommand ? lastCommand->getAddress().getBank() : 0) + 1;

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN168@readNextCo@2
	mov	ebp, DWORD PTR [eax+64]
	jmp	SHORT $LN169@readNextCo@2
$LN168@readNextCo@2:
	xor	ebp, ebp
$LN169@readNextCo@2:
	lea	esi, DWORD PTR _currentRank$219888[esp+376]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	esi, eax
	mov	edi, DWORD PTR [esi+184]
	add	esi, 172				; 000000acH
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN1319@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1319@readNextCo@2:
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _currentBank$219895[esp+376]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T606501[esp+384]
	push	ecx
	mov	ecx, ebp
	lea	eax, DWORD PTR $T606498[esp+388]
	mov	DWORD PTR $T606498[esp+388], edx
	mov	DWORD PTR $T606498[esp+392], edi
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+
	add	esp, 4
	mov	ecx, 1
	call	??H?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator+

; 2020 : 			if (currentBank == currentRank->bank.end())

	lea	esi, DWORD PTR _currentRank$219888[esp+376]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	esi, eax
	mov	edi, DWORD PTR [esi+188]
	add	esi, 172				; 000000acH
	cmp	DWORD PTR [esi+12], edi
	jbe	SHORT $LN1333@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1333@readNextCo@2:
	mov	ebx, DWORD PTR _currentBank$219895[esp+376]
	mov	esi, DWORD PTR [esi]
	test	ebx, ebx
	je	SHORT $LN1344@readNextCo@2
	cmp	ebx, esi
	je	SHORT $LN1345@readNextCo@2
$LN1344@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1345@readNextCo@2:
	mov	ebp, DWORD PTR _currentBank$219895[esp+380]
	cmp	ebp, edi
	jne	SHORT $LN31@readNextCo@2

; 2021 : 			{
; 2022 : 				currentRank++;

	lea	edi, DWORD PTR $T606503[esp+376]
	lea	esi, DWORD PTR _currentRank$219888[esp+376]
	call	??E?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator++

; 2023 : 				if (currentRank == rank.end())

	mov	ebx, DWORD PTR _this$[esp+376]
	add	ebx, 368				; 00000170H
	lea	esi, DWORD PTR $T606504[esp+376]
	mov	edi, ebx
	call	?end@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::end
	mov	esi, eax
	lea	edi, DWORD PTR _currentRank$219888[esp+376]
	call	??8?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator==
	test	al, al
	je	SHORT $LN30@readNextCo@2

; 2024 : 					currentRank = rank.begin();

	lea	esi, DWORD PTR $T606505[esp+376]
	mov	edi, ebx
	call	?begin@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::begin
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _currentRank$219888[esp+376], edx
	mov	DWORD PTR _currentRank$219888[esp+380], eax
$LN30@readNextCo@2:

; 2025 : 				currentBank = currentRank->bank.begin();

	lea	esi, DWORD PTR _currentRank$219888[esp+376]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 172				; 000000acH
	lea	esi, DWORD PTR $T606506[esp+376]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	ebx, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR _currentBank$219895[esp+376], ebx
	mov	DWORD PTR _currentBank$219895[esp+380], ebp
$LN31@readNextCo@2:

; 2026 : 			}
; 2027 : 
; 2028 : 			// set original values to know when a full sweep is finished
; 2029 : 			const vector<Rank>::const_iterator rankEnd = rank.end();

	mov	esi, DWORD PTR _this$[esp+376]
	mov	eax, DWORD PTR [esi+384]
	add	esi, 368				; 00000170H
	mov	DWORD PTR $T610063[esp+376], eax
	cmp	DWORD PTR [esi+12], eax
	jbe	SHORT $LN1355@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1355@readNextCo@2:
	mov	ecx, DWORD PTR [esi]

; 2030 : 			const vector<Bank>::const_iterator startingBank = currentBank;
; 2031 : 			const vector<Rank>::const_iterator startingRank = currentRank;

	mov	edx, DWORD PTR _currentRank$219888[esp+376]
	mov	eax, DWORD PTR _currentRank$219888[esp+380]
	mov	DWORD PTR _rankEnd$219910[esp+376], ecx

; 2032 : 			const bool originalReadSweep = readSweep;

	mov	cl, BYTE PTR _readSweep$219829[esp+376]
	mov	DWORD PTR _startingBank$219916[esp+376], ebx
	mov	DWORD PTR _startingBank$219916[esp+380], ebp
	mov	DWORD PTR _startingRank$219921[esp+376], edx
	mov	DWORD PTR _startingRank$219921[esp+380], eax
	mov	BYTE PTR _originalReadSweep$219922[esp+376], cl
$LL29@readNextCo@2:

; 2033 : 
; 2034 : 			while (true)
; 2035 : 			{
; 2036 : 				const Command *potentialCommand = currentBank->front();

	test	ebx, ebx
	jne	$LN1743@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1377@readNextCo@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN1368@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1368@readNextCo@2:
	mov	edx, DWORD PTR [ebp+36]
	sub	edx, DWORD PTR [ebp+32]
	mov	esi, DWORD PTR [ebp+12]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN1384@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1384@readNextCo@2:
	mov	eax, DWORD PTR [ebp+32]
	mov	edi, DWORD PTR [eax+esi*4]

; 2037 : 
; 2038 : 				// see if this command could be used
; 2039 : 				if (potentialCommand && !potentialCommand->isRefresh())

	test	edi, edi
	je	$LN24@readNextCo@2
	mov	eax, DWORD PTR [edi+80]
	cmp	eax, 12					; 0000000cH
	je	$LN24@readNextCo@2

; 2040 : 				{	
; 2041 : 					if (systemConfig.isReadWriteGrouping())

	mov	ecx, DWORD PTR _this$[esp+376]
	mov	edx, DWORD PTR [ecx+176]
	cmp	BYTE PTR [edx+345], 0
	je	$LN58@readNextCo@2

; 2042 : 					{
; 2043 : 						if (potentialCommand->isActivate())
; 2044 : 							assert(currentBank->read(1));
; 2045 : 
; 2046 : 						const Command *secondCommand = (potentialCommand->isActivate() && currentBank->read(1)) ? currentBank->read(1) : potentialCommand;

	test	eax, eax
	je	SHORT $LN1399@readNextCo@2
	cmp	eax, 8
	jne	SHORT $LN170@readNextCo@2
$LN1399@readNextCo@2:
	lea	esi, DWORD PTR _currentBank$219895[esp+376]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Bank::read
	test	eax, eax
	je	SHORT $LN170@readNextCo@2
	lea	esi, DWORD PTR _currentBank$219895[esp+376]
	call	??C?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPBVBank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?read@Bank@DRAMsimII@@QBEPBVCommand@2@I@Z ; DRAMsimII::Bank::read
	jmp	SHORT $LN171@readNextCo@2
$LN1743@readNextCo@2:

; 2033 : 
; 2034 : 			while (true)
; 2035 : 			{
; 2036 : 				const Command *potentialCommand = currentBank->front();

	mov	eax, DWORD PTR [ebx]
	jmp	$LN1377@readNextCo@2
$LN170@readNextCo@2:

; 2042 : 					{
; 2043 : 						if (potentialCommand->isActivate())
; 2044 : 							assert(currentBank->read(1));
; 2045 : 
; 2046 : 						const Command *secondCommand = (potentialCommand->isActivate() && currentBank->read(1)) ? currentBank->read(1) : potentialCommand;

	mov	eax, edi
$LN171@readNextCo@2:

; 2047 : 						assert(secondCommand->isReadOrWrite() || secondCommand->isBasicPrecharge());
; 2048 : 
; 2049 : 						if ((secondCommand->isRead() && readSweep) ||
; 2050 : 							(secondCommand->isWrite() && !readSweep) || 
; 2051 : 							secondCommand->isBasicPrecharge())

	mov	eax, DWORD PTR [eax+80]
	cmp	eax, 1
	je	SHORT $LN1403@readNextCo@2
	cmp	eax, 2
	jne	SHORT $LN22@readNextCo@2
$LN1403@readNextCo@2:
	cmp	BYTE PTR _readSweep$219829[esp+376], 0
	jne	$LN58@readNextCo@2
$LN22@readNextCo@2:
	cmp	eax, 3
	je	SHORT $LN1407@readNextCo@2
	cmp	eax, 4
	jne	SHORT $LN21@readNextCo@2
$LN1407@readNextCo@2:
	cmp	BYTE PTR _readSweep$219829[esp+376], 0
	je	$LN58@readNextCo@2
$LN21@readNextCo@2:
	cmp	eax, 6
	je	$LN58@readNextCo@2
$LN24@readNextCo@2:

; 2052 : 						{
; 2053 : 							assert(currentBank->front()->getAddress().getRank() == currentRank->getRankID());
; 2054 : 							assert(currentBank->front() == potentialCommand);
; 2055 : 							return potentialCommand;
; 2056 : 						}
; 2057 : 					}
; 2058 : 					else // don't have to follow read_write grouping considerations
; 2059 : 					{
; 2060 : 						return potentialCommand;
; 2061 : 					}
; 2062 : 				}
; 2063 : 
; 2064 : 				// then switch to the next bank
; 2065 : 				currentBank++;

	test	ebx, ebx
	jne	$LN1742@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1422@readNextCo@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN1413@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1413@readNextCo@2:

; 2066 : 				if (currentBank == currentRank->bank.end())

	mov	eax, DWORD PTR _currentRank$219888[esp+376]
	add	ebp, 152				; 00000098H
	mov	DWORD PTR _currentBank$219895[esp+380], ebp
	test	eax, eax
	jne	$LN1741@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1436@readNextCo@2:
	mov	ecx, DWORD PTR _currentRank$219888[esp+380]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN1427@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1427@readNextCo@2:
	mov	eax, DWORD PTR _currentRank$219888[esp+380]
	mov	esi, DWORD PTR [eax+188]
	cmp	DWORD PTR [eax+184], esi
	jbe	SHORT $LN1442@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1442@readNextCo@2:
	mov	edx, DWORD PTR _currentRank$219888[esp+380]
	mov	eax, DWORD PTR [edx+172]
	test	ebx, ebx
	je	SHORT $LN1453@readNextCo@2
	cmp	ebx, eax
	je	SHORT $LN1454@readNextCo@2
$LN1453@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1454@readNextCo@2:
	cmp	ebp, esi
	jne	$LN19@readNextCo@2

; 2067 : 				{
; 2068 : 					// before switching to the next rank, see if all the queues are refreshes in any rank
; 2069 : 					if (currentRank->refreshAllReady())

	mov	eax, DWORD PTR _currentRank$219888[esp+376]
	test	eax, eax
	jne	$LN1740@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1472@readNextCo@2:
	mov	ecx, DWORD PTR _currentRank$219888[esp+380]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN1463@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1463@readNextCo@2:
	mov	edi, DWORD PTR _currentRank$219888[esp+380]
	push	edi
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	jne	$LN1729@readNextCo@2

; 2072 : 					}
; 2073 : 
; 2074 : 					currentRank++;

	mov	ebx, DWORD PTR _currentRank$219888[esp+376]
	test	ebx, ebx
	jne	$LN1739@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1486@readNextCo@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN1477@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1477@readNextCo@2:
	add	edi, 200				; 000000c8H
	mov	DWORD PTR _currentRank$219888[esp+380], edi

; 2075 : 					if (currentRank == rankEnd)

	test	ebx, ebx
	je	SHORT $LN1489@readNextCo@2
	cmp	ebx, DWORD PTR _rankEnd$219910[esp+376]
	je	SHORT $LN1490@readNextCo@2
$LN1489@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1490@readNextCo@2:
	cmp	edi, DWORD PTR $T610063[esp+376]
	jne	SHORT $LN17@readNextCo@2

; 2076 : 						currentRank = rank.begin();

	mov	edi, DWORD PTR _this$[esp+376]
	mov	esi, DWORD PTR [edi+380]
	add	edi, 368				; 00000170H
	cmp	esi, DWORD PTR [edi+16]
	jbe	SHORT $LN1500@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1500@readNextCo@2:
	mov	ebx, DWORD PTR [edi]
	mov	edi, esi
	mov	DWORD PTR _currentRank$219888[esp+376], ebx
	mov	DWORD PTR _currentRank$219888[esp+380], edi
$LN17@readNextCo@2:

; 2077 : 					currentBank = currentRank->bank.begin();		

	test	ebx, ebx
	jne	$LN1738@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1522@readNextCo@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN1513@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1513@readNextCo@2:
	mov	esi, DWORD PTR [edi+184]
	cmp	esi, DWORD PTR [edi+188]
	jbe	SHORT $LN1528@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1528@readNextCo@2:
	mov	ebx, DWORD PTR [edi+172]
	mov	ebp, esi
	mov	DWORD PTR _currentBank$219895[esp+376], ebx
	mov	DWORD PTR _currentBank$219895[esp+380], ebp
$LN19@readNextCo@2:

; 2078 : 				}
; 2079 : 
; 2080 : 				// back to the beginning, either no result or look for the opposite type
; 2081 : 				// n.b. must compare rank iterators first, otherwise comparing bank iterators based on unequal rank iterators is a runtime error
; 2082 : 				if (currentRank == startingRank && currentBank == startingBank)

	mov	eax, DWORD PTR _currentRank$219888[esp+376]
	test	eax, eax
	je	SHORT $LN1539@readNextCo@2
	cmp	eax, DWORD PTR _startingRank$219921[esp+376]
	je	SHORT $LN1540@readNextCo@2
$LN1539@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1540@readNextCo@2:
	mov	edx, DWORD PTR _currentRank$219888[esp+380]
	cmp	edx, DWORD PTR _startingRank$219921[esp+380]
	jne	$LL29@readNextCo@2
	test	ebx, ebx
	je	SHORT $LN1547@readNextCo@2
	cmp	ebx, DWORD PTR _startingBank$219916[esp+376]
	je	SHORT $LN1548@readNextCo@2
$LN1547@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1548@readNextCo@2:
	cmp	ebp, DWORD PTR _startingBank$219916[esp+380]
	jne	$LL29@readNextCo@2

; 2083 : 				{						
; 2084 : 					if (systemConfig.isReadWriteGrouping())

	mov	eax, DWORD PTR _this$[esp+376]
	mov	ecx, DWORD PTR [eax+176]
	cmp	BYTE PTR [ecx+345], 0
	je	$LN1728@readNextCo@2

; 2085 : 					{
; 2086 : 						// try other types
; 2087 : 						readSweep = !readSweep;

	cmp	BYTE PTR _readSweep$219829[esp+376], 0
	sete	al
	mov	BYTE PTR _readSweep$219829[esp+376], al

; 2088 : 
; 2089 : 						if (readSweep == originalReadSweep)

	cmp	al, BYTE PTR _originalReadSweep$219922[esp+376]
	jne	$LL29@readNextCo@2

; 1926 : 						{
; 1927 : #ifndef NDEBUG
; 1928 : 							for (vector<Rank>::const_iterator i = rank.begin(); i != rankEnd; i++)
; 1929 : 							{
; 1930 : 								for (vector<Bank>::const_iterator j = i->bank.begin(); j != i->bank.end(); j++)
; 1931 : 								{
; 1932 : 									assert(j->isEmpty());
; 1933 : 								}
; 1934 : 							}
; 1935 : #endif
; 1936 : 							return NULL;

	xor	eax, eax

; 2182 : 		}
; 2183 : 		break;
; 2184 : 	}
; 2185 : 	return NULL;
; 2186 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1742@readNextCo@2:

; 2052 : 						{
; 2053 : 							assert(currentBank->front()->getAddress().getRank() == currentRank->getRankID());
; 2054 : 							assert(currentBank->front() == potentialCommand);
; 2055 : 							return potentialCommand;
; 2056 : 						}
; 2057 : 					}
; 2058 : 					else // don't have to follow read_write grouping considerations
; 2059 : 					{
; 2060 : 						return potentialCommand;
; 2061 : 					}
; 2062 : 				}
; 2063 : 
; 2064 : 				// then switch to the next bank
; 2065 : 				currentBank++;

	mov	eax, DWORD PTR [ebx]
	jmp	$LN1422@readNextCo@2
$LN1741@readNextCo@2:

; 2066 : 				if (currentBank == currentRank->bank.end())

	mov	eax, DWORD PTR [eax]
	jmp	$LN1436@readNextCo@2
$LN1740@readNextCo@2:

; 2067 : 				{
; 2068 : 					// before switching to the next rank, see if all the queues are refreshes in any rank
; 2069 : 					if (currentRank->refreshAllReady())

	mov	eax, DWORD PTR [eax]
	jmp	$LN1472@readNextCo@2
$LN1739@readNextCo@2:

; 2072 : 					}
; 2073 : 
; 2074 : 					currentRank++;

	mov	eax, DWORD PTR [ebx]
	jmp	$LN1486@readNextCo@2
$LN1738@readNextCo@2:

; 2077 : 					currentBank = currentRank->bank.begin();		

	mov	eax, DWORD PTR [ebx]
	jmp	$LN1522@readNextCo@2
$LN1729@readNextCo@2:

; 2070 : 					{
; 2071 : 						return currentRank->bank.begin()->front();

	lea	esi, DWORD PTR _currentRank$219888[esp+376]
	call	??C?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPBVRank@DRAMsimII@@XZ ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	lea	esi, DWORD PTR $T606511[esp+376]
	jmp	$LN1842@readNextCo@2
$LN12@readNextCo@2:

; 2090 : 						{
; 2091 : #ifndef NDEBUG
; 2092 : 							for (vector<Rank>::const_iterator i = rank.begin(); i != rankEnd; i++)
; 2093 : 							{
; 2094 : 								for (vector<Bank>::const_iterator j = i->bank.begin(); j != i->bank.end(); j++)
; 2095 : 								{
; 2096 : 									assert(j->isEmpty());
; 2097 : 								}
; 2098 : 							}
; 2099 : #endif
; 2100 : 							return NULL;
; 2101 : 						}	
; 2102 : 					}					
; 2103 : 					else
; 2104 : 					{
; 2105 : 
; 2106 : 						return NULL;
; 2107 : 					}
; 2108 : 				}			
; 2109 : 			}
; 2110 : 		}
; 2111 : 		break;
; 2112 : 
; 2113 : 	case COMMAND_PAIR_RANK_HOPPING:
; 2114 : 		{	
; 2115 : 			// determine
; 2116 : 			bool isActivate;
; 2117 : 			unsigned nextRank, nextBank;
; 2118 : 
; 2119 : 			if (lastCommand)

	mov	eax, DWORD PTR [ebp+24]
	test	eax, eax
	je	SHORT $LN11@readNextCo@2

; 2120 : 			{
; 2121 : 				isActivate = lastCommand->isActivate();

	call	?isActivate@Command@DRAMsimII@@QBE_NXZ	; DRAMsimII::Command::isActivate
	mov	bl, al

; 2122 : 				nextRank = lastCommand->getAddress().getRank();

	mov	eax, DWORD PTR [ebp+24]
	mov	edx, DWORD PTR [eax+60]

; 2123 : 				nextBank = lastCommand->getAddress().getBank();

	mov	eax, DWORD PTR [eax+64]
	mov	BYTE PTR _isActivate$219954[esp+376], bl

; 2124 : 				getNextCPRHValues(nextRank, nextBank, isActivate);

	mov	ecx, DWORD PTR _isActivate$219954[esp+376]
	mov	DWORD PTR _nextRank$219955[esp+376], edx
	push	ecx
	mov	DWORD PTR _nextBank$219956[esp+380], eax
	lea	edx, DWORD PTR _nextBank$219956[esp+380]
	push	edx
	lea	eax, DWORD PTR _nextRank$219955[esp+384]
	push	eax
	mov	eax, ebp
	call	?getNextCPRHValues@Channel@DRAMsimII@@IBEXAAI0_N@Z ; DRAMsimII::Channel::getNextCPRHValues

; 2125 : 				assert(nextRank < systemConfig.getRankCount());
; 2126 : 				assert(nextBank < systemConfig.getBankCount());
; 2127 : 				isActivate = !isActivate;

	test	bl, bl

; 2128 : 			}
; 2129 : 			else // special case, must reset to the first value in the pattern

	mov	ebx, DWORD PTR _nextBank$219956[esp+376]
	sete	BYTE PTR _isActivate$219954[esp+376]
	jmp	SHORT $LN10@readNextCo@2
$LN11@readNextCo@2:

; 2130 : 			{
; 2131 : 				isActivate = true;
; 2132 : 				nextRank = 0;
; 2133 : 				nextBank = systemConfig.getBankCount() / 2;

	mov	ebx, DWORD PTR [ecx+364]
	shr	ebx, 1
	mov	BYTE PTR _isActivate$219954[esp+376], 1
	mov	DWORD PTR _nextRank$219955[esp+376], 0
	mov	DWORD PTR _nextBank$219956[esp+376], ebx
$LN10@readNextCo@2:

; 2134 : 			}
; 2135 : 
; 2136 : 			const unsigned originalRank = nextRank;

	mov	ecx, DWORD PTR _nextRank$219955[esp+376]

; 2137 : 			const unsigned originalBank = nextBank;
; 2138 : 			const bool originalActivate = isActivate;

	mov	dl, BYTE PTR _isActivate$219954[esp+376]
	mov	DWORD PTR _originalRank$219961[esp+376], ecx
	mov	DWORD PTR _originalBank$219962[esp+376], ebx
	mov	BYTE PTR _originalActivate$219963[esp+376], dl
	npad	4
$LL9@readNextCo@2:

; 2139 : 
; 2140 : 			while (true)
; 2141 : 			{
; 2142 : 				const Command *potentialCommand = 						
; 2143 : 					((rank.begin() + nextRank)->bank.begin() + nextBank)->front();

	mov	esi, DWORD PTR _this$[esp+376]
	mov	edi, DWORD PTR [esi+380]
	cmp	edi, DWORD PTR [esi+384]
	jbe	SHORT $LN1570@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1570@readNextCo@2:
	mov	esi, DWORD PTR [esi+368]
	mov	ebp, esi
	mov	DWORD PTR __Tmp$610763[esp+380], edi
	test	esi, esi
	jne	SHORT $LN1737@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1593@readNextCo@2:
	mov	ecx, DWORD PTR _nextRank$219955[esp+376]
	imul	ecx, 200				; 000000c8H
	add	edi, ecx
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN1583@readNextCo@2
	test	esi, esi
	je	SHORT $LN1598@readNextCo@2
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN1599@readNextCo@2
$LN1737@readNextCo@2:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN1593@readNextCo@2
$LN1598@readNextCo@2:
	xor	esi, esi
$LN1599@readNextCo@2:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN1584@readNextCo@2
$LN1583@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1584@readNextCo@2:
	test	ebp, ebp
	jne	SHORT $LN1736@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1613@readNextCo@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN1604@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1604@readNextCo@2:
	mov	ebp, DWORD PTR [edi+184]
	cmp	ebp, DWORD PTR [edi+188]
	jbe	SHORT $LN1619@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1619@readNextCo@2:
	mov	esi, DWORD PTR [edi+172]
	mov	DWORD PTR __Tmp$610919[esp+376], esi
	mov	DWORD PTR __Tmp$610919[esp+380], ebp
	test	esi, esi
	jne	SHORT $LN1735@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1642@readNextCo@2:
	imul	ebx, 152				; 00000098H
	lea	edi, DWORD PTR [ebx+ebp]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN1632@readNextCo@2
	test	esi, esi
	je	SHORT $LN1647@readNextCo@2
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN1648@readNextCo@2
$LN1736@readNextCo@2:
	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN1613@readNextCo@2
$LN1735@readNextCo@2:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN1642@readNextCo@2
$LN1647@readNextCo@2:
	xor	esi, esi
$LN1648@readNextCo@2:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN1633@readNextCo@2
$LN1632@readNextCo@2:
	call	__invalid_parameter_noinfo
$LN1633@readNextCo@2:
	mov	eax, DWORD PTR __Tmp$610919[esp+376]
	test	eax, eax
	jne	SHORT $LN1734@readNextCo@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN1662@readNextCo@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN1653@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1653@readNextCo@2:
	mov	edx, DWORD PTR [edi+36]
	sub	edx, DWORD PTR [edi+32]
	mov	esi, DWORD PTR [edi+12]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN1669@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1669@readNextCo@2:
	mov	eax, DWORD PTR [edi+32]
	mov	edi, DWORD PTR [eax+esi*4]

; 2144 : 
; 2145 : 				// see if this command could be used
; 2146 : 				if (potentialCommand)

	test	edi, edi
	je	$LN3@readNextCo@2

; 2147 : 				{
; 2148 : 					if (!potentialCommand->isRefresh())

	mov	eax, DWORD PTR [edi+80]
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN6@readNextCo@2

; 2149 : 					{
; 2150 : 						if (potentialCommand->isActivate() == isActivate)

	test	eax, eax
	je	SHORT $LN1678@readNextCo@2
	cmp	eax, 8
	je	SHORT $LN1678@readNextCo@2
	xor	eax, eax
	jmp	SHORT $LN1679@readNextCo@2
$LN1734@readNextCo@2:

; 2139 : 
; 2140 : 			while (true)
; 2141 : 			{
; 2142 : 				const Command *potentialCommand = 						
; 2143 : 					((rank.begin() + nextRank)->bank.begin() + nextBank)->front();

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1662@readNextCo@2

; 2149 : 					{
; 2150 : 						if (potentialCommand->isActivate() == isActivate)

$LN1678@readNextCo@2:
	mov	eax, 1
$LN1679@readNextCo@2:
	cmp	al, BYTE PTR _isActivate$219954[esp+376]
	je	$LN58@readNextCo@2

; 2151 : 						{							
; 2152 : 							return potentialCommand;
; 2153 : 						}
; 2154 : 					}
; 2155 : 					else

	jmp	SHORT $LN3@readNextCo@2
$LN6@readNextCo@2:

; 2156 : 					{
; 2157 : 						// look for refreshes
; 2158 : 						if ((rank.begin() + nextRank)->refreshAllReady())

	mov	eax, DWORD PTR _this$[esp+376]
	mov	esi, DWORD PTR [eax+380]
	cmp	esi, DWORD PTR [eax+384]
	jbe	SHORT $LN1683@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1683@readNextCo@2:
	mov	ecx, DWORD PTR _this$[esp+376]
	mov	edx, DWORD PTR [ecx+368]
	mov	ecx, DWORD PTR _nextRank$219955[esp+376]
	lea	eax, DWORD PTR $T606520[esp+376]
	push	eax
	lea	eax, DWORD PTR $T606519[esp+380]
	mov	DWORD PTR $T606519[esp+380], edx
	mov	DWORD PTR $T606519[esp+384], esi
	call	??H?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator+
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN1783@readNextCo@2
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1704@readNextCo@2
$LN1783@readNextCo@2:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1705@readNextCo@2
$LN1704@readNextCo@2:
	xor	eax, eax
$LN1705@readNextCo@2:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN1696@readNextCo@2
	call	__invalid_parameter_noinfo
$LN1696@readNextCo@2:
	mov	esi, DWORD PTR [esi+4]
	push	esi
	call	?refreshAllReady@Rank@DRAMsimII@@QBE_NXZ ; DRAMsimII::Rank::refreshAllReady
	test	al, al
	jne	$LN58@readNextCo@2
$LN3@readNextCo@2:

; 2159 : 						{
; 2160 : 							return potentialCommand;
; 2161 : 						}
; 2162 : 					}
; 2163 : 				}
; 2164 : 
; 2165 : 				// then switch command
; 2166 : 				getNextCPRHValues(nextRank, nextBank, isActivate);

	mov	edx, DWORD PTR _isActivate$219954[esp+376]
	push	edx
	lea	eax, DWORD PTR _nextBank$219956[esp+380]
	push	eax
	mov	eax, DWORD PTR _this$[esp+384]
	lea	ecx, DWORD PTR _nextRank$219955[esp+384]
	push	ecx
	call	?getNextCPRHValues@Channel@DRAMsimII@@IBEXAAI0_N@Z ; DRAMsimII::Channel::getNextCPRHValues

; 2167 : 				isActivate = !isActivate;	

	cmp	BYTE PTR _isActivate$219954[esp+376], 0

; 2168 : 
; 2169 : 				// quit if already checked every rank/bank combination
; 2170 : 				if (nextRank == originalRank && nextBank == originalBank && originalActivate == isActivate)

	mov	eax, DWORD PTR _nextRank$219955[esp+376]
	mov	ebx, DWORD PTR _nextBank$219956[esp+376]
	sete	dl
	mov	BYTE PTR _isActivate$219954[esp+376], dl
	cmp	eax, DWORD PTR _originalRank$219961[esp+376]
	jne	$LL9@readNextCo@2
	cmp	ebx, DWORD PTR _originalBank$219962[esp+376]
	jne	$LL9@readNextCo@2
	mov	cl, dl
	cmp	BYTE PTR _originalActivate$219963[esp+376], cl
	jne	$LL9@readNextCo@2

; 2182 : 		}
; 2183 : 		break;
; 2184 : 	}
; 2185 : 	return NULL;
; 2186 : }

	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@readNextCo@2:

; 2171 : 				{
; 2172 : 					return NULL;
; 2173 : 				}							
; 2174 : 			}
; 2175 : 		}
; 2176 : 		break;
; 2177 : 
; 2178 : 	default:
; 2179 : 		{
; 2180 : 			cerr << "This configuration and algorithm combination is not supported" << endl;

	push	OFFSET ??_C@_0DO@ENOGKDBL@This?5configuration?5and?5algorithm@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 2181 : 			exit(-2);

	push	-2					; fffffffeH
	call	_exit
$LN1848@readNextCo@2:
$LN1831@readNextCo@2:
	npad	1
$LN1843@readNextCo@2:

; 2182 : 		}
; 2183 : 		break;
; 2184 : 	}
; 2185 : 	return NULL;
; 2186 : }

	DD	$LN95@readNextCo@2
	DD	$LN82@readNextCo@2
	DD	$LN48@readNextCo@2
	DD	$LN151@readNextCo@2
	DD	$LN135@readNextCo@2
	DD	$LN113@readNextCo@2
	DD	$LN12@readNextCo@2
$LN1844@readNextCo@2:
	DD	$LN79@readNextCo@2
	DD	$LN76@readNextCo@2
	DD	$LN74@readNextCo@2
	DD	$LN71@readNextCo@2
	DD	$LN69@readNextCo@2
	DD	$LN66@readNextCo@2
$LN1801@readNextCo@2:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	2
	npad	3
$LN1845@readNextCo@2:
	DD	$LN45@readNextCo@2
	DD	$LN42@readNextCo@2
	DD	$LN40@readNextCo@2
	DD	$LN37@readNextCo@2
	DD	$LN35@readNextCo@2
	DD	$LN32@readNextCo@2
$LN1802@readNextCo@2:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	2
?readNextCommand@Channel@DRAMsimII@@MBEPBVCommand@2@XZ ENDP ; DRAMsimII::Channel::readNextCommand
_TEXT	ENDS
PUBLIC	?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z ; DRAMsimII::Channel::checkForAvailableCommandSlots
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_i$219194 = -16						; size = 8
_currentBank$219173 = -16				; size = 8
_destinationBank$ = -16					; size = 4
$T611263 = -8						; size = 8
$T611261 = -8						; size = 8
_this$ = 8						; size = 4
?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z PROC ; DRAMsimII::Channel::checkForAvailableCommandSlots
; _incomingTransaction$ = eax

; 937  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, eax

; 938  : 	if (incomingTransaction == NULL)

	test	edi, edi

; 939  : 	{
; 940  : 		return false;

	je	$LN235@checkForAv

; 941  : 	}
; 942  : 	// ensure that this transaction belongs on this channel
; 943  : 	assert (incomingTransaction->getAddress().getChannel() == channelID || incomingTransaction->isRefresh());
; 944  : 
; 945  : 	/// @todo switch to iterator arithmetic
; 946  : 	const Bank &destinationBank = rank[incomingTransaction->getAddress().getRank()].bank[incomingTransaction->getAddress().getBank()];

	mov	ebx, DWORD PTR _this$[esp+28]
	mov	edx, DWORD PTR [ebx+384]
	sub	edx, DWORD PTR [ebx+380]
	mov	ebp, DWORD PTR [edi+60]
	mov	esi, DWORD PTR [edi+64]
	add	ebx, 368				; 00000170H
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	jb	SHORT $LN46@checkForAv
	call	__invalid_parameter_noinfo
$LN46@checkForAv:
	mov	ecx, DWORD PTR [ebx+12]
	imul	ebp, 200				; 000000c8H
	mov	edx, DWORD PTR [ecx+ebp+188]
	sub	edx, DWORD PTR [ecx+ebp+184]
	lea	ebp, DWORD PTR [ecx+ebp+172]
	mov	eax, 1808407283				; 6bca1af3H
	imul	edx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jb	SHORT $LN51@checkForAv
	call	__invalid_parameter_noinfo
$LN51@checkForAv:
	imul	esi, 152				; 00000098H
	add	esi, DWORD PTR [ebp+12]

; 947  : 
; 948  : 	unsigned availableCommandSlots = (incomingTransaction->isRefresh()) ? 0 : rank[incomingTransaction->getAddress().getRank()].bank[incomingTransaction->getAddress().getBank()].freeCommandSlots();

	cmp	DWORD PTR [edi+80], 4
	mov	ecx, esi
	mov	DWORD PTR _destinationBank$[esp+32], ecx
	jne	SHORT $LN36@checkForAv
	xor	ebp, ebp
	jmp	SHORT $LN37@checkForAv
$LN36@checkForAv:
	mov	edx, DWORD PTR [ebx+16]
	sub	edx, DWORD PTR [ebx+12]
	mov	ebp, DWORD PTR [edi+60]
	mov	esi, DWORD PTR [edi+64]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	jb	SHORT $LN66@checkForAv
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR _destinationBank$[esp+32]
$LN66@checkForAv:
	mov	edx, DWORD PTR [ebx+12]
	imul	ebp, 200				; 000000c8H
	lea	ebp, DWORD PTR [edx+ebp+172]
	mov	edx, DWORD PTR [ebp+16]
	sub	edx, DWORD PTR [ebp+12]
	mov	eax, 1808407283				; 6bca1af3H
	imul	edx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jb	SHORT $LN71@checkForAv
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR _destinationBank$[esp+32]
$LN71@checkForAv:
	mov	edx, DWORD PTR [ebp+12]
	imul	esi, 152				; 00000098H
	mov	ebp, DWORD PTR [esi+edx+36]
	sub	ebp, DWORD PTR [esi+edx+32]
	lea	esi, DWORD PTR [esi+edx+8]
	sar	ebp, 2
	sub	ebp, DWORD PTR [esi]
$LN37@checkForAv:

; 949  : 
; 950  : 	// with closed page, all transactions convert into one of the following:
; 951  : 	// RAS, CAS, Precharge
; 952  : 	// RAS, CAS+Precharge
; 953  : 	switch (systemConfig.getRowBufferManagementPolicy())

	mov	eax, DWORD PTR _this$[esp+28]
	mov	edx, DWORD PTR [eax+176]
	mov	edx, DWORD PTR [edx+328]
	lea	esi, DWORD PTR [edx-1]
	cmp	esi, 3
	ja	$LN1@checkForAv
	jmp	DWORD PTR $LN238@checkForAv[esi*4]
$LN30@checkForAv:

; 954  : 	{
; 955  : 	case CLOSE_PAGE_AGGRESSIVE:
; 956  : 	case CLOSE_PAGE:	
; 957  : 		// refresh transactions become only one command and are handled differently
; 958  : 		if (incomingTransaction->isRefresh())

	cmp	DWORD PTR [edi+80], 4
	jne	SHORT $LN29@checkForAv

; 959  : 		{
; 960  : 			const Rank &destinationRank = rank[incomingTransaction->getAddress().getRank()];

	mov	edi, DWORD PTR [edi+60]
	mov	esi, ebx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]

; 961  : 			// make sure that there is room in all the queues for one command
; 962  : 			// refresh commands refresh a row, but kill everything currently in the sense amps
; 963  : 			// therefore, we need to make sure that the refresh commands happen when all banks
; 964  : 			// are available
; 965  : 			for (vector<Bank>::const_iterator currentBank = destinationRank.bank.begin(); currentBank != destinationRank.bank.end(); currentBank++)

	lea	ebx, DWORD PTR [eax+172]
	lea	esi, DWORD PTR _currentBank$219173[esp+32]
	mov	edi, ebx
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
$LL28@checkForAv:
	mov	ebp, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], ebp
	jbe	SHORT $LN93@checkForAv
	call	__invalid_parameter_noinfo
$LN93@checkForAv:
	mov	esi, DWORD PTR _currentBank$219173[esp+32]
	mov	eax, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN106@checkForAv
	cmp	esi, eax
	je	SHORT $LN107@checkForAv
$LN106@checkForAv:
	call	__invalid_parameter_noinfo
$LN107@checkForAv:
	mov	edi, DWORD PTR _currentBank$219173[esp+36]
	cmp	edi, ebp
	je	SHORT $LN19@checkForAv

; 966  : 			{
; 967  : 				if (currentBank->isFull())

	test	esi, esi
	jne	SHORT $LN229@checkForAv
	call	__invalid_parameter_noinfo
$LN125@checkForAv:
	cmp	edi, DWORD PTR [esi+16]
	jb	SHORT $LN116@checkForAv
	call	__invalid_parameter_noinfo
$LN116@checkForAv:
	mov	eax, DWORD PTR [edi+36]
	sub	eax, DWORD PTR [edi+32]
	sar	eax, 2
	cmp	eax, DWORD PTR [edi+8]
	je	$LN235@checkForAv
	lea	edi, DWORD PTR $T611261[esp+32]
	lea	esi, DWORD PTR _currentBank$219173[esp+32]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	jmp	SHORT $LL28@checkForAv
$LN229@checkForAv:
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN125@checkForAv
$LN29@checkForAv:

; 968  : 					return false;
; 969  : 			}
; 970  : 		}
; 971  : 		// must know that there is >0 slots open or the result may not be accurate
; 972  : 		else if (systemConfig.getRowBufferManagementPolicy() == CLOSE_PAGE_AGGRESSIVE &&
; 973  : 			destinationBank.closePageAggressiveInsertCheck(incomingTransaction, time))

	cmp	edx, 4
	jne	SHORT $LN23@checkForAv
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR _destinationBank$[esp+32]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?closePageAggressiveInsertCheck@Bank@DRAMsimII@@QBE_NPBVTransaction@2@_J@Z ; DRAMsimII::Bank::closePageAggressiveInsertCheck
	test	al, al

; 974  : 		{
; 975  : 			return true;

	jne	$LN3@checkForAv

; 968  : 					return false;
; 969  : 			}
; 970  : 		}
; 971  : 		// must know that there is >0 slots open or the result may not be accurate
; 972  : 		else if (systemConfig.getRowBufferManagementPolicy() == CLOSE_PAGE_AGGRESSIVE &&
; 973  : 			destinationBank.closePageAggressiveInsertCheck(incomingTransaction, time))

	mov	eax, DWORD PTR _this$[esp+28]
$LN23@checkForAv:

; 976  : 		}	
; 977  : 		// every transaction translates into at least two commands
; 978  : 		else if (availableCommandSlots < 2)

	cmp	ebp, 2

; 979  : 		{
; 980  : 			return false;

	jb	$LN235@checkForAv

; 981  : 		}
; 982  : 		// or three commands if the CAS+Precharge command is not available
; 983  : 		else if (!systemConfig.isAutoPrecharge() && (availableCommandSlots < 3))

	mov	eax, DWORD PTR [eax+176]
	cmp	BYTE PTR [eax+346], 0
	jne	SHORT $LN19@checkForAv
	cmp	ebp, 3

; 984  : 		{
; 985  : 			return false;

	jb	$LN235@checkForAv
$LN19@checkForAv:

; 1051 : 		break;
; 1052 : 	}
; 1053 : 	return true;

	mov	al, 1

; 1054 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
$LN18@checkForAv:

; 986  : 		}
; 987  : 		break;
; 988  : 
; 989  : 		// open page systems may, in the best case, add a CAS command to an already open row
; 990  : 		// closing the row and precharging may be delayed
; 991  : 
; 992  : 		// all break down into PRE,RAS,CAS
; 993  : 		// or CAS
; 994  : 	case OPEN_PAGE:
; 995  : 	case OPEN_PAGE_AGGRESSIVE:
; 996  : 
; 997  : 		// refresh transactions become only one command and are handled differently
; 998  : 		if (incomingTransaction->isRefresh())

	cmp	DWORD PTR [edi+80], 4
	jne	$LN17@checkForAv

; 999  : 		{
; 1000 : 			const Rank &currentRank = rank[incomingTransaction->getAddress().getRank()];

	mov	edi, DWORD PTR [edi+60]
	mov	esi, ebx
	call	??A?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEABVRank@DRAMsimII@@I@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator[]

; 1001 : 			// make sure that there is room in all the queues for one command
; 1002 : 			// refresh commands refresh a row, but kill everything currently in the sense amps
; 1003 : 			// therefore, we need to make sure that the refresh commands happen when all banks
; 1004 : 			// are available
; 1005 : 			for (vector<Bank>::const_iterator i = currentRank.bank.begin(); i != currentRank.bank.end(); i++)

	lea	ebx, DWORD PTR [eax+172]
	lea	esi, DWORD PTR _i$219194[esp+32]
	mov	edi, ebx
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	npad	6
$LL16@checkForAv:
	mov	ebp, DWORD PTR [ebx+16]
	cmp	DWORD PTR [ebx+12], ebp
	jbe	SHORT $LN147@checkForAv
	call	__invalid_parameter_noinfo
$LN147@checkForAv:
	mov	esi, DWORD PTR _i$219194[esp+32]
	mov	eax, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN160@checkForAv
	cmp	esi, eax
	je	SHORT $LN161@checkForAv
$LN160@checkForAv:
	call	__invalid_parameter_noinfo
$LN161@checkForAv:
	mov	edi, DWORD PTR _i$219194[esp+36]
	cmp	edi, ebp
	je	$LN3@checkForAv

; 1006 : 			{					
; 1007 : 				if (i->freeCommandSlots() < 2)

	test	esi, esi
	jne	SHORT $LN228@checkForAv
	call	__invalid_parameter_noinfo
$LN179@checkForAv:
	cmp	edi, DWORD PTR [esi+16]
	jb	SHORT $LN170@checkForAv
	call	__invalid_parameter_noinfo
$LN170@checkForAv:
	mov	ecx, DWORD PTR [edi+36]
	sub	ecx, DWORD PTR [edi+32]
	sar	ecx, 2
	sub	ecx, DWORD PTR [edi+8]
	cmp	ecx, 2
	jb	$LN235@checkForAv
	lea	edi, DWORD PTR $T611263[esp+32]
	lea	esi, DWORD PTR _i$219194[esp+32]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	jmp	SHORT $LL16@checkForAv
$LN228@checkForAv:
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN179@checkForAv
$LN17@checkForAv:

; 1008 : 					return false;
; 1009 : 			}
; 1010 : 			return true;
; 1011 : 		}
; 1012 : 		else if (!destinationBank.isFull())

	mov	esi, DWORD PTR [ecx+36]
	sub	esi, DWORD PTR [ecx+32]
	sar	esi, 2
	cmp	esi, DWORD PTR [ecx+8]
	je	$LN235@checkForAv

; 1013 : 		{	
; 1014 : 			// try to do a normal open page insert on this transaction
; 1015 : 			if ((systemConfig.getRowBufferManagementPolicy() == OPEN_PAGE_AGGRESSIVE) &&
; 1016 : 				(destinationBank.openPageAggressiveInsertCheck(incomingTransaction, time)))

	cmp	edx, 2
	jne	SHORT $LN10@checkForAv
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	push	eax
	push	edi
	mov	esi, ecx
	call	?openPageAggressiveInsertCheck@Bank@DRAMsimII@@QBE_NPBVTransaction@2@_J@Z ; DRAMsimII::Bank::openPageAggressiveInsertCheck
	test	al, al

; 1017 : 			{					
; 1018 : 				return true;

	jne	SHORT $LN3@checkForAv

; 1013 : 		{	
; 1014 : 			// try to do a normal open page insert on this transaction
; 1015 : 			if ((systemConfig.getRowBufferManagementPolicy() == OPEN_PAGE_AGGRESSIVE) &&
; 1016 : 				(destinationBank.openPageAggressiveInsertCheck(incomingTransaction, time)))

	mov	ecx, DWORD PTR _destinationBank$[esp+32]
$LN10@checkForAv:

; 1019 : 			}
; 1020 : 			else
; 1021 : 			{
; 1022 : 				// first, the precharge command, if necessary
; 1023 : 				if (((destinationBank.isEmpty() && destinationBank.isActivated()) || (!destinationBank.isEmpty() && !destinationBank.back()->isRefresh())))

	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	jne	SHORT $LN237@checkForAv
	cmp	BYTE PTR [ecx+124], al
	jne	SHORT $LN7@checkForAv
	test	eax, eax
	je	SHORT $LN8@checkForAv
$LN237@checkForAv:
	mov	esi, ecx
	call	?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::back
	cmp	DWORD PTR [eax+80], 12			; 0000000cH
	mov	ecx, DWORD PTR _destinationBank$[esp+32]
	je	SHORT $LN8@checkForAv
$LN7@checkForAv:

; 1024 : 				{
; 1025 : 					if (destinationBank.freeCommandSlots() < 3)

	mov	edx, DWORD PTR [ecx+36]
	sub	edx, DWORD PTR [ecx+32]
	sar	edx, 2
	sub	edx, DWORD PTR [ecx+8]
	cmp	edx, 3
	jae	SHORT $LN3@checkForAv

; 1050 : 		return false;

	xor	al, al

; 1054 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
$LN8@checkForAv:

; 1026 : 					{
; 1027 : 						return false;
; 1028 : 					}
; 1029 : 					assert(!destinationBank.back() || destinationBank.back()->getCommandType() != Command::REFRESH_ALL);
; 1030 : 					assert(!destinationBank.back() || destinationBank.back()->getCommandType() != Command::PRECHARGE);
; 1031 : 				}
; 1032 : 				else if (destinationBank.freeCommandSlots() < 2)

	mov	eax, DWORD PTR [ecx+36]
	sub	eax, DWORD PTR [ecx+32]
	sar	eax, 2
	sub	eax, DWORD PTR [ecx+8]
	cmp	eax, 2

; 1033 : 				{
; 1034 : 					return false;

	jb	SHORT $LN235@checkForAv
$LN3@checkForAv:

; 1035 : 				}
; 1036 : 
; 1037 : 				return true;	

	mov	al, 1

; 1054 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
$LN1@checkForAv:

; 1038 : 			}
; 1039 : 		}
; 1040 : 		else
; 1041 : 		{
; 1042 : 			return false;
; 1043 : 		}
; 1044 : 
; 1045 : 		break;
; 1046 : 
; 1047 : 	default:
; 1048 : 
; 1049 : 		cerr << "Unhandled row buffer management policy" << endl;

	push	OFFSET ??_C@_0CH@PMAPFHOL@Unhandled?5row?5buffer?5management?5@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN235@checkForAv:

; 1054 : }

	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
	npad	3
$LN238@checkForAv:
	DD	$LN18@checkForAv
	DD	$LN18@checkForAv
	DD	$LN30@checkForAv
	DD	$LN30@checkForAv
?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z ENDP ; DRAMsimII::Channel::checkForAvailableCommandSlots
_TEXT	ENDS
PUBLIC	?readAvailableTransaction@Channel@DRAMsimII@@IBEI_N@Z ; DRAMsimII::Channel::readAvailableTransaction
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
tv83 = -8						; size = 4
tv69 = -4						; size = 4
_j$219005 = 8						; size = 4
_bufferDelay$ = 8					; size = 1
?readAvailableTransaction@Channel@DRAMsimII@@IBEI_N@Z PROC ; DRAMsimII::Channel::readAvailableTransaction
; _this$ = esi

; 765  : {

	sub	esp, 12					; 0000000cH

; 766  : 	const unsigned delay = bufferDelay ? timingSpecification.tBufferDelay() : 0;

	cmp	BYTE PTR _bufferDelay$[esp+8], 0
	push	ebx
	push	ebp
	push	edi
	je	SHORT $LN14@readAvaila
	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR tv69[esp+24], eax
	jmp	SHORT $LN15@readAvaila
$LN14@readAvaila:
	mov	DWORD PTR tv69[esp+24], 0
$LN15@readAvaila:

; 767  : 
; 768  : 	unsigned limit = min(systemConfig.getDecodeWindow(), transactionQueue.size());

	mov	ecx, DWORD PTR [esi+176]
	mov	eax, DWORD PTR [ecx+376]
	mov	ecx, DWORD PTR [esi+112]
	mov	DWORD PTR tv83[esp+24], eax
	cmp	eax, ecx
	jb	SHORT $LN26@readAvaila
	mov	DWORD PTR tv83[esp+24], ecx
$LN26@readAvaila:

; 769  : 
; 770  : 	for (unsigned i = 0; i < limit; i++)

	xor	ebp, ebp
	cmp	DWORD PTR tv83[esp+24], ebp
	jbe	$LN126@readAvaila
$LL11@readAvaila:

; 771  : 	{
; 772  : 		// if it's ready to decode
; 773  : 		if ((transactionQueue[i]->getEnqueueTime() + delay <= time) &&
; 774  : 			checkForAvailableCommandSlots(transactionQueue[i]))

	cmp	ebp, DWORD PTR [esi+112]
	jge	SHORT $LN33@readAvaila
	test	ebp, ebp
	jl	SHORT $LN33@readAvaila
	mov	ecx, DWORD PTR [esi+140]
	sub	ecx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+116]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebp
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+140]
	sub	edx, DWORD PTR [esi+136]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN39@readAvaila
	call	__invalid_parameter_noinfo
$LN39@readAvaila:
	mov	eax, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN32@readAvaila
$LN33@readAvaila:
	xor	eax, eax
$LN32@readAvaila:
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR tv69[esp+24]
	mov	eax, DWORD PTR [eax+20]
	mov	edx, 0
	adc	eax, edx
	cmp	eax, DWORD PTR [esi+12]
	jg	$LN8@readAvaila
	jl	SHORT $LN134@readAvaila
	cmp	ecx, DWORD PTR [esi+8]
	ja	$LN8@readAvaila
$LN134@readAvaila:
	cmp	ebp, DWORD PTR [esi+112]
	jge	SHORT $LN51@readAvaila
	test	ebp, ebp
	jl	SHORT $LN51@readAvaila
	mov	ecx, DWORD PTR [esi+140]
	sub	ecx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+116]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebp
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+140]
	sub	edx, DWORD PTR [esi+136]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN57@readAvaila
	call	__invalid_parameter_noinfo
$LN57@readAvaila:
	mov	eax, DWORD PTR [esi+136]
	mov	edi, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN50@readAvaila
$LN51@readAvaila:
	xor	edi, edi
$LN50@readAvaila:
	push	esi
	mov	eax, edi
	call	?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z ; DRAMsimII::Channel::checkForAvailableCommandSlots
	test	al, al
	je	$LN8@readAvaila

; 775  : 		{
; 776  : 			bool conflict = false;
; 777  : 			// make sure not to create a RAW, WAR, WAW problem
; 778  : 			for (unsigned j = 0; j < i; j++)

	xor	ecx, ecx
	mov	DWORD PTR _j$219005[esp+20], ecx
	test	ebp, ebp
	jbe	$LN125@readAvaila
$LL7@readAvaila:

; 779  : 			{
; 780  : 				if (transactionQueue[i]->getAddress() == transactionQueue[j]->getAddress())

	cmp	ecx, DWORD PTR [esi+112]
	jge	SHORT $LN67@readAvaila
	test	ecx, ecx
	jl	SHORT $LN67@readAvaila
	mov	edi, DWORD PTR [esi+140]
	sub	edi, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+116]
	xor	edx, edx
	sar	edi, 2
	add	eax, ecx
	div	edi
	mov	edi, edx
	mov	edx, DWORD PTR [esi+140]
	sub	edx, DWORD PTR [esi+136]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN73@readAvaila
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR _j$219005[esp+20]
$LN73@readAvaila:
	mov	eax, DWORD PTR [esi+136]
	mov	ebx, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN66@readAvaila
$LN67@readAvaila:
	xor	ebx, ebx
$LN66@readAvaila:
	cmp	ebp, DWORD PTR [esi+112]
	jge	SHORT $LN85@readAvaila
	test	ebp, ebp
	jl	SHORT $LN85@readAvaila
	mov	edi, DWORD PTR [esi+140]
	sub	edi, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+116]
	xor	edx, edx
	sar	edi, 2
	add	eax, ebp
	div	edi
	mov	edi, edx
	mov	edx, DWORD PTR [esi+140]
	sub	edx, DWORD PTR [esi+136]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN91@readAvaila
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR _j$219005[esp+20]
$LN91@readAvaila:
	mov	eax, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN84@readAvaila
$LN85@readAvaila:
	xor	eax, eax
$LN84@readAvaila:
	mov	edx, DWORD PTR [eax+56]
	cmp	edx, DWORD PTR [ebx+56]
	jne	SHORT $LN100@readAvaila
	mov	edx, DWORD PTR [eax+60]
	cmp	edx, DWORD PTR [ebx+60]
	jne	SHORT $LN100@readAvaila
	mov	edx, DWORD PTR [eax+64]
	cmp	edx, DWORD PTR [ebx+64]
	jne	SHORT $LN100@readAvaila
	mov	edx, DWORD PTR [eax+68]
	cmp	edx, DWORD PTR [ebx+68]
	jne	SHORT $LN100@readAvaila
	mov	eax, DWORD PTR [eax+72]
	cmp	eax, DWORD PTR [ebx+72]
	je	$LN10@readAvaila
$LN100@readAvaila:
	inc	ecx
	mov	DWORD PTR _j$219005[esp+20], ecx
	cmp	ecx, ebp
	jb	$LL7@readAvaila
$LN125@readAvaila:

; 781  : 				{
; 782  : 					conflict = true;
; 783  : 					break;
; 784  : 				}
; 785  : 			}
; 786  : 			if (!conflict)
; 787  : 				return i;

	mov	eax, ebp

; 790  : 			break;
; 791  : 	}
; 792  : 	return UINT_MAX;
; 793  : }

	pop	edi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
$LN8@readAvaila:

; 788  : 		}
; 789  : 		else if (time - transactionQueue[i]->getEnqueueTime() > systemConfig.getSeniorityAgeLimit())

	cmp	ebp, DWORD PTR [esi+112]
	jge	SHORT $LN107@readAvaila
	test	ebp, ebp
	jl	SHORT $LN107@readAvaila
	mov	ecx, DWORD PTR [esi+140]
	sub	ecx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+116]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebp
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+140]
	sub	edx, DWORD PTR [esi+136]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN113@readAvaila
	call	__invalid_parameter_noinfo
$LN113@readAvaila:
	mov	eax, DWORD PTR [esi+136]
	mov	edx, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN106@readAvaila
$LN107@readAvaila:
	xor	edx, edx
$LN106@readAvaila:
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [esi+12]
	sbb	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [esi+176]
	mov	edi, DWORD PTR [edx+320]
	xor	edx, edx
	cmp	eax, edx
	jg	SHORT $LN126@readAvaila
	jl	SHORT $LN10@readAvaila
	cmp	ecx, edi
	ja	SHORT $LN126@readAvaila
$LN10@readAvaila:

; 769  : 
; 770  : 	for (unsigned i = 0; i < limit; i++)

	inc	ebp
	cmp	ebp, DWORD PTR tv83[esp+24]
	jb	$LL11@readAvaila
$LN126@readAvaila:

; 790  : 			break;
; 791  : 	}
; 792  : 	return UINT_MAX;
; 793  : }

	pop	edi
	pop	ebp
	or	eax, -1
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
?readAvailableTransaction@Channel@DRAMsimII@@IBEI_N@Z ENDP ; DRAMsimII::Channel::readAvailableTransaction
_TEXT	ENDS
PUBLIC	?enqueue@Channel@DRAMsimII@@QAE_NPAVTransaction@2@@Z ; DRAMsimII::Channel::enqueue
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_this$ = 8						; size = 4
_incomingTransaction$ = 12				; size = 4
?enqueue@Channel@DRAMsimII@@QAE_NPAVTransaction@2@@Z PROC ; DRAMsimII::Channel::enqueue

; 413  : {

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]

; 414  : 	if (transactionQueue.isFull())

	mov	eax, DWORD PTR [ebx+140]
	sub	eax, DWORD PTR [ebx+136]
	push	ebp
	push	esi
	lea	esi, DWORD PTR [ebx+112]
	sar	eax, 2
	push	edi
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN13@enqueue

; 415  : 		return false;

	xor	al, al

; 458  : 		break;
; 459  : 	}
; 460  : 
; 461  : 	return result;
; 462  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
$LN13@enqueue:

; 416  : 
; 417  : 	incomingTransaction->setEnqueueTime(time);

	mov	edx, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR _incomingTransaction$[esp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [ecx+20], eax

; 418  : 
; 419  : 	assert(!incomingTransaction->isRefresh());
; 420  : 
; 421  : 	assert(incomingTransaction->getAddress().getChannel() == channelID);
; 422  : 
; 423  : 	bool result;
; 424  : 
; 425  : 	switch (systemConfig.getTransactionOrderingAlgorithm())

	mov	edx, DWORD PTR [ebx+176]
	mov	eax, DWORD PTR [edx+292]
	sub	eax, 0
	je	SHORT $LN9@enqueue
	sub	eax, 1
	je	$LN8@enqueue

; 453  : 		}
; 454  : 		break;
; 455  : 	default:
; 456  : 		cerr << "Unknown transaction ordering algorithm." << endl;

	push	OFFSET ??_C@_0CI@CNIHCHBK@Unknown?5transaction?5ordering?5alg@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 457  : 		exit(-1);		

	push	-1
	call	_exit
$LN74@enqueue:
$LN9@enqueue:

; 426  : 	{
; 427  : 	case STRICT:
; 428  : 		result = transactionQueue.push(incomingTransaction);
; 429  : 		break;
; 430  : 	case RIFF:
; 431  : 		// search from back to front
; 432  : 		// insert right after a conflict, any transaction over the seniority limit or any read
; 433  : 		if (incomingTransaction->isRead())

	mov	eax, DWORD PTR [ecx+80]
	test	eax, eax
	je	SHORT $LN26@enqueue
	cmp	eax, 2
	je	SHORT $LN26@enqueue
	cmp	eax, 3
	jne	$LN8@enqueue
$LN26@enqueue:

; 434  : 		{
; 435  : 			for (int currentIndex = transactionQueue.size() - 1; currentIndex >= 0; --currentIndex)

	mov	edi, DWORD PTR [esi]
	sub	edi, 1
	js	$LN5@enqueue
	npad	2
$LL7@enqueue:

; 436  : 			{
; 437  : 				// prevent against starvation and RAW errors, reads do not switch their ordering
; 438  : 				if (transactionQueue[currentIndex]->isRead() ||
; 439  : 					(time - transactionQueue[currentIndex]->getEnqueueTime() > systemConfig.getSeniorityAgeLimit()) ||
; 440  : 					transactionQueue[currentIndex]->getAddress() == incomingTransaction->getAddress())

	cmp	edi, DWORD PTR [esi]
	jge	SHORT $LN35@enqueue
	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, edi
	div	ecx
	mov	ebp, edx
	mov	edx, DWORD PTR [esi+28]
	sub	edx, DWORD PTR [esi+24]
	sar	edx, 2
	cmp	ebp, edx
	jb	SHORT $LN41@enqueue
	call	__invalid_parameter_noinfo
$LN41@enqueue:
	mov	eax, DWORD PTR [esi+24]
	mov	ebp, DWORD PTR [eax+ebp*4]
	jmp	SHORT $LN34@enqueue
$LN35@enqueue:
	xor	ebp, ebp
$LN34@enqueue:
	mov	eax, DWORD PTR [ebp+80]
	test	eax, eax
	je	SHORT $LN63@enqueue
	cmp	eax, 2
	je	SHORT $LN63@enqueue
	cmp	eax, 3
	je	SHORT $LN63@enqueue
	mov	ecx, edi
	call	??A?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@1@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator[]
	mov	edx, DWORD PTR [ebx+8]
	sub	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [ebx+12]
	sbb	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [ebx+176]
	mov	ebp, DWORD PTR [eax+320]
	xor	eax, eax
	cmp	ecx, eax
	jg	SHORT $LN63@enqueue
	jl	SHORT $LN68@enqueue
	cmp	edx, ebp
	ja	SHORT $LN63@enqueue
$LN68@enqueue:
	mov	ecx, edi
	call	??A?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QBEPBVTransaction@1@I@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator[]
	mov	ecx, eax
	mov	eax, DWORD PTR _incomingTransaction$[esp+16]
	add	eax, 40					; 00000028H
	add	ecx, 40					; 00000028H
	call	??8Address@DRAMsimII@@QBE_NABV01@@Z	; DRAMsimII::Address::operator==
	test	al, al
	jne	SHORT $LN63@enqueue

; 434  : 		{
; 435  : 			for (int currentIndex = transactionQueue.size() - 1; currentIndex >= 0; --currentIndex)

	sub	edi, 1
	jns	$LL7@enqueue
$LN5@enqueue:

; 443  : 					assert(result);
; 444  : 					return result;
; 445  : 				}				
; 446  : 			}
; 447  : 			// if there were no conditions to force it to choose another location, insert at the head
; 448  : 			result = transactionQueue.push_front(incomingTransaction);

	mov	edx, DWORD PTR _incomingTransaction$[esp+16]
	push	edx
	mov	eax, esi
	call	?push_front@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::push_front

; 458  : 		break;
; 459  : 	}
; 460  : 
; 461  : 	return result;
; 462  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
$LN63@enqueue:

; 441  : 				{
; 442  : 					result = transactionQueue.insert(incomingTransaction, currentIndex + 1);					

	mov	ecx, DWORD PTR _incomingTransaction$[esp+16]
	inc	edi
	push	edi
	push	ecx
	mov	eax, esi
	call	?insert@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::insert

; 458  : 		break;
; 459  : 	}
; 460  : 
; 461  : 	return result;
; 462  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
$LN8@enqueue:

; 449  : 		}
; 450  : 		else
; 451  : 		{
; 452  : 			result = transactionQueue.push(incomingTransaction);

	push	ecx
	mov	eax, esi
	call	?push@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::push

; 458  : 		break;
; 459  : 	}
; 460  : 
; 461  : 	return result;
; 462  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	8
$LN73@enqueue:
?enqueue@Channel@DRAMsimII@@QAE_NPAVTransaction@2@@Z ENDP ; DRAMsimII::Channel::enqueue
;	COMDAT xdata$x
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\address.cpp
xdata$x	SEGMENT
__unwindtable$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$1
__ehfuncinfo$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
xdata$x	ENDS
;	COMDAT ??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T624960 = 12						; size = 4
_preallocate$ = 12					; size = 1
??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>, COMDAT
; _size$ = ecx

; 88   : 		{

	push	-1
	push	__ehhandler$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ebp, DWORD PTR _this$[esp+32]
	xor	ebx, ebx
	lea	esi, DWORD PTR [ebp+12]
	push	esi
	mov	DWORD PTR [ebp], ebx
	mov	DWORD PTR [ebp+4], ebx
	mov	DWORD PTR [ebp+8], ebx
	call	??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	mov	al, BYTE PTR _preallocate$[esp+32]

; 89   : 			entry.reserve(size);

	push	edi
	mov	BYTE PTR [ebp+36], al
	call	?reserve@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::reserve

; 90   : 
; 91   : 			if (preallocate)

	cmp	BYTE PTR _preallocate$[esp+32], bl
	je	SHORT $LN24@Queue@5

; 92   : 			{
; 93   : 				while (!isFull())

	mov	ecx, DWORD PTR [ebp+28]
	sub	ecx, DWORD PTR [ebp+24]
	sar	ecx, 2
	cmp	ecx, DWORD PTR [ebp]
	je	SHORT $LN24@Queue@5
	or	edi, -1
$LL2@Queue@5:

; 94   : 				{
; 95   : 					push(::new T());

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T624960[esp+32], esi
	mov	BYTE PTR __$EHRec$[esp+44], 1
	cmp	esi, ebx
	je	SHORT $LN6@Queue@5
	call	??0Event@DRAMsimII@@IAE@XZ		; DRAMsimII::Event::Event
	mov	DWORD PTR [esi], OFFSET ??_7Transaction@DRAMsimII@@6B@
	mov	DWORD PTR [esi+80], 7
	mov	DWORD PTR [esi+84], ebx
	mov	DWORD PTR [esi+88], ebx
	mov	DWORD PTR [esi+92], ebx
	mov	DWORD PTR [esi+96], ebx
	mov	DWORD PTR [esi+100], ebx
	mov	DWORD PTR [esi+104], ebx
	mov	DWORD PTR [esi+108], edi
	jmp	SHORT $LN7@Queue@5
$LN6@Queue@5:
	xor	esi, esi
$LN7@Queue@5:
	push	esi
	mov	eax, ebp
	mov	BYTE PTR __$EHRec$[esp+48], bl
	call	?push@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE_NPAVTransaction@2@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::push
	mov	edx, DWORD PTR [ebp+28]
	sub	edx, DWORD PTR [ebp+24]
	sar	edx, 2
	cmp	edx, DWORD PTR [ebp]
	jne	SHORT $LL2@Queue@5
$LN24@Queue@5:

; 96   : 				}
; 97   : 			}
; 98   : 		}

	mov	eax, ebp
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 12					; 0000000cH
	jmp	??1?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
__unwindfunclet$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z$1:
	mov	eax, DWORD PTR $T624960[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
PUBLIC	?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::executeCommand
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
tv1327 = -28						; size = 8
_i$220060 = -28						; size = 8
tv1332 = -20						; size = 8
$T625004 = -20						; size = 8
$T625003 = -12						; size = 8
tv1358 = 8						; size = 4
$T625743 = 8						; size = 4
$T625329 = 8						; size = 4
_currentBank$ = 8					; size = 4
_this$ = 8						; size = 4
_currentRank$ = 12					; size = 4
_thisCommand$ = 12					; size = 4
?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z PROC ; DRAMsimII::Channel::executeCommand

; 2226 : {

	sub	esp, 28					; 0000001cH
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+28]

; 2227 : 	Rank &currentRank = rank[thisCommand->getAddress().getRank()];

	mov	ecx, DWORD PTR [ebx+384]
	sub	ecx, DWORD PTR [ebx+380]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	push	ebp
	mov	ebp, DWORD PTR _thisCommand$[esp+32]
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	push	esi
	mov	esi, DWORD PTR [ebp+60]
	add	eax, edx
	push	edi
	cmp	esi, eax
	jb	SHORT $LN44@executeCom
	call	__invalid_parameter_noinfo
$LN44@executeCom:
	imul	esi, 200				; 000000c8H
	add	esi, DWORD PTR [ebx+380]
	mov	eax, esi

; 2228 : 
; 2229 : 	Bank &currentBank = currentRank.bank[thisCommand->getAddress().getBank()];

	mov	ecx, DWORD PTR [eax+188]
	sub	ecx, DWORD PTR [eax+184]
	mov	esi, DWORD PTR [ebp+64]
	mov	DWORD PTR _currentRank$[esp+40], eax
	add	eax, 172				; 000000acH
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	esi, ecx
	jb	SHORT $LN53@executeCom
	call	__invalid_parameter_noinfo
$LN53@executeCom:
	mov	eax, DWORD PTR _currentRank$[esp+40]
	imul	esi, 152				; 00000098H
	add	esi, DWORD PTR [eax+184]

; 2230 : 
; 2231 : 	currentRank.setLastBankID(thisCommand->getAddress().getBank());

	mov	edx, DWORD PTR [ebp+64]
	mov	DWORD PTR [eax+140], edx

; 2232 : 
; 2233 : 	thisCommand->setStartTime(time);

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebp+24], eax
	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebp+28], ecx

; 2234 : 
; 2235 : 	assert(canIssue(thisCommand));
; 2236 : 
; 2237 : 	bool wasActivated = currentBank.isActivated();
; 2238 : 
; 2239 : 	lastCommandIssueTime = time;

	mov	edi, DWORD PTR [ebx+8]
	mov	DWORD PTR _currentBank$[esp+40], esi
	mov	esi, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebx+16], edi
	mov	DWORD PTR [ebx+20], esi

; 2240 : 
; 2241 : 	switch(thisCommand->getCommandType())

	mov	eax, DWORD PTR [ebp+80]
	cmp	eax, 16					; 00000010H
	ja	$LN1@executeCom
	movzx	edx, BYTE PTR $LN418@executeCom[eax]
	jmp	DWORD PTR $LN421@executeCom[edx*4]
$LN33@executeCom:

; 2242 : 	{
; 2243 : 	case Command::ACTIVATE:
; 2244 : 		{
; 2245 : 			assert(!currentBank.isActivated());
; 2246 : 
; 2247 : 			// see if this was held due to tFAW (or at least tied with other restrictions)
; 2248 : 			if (time - currentRank.lastActivateTimes.back() == timingSpecification.tFAW())

	mov	eax, DWORD PTR _currentRank$[esp+40]
	add	eax, 148				; 00000094H
	call	?back@?$circular_buffer@_JV?$allocator@_J@std@@@boost@@QAEAA_JXZ ; boost::circular_buffer<__int64,std::allocator<__int64> >::back
	sub	edi, DWORD PTR [eax]
	sbb	esi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ebx+52]
	cdq
	cmp	edi, eax
	jne	SHORT $LN72@executeCom
	cmp	esi, edx
	jne	SHORT $LN72@executeCom

; 2249 : 				statistics.reportTFawCommand();

	mov	eax, DWORD PTR [ebx+180]
	inc	DWORD PTR [eax+64]
$LN72@executeCom:

; 2250 : 			
; 2251 : 			currentRank.issueRAS(time, thisCommand);			

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [ebx+8]
	push	ebp
	push	eax
	mov	eax, DWORD PTR _currentRank$[esp+48]
	push	ecx
	call	?issueRAS@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issueRAS

; 2252 : 
; 2253 : 			// specific for RAS command
; 2254 : 			thisCommand->setCompletionTime(thisCommand->getStartTime() + timingSpecification.tCMD() + timingSpecification.tRAS());

	mov	eax, DWORD PTR [ebx+56]
$LN420@executeCom:
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+44]
	mov	esi, edx
	cdq
	add	ecx, eax
	adc	esi, edx
	add	ecx, DWORD PTR [ebp+24]

; 2381 : 		break;
; 2382 : 	}	
; 2383 : 
; 2384 : 	// inserts into a queue which dequeues into the command pool
; 2385 : 	retireCommand(thisCommand);

	push	ebx
	adc	esi, DWORD PTR [ebp+28]
	mov	eax, ebp
	mov	DWORD PTR [ebp+32], ecx
	mov	DWORD PTR [ebp+36], esi
	call	?retireCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::retireCommand

; 2386 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	8
$LN31@executeCom:

; 2255 : 			assert(!thisCommand->getHost());
; 2256 : 		}
; 2257 : 		break;
; 2258 : 
; 2259 : 	case Command::READ_AND_PRECHARGE:
; 2260 : 
; 2261 : 		// precharge may be issued first because timings are based on time, not the last time at which a read command was issued		
; 2262 : 		assert(currentBank.isActivated());
; 2263 : 		currentRank.issuePRE(time, thisCommand);

	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _currentRank$[esp+52]
	call	?issuePRE@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issuePRE
$LN30@executeCom:

; 2264 : 		// lack of break is intentional
; 2265 : 
; 2266 : 	case Command::READ:
; 2267 : 
; 2268 : 		//currentRank.issueCAS(time, thisCommand);
; 2269 : 
; 2270 : 		// specific for CAS command
; 2271 : 		// should account for tAL buffering the CAS command until the right moment
; 2272 : 		//thisCommand->setCompletionTime(max(currentBank.getLastRASTime() + timingSpecification.tRCD() + timingSpecification.tCAS() + timingSpecification.tBurst(), time + timingSpecification.tCMD() + timingSpecification.tCAS() + timingSpecification.tBurst()));
; 2273 : 		assert(wasActivated);
; 2274 : 		assert(currentBank.getOpenRowID() == thisCommand->getAddress().getRow());
; 2275 : 		thisCommand->setCompletionTime(max(currentBank.getLastRASTime() + timingSpecification.tRCD() + timingSpecification.tCAS() + timingSpecification.tBurst(), time + timingSpecification.tAL() + timingSpecification.tCAS() + timingSpecification.tBurst()));

	mov	eax, DWORD PTR [ebx+36]
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR tv1327[esp+48], edx
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR [ebx+64]
	mov	DWORD PTR tv1332[esp+48], edx
	cdq
	mov	esi, eax
	mov	eax, DWORD PTR _currentBank$[esp+40]
	add	esi, DWORD PTR [eax+48]
	mov	DWORD PTR tv1327[esp+44], ecx
	adc	edx, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [ebx+28]
	add	esi, edi
	adc	edx, DWORD PTR tv1332[esp+48]
	add	esi, ecx
	mov	ecx, edx
	adc	ecx, DWORD PTR tv1327[esp+48]
	cdq
	add	eax, edi
	adc	edx, DWORD PTR tv1332[esp+48]
	add	eax, DWORD PTR tv1327[esp+44]
	adc	edx, DWORD PTR tv1327[esp+48]
	mov	DWORD PTR tv1358[esp+40], edx
	mov	edx, eax
	add	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR tv1358[esp+40]
	adc	eax, DWORD PTR [ebx+12]
	cmp	ecx, eax
	jl	SHORT $LN38@executeCom
	jg	SHORT $LN419@executeCom
	cmp	esi, edx
	jbe	SHORT $LN38@executeCom
$LN419@executeCom:
	mov	edx, esi
	mov	eax, ecx
$LN38@executeCom:

; 2276 : 		thisCommand->getHost()->setCompletionTime(thisCommand->getCompletionTime());

	mov	ecx, DWORD PTR [ebp+84]
	mov	DWORD PTR [ebp+32], edx
	mov	DWORD PTR [ebp+36], eax
	mov	DWORD PTR [ecx+32], edx
	mov	DWORD PTR [ecx+36], eax

; 2277 : 
; 2278 : 		/// @todo let each rank figure out if the command is to it or not by combining issueCAS and issueCASother
; 2279 : 		for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	mov	edi, DWORD PTR [ebx+380]
	cmp	edi, DWORD PTR [ebx+384]
	jbe	SHORT $LN123@executeCom
	call	__invalid_parameter_noinfo
$LN123@executeCom:
	mov	esi, DWORD PTR [ebx+368]
	npad	7
$LL140@executeCom:
	mov	eax, DWORD PTR [ebx+384]
	mov	DWORD PTR $T625329[esp+40], eax
	cmp	DWORD PTR [ebx+380], eax
	jbe	SHORT $LN155@executeCom
	call	__invalid_parameter_noinfo
$LN155@executeCom:
	mov	eax, DWORD PTR [ebx+368]
	test	esi, esi
	je	SHORT $LN168@executeCom
	cmp	esi, eax
	je	SHORT $LN169@executeCom
$LN168@executeCom:
	call	__invalid_parameter_noinfo
$LN169@executeCom:
	cmp	edi, DWORD PTR $T625329[esp+40]
	je	$LN34@executeCom

; 2280 : 		{
; 2281 : 			if (&currentRank != &*i)

	test	esi, esi
	jne	SHORT $LN417@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN187@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN178@executeCom
	call	__invalid_parameter_noinfo
$LN178@executeCom:
	cmp	DWORD PTR _currentRank$[esp+40], edi
	je	SHORT $LN26@executeCom

; 2282 : 			{
; 2283 : 				//i->setOtherLastCAS(time + timingSpecification.tAL(),thisCommand->getLength());
; 2284 : 				i->issueCASother(time, thisCommand);

	test	esi, esi
	jne	SHORT $LN416@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN203@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN194@executeCom
	call	__invalid_parameter_noinfo
$LN194@executeCom:
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [ebx+8]
	push	ecx
	push	edx
	push	edi
	mov	ecx, ebp
	call	?issueCASother@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issueCASother

; 2285 : 			}
; 2286 : 			else

	jmp	SHORT $LN28@executeCom
$LN417@executeCom:

; 2280 : 		{
; 2281 : 			if (&currentRank != &*i)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN187@executeCom
$LN416@executeCom:

; 2282 : 			{
; 2283 : 				//i->setOtherLastCAS(time + timingSpecification.tAL(),thisCommand->getLength());
; 2284 : 				i->issueCASother(time, thisCommand);

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN203@executeCom
$LN26@executeCom:

; 2287 : 			{
; 2288 : 				i->issueCAS(time, thisCommand);

	test	esi, esi
	jne	SHORT $LN415@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN219@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN210@executeCom
	call	__invalid_parameter_noinfo
$LN210@executeCom:
	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [ebx+8]
	push	ebp
	push	eax
	push	ecx
	call	?issueCAS@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issueCAS
$LN28@executeCom:

; 2277 : 
; 2278 : 		/// @todo let each rank figure out if the command is to it or not by combining issueCAS and issueCASother
; 2279 : 		for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	test	esi, esi
	jne	SHORT $LN414@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN147@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN138@executeCom
	call	__invalid_parameter_noinfo
$LN138@executeCom:
	add	edi, 200				; 000000c8H
	jmp	$LL140@executeCom
$LN415@executeCom:

; 2287 : 			{
; 2288 : 				i->issueCAS(time, thisCommand);

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN219@executeCom
$LN414@executeCom:

; 2277 : 
; 2278 : 		/// @todo let each rank figure out if the command is to it or not by combining issueCAS and issueCASother
; 2279 : 		for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN147@executeCom
$LN24@executeCom:

; 2289 : 			}
; 2290 : 		}
; 2291 : 		break;
; 2292 : 
; 2293 : 	case Command::WRITE_AND_PRECHARGE:
; 2294 : 
; 2295 : 		// precharge may be issued first because timings are based on time, not the last time at which a read command was issued
; 2296 : 		currentRank.issuePRE(time, thisCommand);		

	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _currentRank$[esp+52]
	call	?issuePRE@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issuePRE
$LN23@executeCom:

; 2297 : 		// missing break is intentional
; 2298 : 
; 2299 : 	case Command::WRITE:
; 2300 : 
; 2301 : 		//currentRank.issueCASW(time, thisCommand);
; 2302 : 
; 2303 : 		// for the CAS write command
; 2304 : 		//thisCommand->setCompletionTime(time + timingSpecification.tCMD() + timingSpecification.tCWD() + timingSpecification.tBurst() + timingSpecification.tWR());
; 2305 : 		assert(wasActivated);
; 2306 : 		assert(currentBank.getOpenRowID() == thisCommand->getAddress().getRow());
; 2307 : 		thisCommand->setCompletionTime(time + timingSpecification.tCMD() + timingSpecification.tCWD() + timingSpecification.tBurst());

	mov	eax, DWORD PTR [ebx+48]
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+44]
	mov	esi, edx
	cdq
	add	ecx, eax
	mov	eax, DWORD PTR [ebx+32]
	adc	esi, edx
	cdq
	add	ecx, eax

; 2308 : 		//thisCommand->getHost()->setCompletionTime(time);
; 2309 : 		thisCommand->getHost()->setCompletionTime(thisCommand->getCompletionTime());

	mov	eax, DWORD PTR [ebp+84]
	adc	esi, edx
	add	ecx, DWORD PTR [ebx+8]
	adc	esi, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebp+32], ecx
	mov	DWORD PTR [ebp+36], esi
	mov	edx, ecx
	mov	DWORD PTR [eax+32], edx
	mov	ecx, DWORD PTR [ebp+36]
	mov	DWORD PTR [eax+36], ecx

; 2310 : 
; 2311 : 		/// @todo let each rank figure out if the command is to it or not by combining issueCAS and issueCASother
; 2312 : 		for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	mov	edi, DWORD PTR [ebx+380]
	cmp	edi, DWORD PTR [ebx+384]
	jbe	SHORT $LN241@executeCom
	call	__invalid_parameter_noinfo
$LN241@executeCom:
	mov	esi, DWORD PTR [ebx+368]
$LL258@executeCom:
	mov	eax, DWORD PTR [ebx+384]
	mov	DWORD PTR $T625743[esp+40], eax
	cmp	DWORD PTR [ebx+380], eax
	jbe	SHORT $LN273@executeCom
	call	__invalid_parameter_noinfo
$LN273@executeCom:
	mov	eax, DWORD PTR [ebx+368]
	test	esi, esi
	je	SHORT $LN286@executeCom
	cmp	esi, eax
	je	SHORT $LN287@executeCom
$LN286@executeCom:
	call	__invalid_parameter_noinfo
$LN287@executeCom:
	cmp	edi, DWORD PTR $T625743[esp+40]
	je	$LN34@executeCom

; 2313 : 		{
; 2314 : 			if (&currentRank != &*i)

	test	esi, esi
	jne	SHORT $LN413@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN305@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN296@executeCom
	call	__invalid_parameter_noinfo
$LN296@executeCom:
	cmp	DWORD PTR _currentRank$[esp+40], edi
	je	SHORT $LN19@executeCom

; 2315 : 			{
; 2316 : 				//i->setOtherLastCASW(time + timingSpecification.tAL(),thisCommand->getLength());
; 2317 : 				i->issueCASWother(time, thisCommand);

	test	esi, esi
	jne	SHORT $LN412@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN321@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN312@executeCom
	call	__invalid_parameter_noinfo
$LN312@executeCom:
	mov	edx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+8]
	push	edx
	push	eax
	push	edi
	mov	ecx, ebp
	call	?issueCASWother@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issueCASWother

; 2318 : 			}
; 2319 : 			else

	jmp	SHORT $LN21@executeCom
$LN413@executeCom:

; 2313 : 		{
; 2314 : 			if (&currentRank != &*i)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN305@executeCom
$LN412@executeCom:

; 2315 : 			{
; 2316 : 				//i->setOtherLastCASW(time + timingSpecification.tAL(),thisCommand->getLength());
; 2317 : 				i->issueCASWother(time, thisCommand);

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN321@executeCom
$LN19@executeCom:

; 2320 : 			{
; 2321 : 				i->issueCASW(time,thisCommand);

	test	esi, esi
	jne	SHORT $LN411@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN337@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN328@executeCom
	call	__invalid_parameter_noinfo
$LN328@executeCom:
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [ebx+8]
	push	ecx
	push	edx
	mov	eax, ebp
	mov	ecx, edi
	call	?issueCASW@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issueCASW
$LN21@executeCom:

; 2310 : 
; 2311 : 		/// @todo let each rank figure out if the command is to it or not by combining issueCAS and issueCASother
; 2312 : 		for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	test	esi, esi
	jne	SHORT $LN410@executeCom
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN265@executeCom:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN256@executeCom
	call	__invalid_parameter_noinfo
$LN256@executeCom:
	add	edi, 200				; 000000c8H
	jmp	$LL258@executeCom
$LN411@executeCom:

; 2320 : 			{
; 2321 : 				i->issueCASW(time,thisCommand);

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN337@executeCom
$LN410@executeCom:

; 2310 : 
; 2311 : 		/// @todo let each rank figure out if the command is to it or not by combining issueCAS and issueCASother
; 2312 : 		for (vector<Rank>::iterator i = rank.begin(); i != rank.end(); i++)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN265@executeCom
$LN17@executeCom:

; 2322 : 			}
; 2323 : 		}
; 2324 : 		break;
; 2325 : 
; 2326 : 	case Command::PRECHARGE:
; 2327 : 
; 2328 : 		assert(currentBank.isActivated());
; 2329 : 
; 2330 : 		// issued to the rank which issues to banks
; 2331 : 		currentRank.issuePRE(time, thisCommand);

	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _currentRank$[esp+52]
	call	?issuePRE@Rank@DRAMsimII@@QAEX_JPBVCommand@2@@Z ; DRAMsimII::Rank::issuePRE

; 2332 : 
; 2333 : 		thisCommand->setCompletionTime(thisCommand->getStartTime() + timingSpecification.tCMD() + timingSpecification.tRP());

	mov	eax, DWORD PTR [ebx+72]

; 2334 : 
; 2335 : 		break;

	jmp	$LN420@executeCom
$LN16@executeCom:

; 2336 : 
; 2337 : 	case Command::REFRESH_ALL:
; 2338 : 
; 2339 : 		for (vector<Bank>::const_iterator i = currentRank.bank.begin(); i != currentRank.bank.end(); i++)

	mov	edi, DWORD PTR _currentRank$[esp+40]
	lea	esi, DWORD PTR $T625003[esp+44]
	add	edi, 172				; 000000acH
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _i$220060[esp+44], esi
	mov	DWORD PTR _i$220060[esp+48], edx
$LL15@executeCom:
	mov	eax, DWORD PTR _currentRank$[esp+40]
	mov	edi, DWORD PTR [eax+188]
	cmp	DWORD PTR [eax+184], edi
	jbe	SHORT $LN353@executeCom
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR _currentRank$[esp+40]
$LN353@executeCom:
	mov	eax, DWORD PTR [eax+172]
	test	esi, esi
	je	SHORT $LN366@executeCom
	cmp	esi, eax
	je	SHORT $LN367@executeCom
$LN366@executeCom:
	call	__invalid_parameter_noinfo
$LN367@executeCom:
	cmp	DWORD PTR _i$220060[esp+48], edi
	je	SHORT $LN13@executeCom

; 2340 : 			if (i->isActivated())

	test	esi, esi
	jne	SHORT $LN409@executeCom
	call	__invalid_parameter_noinfo
$LN385@executeCom:
	mov	eax, DWORD PTR _i$220060[esp+48]
	cmp	eax, DWORD PTR [esi+16]
	jb	SHORT $LN376@executeCom
	call	__invalid_parameter_noinfo
$LN376@executeCom:
	lea	edi, DWORD PTR $T625004[esp+44]
	lea	esi, DWORD PTR _i$220060[esp+44]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	mov	esi, DWORD PTR _i$220060[esp+44]
	jmp	SHORT $LL15@executeCom
$LN409@executeCom:
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN385@executeCom
$LN13@executeCom:

; 2341 : 				assert(!i->isActivated());
; 2342 : 
; 2343 : 		currentRank.issueREF(time);

	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR _currentRank$[esp+40]
	push	ecx
	push	edx
	call	?issueREF@Rank@DRAMsimII@@QAEX_J@Z	; DRAMsimII::Rank::issueREF

; 2344 : 
; 2345 : 		thisCommand->setCompletionTime(time + timingSpecification.tCMD() + timingSpecification.tRFC());

	mov	eax, DWORD PTR [ebx+68]
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+44]
	mov	esi, edx
	cdq
	add	ecx, eax

; 2346 : 		thisCommand->getHost()->setCompletionTime(thisCommand->getCompletionTime());

	mov	eax, DWORD PTR [ebp+84]
	adc	esi, edx
	add	ecx, DWORD PTR [ebx+8]

; 2381 : 		break;
; 2382 : 	}	
; 2383 : 
; 2384 : 	// inserts into a queue which dequeues into the command pool
; 2385 : 	retireCommand(thisCommand);

	push	ebx
	adc	esi, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebp+32], ecx
	mov	DWORD PTR [ebp+36], esi
	mov	edx, ecx
	mov	DWORD PTR [eax+32], edx
	mov	ecx, DWORD PTR [ebp+36]
	mov	DWORD PTR [eax+36], ecx
	mov	eax, ebp
	call	?retireCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::retireCommand

; 2386 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	8
$LN1@executeCom:

; 2347 : 		break;
; 2348 : 
; 2349 : 	case Command::RETIRE_COMMAND:
; 2350 : 		break;	
; 2351 : 
; 2352 : 	case Command::PRECHARGE_ALL:
; 2353 : 		break;
; 2354 : 
; 2355 : 	case Command::ACTIVATE_ALL:
; 2356 : 		break;
; 2357 : 
; 2358 : 	case Command::DRIVE_COMMAND:
; 2359 : 		break;
; 2360 : 
; 2361 : 	case Command::DATA_COMMAND:
; 2362 : 		break;
; 2363 : 
; 2364 : 	case Command::CAS_WITH_DRIVE_COMMAND:
; 2365 : 		break;	
; 2366 : 
; 2367 : 	case Command::SELF_REFRESH:
; 2368 : 		break;
; 2369 : 
; 2370 : 	case Command::DESELECT:
; 2371 : 		break;
; 2372 : 
; 2373 : 	case Command::NOOP:
; 2374 : 		break;
; 2375 : 
; 2376 : 	case Command::INVALID_COMMAND:
; 2377 : 		break;
; 2378 : 
; 2379 : 	default:
; 2380 : 		cerr << "Unknown command type" << endl;

	push	OFFSET ??_C@_0BF@IGPJINBF@Unknown?5command?5type?$AA@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN34@executeCom:

; 2381 : 		break;
; 2382 : 	}	
; 2383 : 
; 2384 : 	// inserts into a queue which dequeues into the command pool
; 2385 : 	retireCommand(thisCommand);

	push	ebx
	mov	eax, ebp
	call	?retireCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::retireCommand

; 2386 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	8
	npad	3
$LN421@executeCom:
	DD	$LN33@executeCom
	DD	$LN30@executeCom
	DD	$LN31@executeCom
	DD	$LN23@executeCom
	DD	$LN24@executeCom
	DD	$LN34@executeCom
	DD	$LN17@executeCom
	DD	$LN16@executeCom
$LN418@executeCom:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	7
	DB	5
	DB	5
	DB	5
	DB	5
?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ENDP ; DRAMsimII::Channel::executeCommand
_TEXT	ENDS
PUBLIC	?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ ; DRAMsimII::Channel::readNextRefresh
;	COMDAT ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A
; File c:\program files\microsoft visual studio 9.0\vc\include\new
_BSS	SEGMENT
?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A DB 070H DUP (?) ; `DRAMsimII::Channel::readNextRefresh'::`7'::newRefreshTransaction
_BSS	ENDS
;	COMDAT ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A
_BSS	SEGMENT
?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A DB 028H DUP (?) ; `DRAMsimII::Channel::readNextRefresh'::`7'::address
_BSS	ENDS
;	COMDAT ?$S1@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4IA
_BSS	SEGMENT
?$S1@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4IA DD 01H DUP (?) ; `DRAMsimII::Channel::readNextRefresh'::`7'::$S1
__unwindtable$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ$1
__ehfuncinfo$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
_earliestRank$ = -28					; size = 4
_earliestTime$ = -24					; size = 8
__$EHRec$ = -12						; size = 12
_currentRank$ = 8					; size = 4
_this$ = 8						; size = 4
?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ PROC ; DRAMsimII::Channel::readNextRefresh

; 880  : {

	push	-1
	push	__ehhandler$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _this$[esp+44]

; 881  : 	assert(rank.size() >= 1);
; 882  : 
; 883  : 	unsigned currentRank = 0;

	xor	eax, eax
	mov	DWORD PTR _currentRank$[esp+44], eax

; 884  : 	unsigned earliestRank = 0;

	mov	DWORD PTR _earliestRank$[esp+48], eax

; 885  : 	tick earliestTime = refreshCounter[0];

	mov	eax, DWORD PTR [ebp+168]
	sub	eax, DWORD PTR [ebp+164]
	sar	eax, 3
	test	eax, eax
	ja	SHORT $LN14@readNextRe
	call	__invalid_parameter_noinfo
$LN14@readNextRe:
	mov	eax, DWORD PTR [ebp+164]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 886  : 
; 887  : 	for (vector<tick>::const_iterator i = refreshCounter.begin(); i != refreshCounter.end(); i++, currentRank++)

	mov	esi, eax
	mov	DWORD PTR _earliestTime$[esp+48], ecx
	mov	DWORD PTR _earliestTime$[esp+52], edx
	cmp	esi, DWORD PTR [ebp+168]
	jbe	SHORT $LN22@readNextRe
	call	__invalid_parameter_noinfo
$LN22@readNextRe:
	mov	edi, DWORD PTR [ebp+152]
	npad	11
$LL6@readNextRe:
	mov	ebx, DWORD PTR [ebp+168]
	cmp	DWORD PTR [ebp+164], ebx
	jbe	SHORT $LN50@readNextRe
	call	__invalid_parameter_noinfo
$LN50@readNextRe:
	mov	eax, DWORD PTR [ebp+152]
	test	edi, edi
	je	SHORT $LN63@readNextRe
	cmp	edi, eax
	je	SHORT $LN64@readNextRe
$LN63@readNextRe:
	call	__invalid_parameter_noinfo
$LN64@readNextRe:
	cmp	esi, ebx
	je	SHORT $LN4@readNextRe

; 888  : 	{
; 889  : 		if (*i < earliestTime)

	test	edi, edi
	jne	SHORT $LN111@readNextRe
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN80@readNextRe:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN71@readNextRe
	call	__invalid_parameter_noinfo
$LN71@readNextRe:
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR _earliestTime$[esp+52]
	jg	SHORT $LN5@readNextRe
	jl	SHORT $LN112@readNextRe
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR _earliestTime$[esp+48]
	jae	SHORT $LN5@readNextRe
$LN112@readNextRe:

; 890  : 		{
; 891  : 			earliestRank = currentRank;

	mov	edx, DWORD PTR _currentRank$[esp+44]
	mov	DWORD PTR _earliestRank$[esp+48], edx

; 892  : 			earliestTime = *i;

	test	edi, edi
	jne	SHORT $LN110@readNextRe
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN92@readNextRe:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN83@readNextRe
	call	__invalid_parameter_noinfo
$LN83@readNextRe:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _earliestTime$[esp+48], eax
	mov	DWORD PTR _earliestTime$[esp+52], ecx
$LN5@readNextRe:

; 886  : 
; 887  : 	for (vector<tick>::const_iterator i = refreshCounter.begin(); i != refreshCounter.end(); i++, currentRank++)

	test	edi, edi
	jne	SHORT $LN109@readNextRe
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN44@readNextRe:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN35@readNextRe
	call	__invalid_parameter_noinfo
$LN35@readNextRe:
	add	esi, 8
	inc	DWORD PTR _currentRank$[esp+44]
	jmp	$LL6@readNextRe
$LN111@readNextRe:

; 888  : 	{
; 889  : 		if (*i < earliestTime)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN80@readNextRe
$LN110@readNextRe:

; 892  : 			earliestTime = *i;

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN92@readNextRe
$LN109@readNextRe:

; 886  : 
; 887  : 	for (vector<tick>::const_iterator i = refreshCounter.begin(); i != refreshCounter.end(); i++, currentRank++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN44@readNextRe
$LN4@readNextRe:

; 893  : 		}
; 894  : 	}
; 895  : 
; 896  : 	static Address address;

	mov	ebx, DWORD PTR ?$S1@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4IA
	or	edi, -1
	test	bl, 1
	jne	SHORT $LN95@readNextRe
	or	ebx, 1
	mov	DWORD PTR ?$S1@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4IA, ebx
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A, edi
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+8, edi
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+12, edi
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+16, edi
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+20, edi
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+24, edi
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+28, edi
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+32, edi
$LN95@readNextRe:

; 897  : 
; 898  : 	address.setAddress(channelID,earliestRank,0,0,0);

	mov	edx, DWORD PTR [ebp+360]
	mov	eax, DWORD PTR _earliestRank$[esp+48]
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+20, eax
	xor	eax, eax
	mov	esi, OFFSET ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+16, edx
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+24, eax
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+32, eax
	mov	DWORD PTR ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A+28, eax
	call	?reverseAddressTranslation@Address@DRAMsimII@@IAE_NXZ ; DRAMsimII::Address::reverseAddressTranslation

; 899  : 
; 900  : 	static Transaction newRefreshTransaction;

	test	bl, 2
	jne	SHORT $LN1@readNextRe
	or	ebx, 2
	mov	DWORD PTR ?$S1@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4IA, ebx
	xor	ebx, ebx
	mov	esi, OFFSET ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A
	mov	DWORD PTR __$EHRec$[esp+56], ebx
	call	??0Event@DRAMsimII@@IAE@XZ		; DRAMsimII::Event::Event
	push	OFFSET ??__FnewRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ@YAXXZ ; `DRAMsimII::Channel::readNextRefresh'::`7'::`dynamic atexit destructor for 'newRefreshTransaction''
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A, OFFSET ??_7Transaction@DRAMsimII@@6B@
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+80, 7
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+84, ebx
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+88, ebx
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+92, ebx
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+96, ebx
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+100, ebx
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+104, ebx
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A+108, edi
	call	_atexit
	add	esp, 4
$LN1@readNextRe:

; 901  : 	::new(&newRefreshTransaction)Transaction(Transaction::AUTO_REFRESH_TRANSACTION, earliestTime, 8, address, 0, 0, UINT_MAX);

	mov	ecx, DWORD PTR _earliestTime$[esp+52]
	mov	edx, DWORD PTR _earliestTime$[esp+48]
	push	edi
	push	8
	push	ecx
	push	edx
	push	4
	mov	edx, OFFSET ?address@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4VAddress@3@A
	mov	eax, OFFSET ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A
	call	??0Transaction@DRAMsimII@@QAE@W4TransactionType@01@_JIABVAddress@1@_KHI@Z ; DRAMsimII::Transaction::Transaction

; 902  : 
; 903  : 	return &newRefreshTransaction;
; 904  : 
; 905  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	4
__unwindfunclet$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ$1:
	mov	eax, DWORD PTR ?$S1@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4IA
	and	eax, -3					; fffffffdH
	mov	DWORD PTR ?$S1@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4IA, eax
	ret	0
__ehhandler$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-32]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ
	jmp	___CxxFrameHandler3
?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ ENDP ; DRAMsimII::Channel::readNextRefresh
PUBLIC	?getAvailableTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@I@Z ; DRAMsimII::Channel::getAvailableTransaction
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?getAvailableTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@I@Z PROC ; DRAMsimII::Channel::getAvailableTransaction
; _this$ = ecx
; _useThis$ = eax

; 802  : {

	push	esi
	mov	esi, ecx

; 803  : 	if (useThis < UINT_MAX)

	cmp	eax, -1
	jae	SHORT $LN4@getAvailab
$LN7@getAvailab:

; 804  : 		return transactionQueue.remove(useThis);

	add	esi, 112				; 00000070H
	call	?remove@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::remove

; 812  : 	}
; 813  : }

	pop	esi
	ret	0
$LN4@getAvailab:

; 805  : 	else
; 806  : 	{
; 807  : 		unsigned val = readAvailableTransaction(true);

	push	1
	call	?readAvailableTransaction@Channel@DRAMsimII@@IBEI_N@Z ; DRAMsimII::Channel::readAvailableTransaction

; 808  : 		if (val < UINT_MAX)

	cmp	eax, -1

; 809  : 			return transactionQueue.remove(val);

	jb	SHORT $LN7@getAvailab

; 810  : 		else
; 811  : 			return NULL;

	xor	eax, eax

; 812  : 	}
; 813  : }

	pop	esi
	ret	0
?getAvailableTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@I@Z ENDP ; DRAMsimII::Channel::getAvailableTransaction
_TEXT	ENDS
PUBLIC	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_nextRefresh$218988 = -8				; size = 8
_bufferDelay$ = 8					; size = 1
?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z PROC ; DRAMsimII::Channel::readTransaction
; _this$ = eax

; 722  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 723  : 	const unsigned delay = bufferDelay ? timingSpecification.tBufferDelay() : 0;

	mov	eax, DWORD PTR _bufferDelay$[esp+16]
	push	edi
	test	al, al
	je	SHORT $LN10@readTransa
	mov	ebx, DWORD PTR [esi+104]
	jmp	SHORT $LN11@readTransa
$LN10@readTransa:
	xor	ebx, ebx
$LN11@readTransa:

; 724  : 
; 725  : 	unsigned val = readAvailableTransaction(bufferDelay);

	push	eax
	call	?readAvailableTransaction@Channel@DRAMsimII@@IBEI_N@Z ; DRAMsimII::Channel::readAvailableTransaction
	mov	ecx, eax

; 726  : 
; 727  : 	const Transaction *nextTransaction = (val < UINT_MAX) ? transactionQueue[val] : NULL;

	cmp	ecx, -1
	jae	SHORT $LN12@readTransa
	cmp	ecx, DWORD PTR [esi+112]
	jge	SHORT $LN12@readTransa
	test	ecx, ecx
	jl	SHORT $LN12@readTransa
	mov	edi, DWORD PTR [esi+140]
	sub	edi, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+116]
	add	eax, ecx
	sar	edi, 2
	xor	edx, edx
	div	edi
	mov	eax, DWORD PTR [esi+140]
	sub	eax, DWORD PTR [esi+136]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN27@readTransa
	call	__invalid_parameter_noinfo
$LN27@readTransa:
	mov	ecx, DWORD PTR [esi+136]
	mov	edi, DWORD PTR [ecx+edi*4]
	jmp	SHORT $LN13@readTransa
$LN12@readTransa:
	xor	edi, edi
$LN13@readTransa:

; 728  : 
; 729  : 	if (systemConfig.getRefreshPolicy() == NO_REFRESH)

	mov	edx, DWORD PTR [esi+176]
	cmp	DWORD PTR [edx+304], 0
	jne	SHORT $LN7@readTransa

; 730  : 	{
; 731  : 		if ((nextTransaction) && (time >= nextTransaction->getEnqueueTime() + delay))

	test	edi, edi
	je	$LN2@readTransa
	mov	eax, DWORD PTR [edi+20]
	mov	edx, DWORD PTR [esi+12]
	xor	ecx, ecx
	add	ebx, DWORD PTR [edi+16]
	adc	eax, ecx
	cmp	edx, eax
	jl	$LN2@readTransa
	jg	SHORT $LN40@readTransa
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, ebx
	jb	$LN2@readTransa
$LN40@readTransa:

; 732  : 		{
; 733  : 			return nextTransaction;

	mov	eax, edi

; 752  : 		}
; 753  : 	}
; 754  : 	return NULL;
; 755  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
$LN7@readTransa:

; 734  : 		}
; 735  : 	}
; 736  : 	else
; 737  : 	{
; 738  : 		const tick nextRefresh = nextRefreshTime();

	mov	eax, esi
	call	?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextRefreshTime
	mov	DWORD PTR _nextRefresh$218988[esp+24], eax
	mov	DWORD PTR _nextRefresh$218988[esp+28], edx

; 739  : 
; 740  : 		// give an advantage to normal transactions, but prevent starvation for refresh operations
; 741  : 		// if there is a normal transaction ready to go, it's ready to go and the refresh command isn't starving
; 742  : 		if (nextTransaction &&
; 743  : 			((time < nextRefresh + systemConfig.getSeniorityAgeLimit()) &&
; 744  : 			(time >= nextTransaction->getEnqueueTime() + delay)))

	test	edi, edi
	je	SHORT $LN4@readTransa
	mov	ecx, DWORD PTR [esi+176]
	mov	ebp, DWORD PTR [ecx+320]
	mov	eax, DWORD PTR [esi+12]
	xor	ecx, ecx
	add	ebp, DWORD PTR _nextRefresh$218988[esp+24]
	adc	ecx, edx
	cmp	eax, ecx
	jg	SHORT $LN4@readTransa
	jl	SHORT $LN41@readTransa
	cmp	DWORD PTR [esi+8], ebp
	jae	SHORT $LN4@readTransa
$LN41@readTransa:
	mov	ecx, DWORD PTR [edi+20]
	xor	ebp, ebp
	add	ebx, DWORD PTR [edi+16]
	adc	ecx, ebp
	cmp	eax, ecx
	jl	SHORT $LN4@readTransa
	jg	SHORT $LN40@readTransa
	cmp	DWORD PTR [esi+8], ebx

; 745  : 		{
; 746  : 			return nextTransaction;

	jae	SHORT $LN40@readTransa
$LN4@readTransa:

; 747  : 		}
; 748  : 		// either there is no transaction or the refresh command will starve
; 749  : 		else if (((time >= nextRefresh) || !bufferDelay) && (checkForAvailableCommandSlots(readNextRefresh())))

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, edx
	jg	SHORT $LN1@readTransa
	jl	SHORT $LN43@readTransa
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, DWORD PTR _nextRefresh$218988[esp+24]
	jae	SHORT $LN1@readTransa
$LN43@readTransa:
	cmp	BYTE PTR _bufferDelay$[esp+20], 0
	jne	SHORT $LN2@readTransa
$LN1@readTransa:
	push	esi
	call	?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ ; DRAMsimII::Channel::readNextRefresh
	push	esi
	call	?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z ; DRAMsimII::Channel::checkForAvailableCommandSlots
	test	al, al
	je	SHORT $LN2@readTransa

; 750  : 		{
; 751  : 			return readNextRefresh();

	push	esi
	call	?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ ; DRAMsimII::Channel::readNextRefresh

; 752  : 		}
; 753  : 	}
; 754  : 	return NULL;
; 755  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
$LN2@readTransa:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx
	add	esp, 8
	ret	4
?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ENDP ; DRAMsimII::Channel::readTransaction
_TEXT	ENDS
PUBLIC	?nextTransactionDecodeTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextTransactionDecodeTime
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?nextTransactionDecodeTime@Channel@DRAMsimII@@IBE_JXZ PROC ; DRAMsimII::Channel::nextTransactionDecodeTime
; _this$ = esi

; 287  : {	

	push	ecx

; 288  : 	if (const Transaction *nextTrans = readTransaction(false))

	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN1@nextTransa

; 289  : 	{
; 290  : 		if (nextTrans)
; 291  : 		{
; 292  : 			if (nextTrans->isRefresh())

	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN2@nextTransa

; 293  : 				return nextTrans->getArrivalTime();

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	pop	ecx

; 300  : }

	ret	0
$LN2@nextTransa:

; 294  : 			else
; 295  : 				return nextTrans->getEnqueueTime() + timingSpecification.tBufferDelay();

	mov	eax, DWORD PTR [esi+104]
	cdq
	add	eax, DWORD PTR [ecx+16]
	adc	edx, DWORD PTR [ecx+20]
	pop	ecx

; 300  : }

	ret	0
$LN1@nextTransa:

; 296  : 		}
; 297  : 	}
; 298  : 
; 299  : 	return TICK_MAX;

	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
	pop	ecx

; 300  : }

	ret	0
?nextTransactionDecodeTime@Channel@DRAMsimII@@IBE_JXZ ENDP ; DRAMsimII::Channel::nextTransactionDecodeTime
; Function compile flags: /Ogtpy
?nextTick@Channel@DRAMsimII@@UBE_JXZ PROC		; DRAMsimII::Channel::nextTick
; _this$ = ecx

; 276  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 277  : 	return max(min(min(nextTransactionDecodeTime(),nextCommandExecuteTime()),nextRefreshTime()),time + 1);

	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	mov	ebp, 4
	test	ecx, ecx
	je	SHORT $LN17@nextTick@2
	cmp	DWORD PTR [ecx+80], ebp
	jne	SHORT $LN18@nextTick@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN21@nextTick@2
$LN18@nextTick@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN21@nextTick@2
$LN17@nextTick@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN21@nextTick@2:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	SHORT $LN32@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN31@nextTick@2
$LN32@nextTick@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN31@nextTick@2:
	cmp	edi, edx
	jg	SHORT $LN3@nextTick@2
	jl	SHORT $LN154@nextTick@2
	cmp	ebx, eax
	jae	SHORT $LN3@nextTick@2
$LN154@nextTick@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN50@nextTick@2
	cmp	DWORD PTR [ecx+80], ebp
	jne	SHORT $LN36@nextTick@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN49@nextTick@2
$LN36@nextTick@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN49@nextTick@2
$LN3@nextTick@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN50@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	mov	ebx, eax
	mov	edi, edx
	jmp	SHORT $LN49@nextTick@2
$LN50@nextTick@2:
	mov	edi, 2147483647				; 7fffffffH
	or	ebx, -1
$LN49@nextTick@2:
	mov	eax, esi
	call	?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextRefreshTime
	cmp	edi, edx
	jg	$LN7@nextTick@2
	jl	SHORT $LN155@nextTick@2
	cmp	ebx, eax
	jae	$LN7@nextTick@2
$LN155@nextTick@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN53@nextTick@2
	cmp	DWORD PTR [ecx+80], ebp
	jne	SHORT $LN54@nextTick@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN57@nextTick@2
$LN54@nextTick@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN57@nextTick@2
$LN53@nextTick@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN57@nextTick@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN68@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN67@nextTick@2
$LN68@nextTick@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN67@nextTick@2:
	cmp	edi, edx
	jg	SHORT $LN5@nextTick@2
	jl	SHORT $LN156@nextTick@2
	cmp	ebx, eax
	jae	SHORT $LN5@nextTick@2
$LN156@nextTick@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN86@nextTick@2
	cmp	DWORD PTR [ecx+80], ebp
	jne	SHORT $LN72@nextTick@2
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	jmp	SHORT $LN8@nextTick@2
$LN72@nextTick@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	add	eax, DWORD PTR [ecx+16]
	adc	edx, DWORD PTR [ecx+20]
	jmp	SHORT $LN8@nextTick@2
$LN5@nextTick@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN86@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN8@nextTick@2
$LN86@nextTick@2:
	mov	edx, 2147483647				; 7fffffffH
	or	eax, -1
	jmp	SHORT $LN8@nextTick@2
$LN7@nextTick@2:
	mov	eax, esi
	call	?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextRefreshTime
$LN8@nextTick@2:
	mov	edi, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+12]
	add	edi, 1
	adc	ecx, 0
	cmp	edx, ecx
	jl	$LN15@nextTick@2
	jg	SHORT $LN157@nextTick@2
	cmp	eax, edi
	jbe	$LN15@nextTick@2
$LN157@nextTick@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN89@nextTick@2
	cmp	DWORD PTR [ecx+80], ebp
	jne	SHORT $LN90@nextTick@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN93@nextTick@2
$LN90@nextTick@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN93@nextTick@2
$LN89@nextTick@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN93@nextTick@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN104@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN103@nextTick@2
$LN104@nextTick@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN103@nextTick@2:
	cmp	edi, edx
	jg	SHORT $LN9@nextTick@2
	jl	SHORT $LN158@nextTick@2
	cmp	ebx, eax
	jae	SHORT $LN9@nextTick@2
$LN158@nextTick@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN122@nextTick@2
	cmp	DWORD PTR [ecx+80], ebp
	jne	SHORT $LN108@nextTick@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN121@nextTick@2
$LN108@nextTick@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN121@nextTick@2
$LN9@nextTick@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN122@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	mov	ebx, eax
	mov	edi, edx
	jmp	SHORT $LN121@nextTick@2
$LN122@nextTick@2:
	mov	edi, 2147483647				; 7fffffffH
	or	ebx, -1
$LN121@nextTick@2:
	mov	eax, esi
	call	?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextRefreshTime
	cmp	edi, edx
	jg	$LN13@nextTick@2
	jl	SHORT $LN159@nextTick@2
	cmp	ebx, eax
	jae	$LN13@nextTick@2
$LN159@nextTick@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN125@nextTick@2
	cmp	DWORD PTR [ecx+80], ebp
	jne	SHORT $LN126@nextTick@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN129@nextTick@2
$LN126@nextTick@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN129@nextTick@2
$LN125@nextTick@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN129@nextTick@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN140@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN139@nextTick@2
$LN140@nextTick@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN139@nextTick@2:
	cmp	edi, edx
	jg	SHORT $LN11@nextTick@2
	jl	SHORT $LN160@nextTick@2
	cmp	ebx, eax
	jae	SHORT $LN11@nextTick@2
$LN160@nextTick@2:
	call	?nextTransactionDecodeTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextTransactionDecodeTime

; 278  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@nextTick@2:

; 277  : 	return max(min(min(nextTransactionDecodeTime(),nextCommandExecuteTime()),nextRefreshTime()),time + 1);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN144@nextTick@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax

; 278  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0

; 277  : 	return max(min(min(nextTransactionDecodeTime(),nextCommandExecuteTime()),nextRefreshTime()),time + 1);

$LN144@nextTick@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH

; 278  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@nextTick@2:

; 277  : 	return max(min(min(nextTransactionDecodeTime(),nextCommandExecuteTime()),nextRefreshTime()),time + 1);

	mov	eax, esi
	call	?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextRefreshTime

; 278  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@nextTick@2:

; 277  : 	return max(min(min(nextTransactionDecodeTime(),nextCommandExecuteTime()),nextRefreshTime()),time + 1);

	mov	eax, edi

; 278  : }

	pop	edi
	mov	edx, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?nextTick@Channel@DRAMsimII@@UBE_JXZ ENDP		; DRAMsimII::Channel::nextTick
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapdramsimwssoaphttpproxy.h
_TEXT	ENDS
;	COMDAT ??1DRAMsimWSSoapHttp@@UAE@XZ
_TEXT	SEGMENT
??1DRAMsimWSSoapHttp@@UAE@XZ PROC			; DRAMsimWSSoapHttp::~DRAMsimWSSoapHttp, COMDAT
; _this$ = ecx

; 31   : 	virtual ~DRAMsimWSSoapHttp() { if (soap) { soap_destroy(soap); soap_end(soap); soap_free(soap); } };

	push	ebx
	mov	ebx, ecx
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], OFFSET ??_7DRAMsimWSSoapHttp@@6B@
	test	esi, esi
	je	SHORT $LN17@DRAMsimWSS@2
	movzx	eax, WORD PTR [esi+4]
	cmp	ax, 1
	je	SHORT $LN14@DRAMsimWSS@2
	cmp	ax, 2
	jne	SHORT $LN13@DRAMsimWSS@2
$LN14@DRAMsimWSS@2:
	cmp	DWORD PTR [esi+96], 0
	je	SHORT $LN5@DRAMsimWSS@2
	push	edi
$LL6@DRAMsimWSS@2:
	mov	edi, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+96], eax
	mov	ecx, DWORD PTR [edi+16]
	push	edi
	call	ecx
	push	edi
	call	_free
	add	esp, 8
	cmp	DWORD PTR [esi+96], 0
	jne	SHORT $LL6@DRAMsimWSS@2
	pop	edi
$LN5@DRAMsimWSS@2:
	mov	DWORD PTR [esi+12208], 0
	mov	DWORD PTR [esi+12204], 0
$LN13@DRAMsimWSS@2:
	mov	eax, DWORD PTR [ebx+4]
	call	_soap_end
	mov	ebx, DWORD PTR [ebx+4]
	mov	eax, ebx
	call	_soap_done
	push	ebx
	call	_free
	add	esp, 4
$LN17@DRAMsimWSS@2:
	pop	esi
	pop	ebx
	ret	0
??1DRAMsimWSSoapHttp@@UAE@XZ ENDP			; DRAMsimWSSoapHttp::~DRAMsimWSSoapHttp
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0DRAMsimWSSoapHttp@@QAE@XZ
_TEXT	SEGMENT
??0DRAMsimWSSoapHttp@@QAE@XZ PROC			; DRAMsimWSSoapHttp::DRAMsimWSSoapHttp, COMDAT
; _this$ = edi

; 18   : 	DRAMsimWSSoapHttp()

	push	esi
	push	95832					; 00017658H
	mov	DWORD PTR [edi], OFFSET ??_7DRAMsimWSSoapHttp@@6B@
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN9@DRAMsimWSS@3
	mov	edx, esi
	call	_soap_init
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+8], 0
$LN9@DRAMsimWSS@3:
	mov	DWORD PTR [edi+4], esi
	mov	DWORD PTR [edi+8], OFFSET ??_C@_0DJ@LMOMBNJL@http?3?1?1id2?4gentag?4com?37777?1DRAMs@

; 19   : 	{ soap = soap_new(); endpoint = "http://id2.gentag.com:7777/DRAMsim/DRAMsimWSSoapHttpPort"; if (soap && !soap->namespaces) { static const struct Namespace namespaces[] = 
; 20   : {
; 21   : 	{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL},
; 22   : 	{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL},
; 23   : 	{"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
; 24   : 	{"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
; 25   : 	{"ns1", "http://DRAMsimReporter/", NULL, NULL},
; 26   : 	{"ns2", "http://DRAMsimReporter/types/", NULL, NULL},
; 27   : 	{NULL, NULL, NULL, NULL}
; 28   : };
; 29   : 	soap->namespaces = namespaces; } };

	mov	eax, edi
	test	esi, esi
	je	SHORT $LN1@DRAMsimWSS@3

; 18   : 	DRAMsimWSSoapHttp()

	cmp	DWORD PTR [esi+80], 0
	jne	SHORT $LN1@DRAMsimWSS@3

; 19   : 	{ soap = soap_new(); endpoint = "http://id2.gentag.com:7777/DRAMsim/DRAMsimWSSoapHttpPort"; if (soap && !soap->namespaces) { static const struct Namespace namespaces[] = 
; 20   : {
; 21   : 	{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL},
; 22   : 	{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL},
; 23   : 	{"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
; 24   : 	{"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
; 25   : 	{"ns1", "http://DRAMsimReporter/", NULL, NULL},
; 26   : 	{"ns2", "http://DRAMsimReporter/types/", NULL, NULL},
; 27   : 	{NULL, NULL, NULL, NULL}
; 28   : };
; 29   : 	soap->namespaces = namespaces; } };

	mov	DWORD PTR [esi+80], OFFSET ?namespaces@?4???0DRAMsimWSSoapHttp@@QAE@XZ@4QBUNamespace@@B ; `DRAMsimWSSoapHttp::DRAMsimWSSoapHttp'::`5'::namespaces
$LN1@DRAMsimWSS@3:
	pop	esi
	ret	0
??0DRAMsimWSSoapHttp@@QAE@XZ ENDP			; DRAMsimWSSoapHttp::DRAMsimWSSoapHttp
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\bank.h
_TEXT	ENDS
;	COMDAT ?push@Bank@DRAMsimII@@QAE_NPAVCommand@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?push@Bank@DRAMsimII@@QAE_NPAVCommand@2@@Z PROC		; DRAMsimII::Bank::push, COMDAT
; _value$ = eax

; 103  : 		bool push(Command *value) { return perBankQueue.push(value); }

	push	eax
	mov	eax, DWORD PTR _this$[esp]
	add	eax, 8
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push
	ret	4
?push@Bank@DRAMsimII@@QAE_NPAVCommand@2@@Z ENDP		; DRAMsimII::Bank::push
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
;	COMDAT ??4?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
$T638092 = 12						; size = 4
_rhs$ = 12						; size = 4
??4?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator=, COMDAT

; 416  : 		{

	push	ebx
	mov	ebx, DWORD PTR _rhs$[esp]
	push	edi

; 417  : 			if (&rhs == this)

	mov	edi, DWORD PTR _this$[esp+4]
	cmp	ebx, edi

; 418  : 				return *this;

	je	$LN41@operator@358

; 419  : 
; 420  : 			count = rhs.count;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [edi], eax

; 421  : 			head = rhs.head;

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [edi+4], ecx

; 422  : 			tail = rhs.tail;

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edi+8], edx

; 423  : 			const_cast<bool&>(pool) = rhs.pool;

	mov	al, BYTE PTR [ebx+36]
	mov	BYTE PTR [edi+36], al

; 424  : 
; 425  : 			entry.resize(rhs.entry.size());

	mov	ecx, DWORD PTR [ebx+28]
	sub	ecx, DWORD PTR [ebx+24]
	push	ebp
	sar	ecx, 2
	lea	eax, DWORD PTR [edi+12]
	push	ecx
	call	?resize@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXIPAVTransaction@DRAMsimII@@@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::resize

; 426  : 
; 427  : 			for (unsigned i = 0; i < rhs.count; i++)

	xor	ebp, ebp
	cmp	DWORD PTR [ebx], ebp
	jbe	$LN1@operator@358
	push	esi
$LL3@operator@358:

; 428  : 			{
; 429  : 				assert(rhs.at(i));
; 430  : 
; 431  : 				entry[(head + i) % entry.size()] = new T(*(rhs.at(i)));

	call	?acquireItem@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::acquireItem
	mov	esi, eax
	test	esi, esi
	je	$LN7@operator@358
	cmp	ebp, DWORD PTR [ebx]
	jge	SHORT $LN19@operator@358
	test	ebp, ebp
	jl	SHORT $LN19@operator@358
	mov	ecx, DWORD PTR [ebx+28]
	sub	ecx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ebx+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebp
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [ebx+28]
	sub	edx, DWORD PTR [ebx+24]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN25@operator@358
	call	__invalid_parameter_noinfo
$LN25@operator@358:
	mov	eax, DWORD PTR [ebx+24]
	mov	edi, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN18@operator@358
$LN19@operator@358:
	xor	edi, edi
$LN18@operator@358:
	mov	ecx, edi
	mov	eax, esi
	call	??0Event@DRAMsimII@@IAE@ABV01@@Z	; DRAMsimII::Event::Event
	mov	DWORD PTR [esi], OFFSET ??_7Transaction@DRAMsimII@@6B@
	mov	ecx, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], ecx
	mov	edx, DWORD PTR [edi+84]
	mov	DWORD PTR [esi+84], edx
	mov	eax, DWORD PTR [edi+88]
	mov	DWORD PTR [esi+88], eax
	mov	ecx, DWORD PTR [edi+92]
	mov	DWORD PTR [esi+92], ecx
	mov	edx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], edx
	mov	eax, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], eax
	mov	ecx, DWORD PTR [edi+104]
	mov	DWORD PTR [esi+104], ecx
	mov	edx, DWORD PTR [edi+108]
	mov	edi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR [esi+108], edx
	mov	DWORD PTR $T638092[esp+12], esi
	jmp	SHORT $LN8@operator@358
$LN7@operator@358:
	mov	DWORD PTR $T638092[esp+12], 0
$LN8@operator@358:
	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [edi+4]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebp
	div	ecx
	mov	esi, edx
	mov	edx, DWORD PTR [edi+28]
	sub	edx, DWORD PTR [edi+24]
	sar	edx, 2
	cmp	esi, edx
	jb	SHORT $LN34@operator@358
	call	__invalid_parameter_noinfo
$LN34@operator@358:
	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR $T638092[esp+12]
	inc	ebp
	mov	DWORD PTR [eax+esi*4], ecx
	cmp	ebp, DWORD PTR [ebx]
	jb	$LL3@operator@358
	pop	esi
$LN1@operator@358:
	pop	ebp
$LN41@operator@358:

; 432  : 			}
; 433  : 
; 434  : 			return *this;

	mov	eax, edi
	pop	edi
	pop	ebx

; 435  : 		}

	ret	8
??4?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator=
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\queue.h
xdata$x	ENDS
;	COMDAT ??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T638213 = 12						; size = 4
$T638178 = 12						; size = 4
_rhs$ = 12						; size = 4
??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z PROC ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>, COMDAT

; 64   : 		{

	push	-1
	push	__ehhandler$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR _rhs$[esp+32]
	mov	eax, DWORD PTR [ebx]
	mov	ebp, DWORD PTR _this$[esp+32]
	mov	DWORD PTR [ebp], eax
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebp+4], ecx
	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebp+8], edx
	mov	edi, DWORD PTR [ebx+28]
	sub	edi, DWORD PTR [ebx+24]
	lea	esi, DWORD PTR [ebp+12]
	sar	edi, 2
	push	esi
	call	??0?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@I@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
	mov	DWORD PTR __$EHRec$[esp+44], 0
	mov	al, BYTE PTR [ebx+36]
	mov	BYTE PTR [ebp+36], al

; 65   : 			entry.reserve(rhs.entry.size());

	mov	ecx, DWORD PTR [ebx+28]
	sub	ecx, DWORD PTR [ebx+24]
	sar	ecx, 2
	push	ecx
	call	?reserve@?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAEXI@Z ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::reserve

; 66   : 
; 67   : 			for (unsigned i = 0; i < rhs.count; i++)

	xor	ebp, ebp
	cmp	DWORD PTR [ebx], ebp
	jbe	$LN48@Queue@8
$LL6@Queue@8:

; 68   : 			{
; 69   : 				assert(rhs.at(i) != NULL);
; 70   : 				// attempt to copy the contents of this queue
; 71   : 				entry[(head + i) % entry.size()] = new T(*rhs.at(i));

	call	?acquireItem@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::acquireItem
	mov	edi, eax
	xor	eax, eax
	cmp	edi, eax
	je	$LN9@Queue@8
	cmp	ebp, DWORD PTR [ebx]
	jge	SHORT $LN22@Queue@8
	cmp	ebp, eax
	jl	SHORT $LN22@Queue@8
	mov	ecx, DWORD PTR [ebx+28]
	sub	ecx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ebx+4]
	add	eax, ebp
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [ebx+28]
	sub	eax, DWORD PTR [ebx+24]
	sar	eax, 2
	mov	DWORD PTR $T638213[esp+32], edx
	cmp	edx, eax
	jb	SHORT $LN28@Queue@8
	call	__invalid_parameter_noinfo
	mov	edx, DWORD PTR $T638213[esp+32]
$LN28@Queue@8:
	mov	ecx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN22@Queue@8:
	mov	DWORD PTR [edi], OFFSET ??_7Event@DRAMsimII@@6B@
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [edi+8], edx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edi+12], ecx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [edi+16], edx
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edi+20], ecx
	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [edi+24], edx
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edi+28], ecx
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR [edi+32], edx
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edi+36], ecx
	movq	xmm0, QWORD PTR [eax+40]
	movq	QWORD PTR [edi+40], xmm0
	movq	xmm0, QWORD PTR [eax+48]
	movq	QWORD PTR [edi+48], xmm0
	movq	xmm0, QWORD PTR [eax+56]
	movq	QWORD PTR [edi+56], xmm0
	movq	xmm0, QWORD PTR [eax+64]
	movq	QWORD PTR [edi+64], xmm0
	movq	xmm0, QWORD PTR [eax+72]
	movq	QWORD PTR [edi+72], xmm0
	mov	DWORD PTR [edi], OFFSET ??_7Transaction@DRAMsimII@@6B@
	mov	edx, DWORD PTR [eax+80]
	mov	DWORD PTR [edi+80], edx
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR [edi+84], ecx
	mov	edx, DWORD PTR [eax+88]
	mov	DWORD PTR [edi+88], edx
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR [edi+92], ecx
	mov	edx, DWORD PTR [eax+96]
	mov	DWORD PTR [edi+96], edx
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR [edi+100], ecx
	mov	edx, DWORD PTR [eax+104]
	mov	DWORD PTR [edi+104], edx
	mov	eax, DWORD PTR [eax+108]
	mov	DWORD PTR [edi+108], eax
	mov	DWORD PTR $T638178[esp+32], edi
	jmp	SHORT $LN10@Queue@8
$LN9@Queue@8:
	mov	DWORD PTR $T638178[esp+32], eax
$LN10@Queue@8:
	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR _this$[esp+32]
	sub	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [edx+4]
	add	eax, ebp
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
	mov	edi, edx
	cmp	edi, eax
	jb	SHORT $LN39@Queue@8
	call	__invalid_parameter_noinfo
$LN39@Queue@8:
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR $T638178[esp+32]
	inc	ebp
	mov	DWORD PTR [ecx+edi*4], edx
	cmp	ebp, DWORD PTR [ebx]
	jb	$LL6@Queue@8
$LN48@Queue@8:

; 72   : 			}
; 73   : 
; 74   : 			for (unsigned i = 0; i < count; i++)
; 75   : 				assert(at(i) && rhs.at(i));
; 76   : 		}	

	mov	eax, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z$0:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 12					; 0000000cH
	jmp	??1?$vector@PAVTransaction@DRAMsimII@@V?$allocator@PAVTransaction@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >::~vector<DRAMsimII::Transaction *,std::allocator<DRAMsimII::Transaction *> >
__ehhandler$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z ENDP ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
PUBLIC	?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ; DRAMsimII::Channel::createNextRefresh
__unwindtable$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ$0
__ehfuncinfo$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
$T638311 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T638280 = 8						; size = 4
$T638279 = 8						; size = 4
_this$ = 8						; size = 4
?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ PROC ; DRAMsimII::Channel::createNextRefresh

; 863  : {

	push	-1
	push	__ehhandler$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR _this$[esp+36]

; 864  : 	Transaction *newRefreshTransaction = new Transaction(*readNextRefresh());

	call	?acquireItem@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::acquireItem
	mov	esi, eax
	mov	DWORD PTR $T638280[esp+36], esi
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+48], eax
	cmp	esi, eax
	je	SHORT $LN3@createNext
	push	ebx
	call	?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ ; DRAMsimII::Channel::readNextRefresh
	mov	edi, eax
	mov	ecx, edi
	mov	eax, esi
	call	??0Event@DRAMsimII@@IAE@ABV01@@Z	; DRAMsimII::Event::Event
	mov	DWORD PTR [esi], OFFSET ??_7Transaction@DRAMsimII@@6B@
	mov	eax, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], eax
	mov	ecx, DWORD PTR [edi+84]
	mov	DWORD PTR [esi+84], ecx
	mov	edx, DWORD PTR [edi+88]
	mov	DWORD PTR [esi+88], edx
	mov	eax, DWORD PTR [edi+92]
	mov	DWORD PTR [esi+92], eax
	mov	ecx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], ecx
	mov	edx, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], edx
	mov	eax, DWORD PTR [edi+104]
	mov	DWORD PTR [esi+104], eax
	mov	ecx, DWORD PTR [edi+108]
	mov	DWORD PTR [esi+108], ecx
	mov	DWORD PTR $T638279[esp+36], esi
	jmp	SHORT $LN4@createNext
$LN3@createNext:
	mov	DWORD PTR $T638279[esp+36], eax
$LN4@createNext:

; 865  : 
; 866  : 	unsigned rank = newRefreshTransaction->getAddress().getRank();
; 867  : 
; 868  : 	refreshCounter[rank] = refreshCounter[rank] + timingSpecification.tREFI();

	mov	eax, DWORD PTR [ebx+168]
	sub	eax, DWORD PTR [ebx+164]
	mov	edx, DWORD PTR $T638279[esp+36]
	mov	esi, DWORD PTR [edx+60]
	sar	eax, 3
	cmp	esi, eax
	jb	SHORT $LN14@createNext
	call	__invalid_parameter_noinfo
$LN14@createNext:
	mov	edx, DWORD PTR [ebx+168]
	sub	edx, DWORD PTR [ebx+164]
	mov	edi, DWORD PTR [ebx+164]
	mov	ecx, DWORD PTR [ebx+108]
	lea	ebp, DWORD PTR [esi*8]
	sar	edx, 3
	add	edi, ebp
	mov	DWORD PTR $T638311[esp+40], ecx
	cmp	esi, edx
	jb	SHORT $LN21@createNext
	call	__invalid_parameter_noinfo
$LN21@createNext:
	mov	eax, DWORD PTR $T638311[esp+40]
	mov	ebx, DWORD PTR [ebx+164]
	cdq
	add	eax, DWORD PTR [edi]
	adc	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx+ebp], eax

; 869  : 
; 870  : 	return newRefreshTransaction;

	mov	eax, DWORD PTR $T638279[esp+36]
	mov	DWORD PTR [ebx+ebp+4], edx

; 871  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
__unwindfunclet$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ$0:
	mov	esi, DWORD PTR $T638280[ebp-4]
	jmp	??3Transaction@DRAMsimII@@SAXPAX@Z	; DRAMsimII::Transaction::operator delete
__ehhandler$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-24]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ
	jmp	___CxxFrameHandler3
?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ENDP ; DRAMsimII::Channel::createNextRefresh
PUBLIC	?getTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ; DRAMsimII::Channel::getTransaction
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_val$ = -12						; size = 4
_nextRefresh$219030 = -8				; size = 8
?getTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ PROC ; DRAMsimII::Channel::getTransaction
; _this$ = eax

; 822  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, eax

; 823  : 	unsigned val = readAvailableTransaction(true);

	push	1
	call	?readAvailableTransaction@Channel@DRAMsimII@@IBEI_N@Z ; DRAMsimII::Channel::readAvailableTransaction
	mov	ebx, eax
	mov	DWORD PTR _val$[esp+28], ebx

; 824  : 
; 825  : 	const Transaction *nextTransaction = (val < UINT_MAX) ? transactionQueue[val] : NULL;

	cmp	ebx, -1
	jae	SHORT $LN9@getTransac
	cmp	ebx, DWORD PTR [esi+112]
	jge	SHORT $LN9@getTransac
	test	ebx, ebx
	jl	SHORT $LN9@getTransac
	mov	ecx, DWORD PTR [esi+140]
	sub	ecx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+116]
	xor	edx, edx
	sar	ecx, 2
	add	eax, ebx
	div	ecx
	mov	edi, edx
	mov	edx, DWORD PTR [esi+140]
	sub	edx, DWORD PTR [esi+136]
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN22@getTransac
	call	__invalid_parameter_noinfo
$LN22@getTransac:
	mov	eax, DWORD PTR [esi+136]
	mov	edi, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN10@getTransac
$LN9@getTransac:
	xor	edi, edi
$LN10@getTransac:

; 826  : 
; 827  : 	// no refresh transactions, just see if normal transactions are decoded
; 828  : 	if (systemConfig.getRefreshPolicy() == NO_REFRESH)

	mov	ecx, DWORD PTR [esi+176]
	cmp	DWORD PTR [ecx+304], 0
	jne	SHORT $LN6@getTransac

; 829  : 	{
; 830  : 		if ((nextTransaction) && (time >= nextTransaction->getEnqueueTime() + timingSpecification.tBufferDelay()))

	test	edi, edi
	je	$LN1@getTransac
	mov	eax, DWORD PTR [esi+104]
	mov	ecx, DWORD PTR [esi+12]
	cdq
	add	eax, DWORD PTR [edi+16]
	adc	edx, DWORD PTR [edi+20]
	cmp	ecx, edx
	jl	$LN1@getTransac
	jg	SHORT $LN45@getTransac
	mov	edx, DWORD PTR [esi+8]
	cmp	edx, eax
	jb	$LN1@getTransac
$LN45@getTransac:

; 831  : 		{
; 832  : 			return getAvailableTransaction(val);

	cmp	ebx, -1
	jae	SHORT $LN36@getTransac
	add	esi, 112				; 00000070H
	mov	eax, ebx
	call	?remove@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::remove

; 850  : 		}
; 851  : 	}
; 852  : 	return NULL;
; 853  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0

; 831  : 		{
; 832  : 			return getAvailableTransaction(val);

$LN36@getTransac:
	push	1
	call	?readAvailableTransaction@Channel@DRAMsimII@@IBEI_N@Z ; DRAMsimII::Channel::readAvailableTransaction
	cmp	eax, -1
	jae	$LN1@getTransac
	add	esi, 112				; 00000070H
	call	?remove@?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEPAVTransaction@2@H@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::remove

; 850  : 		}
; 851  : 	}
; 852  : 	return NULL;
; 853  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
$LN6@getTransac:

; 833  : 		}
; 834  : 	}
; 835  : 	else
; 836  : 	{
; 837  : 		const tick nextRefresh = nextRefreshTime();

	mov	eax, esi
	call	?nextRefreshTime@Channel@DRAMsimII@@IBE_JXZ ; DRAMsimII::Channel::nextRefreshTime
	mov	DWORD PTR _nextRefresh$219030[esp+28], eax
	mov	ebp, edx

; 838  : 
; 839  : 		// give an advantage to normal transactions, but prevent starvation for refresh operations
; 840  : 		// if there is a normal transaction ready to go, it's ready to go and the refresh command isn't starving
; 841  : 		if (nextTransaction &&
; 842  : 			((time < nextRefresh + systemConfig.getSeniorityAgeLimit()) &&
; 843  : 			(time >= nextTransaction->getEnqueueTime() + timingSpecification.tBufferDelay())))

	test	edi, edi
	je	SHORT $LN3@getTransac
	mov	eax, DWORD PTR [esi+176]
	mov	ecx, DWORD PTR [eax+320]
	mov	ebx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+8]
	xor	eax, eax
	add	ecx, DWORD PTR _nextRefresh$219030[esp+28]
	adc	eax, ebp
	cmp	ebx, eax
	jg	SHORT $LN3@getTransac
	jl	SHORT $LN46@getTransac
	cmp	edx, ecx
	jae	SHORT $LN3@getTransac
$LN46@getTransac:
	mov	eax, DWORD PTR [esi+104]
	cdq
	add	eax, DWORD PTR [edi+16]
	adc	edx, DWORD PTR [edi+20]
	cmp	ebx, edx
	jl	SHORT $LN3@getTransac
	jg	SHORT $LN47@getTransac
	cmp	DWORD PTR [esi+8], eax
	jb	SHORT $LN3@getTransac
$LN47@getTransac:

; 844  : 		{
; 845  : 			return getAvailableTransaction(val);

	mov	eax, DWORD PTR _val$[esp+28]
	mov	ecx, esi

; 850  : 		}
; 851  : 	}
; 852  : 	return NULL;
; 853  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH

; 844  : 		{
; 845  : 			return getAvailableTransaction(val);

	jmp	?getAvailableTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@I@Z ; DRAMsimII::Channel::getAvailableTransaction
$LN3@getTransac:

; 846  : 		}
; 847  : 		else if ((time >= nextRefresh) && (checkForAvailableCommandSlots(readNextRefresh())))

	mov	ecx, DWORD PTR [esi+12]
	cmp	ecx, ebp
	jl	SHORT $LN1@getTransac
	jg	SHORT $LN48@getTransac
	mov	edx, DWORD PTR [esi+8]
	cmp	edx, DWORD PTR _nextRefresh$219030[esp+28]
	jb	SHORT $LN1@getTransac
$LN48@getTransac:
	push	esi
	call	?readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ ; DRAMsimII::Channel::readNextRefresh
	push	esi
	call	?checkForAvailableCommandSlots@Channel@DRAMsimII@@IBE_NPBVTransaction@2@@Z ; DRAMsimII::Channel::checkForAvailableCommandSlots
	test	al, al
	je	SHORT $LN1@getTransac

; 848  : 		{
; 849  : 			return createNextRefresh();

	push	esi
	call	?createNextRefresh@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ; DRAMsimII::Channel::createNextRefresh

; 850  : 		}
; 851  : 	}
; 852  : 	return NULL;
; 853  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
$LN1@getTransac:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
?getTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ENDP ; DRAMsimII::Channel::getTransaction
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GDRAMsimWSSoapHttp@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GDRAMsimWSSoapHttp@@UAEPAXI@Z PROC			; DRAMsimWSSoapHttp::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1DRAMsimWSSoapHttp@@UAE@XZ		; DRAMsimWSSoapHttp::~DRAMsimWSSoapHttp
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@100
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@100:
	mov	eax, esi
	pop	esi
	ret	4
??_GDRAMsimWSSoapHttp@@UAEPAXI@Z ENDP			; DRAMsimWSSoapHttp::`scalar deleting destructor'
PUBLIC	?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z ; DRAMsimII::Channel::transaction2commands
__ehfuncinfo$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$8
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
tv4831 = -108						; size = 4
$T645568 = -108						; size = 4
_bankNumber$219360 = -104				; size = 4
$T645540 = -104						; size = 4
_destinationBank$ = -104				; size = 8
$T646974 = -96						; size = 4
__Tmp$645980 = -96					; size = 8
$T645551 = -96						; size = 4
$T645541 = -96						; size = 4
_currentBank$219260 = -96				; size = 8
$T646644 = -88						; size = 1
$T646163 = -88						; size = 1
$T645583 = -88						; size = 4
$T645579 = -88						; size = 4
$T645575 = -88						; size = 4
$T645563 = -88						; size = 4
$T645562 = -88						; size = 4
_i$219323 = -88						; size = 8
$T645555 = -88						; size = 4
$T645547 = -88						; size = 4
_destinationRank$ = -88					; size = 8
__Tmp$645762 = -80					; size = 8
$T645559 = -72						; size = 8
_bankEnd$219317 = -72					; size = 8
$T645538 = -72						; size = 8
$T645537 = -64						; size = 8
_tempAddr$219359 = -56					; size = 40
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_incomingTransaction$ = 12				; size = 4
?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z PROC ; DRAMsimII::Channel::transaction2commands

; 1066 : {

	push	-1
	push	__ehhandler$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+132]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _incomingTransaction$[esp+128]
	mov	esi, DWORD PTR _this$[esp+128]

; 1067 : 	if (incomingTransaction == NULL)

	test	eax, eax

; 1068 : 	{
; 1069 : 		return false;

	je	$LN1117@transactio

; 1070 : 	}
; 1071 : 	// ensure that this transaction belongs on this channel
; 1072 : 	assert(incomingTransaction->getAddress().getChannel() == channelID);
; 1073 : 	assert(incomingTransaction->getAddress().getChannel() < systemConfig.getChannelCount());
; 1074 : 	assert(incomingTransaction->getAddress().getRank() < systemConfig.getRankCount());
; 1075 : 
; 1076 : 	vector<Rank>::iterator destinationRank = rank.begin() + incomingTransaction->getAddress().getRank();

	mov	edi, DWORD PTR [esi+380]
	mov	ebx, DWORD PTR [eax+60]
	cmp	edi, DWORD PTR [esi+384]
	jbe	SHORT $LN101@transactio
	call	__invalid_parameter_noinfo
$LN101@transactio:
	mov	esi, DWORD PTR [esi+368]
	mov	DWORD PTR __Tmp$645762[esp+132], esi
	mov	DWORD PTR __Tmp$645762[esp+136], edi
	test	esi, esi
	jne	SHORT $LN1108@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN126@transactio:
	imul	ebx, 200				; 000000c8H
	lea	ebp, DWORD PTR [ebx+edi]
	mov	DWORD PTR tv4831[esp+132], ebp
	cmp	ebp, DWORD PTR [eax+16]
	ja	SHORT $LN116@transactio
	test	esi, esi
	je	SHORT $LN131@transactio
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN132@transactio
$LN1108@transactio:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN126@transactio
$LN131@transactio:
	xor	esi, esi
$LN132@transactio:
	cmp	ebp, DWORD PTR [esi+12]
	jae	SHORT $LN117@transactio
$LN116@transactio:
	call	__invalid_parameter_noinfo
$LN117@transactio:
	mov	eax, DWORD PTR __Tmp$645762[esp+132]

; 1077 : 
; 1078 : 	vector<Bank>::iterator destinationBank = destinationRank->bank.begin() + incomingTransaction->getAddress().getBank();

	mov	ecx, DWORD PTR _incomingTransaction$[esp+128]
	mov	ebx, DWORD PTR [ecx+64]
	mov	DWORD PTR _destinationRank$[esp+132], eax
	mov	DWORD PTR _destinationRank$[esp+136], ebp
	test	eax, eax
	jne	SHORT $LN1107@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN152@transactio:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN143@transactio
	call	__invalid_parameter_noinfo
$LN143@transactio:
	mov	edi, DWORD PTR [ebp+184]
	cmp	edi, DWORD PTR [ebp+188]
	jbe	SHORT $LN160@transactio
	call	__invalid_parameter_noinfo
$LN160@transactio:
	mov	esi, DWORD PTR [ebp+172]
	mov	DWORD PTR __Tmp$645980[esp+132], esi
	mov	DWORD PTR __Tmp$645980[esp+136], edi
	test	esi, esi
	jne	SHORT $LN1106@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN185@transactio:
	imul	ebx, 152				; 00000098H
	lea	ebp, DWORD PTR [ebx+edi]
	cmp	ebp, DWORD PTR [eax+16]
	ja	SHORT $LN175@transactio
	test	esi, esi
	je	SHORT $LN190@transactio
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN191@transactio
$LN1107@transactio:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN152@transactio
$LN1106@transactio:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN185@transactio
$LN190@transactio:
	xor	esi, esi
$LN191@transactio:
	cmp	ebp, DWORD PTR [esi+12]
	jae	SHORT $LN176@transactio
$LN175@transactio:
	call	__invalid_parameter_noinfo
$LN176@transactio:

; 1079 : 
; 1080 : 	assert(incomingTransaction->getAddress().getBank() < systemConfig.getBankCount());
; 1081 : 	assert(incomingTransaction->getAddress().getRow() < systemConfig.getRowCount());
; 1082 : 	assert(incomingTransaction->getAddress().getColumn() < systemConfig.getColumnCount());
; 1083 : 
; 1084 : 	// with closed page, all transactions convert into one of the following:
; 1085 : 	// RAS, CAS, Precharge
; 1086 : 	// RAS, CAS+Precharge
; 1087 : 	switch (systemConfig.getRowBufferManagementPolicy())

	mov	eax, DWORD PTR _this$[esp+128]
	mov	ecx, DWORD PTR [eax+176]
	mov	ecx, DWORD PTR [ecx+328]
	mov	edx, DWORD PTR __Tmp$645980[esp+132]
	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR _destinationBank$[esp+132], edx
	mov	DWORD PTR _destinationBank$[esp+136], ebp
	cmp	eax, 3
	ja	$LN1@transactio
	jmp	DWORD PTR $LN1119@transactio[eax*4]
$LN59@transactio:

; 1088 : 	{
; 1089 : 		// will either convert a CAS+P into CAS, CAS+P by appending a new command or will add a CAS before a PRE (when autoprecharge is not available)
; 1090 : 	case CLOSE_PAGE:
; 1091 : 	case CLOSE_PAGE_AGGRESSIVE:
; 1092 : 
; 1093 : 		// refresh transactions become only one command and are handled differently
; 1094 : 		if (incomingTransaction->isRefresh())

	mov	edx, DWORD PTR _incomingTransaction$[esp+128]
	cmp	DWORD PTR [edx+80], 4
	jne	$LN58@transactio

; 1095 : 		{
; 1096 : 			// check to see if every per bank command queue has room for one command
; 1097 : 			// make sure that there is room in all the queues for one command
; 1098 : 			// refresh commands refresh a row, but kill everything currently in the sense amps
; 1099 : 			// therefore, we need to make sure that the refresh commands happen when all banks
; 1100 : 			// are available
; 1101 : 			for (vector<Bank>::const_iterator currentBank = destinationRank->bank.begin(); currentBank != destinationRank->bank.end(); currentBank++)

	lea	esi, DWORD PTR _destinationRank$[esp+132]
	call	??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 172				; 000000acH
	lea	esi, DWORD PTR $T645537[esp+132]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	edi, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR _currentBank$219260[esp+132], edi
	mov	DWORD PTR _currentBank$219260[esp+136], ebp
$LL57@transactio:
	lea	esi, DWORD PTR _destinationRank$[esp+132]
	call	??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	esi, eax
	mov	ebx, DWORD PTR [esi+188]
	add	esi, 172				; 000000acH
	cmp	DWORD PTR [esi+12], ebx
	jbe	SHORT $LN203@transactio
	call	__invalid_parameter_noinfo
$LN203@transactio:
	mov	esi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN216@transactio
	cmp	edi, esi
	je	SHORT $LN217@transactio
$LN216@transactio:
	call	__invalid_parameter_noinfo
$LN217@transactio:
	cmp	ebp, ebx
	je	SHORT $LN55@transactio

; 1102 : 			{
; 1103 : 				if (currentBank->isFull())

	test	edi, edi
	jne	SHORT $LN1105@transactio
	call	__invalid_parameter_noinfo
$LN235@transactio:
	cmp	ebp, DWORD PTR [edi+16]
	jb	SHORT $LN226@transactio
	call	__invalid_parameter_noinfo
$LN226@transactio:
	mov	eax, DWORD PTR [ebp+36]
	sub	eax, DWORD PTR [ebp+32]
	sar	eax, 2
	cmp	eax, DWORD PTR [ebp+8]
	je	$LN1117@transactio
	lea	edi, DWORD PTR $T645538[esp+132]
	lea	esi, DWORD PTR _currentBank$219260[esp+132]
	call	??E?$_Vector_const_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator++
	mov	ebp, DWORD PTR _currentBank$219260[esp+136]
	mov	edi, DWORD PTR _currentBank$219260[esp+132]
	jmp	SHORT $LL57@transactio
$LN1105@transactio:
	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LN235@transactio
$LN55@transactio:

; 1104 : 					return false;
; 1105 : 			}
; 1106 : 			// then add the command to all queues
; 1107 : 			Command *refreshCommand = new Command(incomingTransaction, time,  systemConfig.isAutoPrecharge(), timingSpecification.tBurst());

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T645541[esp+132], eax
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+140], edi
	cmp	eax, edi
	je	SHORT $LN65@transactio
	mov	esi, DWORD PTR _this$[esp+128]
	mov	edx, DWORD PTR [esi+176]
	mov	dl, BYTE PTR [edx+346]
	mov	ecx, DWORD PTR [esi+32]
	push	ecx
	mov	BYTE PTR $T646163[esp+136], dl
	mov	ecx, DWORD PTR $T646163[esp+136]
	mov	edx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR [esi+8]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _incomingTransaction$[esp+144]
	push	eax
	lea	edx, DWORD PTR [edi+1]
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	DWORD PTR $T645540[esp+132], eax
	jmp	SHORT $LN66@transactio
$LN65@transactio:
	mov	DWORD PTR $T645540[esp+132], edi
$LN66@transactio:
	mov	DWORD PTR __$EHRec$[esp+140], -1

; 1108 : 
; 1109 : 			for (vector<Bank>::iterator currentBank = destinationRank->bank.begin(); currentBank != destinationRank->bank.end(); currentBank++)

	mov	ebx, DWORD PTR __Tmp$645762[esp+132]
	cmp	ebx, edi
	jne	$LN1104@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN263@transactio:
	mov	ebp, DWORD PTR tv4831[esp+132]
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN254@transactio
	call	__invalid_parameter_noinfo
$LN254@transactio:
	mov	edi, DWORD PTR [ebp+184]
	cmp	edi, DWORD PTR [ebp+188]
	jbe	SHORT $LN271@transactio
	call	__invalid_parameter_noinfo
$LN271@transactio:
	mov	esi, DWORD PTR [ebp+172]
$LL288@transactio:
	test	ebx, ebx
	jne	$LN1103@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN311@transactio:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN302@transactio
	call	__invalid_parameter_noinfo
$LN302@transactio:
	mov	ebx, DWORD PTR [ebp+188]
	cmp	DWORD PTR [ebp+184], ebx
	jbe	SHORT $LN319@transactio
	call	__invalid_parameter_noinfo
$LN319@transactio:
	mov	eax, DWORD PTR [ebp+172]
	test	esi, esi
	je	SHORT $LN332@transactio
	cmp	esi, eax
	je	SHORT $LN333@transactio
$LN332@transactio:
	call	__invalid_parameter_noinfo
$LN333@transactio:
	cmp	edi, ebx
	je	$LN1064@transactio

; 1110 : 			{
; 1111 : #ifndef NDEBUG
; 1112 : 				bool result =
; 1113 : #endif // NDEBUG
; 1114 : 					currentBank->push(refreshCommand);

	test	esi, esi
	jne	SHORT $LN1102@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN353@transactio:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN344@transactio
	call	__invalid_parameter_noinfo
$LN344@transactio:
	mov	edx, DWORD PTR $T645540[esp+132]
	push	edx
	lea	eax, DWORD PTR [edi+8]
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push
	test	esi, esi
	jne	SHORT $LN1101@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN295@transactio:

; 1108 : 
; 1109 : 			for (vector<Bank>::iterator currentBank = destinationRank->bank.begin(); currentBank != destinationRank->bank.end(); currentBank++)

	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN286@transactio
	call	__invalid_parameter_noinfo
$LN286@transactio:
	mov	ebx, DWORD PTR __Tmp$645762[esp+132]
	mov	ebp, DWORD PTR tv4831[esp+132]
	add	edi, 152				; 00000098H
	jmp	$LL288@transactio
$LN1104@transactio:
	mov	eax, DWORD PTR [ebx]
	jmp	$LN263@transactio
$LN1103@transactio:
	mov	eax, DWORD PTR [ebx]
	jmp	$LN311@transactio
$LN1102@transactio:

; 1110 : 			{
; 1111 : #ifndef NDEBUG
; 1112 : 				bool result =
; 1113 : #endif // NDEBUG
; 1114 : 					currentBank->push(refreshCommand);

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN353@transactio
$LN1101@transactio:

; 1108 : 
; 1109 : 			for (vector<Bank>::iterator currentBank = destinationRank->bank.begin(); currentBank != destinationRank->bank.end(); currentBank++)

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN295@transactio
$LN58@transactio:

; 1115 : 				assert(result);
; 1116 : 				assert(currentBank->back() == refreshCommand);
; 1117 : 			}
; 1118 : 		}
; 1119 : 		// need at least one free command slot
; 1120 : 		// or three commands if the CAS+Precharge command is not available
; 1121 : 		else if (systemConfig.getRowBufferManagementPolicy() == CLOSE_PAGE_AGGRESSIVE &&
; 1122 : 			destinationBank->aggressiveInsert(incomingTransaction,time))

	mov	edi, DWORD PTR _this$[esp+128]
	cmp	ecx, 4
	jne	SHORT $LN49@transactio
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+8]
	push	eax
	push	ecx
	push	edx
	lea	esi, DWORD PTR _destinationBank$[esp+144]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	push	eax
	call	?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z ; DRAMsimII::Bank::aggressiveInsert
	test	al, al
	je	SHORT $LN49@transactio

; 1123 : 		{
; 1124 : 			statistics.reportHit();

	mov	eax, DWORD PTR [edi+180]
	inc	DWORD PTR [eax+56]

; 1125 : 		}
; 1126 : 		// every transaction translates into at least two commands
; 1127 : 		// or three commands if the CAS+Precharge command is not available
; 1128 : 		else if ((destinationBank->freeCommandSlots() < 2) ||

	jmp	$LN1064@transactio
$LN49@transactio:

; 1129 : 			(!systemConfig.isAutoPrecharge() && (destinationBank->freeCommandSlots() < 3)))

	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, DWORD PTR [eax+32]
	sar	ecx, 2
	sub	ecx, DWORD PTR [eax+8]
	cmp	ecx, 2
	jb	$LN1117@transactio
	mov	edx, DWORD PTR [edi+176]
	cmp	BYTE PTR [edx+346], 0
	jne	SHORT $LN47@transactio
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, DWORD PTR [eax+32]
	sar	ecx, 2
	sub	ecx, DWORD PTR [eax+8]
	cmp	ecx, 3
	jb	$LN1117@transactio
$LN47@transactio:

; 1130 : 		{
; 1131 : 			return false;
; 1132 : 		}
; 1133 : 		// then it can be piggybacked on an existing R, C, P or R, C+P chain
; 1134 : 		// also make sure not to starve		
; 1135 : 		// R C1 P => R C1 C2 P
; 1136 : 		// R C1+P => R C1 C2+P
; 1137 : 		// TODO: look for the last non-refresh command in the per-bank queue
; 1138 : 		else
; 1139 : 		{
; 1140 : 			// didn't find place to issue command
; 1141 : 			statistics.reportMiss();

	mov	ebx, DWORD PTR _this$[esp+128]
	mov	eax, DWORD PTR [ebx+180]
	mov	ebp, 1
	add	DWORD PTR [eax+60], ebp

; 1142 : 
; 1143 : 			// command one, the RAS command to activate the row
; 1144 : #ifndef NDEBUG
; 1145 : 			bool result =
; 1146 : #endif
; 1147 : 				destinationBank->push(new Command(incomingTransaction, time, false, timingSpecification.tBurst(), Command::ACTIVATE));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T645547[esp+132], eax
	mov	DWORD PTR __$EHRec$[esp+140], ebp
	test	eax, eax
	je	SHORT $LN67@transactio
	mov	ecx, DWORD PTR [ebx+32]
	mov	edx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR [ebx+8]
	push	0
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _incomingTransaction$[esp+144]
	push	eax
	xor	edx, edx
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	edi, eax
	jmp	SHORT $LN68@transactio
$LN67@transactio:
	xor	edi, edi
$LN68@transactio:
	lea	esi, DWORD PTR _destinationBank$[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	push	edi
	add	eax, 8
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push

; 1148 : 			assert(result);
; 1149 : 			assert(destinationBank->back()->getAddress() == incomingTransaction->getAddress());
; 1150 : 
; 1151 : 			// command two, CAS or CAS+Precharge			
; 1152 : #ifndef NDEBUG
; 1153 : 			result =
; 1154 : #endif
; 1155 : 				destinationBank->push(new Command(incomingTransaction, time, systemConfig.isAutoPrecharge(), timingSpecification.tBurst()));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T645551[esp+132], eax
	mov	DWORD PTR __$EHRec$[esp+140], 2
	test	eax, eax
	je	SHORT $LN69@transactio
	mov	edx, DWORD PTR [ebx+176]
	mov	dl, BYTE PTR [edx+346]
	mov	ecx, DWORD PTR [ebx+32]
	push	ecx
	mov	BYTE PTR $T646644[esp+136], dl
	mov	ecx, DWORD PTR $T646644[esp+136]
	mov	edx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR [ebx+8]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _incomingTransaction$[esp+144]
	push	eax
	mov	edx, ebp
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	edi, eax
	jmp	SHORT $LN70@transactio
$LN69@transactio:
	xor	edi, edi
$LN70@transactio:
	or	ebp, -1
	lea	esi, DWORD PTR _destinationBank$[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], ebp
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	push	edi
	add	eax, 8
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push

; 1156 : 			assert(result);
; 1157 : 			assert(destinationBank->back()->getAddress() == incomingTransaction->getAddress());
; 1158 : 
; 1159 : 			// possible command three, Precharge
; 1160 : 			if (!systemConfig.isAutoPrecharge())

	mov	edx, DWORD PTR [ebx+176]
	cmp	BYTE PTR [edx+346], 0
	jne	$LN1064@transactio

; 1161 : 			{				
; 1162 : #ifndef NDEBUG
; 1163 : 				result =
; 1164 : #endif
; 1165 : 					destinationBank->push(new Command(incomingTransaction, time, false, timingSpecification.tBurst(), Command::PRECHARGE));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T645555[esp+132], eax
	mov	DWORD PTR __$EHRec$[esp+140], 3
	test	eax, eax
	je	SHORT $LN71@transactio
	mov	ecx, DWORD PTR [ebx+32]
	mov	edx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, DWORD PTR [ebx+12]
	push	0
	push	ecx
	mov	ecx, DWORD PTR _incomingTransaction$[esp+140]
	push	edx
	push	eax
	lea	edx, DWORD PTR [ebp+7]
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	edi, eax
	mov	DWORD PTR __$EHRec$[esp+140], ebp

; 1166 : 				assert(result);
; 1167 : 				assert(destinationBank->back()->getAddress() == incomingTransaction->getAddress());
; 1168 : 			}
; 1169 : 		}
; 1170 : 		break;

	jmp	$LN1118@transactio
$LN71@transactio:

; 1161 : 			{				
; 1162 : #ifndef NDEBUG
; 1163 : 				result =
; 1164 : #endif
; 1165 : 					destinationBank->push(new Command(incomingTransaction, time, false, timingSpecification.tBurst(), Command::PRECHARGE));

	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+140], ebp

; 1166 : 				assert(result);
; 1167 : 				assert(destinationBank->back()->getAddress() == incomingTransaction->getAddress());
; 1168 : 			}
; 1169 : 		}
; 1170 : 		break;

	jmp	$LN1118@transactio
$LN43@transactio:

; 1171 : 
; 1172 : 		// open page systems may, in the best case, add a CAS command to an already open row
; 1173 : 		// closing the row and precharging may be pushed back one slot
; 1174 : 	case OPEN_PAGE_AGGRESSIVE:
; 1175 : 		// look to see if this queue or queues are getting too full and collapse CAS(W), Pre into
; 1176 : 		// CAS+P commands to relieve congestion
; 1177 : 		if (incomingTransaction->isRefresh())

	mov	eax, DWORD PTR _incomingTransaction$[esp+128]
	cmp	DWORD PTR [eax+80], 4
	jne	$LN42@transactio

; 1178 : 		{
; 1179 : 			vector<Bank>::iterator bankEnd = destinationRank->bank.end();

	lea	esi, DWORD PTR _destinationRank$[esp+132]
	call	??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 172				; 000000acH
	lea	esi, DWORD PTR _bankEnd$219317[esp+132]
	call	?end@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::end

; 1180 : 			// evaluate every per bank queue in this rank and collapse
; 1181 : 			for (vector<Bank>::iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	lea	esi, DWORD PTR _destinationRank$[esp+132]
	call	??C?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QBEPAVRank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator->
	mov	edi, eax
	add	edi, 172				; 000000acH
	lea	esi, DWORD PTR _i$219323[esp+132]
	call	?begin@?$vector@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@2@XZ ; std::vector<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::begin
	mov	edi, DWORD PTR _i$219323[esp+132]
	mov	ebx, DWORD PTR _i$219323[esp+136]
	npad	5
$LL408@transactio:
	test	edi, edi
	je	SHORT $LN420@transactio
	cmp	edi, DWORD PTR _bankEnd$219317[esp+132]
	je	SHORT $LN421@transactio
$LN420@transactio:
	call	__invalid_parameter_noinfo
$LN421@transactio:
	cmp	ebx, DWORD PTR _bankEnd$219317[esp+136]
	je	$LN36@transactio

; 1182 : 			{
; 1183 : 				if (i->isHighUtilization())

	test	edi, edi
	jne	SHORT $LN1100@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN441@transactio:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN432@transactio
	call	__invalid_parameter_noinfo
$LN432@transactio:
	mov	ecx, DWORD PTR [ebx+36]
	sub	ecx, DWORD PTR [ebx+32]
	sar	ecx, 2
	shr	ecx, 1
	cmp	DWORD PTR [ebx+8], ecx
	jbe	SHORT $LN40@transactio

; 1184 : 				{
; 1185 : 					i->collapse();

	lea	esi, DWORD PTR _i$219323[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	call	?collapse@Bank@DRAMsimII@@QAEXXZ	; DRAMsimII::Bank::collapse
$LN40@transactio:

; 1180 : 			// evaluate every per bank queue in this rank and collapse
; 1181 : 			for (vector<Bank>::iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	test	edi, edi
	jne	SHORT $LN1099@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN415@transactio:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN406@transactio
	call	__invalid_parameter_noinfo
$LN406@transactio:
	add	ebx, 152				; 00000098H
	mov	DWORD PTR _i$219323[esp+136], ebx
	jmp	SHORT $LL408@transactio
$LN1100@transactio:

; 1182 : 			{
; 1183 : 				if (i->isHighUtilization())

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN441@transactio
$LN1099@transactio:

; 1180 : 			// evaluate every per bank queue in this rank and collapse
; 1181 : 			for (vector<Bank>::iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN415@transactio
$LN42@transactio:

; 1186 : 				}
; 1187 : 			}
; 1188 : 		}
; 1189 : 		else
; 1190 : 		{
; 1191 : 			if (destinationBank->isHighUtilization())

	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	edx, DWORD PTR [eax+36]
	sub	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [eax+8]
	sar	edx, 2
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN36@transactio

; 1192 : 			{
; 1193 : 				destinationBank->collapse();

	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	call	?collapse@Bank@DRAMsimII@@QAEXXZ	; DRAMsimII::Bank::collapse
$LN36@transactio:

; 1194 : 			}
; 1195 : 		}
; 1196 : 
; 1197 : 		// lack of break it intentional
; 1198 : 	case OPEN_PAGE:
; 1199 : 
; 1200 : 		// refresh transactions become only one command and are handled differently
; 1201 : 		if (incomingTransaction->isRefresh())

	mov	ebx, DWORD PTR _incomingTransaction$[esp+128]
	cmp	DWORD PTR [ebx+80], 4
	jne	$LN34@transactio

; 1202 : 		{
; 1203 : 			// make sure that there is room in all the queues for one command
; 1204 : 			// refresh commands refresh a row, but kill everything currently in the sense amps
; 1205 : 			// therefore, we need to make sure that the refresh commands happen when all banks
; 1206 : 			// are available
; 1207 : 			vector<Bank>::const_iterator bankEnd = destinationRank->bank.end();

	mov	esi, DWORD PTR __Tmp$645762[esp+132]
	test	esi, esi
	jne	$LN1098@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN475@transactio:
	mov	edi, DWORD PTR tv4831[esp+132]
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN466@transactio
	call	__invalid_parameter_noinfo
$LN466@transactio:
	mov	eax, DWORD PTR [edi+188]
	mov	DWORD PTR $T646974[esp+132], eax
	cmp	DWORD PTR [edi+184], eax
	jbe	SHORT $LN483@transactio
	call	__invalid_parameter_noinfo
$LN483@transactio:
	mov	ebp, DWORD PTR [edi+172]
	mov	DWORD PTR $T645559[esp+132], ebp

; 1208 : 			for (vector<Bank>::const_iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	test	esi, esi
	jne	$LN1097@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN507@transactio:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN498@transactio
	call	__invalid_parameter_noinfo
$LN498@transactio:
	mov	esi, DWORD PTR [edi+184]
	cmp	esi, DWORD PTR [edi+188]
	jbe	SHORT $LN515@transactio
	call	__invalid_parameter_noinfo
$LN515@transactio:
	mov	eax, edi
	mov	edi, DWORD PTR [eax+172]
	lea	ebx, DWORD PTR [esi+32]
$LL530@transactio:
	test	edi, edi
	je	SHORT $LN542@transactio
	cmp	edi, ebp
	je	SHORT $LN543@transactio
$LN542@transactio:
	call	__invalid_parameter_noinfo
$LN543@transactio:
	cmp	esi, DWORD PTR $T646974[esp+132]
	je	$LN31@transactio

; 1209 : 			{
; 1210 : 				if (i->back())

	test	edi, edi
	jne	$LN1096@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN561@transactio:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN552@transactio
	call	__invalid_parameter_noinfo
$LN552@transactio:
	mov	eax, DWORD PTR [ebx-24]
	test	eax, eax
	je	SHORT $LN572@transactio
	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ebx-20]
	lea	eax, DWORD PTR [edx+eax-1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	cmp	edx, ecx
	jb	SHORT $LN572@transactio
	call	__invalid_parameter_noinfo
$LN572@transactio:

; 1211 : 					assert(i->back()->isRefresh() || i->back()->isReadOrWrite());
; 1212 : 
; 1213 : 				// either cannot fit a single REF command or cannot fit Pre + REF
; 1214 : 				if (i->isFull() ||
; 1215 : 					(i->freeCommandSlots() < 2 && !i->back()->isPrecharge()))

	test	edi, edi
	jne	$LN1095@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN588@transactio:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN579@transactio
	call	__invalid_parameter_noinfo
$LN579@transactio:
	mov	eax, DWORD PTR [ebx+4]
	sub	eax, DWORD PTR [ebx]
	sar	eax, 2
	cmp	eax, DWORD PTR [ebx-24]
	je	$LN1117@transactio
	test	edi, edi
	jne	$LN1094@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN608@transactio:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN599@transactio
	call	__invalid_parameter_noinfo
$LN599@transactio:
	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	sar	ecx, 2
	sub	ecx, DWORD PTR [ebx-24]
	cmp	ecx, 2
	jae	SHORT $LN32@transactio
	test	edi, edi
	jne	SHORT $LN1093@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN628@transactio:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN619@transactio
	call	__invalid_parameter_noinfo
$LN619@transactio:
	call	?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::back
	mov	eax, DWORD PTR [eax+80]
	cmp	eax, 2
	je	SHORT $LN32@transactio
	cmp	eax, 4
	je	SHORT $LN32@transactio
	cmp	eax, 6
	jne	$LN1117@transactio
$LN32@transactio:

; 1208 : 			for (vector<Bank>::const_iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	test	edi, edi
	jne	SHORT $LN1092@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN537@transactio:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN528@transactio
	call	__invalid_parameter_noinfo
$LN528@transactio:
	add	esi, 152				; 00000098H
	add	ebx, 152				; 00000098H
	jmp	$LL530@transactio
$LN1098@transactio:

; 1202 : 		{
; 1203 : 			// make sure that there is room in all the queues for one command
; 1204 : 			// refresh commands refresh a row, but kill everything currently in the sense amps
; 1205 : 			// therefore, we need to make sure that the refresh commands happen when all banks
; 1206 : 			// are available
; 1207 : 			vector<Bank>::const_iterator bankEnd = destinationRank->bank.end();

	mov	eax, DWORD PTR [esi]
	jmp	$LN475@transactio
$LN1097@transactio:

; 1208 : 			for (vector<Bank>::const_iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	mov	eax, DWORD PTR [esi]
	jmp	$LN507@transactio
$LN1096@transactio:

; 1209 : 			{
; 1210 : 				if (i->back())

	mov	eax, DWORD PTR [edi]
	jmp	$LN561@transactio
$LN1095@transactio:

; 1211 : 					assert(i->back()->isRefresh() || i->back()->isReadOrWrite());
; 1212 : 
; 1213 : 				// either cannot fit a single REF command or cannot fit Pre + REF
; 1214 : 				if (i->isFull() ||
; 1215 : 					(i->freeCommandSlots() < 2 && !i->back()->isPrecharge()))

	mov	eax, DWORD PTR [edi]
	jmp	$LN588@transactio
$LN1094@transactio:
	mov	eax, DWORD PTR [edi]
	jmp	$LN608@transactio
$LN1093@transactio:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN628@transactio
$LN1092@transactio:

; 1208 : 			for (vector<Bank>::const_iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN537@transactio
$LN31@transactio:

; 1216 : 					return false;
; 1217 : 			}
; 1218 : 			// then add the command to all queues
; 1219 : 			Command *refreshCommand = new Command(incomingTransaction, time, false, timingSpecification.tBurst());

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T645563[esp+132], eax
	mov	ebx, DWORD PTR _incomingTransaction$[esp+128]
	xor	esi, esi
	mov	DWORD PTR __$EHRec$[esp+140], 4
	cmp	eax, esi
	je	SHORT $LN73@transactio
	mov	edx, DWORD PTR _this$[esp+128]
	mov	ecx, DWORD PTR [edx+32]
	push	ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR [edx+8]
	push	esi
	push	ecx
	push	edx
	push	eax
	lea	edx, DWORD PTR [esi+1]
	mov	ecx, ebx
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	DWORD PTR $T645562[esp+132], eax
	jmp	SHORT $LN74@transactio
$LN73@transactio:
	mov	DWORD PTR $T645562[esp+132], esi
$LN74@transactio:
	mov	DWORD PTR __$EHRec$[esp+140], -1

; 1220 : 
; 1221 : 			Address tempAddr(incomingTransaction->getAddress());

	movq	xmm0, QWORD PTR [ebx+40]

; 1222 : 			unsigned bankNumber = 0;
; 1223 : 
; 1224 : 			for (vector<Bank>::iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	mov	eax, DWORD PTR __Tmp$645762[esp+132]
	movq	QWORD PTR _tempAddr$219359[esp+132], xmm0
	movq	xmm0, QWORD PTR [ebx+48]
	movq	QWORD PTR _tempAddr$219359[esp+140], xmm0
	movq	xmm0, QWORD PTR [ebx+56]
	movq	QWORD PTR _tempAddr$219359[esp+148], xmm0
	movq	xmm0, QWORD PTR [ebx+64]
	movq	QWORD PTR _tempAddr$219359[esp+156], xmm0
	movq	xmm0, QWORD PTR [ebx+72]
	movq	QWORD PTR _tempAddr$219359[esp+164], xmm0
	mov	DWORD PTR _bankNumber$219360[esp+132], esi
	cmp	eax, esi
	jne	$LN1091@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN654@transactio:
	mov	edi, DWORD PTR tv4831[esp+132]
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN645@transactio
	call	__invalid_parameter_noinfo
$LN645@transactio:
	mov	esi, DWORD PTR [edi+184]
	cmp	esi, DWORD PTR [edi+188]
	jbe	SHORT $LN662@transactio
	call	__invalid_parameter_noinfo
$LN662@transactio:
	mov	ebp, DWORD PTR [edi+172]
	lea	edi, DWORD PTR [esi+32]
$LL679@transactio:
	test	ebp, ebp
	je	SHORT $LN691@transactio
	cmp	ebp, DWORD PTR $T645559[esp+132]
	je	SHORT $LN692@transactio
$LN691@transactio:
	call	__invalid_parameter_noinfo
$LN692@transactio:
	lea	esi, DWORD PTR [edi-32]
	cmp	esi, DWORD PTR $T646974[esp+132]
	je	$LN25@transactio

; 1225 : 			{
; 1226 : 				// can only refresh banks that are in the precharged state
; 1227 : 				if (i->back() && i->back()->isReadOrWrite())

	test	ebp, ebp
	jne	$LN1090@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN712@transactio:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN703@transactio
	call	__invalid_parameter_noinfo
$LN703@transactio:
	mov	eax, DWORD PTR [edi-24]
	lea	ebx, DWORD PTR [edi-24]
	test	eax, eax
	je	$LN24@transactio
	mov	ecx, DWORD PTR [edi+4]
	sub	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi-20]
	lea	eax, DWORD PTR [eax+edx-1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	esi, edx
	cmp	esi, ecx
	jb	SHORT $LN723@transactio
	call	__invalid_parameter_noinfo
$LN723@transactio:
	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax+esi*4], 0
	je	$LN24@transactio
	test	ebp, ebp
	jne	SHORT $LN1089@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN741@transactio:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN732@transactio
	call	__invalid_parameter_noinfo
$LN732@transactio:
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN748@transactio
	mov	ecx, DWORD PTR [edi+4]
	sub	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi-20]
	lea	eax, DWORD PTR [eax+edx-1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	esi, edx
	cmp	esi, ecx
	jb	SHORT $LN752@transactio
	call	__invalid_parameter_noinfo
$LN752@transactio:
	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN749@transactio
$LN1091@transactio:

; 1222 : 			unsigned bankNumber = 0;
; 1223 : 
; 1224 : 			for (vector<Bank>::iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	mov	eax, DWORD PTR [eax]
	jmp	$LN654@transactio
$LN1090@transactio:

; 1225 : 			{
; 1226 : 				// can only refresh banks that are in the precharged state
; 1227 : 				if (i->back() && i->back()->isReadOrWrite())

	mov	eax, DWORD PTR [ebp]
	jmp	$LN712@transactio
$LN1089@transactio:
	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN741@transactio
$LN748@transactio:
	xor	esi, esi
$LN749@transactio:
	mov	eax, DWORD PTR [esi+80]
	cmp	eax, 1
	je	SHORT $LN759@transactio
	cmp	eax, 2
	je	SHORT $LN759@transactio
	cmp	eax, 3
	je	SHORT $LN759@transactio
	cmp	eax, 4
	jne	SHORT $LN24@transactio
$LN759@transactio:

; 1228 : 				{
; 1229 : 					i->back()->setAutoPrecharge(true);

	test	ebp, ebp
	jne	SHORT $LN1088@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN782@transactio:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN773@transactio
	call	__invalid_parameter_noinfo
$LN773@transactio:
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN789@transactio
	mov	ecx, DWORD PTR [edi+4]
	sub	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi-20]
	lea	eax, DWORD PTR [eax+edx-1]
	sar	ecx, 2
	xor	edx, edx
	div	ecx
	mov	esi, edx
	cmp	esi, ecx
	jb	SHORT $LN793@transactio
	call	__invalid_parameter_noinfo
$LN793@transactio:
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN790@transactio
$LN1088@transactio:
	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN782@transactio
$LN789@transactio:
	xor	eax, eax
$LN790@transactio:
	mov	ecx, DWORD PTR [eax+80]
	lea	edx, DWORD PTR [ecx-1]
	cmp	edx, 3
	ja	$LN873@transactio
	jmp	DWORD PTR $LN1120@transactio[edx*4]
$LN800@transactio:
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	lea	edx, DWORD PTR [edx+edx+2]
	mov	DWORD PTR [eax+80], edx
	jmp	$LN873@transactio
$LN24@transactio:

; 1230 : 				}
; 1231 : 				// add a Pre command before the REF to flush written data back to the banks before executing a refresh
; 1232 : 				else if (i->isEmpty() && i->isActivated())

	test	ebp, ebp
	jne	$LN1087@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN820@transactio:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN811@transactio
	call	__invalid_parameter_noinfo
$LN811@transactio:
	cmp	DWORD PTR [ebx], 0
	jne	$LN22@transactio
	test	ebp, ebp
	jne	SHORT $LN1086@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN840@transactio:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN831@transactio
	call	__invalid_parameter_noinfo
$LN831@transactio:
	cmp	BYTE PTR [edi+92], 0
	je	$LN22@transactio

; 1233 : 				{
; 1234 : 					// then need to precharge before
; 1235 : 					tempAddr.setBank(bankNumber);

	mov	eax, DWORD PTR _bankNumber$219360[esp+132]
	mov	DWORD PTR _tempAddr$219359[esp+156], eax

; 1236 : 
; 1237 : 					assert(i->freeCommandSlots() >= 2);
; 1238 : #ifndef NDEBUG
; 1239 : 					bool result =
; 1240 : #endif // NDEBUG
; 1241 : 						i->push(new Command(incomingTransaction, tempAddr, time, false, timingSpecification.tBurst(), Command::PRECHARGE));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T645568[esp+132], eax
	mov	DWORD PTR __$EHRec$[esp+140], 5
	test	eax, eax
	je	SHORT $LN75@transactio
	mov	edx, DWORD PTR _this$[esp+128]
	mov	ecx, DWORD PTR [edx+32]
	push	ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR [edx+8]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _tempAddr$219359[esp+148]
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@ABVAddress@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	esi, eax
	jmp	SHORT $LN76@transactio
$LN1087@transactio:

; 1230 : 				}
; 1231 : 				// add a Pre command before the REF to flush written data back to the banks before executing a refresh
; 1232 : 				else if (i->isEmpty() && i->isActivated())

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN820@transactio
$LN1086@transactio:
	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN840@transactio
$LN75@transactio:

; 1236 : 
; 1237 : 					assert(i->freeCommandSlots() >= 2);
; 1238 : #ifndef NDEBUG
; 1239 : 					bool result =
; 1240 : #endif // NDEBUG
; 1241 : 						i->push(new Command(incomingTransaction, tempAddr, time, false, timingSpecification.tBurst(), Command::PRECHARGE));

	xor	esi, esi
$LN76@transactio:
	mov	DWORD PTR __$EHRec$[esp+140], -1
	test	ebp, ebp
	jne	SHORT $LN1085@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN864@transactio:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN855@transactio
	call	__invalid_parameter_noinfo
$LN855@transactio:
	push	esi
	mov	eax, ebx
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push

; 1242 : 					assert(result);
; 1243 : 					assert(&(rank[tempAddr.getRank()].bank[bankNumber]) == &*i);
; 1244 : 				}
; 1245 : 				else

	jmp	SHORT $LN873@transactio
$LN1085@transactio:

; 1236 : 
; 1237 : 					assert(i->freeCommandSlots() >= 2);
; 1238 : #ifndef NDEBUG
; 1239 : 					bool result =
; 1240 : #endif // NDEBUG
; 1241 : 						i->push(new Command(incomingTransaction, tempAddr, time, false, timingSpecification.tBurst(), Command::PRECHARGE));

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN864@transactio
$LN22@transactio:

; 1246 : 				{
; 1247 : 					if (i->isEmpty())

	test	ebp, ebp
	jne	SHORT $LN1084@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN882@transactio:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN873@transactio
	call	__invalid_parameter_noinfo
$LN873@transactio:

; 1248 : 						assert(!i->isActivated());
; 1249 : 					else 
; 1250 : 						assert(i->back()->isRefresh());
; 1251 : 				}
; 1252 : 				
; 1253 : #ifndef NDEBUG
; 1254 : 				bool result =
; 1255 : #endif // NDEBUG
; 1256 : 					i->push(refreshCommand);

	test	ebp, ebp
	jne	SHORT $LN1083@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN902@transactio:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN893@transactio
	call	__invalid_parameter_noinfo
$LN893@transactio:
	mov	eax, DWORD PTR $T645562[esp+132]
	push	eax
	mov	eax, ebx
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push

; 1257 : 				assert (result);
; 1258 : 				bankNumber++;

	inc	DWORD PTR _bankNumber$219360[esp+132]
	test	ebp, ebp
	jne	SHORT $LN1082@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN686@transactio:
	lea	ecx, DWORD PTR [edi-32]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN677@transactio

; 1222 : 			unsigned bankNumber = 0;
; 1223 : 
; 1224 : 			for (vector<Bank>::iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	call	__invalid_parameter_noinfo
$LN677@transactio:
	mov	ebx, DWORD PTR _incomingTransaction$[esp+128]
	add	edi, 152				; 00000098H
	jmp	$LL679@transactio
$LN1084@transactio:

; 1246 : 				{
; 1247 : 					if (i->isEmpty())

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN882@transactio
$LN1083@transactio:

; 1248 : 						assert(!i->isActivated());
; 1249 : 					else 
; 1250 : 						assert(i->back()->isRefresh());
; 1251 : 				}
; 1252 : 				
; 1253 : #ifndef NDEBUG
; 1254 : 				bool result =
; 1255 : #endif // NDEBUG
; 1256 : 					i->push(refreshCommand);

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN902@transactio
$LN1082@transactio:

; 1222 : 			unsigned bankNumber = 0;
; 1223 : 
; 1224 : 			for (vector<Bank>::iterator i = destinationRank->bank.begin(); i != bankEnd; i++)

	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $LN686@transactio
$LN25@transactio:

; 1259 : 			}
; 1260 : 
; 1261 : 			for (vector<Bank>::const_iterator i = rank[incomingTransaction->getAddress().getRank()].bank.begin(); 

	mov	edi, DWORD PTR _this$[esp+128]
	mov	ecx, DWORD PTR [edi+384]
	sub	ecx, DWORD PTR [edi+380]
	mov	esi, DWORD PTR [ebx+60]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	esi, ecx
	jb	SHORT $LN911@transactio
	call	__invalid_parameter_noinfo
$LN911@transactio:
	mov	edx, DWORD PTR [edi+380]
	imul	esi, 200				; 000000c8H
	mov	edi, DWORD PTR [esi+edx+184]
	cmp	edi, DWORD PTR [esi+edx+188]
	lea	esi, DWORD PTR [esi+edx+172]
	jbe	SHORT $LN921@transactio
	call	__invalid_parameter_noinfo
$LN921@transactio:
	mov	ebx, DWORD PTR [esi]
	mov	ebp, edi

; 1262 : 				i != rank[incomingTransaction->getAddress().getRank()].bank.end(); i++)

$LL936@transactio:
	mov	eax, DWORD PTR _incomingTransaction$[esp+128]
	mov	esi, DWORD PTR [eax+60]
	mov	eax, DWORD PTR _this$[esp+128]
	mov	ecx, DWORD PTR [eax+384]
	sub	ecx, DWORD PTR [eax+380]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	esi, ecx
	jb	SHORT $LN950@transactio
	call	__invalid_parameter_noinfo
$LN950@transactio:
	mov	edx, DWORD PTR _this$[esp+128]
	imul	esi, 200				; 000000c8H
	mov	eax, DWORD PTR [edx+380]
	mov	edi, DWORD PTR [esi+eax+188]
	cmp	DWORD PTR [esi+eax+184], edi
	lea	esi, DWORD PTR [esi+eax+172]
	jbe	SHORT $LN960@transactio
	call	__invalid_parameter_noinfo
$LN960@transactio:
	mov	esi, DWORD PTR [esi]
	test	ebx, ebx
	je	SHORT $LN973@transactio
	cmp	ebx, esi
	je	SHORT $LN974@transactio
$LN973@transactio:
	call	__invalid_parameter_noinfo
$LN974@transactio:
	cmp	ebp, edi
	je	$LN16@transactio
	test	ebx, ebx
	jne	SHORT $LN1081@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN943@transactio:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN934@transactio
	call	__invalid_parameter_noinfo
$LN934@transactio:
	add	ebp, 152				; 00000098H
	jmp	$LL936@transactio
$LN1081@transactio:
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN943@transactio
$LN34@transactio:

; 1263 : 			{
; 1264 : 				assert(i->back() == refreshCommand);
; 1265 : 			}
; 1266 : 
; 1267 : 			return true;
; 1268 : 		}
; 1269 : 		else if (!destinationBank->isFull())

	mov	eax, DWORD PTR __Tmp$645980[esp+132]
	test	eax, eax
	jne	SHORT $LN1080@transactio
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN994@transactio:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN985@transactio
	call	__invalid_parameter_noinfo
$LN985@transactio:
	mov	ecx, DWORD PTR [ebp+36]
	sub	ecx, DWORD PTR [ebp+32]
	sar	ecx, 2
	cmp	ecx, DWORD PTR [ebp+8]
	je	$LN1117@transactio

; 1270 : 		{	
; 1271 : 			// try to do a normal open page insert on this transaction
; 1272 : 			if (destinationBank->aggressiveInsert(incomingTransaction, time))

	mov	ebp, DWORD PTR _this$[esp+128]
	mov	edx, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR [ebp+8]
	push	edx
	push	eax
	push	ebx
	lea	esi, DWORD PTR _destinationBank$[esp+144]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	push	eax
	call	?aggressiveInsert@Bank@DRAMsimII@@QAE_NPAVTransaction@2@_J@Z ; DRAMsimII::Bank::aggressiveInsert
	test	al, al
	je	SHORT $LN13@transactio

; 1273 : 			{
; 1274 : 				// found place to insert, hit
; 1275 : 				statistics.reportHit();

	mov	eax, DWORD PTR [ebp+180]
	inc	DWORD PTR [eax+56]

; 1276 : 			}
; 1277 : 			else

	jmp	$LN1064@transactio
$LN1080@transactio:

; 1263 : 			{
; 1264 : 				assert(i->back() == refreshCommand);
; 1265 : 			}
; 1266 : 
; 1267 : 			return true;
; 1268 : 		}
; 1269 : 		else if (!destinationBank->isFull())

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN994@transactio
$LN13@transactio:

; 1278 : 			{
; 1279 : 				// first, the precharge command, if necessary
; 1280 : 				if (((destinationBank->isEmpty() && destinationBank->isActivated()) || 
; 1281 : 					(!destinationBank->isEmpty() && !destinationBank->back()->isRefresh())))

	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN9@transactio
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	cmp	BYTE PTR [eax+124], 0
	jne	SHORT $LN10@transactio
$LN9@transactio:
	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	cmp	DWORD PTR [eax+8], 0
	je	$LN11@transactio
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::back
	cmp	DWORD PTR [eax+80], 12			; 0000000cH
	je	$LN11@transactio
$LN10@transactio:

; 1282 : 				{
; 1283 : 					assert(!destinationBank->back() || !destinationBank->back()->isPrecharge());
; 1284 : 
; 1285 : 					if (destinationBank->freeCommandSlots() < 3) 

	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, DWORD PTR [eax+32]
	sar	ecx, 2
	sub	ecx, DWORD PTR [eax+8]
	cmp	ecx, 3
	jae	$LN8@transactio

; 1286 : 					{
; 1287 : 						// for aggressive mode, set CAS(W) to CAS(W)+P when there are only two slots left
; 1288 : 						if (systemConfig.getRowBufferManagementPolicy() == OPEN_PAGE_AGGRESSIVE &&
; 1289 : 							destinationBank->freeCommandSlots() == 2 && 
; 1290 : 							destinationBank->back()->isReadOrWrite())

	mov	edx, DWORD PTR [ebp+176]
	mov	eax, DWORD PTR [edx+328]
	cmp	eax, 2
	jne	$LN1117@transactio
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, DWORD PTR [eax+32]
	sar	ecx, 2
	sub	ecx, DWORD PTR [eax+8]
	cmp	ecx, 2
	jne	$LN1117@transactio
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::back
	call	?isReadOrWrite@Command@DRAMsimII@@QBE_NXZ ; DRAMsimII::Command::isReadOrWrite
	test	al, al
	je	$LN1117@transactio

; 1291 : 						{
; 1292 : 							assert(!destinationBank->back()->isPrecharge());
; 1293 : 							assert(destinationBank->back()->isReadOrWrite());
; 1294 : 							destinationBank->back()->setAutoPrecharge(true);

	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	esi, eax
	call	?back@Bank@DRAMsimII@@QBEPBVCommand@2@XZ ; DRAMsimII::Bank::back
	mov	ecx, DWORD PTR [eax+80]
	lea	edx, DWORD PTR [ecx-1]
	cmp	edx, 3
	ja	$LN3@transactio
	jmp	DWORD PTR $LN1121@transactio[edx*4]
$LN1033@transactio:
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	lea	edx, DWORD PTR [edx+edx+2]
	mov	DWORD PTR [eax+80], edx

; 1295 : 						}
; 1296 : 						// not enough slots left
; 1297 : 						else
; 1298 : 						{
; 1299 : 							return false;
; 1300 : 						}
; 1301 : 					}
; 1302 : 					else

	jmp	SHORT $LN3@transactio
$LN8@transactio:

; 1303 : 					{
; 1304 : 						assert(!destinationBank->back() || !destinationBank->back()->isRefresh());
; 1305 : 						assert(!destinationBank->isFull());
; 1306 : #ifndef NDEBUG
; 1307 : 						bool result =
; 1308 : #endif // NDEBUG
; 1309 : 							destinationBank->push(new Command(incomingTransaction, time, false, timingSpecification.tBurst(), Command::PRECHARGE));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T645575[esp+132], eax
	mov	edx, 6
	mov	DWORD PTR __$EHRec$[esp+140], edx
	test	eax, eax
	je	SHORT $LN77@transactio
	mov	ecx, DWORD PTR [ebp+32]
	push	ecx
	mov	ecx, DWORD PTR [ebp+12]
	push	0
	push	ecx
	mov	ecx, DWORD PTR [ebp+8]
	push	ecx
	push	eax
	mov	ecx, ebx
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	edi, eax
	jmp	SHORT $LN78@transactio
$LN77@transactio:
	xor	edi, edi
$LN78@transactio:
	lea	esi, DWORD PTR _destinationBank$[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	push	edi
	add	eax, 8
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push

; 1310 : 						assert(result);
; 1311 : 					}

	jmp	SHORT $LN3@transactio
$LN11@transactio:

; 1312 : 				}
; 1313 : 				else if (destinationBank->freeCommandSlots() < 2)

	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	mov	edx, DWORD PTR [eax+36]
	sub	edx, DWORD PTR [eax+32]
	sar	edx, 2
	sub	edx, DWORD PTR [eax+8]
	cmp	edx, 2

; 1314 : 				{
; 1315 : 					return false;

	jb	$LN1117@transactio
$LN3@transactio:

; 1316 : 				}
; 1317 : 
; 1318 : 				// did not find place to insert
; 1319 : 				statistics.reportMiss();

	mov	eax, DWORD PTR [ebp+180]
	inc	DWORD PTR [eax+60]

; 1320 : 
; 1321 : 				// RAS command
; 1322 : 				assert(!destinationBank->isFull());
; 1323 : #ifndef NDEBUG
; 1324 : 				bool result =
; 1325 : #endif // NDEBUG
; 1326 : 					destinationBank->push(new Command(incomingTransaction, time, false, timingSpecification.tBurst(), Command::ACTIVATE));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T645579[esp+132], eax
	mov	DWORD PTR __$EHRec$[esp+140], 7
	test	eax, eax
	je	SHORT $LN79@transactio
	mov	ecx, DWORD PTR [ebp+32]
	mov	edx, DWORD PTR [ebp+8]
	push	ecx
	mov	ecx, DWORD PTR [ebp+12]
	push	0
	push	ecx
	push	edx
	push	eax
	xor	edx, edx
	mov	ecx, ebx
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	edi, eax
	jmp	SHORT $LN80@transactio
$LN79@transactio:
	xor	edi, edi
$LN80@transactio:
	lea	esi, DWORD PTR _destinationBank$[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	push	edi
	add	eax, 8
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push

; 1327 : 				assert(result);
; 1328 : 
; 1329 : 				// CAS/CASW command
; 1330 : 				assert(!destinationBank->isFull());
; 1331 : #ifndef NDEBUG
; 1332 : 				result =
; 1333 : #endif // NDEBUG
; 1334 : 					destinationBank->push(new Command(incomingTransaction, time, false, timingSpecification.tBurst()));

	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T645583[esp+132], eax
	mov	DWORD PTR __$EHRec$[esp+140], 8
	test	eax, eax
	je	SHORT $LN81@transactio
	mov	ecx, DWORD PTR [ebp+32]
	mov	edx, DWORD PTR [ebp+8]
	push	ecx
	mov	ecx, DWORD PTR [ebp+12]
	push	0
	push	ecx
	push	edx
	push	eax
	mov	edx, 1
	mov	ecx, ebx
	call	??0Command@DRAMsimII@@QAE@PAVTransaction@1@_J_NIW4CommandType@01@@Z ; DRAMsimII::Command::Command
	mov	edi, eax
	jmp	SHORT $LN82@transactio
$LN81@transactio:
	xor	edi, edi
$LN82@transactio:
	mov	DWORD PTR __$EHRec$[esp+140], -1
$LN1118@transactio:
	lea	esi, DWORD PTR _destinationBank$[esp+132]
	call	??C?$_Vector_iterator@VBank@DRAMsimII@@V?$allocator@VBank@DRAMsimII@@@std@@@std@@QBEPAVBank@DRAMsimII@@XZ ; std::_Vector_iterator<DRAMsimII::Bank,std::allocator<DRAMsimII::Bank> >::operator->
	push	edi
	add	eax, 8
	call	?push@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAE_NPAVCommand@2@@Z ; DRAMsimII::Queue<DRAMsimII::Command>::push
$LN1064@transactio:

; 1349 : 
; 1350 : 	}
; 1351 : 
; 1352 : 	incomingTransaction->setDecodeTime(time);

	mov	ecx, DWORD PTR _this$[esp+128]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _incomingTransaction$[esp+128]
	mov	DWORD PTR [eax+88], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+92], ecx
$LN16@transactio:

; 1353 : 
; 1354 : 	return true;

	mov	al, 1
	jmp	SHORT $LN63@transactio
$LN1@transactio:

; 1335 : 				assert(result);
; 1336 : 			}
; 1337 : 		}
; 1338 : 		else
; 1339 : 		{
; 1340 : 			return false;
; 1341 : 		}
; 1342 : 
; 1343 : 		break;
; 1344 : 
; 1345 : 	default:
; 1346 : 
; 1347 : 		cerr << "Unhandled row buffer management policy" << endl;

	push	OFFSET ??_C@_0CH@PMAPFHOL@Unhandled?5row?5buffer?5management?5@
	push	OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN1117@transactio:

; 1348 : 		return false;

	xor	al, al
$LN63@transactio:

; 1355 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+132]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 112				; 00000070H
	ret	8
	npad	1
$LN1119@transactio:
	DD	$LN36@transactio
	DD	$LN43@transactio
	DD	$LN59@transactio
	DD	$LN59@transactio
$LN1120@transactio:
	DD	$LN800@transactio
	DD	$LN873@transactio
	DD	$LN800@transactio
	DD	$LN873@transactio
$LN1121@transactio:
	DD	$LN1033@transactio
	DD	$LN3@transactio
	DD	$LN1033@transactio
	DD	$LN3@transactio
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$0:
	mov	esi, DWORD PTR $T645541[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$1:
	mov	esi, DWORD PTR $T645547[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$2:
	mov	esi, DWORD PTR $T645551[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$3:
	mov	esi, DWORD PTR $T645555[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$4:
	mov	esi, DWORD PTR $T645563[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$5:
	mov	esi, DWORD PTR $T645568[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$6:
	mov	esi, DWORD PTR $T645575[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$7:
	mov	esi, DWORD PTR $T645579[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z$8:
	mov	esi, DWORD PTR $T645583[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__ehhandler$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-116]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z
	jmp	___CxxFrameHandler3
?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z ENDP ; DRAMsimII::Channel::transaction2commands
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_currentTime$ = 8					; size = 8
?moveToTime@Channel@DRAMsimII@@UAEX_J@Z PROC		; DRAMsimII::Channel::moveToTime
; _this$ = ecx

; 184  : {	

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 185  : 	assert(finishedTransactions.size() == 0);
; 186  : 
; 187  : 	/// @todo continue until no events are processed, no commands issued, no transactions decoded
; 188  : 	while (time < currentTime)

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR _currentTime$[ebp+4]
	push	edi
	jg	$LN191@moveToTime@2
	jl	SHORT $LL6@moveToTime@2
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, DWORD PTR _currentTime$[ebp]
	jae	$LN191@moveToTime@2
$LL6@moveToTime@2:

; 189  : 	{	
; 190  : 		// move time to either when the next command executes or the next transaction decodes, whichever is earlier
; 191  : 		// otherwise just go to the end
; 192  : #ifndef NDEBUG
; 193  : 		tick oldTime = time;
; 194  : #endif
; 195  : 		/// @todo verify that this is right
; 196  : 		//time = max(min(currentTime,min(nextTransactionDecodeTime(),min(nextCommandExecuteTime(),nextRefreshTime()))),time);
; 197  : 		time = max(min(currentTime,min(nextTransactionDecodeTime(),nextCommandExecuteTime())),time);

	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN23@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN24@moveToTime@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN27@moveToTime@2
$LN24@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN27@moveToTime@2
$LN23@moveToTime@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN27@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN38@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN37@moveToTime@2
$LN38@moveToTime@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN37@moveToTime@2:
	cmp	edi, edx
	jg	SHORT $LN9@moveToTime@2
	jl	SHORT $LN183@moveToTime@2
	cmp	ebx, eax
	jae	SHORT $LN9@moveToTime@2
$LN183@moveToTime@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN56@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN42@moveToTime@2
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	jmp	SHORT $LN55@moveToTime@2
$LN42@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	add	eax, DWORD PTR [ecx+16]
	adc	edx, DWORD PTR [ecx+20]
	jmp	SHORT $LN55@moveToTime@2
$LN9@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN56@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN55@moveToTime@2
$LN56@moveToTime@2:
	mov	edx, 2147483647				; 7fffffffH
	or	eax, -1
$LN55@moveToTime@2:
	mov	ecx, DWORD PTR _currentTime$[ebp+4]
	cmp	ecx, edx
	jg	SHORT $LN13@moveToTime@2
	jl	SHORT $LN184@moveToTime@2
	cmp	DWORD PTR _currentTime$[ebp], eax
	jae	SHORT $LN13@moveToTime@2
$LN184@moveToTime@2:
	mov	eax, DWORD PTR _currentTime$[ebp]
	mov	edx, ecx
	jmp	$LN91@moveToTime@2
$LN13@moveToTime@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN59@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN60@moveToTime@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN63@moveToTime@2
$LN60@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN63@moveToTime@2
$LN59@moveToTime@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN63@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN74@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN73@moveToTime@2
$LN74@moveToTime@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN73@moveToTime@2:
	cmp	edi, edx
	jg	SHORT $LN11@moveToTime@2
	jl	SHORT $LN185@moveToTime@2
	cmp	ebx, eax
	jae	SHORT $LN11@moveToTime@2
$LN185@moveToTime@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN92@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN78@moveToTime@2
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	jmp	SHORT $LN91@moveToTime@2
$LN78@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	add	eax, DWORD PTR [ecx+16]
	adc	edx, DWORD PTR [ecx+20]
	jmp	SHORT $LN91@moveToTime@2
$LN11@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN92@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN91@moveToTime@2
$LN92@moveToTime@2:
	mov	edx, 2147483647				; 7fffffffH
	or	eax, -1
$LN91@moveToTime@2:
	mov	ecx, DWORD PTR [esi+12]
	cmp	edx, ecx
	mov	edi, DWORD PTR [esi+8]
	jl	$LN21@moveToTime@2
	jg	SHORT $LN186@moveToTime@2
	cmp	eax, edi
	jbe	$LN21@moveToTime@2
$LN186@moveToTime@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN95@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN96@moveToTime@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN99@moveToTime@2
$LN96@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN99@moveToTime@2
$LN95@moveToTime@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN99@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN110@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN109@moveToTime@2
$LN110@moveToTime@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN109@moveToTime@2:
	cmp	edi, edx
	jg	SHORT $LN15@moveToTime@2
	jl	SHORT $LN187@moveToTime@2
	cmp	ebx, eax
	jae	SHORT $LN15@moveToTime@2
$LN187@moveToTime@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN128@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN114@moveToTime@2
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	jmp	SHORT $LN127@moveToTime@2
$LN114@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	add	eax, DWORD PTR [ecx+16]
	adc	edx, DWORD PTR [ecx+20]
	jmp	SHORT $LN127@moveToTime@2
$LN15@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN128@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN127@moveToTime@2
$LN128@moveToTime@2:
	mov	edx, 2147483647				; 7fffffffH
	or	eax, -1
$LN127@moveToTime@2:
	mov	ecx, DWORD PTR _currentTime$[ebp+4]
	cmp	ecx, edx
	jg	SHORT $LN19@moveToTime@2
	jl	SHORT $LN188@moveToTime@2
	cmp	DWORD PTR _currentTime$[ebp], eax
	jae	SHORT $LN19@moveToTime@2
$LN188@moveToTime@2:
	mov	eax, DWORD PTR _currentTime$[ebp]
	jmp	$LN201@moveToTime@2
$LN19@moveToTime@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN131@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN132@moveToTime@2
	mov	ebx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	jmp	SHORT $LN135@moveToTime@2
$LN132@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	mov	ebx, eax
	add	ebx, DWORD PTR [ecx+16]
	mov	edi, edx
	adc	edi, DWORD PTR [ecx+20]
	jmp	SHORT $LN135@moveToTime@2
$LN131@moveToTime@2:
	or	ebx, -1
	mov	edi, 2147483647				; 7fffffffH
$LN135@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN146@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN145@moveToTime@2
$LN146@moveToTime@2:
	or	eax, -1
	mov	edx, 2147483647				; 7fffffffH
$LN145@moveToTime@2:
	cmp	edi, edx
	jg	SHORT $LN17@moveToTime@2
	jl	SHORT $LN189@moveToTime@2
	cmp	ebx, eax
	jae	SHORT $LN17@moveToTime@2
$LN189@moveToTime@2:
	push	0
	mov	eax, esi
	call	?readTransaction@Channel@DRAMsimII@@IBEPBVTransaction@2@_N@Z ; DRAMsimII::Channel::readTransaction
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN164@moveToTime@2
	cmp	DWORD PTR [ecx+80], 4
	jne	SHORT $LN150@moveToTime@2
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	jmp	SHORT $LN22@moveToTime@2
$LN150@moveToTime@2:
	mov	eax, DWORD PTR [esi+104]
	cdq
	add	eax, DWORD PTR [ecx+16]
	adc	edx, DWORD PTR [ecx+20]
	jmp	SHORT $LN22@moveToTime@2
$LN17@moveToTime@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	SHORT $LN164@moveToTime@2
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax
	jmp	SHORT $LN22@moveToTime@2
$LN164@moveToTime@2:
	mov	edx, 2147483647				; 7fffffffH
	or	eax, -1
	jmp	SHORT $LN22@moveToTime@2
$LN21@moveToTime@2:
	mov	eax, edi
$LN201@moveToTime@2:
	mov	edx, ecx
$LN22@moveToTime@2:
	mov	DWORD PTR [esi+8], eax

; 198  : 		assert(time <= currentTime);
; 199  : 		assert(time >= oldTime);
; 200  : 
; 201  : 		// has room to decode an available transaction, as many as are ready
; 202  : 		// 		unsigned decodedCount = 0;
; 203  : 		// 		unsigned decodedRefreshCount = 0;
; 204  : 
; 205  : 		while (Transaction *nextTransaction = getTransaction())

	mov	eax, esi
	mov	DWORD PTR [esi+12], edx
	call	?getTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ; DRAMsimII::Channel::getTransaction
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN3@moveToTime@2
$LL4@moveToTime@2:

; 206  : 		{
; 207  : 			// actually remove it from the queue now
; 208  : 			//Transaction *decodedTransaction = getTransaction();
; 209  : 			assert(nextTransaction);
; 210  : 
; 211  : 			// 			if (nextTransaction->isRefresh())
; 212  : 			// 				decodedRefreshCount++;
; 213  : 			// 			else
; 214  : 			// 				decodedCount++;
; 215  : 			// then break into commands and insert into per bank command queues			
; 216  : 			assert(checkForAvailableCommandSlots(nextTransaction));
; 217  : 
; 218  : #ifndef NDEBUG
; 219  : 			bool t2cResult =
; 220  : #endif
; 221  : 				transaction2commands(nextTransaction);

	push	edi
	push	esi
	call	?transaction2commands@Channel@DRAMsimII@@IAE_NPAVTransaction@2@@Z ; DRAMsimII::Channel::transaction2commands

; 222  : 
; 223  : 
; 224  : 			assert(t2cResult);
; 225  : 
; 226  : 			nextTransaction->setDecodeTime(time);

	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+88], ecx
	mov	edx, DWORD PTR [esi+12]
	mov	eax, esi
	mov	DWORD PTR [edi+92], edx
	call	?getTransaction@Channel@DRAMsimII@@IAEPAVTransaction@2@XZ ; DRAMsimII::Channel::getTransaction
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL4@moveToTime@2
$LN3@moveToTime@2:

; 227  : 			// checkForAvailablecommandSlots() should not have returned true if there was not enough space
; 228  : 
; 229  : 			DEBUG_TRANSACTION_LOG("T->C [" << std::dec << time << "] Q[" << std::dec << getTransactionQueueCount() << "/" << std::dec << transactionQueue.depth() << "]->[" << std::dec <<
; 230  : 				rank[nextTransaction->getAddress().getRank()].bank[nextTransaction->getAddress().getBank()].size() << "/" << std::dec <<
; 231  : 				rank[nextTransaction->getAddress().getRank()].bank[nextTransaction->getAddress().getBank()].depth() << "] " << *nextTransaction);
; 232  : 
; 233  : 			//nextToDecode = readAvailableTransaction();
; 234  : 			//nextTransaction = readTransaction(true);
; 235  : 		}		
; 236  : #ifndef NDEBUG
; 237  : 		//if (decodedCount > 3 || decodedRefreshCount > 1)
; 238  : 		//cerr << "decoded " << decodedCount << "/" << decodedRefreshCount << endl;
; 239  : #endif
; 240  : 
; 241  : 		// execute commands for this time, reevaluate what the next command is since this may have changed after decoding the transaction
; 242  : 		const Command *nextCommand = readNextCommand();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	mov	ecx, esi
	call	edx
	mov	edi, eax

; 243  : 
; 244  : 		while (nextCommand && (earliestExecuteTime(nextCommand) <= time))

	test	edi, edi
	je	SHORT $LN1@moveToTime@2
$LL2@moveToTime@2:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+8]
	push	edi
	mov	ecx, esi
	call	edx
	cmp	edx, DWORD PTR [esi+12]
	jg	SHORT $LN1@moveToTime@2
	jl	SHORT $LN190@moveToTime@2
	cmp	eax, DWORD PTR [esi+8]
	ja	SHORT $LN1@moveToTime@2
$LN190@moveToTime@2:

; 245  : 		{
; 246  : 			Command *executingCommand = getNextCommand(nextCommand);

	push	edi
	push	esi
	call	?getNextCommand@Channel@DRAMsimII@@IAEPAVCommand@2@PBV32@@Z ; DRAMsimII::Channel::getNextCommand
	mov	edi, eax

; 247  : 
; 248  : 			assert(executingCommand == nextCommand);
; 249  : 
; 250  : 			assert(earliestExecuteTimeLog(nextCommand) <= time);
; 251  : 
; 252  : 			executeCommand(executingCommand);	

	push	edi
	push	esi
	call	?executeCommand@Channel@DRAMsimII@@IAEXPAVCommand@2@@Z ; DRAMsimII::Channel::executeCommand

; 253  : 
; 254  : 			DEBUG_COMMAND_LOG("C " << *executingCommand);
; 255  : 
; 256  : //#ifndef NDEBUG
; 257  : 			printVerilogCommand(executingCommand);

	mov	eax, edi
	mov	ecx, esi
	call	?printVerilogCommand@Channel@DRAMsimII@@IAEXPBVCommand@2@@Z ; DRAMsimII::Channel::printVerilogCommand

; 258  : //#endif
; 259  : 
; 260  : 			nextCommand = readNextCommand();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	mov	ecx, esi
	call	edx
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL2@moveToTime@2
$LN1@moveToTime@2:

; 185  : 	assert(finishedTransactions.size() == 0);
; 186  : 
; 187  : 	/// @todo continue until no events are processed, no commands issued, no transactions decoded
; 188  : 	while (time < currentTime)

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR _currentTime$[ebp+4]
	jl	$LL6@moveToTime@2
	jg	SHORT $LN191@moveToTime@2
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, DWORD PTR _currentTime$[ebp]
	jb	$LL6@moveToTime@2
$LN191@moveToTime@2:

; 261  : 		}
; 262  : 	}
; 263  : 
; 264  : 	//transFinishTime = currentTime;
; 265  : 	//M5_TIMING_LOG("ch[" << channelID << "] @ " << dec << time);
; 266  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?moveToTime@Channel@DRAMsimII@@UAEX_J@Z ENDP		; DRAMsimII::Channel::moveToTime
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z$0
__ehfuncinfo$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z
_TEXT	SEGMENT
$T650513 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z PROC ; std::_Construct<DRAMsimII::Rank,DRAMsimII::Rank>, COMDAT
; __Val$ = ecx

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Ptr$[esp+20]

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	DWORD PTR __Vptr$[esp+20], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T650513[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	eax, eax
	je	SHORT $LN3@Construct@21
	push	eax
	call	??0Rank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Rank::Rank
$LN3@Construct@21:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T650513[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@VRank@DRAMsimII@@V12@@std@@YAXPAVRank@DRAMsimII@@ABV12@@Z ENDP ; std::_Construct<DRAMsimII::Rank,DRAMsimII::Rank>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *,std::forward_iterator_tag>, COMDAT
; __First$ = ecx
; __Dest$ = eax

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx
	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, eax

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	esi, ebx
	je	SHORT $LN1@Copy_opt@10
	npad	1
$LL3@Copy_opt@10:

; 2472 : 		*_Dest = *_First;

	push	esi
	call	??4Rank@DRAMsimII@@QAEAAV01@ABV01@@Z	; DRAMsimII::Rank::operator=
	add	esi, 200				; 000000c8H
	add	edi, 200				; 000000c8H
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt@10

; 2473 : 	return (_Dest);

	mov	eax, edi
$LN1@Copy_opt@10:

; 2474 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z$0
__ehfuncinfo$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z
_TEXT	SEGMENT
$T650546 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$650552 = 8					; size = 4
__Ptr$ = 8						; size = 4
?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z PROC ; std::allocator<DRAMsimII::Rank>::construct, COMDAT
; __Val$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Ptr$[esp+20]

; 155  : 		_Construct(_Ptr, _Val);

	mov	DWORD PTR __Vptr$650552[esp+20], eax
	mov	DWORD PTR $T650546[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	eax, eax
	je	SHORT $LN5@construct@17
	push	eax
	call	??0Rank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Rank::Rank
$LN5@construct@17:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z$0:
	mov	eax, DWORD PTR __Vptr$650552[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T650546[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@VRank@DRAMsimII@@@std@@QAEXPAVRank@DRAMsimII@@ABV34@@Z ENDP ; std::allocator<DRAMsimII::Rank>::construct
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\smart_ptr\intrusive_ptr.hpp
xdata$x	SEGMENT
__unwindtable$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T650588 = -28						; size = 4
__Vptr$650594 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Val$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; __Count$ = ecx

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	esi, DWORD PTR __First$[ebp]

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
$LL6@Uninit_fil@14:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil@14

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$650594[ebp], esi
	mov	DWORD PTR $T650588[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil@14
	mov	ecx, DWORD PTR __Val$[ebp]
	push	esi
	call	??0Rank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Rank::Rank
$LN18@Uninit_fil@14:
	dec	edi
	add	esi, 200				; 000000c8H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@14
__catch$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@14
	npad	4
$LL3@Uninit_fil@14:

; 407  : 		_Al.destroy(_Next);

	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	esi, 200				; 000000c8H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@14
$LN1@Uninit_fil@14:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN36@Uninit_fil@14:
$LN4@Uninit_fil@14:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@Uninit_fil@14:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$650594[ebp]
	push	eax
	mov	ecx, DWORD PTR $T650588[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@@std@@YAPAVRank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv148 = 8						; size = 4
__Last$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@@std@@YAPAVRank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *>, COMDAT
; __First$ = ecx
; __Dest$ = eax

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+8]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, eax

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	ecx, ebp
	sub	ecx, esi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ebx, eax
	imul	ebx, 200				; 000000c8H
	add	ebx, edi

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	cmp	esi, ebp
	je	SHORT $LN14@Copy_opt@11
	mov	eax, edi
	sub	eax, esi
	mov	DWORD PTR tv148[esp+16], eax
	jmp	SHORT $LN9@Copy_opt@11
	npad	6
$LL15@Copy_opt@11:
	mov	eax, DWORD PTR tv148[esp+16]
$LN9@Copy_opt@11:
	push	esi
	lea	edi, DWORD PTR [eax+esi]
	call	??4Rank@DRAMsimII@@QAEAAV01@ABV01@@Z	; DRAMsimII::Rank::operator=
	add	esi, 200				; 000000c8H
	cmp	esi, ebp
	jne	SHORT $LL15@Copy_opt@11
$LN14@Copy_opt@11:

; 2486 : 	return _Result;
; 2487 : 	}

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	pop	ecx
	ret	0
??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@@std@@YAPAVRank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
$T650659 = -4						; size = 1
__Cat$650663 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
??$unchecked_uninitialized_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT
; __Val$ = edx

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	BYTE PTR $T650659[esp+4], 0
	mov	eax, DWORD PTR $T650659[esp+4]
	mov	ecx, DWORD PTR __Cat$650663[esp+4]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	push	eax
	call	??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >

; 943  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$unchecked_uninitialized_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAVRank@DRAMsimII@@PAV12@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00@Z
_TEXT	SEGMENT
$T650668 = -4						; size = 1
__First$ = 8						; size = 4
__Cat$650673 = 12					; size = 1
$T650670 = 12						; size = 1
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVRank@DRAMsimII@@PAV12@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00@Z PROC ; stdext::unchecked_copy<DRAMsimII::Rank *,DRAMsimII::Rank *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	sub	esp, 8

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$650673[esp+4]
	mov	edx, DWORD PTR $T650670[esp+4]
	mov	BYTE PTR $T650668[esp+8], 0
	mov	eax, DWORD PTR $T650668[esp+8]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+12]
	push	edx
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+20]
	call	??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@@std@@YAPAVRank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *>

; 3607 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$unchecked_copy@PAVRank@DRAMsimII@@PAV12@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00@Z ENDP ; stdext::unchecked_copy<DRAMsimII::Rank *,DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV34@IABV34@@Z
_TEXT	SEGMENT
$T650710 = -4						; size = 1
__Cat$650713 = -4					; size = 1
?_Ufill@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV34@IABV34@@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	BYTE PTR $T650710[esp+4], 0
	mov	eax, DWORD PTR $T650710[esp+4]
	mov	ecx, DWORD PTR __Cat$650713[esp+4]
	push	eax
	push	ecx
	push	edx
	push	edi
	mov	ecx, esi
	call	??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >

; 1255 : 		return (_Ptr + _Count);

	mov	eax, esi
	imul	eax, 200				; 000000c8H
	add	eax, edi

; 1256 : 		}

	add	esp, 20					; 00000014H
	ret	0
?_Ufill@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV34@IABV34@@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@0@Z
_TEXT	SEGMENT
$T650905 = -4						; size = 1
__Cat$650909 = 8					; size = 1
$T650907 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@0@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::erase, COMDAT
; _this$ = esi

; 1028 : 		{	// erase [_First, _Last)

	push	ecx
	push	ebx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+4]
	push	ebp
	push	edi
	mov	DWORD PTR [ebx], 0
	test	esi, esi
	je	SHORT $LN8@erase@32
	mov	eax, DWORD PTR __First_arg$[esp+16]
	cmp	DWORD PTR [esi+12], eax
	ja	SHORT $LN8@erase@32
	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN9@erase@32
$LN8@erase@32:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+16]
$LN9@erase@32:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	edi, DWORD PTR __Last_arg$[esp+16]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [esi+12], edi
	ja	SHORT $LN24@erase@32
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN25@erase@32
$LN24@erase@32:
	call	__invalid_parameter_noinfo
	mov	edi, DWORD PTR __Last_arg$[esp+16]
$LN25@erase@32:

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN38@erase@32
	cmp	eax, ecx
	je	SHORT $LN39@erase@32
$LN38@erase@32:
	call	__invalid_parameter_noinfo
$LN39@erase@32:
	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, edi
	je	SHORT $LN80@erase@32

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ecx, DWORD PTR [esi+16]
	mov	BYTE PTR $T650905[esp+16], 0
	mov	edx, DWORD PTR $T650905[esp+16]
	push	edx
	mov	edx, DWORD PTR __Cat$650909[esp+16]
	push	edx
	mov	edx, DWORD PTR $T650907[esp+20]
	push	edx
	push	ecx
	mov	ecx, edi
	call	??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@@std@@YAPAVRank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *>

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ebp, DWORD PTR [esi+16]
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	edi, ebx
	cmp	ebx, ebp
	je	SHORT $LN66@erase@32
	npad	4
$LL68@erase@32:
	push	edi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	edi, 200				; 000000c8H
	cmp	edi, ebp
	jne	SHORT $LL68@erase@32
$LN66@erase@32:

; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+16], ebx

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]

; 1055 : #endif
; 1056 : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	20					; 00000014H
$LN80@erase@32:
	pop	edi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	pop	ecx
	ret	20					; 00000014H
?erase@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@0@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T651019 = -12						; size = 8
?clear@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXXZ PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 1060 : 		erase(begin(), end());

	mov	ebp, DWORD PTR [esi+16]
	push	edi
	cmp	DWORD PTR [esi+12], ebp
	jbe	SHORT $LN8@clear@23
	call	__invalid_parameter_noinfo
$LN8@clear@23:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN24@clear@23
	call	__invalid_parameter_noinfo
$LN24@clear@23:
	mov	eax, DWORD PTR [esi]
	push	ebp
	push	ebx
	push	edi
	push	eax
	lea	eax, DWORD PTR $T651019[esp+44]
	push	eax
	call	?erase@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE?AV?$_Vector_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@2@0@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::erase

; 1061 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
?clear@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXXZ ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::clear
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z$0
__tryblocktable$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z$2
__ehfuncinfo$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z
_TEXT	SEGMENT
$T651207 = -20						; size = 1
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Cat$651210 = 12					; size = 1
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Construct_n, COMDAT

; 545  : 		{	// construct from _Count * _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR _this$[ebp]

; 546  : 		if (_Buy(_Count))

	mov	ebx, DWORD PTR __Count$[ebp]
	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	cmp	ebx, eax
	je	SHORT $LN7@Construct_@9
	cmp	ebx, 21474836				; 0147ae14H
	jbe	SHORT $LN10@Construct_@9
	call	?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Xlen
$LN32@Construct_@9:
$LN10@Construct_@9:
	mov	ecx, ebx
	call	?allocate@?$allocator@VRank@DRAMsimII@@@std@@QAEPAVRank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Rank>::allocate
	imul	ebx, 200				; 000000c8H
	mov	edi, eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	edx, DWORD PTR __Cat$651210[ebp]
	mov	BYTE PTR $T651207[ebp], 0
	mov	ecx, DWORD PTR $T651207[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ebx+edi]
	mov	DWORD PTR [esi+20], eax
	mov	eax, DWORD PTR __Val$[ebp]
	push	edx
	push	eax
	push	edi
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	call	??$_Uninit_fill_n@PAVRank@DRAMsimII@@IV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAXPAVRank@DRAMsimII@@IABV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<DRAMsimII::Rank *,unsigned int,DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	add	esp, 16					; 00000010H
	add	ebx, edi
	mov	DWORD PTR [esi+16], ebx
$LN7@Construct_@9:

; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z$0:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Tidy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Tidy

; 552  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN33@Construct_@9:
$LN31@Construct_@9:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Construct_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z$0
__ehfuncinfo$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT

; 488  : 		{	// construct from _Count * _Val

	push	-1
	push	__ehhandler$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+20]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@vector@48
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@48
$LN13@vector@48:
	xor	eax, eax
$LN14@vector@48:
	mov	DWORD PTR [esi], eax

; 489  : 		_Construct_n(_Count, _Val);

	mov	eax, DWORD PTR __Val$[esp+20]
	mov	ecx, DWORD PTR __Count$[esp+20]
	push	eax
	push	ecx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+44], 0
	call	?_Construct_n@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXIABVRank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Construct_n

; 490  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z ; DRAMsimII::Channel::Channel
__unwindtable$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$3
__ehfuncinfo$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
tv537 = -220						; size = 4
$T651355 = -216						; size = 200
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_settings$ = 12						; size = 4
_sysConfig$ = 16					; size = 4
_stats$ = 20						; size = 4
??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z PROC ; DRAMsimII::Channel::Channel

; 66   : {

	push	-1
	push	__ehhandler$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 212				; 000000d4H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+244]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _settings$[esp+240]
	mov	ebx, DWORD PTR _this$[esp+240]
	xor	esi, esi
	lea	eax, DWORD PTR [ebx+28]
	mov	ecx, ebp
	mov	DWORD PTR [ebx], OFFSET ??_7Channel@DRAMsimII@@6B@
	mov	DWORD PTR [ebx+8], esi
	mov	DWORD PTR [ebx+12], esi
	mov	DWORD PTR [ebx+16], -100		; ffffff9cH
	mov	DWORD PTR [ebx+20], -1
	mov	DWORD PTR [ebx+24], esi
	call	??0TimingSpecification@DRAMsimII@@QAE@ABVSettings@1@@Z ; DRAMsimII::TimingSpecification::TimingSpecification
	mov	ecx, DWORD PTR [ebp+256]
	push	esi
	lea	eax, DWORD PTR [ebx+112]
	push	eax
	call	??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
	lea	eax, DWORD PTR [ebx+152]
	mov	DWORD PTR __$EHRec$[esp+252], esi
	mov	edi, DWORD PTR [ebp+304]
	push	eax
	call	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
	mov	ecx, DWORD PTR _stats$[esp+240]
	mov	edi, DWORD PTR _sysConfig$[esp+240]
	mov	BYTE PTR __$EHRec$[esp+252], 1
	mov	DWORD PTR [ebx+180], ecx
	lea	esi, DWORD PTR [ebx+184]
	mov	ecx, ebp
	mov	DWORD PTR [ebx+176], edi
	call	??0PowerConfig@DRAMsimII@@QAE@ABVSettings@1@@Z ; DRAMsimII::PowerConfig::PowerConfig
	mov	dl, BYTE PTR [ebp+291]
	push	edi
	lea	eax, DWORD PTR [ebx+28]
	push	eax
	push	ebp
	lea	eax, DWORD PTR $T651355[esp+256]
	push	eax
	mov	BYTE PTR [ebx+364], dl
	call	??0Rank@DRAMsimII@@QAE@ABVSettings@1@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ; DRAMsimII::Rank::Rank
	mov	BYTE PTR __$EHRec$[esp+252], 2
	mov	edi, DWORD PTR [edi+360]
	push	eax
	push	edi
	lea	esi, DWORD PTR [ebx+368]
	push	esi
	call	??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	lea	ecx, DWORD PTR $T651355[esp+244]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+256], 4
	call	??1Rank@DRAMsimII@@QAE@XZ
	push	4
	lea	edi, DWORD PTR [ebx+392]
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN37@Channel@2
	mov	DWORD PTR [eax], edi
	jmp	SHORT $LN38@Channel@2
$LN37@Channel@2:
	xor	eax, eax
$LN38@Channel@2:
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+16], ecx
	mov	DWORD PTR [edi+20], ecx
	mov	DWORD PTR [edi+24], ecx
	mov	DWORD PTR [edi+28], ecx

; 67   : 	// assign an id to each channel (normally done with commands)
; 68   : 	for (unsigned i = 0; i < settings.rankCount; i++)

	xor	edi, edi
	cmp	DWORD PTR [ebp+304], ecx
	jbe	SHORT $LN5@Channel@2

; 66   : {

	mov	DWORD PTR tv537[esp+244], ecx
	npad	2
$LL7@Channel@2:

; 69   : 	{
; 70   : 		rank[i].setRankID(i);

	mov	edx, DWORD PTR [esi+16]
	sub	edx, DWORD PTR [esi+12]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jb	SHORT $LN66@Channel@2
	call	__invalid_parameter_noinfo
	xor	ecx, ecx
$LN66@Channel@2:
	mov	eax, DWORD PTR tv537[esp+244]
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+edx+136], edi
	inc	edi
	add	eax, 200				; 000000c8H
	mov	DWORD PTR tv537[esp+244], eax
	cmp	edi, DWORD PTR [ebp+304]
	jb	SHORT $LL7@Channel@2
$LN5@Channel@2:

; 71   : 	}
; 72   : 
; 73   : 	// initialize the refresh counters per rank
; 74   : 	if (settings.refreshPolicy != NO_REFRESH)

	cmp	DWORD PTR [ebp+196], ecx
	je	SHORT $LN85@Channel@2

; 75   : 	{
; 76   : 		// stagger the times that each rank will be refreshed so they don't all arrive incomingTransaction a burst
; 77   : 		unsigned step = settings.tREFI / settings.rankCount;

	mov	eax, DWORD PTR [ebp+356]
	xor	edx, edx
	div	DWORD PTR [ebp+304]

; 78   : 
; 79   : 		for (unsigned j = 0; j < refreshCounter.size(); ++j)

	mov	edx, DWORD PTR [ebx+168]
	sub	edx, DWORD PTR [ebx+164]
	xor	esi, esi
	sar	edx, 3
	test	edx, edx
	jbe	SHORT $LN85@Channel@2
	xor	edi, edi
	lea	ebp, DWORD PTR [eax+1]
	npad	14
$LL3@Channel@2:

; 80   : 		{
; 81   : 			refreshCounter[j] = j * (step + 1);

	mov	eax, DWORD PTR [ebx+168]
	sub	eax, DWORD PTR [ebx+164]
	sar	eax, 3
	cmp	esi, eax
	jb	SHORT $LN75@Channel@2
	call	__invalid_parameter_noinfo
	xor	ecx, ecx
$LN75@Channel@2:
	mov	eax, DWORD PTR [ebx+164]
	mov	DWORD PTR [eax+esi*8], edi
	mov	DWORD PTR [eax+esi*8+4], ecx
	mov	edx, DWORD PTR [ebx+168]
	sub	edx, DWORD PTR [ebx+164]
	inc	esi
	sar	edx, 3
	add	edi, ebp
	cmp	esi, edx
	jb	SHORT $LL3@Channel@2
$LN85@Channel@2:

; 82   : 		}
; 83   : 	}
; 84   : }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+244]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 224				; 000000e0H
	ret	16					; 00000010H
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 112				; 00000070H
	push	eax
	call	??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$1:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 152				; 00000098H
	jmp	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$2:
	lea	eax, DWORD PTR $T651355[ebp]
	push	eax
	call	??1Rank@DRAMsimII@@QAE@XZ
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z$3:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 368				; 00000170H
	push	eax
	call	??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	ret	0
__ehhandler$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-228]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	jmp	___CxxFrameHandler3
??0Channel@DRAMsimII@@QAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@@Z ENDP ; DRAMsimII::Channel::Channel
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\reporting\soapdramsimwssoaphttpproxy.h
;	COMDAT ?__ns1__submitEpochResult@DRAMsimWSSoapHttp@@UAEHPAV_ns2__submitEpochResultElement@@PAV_ns2__submitEpochResultResponseElement@@@Z
_TEXT	SEGMENT
_ns2__submitEpochResultElement$ = 8			; size = 4
_ns2__submitEpochResultResponseElement$ = 12		; size = 4
?__ns1__submitEpochResult@DRAMsimWSSoapHttp@@UAEHPAV_ns2__submitEpochResultElement@@PAV_ns2__submitEpochResultResponseElement@@@Z PROC ; DRAMsimWSSoapHttp::__ns1__submitEpochResult, COMDAT
; _this$ = ecx

; 37   : 	virtual int __ns1__submitEpochResult(_ns2__submitEpochResultElement *ns2__submitEpochResultElement, _ns2__submitEpochResultResponseElement *ns2__submitEpochResultResponseElement) { return soap ? soap_call___ns1__submitEpochResult(soap, endpoint, NULL, ns2__submitEpochResultElement, ns2__submitEpochResultResponseElement) : SOAP_EOM; };

	mov	eax, ecx
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN3@ns1__submi
	mov	edx, DWORD PTR _ns2__submitEpochResultResponseElement$[esp]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	push	eax
	mov	eax, DWORD PTR _ns2__submitEpochResultElement$[esp+8]
	call	?soap_call___ns1__submitEpochResult@@YAHPAUsoap@@PBD1PAV_ns2__submitEpochResultElement@@PAV_ns2__submitEpochResultResponseElement@@@Z ; soap_call___ns1__submitEpochResult
	add	esp, 8
	pop	ecx
	ret	8
$LN3@ns1__submi:
	mov	eax, 20					; 00000014H
	pop	ecx
	ret	8
?__ns1__submitEpochResult@DRAMsimWSSoapHttp@@UAEHPAV_ns2__submitEpochResultElement@@PAV_ns2__submitEpochResultResponseElement@@@Z ENDP ; DRAMsimWSSoapHttp::__ns1__submitEpochResult
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?__ns1__getSettingsFile@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSettingsFileElement@@PAV_ns2__getSettingsFileResponseElement@@@Z
_TEXT	SEGMENT
_ns2__getSettingsFileElement$ = 8			; size = 4
_ns2__getSettingsFileResponseElement$ = 12		; size = 4
?__ns1__getSettingsFile@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSettingsFileElement@@PAV_ns2__getSettingsFileResponseElement@@@Z PROC ; DRAMsimWSSoapHttp::__ns1__getSettingsFile, COMDAT
; _this$ = ecx

; 35   : 	virtual int __ns1__getSettingsFile(_ns2__getSettingsFileElement *ns2__getSettingsFileElement, _ns2__getSettingsFileResponseElement *ns2__getSettingsFileResponseElement) { return soap ? soap_call___ns1__getSettingsFile(soap, endpoint, NULL, ns2__getSettingsFileElement, ns2__getSettingsFileResponseElement) : SOAP_EOM; };

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN3@ns1__getSe
	mov	edx, DWORD PTR _ns2__getSettingsFileResponseElement$[esp-4]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	push	eax
	mov	eax, DWORD PTR _ns2__getSettingsFileElement$[esp+4]
	call	?soap_call___ns1__getSettingsFile@@YAHPAUsoap@@PBD1PAV_ns2__getSettingsFileElement@@PAV_ns2__getSettingsFileResponseElement@@@Z ; soap_call___ns1__getSettingsFile
	add	esp, 8
	ret	8
$LN3@ns1__getSe:
	mov	eax, 20					; 00000014H
	ret	8
?__ns1__getSettingsFile@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSettingsFileElement@@PAV_ns2__getSettingsFileResponseElement@@@Z ENDP ; DRAMsimWSSoapHttp::__ns1__getSettingsFile
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?__ns1__getSessionID@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSessionIDElement@@PAV_ns2__getSessionIDResponseElement@@@Z
_TEXT	SEGMENT
_ns2__getSessionIDElement$ = 8				; size = 4
_ns2__getSessionIDResponseElement$ = 12			; size = 4
?__ns1__getSessionID@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSessionIDElement@@PAV_ns2__getSessionIDResponseElement@@@Z PROC ; DRAMsimWSSoapHttp::__ns1__getSessionID, COMDAT
; _this$ = ecx

; 33   : 	virtual int __ns1__getSessionID(_ns2__getSessionIDElement *ns2__getSessionIDElement, _ns2__getSessionIDResponseElement *ns2__getSessionIDResponseElement) { return soap ? soap_call___ns1__getSessionID(soap, endpoint, NULL, ns2__getSessionIDElement, ns2__getSessionIDResponseElement) : SOAP_EOM; };

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN3@ns1__getSe@2
	mov	edx, DWORD PTR _ns2__getSessionIDResponseElement$[esp-4]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	push	eax
	mov	eax, DWORD PTR _ns2__getSessionIDElement$[esp+4]
	call	?soap_call___ns1__getSessionID@@YAHPAUsoap@@PBD1PAV_ns2__getSessionIDElement@@PAV_ns2__getSessionIDResponseElement@@@Z ; soap_call___ns1__getSessionID
	add	esp, 8
	ret	8
$LN3@ns1__getSe@2:
	mov	eax, 20					; 00000014H
	ret	8
?__ns1__getSessionID@DRAMsimWSSoapHttp@@UAEHPAV_ns2__getSessionIDElement@@PAV_ns2__getSessionIDResponseElement@@@Z ENDP ; DRAMsimWSSoapHttp::__ns1__getSessionID
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\smart_ptr\intrusive_ptr.hpp
xdata$x	SEGMENT
__unwindtable$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T651711 = -28						; size = 4
__Vptr$651717 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Last$ = 8						; size = 4
__Dest$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >, COMDAT
; __First$ = ecx

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR __Dest$[ebp]
	mov	edi, ecx

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
$LL6@Uninit_cop@9:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@9

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$651717[ebp], esi
	mov	DWORD PTR $T651711[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@9
	push	esi
	mov	ecx, edi
	call	??0Rank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Rank::Rank
$LN18@Uninit_cop@9:
	add	esi, 200				; 000000c8H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 200				; 000000c8H
	jmp	SHORT $LL6@Uninit_cop@9
__catch$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@9
$LL3@Uninit_cop@9:

; 134  : 		_Al.destroy(_Next);

	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	esi, 200				; 000000c8H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@9
$LN1@Uninit_cop@9:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN36@Uninit_cop@9:
$LN4@Uninit_cop@9:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);

	mov	eax, esi

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@Uninit_cop@9:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$651717[ebp]
	push	eax
	mov	ecx, DWORD PTR $T651711[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
;	COMDAT xdata$x
; File c:\program files\boost\boost_1_40\boost\smart_ptr\intrusive_ptr.hpp
xdata$x	SEGMENT
__unwindtable$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T651781 = -28						; size = 4
__Vptr$651778 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Last$ = 8						; size = 4
__Dest$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<DRAMsimII::Rank const *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >, COMDAT
; __First$ = ecx

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, DWORD PTR __Dest$[ebp]
	mov	edi, ecx

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
$LL6@Uninit_cop@10:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@10

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$651778[ebp], esi
	mov	DWORD PTR $T651781[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@10
	push	esi
	mov	ecx, edi
	call	??0Rank@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Rank::Rank
$LN18@Uninit_cop@10:
	add	esi, 200				; 000000c8H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 200				; 000000c8H
	jmp	SHORT $LL6@Uninit_cop@10
__catch$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@10
$LL3@Uninit_cop@10:

; 134  : 		_Al.destroy(_Next);

	push	esi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	esi, 200				; 000000c8H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@10
$LN1@Uninit_cop@10:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN36@Uninit_cop@10:
$LN4@Uninit_cop@10:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);

	mov	eax, esi

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@Uninit_cop@10:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$651778[ebp]
	push	eax
	mov	ecx, DWORD PTR $T651781[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<DRAMsimII::Rank const *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@std@@@Z
_TEXT	SEGMENT
$T651821 = -4						; size = 1
__First$ = 8						; size = 4
__Cat$651825 = 12					; size = 1
__Last$ = 12						; size = 4
??$unchecked_uninitialized_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >, COMDAT
; __Dest$ = edx

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$651825[esp]
	mov	BYTE PTR $T651821[esp+4], 0
	mov	eax, DWORD PTR $T651821[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+8]
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >

; 823  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$unchecked_uninitialized_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@2@@stdext@@YAPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@4@@Z
_TEXT	SEGMENT
$T651850 = -4						; size = 1
__First$ = 8						; size = 8
__Cat$651854 = 16					; size = 1
__Last$ = 16						; size = 8
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@2@@stdext@@YAPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >, COMDAT
; __Dest$ = edx

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$651854[esp]
	mov	BYTE PTR $T651850[esp+4], 0
	mov	eax, DWORD PTR $T651850[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+12]
	push	edx
	push	eax
	call	??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Rank const *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >

; 823  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@PAVRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@2@@stdext@@YAPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAVRank@DRAMsimII@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV23@00@Z
_TEXT	SEGMENT
$T651922 = -4						; size = 1
__First$ = 8						; size = 4
__Cat$651925 = 12					; size = 1
__Last$ = 12						; size = 4
??$_Ucopy@PAVRank@DRAMsimII@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV23@00@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<DRAMsimII::Rank *>, COMDAT
; __Ptr$ = edx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	ecx, DWORD PTR __Cat$651925[esp]
	mov	BYTE PTR $T651922[esp+4], 0
	mov	eax, DWORD PTR $T651922[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+8]
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PAV12@00AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Rank *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >

; 1142 : 		}

	add	esp, 20					; 00000014H
	ret	8
??$_Ucopy@PAVRank@DRAMsimII@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV23@00@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<DRAMsimII::Rank *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@1@0PAV23@@Z
_TEXT	SEGMENT
$T651986 = -4						; size = 1
__First$ = 8						; size = 8
__Cat$651989 = 16					; size = 1
__Last$ = 16						; size = 8
??$_Ucopy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@1@0PAV23@@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >, COMDAT
; __Ptr$ = edx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	ecx, DWORD PTR __Cat$651989[esp]
	mov	BYTE PTR $T651986[esp+4], 0
	mov	eax, DWORD PTR $T651986[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+12]
	push	edx
	push	eax
	call	??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Rank const *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >

; 1142 : 		}

	add	esp, 20					; 00000014H
	ret	16					; 00000010H
??$_Ucopy@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@V?$_Vector_const_iterator@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@1@0PAV23@@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<std::_Vector_const_iterator<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T652054 = 8						; size = 1
__Cat$652058 = 8					; size = 1
$T652056 = 8						; size = 1
__Right$ = 8						; size = 4
??4?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator=, COMDAT
; _this$ = esi

; 563  : 		{	// assign _Right

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Right$[esp+8]
	push	edi

; 564  : 		if (this != &_Right)

	cmp	esi, ebp
	je	$LN67@operator@361

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	eax, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [ebp+16]
	sub	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	jne	SHORT $LN8@operator@361

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	eax, esi
	call	?clear@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::clear

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN8@operator@361:

; 573  : 			else if (_Right.size() <= size())

	mov	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+12]
	sub	edx, ecx
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 6
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	cmp	edi, ebx
	ja	SHORT $LN6@operator@361

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	BYTE PTR $T652054[esp+12], 0
	mov	eax, DWORD PTR $T652054[esp+12]
	mov	edx, DWORD PTR __Cat$652058[esp+12]
	push	eax
	mov	eax, DWORD PTR $T652056[esp+16]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ebp+16]
	push	eax
	mov	eax, ecx
	mov	ecx, DWORD PTR [ebp+12]
	call	??$_Copy_opt@PAVRank@DRAMsimII@@PAV12@@std@@YAPAVRank@DRAMsimII@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<DRAMsimII::Rank *,DRAMsimII::Rank *>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ebx, DWORD PTR [esi+16]
	add	esp, 16					; 00000010H
	mov	edi, eax
	cmp	eax, ebx
	je	SHORT $LN38@operator@361
$LL40@operator@361:
	push	edi
	call	??1Rank@DRAMsimII@@QAE@XZ
	add	edi, 200				; 000000c8H
	cmp	edi, ebx
	jne	SHORT $LL40@operator@361
$LN38@operator@361:

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR [ebp+16]
	sub	ecx, DWORD PTR [ebp+12]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	imul	ecx, 200				; 000000c8H
	add	ecx, DWORD PTR [esi+12]

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	mov	DWORD PTR [esi+16], ecx

; 599  : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN6@operator@361:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ecx, ecx
	jne	SHORT $LN56@operator@361
	xor	eax, eax
	jmp	SHORT $LN57@operator@361
$LN56@operator@361:
	mov	edx, DWORD PTR [esi+20]
	sub	edx, ecx
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$LN57@operator@361:
	cmp	edi, eax
	ja	SHORT $LN4@operator@361

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, DWORD PTR [ebp+12]
	imul	ebx, 200				; 000000c8H

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ecx
	add	ebx, eax
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVRank@DRAMsimII@@PAV12@@stdext@@YAPAVRank@DRAMsimII@@PAV12@00@Z ; stdext::unchecked_copy<DRAMsimII::Rank *,DRAMsimII::Rank *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR [ebp+16]
	add	esp, 12					; 0000000cH
	push	edx
	mov	edx, DWORD PTR [esi+16]
	push	ebx

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	call	??$_Ucopy@PAVRank@DRAMsimII@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV23@00@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<DRAMsimII::Rank *>
	mov	DWORD PTR [esi+16], eax

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi

; 599  : 		}

	pop	edi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN4@operator@361:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ecx, ecx
	je	SHORT $LN60@operator@361

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [esi+16]
	mov	eax, ecx
	call	?_Destroy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXPAVRank@DRAMsimII@@0@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN60@operator@361:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR [ebp+16]
	sub	ecx, DWORD PTR [ebp+12]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edi, esi
	call	?_Buy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAE_NI@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Buy
	test	al, al
	je	SHORT $LN67@operator@361

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [ebp+12]
	push	ecx
	push	edx
	mov	edx, DWORD PTR [esi+12]
	call	??$_Ucopy@PAVRank@DRAMsimII@@@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEPAVRank@DRAMsimII@@PAV23@00@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Ucopy<DRAMsimII::Rank *>
	mov	DWORD PTR [esi+16], eax
$LN67@operator@361:

; 599  : 		}

	pop	edi
	pop	ebp
	mov	eax, esi
	pop	ebx
	pop	ecx
	ret	4
??4?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator=
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$5
__ehfuncinfo$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T652381 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$652514 = 8					; size = 1
_this$ = 8						; size = 4
$T652511 = 12						; size = 1
__Right$ = 12						; size = 4
??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >, COMDAT

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, DWORD PTR __Right$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@vector@49
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN20@vector@49
$LN19@vector@49:
	xor	eax, eax
$LN20@vector@49:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR [ebx+16]
	sub	ecx, DWORD PTR [ebx+12]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	edi, edx
	mov	eax, 0
	shr	edi, 31					; 0000001fH
	add	edi, edx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	je	SHORT $LN8@vector@49
	cmp	edi, 21474836				; 0147ae14H
	jbe	SHORT $LN46@vector@49
	call	?_Xlen@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@KAXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Xlen
$LN107@vector@49:
$LN46@vector@49:
	mov	ecx, edi
	call	?allocate@?$allocator@VRank@DRAMsimII@@@std@@QAEPAVRank@DRAMsimII@@I@Z ; std::allocator<DRAMsimII::Rank>::allocate
	imul	edi, 200				; 000000c8H
	add	edi, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], edi

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR $T652381[ebp], eax
	cmp	DWORD PTR [ebx+12], eax
	jbe	SHORT $LN60@vector@49
	call	__invalid_parameter_noinfo
$LN60@vector@49:
	mov	edi, DWORD PTR [ebx+12]
	cmp	edi, DWORD PTR [ebx+16]
	jbe	SHORT $LN74@vector@49
	call	__invalid_parameter_noinfo
$LN74@vector@49:
	mov	edx, DWORD PTR __Cat$652514[ebp]
	mov	eax, DWORD PTR [esi+12]
	mov	BYTE PTR $T652511[ebp], 0
	mov	ecx, DWORD PTR $T652511[ebp]
	push	ecx
	push	edx
	push	eax
	mov	eax, DWORD PTR $T652381[ebp]
	push	eax
	mov	ecx, edi
	call	??$_Uninit_copy@PBVRank@DRAMsimII@@PAV12@V?$allocator@VRank@DRAMsimII@@@std@@@std@@YAPAVRank@DRAMsimII@@PBV12@0PAV12@AAV?$allocator@VRank@DRAMsimII@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<DRAMsimII::Rank const *,DRAMsimII::Rank *,std::allocator<DRAMsimII::Rank> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+16], eax
$LN8@vector@49:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Tidy@?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@IAEXXZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN108@vector@49:
$LN106@vector@49:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	eax, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
PUBLIC	??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z		; DRAMsimII::Channel::operator=
__unwindtable$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z$0
__ehfuncinfo$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
$T652551 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z PROC		; DRAMsimII::Channel::operator=
; _this$ = edi
; _rhs$ = ecx

; 3028 : {

	push	-1
	push	__ehhandler$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 3029 : 	time = rhs.time;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], eax
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], ecx

; 3030 : 	lastCommandIssueTime = rhs.lastCommandIssueTime;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], edx
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], eax

; 3031 : 	lastCommand = rhs.lastCommand ? new Command(*(rhs.lastCommand)) : NULL;

	cmp	DWORD PTR [esi+24], 0
	je	SHORT $LN5@operator@362
	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T652551[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	eax, eax
	je	SHORT $LN3@operator@362
	mov	ecx, DWORD PTR [esi+24]
	push	ecx
	push	eax
	call	??0Command@DRAMsimII@@QAE@ABV01@@Z	; DRAMsimII::Command::Command
	mov	DWORD PTR __$EHRec$[esp+32], -1
	jmp	SHORT $LN6@operator@362
$LN3@operator@362:
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+32], -1
	jmp	SHORT $LN6@operator@362
$LN5@operator@362:
	xor	eax, eax
$LN6@operator@362:

; 3032 : 	transactionQueue = rhs.transactionQueue;

	lea	edx, DWORD PTR [esi+112]
	mov	DWORD PTR [edi+24], eax
	push	edx
	lea	eax, DWORD PTR [edi+112]
	push	eax
	call	??4?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAEAAV01@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::operator=

; 3033 : 	refreshCounter = rhs.refreshCounter;

	lea	ecx, DWORD PTR [esi+152]
	push	ecx
	lea	eax, DWORD PTR [edi+152]
	call	??4?$vector@_JV?$allocator@_J@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<__int64,std::allocator<__int64> >::operator=

; 3034 : 	channelID = rhs.channelID;

	mov	edx, DWORD PTR [esi+360]

; 3035 : 	rank = rhs.rank;

	add	esi, 368				; 00000170H
	push	esi
	lea	esi, DWORD PTR [edi+368]
	mov	DWORD PTR [edi+360], edx
	call	??4?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator=

; 3036 : 
; 3037 : 	return *this;

	mov	eax, edi

; 3038 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
__unwindfunclet$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z$0:
	mov	esi, DWORD PTR $T652551[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__ehhandler$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z
	jmp	___CxxFrameHandler3
??4Channel@DRAMsimII@@QAEAAV01@ABV01@@Z ENDP		; DRAMsimII::Channel::operator=
PUBLIC	__$ArrayPad$
__unwindtable$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$10
	DD	07H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$8
	DD	09H
	DD	FLAT:__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$9
__ehfuncinfo$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T652566 = -285						; size = 1
_ACTArray$ = -284					; size = 24
$T652849 = -260						; size = 4
_ACTSTBYArray$ = -256					; size = 24
_response$ = -232					; size = 12
_service$ = -220					; size = 12
_channelArray$ = -208					; size = 24
_submit$ = -184						; size = 136
_session$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_PsysRD$ = 8						; size = 8
_PsysWR$ = 16						; size = 8
_rankArray$ = 24					; size = 24
_PsysACTSTBYArray$ = 48					; size = 24
_PsysACTArray$ = 72					; size = 24
_currentTime$ = 96					; size = 8
?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z PROC ; DRAMsimII::Channel::sendPower
; _this$ = ecx

; 684  : {

	push	-1
	push	__ehhandler$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 280				; 00000118H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+292], eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+308]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+316], ebx

; 685  : 	DRAMsimWSSoapHttp service;

	lea	edi, DWORD PTR _service$[esp+308]
	call	??0DRAMsimWSSoapHttp@@QAE@XZ		; DRAMsimWSSoapHttp::DRAMsimWSSoapHttp

; 686  : 	_ns2__submitEpochResultElement submit;

	lea	ecx, DWORD PTR _submit$[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 3
	call	??0_ns2__submitEpochResultElement@@QAE@XZ ; _ns2__submitEpochResultElement::_ns2__submitEpochResultElement
	mov	BYTE PTR __$EHRec$[esp+316], 4

; 687  : 
; 688  : 	string session(systemConfig.getSessionID());

	mov	eax, DWORD PTR [esi+176]
	push	-1
	add	eax, 400				; 00000190H
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _session$[esp+320]
	mov	DWORD PTR _session$[esp+344], 15	; 0000000fH
	mov	DWORD PTR _session$[esp+340], ebx
	mov	BYTE PTR _session$[esp+324], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 689  : 	submit.sessionID = &session;
; 690  : 
; 691  : 	submit.epoch = currentTime;

	mov	ecx, DWORD PTR _currentTime$[esp+304]
	mov	edx, DWORD PTR _currentTime$[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 5
	mov	DWORD PTR _submit$[esp+324], ecx

; 692  : 
; 693  : 	vector<int> channelArray(rank.size(),channelID);	

	mov	ecx, DWORD PTR [esi+384]
	sub	ecx, DWORD PTR [esi+380]
	lea	eax, DWORD PTR _session$[esp+308]
	mov	DWORD PTR _submit$[esp+316], eax
	mov	DWORD PTR _submit$[esp+328], edx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	mov	eax, DWORD PTR [esi+360]
	sar	edx, 6
	mov	edi, edx
	push	eax
	lea	ecx, DWORD PTR _channelArray$[esp+312]
	shr	edi, 31					; 0000001fH
	add	edi, edx
	push	ecx
	call	??$?0I@?$vector@HV?$allocator@H@std@@@std@@QAE@II@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> ><unsigned int>

; 694  : 	submit.channel = channelArray;

	lea	edx, DWORD PTR _channelArray$[esp+308]
	push	edx
	lea	eax, DWORD PTR _submit$[esp+336]
	mov	BYTE PTR __$EHRec$[esp+320], 6
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=

; 695  : 
; 696  : 	submit.rank = rankArray;

	lea	eax, DWORD PTR _rankArray$[esp+304]
	push	eax
	lea	eax, DWORD PTR _submit$[esp+360]
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=

; 697  : 
; 698  : 	vector<float> ACTSTBYArray(PsysACTSTBYArray.size());

	mov	edi, DWORD PTR _PsysACTSTBYArray$[esp+320]
	sub	edi, DWORD PTR _PsysACTSTBYArray$[esp+316]
	lea	ecx, DWORD PTR _ACTSTBYArray$[esp+308]
	sar	edi, 3
	push	ecx
	call	??0?$vector@MV?$allocator@M@std@@@std@@QAE@I@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	mov	BYTE PTR __$EHRec$[esp+316], 7

; 699  : 	for (vector<float>::size_type i = 0; i < PsysACTSTBYArray.size(); ++i)

	mov	eax, DWORD PTR _PsysACTSTBYArray$[esp+320]
	sub	eax, DWORD PTR _PsysACTSTBYArray$[esp+316]
	xor	esi, esi
	sar	eax, 3
	cmp	eax, ebx
	jbe	SHORT $LN4@sendPower

; 700  : 		ACTSTBYArray[i] = PsysACTSTBYArray[i];

	cmp	esi, eax
	jb	SHORT $LN53@sendPower
	call	__invalid_parameter_noinfo
$LN53@sendPower:
	mov	eax, DWORD PTR _ACTSTBYArray$[esp+324]
	sub	eax, DWORD PTR _ACTSTBYArray$[esp+320]
	mov	edx, DWORD PTR _PsysACTSTBYArray$[esp+316]
	sar	eax, 2
	lea	edi, DWORD PTR [edx+esi*8]
	cmp	esi, eax
	jb	SHORT $LN58@sendPower
	call	__invalid_parameter_noinfo
$LN58@sendPower:
	movsd	xmm0, QWORD PTR [edi]
	mov	ecx, DWORD PTR _ACTSTBYArray$[esp+320]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [ecx+esi*4], xmm0
	mov	eax, DWORD PTR _PsysACTSTBYArray$[esp+320]
	sub	eax, DWORD PTR _PsysACTSTBYArray$[esp+316]
	inc	esi
	sar	eax, 3
	cmp	esi, eax
	jb	SHORT $LN53@sendPower
$LN4@sendPower:

; 701  : 	vector<float> ACTArray(PsysACTArray.size());

	mov	edi, DWORD PTR _PsysACTArray$[esp+320]
	sub	edi, DWORD PTR _PsysACTArray$[esp+316]
	push	4
	sar	edi, 3
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN77@sendPower
	lea	edx, DWORD PTR _ACTArray$[esp+308]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN78@sendPower
$LN77@sendPower:
	xor	eax, eax
$LN78@sendPower:
	mov	DWORD PTR _ACTArray$[esp+308], eax
	mov	BYTE PTR __$EHRec$[esp+316], 8
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR $T652849[esp+308]
	push	eax
	lea	esi, DWORD PTR _ACTArray$[esp+312]
	movss	DWORD PTR $T652849[esp+312], xmm0
	call	?_Construct_n@?$vector@MV?$allocator@M@std@@@std@@QAEXIABM@Z ; std::vector<float,std::allocator<float> >::_Construct_n
	mov	BYTE PTR __$EHRec$[esp+316], 9

; 702  : 	for (vector<float>::size_type i = 0; i < PsysACTArray.size() ; ++i)

	mov	eax, DWORD PTR _PsysACTArray$[esp+320]
	sub	eax, DWORD PTR _PsysACTArray$[esp+316]
	xor	esi, esi
	sar	eax, 3
	cmp	eax, ebx
	jbe	SHORT $LN1@sendPower

; 703  : 		ACTArray[i] = PsysACTArray[i];

	cmp	esi, eax
	jb	SHORT $LN104@sendPower
	call	__invalid_parameter_noinfo
$LN104@sendPower:
	mov	edx, DWORD PTR _ACTArray$[esp+324]
	sub	edx, DWORD PTR _ACTArray$[esp+320]
	mov	ecx, DWORD PTR _PsysACTArray$[esp+316]
	sar	edx, 2
	lea	edi, DWORD PTR [ecx+esi*8]
	cmp	esi, edx
	jb	SHORT $LN109@sendPower
	call	__invalid_parameter_noinfo
$LN109@sendPower:
	movsd	xmm0, QWORD PTR [edi]
	mov	eax, DWORD PTR _ACTArray$[esp+320]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [eax+esi*4], xmm0
	mov	eax, DWORD PTR _PsysACTArray$[esp+320]
	sub	eax, DWORD PTR _PsysACTArray$[esp+316]
	inc	esi
	sar	eax, 3
	cmp	esi, eax
	jb	SHORT $LN104@sendPower
$LN1@sendPower:

; 704  : 	submit.PsysACTSTBY = ACTSTBYArray;

	lea	ecx, DWORD PTR _ACTSTBYArray$[esp+308]
	push	ecx
	lea	eax, DWORD PTR _submit$[esp+384]
	call	??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<float,std::allocator<float> >::operator=

; 705  : 	submit.PsysACT = ACTArray;

	lea	edx, DWORD PTR _ACTArray$[esp+308]
	push	edx
	lea	eax, DWORD PTR _submit$[esp+408]
	call	??4?$vector@MV?$allocator@M@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<float,std::allocator<float> >::operator=

; 706  : 	submit.PsysRD = (float)PsysRD;

	movsd	xmm0, QWORD PTR _PsysRD$[esp+304]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR _submit$[esp+428], xmm0

; 707  : 	submit.PsysWR = (float)PsysWR;

	movsd	xmm0, QWORD PTR _PsysWR$[esp+304]

; 708  : 	_ns2__submitEpochResultResponseElement response;

	mov	esi, OFFSET ??_7_ns2__submitEpochResultResponseElement@@6B@
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR _submit$[esp+432], xmm0
	mov	DWORD PTR _response$[esp+308], esi
	mov	BYTE PTR _response$[esp+312], bl
	mov	DWORD PTR _response$[esp+316], ebx
	mov	BYTE PTR __$EHRec$[esp+316], 10		; 0000000aH

; 709  : 	int retVal = service.__ns1__submitEpochResult(&submit,&response);

	mov	ecx, DWORD PTR _service$[esp+312]
	cmp	ecx, ebx
	je	SHORT $LN118@sendPower
	mov	edx, DWORD PTR _service$[esp+316]
	lea	eax, DWORD PTR _response$[esp+308]
	push	eax
	push	edx
	lea	eax, DWORD PTR _submit$[esp+316]
	call	?soap_call___ns1__submitEpochResult@@YAHPAUsoap@@PBD1PAV_ns2__submitEpochResultElement@@PAV_ns2__submitEpochResultResponseElement@@@Z ; soap_call___ns1__submitEpochResult
	add	esp, 8
	jmp	SHORT $LN119@sendPower
$LN118@sendPower:
	mov	eax, 20					; 00000014H
$LN119@sendPower:

; 710  : 	return (retVal == 0);

	cmp	eax, ebx
	mov	eax, DWORD PTR _ACTArray$[esp+320]
	sete	BYTE PTR $T652566[esp+308]
	mov	DWORD PTR _response$[esp+308], esi
	cmp	eax, ebx
	je	SHORT $LN127@sendPower
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN127@sendPower:
	mov	eax, DWORD PTR _ACTArray$[esp+308]
	push	eax
	mov	DWORD PTR _ACTArray$[esp+324], ebx
	mov	DWORD PTR _ACTArray$[esp+328], ebx
	mov	DWORD PTR _ACTArray$[esp+332], ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _ACTSTBYArray$[esp+324]
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN142@sendPower
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN142@sendPower:
	mov	ecx, DWORD PTR _ACTSTBYArray$[esp+308]
	push	ecx
	mov	DWORD PTR _ACTSTBYArray$[esp+324], ebx
	mov	DWORD PTR _ACTSTBYArray$[esp+328], ebx
	mov	DWORD PTR _ACTSTBYArray$[esp+332], ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _channelArray$[esp+324]
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN157@sendPower
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN157@sendPower:
	mov	edx, DWORD PTR _channelArray$[esp+308]
	push	edx
	mov	DWORD PTR _channelArray$[esp+324], ebx
	mov	DWORD PTR _channelArray$[esp+328], ebx
	mov	DWORD PTR _channelArray$[esp+332], ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	DWORD PTR _session$[esp+332], 16	; 00000010H
	jb	SHORT $LN183@sendPower
	mov	eax, DWORD PTR _session$[esp+312]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN183@sendPower:
	lea	ecx, DWORD PTR _submit$[esp+308]
	mov	DWORD PTR _session$[esp+332], 15	; 0000000fH
	mov	DWORD PTR _session$[esp+328], ebx
	mov	BYTE PTR _session$[esp+312], bl
	call	??1_ns2__submitEpochResultElement@@UAE@XZ ; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement
	lea	ecx, DWORD PTR _service$[esp+308]
	call	??1DRAMsimWSSoapHttp@@UAE@XZ		; DRAMsimWSSoapHttp::~DRAMsimWSSoapHttp
	mov	eax, DWORD PTR _rankArray$[esp+316]
	cmp	eax, ebx
	je	SHORT $LN198@sendPower
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN198@sendPower:
	mov	ecx, DWORD PTR _rankArray$[esp+304]
	push	ecx
	mov	DWORD PTR _rankArray$[esp+320], ebx
	mov	DWORD PTR _rankArray$[esp+324], ebx
	mov	DWORD PTR _rankArray$[esp+328], ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _PsysACTSTBYArray$[esp+320]
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN213@sendPower
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN213@sendPower:
	mov	edx, DWORD PTR _PsysACTSTBYArray$[esp+304]
	push	edx
	mov	DWORD PTR _PsysACTSTBYArray$[esp+320], ebx
	mov	DWORD PTR _PsysACTSTBYArray$[esp+324], ebx
	mov	DWORD PTR _PsysACTSTBYArray$[esp+328], ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _PsysACTArray$[esp+320]
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN228@sendPower
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN228@sendPower:
	mov	eax, DWORD PTR _PsysACTArray$[esp+304]
	push	eax
	mov	DWORD PTR _PsysACTArray$[esp+320], ebx
	mov	DWORD PTR _PsysACTArray$[esp+324], ebx
	mov	DWORD PTR _PsysACTArray$[esp+328], ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	al, BYTE PTR $T652566[esp+312]
	add	esp, 4

; 711  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+308]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+292]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 292				; 00000124H
	ret	96					; 00000060H
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$0:
	lea	esi, DWORD PTR _PsysACTArray$[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$1:
	lea	esi, DWORD PTR _PsysACTSTBYArray$[ebp-4]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$2:
	lea	ecx, DWORD PTR _rankArray$[ebp-4]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$3:
	lea	ecx, DWORD PTR _service$[ebp]
	jmp	??1DRAMsimWSSoapHttp@@UAE@XZ		; DRAMsimWSSoapHttp::~DRAMsimWSSoapHttp
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$4:
	lea	ecx, DWORD PTR _submit$[ebp]
	jmp	??1_ns2__submitEpochResultElement@@UAE@XZ ; _ns2__submitEpochResultElement::~_ns2__submitEpochResultElement
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$5:
	lea	ecx, DWORD PTR _session$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$6:
	lea	ecx, DWORD PTR _channelArray$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$7:
	lea	ecx, DWORD PTR _ACTSTBYArray$[ebp]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$10:
	lea	eax, DWORD PTR _ACTArray$[ebp]
	jmp	??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$8:
	lea	ecx, DWORD PTR _ACTArray$[ebp]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
__unwindfunclet$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z$9:
	lea	ecx, DWORD PTR _response$[ebp]
	jmp	??1_ns2__submitEpochResultResponseElement@@UAE@XZ ; _ns2__submitEpochResultResponseElement::~_ns2__submitEpochResultResponseElement
__ehhandler$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-292]
	mov	ecx, DWORD PTR [edx-296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z
	jmp	___CxxFrameHandler3
?sendPower@Channel@DRAMsimII@@ABE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@1_J@Z ENDP ; DRAMsimII::Channel::sendPower
PUBLIC	__real@3fa9999a00000000
PUBLIC	__real@3fefae147b000000
;	COMDAT __real@3fa9999a00000000
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
__real@3fa9999a00000000 DQ 03fa9999a00000000r	; 0.05
CONST	ENDS
;	COMDAT __real@3fefae147b000000
CONST	SEGMENT
__real@3fefae147b000000 DQ 03fefae147b000000r	; 0.99
__unwindtable$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z$4
__ehfuncinfo$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\crius\documents\visual studio 2008\projects\dramsimiihg\src\channel.cpp
_TEXT	SEGMENT
$T653364 = -292						; size = 4
_k$217473 = -292					; size = 8
$T653363 = -284						; size = 4
_perRankRASCount$217480 = -284				; size = 4
_tRRDsch$ = -284					; size = 4
tv3377 = -280						; size = 4
tv3365 = -280						; size = 4
tv3348 = -280						; size = 4
tv3345 = -280						; size = 4
tv3332 = -280						; size = 4
tv3329 = -280						; size = 4
tv3317 = -280						; size = 4
tv3314 = -280						; size = 4
tv2612 = -280						; size = 8
$T654258 = -280						; size = 4
$T653547 = -280						; size = 4
$T653362 = -280						; size = 4
$T653361 = -280						; size = 4
$T653342 = -280						; size = 4
_PsysACT_STBY$ = -272					; size = 8
_PsysACT$ = -264					; size = 8
$T655197 = -252						; size = 8
$T653360 = -252						; size = 12
$T653357 = -252						; size = 8
$T653354 = -252						; size = 8
$T653351 = -252						; size = 8
$T653348 = -252						; size = 8
$T653345 = -252						; size = 8
_PsysWR$ = -240						; size = 8
_PsysRD$ = -232						; size = 8
_rankArray$ = -224					; size = 24
_PsysACTSTBYArray$ = -200				; size = 24
_PsysACTArray$ = -176					; size = 24
_PsysPRE_STBY$ = -152					; size = 8
tv3353 = -144						; size = 8
tv3308 = -136						; size = 8
tv3384 = -128						; size = 8
tv3323 = -120						; size = 8
tv3392 = -112						; size = 8
tv2599 = -104						; size = 8
_percentActive$217541 = -96				; size = 8
tv2615 = -88						; size = 8
$T654830 = -80						; size = 8
$T653905 = -72						; size = 8
__$EHRec$ = -12						; size = 12
_systemTime$ = 8					; size = 8
?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z PROC	; DRAMsimII::Channel::doPowerCalculation
; _this$ = ecx

; 518  : {	

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	push	-1
	push	__ehhandler$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 296				; 00000128H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+324]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 519  : 	// the counts for the total number of operations
; 520  : 	//unsigned entireRAS = 1;
; 521  : 	//unsigned entireCAS = 1;
; 522  : 	//unsigned entireCASW = 1;
; 523  : 
; 524  : 	// the counts for the operations this epoch
; 525  : 	unsigned totalRAS = 1;
; 526  : 
; 527  : 	double PsysACTTotal = 0.0F;
; 528  : 	double PsysRD = 0.0F;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _PsysRD$[esp+324], xmm0

; 529  : 	double PsysWR = 0.0F;

	movsd	QWORD PTR _PsysWR$[esp+324], xmm0

; 530  : 	double PsysACT_STBY = 0.0F;

	movsd	QWORD PTR _PsysACT_STBY$[esp+324], xmm0

; 531  : 	double PsysPRE_STBY = 0.0F;

	movsd	QWORD PTR _PsysPRE_STBY$[esp+324], xmm0

; 532  : 	double PsysPRE_PDN = 0.0F;
; 533  : 	double PsysACT_PDN = 0.0F;
; 534  : 	double PsysACT = 0.0F;

	movsd	QWORD PTR _PsysACT$[esp+324], xmm0

; 535  : 
; 536  : 	float tRRDsch = 0.0F;

	xorps	xmm0, xmm0

; 537  : 
; 538  : 	vector<int> rankArray;

	lea	ecx, DWORD PTR _rankArray$[esp+324]
	movss	DWORD PTR _tRRDsch$[esp+324], xmm0
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >

; 539  : 	vector<double> PsysACTSTBYArray, PsysACTArray;

	lea	eax, DWORD PTR _PsysACTSTBYArray$[esp+324]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+336], 0
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	lea	ecx, DWORD PTR _PsysACTArray$[esp+324]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+336], 1
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	mov	BYTE PTR __$EHRec$[esp+332], 2

; 540  : 
; 541  : 	for (vector<Rank>::iterator k = rank.begin(); k != rank.end(); k++)

	mov	esi, DWORD PTR [edi+380]
	cmp	esi, DWORD PTR [edi+384]
	jbe	SHORT $LN33@doPowerCal
	call	__invalid_parameter_noinfo
$LN33@doPowerCal:
	mov	ebx, DWORD PTR [edi+368]
	mov	DWORD PTR _k$217473[esp+324], ebx
	mov	DWORD PTR _k$217473[esp+328], esi
	npad	3
$LL50@doPowerCal:
	mov	eax, DWORD PTR [edi+384]
	mov	DWORD PTR $T653547[esp+324], eax
	cmp	DWORD PTR [edi+380], eax
	jbe	SHORT $LN65@doPowerCal
	call	__invalid_parameter_noinfo
$LN65@doPowerCal:
	mov	eax, DWORD PTR [edi+368]
	test	ebx, ebx
	je	SHORT $LN78@doPowerCal
	cmp	ebx, eax
	je	SHORT $LN79@doPowerCal
$LN78@doPowerCal:
	call	__invalid_parameter_noinfo
$LN79@doPowerCal:
	cmp	esi, DWORD PTR $T653547[esp+324]
	je	$LN5@doPowerCal

; 542  : 	{
; 543  : 		unsigned perRankRASCount = 1;

	mov	DWORD PTR _perRankRASCount$217480[esp+324], 1

; 544  : 		//unsigned totalCAS = 1;
; 545  : 		//unsigned totalCASW = 1; // ensure no div/0
; 546  : 
; 547  : 		rankArray.push_back(k->getRankID());

	test	ebx, ebx
	jne	SHORT $LN760@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN99@doPowerCal:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN90@doPowerCal
	call	__invalid_parameter_noinfo
$LN90@doPowerCal:
	mov	edx, DWORD PTR _rankArray$[esp+336]
	mov	esi, DWORD PTR [esi+136]
	mov	DWORD PTR $T653342[esp+324], esi
	test	edx, edx
	jne	SHORT $LN112@doPowerCal
	xor	ecx, ecx
	jmp	SHORT $LN113@doPowerCal
$LN760@doPowerCal:
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN99@doPowerCal
$LN112@doPowerCal:
	mov	ecx, DWORD PTR _rankArray$[esp+344]
	sub	ecx, edx
	sar	ecx, 2
$LN113@doPowerCal:
	mov	eax, DWORD PTR _rankArray$[esp+340]
	mov	ebx, eax
	sub	ebx, edx
	sar	ebx, 2
	cmp	ebx, ecx
	jae	SHORT $LN105@doPowerCal
	mov	DWORD PTR [eax], esi
	add	eax, 4
	mov	DWORD PTR _rankArray$[esp+340], eax
	jmp	SHORT $LN104@doPowerCal
$LN105@doPowerCal:
	mov	esi, eax
	cmp	edx, eax
	jbe	SHORT $LN142@doPowerCal
	call	__invalid_parameter_noinfo
$LN142@doPowerCal:
	mov	eax, DWORD PTR _rankArray$[esp+324]
	push	esi
	push	eax
	lea	edx, DWORD PTR $T653342[esp+332]
	push	edx
	lea	eax, DWORD PTR $T653905[esp+336]
	push	eax
	lea	eax, DWORD PTR _rankArray$[esp+340]
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
$LN104@doPowerCal:

; 548  : 
; 549  : 		for (vector<Bank>::iterator l = k->bank.begin(); l != k->bank.end(); l++)

	mov	eax, DWORD PTR _k$217473[esp+324]
	test	eax, eax
	jne	$LN759@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN166@doPowerCal:
	mov	ebx, DWORD PTR _k$217473[esp+328]
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN157@doPowerCal
	call	__invalid_parameter_noinfo
$LN157@doPowerCal:
	mov	esi, DWORD PTR [ebx+184]
	cmp	esi, DWORD PTR [ebx+188]
	jbe	SHORT $LN174@doPowerCal
	call	__invalid_parameter_noinfo
$LN174@doPowerCal:
	mov	ecx, DWORD PTR _k$217473[esp+328]
	mov	ebx, DWORD PTR [ecx+172]
	add	esi, 140				; 0000008cH
	npad	7
$LL191@doPowerCal:
	mov	eax, DWORD PTR _k$217473[esp+324]
	test	eax, eax
	jne	$LN758@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN214@doPowerCal:
	mov	edx, DWORD PTR _k$217473[esp+328]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN205@doPowerCal
	call	__invalid_parameter_noinfo
$LN205@doPowerCal:
	mov	eax, DWORD PTR _k$217473[esp+328]
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR $T654258[esp+324], ecx
	cmp	DWORD PTR [eax+184], ecx
	jbe	SHORT $LN222@doPowerCal
	call	__invalid_parameter_noinfo
$LN222@doPowerCal:
	mov	eax, DWORD PTR _k$217473[esp+328]
	mov	eax, DWORD PTR [eax+172]
	test	ebx, ebx
	je	SHORT $LN235@doPowerCal
	cmp	ebx, eax
	je	SHORT $LN236@doPowerCal
$LN235@doPowerCal:
	call	__invalid_parameter_noinfo
$LN236@doPowerCal:
	lea	eax, DWORD PTR [esi-140]
	cmp	eax, DWORD PTR $T654258[esp+324]
	je	$LN2@doPowerCal

; 550  : 		{
; 551  : 			totalRAS += l->getRASCount();			

	test	ebx, ebx
	jne	$LN757@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN256@doPowerCal:
	lea	ecx, DWORD PTR [esi-140]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN247@doPowerCal
	call	__invalid_parameter_noinfo
$LN247@doPowerCal:

; 552  : 			perRankRASCount += l->getRASCount();

	test	ebx, ebx
	jne	$LN756@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN274@doPowerCal:
	lea	ecx, DWORD PTR [esi-140]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN265@doPowerCal
	call	__invalid_parameter_noinfo
$LN265@doPowerCal:
	mov	ecx, DWORD PTR [esi-12]
	add	DWORD PTR _perRankRASCount$217480[esp+324], ecx

; 553  : 			//totalCAS += l->getCASCount();
; 554  : 			//totalCASW += l->getCASWCount();
; 555  : 			l->accumulateAndResetCounts();

	test	ebx, ebx
	jne	SHORT $LN755@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN292@doPowerCal:
	lea	ecx, DWORD PTR [esi-140]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN283@doPowerCal
	call	__invalid_parameter_noinfo
$LN283@doPowerCal:
	mov	eax, DWORD PTR [esi-4]
	mov	edx, DWORD PTR [esi-12]
	add	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [esi+4]
	add	DWORD PTR [esi-8], edx
	add	DWORD PTR [esi+8], ecx
	xor	eax, eax
	mov	DWORD PTR [esi-4], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi-12], eax
	cmp	ebx, eax
	jne	SHORT $LN754@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN198@doPowerCal:
	lea	ecx, DWORD PTR [esi-140]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN189@doPowerCal

; 548  : 
; 549  : 		for (vector<Bank>::iterator l = k->bank.begin(); l != k->bank.end(); l++)

	call	__invalid_parameter_noinfo
$LN189@doPowerCal:
	add	esi, 152				; 00000098H
	jmp	$LL191@doPowerCal
$LN759@doPowerCal:
	mov	eax, DWORD PTR [eax]
	jmp	$LN166@doPowerCal
$LN758@doPowerCal:
	mov	eax, DWORD PTR [eax]
	jmp	$LN214@doPowerCal
$LN757@doPowerCal:

; 550  : 		{
; 551  : 			totalRAS += l->getRASCount();			

	mov	eax, DWORD PTR [ebx]
	jmp	$LN256@doPowerCal
$LN756@doPowerCal:

; 552  : 			perRankRASCount += l->getRASCount();

	mov	eax, DWORD PTR [ebx]
	jmp	$LN274@doPowerCal
$LN755@doPowerCal:

; 553  : 			//totalCAS += l->getCASCount();
; 554  : 			//totalCASW += l->getCASWCount();
; 555  : 			l->accumulateAndResetCounts();

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN292@doPowerCal
$LN754@doPowerCal:

; 548  : 
; 549  : 		for (vector<Bank>::iterator l = k->bank.begin(); l != k->bank.end(); l++)

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN198@doPowerCal
$LN2@doPowerCal:

; 556  : 		}
; 557  : 
; 558  : 		// FIXME: assumes CKE is always high, so (1 - CKE_LOW_PRE%) = 1
; 559  : 		double percentActive = 1.0F - (k->getPrechargeTime(time) / (double)(time - powerModel.getLastCalculation()));

	mov	eax, DWORD PTR _k$217473[esp+324]
	test	eax, eax
	jne	$LN753@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN310@doPowerCal:
	mov	edx, DWORD PTR _k$217473[esp+328]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN301@doPowerCal
	call	__invalid_parameter_noinfo
$LN301@doPowerCal:
	mov	eax, DWORD PTR [edi+12]
	mov	ebx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR _k$217473[esp+328]
	push	eax
	push	ebx
	mov	DWORD PTR tv2599[esp+336], eax
	call	?getPrechargeTime@Rank@DRAMsimII@@QBE_J_J@Z ; DRAMsimII::Rank::getPrechargeTime
	sub	ebx, DWORD PTR [edi+352]
	mov	DWORD PTR tv3392[esp+324], eax
	mov	eax, DWORD PTR tv2599[esp+328]
	sbb	eax, DWORD PTR [edi+356]
	mov	DWORD PTR tv3392[esp+328], edx
	fild	QWORD PTR tv3392[esp+324]
	mov	DWORD PTR tv3384[esp+328], eax
	mov	DWORD PTR tv3384[esp+324], ebx
	fild	QWORD PTR tv3384[esp+324]

; 560  : 		assert(percentActive >= 0.0F && percentActive <= 1.0F);
; 561  : 		assert(k->getPrechargeTime(time) <= time - powerModel.getLastCalculation());
; 562  : 
; 563  : 		/// @todo actually simulate CKE, per rank
; 564  : 		double CKE_LO_PRE = 0.95F;
; 565  : 		double CKE_LO_ACT = 0.01F;
; 566  : 
; 567  : 		// calculate PsysACT-STBY
; 568  : 		PsysACT_STBY += powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() *
; 569  : 			powerModel.getIDD3N() * powerModel.getVDDmax() * percentActive * (1.0F - CKE_LO_ACT);

	mov	eax, DWORD PTR [edi+324]
	fdivp	ST(1), ST(0)
	fld1
	fsubrp	ST(1), ST(0)
	fst	QWORD PTR _percentActive$217541[esp+324]
	fild	DWORD PTR [edi+324]
	test	eax, eax
	jge	SHORT $LN768@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN768@doPowerCal:
	fmul	QWORD PTR [edi+256]

; 570  : 
; 571  : 		PsysACTSTBYArray.push_back(PsysACT_STBY);

	mov	eax, DWORD PTR _PsysACTSTBYArray$[esp+336]
	fmul	QWORD PTR [edi+264]
	fimul	DWORD PTR [edi+208]
	fmul	DWORD PTR [edi+188]
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fefae147b000000
	fadd	QWORD PTR _PsysACT_STBY$[esp+324]
	fstp	QWORD PTR _PsysACT_STBY$[esp+324]
	test	eax, eax
	jne	SHORT $LN333@doPowerCal
	xor	edx, edx
	jmp	SHORT $LN334@doPowerCal
$LN753@doPowerCal:

; 556  : 		}
; 557  : 
; 558  : 		// FIXME: assumes CKE is always high, so (1 - CKE_LOW_PRE%) = 1
; 559  : 		double percentActive = 1.0F - (k->getPrechargeTime(time) / (double)(time - powerModel.getLastCalculation()));

	mov	eax, DWORD PTR [eax]
	jmp	$LN310@doPowerCal

; 570  : 
; 571  : 		PsysACTSTBYArray.push_back(PsysACT_STBY);

$LN333@doPowerCal:
	mov	edx, DWORD PTR _PsysACTSTBYArray$[esp+344]
	sub	edx, eax
	sar	edx, 3
$LN334@doPowerCal:
	mov	ecx, DWORD PTR _PsysACTSTBYArray$[esp+340]
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 3
	cmp	esi, edx
	jae	SHORT $LN326@doPowerCal
	movsd	xmm0, QWORD PTR _PsysACT_STBY$[esp+324]
	movsd	QWORD PTR [ecx], xmm0
	add	ecx, 8
	mov	DWORD PTR _PsysACTSTBYArray$[esp+340], ecx
	jmp	SHORT $LN325@doPowerCal
$LN326@doPowerCal:
	mov	esi, ecx
	cmp	eax, ecx
	jbe	SHORT $LN363@doPowerCal
	call	__invalid_parameter_noinfo
$LN363@doPowerCal:
	mov	eax, DWORD PTR _PsysACTSTBYArray$[esp+324]
	push	esi
	push	eax
	lea	ecx, DWORD PTR _PsysACT_STBY$[esp+332]
	push	ecx
	lea	edx, DWORD PTR $T654830[esp+336]
	push	edx
	lea	eax, DWORD PTR _PsysACTSTBYArray$[esp+340]
	call	?insert@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@ABN@Z ; std::vector<double,std::allocator<double> >::insert
$LN325@doPowerCal:
	mov	eax, DWORD PTR [edi+324]
	fild	DWORD PTR [edi+324]
	test	eax, eax
	jge	SHORT $LN769@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN769@doPowerCal:

; 572  : 
; 573  : 		// calculate PsysPRE-STBY
; 574  : 		PsysPRE_STBY += powerModel.getDevicesPerRank() * powerModel.getFrequencyScaleFactor() * powerModel.getVoltageScaleFactor() *
; 575  : 			powerModel.getIDD2N() * powerModel.getVDDmax() * (1 - percentActive) * (1 - CKE_LO_PRE);

	movsd	xmm0, QWORD PTR [edi+256]
	fst	QWORD PTR tv2612[esp+324]
	movsd	xmm1, QWORD PTR tv2612[esp+324]
	mulsd	xmm1, QWORD PTR [edi+264]

; 576  : 
; 577  : 		// calculate PsysPRE-PDN
; 578  : 		PsysPRE_PDN += powerModel.getVoltageScaleFactor() * powerModel.getIDD2P() * powerModel.getVDDmax() * (1 - percentActive) * CKE_LO_PRE;
; 579  : 
; 580  : 		// calculate PsysACT-PDN
; 581  : 		/// @todo: account for CKE
; 582  : 		PsysACT_PDN += powerModel.getVoltageScaleFactor() * powerModel.getIDD3P() * powerModel.getVDDmax() * percentActive * (1 - CKE_LO_ACT);
; 583  : 
; 584  : 		// calculate PsysACT
; 585  : 		tRRDsch = ((double)(time - powerModel.getLastCalculation())) / perRankRASCount;

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+352]
	mov	edx, DWORD PTR [edi+12]
	sbb	edx, DWORD PTR [edi+356]
	mov	eax, DWORD PTR _perRankRASCount$217480[esp+324]
	mulsd	xmm1, xmm0
	movsd	QWORD PTR tv2615[esp+324], xmm0
	cvtsi2sd xmm0, DWORD PTR [edi+200]
	mulsd	xmm1, xmm0
	movss	xmm0, DWORD PTR [edi+188]
	cvtps2pd xmm0, xmm0
	mulsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _percentActive$217541[esp+324]
	mulsd	xmm1, xmm0
	mulsd	xmm1, QWORD PTR __real@3fa9999a00000000
	addsd	xmm1, QWORD PTR _PsysPRE_STBY$[esp+324]
	mov	DWORD PTR tv3353[esp+324], ecx
	mov	DWORD PTR tv3353[esp+328], edx
	fild	QWORD PTR tv3353[esp+324]
	movsd	QWORD PTR _PsysPRE_STBY$[esp+324], xmm1
	fild	DWORD PTR _perRankRASCount$217480[esp+324]
	test	eax, eax
	jge	SHORT $LN770@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN770@doPowerCal:
	fdivp	ST(1), ST(0)

; 586  : 
; 587  : 		//if (tRRDsch > 200.0F)
; 588  : 		//	cerr << "t=" << time << ", last t=" << powerModel.getLastCalculation() << ", #RAS=" << perRankRASCount << endl;
; 589  : 
; 590  : 		PsysACT += powerModel.getDevicesPerRank() * ((double)powerModel.gettRC() / (double)tRRDsch) * powerModel.getVoltageScaleFactor() * powerModel.getPdsACT();

	mov	ecx, DWORD PTR [edi+340]
	fstp	DWORD PTR _tRRDsch$[esp+324]
	fild	DWORD PTR [edi+340]
	test	ecx, ecx
	jge	SHORT $LN771@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN771@doPowerCal:
	fdiv	DWORD PTR _tRRDsch$[esp+324]

; 591  : 
; 592  : 		PsysACTArray.push_back(PsysACT);

	mov	edx, DWORD PTR _PsysACTArray$[esp+336]
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR tv2615[esp+324]
	fmul	QWORD PTR [edi+224]
	fadd	QWORD PTR _PsysACT$[esp+324]
	fstp	QWORD PTR _PsysACT$[esp+324]
	test	edx, edx
	jne	SHORT $LN414@doPowerCal
	xor	ecx, ecx
	jmp	SHORT $LN415@doPowerCal
$LN414@doPowerCal:
	mov	ecx, DWORD PTR _PsysACTArray$[esp+344]
	sub	ecx, edx
	sar	ecx, 3
$LN415@doPowerCal:
	mov	eax, DWORD PTR _PsysACTArray$[esp+340]
	mov	esi, eax
	sub	esi, edx
	sar	esi, 3
	cmp	esi, ecx
	jae	SHORT $LN407@doPowerCal
	movsd	xmm0, QWORD PTR _PsysACT$[esp+324]
	movsd	QWORD PTR [eax], xmm0
	add	eax, 8
	mov	DWORD PTR _PsysACTArray$[esp+340], eax
	jmp	SHORT $LN406@doPowerCal
$LN407@doPowerCal:
	mov	esi, eax
	cmp	edx, eax
	jbe	SHORT $LN444@doPowerCal
	call	__invalid_parameter_noinfo
$LN444@doPowerCal:
	mov	eax, DWORD PTR _PsysACTArray$[esp+324]
	push	esi
	push	eax
	lea	edx, DWORD PTR _PsysACT$[esp+332]
	push	edx
	lea	eax, DWORD PTR $T655197[esp+336]
	push	eax
	lea	eax, DWORD PTR _PsysACTArray$[esp+340]
	call	?insert@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@ABN@Z ; std::vector<double,std::allocator<double> >::insert
$LN406@doPowerCal:

; 593  : 
; 594  : 		PsysACTTotal += ((double)powerModel.gettRC() / (double)tRRDsch) * powerModel.getVoltageScaleFactor() * powerModel.getPdsACT();
; 595  : 
; 596  : 		// calculate PdsRD
; 597  : 		double RDschPct = k->getReadCycles() / (double)(time - powerModel.getLastCalculation());

	mov	ebx, DWORD PTR _k$217473[esp+324]
	test	ebx, ebx
	jne	$LN752@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN474@doPowerCal:
	mov	esi, DWORD PTR _k$217473[esp+328]
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN465@doPowerCal
	call	__invalid_parameter_noinfo
$LN465@doPowerCal:

; 598  : 
; 599  : 		PsysRD += powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() * powerModel.getPdsRD() * RDschPct;

	mov	ecx, DWORD PTR [edi+324]
	fild	DWORD PTR [edi+324]
	test	ecx, ecx
	jge	SHORT $LN772@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN772@doPowerCal:
	fmul	QWORD PTR [edi+256]
	mov	edx, DWORD PTR [esi+128]
	fmul	QWORD PTR [edi+264]
	fmul	QWORD PTR [edi+240]
	fild	DWORD PTR [esi+128]
	test	edx, edx
	jge	SHORT $LN773@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN773@doPowerCal:

; 593  : 
; 594  : 		PsysACTTotal += ((double)powerModel.gettRC() / (double)tRRDsch) * powerModel.getVoltageScaleFactor() * powerModel.getPdsACT();
; 595  : 
; 596  : 		// calculate PdsRD
; 597  : 		double RDschPct = k->getReadCycles() / (double)(time - powerModel.getLastCalculation());

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+352]
	mov	ecx, DWORD PTR [edi+12]
	sbb	ecx, DWORD PTR [edi+356]

; 598  : 
; 599  : 		PsysRD += powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() * powerModel.getPdsRD() * RDschPct;

	mov	DWORD PTR tv3323[esp+324], eax
	mov	DWORD PTR tv3323[esp+328], ecx
	fild	QWORD PTR tv3323[esp+324]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR _PsysRD$[esp+324]
	fstp	QWORD PTR _PsysRD$[esp+324]

; 600  : 
; 601  : 		// calculate PdsWR
; 602  : 		double WRschPct = k->getWriteCycles() / (double)(time - powerModel.getLastCalculation());

	test	ebx, ebx
	jne	$LN751@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN502@doPowerCal:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN493@doPowerCal
	call	__invalid_parameter_noinfo
$LN493@doPowerCal:

; 603  : 
; 604  : 		PsysWR += powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() * powerModel.getPdsWR() * WRschPct;

	mov	edx, DWORD PTR [edi+324]
	fild	DWORD PTR [edi+324]
	test	edx, edx
	jge	SHORT $LN774@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN774@doPowerCal:
	fmul	QWORD PTR [edi+256]
	mov	eax, DWORD PTR [esi+132]
	fmul	QWORD PTR [edi+264]
	fmul	QWORD PTR [edi+248]
	fild	DWORD PTR [esi+132]
	test	eax, eax
	jge	SHORT $LN775@doPowerCal
	fadd	QWORD PTR __real@41f0000000000000
$LN775@doPowerCal:

; 600  : 
; 601  : 		// calculate PdsWR
; 602  : 		double WRschPct = k->getWriteCycles() / (double)(time - powerModel.getLastCalculation());

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+352]
	mov	edx, DWORD PTR [edi+12]
	sbb	edx, DWORD PTR [edi+356]

; 603  : 
; 604  : 		PsysWR += powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() * powerModel.getPdsWR() * WRschPct;

	mov	DWORD PTR tv3308[esp+324], ecx
	mov	DWORD PTR tv3308[esp+328], edx
	fild	QWORD PTR tv3308[esp+324]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR _PsysWR$[esp+324]
	fstp	QWORD PTR _PsysWR$[esp+324]

; 605  : 
; 606  : 		k->resetPrechargeTime(time);

	test	ebx, ebx
	jne	SHORT $LN750@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN530@doPowerCal:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN521@doPowerCal
	call	__invalid_parameter_noinfo
$LN521@doPowerCal:
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+12]
	xor	edx, edx
	mov	DWORD PTR [esi+56], edx
	mov	DWORD PTR [esi+60], edx
	mov	DWORD PTR [esi+104], eax
	mov	DWORD PTR [esi+108], ecx

; 607  : 		k->resetCycleCounts();

	cmp	ebx, edx
	jne	SHORT $LN749@doPowerCal
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN548@doPowerCal:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN539@doPowerCal
	call	__invalid_parameter_noinfo
$LN539@doPowerCal:
	xor	eax, eax
	mov	DWORD PTR [esi+132], eax
	mov	DWORD PTR [esi+128], eax
	cmp	ebx, eax
	jne	SHORT $LN748@doPowerCal
	call	__invalid_parameter_noinfo
	xor	ebx, ebx
$LN57@doPowerCal:

; 540  : 
; 541  : 	for (vector<Rank>::iterator k = rank.begin(); k != rank.end(); k++)

	cmp	esi, DWORD PTR [ebx+16]
	jb	SHORT $LN48@doPowerCal
	call	__invalid_parameter_noinfo
$LN48@doPowerCal:
	mov	ebx, DWORD PTR _k$217473[esp+324]
	add	esi, 200				; 000000c8H
	mov	DWORD PTR _k$217473[esp+328], esi
	jmp	$LL50@doPowerCal
$LN752@doPowerCal:

; 593  : 
; 594  : 		PsysACTTotal += ((double)powerModel.gettRC() / (double)tRRDsch) * powerModel.getVoltageScaleFactor() * powerModel.getPdsACT();
; 595  : 
; 596  : 		// calculate PdsRD
; 597  : 		double RDschPct = k->getReadCycles() / (double)(time - powerModel.getLastCalculation());

	mov	eax, DWORD PTR [ebx]
	jmp	$LN474@doPowerCal
$LN751@doPowerCal:

; 600  : 
; 601  : 		// calculate PdsWR
; 602  : 		double WRschPct = k->getWriteCycles() / (double)(time - powerModel.getLastCalculation());

	mov	eax, DWORD PTR [ebx]
	jmp	$LN502@doPowerCal
$LN750@doPowerCal:

; 605  : 
; 606  : 		k->resetPrechargeTime(time);

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN530@doPowerCal
$LN749@doPowerCal:

; 607  : 		k->resetCycleCounts();

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN548@doPowerCal
$LN748@doPowerCal:

; 540  : 
; 541  : 	for (vector<Rank>::iterator k = rank.begin(); k != rank.end(); k++)

	mov	ebx, DWORD PTR [ebx]
	jmp	SHORT $LN57@doPowerCal
$LN5@doPowerCal:

; 608  : 	}
; 609  : 
; 610  : 	systemConfig.powerOutStream << "-Psys(ACT_STBY) ch[" << channelID << "] {" << setprecision(5) <<
; 611  : 		PsysACT_STBY << "} mW" << endl;

	mov	eax, DWORD PTR [edi+176]
	lea	ecx, DWORD PTR [eax+72]
	test	ecx, ecx
	je	SHORT $LN10@doPowerCal
	lea	ebx, DWORD PTR [eax+80]
	jmp	SHORT $LN11@doPowerCal
$LN10@doPowerCal:
	xor	ebx, ebx
$LN11@doPowerCal:
	lea	edx, DWORD PTR $T653345[esp+324]
	push	5
	push	edx
	call	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z ; std::setprecision
	add	esp, 8
	push	OFFSET ??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@
	push	ecx
	mov	esi, eax
	mov	eax, DWORD PTR [edi+360]
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BE@OKBLMJCG@?9Psys?$CIACT_STBY?$CJ?5ch?$FL?$AA@
	push	ebx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	je	SHORT $LN556@doPowerCal
$LN555@doPowerCal:
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, ebx
$LN556@doPowerCal:
	mov	edx, DWORD PTR [esi+4]
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi]
	call	eax
	fld	QWORD PTR _PsysACT_STBY$[esp+332]
	add	esp, 8
	push	OFFSET ??_C@_04CNFIBAEC@?$HN?5mW?$AA@
	sub	esp, 12					; 0000000cH
	fstp	QWORD PTR [esp]
	push	ebx
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+esi+8]
	lea	eax, DWORD PTR [edx+esi]
	xor	ebx, ebx
	test	cl, 6
	jne	SHORT $LN561@doPowerCal
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN561@doPowerCal
	mov	ebx, 4
$LN561@doPowerCal:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN577@doPowerCal
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN579@doPowerCal
	or	eax, 4
$LN579@doPowerCal:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN577@doPowerCal:

; 612  : 	//Pre(" << k->getPrechargeTime() << "/" << time - powerModel.getLastCalculation() << ")" << endl;
; 613  : 
; 614  : 	systemConfig.powerOutStream << "-Psys(ACT) ch[" << channelID << "] {"<< setprecision(5) <<
; 615  : 		PsysACT << "} mW tRRD[" << tRRDsch << "]" << endl;

	mov	eax, DWORD PTR [edi+176]
	lea	edx, DWORD PTR [eax+72]
	test	edx, edx
	je	SHORT $LN12@doPowerCal
	lea	esi, DWORD PTR [eax+80]
	jmp	SHORT $LN13@doPowerCal
$LN12@doPowerCal:
	xor	esi, esi
$LN13@doPowerCal:
	lea	eax, DWORD PTR $T653348[esp+324]
	push	5
	push	eax
	call	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z ; std::setprecision
	add	esp, 8
	push	OFFSET ??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@
	push	ecx
	mov	ecx, DWORD PTR [edi+360]
	push	ecx
	push	ecx
	push	OFFSET ??_C@_0P@JAGAIFBA@?9Psys?$CIACT?$CJ?5ch?$FL?$AA@
	push	esi
	mov	ebx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	je	SHORT $LN584@doPowerCal
$LN583@doPowerCal:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
$LN584@doPowerCal:
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	eax
	call	edx
	fld	DWORD PTR _tRRDsch$[esp+332]
	add	esp, 8
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+4]
	push	OFFSET ??_C@_0L@EOFJECFB@?$HN?5mW?5tRRD?$FL?$AA@
	fld	QWORD PTR _PsysACT$[esp+344]
	sub	esp, 12					; 0000000cH
	fstp	QWORD PTR [esp]
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN589@doPowerCal
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN589@doPowerCal
	mov	ebx, 4
$LN589@doPowerCal:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN605@doPowerCal
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN607@doPowerCal
	or	eax, 4
$LN607@doPowerCal:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN605@doPowerCal:

; 616  : 
; 617  : 	systemConfig.powerOutStream << "-Psys(PRE_STBY) ch[" << channelID << "] {" << setprecision(5) <<
; 618  : 		PsysPRE_STBY << "} mW" << endl;

	mov	eax, DWORD PTR [edi+176]
	lea	edx, DWORD PTR [eax+72]
	test	edx, edx
	je	SHORT $LN14@doPowerCal
	lea	esi, DWORD PTR [eax+80]
	jmp	SHORT $LN15@doPowerCal
$LN14@doPowerCal:
	xor	esi, esi
$LN15@doPowerCal:
	lea	eax, DWORD PTR $T653351[esp+324]
	push	5
	push	eax
	call	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z ; std::setprecision
	add	esp, 8
	push	OFFSET ??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@
	push	ecx
	mov	ecx, DWORD PTR [edi+360]
	push	ecx
	push	ecx
	push	OFFSET ??_C@_0BE@OPIKMKPA@?9Psys?$CIPRE_STBY?$CJ?5ch?$FL?$AA@
	push	esi
	mov	ebx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	je	SHORT $LN612@doPowerCal
$LN611@doPowerCal:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
$LN612@doPowerCal:
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	eax
	call	edx
	fld	QWORD PTR _PsysPRE_STBY$[esp+332]
	add	esp, 8
	push	OFFSET ??_C@_04CNFIBAEC@?$HN?5mW?$AA@
	sub	esp, 12					; 0000000cH
	fstp	QWORD PTR [esp]
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN617@doPowerCal
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN617@doPowerCal
	mov	ebx, 4
$LN617@doPowerCal:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN633@doPowerCal
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN635@doPowerCal
	or	eax, 4
$LN635@doPowerCal:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN633@doPowerCal:

; 619  : 	//Pre(" << k->getPrechargeTime() << "/" << time - powerModel.getLastCalculation() << ")" << endl;
; 620  : 
; 621  : 	systemConfig.powerOutStream << "-Psys(RD) ch[" << channelID << "] {" << setprecision(5) << PsysRD << "} mW" << endl;

	mov	eax, DWORD PTR [edi+176]
	lea	edx, DWORD PTR [eax+72]
	test	edx, edx
	je	SHORT $LN16@doPowerCal
	lea	esi, DWORD PTR [eax+80]
	jmp	SHORT $LN17@doPowerCal
$LN16@doPowerCal:
	xor	esi, esi
$LN17@doPowerCal:
	lea	eax, DWORD PTR $T653354[esp+324]
	push	5
	push	eax
	call	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z ; std::setprecision
	add	esp, 8
	push	OFFSET ??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@
	push	ecx
	mov	ecx, DWORD PTR [edi+360]
	push	ecx
	push	ecx
	push	OFFSET ??_C@_0O@NPIBAAFJ@?9Psys?$CIRD?$CJ?5ch?$FL?$AA@
	push	esi
	mov	ebx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	je	SHORT $LN640@doPowerCal
$LN639@doPowerCal:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
$LN640@doPowerCal:
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	eax
	call	edx
	fld	QWORD PTR _PsysRD$[esp+332]
	add	esp, 8
	push	OFFSET ??_C@_04CNFIBAEC@?$HN?5mW?$AA@
	sub	esp, 12					; 0000000cH
	fstp	QWORD PTR [esp]
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN645@doPowerCal
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN645@doPowerCal
	mov	ebx, 4
$LN645@doPowerCal:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	ebx, ebx
	je	SHORT $LN661@doPowerCal
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN663@doPowerCal
	or	eax, 4
$LN663@doPowerCal:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN661@doPowerCal:

; 622  : 
; 623  : 	systemConfig.powerOutStream << "-Psys(WR) ch[" << channelID << "] {" << setprecision(5) << PsysWR << "} mW" << endl;

	mov	eax, DWORD PTR [edi+176]
	lea	edx, DWORD PTR [eax+72]
	test	edx, edx
	je	SHORT $LN18@doPowerCal
	lea	esi, DWORD PTR [eax+80]
	jmp	SHORT $LN19@doPowerCal
$LN18@doPowerCal:
	xor	esi, esi
$LN19@doPowerCal:
	lea	eax, DWORD PTR $T653357[esp+324]
	push	5
	push	eax
	call	?setprecision@std@@YA?AU?$_Smanip@H@1@H@Z ; std::setprecision
	add	esp, 8
	push	OFFSET ??_C@_03BDFKBBEB@?$FN?5?$HL?$AA@
	push	ecx
	mov	ecx, DWORD PTR [edi+360]
	push	ecx
	push	ecx
	push	OFFSET ??_C@_0O@JDGPKHMJ@?9Psys?$CIWR?$CJ?5ch?$FL?$AA@
	push	esi
	mov	ebx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	je	SHORT $LN668@doPowerCal
$LN667@doPowerCal:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
$LN668@doPowerCal:
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	eax
	call	edx
	fld	QWORD PTR _PsysWR$[esp+332]
	add	esp, 8
	push	OFFSET ??_C@_04CNFIBAEC@?$HN?5mW?$AA@
	sub	esp, 12					; 0000000cH
	fstp	QWORD PTR [esp]
	push	esi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	add	esp, 4
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+esi]
	xor	ebx, ebx
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN673@doPowerCal
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN673@doPowerCal
	lea	ebx, DWORD PTR [eax+5]
$LN673@doPowerCal:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	xor	esi, esi
	cmp	ebx, esi
	je	SHORT $LN689@doPowerCal
	mov	eax, DWORD PTR [ecx+8]
	or	eax, ebx
	cmp	DWORD PTR [ecx+40], esi
	jne	SHORT $LN691@doPowerCal
	or	eax, 4
$LN691@doPowerCal:
	push	esi
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN689@doPowerCal:

; 624  : 
; 625  : 	// report these results
; 626  : 	if (dbReporting)

	cmp	BYTE PTR [edi+364], 0
	je	$LN1@doPowerCal

; 627  : 	{
; 628  : 		boost::thread(boost::bind(&DRAMsimII::Channel::sendPower,this,PsysRD, PsysWR, rankArray, PsysACTSTBYArray, PsysACTArray, systemTime));

	sub	esp, 112				; 00000070H
	mov	DWORD PTR $T653361[esp+436], esp
	mov	ebx, esp
	sub	esp, 24					; 00000018H
	mov	edx, esp
	mov	DWORD PTR $T653362[esp+460], esp
	lea	eax, DWORD PTR _PsysACTArray$[esp+460]
	push	eax
	push	edx
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+492], 3
	mov	ecx, esp
	mov	DWORD PTR $T653363[esp+484], esp
	lea	edx, DWORD PTR _PsysACTSTBYArray$[esp+484]
	push	edx
	push	ecx
	call	??0?$vector@NV?$allocator@N@std@@@std@@QAE@ABV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
	sub	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+516], 4
	mov	eax, esp
	mov	DWORD PTR $T653364[esp+508], esp
	lea	ecx, DWORD PTR _rankArray$[esp+508]
	push	ecx
	push	eax
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	fld	QWORD PTR _PsysWR$[esp+508]
	mov	edx, DWORD PTR _systemTime$[ebp+4]
	mov	eax, DWORD PTR _systemTime$[ebp]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	mov	BYTE PTR __$EHRec$[esp+532], 2
	fld	QWORD PTR _PsysRD$[esp+524]
	fstp	QWORD PTR [esp]
	push	edx
	push	eax
	push	edi
	push	ebx
	call	??$bind@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_JPAV12@NNV34@V54@V54@_J@boost@@YA?AV?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@0@P8Channel@DRAMsimII@@BE_NNNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@6@1_J@ZPAV34@NN0112@Z ; boost::bind<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64,DRAMsimII::Channel *,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>
	add	esp, 104				; 00000068H
	lea	ecx, DWORD PTR $T653360[esp+436]
	push	ecx
	call	??$?0V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@boost@@@thread@boost@@QAE@V?$bind_t@_NV?$cmf6@_NVChannel@DRAMsimII@@NNV?$vector@HV?$allocator@H@std@@@std@@V?$vector@NV?$allocator@N@std@@@4@V54@_J@_mfi@boost@@V?$list7@V?$value@PAVChannel@DRAMsimII@@@_bi@boost@@V?$value@N@23@V423@V?$value@V?$vector@HV?$allocator@H@std@@@std@@@23@V?$value@V?$vector@NV?$allocator@N@std@@@std@@@23@V623@V?$value@_J@23@@_bi@3@@_bi@1@PAUdummy@01@@Z ; boost::thread::thread<boost::_bi::bind_t<bool,boost::_mfi::cmf6<bool,DRAMsimII::Channel,double,double,std::vector<int,std::allocator<int> >,std::vector<double,std::allocator<double> >,std::vector<double,std::allocator<double> >,__int64>,boost::_bi::list7<boost::_bi::value<DRAMsimII::Channel *>,boost::_bi::value<double>,boost::_bi::value<double>,boost::_bi::value<std::vector<int,std::allocator<int> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<std::vector<double,std::allocator<double> > >,boost::_bi::value<__int64> > > >
	lea	ecx, DWORD PTR $T653360[esp+324]
	call	??1thread@boost@@QAE@XZ			; boost::thread::~thread
$LN1@doPowerCal:

; 629  : 	}
; 630  : 
; 631  : 	// no total power calcs for now
; 632  : #if 0
; 633  : 	powerOutStream << "++++++++++++++++++++++ total ++++++++++++++++++++++" << endl;
; 634  : 
; 635  : 	PsysACTTotal = 0;
; 636  : 
; 637  : 	for (vector<Rank>::const_iterator k = rank.begin(); k != rank.end(); k++)
; 638  : 	{
; 639  : 		unsigned perRankRASCount = 1;
; 640  : 
; 641  : 		for (vector<Bank>::const_iterator l = k->bank.begin(); l != k->bank.end(); l++)
; 642  : 		{
; 643  : 			entireRAS += l->getTotalRASCount();
; 644  : 			entireCAS += l->getTotalCASCount();
; 645  : 			entireCASW += l->getTotalCASWCount();
; 646  : 			perRankRASCount += l->getTotalRASCount();
; 647  : 		}
; 648  : 
; 649  : 		float percentActive = 1.0F - (double)(k->getTotalPrechargeTime())/(double)time;
; 650  : 
; 651  : 		powerOutStream << "+Psys(ACT_STBY) ch[" << channelID << "] r[" << k->getRankID() << "] {" << setprecision(5) <<
; 652  : 			powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() * powerModel.getIDD3N() * powerModel.getVDDmax() * percentActive << "} mW P(" << k->getTotalPrechargeTime() << "/" << time  << ")" << endl;
; 653  : 
; 654  : 		float tRRDsch = ((double)time) / perRankRASCount;
; 655  : 
; 656  : 		powerOutStream << "+Psys(ACT) ch[" << channelID << "] r[" << k->getRankID() << "] {"<< setprecision(5) <<
; 657  : 			powerModel.getDevicesPerRank() * ((double)powerModel.gettRC() / (double)tRRDsch) * powerModel.getVoltageScaleFactor() * powerModel.getPdsACT() << "} mW" << endl;
; 658  : 
; 659  : 		PsysACTTotal += powerModel.getDevicesPerRank() * ((double)powerModel.gettRC() / (double)tRRDsch) * powerModel.getVoltageScaleFactor() * powerModel.getPdsACT();
; 660  : 	}
; 661  : 
; 662  : 	double RDschPct = entireCAS * timingSpecification.tBurst() / (double)(time);
; 663  : 	double WRschPct = entireCAS * timingSpecification.tBurst() / (double)(time);
; 664  : 
; 665  : 	//cerr << RDschPct * 100 << "%\t" << WRschPct * 100 << "%"<< endl;
; 666  : 
; 667  : 	powerOutStream << "+Psys(ACT) ch[" << channelID << "] " << setprecision(5) <<
; 668  : 		PsysACTTotal << " mW" << endl;
; 669  : 
; 670  : 	powerOutStream << "+Psys(RD) ch[" << channelID << "] {" << setprecision(5) <<
; 671  : 		powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() * (powerModel.getIDD4R() - powerModel.getIDD3N()) * RDschPct << "} mW" << endl;
; 672  : 
; 673  : 	powerOutStream << "+Psys(WR) ch[" << channelID << "] {" << setprecision(5) <<
; 674  : 		powerModel.getDevicesPerRank() * powerModel.getVoltageScaleFactor() * powerModel.getFrequencyScaleFactor() * (powerModel.getIDD4W() - powerModel.getIDD3N()) * WRschPct << "} mW" << endl;
; 675  : #endif
; 676  : 	powerModel.setLastCalculation(time);

	mov	eax, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+356], eax

; 677  : }

	mov	eax, DWORD PTR _PsysACTArray$[esp+336]
	mov	DWORD PTR [edi+352], edx
	cmp	eax, esi
	je	SHORT $LN700@doPowerCal
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN700@doPowerCal:
	mov	ecx, DWORD PTR _PsysACTArray$[esp+324]
	push	ecx
	mov	DWORD PTR _PsysACTArray$[esp+340], esi
	mov	DWORD PTR _PsysACTArray$[esp+344], esi
	mov	DWORD PTR _PsysACTArray$[esp+348], esi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _PsysACTSTBYArray$[esp+340]
	add	esp, 4
	cmp	eax, esi
	je	SHORT $LN715@doPowerCal
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN715@doPowerCal:
	mov	edx, DWORD PTR _PsysACTSTBYArray$[esp+324]
	push	edx
	mov	DWORD PTR _PsysACTSTBYArray$[esp+340], esi
	mov	DWORD PTR _PsysACTSTBYArray$[esp+344], esi
	mov	DWORD PTR _PsysACTSTBYArray$[esp+348], esi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR _rankArray$[esp+340]
	add	esp, 4
	cmp	eax, esi
	je	SHORT $LN730@doPowerCal
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN730@doPowerCal:
	mov	eax, DWORD PTR _rankArray$[esp+324]
	push	eax
	mov	DWORD PTR _rankArray$[esp+340], esi
	mov	DWORD PTR _rankArray$[esp+344], esi
	mov	DWORD PTR _rankArray$[esp+348], esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	ecx, DWORD PTR __$EHRec$[esp+324]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z$0:
	lea	ecx, DWORD PTR _rankArray$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z$1:
	lea	esi, DWORD PTR _PsysACTSTBYArray$[ebp]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z$2:
	lea	esi, DWORD PTR _PsysACTArray$[ebp]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z$3:
	mov	esi, DWORD PTR $T653362[ebp]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z$4:
	mov	esi, DWORD PTR $T653363[ebp]
	jmp	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__ehhandler$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-308]
	mov	ecx, DWORD PTR [edx-312]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z
	jmp	___CxxFrameHandler3
?doPowerCalculation@Channel@DRAMsimII@@QAEX_J@Z ENDP	; DRAMsimII::Channel::doPowerCalculation
PUBLIC	??0Channel@DRAMsimII@@QAE@ABV01@@Z		; DRAMsimII::Channel::Channel
__unwindtable$??0Channel@DRAMsimII@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$3
	DD	04H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$4
__ehfuncinfo$??0Channel@DRAMsimII@@QAE@ABV01@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0Channel@DRAMsimII@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T656373 = -216						; size = 200
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_rhs$ = 12						; size = 4
??0Channel@DRAMsimII@@QAE@ABV01@@Z PROC			; DRAMsimII::Channel::Channel

; 150  : {

	push	-1
	push	__ehhandler$??0Channel@DRAMsimII@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+236]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _rhs$[esp+232]
	mov	ebx, DWORD PTR _this$[esp+232]
	mov	DWORD PTR [ebx], OFFSET ??_7Channel@DRAMsimII@@6B@
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebx+8], eax
	mov	ecx, DWORD PTR [ebp+12]
	mov	DWORD PTR [ebx+12], ecx
	mov	edx, DWORD PTR [ebp+16]
	mov	DWORD PTR [ebx+16], edx
	mov	eax, DWORD PTR [ebp+20]
	mov	DWORD PTR [ebx+20], eax
	mov	ecx, DWORD PTR [ebp+24]
	lea	edx, DWORD PTR [ebp+112]
	mov	DWORD PTR [ebx+24], ecx
	push	edx
	lea	eax, DWORD PTR [ebx+112]
	lea	edi, DWORD PTR [ebx+28]
	lea	esi, DWORD PTR [ebp+28]
	mov	ecx, 21					; 00000015H
	push	eax
	rep movsd
	call	??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
	lea	ecx, DWORD PTR [ebp+152]
	push	ecx
	lea	edx, DWORD PTR [ebx+152]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+252], 0
	call	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
	mov	BYTE PTR __$EHRec$[esp+244], 1
	mov	eax, DWORD PTR [ebp+176]
	mov	DWORD PTR [ebx+176], eax
	mov	ecx, DWORD PTR [ebp+180]
	mov	DWORD PTR [ebx+180], ecx
	lea	esi, DWORD PTR [ebp+184]
	lea	edi, DWORD PTR [ebx+184]
	mov	ecx, 44					; 0000002cH
	rep movsd
	mov	edx, DWORD PTR [ebp+360]
	mov	DWORD PTR [ebx+360], edx
	mov	al, BYTE PTR [ebp+364]
	mov	BYTE PTR [ebx+364], al
	mov	ecx, DWORD PTR [ebp+384]
	sub	ecx, DWORD PTR [ebp+380]
	add	ebp, 368				; 00000170H
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	jne	SHORT $LN8@Channel@3
	call	__invalid_parameter_noinfo
$LN8@Channel@3:
	mov	eax, DWORD PTR [ebx+176]
	mov	edx, DWORD PTR [ebp+12]
	push	eax
	lea	ecx, DWORD PTR $T656373[esp+240]
	push	ecx
	lea	ecx, DWORD PTR [ebx+28]
	call	??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ; DRAMsimII::Rank::Rank
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[esp+244], 2
	mov	ecx, DWORD PTR [ebp+16]
	sub	ecx, DWORD PTR [ebp+12]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	push	edi
	add	eax, edx
	push	eax
	lea	esi, DWORD PTR [ebx+368]
	push	esi
	call	??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	lea	edx, DWORD PTR $T656373[esp+236]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+248], 4
	call	??1Rank@DRAMsimII@@QAE@XZ
	push	4
	lea	edi, DWORD PTR [ebx+392]
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN35@Channel@3
	mov	DWORD PTR [eax], edi
	jmp	SHORT $LN36@Channel@3
$LN35@Channel@3:
	xor	eax, eax
$LN36@Channel@3:
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+16], ecx
	mov	DWORD PTR [edi+20], ecx
	mov	DWORD PTR [edi+24], ecx
	mov	DWORD PTR [edi+28], ecx

; 151  : 	// TODO: copy over values incomingTransaction ranks now that reference members are init
; 152  : 	// assign an id to each channel (normally done with commands)
; 153  : 	rank = rhs.rank;

	push	ebp
	mov	BYTE PTR __$EHRec$[esp+248], 5
	call	??4?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator=

; 154  : }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+236]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 216				; 000000d8H
	ret	8
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 112				; 00000070H
	push	eax
	call	??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$1:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 152				; 00000098H
	jmp	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$2:
	lea	eax, DWORD PTR $T656373[ebp]
	push	eax
	call	??1Rank@DRAMsimII@@QAE@XZ
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$3:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 368				; 00000170H
	push	eax
	call	??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@@Z$4:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 392				; 00000188H
	jmp	??1?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ
__ehhandler$??0Channel@DRAMsimII@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-220]
	mov	ecx, DWORD PTR [edx-224]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Channel@DRAMsimII@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
??0Channel@DRAMsimII@@QAE@ABV01@@Z ENDP			; DRAMsimII::Channel::Channel
PUBLIC	??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z ; DRAMsimII::Channel::Channel
__unwindtable$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z$2
__ehfuncinfo$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_settings$ = 12						; size = 4
_sysConf$ = 16						; size = 4
_stats$ = 20						; size = 4
_power$ = 24						; size = 4
_newRank$ = 28						; size = 4
??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z PROC ; DRAMsimII::Channel::Channel
; _timing$ = edx

; 129  : {}

	push	-1
	push	__ehhandler$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR _this$[esp+28]
	xor	ebp, ebp
	mov	esi, edx
	mov	DWORD PTR [ebx], OFFSET ??_7Channel@DRAMsimII@@6B@
	mov	DWORD PTR [ebx+8], ebp
	mov	DWORD PTR [ebx+12], ebp
	mov	DWORD PTR [ebx+16], ebp
	mov	DWORD PTR [ebx+20], ebp
	mov	DWORD PTR [ebx+24], ebp
	lea	edi, DWORD PTR [ebx+28]
	mov	ecx, 21					; 00000015H
	push	ebp
	lea	eax, DWORD PTR [ebx+112]
	rep movsd
	push	eax
	xor	ecx, ecx
	call	??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@I_N@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
	lea	ecx, DWORD PTR [ebx+152]
	push	ecx
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+44], ebp
	call	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@I@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
	mov	edx, DWORD PTR _sysConf$[esp+28]
	mov	eax, DWORD PTR _stats$[esp+28]
	mov	esi, DWORD PTR _power$[esp+28]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [ebx+180], eax
	mov	eax, DWORD PTR _newRank$[esp+28]
	mov	DWORD PTR [ebx+176], edx
	lea	edi, DWORD PTR [ebx+184]
	mov	ecx, 44					; 0000002cH
	rep movsd
	mov	ecx, DWORD PTR _settings$[esp+28]
	mov	DWORD PTR [ebx+360], -1
	mov	dl, BYTE PTR [ecx+291]
	push	eax
	lea	ecx, DWORD PTR [ebx+368]
	push	ecx
	mov	BYTE PTR [ebx+364], dl
	call	??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@ABV01@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	push	4
	mov	BYTE PTR __$EHRec$[esp+44], 2
	lea	esi, DWORD PTR [ebx+392]
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebp
	je	SHORT $LN27@Channel@4
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN28@Channel@4
$LN27@Channel@4:
	xor	eax, eax
$LN28@Channel@4:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebp
	mov	DWORD PTR [esi+24], ebp
	mov	DWORD PTR [esi+28], ebp
	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	24					; 00000018H
__unwindfunclet$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 112				; 00000070H
	push	eax
	call	??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z$1:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 152				; 00000098H
	jmp	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
__unwindfunclet$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z$2:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 368				; 00000170H
	push	eax
	call	??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	ret	0
__ehhandler$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z
	jmp	___CxxFrameHandler3
??0Channel@DRAMsimII@@AAE@ABVSettings@1@ABVSystemConfiguration@1@AAVStatistics@1@ABVPowerConfig@1@ABV?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@ABVTimingSpecification@1@@Z ENDP ; DRAMsimII::Channel::Channel
PUBLIC	??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z ; DRAMsimII::Channel::Channel
__unwindtable$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$4
	DD	05H
	DD	FLAT:__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$5
__ehfuncinfo$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T656928 = -216						; size = 4
$T656933 = -212						; size = 200
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_rhs$ = 12						; size = 4
_systemConfig$ = 16					; size = 4
_stats$ = 20						; size = 4
??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z PROC ; DRAMsimII::Channel::Channel

; 106  : {

	push	-1
	push	__ehhandler$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+236]
	mov	DWORD PTR fs:0, eax
	mov	ebp, DWORD PTR _rhs$[esp+232]
	mov	ebx, DWORD PTR _this$[esp+232]
	mov	DWORD PTR [ebx], OFFSET ??_7Channel@DRAMsimII@@6B@
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebx+8], eax
	mov	ecx, DWORD PTR [ebp+12]
	mov	DWORD PTR [ebx+12], ecx
	mov	edx, DWORD PTR [ebp+16]
	mov	DWORD PTR [ebx+16], edx
	mov	eax, DWORD PTR [ebp+20]
	mov	DWORD PTR [ebx+20], eax
	cmp	DWORD PTR [ebp+24], 0
	je	SHORT $LN5@Channel@5
	call	?acquireItem@?$Queue@VCommand@DRAMsimII@@@DRAMsimII@@QAEPAVCommand@2@XZ ; DRAMsimII::Queue<DRAMsimII::Command>::acquireItem
	mov	DWORD PTR $T656928[esp+236], eax
	mov	DWORD PTR __$EHRec$[esp+244], 0
	test	eax, eax
	je	SHORT $LN3@Channel@5
	mov	ecx, DWORD PTR [ebp+24]
	push	ecx
	push	eax
	call	??0Command@DRAMsimII@@QAE@ABV01@@Z	; DRAMsimII::Command::Command
	mov	DWORD PTR __$EHRec$[esp+244], -1
	jmp	SHORT $LN6@Channel@5
$LN3@Channel@5:
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+244], -1
	jmp	SHORT $LN6@Channel@5
$LN5@Channel@5:
	xor	eax, eax
$LN6@Channel@5:
	mov	DWORD PTR [ebx+24], eax
	lea	edx, DWORD PTR [ebp+112]
	push	edx
	lea	eax, DWORD PTR [ebx+112]
	lea	edi, DWORD PTR [ebx+28]
	lea	esi, DWORD PTR [ebp+28]
	mov	ecx, 21					; 00000015H
	push	eax
	rep movsd
	call	??0?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@ABV01@@Z ; DRAMsimII::Queue<DRAMsimII::Transaction>::Queue<DRAMsimII::Transaction>
	lea	ecx, DWORD PTR [ebp+152]
	push	ecx
	lea	edx, DWORD PTR [ebx+152]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+252], 1
	call	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@ABV01@@Z ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
	mov	ecx, DWORD PTR _stats$[esp+232]
	mov	eax, DWORD PTR _systemConfig$[esp+232]
	mov	BYTE PTR __$EHRec$[esp+244], 2
	mov	DWORD PTR [ebx+180], ecx
	mov	DWORD PTR [ebx+176], eax
	lea	esi, DWORD PTR [ebp+184]
	lea	edi, DWORD PTR [ebx+184]
	mov	ecx, 44					; 0000002cH
	rep movsd
	mov	edx, DWORD PTR [ebp+360]
	mov	DWORD PTR [ebx+360], edx
	mov	al, BYTE PTR [ebp+364]
	mov	BYTE PTR [ebx+364], al
	mov	ecx, DWORD PTR [ebp+384]
	sub	ecx, DWORD PTR [ebp+380]
	add	ebp, 368				; 00000170H
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	jne	SHORT $LN15@Channel@5
	call	__invalid_parameter_noinfo
$LN15@Channel@5:
	mov	esi, DWORD PTR _systemConfig$[esp+232]
	mov	edx, DWORD PTR [ebp+12]
	push	esi
	lea	eax, DWORD PTR $T656933[esp+240]
	push	eax
	lea	ecx, DWORD PTR [ebx+28]
	call	??0Rank@DRAMsimII@@QAE@ABV01@ABVTimingSpecification@1@ABVSystemConfiguration@1@@Z ; DRAMsimII::Rank::Rank
	mov	BYTE PTR __$EHRec$[esp+244], 3
	mov	ecx, DWORD PTR [esi+360]
	push	eax
	push	ecx
	lea	esi, DWORD PTR [ebx+368]
	push	esi
	call	??0?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@IABVRank@DRAMsimII@@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	lea	ecx, DWORD PTR $T656933[esp+236]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+248], 5
	call	??1Rank@DRAMsimII@@QAE@XZ
	push	4
	lea	edi, DWORD PTR [ebx+392]
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN42@Channel@5
	mov	DWORD PTR [eax], edi
	jmp	SHORT $LN43@Channel@5
$LN42@Channel@5:
	xor	eax, eax
$LN43@Channel@5:
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+16], ecx
	mov	DWORD PTR [edi+20], ecx
	mov	DWORD PTR [edi+24], ecx
	mov	DWORD PTR [edi+28], ecx

; 107  : 	// to fill incomingTransaction the values
; 108  : 	rank = rhs.rank;

	push	ebp
	mov	BYTE PTR __$EHRec$[esp+248], 6
	call	??4?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::operator=

; 109  : }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+236]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 216				; 000000d8H
	ret	16					; 00000010H
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$0:
	mov	esi, DWORD PTR $T656928[ebp]
	jmp	??3Command@DRAMsimII@@SAXPAX@Z		; DRAMsimII::Command::operator delete
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$1:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 112				; 00000070H
	push	eax
	call	??1?$Queue@VTransaction@DRAMsimII@@@DRAMsimII@@QAE@XZ ; DRAMsimII::Queue<DRAMsimII::Transaction>::~Queue<DRAMsimII::Transaction>
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$2:
	mov	esi, DWORD PTR _this$[ebp-4]
	add	esi, 152				; 00000098H
	jmp	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$3:
	lea	eax, DWORD PTR $T656933[ebp]
	push	eax
	call	??1Rank@DRAMsimII@@QAE@XZ
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$4:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 368				; 00000170H
	push	eax
	call	??1?$vector@VRank@DRAMsimII@@V?$allocator@VRank@DRAMsimII@@@std@@@std@@QAE@XZ ; std::vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >::~vector<DRAMsimII::Rank,std::allocator<DRAMsimII::Rank> >
	ret	0
__unwindfunclet$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z$5:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 392				; 00000188H
	jmp	??1?$queue@U?$pair@I_J@std@@V?$deque@U?$pair@I_J@std@@V?$allocator@U?$pair@I_J@std@@@2@@2@@std@@QAE@XZ
__ehhandler$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-220]
	mov	ecx, DWORD PTR [edx-224]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z
	jmp	___CxxFrameHandler3
??0Channel@DRAMsimII@@QAE@ABV01@ABVSystemConfiguration@1@AAVStatistics@1@@Z ENDP ; DRAMsimII::Channel::Channel
; Function compile flags: /Ogtpy
;	COMDAT ??__FnewRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ@YAXXZ
text$yd	SEGMENT
??__FnewRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ@YAXXZ PROC ; `DRAMsimII::Channel::readNextRefresh'::`7'::`dynamic atexit destructor for 'newRefreshTransaction'', COMDAT
	mov	DWORD PTR ?newRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@3@XZ@4V43@A, OFFSET ??_7Event@DRAMsimII@@6B@
	ret	0
??__FnewRefreshTransaction@?6??readNextRefresh@Channel@DRAMsimII@@IBEPBVTransaction@2@XZ@YAXXZ ENDP ; `DRAMsimII::Channel::readNextRefresh'::`7'::`dynamic atexit destructor for 'newRefreshTransaction''
__6	DB	01H DUP (?)
	ALIGN	4

__3	DB	01H DUP (?)
	ALIGN	4

__4	DB	01H DUP (?)
	ALIGN	4

__1	DB	01H DUP (?)
	ALIGN	4

__8	DB	01H DUP (?)
	ALIGN	4

__5	DB	01H DUP (?)
	ALIGN	4

__7	DB	01H DUP (?)
	ALIGN	4

__2	DB	01H DUP (?)
	ALIGN	4

__9	DB	01H DUP (?)
END
